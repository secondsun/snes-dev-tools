; Main file for Oracle of Ages, US version

.include "include/rominfo.s"
.include "include/emptyfill.s"
.include "include/constants.s"
.include "include/structs.s"
.include "include/wram.s"
.include "include/hram.s"
.include "include/macros.s"
.include "include/script_commands.s"
.include "include/simplescript_commands.s"
.include "include/movementscript_commands.s"

.include "objects/macros.s"
.include "include/gfxDataMacros.s"

.include "build/textDefines.s"


.BANK $00 SLOT 0

.ORGA $0000
; rst_jumpTable
	add a			; $0000
	pop hl			; $0001
	add l			; $0002
	ld l,a			; $0003
	jr nc,+			; $0004
	inc h			; $0006
+
	ldi a,(hl)		; $0007
	ld h,(hl)		; $0008
	ld l,a			; $0009
	jp hl			; $000a

.ORGA $0010
; rst_addAToHl
	add l			; $0010
	ld l,a			; $0011
	ret nc			; $0012
	inc h			; $0013
	ret			; $0014

.ORGA $0018
; rst_addDoubleIndex
	push bc			; $0018
	ld c,a			; $0019
	ld b,$00		; $001a
	add hl,bc		; $001c
	add hl,bc		; $001d
	pop bc			; $001e
	ret			; $001f

.ORGA $0038
; Not used as rst $38
	nop			; $0038
	nop			; $0039
	nop			; $003a
	pop hl			; $003b
	pop de			; $003c
	pop bc			; $003d
	pop af			; $003e
	reti			; $003f

.ORGA $0040
; VBlank interrupt
	push af			; $0040
	push bc			; $0041
	push de			; $0042
	push hl			; $0043
	jp vblankInterrupt

.ORGA $0048
; LCD interrupt
	push af			; $0048
	push hl			; $0049
	jp lcdInterrupt

.ORGA $0050
; Timer interrupt
	ei			; $0050
	push af			; $0051
	push bc			; $0052
	push de			; $0053
	push hl			; $0054
	jp timerInterrupt

.ORGA $0058
; Serial interrupt
	push af			; $0058
	jp serialInterrupt

.ORGA $0060
; Joypad interrupt
	reti			; $0060

; Put the nops here explicitly so the next section can't start until $0068

	nop
	nop
	nop
	nop
	nop
	nop
	nop


.ORGA $0068

.SECTION "Bank 0 Early Functions"

;;
; @param a
; @param de
; @addr{0068}
addAToDe:
	add e			; $0068
	ld e,a			; $0069
	ret nc			; $006a
	inc d			; $006b
	ret			; $006c

;;
; @param a
; @param bc
; @addr{006d}
addAToBc:
	add c			; $006d
	ld c,a			; $006e
	ret nc			; $006f
	inc b			; $0070
	ret			; $0071

;;
; Adds a*2 to de.
; @param a
; @param de
; @addr{0072}
addDoubleIndexToDe:
	push hl			; $0072
	add a			; $0073
	ld l,a			; $0074
	ld a,$00		; $0075
	adc a			; $0077
	ld h,a			; $0078
	add hl,de		; $0079
	ld e,l			; $007a
	ld d,h			; $007b
	pop hl			; $007c
	ret			; $007d

;;
; Adds a*2 to bc.
; @param a
; @param bc
; @addr{007e}
addDoubleIndexToBc:
	push hl			; $007e
	add a			; $007f
	ld l,a			; $0080
	ld a,$00		; $0081
	adc a			; $0083
	ld h,a			; $0084
	add hl,bc		; $0085
	ld c,l			; $0086
	ld b,h			; $0087
	pop hl			; $0088
	ret			; $0089

;;
; Call a function in any bank, from any bank.
; @param e Bank of the function to call
; @param hl Address of the function to call
; @addr{008a}
interBankCall:
	ld a,($ff97)		; $008a
	push af			; $008d
	ld a,e			; $008e
	ld ($ff97),a		; $008f
	ld ($2222),a		; $0092
	call jpHl		; $0095
	pop af			; $0098
	ld ($ff97),a		; $0099
	ld ($2222),a		; $009c
	ret			; $009f

;;
; Jump to hl.
; @param hl Address to jump to.
; @addr{00a0}
jpHl:
	jp hl			; $00a0


; Symbol list for secrets:
;	BDFGHJLM♠♥♦♣#
;	NQRSTWY!●▲■+-
;	bdfghj m$*/:~
;	nqrstwy?%&<=>
;	23456789↑↓←→@
; @addr{00a1}
secretSymbols:
	.asc "BDFGHJLM"
	.db $13 $bd $12 $11 $23
	.asc "NQRSTWY!"
	.db $10 $7e $7f $2b $2d
	.asc "bdfghjm$*/:~"
	.asc "nqrstwy?%&<=>"
	.asc "23456789"
	.db $15 $16 $17 $18 $40

	.db $00 ; Null terminator

; Filler?
	.DB         $00 $00 $00 $00 $00 $ff	; $00e2
	.DB $00 $00 $00 $00 $00 $00 $00 $00	; $00e8
	.DB $00 $00 $00 $00 $00 $00 $00 $00	; $00f0

;;;
bitTable:
	.db $01 $02 $04 $08 $10 $20 $40 $80	; $00f8

; Entry point
	nop			; $0100
	jp begin

.ENDS


; ROM title / manufacturer code
.ORGA $134

.ifdef ROM_SEASONS
	.asc "ZELDA DIN" 0 0
	.asc "AZ7E"
.else ; ROM_AGES
	.asc "ZELDA NAYRU"
	.asc "AZ8E"
.endif


.ORGA $150

.SECTION "Bank 0"

;;
; The game's entrypoint.
; @addr{0150}
begin:
	nop
	di
	cp $11
	ld a,$00
	jr nz,+

	; Check GBA Mode
	inc a
	bit 0,b
	jr z,+
	ld a,$ff
+
	ldh (<hGameboyType),a
	ld a,$37
	ldh (<hRng1),a
	ld a,$0d
	ldh (<hRng2),a
resetGame:
	ld sp,wMainStackTop
	jpfrombank0 init


;;
; Get the number of set bits in a.
;
; @param	a	Value to check
; @param[out]	a,b	Number of set bits in 'a'
; @addr{0176}
getNumSetBits:
	ld b,$00		; $0176
-
	add a			; $0178
	jr nc,+
	inc b			; $017b
+
	or a			; $017c
	jr nz,-
	ld a,b			; $017f
	ret			; $0180

;;
; Add a bcd-encoded number to a 16-bit memory address. If it would go above $9999, the
; result is $9999.
;
; @param[in]  bc	Number to add.
; @param[in]  hl	Address to add with and store result into.
; @param[out] cflag	Set if the value would have gone over $9999.
; @addr{0181}
addDecimalToHlRef:
	ld a,(hl)		; $0181
	add c			; $0182
	daa			; $0183
	ldi (hl),a		; $0184
	ld a,(hl)		; $0185
	adc b			; $0186
	daa			; $0187
	ldd (hl),a		; $0188
	ret nc			; $0189
	ld a,$63		; $018a
	ldi (hl),a		; $018c
	ldd (hl),a		; $018d
	ret			; $018e

;;
; Subtract a bcd-encoded number from a 16-bit memory address. If it would go below 0, the
; result is 0.
;
; @param	bc	Value to subtract.
; @param	hl	Address to subtract with and store result into.
; @param[out]	cflag	Set if the value would have gone under $0000.
; @addr{018f}
subDecimalFromHlRef:
	ld a,(hl)		; $018f
	sub c			; $0190
	daa			; $0191
	ldi (hl),a		; $0192
	ld a,(hl)		; $0193
	sbc b			; $0194
	daa			; $0195
	ldd (hl),a		; $0196
	ret nc			; $0197
	xor a			; $0198
	ldi (hl),a		; $0199
	ldd (hl),a		; $019a
	scf			; $019b
	ret			; $019c

;;
; @param	a	Operand 1
; @param	c	Operand 2
; @param[out]	hl	Result
; @trashes{b,e}
; @addr{019d}
multiplyAByC:
	ld e,$08		; $019d
	ld b,$00		; $019f
	ld l,b			; $01a1
	ld h,b			; $01a2
-
	add hl,hl		; $01a3
	add a			; $01a4
	jr nc,+
	add hl,bc		; $01a7
+
	dec e			; $01a8
	jr nz,-
	ret			; $01ab

;;
; Multiply 'a' by $10, store result in bc.
;
; @param	a	Value to multiply
; @param[out]	bc	Result
; @addr{01ac}
multiplyABy16:
	swap a			; $01ac
	ld b,a			; $01ae
	and $f0			; $01af
	ld c,a			; $01b1
	ld a,b			; $01b2
	and $0f			; $01b3
	ld b,a			; $01b5
	ret			; $01b6

;;
; Multiply 'a' by 8, store result in bc.
;
; @param	a	Value to multiply
; @param[out]	bc	Result
; @addr{01b7}
multiplyABy8:
	swap a			; $01b7
	rrca			; $01b9
	ld b,a			; $01ba
	and $f8			; $01bb
	ld c,a			; $01bd
	ld a,b			; $01be
	and $07			; $01bf
	ld b,a			; $01c1
	ret			; $01c2

;;
; Multiply 'a' by 4, store result in bc.
;
; @param	a	Value to multiply
; @param[out]	bc	Result
; @addr{01c3}
multiplyABy4:
	ld b,$00		; $01c3
	add a			; $01c5
	rl b			; $01c6
	add a			; $01c8
	rl b			; $01c9
	ld c,a			; $01cb
	ret			; $01cc

;;
; Convert a signed 8-bit value in 'a' to signed 16-bit value in 'bc'
;
; @param	a	Signed value
; @param[out]	bc	Signed 16-bit value
; @addr{01cd}
s8ToS16:
	ld b,$ff		; $01cd
	bit 7,a			; $01cf
	jr nz,+
	inc b			; $01d3
+
	ld c,a			; $01d4
	ret			; $01d5

;;
; @param[out]	a	$ff if hl < bc, $01 if hl > bc, $00 if equal
; @param[out]	cflag	c if hl < bc, nc otherwise
; @addr{01d6}
compareHlToBc:
	ld a,h			; $01d6
	cp b			; $01d7
	jr c,+
	jr nz,++
	ld a,l			; $01dc
	cp c			; $01dd
	jr c,+
	jr nz,++
	xor a			; $01e2
	ret			; $01e3
+
	ld a,$ff		; $01e4
	ret			; $01e6
++
	ld a,$01		; $01e7
	ret			; $01e9

;;
; This returns the highest set bit in 'a', which in effect is like log base 2.
;
; @param[out]	a	Bit value (0-7) or unchanged if no bits are set
; @param[out]	cflag	c if at least one bit was set (output is valid)
; @addr{01ea}
getHighestSetBit:
	or a			; $01ea
	ret z			; $01eb
	push bc			; $01ec
	ld c,$ff		; $01ed
-
	inc c			; $01ef
	srl a			; $01f0
	jr nz,-
	ld a,c			; $01f4
	pop bc			; $01f5
	scf			; $01f6
	ret			; $01f7

;;
; @param[out]	a	Bit value (0-7) or unchanged if no bits are set
; @param[out]	cflag	c if at least one bit was set (output is valid)
; @addr{01f8}
getLowestSetBit:
	or a			; $01f8
	ret z			; $01f9
	push bc			; $01fa
	ld c,$08		; $01fb
-
	dec c			; $01fd
	add a			; $01fe
	jr nz,-
	ld a,c			; $0201
	pop bc			; $0202
	scf			; $0203
	ret			; $0204

;;
; A "flag" is just a bit in memory. These flag-related functions take a base address
; ('hl'), and check a bit in memory starting at that address ('a').
;
; @param	a	Flag to check
; @param	hl	Start address of flags
; @param[out]	a	AND result
; @param[out]	zflag	Set if the flag is not set.
; @addr{0205}
checkFlag:
	push hl			; $0205
	push bc			; $0206
	call _flagHlpr		; $0207
	and (hl)		; $020a
	pop bc			; $020b
	pop hl			; $020c
	ret			; $020d

;;
; @param	a	Flag to set
; @param	hl	Start address of flags
; @addr{020e}
setFlag:
	push hl			; $020e
	push bc			; $020f
	call _flagHlpr		; $0210
	or (hl)			; $0213
	ld (hl),a		; $0214
	pop bc			; $0215
	pop hl			; $0216
	ret			; $0217

;;
; @param	a	Flag to unset
; @param	hl	Start address of flags
; @addr{0218}
unsetFlag:
	push hl			; $0218
	push bc			; $0219
	call _flagHlpr		; $021a
	cpl			; $021d
	and (hl)		; $021e
	ld (hl),a		; $021f
	pop bc			; $0220
	pop hl			; $0221
	ret			; $0222

;;
; Add (a/8) to hl, set 'a' to a bitmask for the desired bit (a%8)
;
; @addr{0223}
_flagHlpr:
	ld b,a			; $0223
	and $f8			; $0224
	rlca			; $0226
	swap a			; $0227
	ld c,a			; $0229
	ld a,b			; $022a
	ld b,$00		; $022b
	add hl,bc		; $022d
	and $07			; $022e
	ld bc,bitTable		; $0230
	add c			; $0233
	ld c,a			; $0234
	ld a,(bc)		; $0235
	ret			; $0236

;;
; @addr{0237}
decHlRef16WithCap:
	inc hl			; $0237
	ldd a,(hl)		; $0238
	or (hl)			; $0239
	ret z			; $023a
	ld a,(hl)		; $023b
	sub $01			; $023c
	ldi (hl),a		; $023e
	ld a,(hl)		; $023f
	sbc $00			; $0240
	ldd (hl),a		; $0242
	or (hl)			; $0243
	ret			; $0244

;;
; @addr{0245}
incHlRefWithCap:
	inc (hl)		; $0245
	ret nz			; $0246
	ld (hl),$ff		; $0247
	ret			; $0249

;;
; @addr{024a}
incHlRef16WithCap:
	inc (hl)		; $024a
	ret nz			; $024b
	inc hl			; $024c
	inc (hl)		; $024d
	jr z,+
	dec hl			; $0250
	ret			; $0251
+
	push af			; $0252
	ld a,$ff		; $0253
	ldd (hl),a		; $0255
	ld (hl),a		; $0256
	pop af			; $0257
	ret			; $0258

;;
; Convert hex value in a to a bcd-encoded decimal value in bc
;
; @param	a	Hexadecimal number
; @param[out]	bc	bcd-encoded decimal number
; @addr{0259}
hexToDec:
	ld bc,$0000		; $0259
-
	cp 100			; $025c
	jr c,@doneHundreds	; $025e
	sub 100			; $0260
	inc b			; $0262
	jr -

@doneHundreds:
	cp 10			; $0265
	ret c			; $0267
	sub 10			; $0268
	inc c			; $026a
	jr @doneHundreds		; $026b

;;
; Update wKeysPressed, wKeysJustPressed, and wKeysPressedLastFrame.
;
; @trashes{bc,hl}
; @addr{026d}
pollInput:
	ld c,R_P1		; $026d
	ld a,$20		; $026f
	ld ($ff00+c),a		; $0271
	ld a,($ff00+c)		; $0272
	ld a,($ff00+c)		; $0273
	ld a,($ff00+c)		; $0274
	ld b,a			; $0275
	ld a,$10		; $0276
	ld ($ff00+c),a		; $0278
	ld a,b			; $0279
	and $0f			; $027a
	swap a			; $027c
	ld b,a			; $027e
	ld hl,wKeysPressed
	ldd a,(hl)		; $0282
	ldi (hl),a		; $0283
	cpl			; $0284
	ld (hl),a		; $0285
	ld a,($ff00+c)		; $0286
	ld a,($ff00+c)		; $0287
	and $0f			; $0288
	or b			; $028a
	cpl			; $028b
	ld b,(hl)		; $028c
	ldi (hl),a		; $028d
	and b			; $028e
	ld (hl),a		; $028f
	ld a,$30		; $0290
	ld ($ff00+c),a		; $0292
	ret			; $0293

;;
; @addr{0294}
getInputWithAutofire:
	push hl			; $0294
	push bc			; $0295
	ld a,(wKeysPressed)		; $0296
	and $f0			; $0299
	ld b,a			; $029b
	ld hl,wAutoFireKeysPressed
	ld a,(hl)		; $029f
	and b			; $02a0
	ld a,b			; $02a1
	ldi (hl),a		; $02a2
	jr z,+
	inc (hl)		; $02a5
	ld a,(hl)		; $02a6
	cp $28			; $02a7
	jr c,++
	and $1f			; $02ab
	or $80			; $02ad
	ld (hl),a		; $02af
	and $03			; $02b0
	jr nz,++
	ld a,(wKeysPressed)
	jr +++
+
	xor a			; $02b9
	ld (hl),a		; $02ba
++
	ld a,(wKeysJustPressed)		; $02bb
+++
	pop bc			; $02be
	pop hl			; $02bf
	ret			; $02c0

;;
; @addr{02c1}
disableLcd:
	ld a,($ff00+R_LCDC)	; $02c1
	rlca			; $02c3
	ret nc			; $02c4
	push bc			; $02c5
	ld a,($ff00+R_IE)	; $02c6
	ld b,a			; $02c8
	and INT_VBLANK ~ $FF
	ld ($ff00+R_IE),a	; $02cb
-
	ld a,($ff00+R_LY)	; $02cd
	cp $91			; $02cf
	jr c,-
	ld a,$03		; $02d3
	ldh (<hNextLcdInterruptBehaviour),a	; $02d5
	xor a			; $02d7
	ld (wGfxRegsFinal.LCDC),a		; $02d8
	ld (wGfxRegs2.LCDC),a		; $02db
	ld (wGfxRegs1.LCDC),a		; $02de
	ld ($ff00+R_LCDC),a	; $02e1
	ld ($ff00+R_IF),a	; $02e3
	ld a,b			; $02e5
	ld ($ff00+R_IE),a	; $02e6
	pop bc			; $02e8
	ret			; $02e9

;;
; @param	a	Gfx register state index to load
; @addr{02ea}
loadGfxRegisterStateIndex:
	; a *= $06
	ld l,a			; $02ea
	add a			; $02eb
	add l			; $02ec
	add a			; $02ed

	ld hl,gfxRegisterStates
	rst_addDoubleIndex			; $02f1
	ld b,GfxRegsStruct.size*2
	ld de,wGfxRegs1		; $02f4
-
	ldi a,(hl)		; $02f7
	ld (de),a		; $02f8
	inc e			; $02f9
	dec b			; $02fa
	jr nz,-
	ld a,(wGfxRegs1.LCDC)		; $02fd
	ld (wGfxRegsFinal.LCDC),a		; $0300
	ld ($ff00+R_LCDC),a	; $0303
	ret			; $0305

; @addr{0306}
gfxRegisterStates:
	.db $c3 $00 $00 $c7 $c7 $c7 ; 0x00: DMG mode screen, capcom intro, ...
	.db $c3 $00 $00 $c7 $c7 $c7

	.db $c7 $00 $00 $c7 $c7 $c7 ; 0x01
	.db $00 $00 $00 $c7 $c7 $c7

	.db $ef $f0 $00 $8f $8f $0f ; 0x02: Post-d3 cutscene, twinrova/ganon fight, CUTSCENE_BLACK_TOWER_ESCAPE
	.db $e7 $00 $00 $c7 $c7 $c7

	.db $ef $f0 $00 $10 $c7 $0f ; 0x03
	.db $f7 $f0 $00 $10 $c7 $75

	.db $c7 $00 $00 $c7 $c7 $c7 ; 0x04: titlescreen
	.db $00 $00 $00 $c7 $c7 $c7

	.db $cf $00 $00 $c7 $c7 $c7 ; 0x05
	.db $00 $00 $00 $c7 $c7 $c7

	.db $a7 $00 $b0 $c7 $c7 $1f ; 0x06
	.db $8f $00 $00 $c7 $c7 $c7

	.db $c7 $00 $00 $c7 $c7 $c7 ; 0x07: map screens (both overworld and dungeon)?
	.db $00 $00 $00 $c7 $c7 $c7

	.db $a7 $00 $00 $90 $07 $00 ; 0x08
	.db $a7 $40 $00 $90 $07 $c7

	.db $c7 $70 $00 $c7 $c7 $c7 ; 0x09: temple in intro
	.db $c7 $00 $00 $c7 $c7 $c7

	.db $cf $70 $00 $c7 $c7 $c7 ; 0x0a: scrolling up the tree in the intro
	.db $cf $00 $00 $c7 $c7 $c7

	.db $cf $00 $20 $c7 $c7 $c7 ; 0x0b
	.db $cf $00 $00 $c7 $c7 $c7

	.db $a7 $00 $00 $78 $07 $27 ; 0x0c
	.db $af $f0 $00 $78 $07 $c7

	.db $c7 $10 $30 $c7 $c7 $c7 ; 0x0d
	.db $c7 $00 $00 $c7 $c7 $c7

	.db $e7 $01 $00 $4c $4c $c7 ; 0x0e
	.db $c7 $00 $00 $c7 $c7 $c7

	.db $af $f0 $00 $10 $07 $17 ; 0x0f: ring appraisal menu
	.db $f7 $f0 $00 $10 $c7 $57

	.db $b7 $f0 $00 $10 $07 $1f ; 0x10: ring list menu
	.db $f7 $f0 $00 $10 $c7 $47

	.db $ef $f0 $00 $8f $8f $0f ; 0x11
	.db $e7 $00 $00 $40 $57 $c7

	.db $ef $f0 $00 $8f $8f $0f ; 0x12
	.db $e7 $00 $00 $90 $47 $c7

	.db $e7 $00 $28 $c7 $c7 $c7 ; 0x13
	.db $e7 $00 $28 $c7 $c7 $c7

	.db $ef $f0 $00 $8f $8f $00 ; 0x14
	.db $e7 $00 $00 $c7 $c7 $c7

	.db $e7 $00 $00 $c7 $c7 $c7 ; 0x15
	.db $e7 $00 $00 $c7 $c7 $c7

	.db $ff $30 $00 $60 $07 $18 ; 0x16: farore's secret list
	.db $ff $30 $00 $60 $07 $c7

.ifdef ROM_AGES
	.db $ef $00 $00 $90 $07 $00 ; 0x17: intro cinematic screen 1
	.db $e7 $00 $00 $90 $07 $c7

	.db $ef $98 $00 $68 $07 $40 ; 0x18
	.db $ef $98 $00 $68 $07 $c7

	.db $ef $00 $00 $90 $07 $30 ; 0x19
	.db $e7 $98 $00 $60 $07 $c7
.endif


;;
; @param[out]	a	Random number
; @addr{043e}
getRandomNumber:
	push hl			; $043e
	push bc			; $043f
	ldh a,(<hRng1)	; $0440
	ld l,a			; $0442
	ld c,a			; $0443
	ldh a,(<hRng2)	; $0444
	ld h,a			; $0446
	ld b,a			; $0447
	add hl,hl		; $0448
	add hl,bc		; $0449
	ld a,h			; $044a
	ldh (<hRng2),a	; $044b
	add c			; $044d
	ldh (<hRng1),a	; $044e
	pop bc			; $0450
	pop hl			; $0451
	ret			; $0452

;;
; Same as above, except it doesn't preserve bc and hl. It's a little faster I guess?
;
; @param[out]	a,c	Random number
; @param[out]	hl	Intermediate calculation (sometimes also used as random values?)
; @addr{0453}
getRandomNumber_noPreserveVars:
	ldh a,(<hRng1)	; $0453
	ld l,a			; $0455
	ld c,a			; $0456
	ldh a,(<hRng2)	; $0457
	ld h,a			; $0459
	ld b,a			; $045a
	add hl,hl		; $045b
	add hl,bc		; $045c
	ld a,h			; $045d
	ldh (<hRng2),a	; $045e
	add c			; $0460
	ldh (<hRng1),a	; $0461
	ret			; $0463

;;
; Reads a probability distribution from hl, and returns (in 'b') an index from the
; distribution.
;
; The sum of all values in the distribution should equal $100. Higher values have a higher
; weighting for the corresponding index, meaning it's more likely that those values will
; be picked.
;
; @param	hl	Probability distribution
; @param[out]	b	The index chosen from the distribution
; @addr{0464}
getRandomIndexFromProbabilityDistribution:
	ld b,$00		; $0464
	call getRandomNumber
-
	sub (hl)		; $0469
	ret c			; $046a
	inc hl			; $046b
	inc b			; $046c
	jr -

;;
; @param	b	# of bytes to clear
; @param	hl	Memory to clear
; @addr{046f}
clearMemory:
	xor a			; $046f

;;
; @param	a	Value to fill memory with
; @param	b	# of bytes to fill
; @param	hl	Memory to fill
; @addr{0470}
fillMemory:
	ldi (hl),a		; $0470
	dec b			; $0471
	jr nz,fillMemory
	ret			; $0474

;;
; @param	bc	# of bytes to clear
; @param	hl	Memory to clear
; @addr{0475}
clearMemoryBc:
	xor a			; $0475

;;
; @param	a	Value to fill memory with
; @param	bc	# of bytes to fill
; @param	hl	Memory to fill
; @addr{0476}
fillMemoryBc:
	ld e,a			; $0476
-
	ld a,e			; $0477
	ldi (hl),a		; $0478
	dec bc			; $0479
	ld a,c			; $047a
	or b			; $047b
	jr nz,-
	ret			; $047e

;;
; @param	b	# of bytes to copy
; @param	de	Source
; @param	hl	Destination
; @addr{047f}
copyMemoryReverse:
	ld a,(de)		; $047f
	ldi (hl),a		; $0480
	inc de			; $0481
	dec b			; $0482
	jr nz,copyMemoryReverse
	ret			; $0485

;;
; @param	b	# of bytes to copy
; @param	de	Destination
; @param	hl	Source
; @addr{0486}
copyMemory:
	ldi a,(hl)		; $0486
	ld (de),a		; $0487
	inc de			; $0488
	dec b			; $0489
	jr nz,copyMemory
	ret			; $048c

;;
; @param	bc	# of bytes to copy
; @param	de	Source
; @param	hl	Destination
; @addr{048d}
copyMemoryBcReverse:
	ld a,(de)		; $048d
	ldi (hl),a		; $048e
	inc de			; $048f
	dec bc			; $0490
	ld a,b			; $0491
	or c			; $0492
	jr nz,copyMemoryBcReverse
	ret			; $0495

;;
; @param	bc	# of bytes to copy
; @param	de	Destination
; @param	hl	Source
; @addr{0496}
copyMemoryBc:
	ldi a,(hl)		; $0496
	ld (de),a		; $0497
	inc de			; $0498
	dec bc			; $0499
	ld a,b			; $049a
	or c			; $049b
	jr nz,copyMemoryBc
	ret			; $049e

;;
; @addr{049f}
clearOam:
	xor a			; $049f
	ldh (<hOamTail),a	; $04a0
	ld h, wOam>>8
	ld b,$e0		; $04a4
-
	ld l,a			; $04a6
	ld (hl),b		; $04a7
	add $04			; $04a8
	cp <wOamEnd			; $04aa
	jr c,-
	ret			; $04ae

;;
; @addr{04af}
clearVram:
	call disableLcd		; $04af
	call clearOam
	ld a,$01		; $04b5
	ld ($ff00+R_VBK),a	; $04b7
	ld hl,$8000		; $04b9
	ld bc,$2000		; $04bc
	call clearMemoryBc		; $04bf
	xor a			; $04c2
	ld ($ff00+R_VBK),a	; $04c3
	ld hl,$8000		; $04c5
	ld bc,$2000		; $04c8
	jr clearMemoryBc

;;
; @addr{04cd}
initializeVramMaps:
	call initializeVramMap1		; $04cd
;;
; @addr{04d0}
initializeVramMap0:
	call disableLcd		; $04d0
	ld a,$01		; $04d3
	ld ($ff00+R_VBK),a	; $04d5
	ld hl,$9800		; $04d7
	ld bc,$0400		; $04da
	ld a,$80		; $04dd
	call fillMemoryBc		; $04df
	xor a			; $04e2
	ld ($ff00+R_VBK),a	; $04e3
	ld hl,$9800		; $04e5
	ld bc,$0400		; $04e8
	jr clearMemoryBc

;;
; @addr{04ed}
initializeVramMap1:
	call disableLcd		; $04ed
	ld a,$01		; $04f0
	ld ($ff00+R_VBK),a	; $04f2
	ld hl,$9c00		; $04f4
	ld bc,$0400		; $04f7
	ld a,$80		; $04fa
	call fillMemoryBc		; $04fc
	xor a			; $04ff
	ld ($ff00+R_VBK),a	; $0500
	ld hl,$9c00		; $0502
	ld bc,$0400		; $0505
	jp clearMemoryBc		; $0508

;;
; @param	a	Palette header to load (see data/[ages|seasons]/paletteHeaders.s)
; @addr{050b}
loadPaletteHeader:
	push de			; $050b
	ld l,a			; $050c
	ld a,($ff00+R_SVBK)	; $050d
	ld c,a			; $050f
	ldh a,(<hRomBank)	; $0510
	ld b,a			; $0512
	push bc			; $0513
	ld a,$02		; $0514
	ld ($ff00+R_SVBK),a	; $0516
	ld a,:paletteHeaderTable
	setrombank		; $051a
	ld a,l			; $051f
	ld hl,paletteHeaderTable
	rst_addDoubleIndex			; $0523
	ldi a,(hl)		; $0524
	ld h,(hl)		; $0525
	ld l,a			; $0526
---
	ld a,:paletteHeaderTable
	setrombank		; $0529

	; b: how many palettes to load
	ld a,(hl)		; $052e
	and $07			; $052f
	inc a			; $0531
	ld b,a			; $0532

	; c: which palette to start on
	ld a,(hl)		; $0533
	rlca			; $0534
	swap a			; $0535
	and $07			; $0537
	ld de,bitTable		; $0539
	add e			; $053c
	ld e,a			; $053d
	ld a,(de)		; $053e
	ld c,a			; $053f

	; Turn b into a bitmask for which palettes to load
	xor a			; $0540
-
	or c			; $0541
	dec b			; $0542
	jr z,+
	rlca			; $0545
	jr -
+
	ld b,a			; $0548

	; Mark palettes as dirty
	ld c,<hDirtyBgPalettes
	bit 6,(hl)		; $054b
	jr z,+
	ld c,<hDirtySprPalettes
+
	ld a,($ff00+c)		; $0551
	or b			; $0552
	ld ($ff00+c),a		; $0553

	; de = destination
	ld a,(hl)		; $0554
	and $78			; $0555
	add w2AreaBgPalettes&$ff
	ld e,a			; $0559
	ld d, w2AreaBgPalettes>>8

	; b = number of palettes
	ld a,(hl)		; $055c
	and $07			; $055d
	inc a			; $055f
	ld b,a			; $0560

	; Set carry if there's another palette header to process
	ldi a,(hl)		; $0561
	rlca			; $0562

	; Load pointer to actual palette data into hl
	ldi a,(hl)		; $0563
	ld c,a			; $0564
	ldi a,(hl)		; $0565
	push hl			; $0566
	ld l,c			; $0567
	ld h,a			; $0568

	; Set bank, begin copying
	ld a,:paletteDataStart
	setrombank		; $056b
--
	ld c,$08		; $0570
-
	ldi a,(hl)		; $0572
	ld (de),a		; $0573
	inc e			; $0574
	dec c			; $0575
	jr nz,-
	dec b			; $0578
	jr nz,--
	pop hl			; $057b
	jr c,---

	pop bc			; $057e
	ld a,b			; $057f
	setrombank		; $0580
	ld a,c			; $0585
	ld ($ff00+R_SVBK),a	; $0586
	pop de			; $0588
	ret			; $0589

;;
; Do a DMA transfer next vblank. Note:
;  - Only banks $00-$3f work properly
;  - Destination address must be a multiple of 16
; @param	b	(data size)/16 - 1
; @param	c	src bank
; @param	de	(dest address) | (vram or wram bank)
; @param	hl	src address
; @param[out]	cflag	Set if the lcd is on (data can't be copied immediately)
; @addr{058a}
queueDmaTransfer:
	ld a,($ff00+R_LCDC)	; $058a
	rlca			; $058c
	jr nc,++

	push de			; $058f
	push hl			; $0590
	ld h,wVBlankFunctionQueue>>8
	ldh a,(<hVBlankFunctionQueueTail)
	ld l,a			; $0595
	ld a,(vblankDmaFunctionOffset)		; $0596
	ldi (hl),a		; $0599
	ld a,c			; $059a
	ldi (hl),a		; $059b
	pop de			; $059c
	ld a,d			; $059d
	ldi (hl),a		; $059e
	ld a,e			; $059f
	ldi (hl),a		; $05a0
	pop de			; $05a1
	ld a,e			; $05a2
	ldi (hl),a		; $05a3
	ld a,d			; $05a4
	ldi (hl),a		; $05a5
	ld a,e			; $05a6
	ldi (hl),a		; $05a7
	ld a,b			; $05a8
	ldi (hl),a		; $05a9
	ld a,l			; $05aa
	ldh (<hVBlankFunctionQueueTail),a	; $05ab
	scf			; $05ad
	ret			; $05ae
++
; If LCD is off, copy data immediately?
	ldh a,(<hRomBank)	; $05af
	push af			; $05b1
	ld a,($ff00+R_SVBK)	; $05b2
	push af			; $05b4
	push de			; $05b5
	push hl			; $05b6
	ld a,c			; $05b7
	ld ($ff00+R_SVBK),a	; $05b8
	setrombank		; $05ba
	pop de			; $05bf
	ld hl, HDMA1
	ld (hl),d		; $05c3
	inc l			; $05c4
	ld (hl),e		; $05c5
	inc l			; $05c6
	pop de			; $05c7
	ld a,e			; $05c8
	ld ($ff00+R_VBK),a	; $05c9
	ld (hl),d		; $05cb
	inc l			; $05cc
	ldi (hl),a		; $05cd
	ld (hl),b		; $05ce
	pop af			; $05cf
	ld ($ff00+R_SVBK),a	; $05d0
	pop af			; $05d2
	setrombank		; $05d3
	xor a			; $05d8
	ret			; $05d9

;;
; @param	a	Uncompressed gfx header index to load
; @trashes{bc,de,hl}
; @addr{05da}
loadUncompressedGfxHeader:
	ld e,a			; $05da
	ld a,($ff00+R_SVBK)	; $05db
	ld c,a			; $05dd
	ldh a,(<hRomBank)	; $05de
	ld b,a			; $05e0
	push bc			; $05e1
	ld a,:uncmpGfxHeaderTable		; $05e2
	setrombank		; $05e4
	ld a,e			; $05e9
	ld hl,uncmpGfxHeaderTable		; $05ea
	rst_addDoubleIndex			; $05ed
	ldi a,(hl)		; $05ee
	ld h,(hl)		; $05ef
	ld l,a			; $05f0
--
	ldi a,(hl)		; $05f1
	ld c,a			; $05f2
	ldi a,(hl)		; $05f3
	ld d,a			; $05f4
	ldi a,(hl)		; $05f5
	ld e,a			; $05f6
	push de			; $05f7
	ldi a,(hl)		; $05f8
	ld d,a			; $05f9
	ldi a,(hl)		; $05fa
	ld e,a			; $05fb
	ld a,(hl)		; $05fc
	and $7f			; $05fd
	ld b,a			; $05ff
	ld a,l			; $0600
	ldh (<hFF90),a	; $0601
	ld a,h			; $0603
	ldh (<hFF91),a	; $0604
	pop hl			; $0606
	call queueDmaTransfer		; $0607
	ld a,:uncmpGfxHeaderTable		; $060a
	setrombank		; $060c
	ldh a,(<hFF90)	; $0611
	ld l,a			; $0613
	ldh a,(<hFF91)	; $0614
	ld h,a			; $0616
	ldi a,(hl)		; $0617
	add a			; $0618
	jr c,--

	pop bc			; $061b
	ld a,b			; $061c
	setrombank		; $061d
	ld a,c			; $0622
	ld ($ff00+R_SVBK),a	; $0623
	ret			; $0625

;;
; @param	a	The index of the gfx header to load
; @addr{0626}
loadGfxHeader:
	ld e,a			; $0626
	ld a,($ff00+R_SVBK)	; $0627
	ld c,a			; $0629
	ldh a,(<hRomBank)	; $062a
	ld b,a			; $062c
	push bc			; $062d
	ld a,:gfxHeaderTable
	setrombank		; $0630
	ld a,e			; $0635
	ld hl,gfxHeaderTable
	rst_addDoubleIndex			; $0639
	ldi a,(hl)		; $063a
	ld h,(hl)		; $063b
	ld l,a			; $063c
--
	ldi a,(hl)		; $063d
	ld c,a			; $063e
	ldi a,(hl)		; $063f
	ld d,a			; $0640
	ldi a,(hl)		; $0641
	ld e,a			; $0642
	push de			; $0643
	ldi a,(hl)		; $0644
	ld d,a			; $0645
	ldi a,(hl)		; $0646
	ld e,a			; $0647
	ld a,(hl)		; $0648
	and $7f			; $0649
	ld b,a			; $064b
	ld a,l			; $064c
	ldh (<hFF90),a	; $064d
	ld a,h			; $064f
	ldh (<hFF91),a	; $0650
	pop hl			; $0652
	call decompressGraphics		; $0653
	ld a,:gfxHeaderTable		; $0656
	setrombank		; $0658
	ldh a,(<hFF90)	; $065d
	ld l,a			; $065f
	ldh a,(<hFF91)	; $0660
	ld h,a			; $0662
	ldi a,(hl)		; $0663
	add a			; $0664
	jr c,--

	pop bc			; $0667
	ld a,b			; $0668
	setrombank		; $0669
	ld a,c			; $066e
	ld ($ff00+R_SVBK),a	; $066f
	ret			; $0671

;;
; Deals with graphics compression
;
; @param	b	Data size (divided by 16, minus 1)
; @param	c	ROM bank (bits 0-5) and compression mode (bits 6-7)
; @param	de	Destination (lower 4 bits = destination bank, either vram or wram)
; @param	hl	Source
; @addr{0672}
decompressGraphics:
	ld a,e			; $0672
	and $0f			; $0673
	ld ($ff00+R_VBK),a	; $0675
	ld ($ff00+R_SVBK),a	; $0677
	xor e			; $0679
	ld e,a			; $067a
	ld a,c			; $067b
	and $3f			; $067c
	setrombank		; $067e
	inc b			; $0683
	ld a,c			; $0684
	and $c0			; $0685
	jp z,func_06e0		; $0687
	cp $c0			; $068a
	jr z,_label_00_059	; $068c
	cp $40			; $068e
	jr z,_label_00_060	; $0690
	ld a,b			; $0692
-
	push af			; $0693
	call func_069c		; $0694
	pop af			; $0697
	dec a			; $0698
	jr nz,-			; $0699
	ret			; $069b

;;
; @addr{069c}
func_069c:
	call readByteSequential		; $069c
	ld c,a			; $069f
	call readByteSequential		; $06a0
	ldh (<hFF8A),a	; $06a3
	or c			; $06a5
	jr nz,_label_00_050	; $06a6
	ld b,$10		; $06a8
_label_00_049:
	call readByteSequential		; $06aa
	ld (de),a		; $06ad
	inc de			; $06ae
	dec b			; $06af
	jr nz,_label_00_049	; $06b0
	ret			; $06b2
_label_00_050:
	call readByteSequential		; $06b3
	ldh (<hFF8B),a	; $06b6
	ld b,$08		; $06b8
_label_00_051:
	rl c			; $06ba
	jr c,_label_00_052	; $06bc
	call readByteSequential		; $06be
	jr _label_00_053		; $06c1
_label_00_052:
	ldh a,(<hFF8B)	; $06c3
_label_00_053:
	ld (de),a		; $06c5
	inc de			; $06c6
	dec b			; $06c7
	jr nz,_label_00_051	; $06c8
	ldh a,(<hFF8A)	; $06ca
	ld c,a			; $06cc
	ld b,$08		; $06cd
_label_00_054:
	rl c			; $06cf
	jr c,_label_00_055	; $06d1
	call readByteSequential		; $06d3
	jr _label_00_056		; $06d6
_label_00_055:
	ldh a,(<hFF8B)	; $06d8
_label_00_056:
	ld (de),a		; $06da
	inc de			; $06db
	dec b			; $06dc
	jr nz,_label_00_054	; $06dd
	ret			; $06df

;;
; @addr{06e0}
func_06e0:
	ld c,$10		; $06e0
-
	call readByteSequential		; $06e2
	ld (de),a		; $06e5
	inc de			; $06e6
	dec c			; $06e7
	jr nz,-
	dec b			; $06ea
	jr nz,func_06e0	; $06eb
	ret			; $06ed

_label_00_059:
	ld a,$ff		; $06ee
	jr _label_00_061		; $06f0
_label_00_060:
	xor a			; $06f2
	ldh (<hFF93),a	; $06f3
_label_00_061:
	ldh (<hFF8E),a	; $06f5
	swap b			; $06f7
	ld a,b			; $06f9
	and $f0			; $06fa
	ld c,a			; $06fc
	xor b			; $06fd
	ld b,a			; $06fe
	ld a,$01		; $06ff
	ldh (<hFF8B),a	; $0701
_label_00_062:
	ldh a,(<hFF8B)	; $0703
	dec a			; $0705
	ldh (<hFF8B),a	; $0706
	jr nz,_label_00_063	; $0708
	ld a,$08		; $070a
	ldh (<hFF8B),a	; $070c
	ldi a,(hl)		; $070e
	ldh (<hFF8A),a	; $070f
	call _adjustHLSequential		; $0711
_label_00_063:
	ldh a,(<hFF8A)	; $0714
	add a			; $0716
	ldh (<hFF8A),a	; $0717
	jr c,_label_00_064	; $0719
	call copyByteSequential		; $071b
	jr nz,_label_00_062	; $071e
	ret			; $0720
_label_00_064:
	ldh a,(<hFF8E)	; $0721
	or a			; $0723
	jr nz,_label_00_065	; $0724
	ld a,(hl)		; $0726
	and $1f			; $0727
	ldh (<hFF92),a	; $0729
	xor (hl)		; $072b
	jr z,_label_00_066	; $072c
	swap a			; $072e
	rrca			; $0730
	inc a			; $0731
	jr _label_00_067		; $0732
_label_00_065:
	ldi a,(hl)		; $0734
	ldh (<hFF92),a	; $0735
	call _adjustHLSequential		; $0737
	ld a,(hl)		; $073a
	and $07			; $073b
	ldh (<hFF93),a	; $073d
	xor (hl)		; $073f
	jr z,_label_00_066	; $0740
	rrca			; $0742
	rrca			; $0743
	rrca			; $0744
	add $02			; $0745
	jr _label_00_067		; $0747
_label_00_066:
	inc hl			; $0749
	call _adjustHLSequential		; $074a
	ld a,(hl)		; $074d
_label_00_067:
	ldh (<hFF8F),a	; $074e
	inc hl			; $0750
	call _adjustHLSequential		; $0751
	push hl			; $0754
	ldh a,(<hFF92)	; $0755
	cpl			; $0757
	ld l,a			; $0758
	ldh a,(<hFF93)	; $0759
	cpl			; $075b
	ld h,a			; $075c
	add hl,de		; $075d
_label_00_068:
	ldi a,(hl)		; $075e
	ld (de),a		; $075f
	inc de			; $0760
	dec bc			; $0761
	ld a,b			; $0762
	or c			; $0763
	jr z,_label_00_069	; $0764
	ldh a,(<hFF8F)	; $0766
	dec a			; $0768
	ldh (<hFF8F),a	; $0769
	jr nz,_label_00_068	; $076b
	pop hl			; $076d
	jr _label_00_062		; $076e
_label_00_069:
	pop hl			; $0770
	ret			; $0771


;;
; Copies a single byte, and checks whether to increment the bank.
; @param	bc	Amount of bytes to read (not enforced here)
; @param	de	Address to write data to
; @param	hl	Address to read data from
; @param[out]	zflag	Set if bc reaches 0.
; @addr{0772}
copyByteSequential:
	ldi a,(hl)		; $0772
	ld (de),a		; $0773
	inc de			; $0774
	dec bc			; $0775

;;
; Adjusts the value of hl and the current loaded bank for various "sequental read"
; functions.
; @param	hl	Address
; @param[out]	zflag	Set if bc is 0.
; @addr{0776}
_adjustHLSequential:
	ld a,h			; $0776
	cp $80			; $0777
	jr nz,+
	ld h,$40		; $077b
	ldh a,(<hRomBank)	; $077d
	inc a			; $077f
	setrombank		; $0780
+
	ld a,b			; $0785
	or c			; $0786
	ret			; $0787

;;
; @param	hl	Address to read from
; @addr{0788}
readByteSequential:
	ldi a,(hl)		; $0788
	bit 7,h			; $0789
	ret z			; $078b
	push af			; $078c
	ld h,$40		; $078d
	ldh a,(<hRomBank)	; $078f
	inc a			; $0791
	setrombank		; $0792
	pop af			; $0797
	ret			; $0798

;;
; @param	a	Tileset to load (tilesets include collision data and tile indices)
; @addr{0799}
loadTileset:
	ld e,a			; $0799
	ld a,($ff00+R_SVBK)	; $079a
	ld c,a			; $079c
	ldh a,(<hRomBank)	; $079d
	ld b,a			; $079f
	push bc			; $07a0

	ld a,:tilesetHeaderGroupTable
	setrombank		; $07a3
	ld a,e			; $07a8
	ld hl,tilesetHeaderGroupTable
	rst_addDoubleIndex			; $07ac
	ldi a,(hl)		; $07ad
	ld h,(hl)		; $07ae
	ld l,a			; $07af
--
	ldi a,(hl)		; $07b0
	push hl			; $07b1
	ld hl,tilesetDictionaryTable
	rst_addDoubleIndex			; $07b5
	ldi a,(hl)		; $07b6
	ld h,(hl)		; $07b7
	ld l,a			; $07b8
	ldi a,(hl)		; $07b9
	ldh (<hFF8F),a	; $07ba
	ldi a,(hl)		; $07bc
	ldh (<hFF91),a	; $07bd
	ldi a,(hl)		; $07bf
	ldh (<hFF90),a	; $07c0
	pop hl			; $07c2

	; Get source data bank
	ldi a,(hl)		; $07c3
	ldh (<hFF8E),a	; $07c4

	; Load data pointer to stack for later use
	ldi a,(hl)		; $07c6
	ld d,a			; $07c7
	ldi a,(hl)		; $07c8
	ld e,a			; $07c9
	push de			; $07ca

	; Load destination in de
	ldi a,(hl)		; $07cb
	ld d,a			; $07cc
	ldi a,(hl)		; $07cd
	ld e,a			; $07ce

	; Write data size into ff8c
	ldi a,(hl)		; $07cf
	and $7f			; $07d0
	ldh (<hFF8D),a	; $07d2
	ldd a,(hl)		; $07d4
	ldh (<hFF8C),a	; $07d5

	; Store header position into ff92
	ld a,h			; $07d7
	ldh (<hFF93),a	; $07d8
	ld a,l			; $07da
	ldh (<hFF92),a	; $07db

	; Data pointer in hl
	pop hl			; $07dd
	call loadTilesetHlpr		; $07de

	ld a,:tilesetHeaderGroupTable
	setrombank		; $07e3

	; Retrieve header position
	ldh a,(<hFF93)	; $07e8
	ld h,a			; $07ea
	ldh a,(<hFF92)	; $07eb
	ld l,a			; $07ed

	; Check if repeat bit is set
	ldi a,(hl)		; $07ee
	inc hl			; $07ef
	add a			; $07f0
	jr c,--

	pop bc			; $07f3
	ld a,b			; $07f4
	setrombank		; $07f5
	ld a,c			; $07fa
	ld ($ff00+R_SVBK),a	; $07fb
	ret			; $07fd

;;
; @param	hl	pointer to compressed data
; @param	[ff8e]	bank of compressed data
; @addr{07fe}
loadTilesetHlpr:

; Internal variables:
; ff8a: size of chunk to read from dictionary
; ff8b: "key" byte (sorry bad at explaining)

	ld a,e			; $07fe
	and $0f			; $07ff
	ld ($ff00+R_VBK),a	; $0801
	ld ($ff00+R_SVBK),a	; $0803
	xor e			; $0805
	ld e,a			; $0806
----
	ldh a,(<hFF8E)	; $0807
	setrombank		; $0809
	ldi a,(hl)		; $080e
	ldh (<hFF8B),a	; $080f
	ld b,$08		; $0811
---
	ldh a,(<hFF8E)	; $0813
	setrombank		; $0815
	ldh a,(<hFF8B)	; $081a
	rrca			; $081c
	ldh (<hFF8B),a	; $081d
	jr c,++

	ldi a,(hl)		; $0821
	ld (de),a		; $0822
	inc de			; $0823
	call dec16_ff8c		; $0824
	ret z			; $0827
	dec b			; $0828
	jr nz,---
	jr ----
++
	push bc			; $082d
	ldh a,(<hFF8F)	; $082e
	bit 7,a			; $0830
	jr nz,+

	ldi a,(hl)		; $0834
	ld c,a			; $0835
	ldi a,(hl)		; $0836
	ldh (<hFF8A),a	; $0837
	and $0f			; $0839
	ld b,a			; $083b
	ldh a,(<hFF8A)	; $083c
	swap a			; $083e
	and $0f			; $0840
	add $03			; $0842
	ldh (<hFF8A),a	; $0844
	jr ++
+
	ldi a,(hl)		; $0848
	ldh (<hFF8A),a	; $0849
	ldi a,(hl)		; $084b
	ld c,a			; $084c
	ldi a,(hl)		; $084d
	ld b,a			; $084e
++
	push hl			; $084f
	ld hl,hFF90		; $0850
	ldi a,(hl)		; $0853
	ld h,(hl)		; $0854
	ld l,a			; $0855
	add hl,bc		; $0856
	ldh a,(<hFF8A)	; $0857
	ld b,a			; $0859
	ldh a,(<hFF8F)	; $085a
	and $3f			; $085c
	setrombank		; $085e
-
	ldi a,(hl)		; $0863
	ld (de),a		; $0864
	inc de			; $0865
	call dec16_ff8c		; $0866
	jr z,+++
	dec b			; $086b
	jr nz,-

	pop hl			; $086e
	pop bc			; $086f
	dec b			; $0870
	jr nz,---
	jr ----
+++
	pop hl			; $0875
	pop bc			; $0876
	ret			; $0877

;;
; @addr{0878}
dec16_ff8c:
	push hl			; $0878
	ld hl,hFF8C		; $0879
	call decHlRef16WithCap		; $087c
	pop hl			; $087f
	ret			; $0880

;;
; @addr{0881}
enableIntroInputs:
	ldh a,(<hIntroInputsEnabled)	; $0881
	bit 7,a			; $0883
	ret nz			; $0885
	ld a,$01		; $0886
	ldh (<hIntroInputsEnabled),a	; $0888
	ret			; $088a

;;
; @addr{088b}
threadFunc_088b:
	push hl			; $088b
	ld l,a			; $088c
	ld h,>wThreadStateBuffer	; $088d
	set 7,(hl)		; $088f
	pop hl			; $0891
	ret			; $0892

;;
; @addr{0893}
threadFunc_0893:
	push hl			; $0893
	ld l,a			; $0894
	ld h,>wThreadStateBuffer	; $0895
	res 7,(hl)		; $0897
	pop hl			; $0899
	ret			; $089a

;;
; @param	a	Low byte of thread address
; @addr{089b}
threadStop:
	push hl			; $089b
	ld l,a			; $089c
	ld h,>wThreadStateBuffer	; $089d
	ld (hl),$00		; $089f
	pop hl			; $08a1
	ret			; $08a2

;;
; @param	a	Low byte of thread address
; @param[in]	bc	Address where thread should restart
; @addr{08a3}
threadRestart:
	push hl			; $08a3
	push de			; $08a4
	push bc			; $08a5
	ld e,a			; $08a6
	add $04			; $08a7
	ld c,a			; $08a9
	ld d,$00		; $08aa
	ld hl,_initialThreadStates-(<wThreadStateBuffer)	; $08ac
	add hl,de		; $08af
	ld d,>wThreadStateBuffer	; $08b0
	ld b,$08		; $08b2
-
	ldi a,(hl)		; $08b4
	ld (de),a		; $08b5
	inc e			; $08b6
	dec b			; $08b7
	jr nz,-

	ld l,c			; $08ba
	ld h,d			; $08bb
	pop bc			; $08bc
	ld (hl),c		; $08bd
	inc l			; $08be
	ld (hl),b		; $08bf
	pop de			; $08c0
	pop hl			; $08c1
	ret			; $08c2

;;
; @param[in]	bc	Address where thread should restart
; @addr{08c3}
restartThisThread:
	push bc			; $08c3
	ldh a,(<hActiveThread)	; $08c4
	ld e,a			; $08c6
	add $04			; $08c7
	ld c,a			; $08c9
	ld d,$00		; $08ca
	ld hl,_initialThreadStates-(<wThreadStateBuffer)	; $08cc
	add hl,de		; $08cf
	ld d,>wThreadStateBuffer		; $08d0
	ld b,$08		; $08d2
-
	ldi a,(hl)		; $08d4
	ld (de),a		; $08d5
	inc e			; $08d6
	dec b			; $08d7
	jr nz,-

	ld l,c			; $08da
	ld h,d			; $08db
	pop bc			; $08dc
	ld (hl),c		; $08dd
	inc l			; $08de
	ld (hl),b		; $08df
	jr _nextThread		; $08e0

;;
; @addr{08e2}
stubThreadStart:
	ldh a,(<hActiveThread)	; $08e2
	ld l,a			; $08e4
	ld h,>wThreadStateBuffer		; $08e5
	ld (hl),$00		; $08e7
	jr _nextThread		; $08e9

;;
; @addr{08eb}
resumeThreadNextFrameAndSaveBank:
	ld a,$01		; $08eb
	push bc			; $08ed
	ld b,a			; $08ee
	ldh a,(<hRomBank)	; $08ef
	ld c,a			; $08f1
	ld a,b			; $08f2
	call resumeThreadInAFrames		; $08f3
	ld a,c			; $08f6
	setrombank		; $08f7
	pop bc			; $08fc
	ret			; $08fd

;;
; @addr{08fe}
resumeThreadNextFrame:
	ld a,$01		; $08fe
;;
; @param	a	Frames before the active thread will be executed next
; @addr{0900}
resumeThreadInAFrames:
	push hl			; $0900
	push de			; $0901
	push bc			; $0902
	ld b,a			; $0903
	ldh a,(<hActiveThread)	; $0904
	ld l,a			; $0906
	ld h,>wThreadStateBuffer	; $0907

	; Value $01 says to resume in X frames
	ld a,$01		; $0909
	ldi (hl),a		; $090b

	; Number of frames to wait
	ld (hl),b		; $090c
	inc l			; $090d

	; Save stack
	ld (hFF92),sp		; $090e
	ldh a,(<hFF92)	; $0911
	ldi (hl),a		; $0913
	ldh a,(<hFF93)	; $0914
	ld (hl),a		; $0916
;;
; @addr{0917}
_nextThread:
	ld sp,wMainStackTop		; $0917
	ld h,>wThreadStateBuffer	; $091a
	ld a,$01		; $091c
	ld ($ff00+R_SVBK),a	; $091e
	jr _mainLoop_nextThread		; $0920

;;
; Called just after basic initialization
;
; @addr{0922}
startGame:
	; Initialize thread states
	ld sp,wMainStackTop		; $0922
	ld hl,_initialThreadStates
	ld de,wThreadStateBuffer		; $0928
	ld b,NUM_THREADS*8	; $092b
-
	ldi a,(hl)		; $092d
	ld (de),a		; $092e
	inc e			; $092f
	dec b			; $0930
	jr nz,-

;;
; @addr{0933}
_mainLoop:
	call pollInput		; $0933
	ldh a,(<hIntroInputsEnabled)	; $0936
	add a			; $0938
	jr z,+

	ld a,(wKeysPressed)		; $093b
	sub (BTN_A | BTN_B | BTN_START | BTN_SELECT)
	jp z,resetGame		; $0940
+
	ld a,$10		; $0943
	ldh (<hOamTail),a	; $0945
	ld h,>wThreadStateBuffer		; $0947
	ld a,<wThreadStateBuffer		; $0949
	ldh (<hActiveThread),a	; $094b

--
	ld l,a			; $094d
	ld a,(hl)		; $094e

	; (hl) == 1?
	dec a			; $094f
	jr z,_countdownToRunThread	; $0950

	; (hl) == 2?
	dec a			; $0952
	jr z,_initializeThread	; $0953

;;
; @addr{0955}
_mainLoop_nextThread:
	ldh a,(<hActiveThread)	; $0955
	add $08			; $0957
	ldh (<hActiveThread),a	; $0959
	cp <(wThreadStateBuffer+NUM_THREADS*8)
	jr nz,--

	; No threads remaining this frame

	callfrombank0 bank3f.refreshDirtyPalettes	; $095f
	xor a			; $0969
	ld ($ff00+R_SVBK),a	; $096a
	ld hl,$c49e		; $096c
	inc (hl)		; $096f
	ld hl,wGfxRegs1		; $0970
	ld de,wGfxRegsFinal		; $0973
	ld b,GfxRegsStruct.size
-
	ldi a,(hl)		; $0978
	ld (de),a		; $0979
	inc e			; $097a
	dec b			; $097b
	jr nz,-

	; Wait for vblank
	ld hl,wVBlankChecker		; $097e
	ld (hl),$ff		; $0981
-
	halt			; $0983
	nop			; $0984
	bit 7,(hl)		; $0985
	jr nz,-
	jr _mainLoop

;;
; @addr{098b}
_countdownToRunThread:
	inc l			; $098b
	dec (hl)		; $098c
	jr nz,_mainLoop_nextThread	; $098d

	dec l			; $098f
	ld a,$03		; $0990
	ldi (hl),a		; $0992
	inc l			; $0993
	ldi a,(hl)		; $0994
	ld h,(hl)		; $0995
	ld l,a			; $0996
	ld sp,hl		; $0997
	pop bc			; $0998
	pop de			; $0999
	pop hl			; $099a
	ret			; $099b

;;
; @addr{099c}
_initializeThread:
	ld a,$03		; $099c
	ldi (hl),a		; $099e
	inc l			; $099f
	; Put stack value in de
	ldi a,(hl)		; $09a0
	ld e,a			; $09a1
	ldi a,(hl)		; $09a2
	ld d,a			; $09a3
	; Put function address in bc
	ldi a,(hl)		; $09a4
	ld b,(hl)		; $09a5
	ld c,a			; $09a6
	; hl <- de
	ld l,e			; $09a7
	ld h,d			; $09a8
	; Jump to bc with new stack
	ld sp,hl		; $09a9
	push bc			; $09aa
	ret			; $09ab

_initialThreadStates:
	m_ThreadState $02 $00 wThread0StackTop introThreadStart
	m_ThreadState $02 $00 wThread1StackTop stubThreadStart
	m_ThreadState $02 $00 wThread2StackTop stubThreadStart
	m_ThreadState $02 $00 wThread3StackTop paletteFadeThreadStart


; Upper bytes of addresses of flags for each group
; @addr{09cc}
flagLocationGroupTable:
	.db >wPresentRoomFlags >wPastRoomFlags
	.db >wPresentRoomFlags >wPastRoomFlags
	.db >wGroup4Flags >wGroup5Flags
	.db >wGroup4Flags >wGroup5Flags

;;
; @param	hActiveFileSlot	File index
; @addr{09d4}
initializeFile:
	ld c,$00		; $09d4
	jr ++			; $09d6

;;
; @param	hActiveFileSlot	File index
; @addr{09d8}
saveFile:
	ld c,$01		; $09d8
	jr ++			; $09da

;;
; @param	hActiveFileSlot	File index
; @addr{09dc}
loadFile:
	ld c,$02		; $09dc
	jr ++			; $09de

;;
; @param	hActiveFileSlot	File index
; @addr{09e0}
eraseFile:
	ld c,$03		; $09e0

++
	ldh a,(<hRomBank)	; $09e2
	push af			; $09e4
	callfrombank0 fileManagement.fileManagementFunction		; $09e5
	ld c,a			; $09ef
	pop af			; $09f0
	setrombank		; $09f1
	ld a,c			; $09f6
	ret			; $09f7

;;
; @addr{09f8}
vblankInterrupt:
	ldh a,(<hNextLcdInterruptBehaviour)	; $09f8
	ldh (<hLcdInterruptBehaviour),a	; $09fa
	xor a			; $09fc
	ldh (<hLcdInterruptCounter),a	; $09fd
	ld hl,hFFB7		; $09ff
	set 7,(hl)		; $0a02

	; Copy wram variables to real equivalents
	ld hl,wGfxRegsFinal		; $0a04
	ldi a,(hl)		; $0a07
	ld ($ff00+R_LCDC),a	; $0a08
	ldi a,(hl)		; $0a0a
	ld ($ff00+R_SCY),a	; $0a0b
	ldi a,(hl)		; $0a0d
	ld ($ff00+R_SCX),a	; $0a0e
	ldi a,(hl)		; $0a10
	ld ($ff00+R_WY),a	; $0a11
	ldi a,(hl)		; $0a13
	ld ($ff00+R_WX),a	; $0a14
	ldi a,(hl)		; $0a16
	ld ($ff00+R_LYC),a	; $0a17

	; increment wVBlankChecker
	inc (hl)		; $0a19
	jr nz,++

; The following code will only run when the main loop is explicitly waiting for vblank.

	ld de,wGfxRegs2		; $0a1c
	ld l,<wGfxRegs3
	ld a,(de)		; $0a21
	ldi (hl),a		; $0a22
	inc e			; $0a23
	ld a,(de)		; $0a24
	ldi (hl),a		; $0a25
	inc e			; $0a26
	ld a,(de)		; $0a27
	ldi (hl),a		; $0a28
	inc e			; $0a29
	ld a,(de)		; $0a2a
	ldi (hl),a		; $0a2b
	inc e			; $0a2c
	ld a,(de)		; $0a2d
	ldi (hl),a		; $0a2e
	inc e			; $0a2f
	ld a,(de)		; $0a30
	ldi (hl),a		; $0a31

	ld a,($ff00+R_VBK)	; $0a32
	ld b,a			; $0a34
	ld a,($ff00+R_SVBK)	; $0a35
	ld c,a			; $0a37
	push bc			; $0a38

	ldh a,(<hVBlankFunctionQueueTail)	; $0a39
	or a			; $0a3b
	call nz,runVBlankFunctions		; $0a3c

	call updateDirtyPalettes		; $0a3f

	di			; $0a42
	call hOamFunc		; $0a43

	pop bc			; $0a46
	ld a,c			; $0a47
	ld ($ff00+R_SVBK),a	; $0a48
	ld a,b			; $0a4a
	ld ($ff00+R_VBK),a	; $0a4b

	ld hl,wGfxRegs6.LCDC		; $0a4d
	ldi a,(hl)		; $0a50
	ld (wGfxRegs7.LCDC),a		; $0a51
	ldi a,(hl)		; $0a54
	ld (wGfxRegs7.SCY),a		; $0a55
	ldi a,(hl)		; $0a58
	ld (wGfxRegs7.SCX),a		; $0a59
++
	ld hl,hFFB7		; $0a5c
	res 7,(hl)		; $0a5f
	ldh a,(<hRomBank)	; $0a61
	bit 0,(hl)		; $0a63
	jr z,+
	ldh a,(<hSoundDataBaseBank2)	; $0a67
+
	ld ($2222),a		; $0a69
	pop hl			; $0a6c
	pop de			; $0a6d
	pop bc			; $0a6e
	pop af			; $0a6f
	reti			; $0a70

;;
; @addr{0a71}
runVBlankFunctions:
	ld hl,wVBlankFunctionQueue		; $0a71
--
	ldi a,(hl)		; $0a74
	push hl			; $0a75
	ld c,a			; $0a76
	ld b,$00		; $0a77
	ld hl,vblankFunctionsStart
	add hl,bc		; $0a7c
	jp hl			; $0a7d
;;
; @addr{0a7e}
vblankFunctionRet:
	ldh a,(<hVBlankFunctionQueueTail)	; $0a7e
	cp l			; $0a80
	jr nz,--

	xor a			; $0a83
	ldh (<hVBlankFunctionQueueTail),a	; $0a84
	ret			; $0a86

; Unused?
vblankFunctionOffset0:
	.db vblankFunction0a8e - vblankFunctionsStart	; $0a87

vblankRunBank4FunctionOffset:
	.db vblankRunBank4Function - vblankFunctionsStart	; $0a88

vblankCopyTileFunctionOffset:
	.db vblankCopyTileFunction - vblankFunctionsStart	; $0a89

; Unused?
vblankFunctionOffset3:
	.db vblankFunction0ad9 - vblankFunctionsStart	; $0a8a

vblankFunctionOffset4:
	.db vblankFunction0ad9 - vblankFunctionsStart 	; $0a8b

; Unused?
vblankFunctionOffset5:
	.db vblankFunction0aa8 - vblankFunctionsStart	; $0a8c

vblankDmaFunctionOffset:
	.db vblankDmaFunction - vblankFunctionsStart	; $0a8d


vblankFunctionsStart:

;;
; @addr{0a8e}
vblankFunction0a8e:
	pop hl			; $0a8e
	ldi a,(hl)		; $0a8f
	ld ($ff00+R_VBK),a	; $0a90
	ldi a,(hl)		; $0a92
	ld e,a			; $0a93
	ldi a,(hl)		; $0a94
	ld d,a			; $0a95
	ldi a,(hl)		; $0a96
	ld b,a			; $0a97
-
	ldi a,(hl)		; $0a98
	ld (de),a		; $0a99
	inc de			; $0a9a
	dec b			; $0a9b
	jr nz,-
	jr vblankFunctionRet		; $0a9e

;;
; @addr{0aa0}
vblankRunBank4Function:
	ld a,:vblankRunBank4Function_b04		; $0aa0
	ld ($2222),a		; $0aa2
	jp vblankRunBank4Function_b04		; $0aa5

;;
; @addr{0aa8}
vblankFunction0aa8:
	pop hl			; $0aa8
	ldi a,(hl)		; $0aa9
	ld c,a			; $0aaa
	ldi a,(hl)		; $0aab
	push hl			; $0aac
	ld l,c			; $0aad
	ld h,a			; $0aae
	ld bc,@return		; $0aaf
	push bc			; $0ab2
	jp hl			; $0ab3

@return:
	pop hl			; $0ab4
	jr vblankFunctionRet		; $0ab5

;;
; @addr{0ab7}
vblankCopyTileFunction:
	pop hl			; $0ab7
	ld de,vblankFunctionRet		; $0ab8
	push de			; $0abb

	xor a			; $0abc
	ld ($ff00+R_VBK),a	; $0abd
	ldi a,(hl)		; $0abf
	ld e,a			; $0ac0
	ldi a,(hl)		; $0ac1
	ld d,a			; $0ac2
	ld c,e			; $0ac3
	call @write4Bytes		; $0ac4

	ld e,c			; $0ac7
	ld a,$01		; $0ac8
	ld ($ff00+R_VBK),a	; $0aca

;;
; @param	de	Destination (vram)
; @param	hl	Source
; @addr{0acc}
@write4Bytes:
	; Write 2 bytes
	ldi a,(hl)		; $0acc
	ld (de),a		; $0acd
	inc e			; $0ace
	ldi a,(hl)		; $0acf
	ld (de),a		; $0ad0

	; Get a new value for 'e' (I guess calculating it would be too expensive during
	; vblank)
	ldi a,(hl)		; $0ad1
	ld e,a			; $0ad2

	; Write the next 2 bytes
	ldi a,(hl)		; $0ad3
	ld (de),a		; $0ad4
	inc e			; $0ad5
	ldi a,(hl)		; $0ad6
	ld (de),a		; $0ad7
	ret			; $0ad8

;;
; @addr{0ad9}
vblankFunction0ad9:
	pop hl			; $0ad9
	ldi a,(hl)		; $0ada
	ld ($ff00+R_VBK),a	; $0adb
	ldi a,(hl)		; $0add
	ld e,a			; $0ade
	ldi a,(hl)		; $0adf
	ld d,a			; $0ae0
	ldi a,(hl)		; $0ae1
	ld b,a			; $0ae2
-
	ldi a,(hl)		; $0ae3
	ld (de),a		; $0ae4
	inc de			; $0ae5
	dec b			; $0ae6
	jr nz,-
	jr vblankFunctionRet		; $0ae9

;;
; @addr{0aeb}
vblankDmaFunction:
	pop hl			; $0aeb
	ldi a,(hl)		; $0aec
	ld ($ff00+R_SVBK),a	; $0aed
	ld ($2222),a		; $0aef
	ldi a,(hl)		; $0af2
	ld ($ff00+R_HDMA1),a	; $0af3
	ldi a,(hl)		; $0af5
	ld ($ff00+R_HDMA2),a	; $0af6
	ldi a,(hl)		; $0af8
	ld ($ff00+R_VBK),a	; $0af9
	ldi a,(hl)		; $0afb
	ld ($ff00+R_HDMA3),a	; $0afc
	ldi a,(hl)		; $0afe
	ld ($ff00+R_HDMA4),a	; $0aff
	ldi a,(hl)		; $0b01
	ld ($ff00+R_HDMA5),a	; $0b02
	jp vblankFunctionRet		; $0b04



;;
; Update all palettes marked as dirty.
;
; @addr{0b07}
updateDirtyPalettes:
	ld a,$02		; $0b07
	ld ($ff00+R_SVBK),a	; $0b09

	ldh a,(<hDirtyBgPalettes)	; $0b0b
	ld d,a			; $0b0d
	xor a			; $0b0e
	ldh (<hDirtyBgPalettes),a	; $0b0f
	ld c, R_BGPI
	ld hl, w2BgPalettesBuffer
	call @writePaletteRegs		; $0b16

	ldh a,(<hDirtySprPalettes)	; $0b19
	ld d,a			; $0b1b
	xor a			; $0b1c
	ldh (<hDirtySprPalettes),a	; $0b1d
	ld c, R_OBPI
	ld l, w2SprPalettesBuffer&$ff
;;
; @addr{0b23}
@writePaletteRegs:
	srl d			; $0b23
	jr nc,++

	ld a,l			; $0b27
	or $80			; $0b28
	ld ($ff00+c),a		; $0b2a
	inc c			; $0b2b
	ldi a,(hl)		; $0b2c
	ld ($ff00+c),a		; $0b2d
	ldi a,(hl)		; $0b2e
	ld ($ff00+c),a		; $0b2f
	ldi a,(hl)		; $0b30
	ld ($ff00+c),a		; $0b31
	ldi a,(hl)		; $0b32
	ld ($ff00+c),a		; $0b33
	ldi a,(hl)		; $0b34
	ld ($ff00+c),a		; $0b35
	ldi a,(hl)		; $0b36
	ld ($ff00+c),a		; $0b37
	ldi a,(hl)		; $0b38
	ld ($ff00+c),a		; $0b39
	ldi a,(hl)		; $0b3a
	ld ($ff00+c),a		; $0b3b
	dec c			; $0b3c
	jr @writePaletteRegs	; $0b3d
++
	ret z			; $0b3f
	ld a,l			; $0b40
	add $08			; $0b41
	ld l,a			; $0b43
	jr @writePaletteRegs	; $0b44

;;
; @addr{0b46}
lcdInterrupt:
	ldh a,(<hLcdInterruptBehaviour)	; $0b46
	cp $02			; $0b48
	jr nc,@behaviour2OrHigher

	or a			; $0b4c
	ld a,($ff00+R_LY)	; $0b4d
	ld l,a			; $0b4f
	ld h,>wBigBuffer		; $0b50
	ldi a,(hl)		; $0b52
	jr nz,+

	ld ($ff00+R_SCX),a	; $0b55
	jr ++
+
	ld ($ff00+R_SCY),a	; $0b59
++
	ld a,l			; $0b5b
	cp $90			; $0b5c
	jr nc,+
	ld ($ff00+R_LYC),a	; $0b60
+
	pop hl			; $0b62
	pop af			; $0b63
	reti			; $0b64

@behaviour2OrHigher:
	push bc			; $0b65
	ld c,$03		; $0b66

	; The first time the interrupt triggers, it's always to switch between displaying
	; the status bar at the top of the screen and the actual game.
	ldh a,(<hLcdInterruptCounter)	; $0b68
	or a			; $0b6a
	jr nz,@notStatusBar
	ld hl,wGfxRegs3		; $0b6d
-
	ld a,($ff00+R_STAT)	; $0b70
	and c			; $0b72
	jr nz,-

	ldi a,(hl)		; $0b75
	ld ($ff00+R_LCDC),a	; $0b76
	ldi a,(hl)		; $0b78
	ld ($ff00+R_SCY),a	; $0b79
	ldi a,(hl)		; $0b7b
	ld ($ff00+R_SCX),a	; $0b7c
	ldi a,(hl)		; $0b7e
	ld ($ff00+R_WY),a	; $0b7f
	ldi a,(hl)		; $0b81
	ld ($ff00+R_WX),a	; $0b82
	ldi a,(hl)		; $0b84
	ld ($ff00+R_LYC),a	; $0b85
	ldh a,(<hLcdInterruptBehaviour)	; $0b87
	cp $02			; $0b89
	jr nz,+

	xor a			; $0b8d
	ldh (<hLcdInterruptBehaviour),a	; $0b8e
+
	ld a,$01		; $0b90
	ldh (<hLcdInterruptCounter),a	; $0b92
	jr _lcdInterruptEnd		; $0b94

@notStatusBar:
	ldh a,(<hLcdInterruptBehaviour)	; $0b96
	cp $07			; $0b98
	jr nc,lcdInterrupt_clearLYC	; $0b9a
	rst_jumpTable			; $0b9c
	.dw lcdInterrupt_clearLYC
	.dw lcdInterrupt_clearLYC
	.dw lcdInterrupt_clearLYC
	.dw lcdInterrupt_setLcdcToA7
	.dw lcdInterrupt_clearWXY
	.dw lcdInterrupt_ringMenu
	.dw lcdInterrupt_0bea

;;
; @addr{0bab}
lcdInterrupt_setLcdcToA7:
	ld a,($ff00+R_STAT)	; $0bab
	and c			; $0bad
	jr nz,lcdInterrupt_setLcdcToA7
	ld a,$a7		; $0bb0
	ld ($ff00+R_LCDC),a	; $0bb2
	jr lcdInterrupt_clearLYC		; $0bb4

;;
; Ring menu: LCD interrupt triggers up to two times:
;   * Once on line $47 (list menu) or $57 (appraisal menu), where the textbox starts.
;   * If on the list menu, once more on line $87, where the textbox ends.
;
; @addr{0bb6}
lcdInterrupt_ringMenu:
	ld a,($ff00+R_STAT)	; $0bb6
	and c			; $0bb8
	jr nz,lcdInterrupt_ringMenu		; $0bb9

	ld ($ff00+R_SCX),a ; SCX = 0
	ld a,$87		; $0bbd
	ld ($ff00+R_LCDC),a	; $0bbf

	ldh a,(<hLcdInterruptCounter)	; $0bc1
	dec a			; $0bc3
	jr nz,@afterTextbox

	ld a,(wRingMenu_mode)		; $0bc6
	or a			; $0bc9
	jr z,+
	ld a,$87 ; Trigger LCD interrupt again later on line $87
	ld ($ff00+R_LYC),a	; $0bce
+
	ld a,$02		; $0bd0
	ldh (<hLcdInterruptCounter),a	; $0bd2
	jr _lcdInterruptEnd		; $0bd4

@afterTextbox:
	ld a,$80		; $0bd6
	ld ($ff00+R_SCY),a	; $0bd8
	jr lcdInterrupt_clearWXY		; $0bda

;;
; @addr{0bdc}
lcdInterrupt_clearWXY:
	ld a,$c7		; $0bdc
	ld ($ff00+R_WY),a	; $0bde
	ld ($ff00+R_WX),a	; $0be0

;;
; @addr{0be2}
lcdInterrupt_clearLYC:
	ld a,$c7		; $0be2
	ld ($ff00+R_LYC),a	; $0be4
_lcdInterruptEnd:
	pop bc			; $0be6
	pop hl			; $0be7
	pop af			; $0be8
	reti			; $0be9

;;
; @addr{0bea}
lcdInterrupt_0bea:
	ld a,($ff00+R_STAT)	; $0bea
	and c			; $0bec
	jr nz,lcdInterrupt_0bea	; $0bed
	ld hl,wGfxRegs7.LCDC		; $0bef
	ldi a,(hl)		; $0bf2
	ld ($ff00+R_LCDC),a	; $0bf3
	ldi a,(hl)		; $0bf5
	ld ($ff00+R_SCY),a	; $0bf6
	ldi a,(hl)		; $0bf8
	ld ($ff00+R_SCX),a	; $0bf9
	jr lcdInterrupt_clearLYC		; $0bfb

; Table of functions in bank $04?
; @addr{0bfd}
data_0bfd:
	.dw b4VBlankFunction0
	.dw b4VBlankFunction1
	.dw b4VBlankFunction2
	.dw b4VBlankFunction3
	.dw b4VBlankFunction4
	.dw b4VBlankFunction5
	.dw b4VBlankFunction6
	.dw b4VBlankFunction7
	.dw b4VBlankFunction8
	.dw b4VBlankFunction9
	.dw b4VBlankFunction10
	.dw b4VBlankFunction11
	.dw b4VBlankFunction12
	.dw b4VBlankFunction13
	.dw b4VBlankFunction14
	.dw b4VBlankFunction15
	.dw b4VBlankFunction16
	.dw b4VBlankFunction17
	.dw b4VBlankFunction18
	.dw b4VBlankFunction19
	.dw b4VBlankFunction20
	.dw b4VBlankFunction21
	.dw b4VBlankFunction22
	.dw b4VBlankFunction23
	.dw b4VBlankFunction24
	.dw b4VBlankFunction25
	.dw b4VBlankFunction26
	.dw b4VBlankFunction27
	.dw b4VBlankFunction28
	.dw b4VBlankFunction29
	.dw b4VBlankFunction30
	.dw b4VBlankFunction31

;;
; @addr{0c3d}
serialInterrupt:
	ldh a,(<hSerialInterruptBehaviour)	; $0c3d
	or a			; $0c3f
	jr z,+

	ld a,($ff00+R_SB)	; $0c42
	ldh (<hSerialByte),a	; $0c44
	xor a			; $0c46
	ld ($ff00+R_SB),a	; $0c47
	inc a			; $0c49
	ldh (<hSerialRead),a	; $0c4a
	pop af			; $0c4c
	reti			; $0c4d
+
	ld a,($ff00+R_SB)	; $0c4e
	cp $e1			; $0c50
	jr z,+

	cp $e0			; $0c54
	jr nz,++
+
	ldh (<hSerialInterruptBehaviour),a	; $0c58
	xor a			; $0c5a
	ld ($ff00+R_SB),a	; $0c5b
	pop af			; $0c5d
	reti			; $0c5e
++
	ld a,$e1		; $0c5f
	ld ($ff00+R_SB),a	; $0c61
	ld a,$80		; $0c63
	call writeToSC		; $0c65
	pop af			; $0c68
	reti			; $0c69

;;
; Writes A to SC. Also writes $01 beforehand which might just be to reset any active
; transfers?
;
; @addr{0c6a}
writeToSC:
	push af			; $0c6a
	and $01			; $0c6b
	ld ($ff00+R_SC),a	; $0c6d
	pop af			; $0c6f
	ld ($ff00+R_SC),a	; $0c70
	ret			; $0c72

;;
; @addr{0c73}
serialFunc_0c73:
	xor a			; $0c73
	ldh (<hFFBD),a	; $0c74
	ld a,$e0		; $0c76
	ld ($ff00+R_SB),a	; $0c78
	ld a,$81		; $0c7a
	jr writeToSC		; $0c7c

;;
; @addr{0c7e}
serialFunc_0c7e:
	xor a			; $0c7e
	ldh (<hSerialInterruptBehaviour),a	; $0c7f
	ld ($ff00+R_SB),a	; $0c81
	jr writeToSC		; $0c83

;;
; @addr{0c85}
serialFunc_0c85:
	jpab bank16.func_44ac		; $0c85

;;
; @addr{0c8d}
serialFunc_0c8d:
	push de			; $0c8d
	callab bank16.func_4000		; $0c8e
	pop de			; $0c96
	ret			; $0c97

;;
; @param	a	Sound to play
; @addr{0c98}
playSound:
	or a			; $0c98
	ret z			; $0c99

	ld h,a			; $0c9a
	ldh a,(<hFFB7)	; $0c9b
	bit 3,a			; $0c9d
	ret nz			; $0c9f

	ldh a,(<hMusicQueueTail)	; $0ca0
	ld l,a			; $0ca2
	ld a,h			; $0ca3
	ld h,>wMusicQueue		; $0ca4
	ldi (hl),a		; $0ca6
	ld a,l			; $0ca7
	and $af			; $0ca8
	ldh (<hMusicQueueTail),a	; $0caa
	ret			; $0cac

;;
; @param	a	Volume (0-3)
; @addr{0cad}
setMusicVolume:
	or $80			; $0cad
	ldh (<hMusicVolume),a	; $0caf
	ret			; $0cb1

;;
; @addr{0cb2}
restartSound:
	ld bc,b39_stopSound		; $0cb2
	jr _startSound

;;
; @addr{0cb7}
initSound:
	ld bc,b39_initSound		; $0cb7

;;
; @param bc Function to call for initialization
; @addr{0cba}
_startSound:
	push de			; $0cba
	ldh a,(<hRomBank)	; $0cbb
	push af			; $0cbd
	call disableTimer		; $0cbe
	ld a,:b39_initSound		; $0cc1
	ldh (<hSoundDataBaseBank),a	; $0cc3
	ldh (<hSoundDataBaseBank2),a	; $0cc5
	setrombank		; $0cc7
	call jpBc		; $0ccc
	call enableTimer		; $0ccf
	pop af			; $0cd2
	setrombank		; $0cd3
	pop de			; $0cd8
	ret			; $0cd9

;;
; @addr{0cda}
jpBc:
	ld l,c			; $0cda
	ld h,b			; $0cdb
	jp hl			; $0cdc

;;
; @addr{0cdd}
disableTimer:
	ld hl,hFFB7		; $0cdd
	set 0,(hl)		; $0ce0
	xor a			; $0ce2
	ld ($ff00+R_TAC),a	; $0ce3
	ret			; $0ce5

;;
; @addr{0ce6}
enableTimer:
	xor a			; $0ce6
	ld ($ff00+R_TAC),a	; $0ce7
	ld a,<wMusicQueue		; $0ce9
	ldh (<hMusicQueueTail),a	; $0ceb
	ldh (<hMusicQueueHead),a	; $0ced
	ld a,($ff00+R_KEY1)	; $0cef
	rlca			; $0cf1
	ld a,$77		; $0cf2
	jr c,+
	ld a,$bb		; $0cf6
+
	ld hl,TIMA		; $0cf8
	ldi (hl),a		; $0cfb
	ldi (hl),a		; $0cfc
	xor a			; $0cfd
	ld (hl),a		; $0cfe
	set 2,(hl)		; $0cff
	ld hl,hFFB7		; $0d01
	res 0,(hl)		; $0d04
	ret			; $0d06

;;
; @addr{0d07}
timerInterrupt:
	ld hl,hFFB7		; $0d07
	bit 7,(hl)		; $0d0a
	jr nz,@interruptEnd	; $0d0c
	bit 0,(hl)		; $0d0e
	jr nz,@interruptEnd	; $0d10

	set 0,(hl)		; $0d12

	; Increment hFFB8
	inc l			; $0d14
	dec (hl)		; $0d15
	jr nz,+

	ld (hl),$07		; $0d18
	ld a,($ff00+R_TMA)	; $0d1a
	dec a			; $0d1c
	ld ($ff00+R_TIMA),a	; $0d1d
+
	ld a,:b39_updateMusicVolume		; $0d1f
	ld ($2222),a		; $0d21
	ldh a,(<hMusicVolume)	; $0d24
	bit 7,a			; $0d26
	jr z,+

	and $03			; $0d2a
	ldh (<hMusicVolume),a	; $0d2c
	call b39_updateMusicVolume		; $0d2e
+
	ldh a,(<hMusicQueueTail)	; $0d31
	ld b,a			; $0d33
	ldh a,(<hMusicQueueHead)	; $0d34
	cp b			; $0d36
	jr z,++

	ld h,>wMusicQueue		; $0d39
-
	ld l,a			; $0d3b
	ldi a,(hl)		; $0d3c
	push bc			; $0d3d
	push hl			; $0d3e
	call b39_playSound		; $0d3f
	pop hl			; $0d42
	pop bc			; $0d43
	ld a,l			; $0d44
	and $af			; $0d45
	cp b			; $0d47
	jr nz,-

	ldh (<hMusicQueueHead),a	; $0d4a
++
	call b39_updateSound		; $0d4c
	ld hl,hFFB7		; $0d4f
	res 0,(hl)		; $0d52
	ldh a,(<hRomBank)	; $0d54
	ld ($2222),a		; $0d56

@interruptEnd:
	pop hl			; $0d59
	pop de			; $0d5a
	pop bc			; $0d5b
	pop af			; $0d5c
	reti			; $0d5d

;;
; Writes data at hl to oam. First byte of data is how many objects. Each object
; has 4 bytes (y, x, tile, attributes).
;
; ff8b: internal variable (number of objects remaining)
;
; @param	hl	OAM data
; @addr{0d5e}
addSpritesToOam:
	ld bc,$0000		; $0d5e

;;
; @param	bc	Sprite offset
; @param	hl	OAM data
; @addr{0d61}
addSpritesToOam_withOffset:
	ldh a,(<hOamTail)	; $0d61
	cp $a0			; $0d63
	ret nc			; $0d65
	ld e,a			; $0d66
	ld d,>wOam		; $0d67
	ldi a,(hl)		; $0d69
	or a			; $0d6a
	ret z			; $0d6b
@next:
	ldh (<hFF8B),a	; $0d6c
	ldi a,(hl)		; $0d6e
	add b			; $0d6f
	cp $a0			; $0d70
	jr nc,@skip3Bytes	; $0d72
	ld (de),a		; $0d74
	ldi a,(hl)		; $0d75
	add c			; $0d76
	cp $a8			; $0d77
	jr nc,@skip2Bytes	; $0d79
	inc e			; $0d7b
	ld (de),a		; $0d7c
	inc e			; $0d7d
	ldi a,(hl)		; $0d7e
	ld (de),a		; $0d7f
	inc e			; $0d80
	ldi a,(hl)		; $0d81
	ld (de),a		; $0d82
	inc e			; $0d83
	ld a,e			; $0d84
	cp $a0			; $0d85
	jr nc,@end		; $0d87
@decCounter:
	ldh a,(<hFF8B)	; $0d89
	dec a			; $0d8b
	jr nz,@next		; $0d8c
	ld a,e			; $0d8e
@end:
	ldh (<hOamTail),a	; $0d8f
	ret			; $0d91

@skip3Bytes:
	inc hl			; $0d92
@skip2Bytes:
	inc hl			; $0d93
	inc hl			; $0d94
	ld a,$e0		; $0d95
	ld (de),a		; $0d97
	jr @decCounter		; $0d98

;;
; @addr{0d9a}
drawAllSprites:
	ld hl,wc4b6		; $0d9a
	bit 0,(hl)		; $0d9d
	ret nz			; $0d9f

	ld (hl),$ff		; $0da0

;;
; @addr{0da2}
drawAllSpritesUnconditionally:
	ldh a,(<hRomBank)	; $0da2
	push af			; $0da4
	call queueDrawEverything		; $0da5

.ifdef ROM_AGES
	ld a,(wLinkRaisedFloorOffset)		; $0da8
	ld hl,w1Link.yh		; $0dab
	add (hl)		; $0dae
	ld (hl),a		; $0daf
.endif

	ld de,w1Link		; $0db0

	ld b,<w1Link.yh		; $0db3
	ld a,(wTextboxFlags)		; $0db5
	and TEXTBOXFLAG_ALTPALETTE1	; $0db8
	jr z,@loop			; $0dba

	; Draw link object
	call objectQueueDraw		; $0dbc
	jr ++			; $0dbf

	; Draw w1Link, w1Companion, and w1ParentItem2-w1ParentItem5.
@loop:
	call objectQueueDraw		; $0dc1
	inc d			; $0dc4
	ld a,d			; $0dc5
	cp $d6			; $0dc6
	jr c,@loop			; $0dc8
++
	; Update the puddle animation
	ld a,:terrainEffects.puddleAnimationFrames		; $0dca
	setrombank		; $0dcc

	; Every 16 frames, the animation changes
	ld a,(wFrameCounter)		; $0dd1
	add a			; $0dd4
	swap a			; $0dd5
	and $03			; $0dd7
	ld hl,terrainEffects.puddleAnimationFrames		; $0dd9
	rst_addDoubleIndex			; $0ddc

	ldi a,(hl)		; $0ddd
	ld (wPuddleAnimationPointer),a		; $0dde
	ldi a,(hl)		; $0de1
	ld (wPuddleAnimationPointer+1),a		; $0de2

	; Write a "jp" opcode to wRamFunction
	ld hl,wRamFunction		; $0de5
	; Jump
	ld a,$c3		; $0de8
	ldi (hl),a		; $0dea
	; Jump to _getObjectPositionOnScreen
	ld a,<_getObjectPositionOnScreen
	ldi (hl),a		; $0ded
	ld (hl),>_getObjectPositionOnScreen

	ld a,(wScrollMode)		; $0df0
	cp $08			; $0df3
	jr nz,++

	; Or if a screen transition is occuring, jump to _getObjectPositionOnScreen_duringScreenTransition
	ld a,>_getObjectPositionOnScreen_duringScreenTransition
	ldd (hl),a		; $0df9
	ld (hl),<_getObjectPositionOnScreen_duringScreenTransition

	; Load some variables (hFF90-hFF93) for the
	; _getObjectPositionOnScreen_duringScreenTransition function
	xor a			; $0dfc
	ld b,a			; $0dfd
	inc a			; $0dfe
	ldh (<hFF8A),a	; $0dff
	ld a,(wRoomIsLarge)		; $0e01
	or a			; $0e04
	jr z,+
	ld a,$04		; $0e07
+
	ld c,a			; $0e09
	ld a,(wScreenTransitionDirection)		; $0e0a
	add c			; $0e0d
	add a			; $0e0e
	add a			; $0e0f
	ld c,a			; $0e10
	ld hl,data_1058		; $0e11
	add hl,bc		; $0e14
	ldi a,(hl)		; $0e15
	ldh (<hFF90),a	; $0e16
	ldi a,(hl)		; $0e18
	ldh (<hFF91),a	; $0e19
	ldi a,(hl)		; $0e1b
	ldh (<hFF92),a	; $0e1c
	ldi a,(hl)		; $0e1e
	ldh (<hFF93),a	; $0e1f
++

	; Draw all queued objects
	ld hl,wObjectsToDraw	; $0e21
-
	ld a,(hl)		; $0e24
	or a			; $0e25
	call nz,@drawObject		; $0e26
	inc l			; $0e29
	inc l			; $0e2a
	bit 7,l			; $0e2b
	jr z,-

	; Draw pending terrain effects (shadows)
	ld hl,wTerrainEffectsBuffer		; $0e2f
	ldh a,(<hTerrainEffectsBufferUsedSize)	; $0e32
	rrca			; $0e34
	srl a			; $0e35
	ld b,a			; $0e37
	jr z,++
-
	push bc			; $0e3a
	ldi a,(hl)		; $0e3b
	ldh (<hFF8C),a	; $0e3c
	ldi a,(hl)		; $0e3e
	ldh (<hFF8D),a	; $0e3f
	ldi a,(hl)		; $0e41
	push hl			; $0e42
	ld h,(hl)		; $0e43
	ld l,a			; $0e44
	call func_0eda		; $0e45
	pop hl			; $0e48
	inc l			; $0e49
	pop bc			; $0e4a
	dec b			; $0e4b
	jr nz,-
++

	; Clear all unused OAM entries
	ldh a,(<hOamTail)	; $0e4e
	cp $a0			; $0e50
	jr nc,++

	ld h,>wOam		; $0e54
	ld b,$e0		; $0e56
-
	ld l,a			; $0e58
	ld (hl),b		; $0e59
	add $04			; $0e5a
	cp $a0			; $0e5c
	jr c,-
++

.ifdef ROM_AGES
	; Undo link's Y offset for drawing
	ld a,(wLinkRaisedFloorOffset)		; $0e60
	cpl			; $0e63
	inc a			; $0e64
	ld hl,w1Link.yh		; $0e65
	add (hl)		; $0e68
	ld (hl),a		; $0e69
.endif

	pop af			; $0e6a
	setrombank		; $0e6b
	ret			; $0e70

;;
; @param hl Address in wObjectsToDraw.
; @addr{0e71}
@drawObject:
	push hl			; $0e71
	inc l			; $0e72
	ld h,(hl)		; $0e73
	ld l,a			; $0e74
	; hl now points to the object's y-position.

	; This is equivalent to either
	; "call _getObjectPositionOnScreen" or
	; "call _getObjectPositionOnScreen_duringScreenTransition".
	call wRamFunction		; $0e75
	jr nc,@return		; $0e78

	; hl points to Object.oamFlags
	ldi a,(hl)		; $0e7a
	ldh (<hFF8F),a	; $0e7b

	; Object.oamTileIndexBase
	ldi a,(hl)		; $0e7d
	ldh (<hFF8E),a	; $0e7e

	; Object.oamDataAddress
	ldi a,(hl)		; $0e80
	ld h,(hl)		; $0e81
	ld l,a			; $0e82

	; Get address, bank of animation frame data
	ld a,h			; $0e83
	and $c0			; $0e84
	rlca			; $0e86
	rlca			; $0e87
	add BASE_OAM_DATA_BANK			; $0e88
	setrombank		; $0e8a
	set 6,h			; $0e8f
	res 7,h			; $0e91

	; Check how many sprites are to be drawn, load it into c
	ldi a,(hl)		; $0e93
	or a			; $0e94
	jr z,@return		; $0e95

	ld c,a			; $0e97

	; Get first available OAM index, or return if it's full
	ldh a,(<hOamTail)	; $0e98
	ld e,a			; $0e9a
	ld a,<wOamEnd		; $0e9b
	sub e			; $0e9d
	jr z,@return		; $0e9e

	; Set b to the number of available OAM slots, will return if this
	; reaches zero
	rrca			; $0ea0
	rrca			; $0ea1
	ld b,a			; $0ea2

	ld d,>wOam		; $0ea3
	; b = # available slots,
	; c = # sprites to be drawn,
	; de points to OAM,
	; hl points to animation frame data

@nextSprite:
	; Y position
	ldh a,(<hFF8C)	; $0ea5
	add (hl)		; $0ea7
	inc hl			; $0ea8
	cp $a0			; $0ea9
	jr nc,@incHlToNextSprite	; $0eab
	ld (de),a		; $0ead

	; X position
	ldh a,(<hFF8D)	; $0eae
	add (hl)		; $0eb0
	cp $a8			; $0eb1
	jr nc,@incHlToNextSprite	; $0eb3

	inc e			; $0eb5
	ld (de),a		; $0eb6

	; Tile index
	inc hl			; $0eb7
	inc e			; $0eb8
	ldh a,(<hFF8E)	; $0eb9
	add (hl)		; $0ebb
	ld (de),a		; $0ebc

	; Flags
	inc hl			; $0ebd
	inc e			; $0ebe
	ldh a,(<hFF8F)	; $0ebf
	xor (hl)		; $0ec1
	ld (de),a		; $0ec2

	inc hl			; $0ec3
	inc e			; $0ec4
	dec b			; $0ec5
	jr z,@doneDrawing			; $0ec6

	dec c			; $0ec8
	jr nz,@nextSprite	; $0ec9

@doneDrawing:
	ld a,e			; $0ecb
	ldh (<hOamTail),a	; $0ecc
@return:
	pop hl			; $0ece
	ld (hl),$00		; $0ecf
	ret			; $0ed1

@incHlToNextSprite:
	inc hl			; $0ed2
	inc hl			; $0ed3
	inc hl			; $0ed4
	dec c			; $0ed5
	jr nz,@nextSprite	; $0ed6
	jr @doneDrawing		; $0ed8

;;
; This function is similar to @drawObject above, except it simply draws raw OAM
; data which isn't associated with a particular object. It has a rather
; specific purpose, hence the hard-coded bank number.
; @param hl Address of oam data
; @param hFF8C Y-position to draw at
; @param hFF8D X-position to draw at
; @addr{0eda}
func_0eda:
	ld a,:terrainEffects.shadowAnimation		; $0eda
	setrombank		; $0edc

	; Get the end of used OAM, get how many sprites are to be drawn, check
	; if there's enough space
	ldh a,(<hOamTail)	; $0ee1
	ld e,a			; $0ee3
	ldi a,(hl)		; $0ee4
	ld c,a			; $0ee5
	add a			; $0ee6
	add a			; $0ee7
	add e			; $0ee8
	cp <wOamEnd+1			; $0ee9
	jr nc,@end		; $0eeb
	ld d,>wOam		; $0eed

@nextSprite:
	; Y-position
	ldh a,(<hFF8C)	; $0eef
	add (hl)		; $0ef1
	ld (de),a		; $0ef2
	inc hl			; $0ef3
	inc e			; $0ef4

	; X-position
	ldh a,(<hFF8D)	; $0ef5
	add (hl)		; $0ef7
	ld (de),a		; $0ef8
	inc hl			; $0ef9
	inc e			; $0efa

	; Tile index
	ldi a,(hl)		; $0efb
	ld (de),a		; $0efc
	inc e			; $0efd

	; Flags
	ldi a,(hl)		; $0efe
	ld (de),a		; $0eff
	inc e			; $0f00

	dec c			; $0f01
	jr nz,@nextSprite		; $0f02

	ld a,e			; $0f04
	ldh (<hOamTail),a	; $0f05
@end:
	ret			; $0f07

;;
; Draw an object's shadow, or grass / puddle animation as necessary.
; @param	b	Value of hCameraY?
; @param	e	Object's Z position
; @param	hl	Pointer to object
; @param	[hFF8C]	Y-position
; @param	[hFF8D]	X-position
; @addr{0f08}
_drawObjectTerrainEffects:
	ld a,(wAreaFlags)		; $0f08
	and AREAFLAG_SIDESCROLL
	ret nz			; $0f0d

	ld a,b			; $0f0e
	cp $97			; $0f0f
	ret nc			; $0f11

	bit 7,e			; $0f12
	jr z,@onGround

@inAir:
	; Return every other frame (creates flickering effect)
	ld a,(wFrameCounter)		; $0f16
	xor h			; $0f19
	rrca			; $0f1a
	ret nc			; $0f1b

	; Add an entry to wTerrainEffectsBuffer to queue a shadow for drawing
	push hl			; $0f1c
	ldh a,(<hTerrainEffectsBufferUsedSize)	; $0f1d
	add <wTerrainEffectsBuffer			; $0f1f
	ld l,a			; $0f21
	ld h,>wTerrainEffectsBuffer		; $0f22
	ldh a,(<hFF8C)		; $0f24
	ldi (hl),a		; $0f26
	ldh a,(<hFF8D)		; $0f27
	ldi (hl),a		; $0f29
	ld a,<terrainEffects.shadowAnimation		; $0f2a
	ldi (hl),a		; $0f2c
	ld a,>terrainEffects.shadowAnimation		; $0f2d
	ldi (hl),a		; $0f2f
	ld a,l			; $0f30
	sub <wTerrainEffectsBuffer			; $0f31
	ldh (<hTerrainEffectsBufferUsedSize),a	; $0f33
	pop hl			; $0f35
	ret			; $0f36

@onGround:
	ld a,(wScrollMode)		; $0f37
	cp $08			; $0f3a
	ret z			; $0f3c
	push hl			; $0f3d
	ld a,l			; $0f3e
	and $c0			; $0f3f
	add $0b			; $0f41
	ld l,a			; $0f43
	ldi a,(hl)		; $0f44
	ld b,a			; $0f45
	add $05			; $0f46
	and $f0			; $0f48
	ld c,a			; $0f4a
	inc l			; $0f4b
	ld l,(hl)		; $0f4c
	ld a,l			; $0f4d
	xor b			; $0f4e
	ld h,a			; $0f4f
	ld a,l			; $0f50
	and $f0			; $0f51
	swap a			; $0f53
	or c			; $0f55
	ld c,a			; $0f56
	ld b,>wRoomLayout		; $0f57
	ld a,(bc)		; $0f59

.ifdef ROM_AGES
	cp TILEINDEX_GRASS			; $0f5a
	jr z,@walkingInGrass
	cp TILEINDEX_PUDDLE			; $0f5e
	jr nz,@end		; $0f60

.else ; ROM_SEASONS
	; Seasons has multiple grass and shallow water tiles, so this checks ranges
	; instead of exact values
	cp TILEINDEX_GRASS
	jr c,@end
	cp TILEINDEX_WATER
	jr nc,@end
	cp TILEINDEX_PUDDLE
	jr c,@walkingInGrass
.endif

@walkingInPuddle:
	inc e			; $0f62
	ld hl,wPuddleAnimationPointer		; $0f63
	ldi a,(hl)		; $0f66
	ld h,(hl)		; $0f67
	ld l,a			; $0f68
	jr @grassOrWater

@walkingInGrass:
	bit 2,h			; $0f6b
	ld a,(wGrassAnimationModifier)		; $0f6d
	jr z,+
	add $24			; $0f72
+
	ld c,a			; $0f74
	ld b,$00		; $0f75
	ld hl,terrainEffects.greenGrassAnimationFrame0		; $0f77
	add hl,bc		; $0f7a

@grassOrWater:
	push de			; $0f7b
	call func_0eda		; $0f7c
	pop de			; $0f7f

@end:
	pop hl			; $0f80
	ret			; $0f81

;;
; Get the position where an object should be drawn on-screen, accounting for
; screen scrolling. Clears carry flag if the object is not visible.
; @param[in] hl Pointer to an object's y-position.
; @param[out] hl Pointer to the object's Object.oamFlags variable.
; @param[out] hFF8C Y position to draw the object
; @param[out] hFF8D X position to draw the object
; @addr{0f82}
_getObjectPositionOnScreen:
	ldh a,(<hCameraX)	; $0f82
	ld c,a			; $0f84
	ldh a,(<hCameraY)	; $0f85
	ld b,a			; $0f87

	; Object.yh
	ldi a,(hl)		; $0f88
	sub b			; $0f89
	add $10			; $0f8a
	ldh (<hFF8C),a	; $0f8c
	ld d,a			; $0f8e

	; Object.xh
	inc l			; $0f8f
	ldi a,(hl)		; $0f90
	sub c			; $0f91
--
	ldh (<hFF8D),a	; $0f92

	; Object.zh
	inc l			; $0f94
	ld e,(hl)		; $0f95

	; Return if not visible (bit 7 of Object.visible unset)
	ld a,l			; $0f96
	and $c0			; $0f97
	add Object.visible		; $0f99
	ld l,a			; $0f9b
	ld a,(hl)		; $0f9c
	rlca			; $0f9d
	ret nc			; $0f9e

	; Draw shadows and stuff if bit 6 is set
	rlca			; $0f9f
	call c,_drawObjectTerrainEffects		; $0fa0

	; Account for Z position
	ld a,d			; $0fa3
	add e			; $0fa4
	ldh (<hFF8C),a	; $0fa5

	; Point hl to the Object.oamFlags variable
	ld a,l			; $0fa7
	and $c0			; $0fa8
	add Object.oamFlags		; $0faa
	ld l,a			; $0fac

	scf			; $0fad
	ret			; $0fae

;;
; @addr{0faf}
_label_00_152:
	ldh a,(<hCameraX)	; $0faf
	ld c,a			; $0fb1
	ldh a,(<hCameraY)	; $0fb2
	ld b,a			; $0fb4
	ldi a,(hl)		; $0fb5
	sub b			; $0fb6
	add $10			; $0fb7
	ldh (<hFF8C),a	; $0fb9
	ld d,a			; $0fbb
	inc l			; $0fbc
	ldi a,(hl)		; $0fbd
	sub c			; $0fbe
	jr --

;;
; This function takes the place of "_getObjectPositionOnScreen" during screen
; transitions.
; Clears carry flag if the object shouldn't be drawn for whatever reason.
; @param[in]	hl	Pointer to an object's y-position.
; @param[in]	hFF8A	Bitset on Object.enabled to check (always $01?)
; @param[in]	hFF90-hFF93
; @param[out]	hl	Pointer to the object's Object.oamFlags variable.
; @param[out]	hFF8C	Y position to draw the object
; @param[out]	hFF8D	X position to draw the object
; @addr{0fc1}
_getObjectPositionOnScreen_duringScreenTransition:
	ld d,h			; $0fc1
	ld a,l			; $0fc2
	and $c0			; $0fc3
	ld e,a			; $0fc5
	ld a,(de)		; $0fc6
	and $03			; $0fc7
	cp $03			; $0fc9
	jr z,_label_00_152	; $0fcb

	; Read Object.yh
	ld d,$00		; $0fcd
	ldi a,(hl)		; $0fcf
	add $10			; $0fd0
	ld c,a			; $0fd2
	ld a,d			; $0fd3
	adc a			; $0fd4
	ld b,a			; $0fd5

	; Read Object.xh
	inc l			; $0fd6
	ldi a,(hl)		; $0fd7
	ld e,a			; $0fd8
	push hl			; $0fd9

	; Check Object.enabled is set (hFF8A is always $01 here?)
	ld a,l			; $0fda
	and $c0			; $0fdb
	ld l,a			; $0fdd
	ldh a,(<hFF8A)	; $0fde
	and (hl)		; $0fe0
	jr z,+

	ld hl,hFF90		; $0fe3
	ldi a,(hl)		; $0fe6
	add c			; $0fe7
	ld c,a			; $0fe8
	ldi a,(hl)		; $0fe9
	adc b			; $0fea
	ld b,a			; $0feb
	ldi a,(hl)		; $0fec
	add e			; $0fed
	ld e,a			; $0fee
	ldi a,(hl)		; $0fef
	adc d			; $0ff0
	ld d,a			; $0ff1
+
	ld hl,hCameraY		; $0ff2
	ld a,c			; $0ff5
	sub (hl)		; $0ff6
	ld c,a			; $0ff7
	inc l			; $0ff8
	ld a,b			; $0ff9
	sbc (hl)		; $0ffa
	ld b,a			; $0ffb
	jr z,+

	inc a			; $0ffe
	jr nz,@dontDraw		; $0fff
	ld a,c			; $1001
	cp $e0			; $1002
	jr c,@dontDraw		; $1004
	jr ++
+
	ld a,c			; $1008
	cp $b0			; $1009
	jr nc,@dontDraw		; $100b
++
	; This write seems mostly pointless, although it could be necessary for
	; the call to _drawObjectTerrainEffects? (This gets overwritten later)
	ldh (<hFF8C),a	; $100d

	ld b,a			; $100f
	inc l			; $1010
	ld a,e			; $1011
	sub (hl)		; $1012
	ld e,a			; $1013
	inc l			; $1014
	ld a,d			; $1015
	sbc (hl)		; $1016
	ld d,a			; $1017
	jr z,+

	inc a			; $101a
	jr nz,@dontDraw		; $101b
	ld a,e			; $101d
	cp $e8			; $101e
	jr c,@dontDraw		; $1020
	jr ++
+
	ld a,e			; $1024
	cp $b8			; $1025
	jr nc,@dontDraw		; $1027
++
	ldh (<hFF8D),a	; $1029
	ld d,b			; $102b
	pop hl			; $102c
	inc l			; $102d
	ld e,(hl)		; $102e
	ld a,l			; $102f
	and $c0			; $1030
	add Object.visible			; $1032
	ld l,a			; $1034
	ld a,(hl)		; $1035
	rlca			; $1036
	ret nc			; $1037

	; Draw shadows and stuff if bit 6 is set
	rlca			; $1038
	call c,_drawObjectTerrainEffects		; $1039

	ld a,d			; $103c
	add e			; $103d
	ldh (<hFF8C),a	; $103e
	ld a,l			; $1040
	and $c0			; $1041
	add Object.oamFlags			; $1043
	ld l,a			; $1045
	scf			; $1046
	ret			; $1047

@dontDraw:
	pop hl			; $1048
	ld a,l			; $1049
	and $c0			; $104a
	ld l,a			; $104c
	bit 1,(hl)		; $104d
	jr z,+

	or Object.visible			; $1051
	ld l,a			; $1053
	ld (hl),$00		; $1054
+
	xor a			; $1056
	ret			; $1057

; Something to do with sprite positions during screen transitions. 4 bytes get written to
; hFF90-hFF93, and the values are used in
; _getObjectPositionOnScreen_duringScreenTransition.
; @addr{1058}
data_1058:
	; Small rooms
	.db $80 $ff $00 $00 ; scrolling up
	.db $00 $00 $a0 $00 ; scrolling right
	.db $80 $00 $00 $00 ; scrolling down
	.db $00 $00 $60 $ff ; scrolling left
	; Large rooms
	.db $50 $ff $00 $00 ; scrolling up
	.db $00 $00 $f0 $00 ; scrolling right
	.db $b0 $00 $00 $00 ; scrolling down
	.db $00 $00 $10 $ff ; scrolling left

;;
; Call objectQueueDraw on everything, except $d0-$d5 objects at $00-$3f (Link, Companion,
; and "ParentItems").
; @addr{1078}
queueDrawEverything:
	ld hl,hTerrainEffectsBufferUsedSize		; $1078
	xor a			; $107b
	ldi (hl),a		; $107c
	ldi (hl),a		; $107d
	ldi (hl),a		; $107e
	ldi (hl),a		; $107f
	ldi (hl),a		; $1080

	ld de,FIRST_ITEM_INDEX<<8		; $1081
	ld b,Item.yh		; $1084
	call @func		; $1086

	ld de,$d080		; $1089
	ld b,Enemy.yh		; $108c
	call @func		; $108e

	ld de,$d0c0		; $1091
	ld b,Part.yh		; $1094
	call @func		; $1096

	ld de,$d040		; $1099
	ld b,Interaction.yh		; $109c
@func:
	call objectQueueDraw		; $109e
	inc d			; $10a1
	ld a,d			; $10a2
	cp $e0			; $10a3
	jr c,@func
	ret			; $10a7

;;
; @param	b	Low byte of the address of the Object.yh variable
; @param	de	Start address of object to draw
; @addr{10a8}
objectQueueDraw:
	ld a,(de)		; $10a8
	or a			; $10a9
	ret z			; $10aa

	ld a,e			; $10ab
	or Object.visible		; $10ac
	ld l,a			; $10ae
	ld h,d			; $10af
	ld a,(hl)		; $10b0
	bit 7,a			; $10b1
	ret z			; $10b3

	and $03			; $10b4
	ld h,a			; $10b6
	add <hObjectPriority0Counter	; $10b7
	ld c,a			; $10b9
	ld a,($ff00+c)		; $10ba
	cp $10			; $10bb
	ret nc			; $10bd

	; Write the object's address to the appropriate position in
	; wObjectsToDraw, increment the ObjectPriorityCounter.
	inc a			; $10be
	ld ($ff00+c),a		; $10bf
	dec a			; $10c0
	swap h			; $10c1
	add h			; $10c3
	add a			; $10c4
	ld l,a			; $10c5
	ld h,>wObjectsToDraw	; $10c6
	ld a,b			; $10c8
	ldi (hl),a		; $10c9
	ld (hl),d		; $10ca
	ret			; $10cb

;;
; Gets the data for a chest in the current room.
; Defaults to position $00, contents $2800 if a chest is not found.
; @param	bc	Chest contents
; @param	e	Chest position
; @addr{10cc}
getChestData:
	ldh a,(<hRomBank)	; $10cc
	push af			; $10ce
	ld a,:bank16.chestDataGroupTable		; $10cf
	setrombank		; $10d1
	ld a,(wActiveGroup)		; $10d6
	ld hl,bank16.chestDataGroupTable	; $10d9
	rst_addDoubleIndex			; $10dc
	ldi a,(hl)		; $10dd
	ld h,(hl)		; $10de
	ld l,a			; $10df
	ld a,(wActiveRoom)		; $10e0
	ld b,a			; $10e3
-
	ldi a,(hl)		; $10e4
	ld e,a			; $10e5
	inc a			; $10e6
	jr z,@chestNotFound

	ldi a,(hl)		; $10e9
	cp b			; $10ea
	jr z,+

	inc hl			; $10ed
	inc hl			; $10ee
	jr -
+
	ld b,(hl)		; $10f1
	inc hl			; $10f2
	ld c,(hl)		; $10f3
	jr @end

@chestNotFound:
	ld bc,$2800		; $10f6

@end:
	pop af			; $10f9
	setrombank		; $10fa
	ret			; $10ff

;;
; Set Link's death respawn point based on the current room / position variables.
; @addr{1100}
setDeathRespawnPoint:
	ld hl,wDeathRespawnBuffer		; $1100
	ld a,(wActiveGroup)		; $1103
	ldi (hl),a		; $1106
	ld a,(wActiveRoom)		; $1107
	ldi (hl),a		; $110a
	ld a,(wRoomStateModifier)		; $110b
	ldi (hl),a		; $110e
	ld a,(w1Link.direction)		; $110f
	ldi (hl),a		; $1112
	ld a,(w1Link.yh)		; $1113
	ldi (hl),a		; $1116
	ld a,(w1Link.xh)		; $1117
	ldi (hl),a		; $111a
	ld a,(wRememberedCompanionId)		; $111b
	ldi (hl),a		; $111e
	ld a,(wRememberedCompanionGroup)		; $111f
	ldi (hl),a		; $1122
	ld a,(wRememberedCompanionRoom)		; $1123
	ldi (hl),a		; $1126
	ld a,(wLinkObjectIndex)		; $1127
	ldi (hl),a		; $112a
	inc l			; $112b
	ld a,(wRememberedCompanionY)		; $112c
	ldi (hl),a		; $112f
	ld a,(wRememberedCompanionX)		; $1130
	ldi (hl),a		; $1133
	ret			; $1134

;;
; @addr{1135}
func_1135:
	xor a			; $1135
	ld (wDeathRespawnBuffer.rememberedCompanionGroup),a		; $1136
	ret			; $1139

;;
; @addr{113a}
updateLinkLocalRespawnPosition:
	ld a,(wLinkObjectIndex)		; $113a
	ld h,a			; $113d
	ld l,<w1Link.direction
	ld a,(hl)		; $1140
	ld (wLinkLocalRespawnDir),a		; $1141
	ld l,<w1Link.yh
	ld a,(hl)		; $1146
	ld (wLinkLocalRespawnY),a		; $1147
	ld l,<w1Link.xh
	ld a,(hl)		; $114c
	ld (wLinkLocalRespawnX),a		; $114d
	ret			; $1150

;;
; Updates room flags when a tile is broken. For some tiles, this involves setting the room
; flags in more than one room, to mark a door as open on both sides.
;
; @param	a	Tile that was broken
; @addr{1151}
updateRoomFlagsForBrokenTile:
	push af			; $1151
	ld hl,_unknownTileCollisionTable	; $1152
	call lookupCollisionTable		; $1155
	call c,addToGashaMaturity		; $1158

	pop af			; $115b
	ld hl,_tileUpdateRoomFlagsOnBreakTable	; $115c
	call lookupCollisionTable		; $115f
	ret nc			; $1162

	bit 7,a			; $1163
	jp nz,setRoomFlagsForUnlockedKeyDoor		; $1165

	bit 6,a			; $1168
	jp nz,setRoomFlagsForUnlockedKeyDoor_overworldOnly		; $116a

	and $0f			; $116d
	ld bc,bitTable		; $116f
	add c			; $1172
	ld c,a			; $1173
	ld a,(wActiveGroup)		; $1174
	ld hl, flagLocationGroupTable
	rst_addAToHl			; $117a
	ld h,(hl)		; $117b
	ld a,(wActiveRoom)		; $117c
	ld l,a			; $117f
	ld a,(bc)		; $1180
	or (hl)			; $1181
	ld (hl),a		; $1182
	ret			; $1183


; This is a list of tiles that will cause certain room flag bits to be set when destroyed.
; (In order for this to work, the corresponding bit in the "_breakableTileModes" table
; must be set so that it calls the above function.)
_tileUpdateRoomFlagsOnBreakTable:
	.dw @collisions0
	.dw @collisions1
	.dw @collisions2
	.dw @collisions3
	.dw @collisions4
	.dw @collisions5

; Data format:
; b0: tile index
; b1: bit 7:    Set if it's a door linked between two rooms in a dungeon (will update the
;               room flags in both rooms)
;     bit 6:    Set if it's a door linked between two rooms in the overworld
;     bits 0-3: If bit 6 or 7 is set, this is the "direction" of the room link (times 4).
;               If bits 6 and 7 aren't set, this is the bit to set in the room flags (ie.
;               value of 2 will set bit 2).

.ifdef ROM_AGES

@collisions0:
@collisions4:
	.db $c6 $07
	.db $c7 $07
	.db $c9 $07
	.db $c1 $07
	.db $c2 $07
	.db $c4 $07
	.db $cb $07
	.db $d1 $07
	.db $cf $07
	.db $00
@collisions1:
	.db $30 $00
	.db $31 $44
	.db $32 $02
	.db $33 $4c
	.db $00
@collisions2:
@collisions5:
	.db $30 $80
	.db $31 $84
	.db $32 $88
	.db $33 $8c
	.db $38 $80
	.db $39 $84
	.db $3a $88
	.db $3b $8c
	.db $68 $84
	.db $69 $8c
@collisions3:
	.db $00


.else ; ROM_SEASONS


@collisions0:
	.db $c6 $07
	.db $c1 $07
	.db $c2 $07
	.db $e3 $07
@collisions1:
	.db $e2 $07
	.db $cb $07
	.db $c5 $07
@collisions2:
	.db $00

@collisions3:
	.db $30 $00
	.db $31 $44
	.db $32 $02
	.db $33 $4c
	.db $00

@collisions4:
	.db $30 $80
	.db $31 $84
	.db $32 $88
	.db $33 $8c
	.db $38 $80
	.db $39 $84
	.db $3a $88
	.db $3b $8c
@collisions5:
	.db $00

.endif


; Seems to list some breakable tiles similar to the table above?
_unknownTileCollisionTable:
	.dw @collisions0
	.dw @collisions1
	.dw @collisions2
	.dw @collisions3
	.dw @collisions4
	.dw @collisions5

; Data format:
; b0: tile index
; b1: amount to add to wGashaMaturity?

.ifdef ROM_AGES

@collisions0:
@collisions4:
	.db $c7 50
	.db $c2 50
	.db $cb 50
	.db $d1 50
	.db $cf 30
	.db $c6 30
	.db $c4 30
	.db $c9 30
	.db $00
@collisions1:
	.db $30 100
	.db $31 100
	.db $32 100
	.db $33 100
	.db $00
@collisions2:
@collisions5:
	.db $30 50
	.db $31 50
	.db $32 50
	.db $33 50
	.db $38 100
	.db $39 100
	.db $3a 100
	.db $3b 100
	.db $68 50
	.db $69 50
@collisions3:
	.db $00


.else ; ROM_SEASONS


@collisions0:
	.db $c6 $32
	.db $c2 $32
	.db $e3 $32
@collisions1:
	.db $e2 $32
	.db $cb $1e
	.db $c5 $1e
@collisions2:
	.db $00

@collisions3:
	.db $30 $64
	.db $31 $64
	.db $32 $64
	.db $33 $64
	.db $00

@collisions4:
	.db $30 $32
	.db $31 $32
	.db $32 $32
	.db $33 $32
	.db $38 $64
	.db $39 $64
	.db $3a $64
	.db $3b $64
@collisions5:
	.db $00

.endif


;;
; Marks a key door as unlocked by writing to the room flags, and checks for the adjacent
; room to unlock the other side of the door as well.
;
; @param	a	Direction of door (times 4) (upper 4 bits are ignored)
; @addr{11fc}
setRoomFlagsForUnlockedKeyDoor:
	and $0f			; $11fc
	ld de,_adjacentRoomsData		; $11fe
	call addAToDe		; $1201
	ld a,(wDungeonIndex)		; $1204
	cp $ff			; $1207
	jr z,@notInDungeon

	; Set the flag in the first room
	call getActiveRoomFromDungeonMapPosition		; $120b
	call @setRoomFlag		; $120e

	; Calculate the position of the second room, and set the corresponding flag there
	inc de			; $1211
	ld a,(wDungeonMapPosition)		; $1212
	ld l,a			; $1215
	ld a,(de)		; $1216
	add l			; $1217
	call getRoomInDungeon		; $1218
	inc de			; $121b

@setRoomFlag:
	ld c,a			; $121c
	ld a,(wDungeonFlagsAddressH)		; $121d
	ld b,a			; $1220
	ld a,(de)		; $1221
	ld l,a			; $1222
	ld a,(bc)		; $1223
	or l			; $1224
	ld (bc),a		; $1225
	ret			; $1226

@notInDungeon:
	call getThisRoomFlags		; $1227
	ld a,(de)		; $122a
	or (hl)			; $122b
	ld (hl),a		; $122c
	ret			; $122d

; Data format:
; b0: Room flag to set in first room
; b1: Value to add to wDungeonMapPosition to get the adjacent room
; b2: Room flag to set in second room
; b3: Unused
; @addr{122e}
_adjacentRoomsData:
	.db $01 $f8 $04 $00 ; Key door going up
	.db $02 $01 $08 $00 ; Key door going right
	.db $04 $08 $01 $00 ; Key door going down
	.db $08 $ff $02 $00 ; Key door going left

;;
; This function differs from the above one in that:
; * It only works for the PRESENT OVERWORLD.
; * The above, which CAN work for the overworlds, only sets the flag on the one screen
;   when used on the overworld; the adjacent room doesn't get updated.
; * This only works for rooms connected horizontally, since it uses the table above for
;   dungeons which assumes that vertical rooms are separated by $08 instead of $10.
;
; @param	a	Direction of door (times 4) (upper 4 bits are ignored)
; @addr{123e}
setRoomFlagsForUnlockedKeyDoor_overworldOnly:
	and $0f			; $123e
	ld hl,_adjacentRoomsData		; $1240
	rst_addAToHl			; $1243
	ld a,(wActiveRoom)		; $1244
	ld c,a			; $1247
	ld b,>wPresentRoomFlags		; $1248
	ld a,(bc)		; $124a
	or (hl)			; $124b
	ld (bc),a		; $124c
	inc hl			; $124d
	ldi a,(hl)		; $124e
	add c			; $124f
	ld c,a			; $1250
	ld a,(bc)		; $1251
	or (hl)			; $1252
	ld (bc),a		; $1253
	ret			; $1254

;;
; Allows link to walk through chests when he's already inside one.
; @addr{1255}
checkAndUpdateLinkOnChest:
	ld a,(wLinkOnChest)		; $1255
	or a			; $1258
	jr nz,++

	ld a,(wActiveTileIndex)		; $125b
	cp TILEINDEX_CHEST
	ret nz			; $1260

	ld a,(wActiveTilePos)		; $1261
	ld (wLinkOnChest),a		; $1264
	ld l,a			; $1267
	ld h,>wRoomCollisions	; $1268
	ld (hl),$00		; $126a
	ret			; $126c
++
	ld c,a			; $126d
	ld a,(wActiveTilePos)		; $126e
	cp c			; $1271
	ret z			; $1272

	ld b,>wRoomLayout
	ld a,(bc)		; $1275
	call retrieveTileCollisionValue		; $1276
	dec b			; $1279
	ld (bc),a		; $127a
	xor a			; $127b
	ld (wLinkOnChest),a		; $127c
	ret			; $127f

;;
; @param[out]	cflag	Set if Link interacted with a tile that should disable some of his
;			code? (Opened a chest, read a sign, opened an overworld keyhole)
; @addr{1280}
interactWithTileBeforeLink:
	ldh a,(<hRomBank)	; $1280
	push af			; $1282
	callfrombank0 bank6.interactWithTileBeforeLink		; $1283
	rl c			; $128d
	pop af			; $128f
	setrombank		; $1290
	srl c			; $1295
	ret			; $1297

;;
; Shows TX_510a ("It's too heavy to move") if it hasn't been shown already.
; @addr{1298}
showInfoTextForRoller:
	ldh a,(<hRomBank)	; $1298
	push af			; $129a
	ld a,:bank6.showInfoTextForTile		; $129b
	setrombank		; $129d
	ld a,$09		; $12a2
	call bank6.showInfoTextForTile		; $12a4
	pop af			; $12a7
	setrombank		; $12a8
	ret			; $12ad

;;
; @addr{12ae}
updateCamera:
	ld a,(wScrollMode)		; $12ae
	and $05			; $12b1
	ret z			; $12b3

	ldh a,(<hRomBank)	; $12b4
	push af			; $12b6
	callfrombank0 bank1.updateCameraPosition		; $12b7
	call          bank1.updateGfxRegs2Scroll		; $12c1
	call          bank1.updateScreenShake		; $12c4
	pop af			; $12c7
	setrombank		; $12c8
	ret			; $12cd

;;
; @addr{12ce}
resetCamera:
	ldh a,(<hRomBank)	; $12ce
	push af			; $12d0
	callfrombank0 bank1.calculateCameraPosition		; $12d1
	call          bank1.updateGfxRegs2Scroll		; $12db
	pop af			; $12de
	setrombank		; $12df
	ret			; $12e4

;;
; @addr{12e5}
setCameraFocusedObject:
	ldh a,(<hActiveObject)	; $12e5
	ld (wCameraFocusedObject),a		; $12e7
	ldh a,(<hActiveObjectType)	; $12ea
	ld (wCameraFocusedObjectType),a		; $12ec
	ret			; $12ef

;;
; @addr{12f0}
setCameraFocusedObjectToLink:
	ld a,(wLinkObjectIndex)		; $12f0
	ld (wCameraFocusedObject),a		; $12f3
	ld a,$00		; $12f6
	ld (wCameraFocusedObjectType),a		; $12f8
	ret			; $12fb

;;
; Reloads tile map for the room from w3VramTiles, w3VramAttributes.
; @addr{12fc}
reloadTileMap:
	ldh a,(<hRomBank)	; $12fc
	push af			; $12fe
	xor a			; $12ff
	ld (wScreenOffsetY),a		; $1300
	ld (wScreenOffsetX),a		; $1303
	ld a,UNCMP_GFXH_10		; $1306
	call loadUncompressedGfxHeader		; $1308
	callfrombank0 bank1.setScreenTransitionState02		; $130b
	call          bank1.updateGfxRegs2Scroll		; $1315
	pop af			; $1318
	setrombank		; $1319
	ret			; $131e

;;
; Called whenever entering an area with a fadein transition.
; @addr{131f}
func_131f:
	xor a			; $131f
	ld (wScreenOffsetY),a		; $1320
	ld (wScreenOffsetX),a		; $1323
	ldh a,(<hRomBank)	; $1326
	push af			; $1328
	callfrombank0 bank1.initializeRoomBoundaryAndLoadAnimations		; $1329
	call          bank1.setScreenTransitionState02		; $1333
	call          loadTilesetAndRoomLayout		; $1336

.ifdef ROM_AGES
	ld a,(wcddf)		; $1339
	or a			; $133c
	jr z,+

	callab func_04_6ed1		; $133f
	callab func_04_6f31		; $1347
	ld a,UNCMP_GFXH_30		; $134f
	call loadUncompressedGfxHeader		; $1351
	jr ++
.endif

+
	call loadRoomCollisions		; $1356
	call generateVramTilesWithRoomChanges		; $1359
	ld a,UNCMP_GFXH_10		; $135c
	call loadUncompressedGfxHeader		; $135e
++
	ld a,(wAreaPalette)		; $1361
	ld (wLoadedAreaPalette),a		; $1364
	ld a,(wAreaUniqueGfx)		; $1367
	ld (wLoadedAreaUniqueGfx),a		; $136a
	pop af			; $136d
	setrombank		; $136e
	ret			; $1373

;;
; @addr{1374}
loadAreaAnimation:
	ld a,(wLoadedAreaAnimation)		; $1374
	ld b,a			; $1377
	ld a,(wAreaAnimation)		; $1378
	cp b			; $137b
	ret z			; $137c
	ld (wLoadedAreaAnimation),a		; $137d
	jp loadAnimationData		; $1380

;;
; Seasons-only function
;
; @addr{1383}
func_1383:

.ifdef ROM_SEASONS
	push de			; $1324
	ld ($cc4c),a		; $1325
	ld a,b			; $1328
	ld (wScreenTransitionDirection),a		; $1329
	ld a,($ff00+$70)	; $132c
	ld c,a			; $132e
	ld a,($ff00+$97)	; $132f
	ld b,a			; $1331
	push bc			; $1332
	ld a,$08		; $1333
	ld ($cd00),a		; $1335
	ld a,$03		; $1338
	ld ($cd04),a		; $133a
	xor a			; $133d
	ld ($cd05),a		; $133e
	ld ($cd06),a		; $1341
	ld a,$01		; $1344
	ld ($ff00+$97),a	; $1346
	ld ($2222),a		; $1348
	call $4956		; $134b
	call $4964		; $134e
	call applyWarpDest		; $1351
	call loadAreaData		; $1354
	ld a,($cc4c)		; $1357
	ld ($cc4b),a		; $135a
	call loadTilesetAndRoomLayout		; $135d
	call loadRoomCollisions		; $1360
	call generateVramTilesWithRoomChanges		; $1363
	pop bc			; $1366
	ld a,b			; $1367
	ld ($ff00+$97),a	; $1368
	ld ($2222),a		; $136a
	ld a,c			; $136d
	ld ($ff00+$70),a	; $136e
	pop de			; $1370
	ret			; $1371

.else ; ROM_AGES
	ret
.endif

;;
; Loads w2WaveScrollValues to make the screen sway in a sine wave.
;
; @param	a	Amplitude
; @addr{1384}
initWaveScrollValues:
	ldh (<hFF93),a	; $1384
	ld a,($ff00+R_SVBK)	; $1386
	ld c,a			; $1388
	ldh a,(<hRomBank)	; $1389
	ld b,a			; $138b
	push bc			; $138c
	ld a,:bank1.initWaveScrollValues_body		; $138d
	setrombank		; $138f
	ldh a,(<hFF93)	; $1394
	ld c,a			; $1396
	call bank1.initWaveScrollValues_body		; $1397
	pop bc			; $139a
	ld a,b			; $139b
	setrombank		; $139c
	ld a,c			; $13a1
	ld ($ff00+R_SVBK),a	; $13a2
	ret			; $13a4

;;
; Loads wBigBuffer with the values from w2WaveScrollValues (offset based on
; wFrameCounter). The LCD interrupt will read from there when configured properly.
;
; @param	a	Affects the frequency of the wave?
; @addr{13a5}
loadBigBufferScrollValues:
	ldh (<hFF93),a	; $13a5
	ld a,($ff00+R_SVBK)	; $13a7
	ld c,a			; $13a9
	ldh a,(<hRomBank)	; $13aa
	ld b,a			; $13ac
	push bc			; $13ad
	ld a,:bank1.loadBigBufferScrollValues_body		; $13ae
	setrombank		; $13b0
	ldh a,(<hFF93)	; $13b5
	ld b,a			; $13b7
	call bank1.loadBigBufferScrollValues_body		; $13b8
	pop bc			; $13bb
	ld a,b			; $13bc
	setrombank		; $13bd
	ld a,c			; $13c2
	ld ($ff00+R_SVBK),a	; $13c3
	ret			; $13c5

;;
; @param	bc	Pointer to palette data?
; @param	hl	Pointer to palette data?
; @addr{13c6}
func_13c6:
	ldh a,(<hRomBank)	; $13c6
	push af			; $13c8
	ld a,:w2ColorComponentBuffer1		; $13c9
	ld ($ff00+R_SVBK),a	; $13cb
	push de			; $13cd
	push bc			; $13ce
	ld de,w2ColorComponentBuffer1		; $13cf
	call extractColorComponents		; $13d2
	pop hl			; $13d5
	ld de,w2ColorComponentBuffer2		; $13d6
	call extractColorComponents		; $13d9
	pop de			; $13dc
	pop af			; $13dd
	setrombank		; $13de
	xor a			; $13e3
	ld ($ff00+R_SVBK),a	; $13e4
	jp startFadeBetweenTwoPalettes		; $13e6

;;
; This function appears to extract the color components from $30 colors ($c palettes).
; This is probably used for palette fades.
;
; @param	de	Destination to write colors to
; @param	hl	First palette to extract from
; @addr{13e9}
extractColorComponents:
	ldh a,(<hRomBank)	; $13e9
	push af			; $13eb
	ld a,:paletteDataStart	; $13ec
	setrombank		; $13ee
	ld b,$30		; $13f3
--
	ld c,(hl)		; $13f5
	inc hl			; $13f6
	ld a,(hl)		; $13f7
	sla c			; $13f8
	rla			; $13fa
	rl c			; $13fb
	rla			; $13fd
	rl c			; $13fe
	rla			; $1400
	and $1f			; $1401
	ld (de),a		; $1403
	inc e			; $1404
	ldd a,(hl)		; $1405
	rra			; $1406
	rra			; $1407
	and $1f			; $1408
	ld (de),a		; $140a
	inc e			; $140b
	ldi a,(hl)		; $140c
	and $1f			; $140d
	ld (de),a		; $140f
	inc e			; $1410
	inc hl			; $1411
	dec b			; $1412
	jr nz,--

	pop af			; $1415
	setrombank		; $1416
	ret			; $141b

;;
; Similar to setTile, except this won't reload the tile's graphics at vblank.
;
; This is only ever actually used by setTile itself.
;
; @param	a	Value to change tile to
; @param	c	Position of tile to change
; @addr{141c}
setTileWithoutGfxReload:
	ld b,>wRoomLayout	; $141c
	ld (bc),a		; $141e
	call retrieveTileCollisionValue		; $141f
	ld b,>wRoomCollisions
	ld (bc),a		; $1424
	ret			; $1425

;;
; @param	b	New index for tile
; @param	c	Position to change
; @addr{1426}
setTileInRoomLayoutBuffer:
	ld a,($ff00+R_SVBK)	; $1426
	push af			; $1428
	ld a,:w3RoomLayoutBuffer	; $1429
	ld ($ff00+R_SVBK),a	; $142b
	ld a,b			; $142d
	ld b,>w3RoomLayoutBuffer	; $142e
	ld (bc),a		; $1430
	pop af			; $1431
	ld ($ff00+R_SVBK),a	; $1432
	ret			; $1434

;;
; Gets the type of tile at the object's position plus bc (b=y, c=x).
;
; @param	bc	Offset to add to object's position
; @param[out]	a	The tile at position bc
; @param[out]	hl	The tile's address in wRoomLayout
; @addr{1435}
objectGetRelativeTile:
	ldh a,(<hActiveObjectType)	; $1435
	or Object.yh
	ld l,a			; $1439
	ld h,d			; $143a
	ldi a,(hl)		; $143b
	add b			; $143c
	ld b,a			; $143d
	inc l			; $143e
	ldi a,(hl)		; $143f
	add c			; $1440
	ld c,a			; $1441
	jr getTileAtPosition

;;
; Gets the tile index the object is on.
;
; @param[in]	d	Object
; @param[out]	a	The tile at the object's position
; @param[out]	hl	The tile's address in wRoomLayout
; @addr{1444}
objectGetTileAtPosition:
	call objectGetPosition		; $1444
;;
; @param[in]	bc	The position to check (format: YYXX)
; @param[out]	a	The tile at position bc
; @param[out]	hl	The tile's address in wRoomLayout
; @addr{1447}
getTileAtPosition:
	ld a,c			; $1447
	and $f0			; $1448
	swap a			; $144a
	ld l,a			; $144c
	ld a,b			; $144d
	and $f0			; $144e
	or l			; $1450
	ld l,a			; $1451
	ld h,>wRoomLayout
	ld a,(hl)		; $1454
	ret			; $1455

;;
; Returns the direction of a type of tile if it's adjacent to the object, or $ff if that
; tile is not adjacent.
;
; @param	a	Tile to check for adjacency
; @param[out]	a	The direction of the tile relative to the object, or $ff.
; @addr{1456}
objectGetRelativePositionOfTile:
	ldh (<hFF8B),a	; $1456
	call objectGetShortPosition		; $1458
	ld e,a			; $145b
	ld h,>wRoomLayout

	ld a,$f0		; $145e
	call @checkTileAtOffset		; $1460
	ld a,DIR_UP
	ret z			; $1465

	ld a,$01		; $1466
	call @checkTileAtOffset		; $1468
	ld a,DIR_RIGHT
	ret z			; $146d

	ld a,$10		; $146e
	call @checkTileAtOffset		; $1470
	ld a,DIR_DOWN
	ret z			; $1475

	ld a,$ff		; $1476
	call @checkTileAtOffset		; $1478
	ld a,DIR_LEFT
	ret z			; $147d

	ld a,$ff		; $147e
	ret			; $1480

;;
; @param	a	Offset to add to 'e'
; @param	e	Position of object
; @param[out]	zflag	Set if the tile is at that position.
; @addr{1481}
@checkTileAtOffset:
	add e			; $1481
	ld l,a			; $1482
	ldh a,(<hFF8B)	; $1483
	cp (hl)			; $1485
	ret			; $1486

;;
; Seems to return 1 (zero flag unset) if the object is on a solid part of a tile. Accounts
; for quarter tiles.
;
; This will NOT work for collision values $10 and above.
;
; @param[out]	zflag	Set if there is no collision.
; @addr{1487}
objectCheckSimpleCollision:
	ldh a,(<hActiveObjectType)	; $1487
	or Object.yh
	ld l,a			; $148b
	ld h,d			; $148c

	; Load YX into bc, put shortened YX into 'l'.
	ld b,(hl)		; $148d
	inc l			; $148e
	inc l			; $148f
	ld c,(hl)		; $1490
	ld a,b			; $1491
	and $f0			; $1492
	ld l,a			; $1494
	ld a,c			; $1495
	swap a			; $1496
	and $0f			; $1498
	or l			; $149a
	ld l,a			; $149b

	ld h,>wRoomCollisions
	ld a,(hl)		; $149e

	; Set zero flag based on which quarter of the tile the object is on
	bit 3,b			; $149f
	jr nz,+
	rrca			; $14a3
	rrca			; $14a4
+
	bit 3,c			; $14a5
	jr nz,+
	rrca			; $14a9
+
	and $01			; $14aa
	ret			; $14ac

;;
; Get the collision value of the tile the object is on.
;
; @param[out]	a	Collision value
; @param[out]	hl	Address of collision data
; @param[out]	zflag	Set if there is no collision.
; @addr{14ad}
objectGetTileCollisions:
	ldh a,(<hActiveObjectType)	; $14ad
	or Object.yh
	ld l,a			; $14b1
	ld h,d			; $14b2

	; Load YX into bc
	ld b,(hl)		; $14b3
	inc l			; $14b4
	inc l			; $14b5
	ld c,(hl)		; $14b6

;;
; @param	bc	Position
; @param[out]	a	Collision value
; @param[out]	hl	Address of collision data
; @param[out]	zflag	Set if there is no collision.
; @addr{14b7}
getTileCollisionsAtPosition:
	ld a,b			; $14b7
	and $f0			; $14b8
	ld l,a			; $14ba
	ld a,c			; $14bb
	swap a			; $14bc
	and $0f			; $14be
	or l			; $14c0
	ld l,a			; $14c1

	ld h,>wRoomCollisions	; $14c2
	ld a,(hl)		; $14c4
	or a			; $14c5
	ret			; $14c6

;;
; Checks if the object is colliding with a tile.
;
; This accounts for quarter-tiles as well as "special collisions" (collision value $10 or
; higher). Meant for link and items, as it allows passage through holes and lava (enemies
; should be prevented from doing that).
;
; @param[out]	cflag	Set on collision
; @addr{14c7}
objectCheckTileCollision_allowHoles:
	ldh a,(<hActiveObjectType)	; $14c7
	or Object.yh
	ld l,a			; $14cb
	ld h,d			; $14cc

	; Load YX into bc
	ld b,(hl)		; $14cd
	inc l			; $14ce
	inc l			; $14cf
	ld c,(hl)		; $14d0

;;
; Same as above function, but with explicit YX.
;
; @param	bc	YX position to check
; @addr{14d1}
checkTileCollisionAt_allowHoles:
	; Put shortened YX into 'l'
	ld a,b			; $14d1
	and $f0			; $14d2
	ld l,a			; $14d4
	ld a,c			; $14d5
	swap a			; $14d6
	and $0f			; $14d8
	or l			; $14da
	ld l,a			; $14db

;;
; @addr{14dc}
checkTileCollision_allowHoles:
	ld h,>wRoomCollisions	; $14dc
	ld a,(hl)		; $14de

;;
; @param	a	Collision value
; @param	bc	YX position to check
; @addr{14df}
checkGivenCollision_allowHoles:
	cp $10			; $14df
	jr c,_simpleCollision	; $14e1

	ld hl,@specialCollisions		; $14e3
	jr _complexCollision		; $14e6

; See constants/specialCollisionValues.s for what each of these bytes is for.
; ie. The first defined byte is for holes.
@specialCollisions:
	.db %00000000 %11000011 %00000011 %11000000 %00000000 %11000011 %11000011 %00000000
	.db %00000000 %11000011 %00000011 %11000000 %11000000 %11000001 %11111111 %00000000

;;
; Same as above functions, but for enemies that shouldn't be allowed to cross holes or
; water tiles.
;
; @addr{14f8}
objectCheckTileCollision_disallowHoles:
	ldh a,(<hActiveObjectType)	; $14f8
	or Object.yh
	ld l,a			; $14fc
	ld h,d			; $14fd

	; Load YX into bc
	ld b,(hl)		; $14fe
	inc l			; $14ff
	inc l			; $1500
	ld c,(hl)		; $1501

;;
; @param	bc	YX position to check
; @addr{1502}
checkTileCollisionAt_disallowHoles:
	; Put shortened YX into 'l'
	ld a,b			; $1502
	and $f0			; $1503
	ld l,a			; $1505
	ld a,c			; $1506
	swap a			; $1507
	and $0f			; $1509
	or l			; $150b
	ld l,a			; $150c

;;
; @addr{150d}
checkTileCollision_disallowHoles:
	ld h,>wRoomCollisions	; $150d
	ld a,(hl)		; $150f

;;
; @param	a	Collision value
; @addr{1510}
checkGivenCollision_disallowHoles:
	cp $10			; $1510
	jr c,_simpleCollision	; $1512
	ld hl,@specialCollisions
	jr _complexCollision		; $1517

@specialCollisions:
	.db %11111111 %11000011 %00000011 %11000000 %00000000 %11000011 %11000011 %00000000
	.db %00000000 %11000011 %00000011 %11000000 %11000001 %11000001 %11111111 %11111111

;;
; @param	bc	Full position to check
; @param	l	Shortened position (where the tile is)
; @addr{1529}
checkCollisionPosition_disallowSmallBridges:
	ld h,>wRoomCollisions	; $1529
	ld a,(hl)		; $152b
	cp $10			; $152c
	jr c,_simpleCollision	; $152e
	ld hl,@specialCollisions		; $1530
	jr _complexCollision		; $1533

@specialCollisions:
	.db %00000000 %11111111 %00000011 %11000000 %11000011 %11000011 %11000011 %00000000
	.db %00000000 %11111111 %00000011 %11000000 %11000001 %11000001 %11111111 %00000000

; Sets carry flag if the object is not in a wall?
_simpleCollision:
	bit 3,b			; $1545
	jr nz,+
	rrca			; $1549
	rrca			; $154a
+
	bit 3,c			; $154b
	jr nz,+
	rrca			; $154f
+
	rrca			; $1550
	ret			; $1551

; @param	bc	Position
; @param	hl
; @param[out]	cflag	Set on collision?
; @param[out]	zflag	Unset on collision?
_complexCollision:
	push de			; $1552
	and $0f			; $1553
	ld e,a			; $1555
	ld d,$00		; $1556

	add hl,de		; $1558
	ld e,(hl)		; $1559
	cp $08			; $155a
	ld a,b			; $155c
	jr nc,+
	ld a,c			; $155f
+
	rrca			; $1560
	and $07			; $1561
	ld hl,bitTable		; $1563
	add l			; $1566
	ld l,a			; $1567
	ld a,(hl)		; $1568
	and e			; $1569
	pop de			; $156a
	ret z			; $156b
	scf			; $156c
	ret			; $156d

;;
; Get tile collision value from buffer in bank 3, not wRoomCollisions
; @addr{156e}
retrieveTileCollisionValue:
	ld h,>w3TileCollisions	; $156e
	ld l,a			; $1570
	ld a,:w3TileCollisions
	ld ($ff00+R_SVBK),a	; $1573
	ld l,(hl)		; $1575
	xor a			; $1576
	ld ($ff00+R_SVBK),a	; $1577
	ld a,l			; $1579
	ret			; $157a

;;
; Load data into wRoomCollisions based on wRoomLayout and w3TileCollisions
; @addr{157b}
loadRoomCollisions:
	ld a,:w3TileCollisions	; $157b
	ld ($ff00+R_SVBK),a	; $157d
	ld d,>w3TileCollisions
	ld hl,wRoomLayout		; $1581
	ld b,LARGE_ROOM_HEIGHT*$10
-
	ld a,(hl)		; $1586
	ld e,a			; $1587
	ld a,(de)		; $1588
	dec h			; $1589
	ldi (hl),a		; $158a
	inc h			; $158b
	dec b			; $158c
	jr nz,-

	call @blankDataAroundCollisions		; $158f
	xor a			; $1592
	ld ($ff00+R_SVBK),a	; $1593
	ret			; $1595

;;
; Blanks data around the "edges" of wRoomCollisions.
; @addr{1596}
@blankDataAroundCollisions:
	ld hl, wRoomCollisions+$f0		; $1596
	call @blankDataHorizontally		; $1599
	ld hl, wRoomCollisions+$0f		; $159c
	call @blankDataVertically		; $159f
	ld a,(wActiveGroup)		; $15a2
	cp NUM_SMALL_GROUPS
	jr c,+
	ld l,LARGE_ROOM_HEIGHT*$10
	jr @blankDataHorizontally
+
	ld l,SMALL_ROOM_HEIGHT*$10
	call @blankDataHorizontally		; $15af
	ld l,SMALL_ROOM_WIDTH
	jr @blankDataVertically

@blankDataHorizontally:
	ld a,$ff		; $15b6
	ld b,$10		; $15b8
-
	ldi (hl),a		; $15ba
	dec b			; $15bb
	jr nz,-
	ret			; $15be

@blankDataVertically:
	ld b,LARGE_ROOM_HEIGHT
	ld c,$ff		; $15c1
-
	ld (hl),c		; $15c3
	ld a,l			; $15c4
	add $10			; $15c5
	ld l,a			; $15c7
	dec b			; $15c8
	jr nz,-
	ret			; $15cb

;;
; @param	a	Tile to find in the room
; @param[out]	hl	Address of the tile in wRoomLayout (if it was found)
; @param[out]	zflag	Set if the tile was found.
; @addr{15cc}
findTileInRoom:
	ld h,>wRoomLayout	; $15cc
	ld l,LARGE_ROOM_HEIGHT*$10+$0f

;;
; @param	a	Value to search for
; @param	hl	Address to start the search at (end when 'l' reaches 0)
; @param[out]	hl	Address of the value (if it was found)
; @param[out]	zflag	Set if the value was found.
; @addr{15d0}
backwardsSearch:
	cp (hl)			; $15d0
	ret z			; $15d1
	dec l			; $15d2
	jr nz,backwardsSearch

	cp (hl)			; $15d5
	ret			; $15d6

;;
; Gets the collision data for the tile at c based on w3RoomLayoutBuffer (so, the original
; room layout?)
;
; @param[in]	a	Position of tile
; @param[out]	a	Tile value from w3RoomLayoutBuffer
; @param[out]	b	The tile's collision value
; @param[out]	c	Position of tile (passed in as A)
; @param[out]	cflag	Set carry flag if the tile's collision value is between $1 and $f
;			(at least partially solid)
; @addr{15d7}
getTileIndexFromRoomLayoutBuffer:
	ld c,a			; $15d7

;;
; @addr{15d8}
getTileIndexFromRoomLayoutBuffer_paramC:
	ld a,($ff00+R_SVBK)	; $15d8
	push af			; $15da
	ld a,:w3RoomLayoutBuffer	; $15db
	ld ($ff00+R_SVBK),a	; $15dd
	ld b,>w3RoomLayoutBuffer	; $15df
	ld a,(bc)		; $15e1
	ld e,a			; $15e2
	ld a,:w3TileCollisions
	ld ($ff00+R_SVBK),a	; $15e5
	ld l,e			; $15e7
	ld h,>w3TileCollisions
	ld b,(hl)		; $15ea
	pop af			; $15eb
	ld ($ff00+R_SVBK),a	; $15ec
	ld a,b			; $15ee
	cp $10			; $15ef
	jr nc,++

	or a			; $15f3
	jr z,++

	scf			; $15f6
	ld a,e			; $15f7
	ret			; $15f8
++
	ld a,e			; $15f9
	ret			; $15fa

;;
; Load an interaction's graphics and initialize the animation.
; @param[out] c
; @addr{15fb}
interactionInitGraphics:
	ldh a,(<hRomBank)	; $15fb
	push af			; $15fd
	callfrombank0 bank3f.interactionLoadGraphics		; $15fe
	ld c,a			; $1608
	pop af			; $1609
	setrombank		; $160a
	ld a,c			; $160f
	jp interactionSetAnimation		; $1610

;;
; @addr{1613}
func_1613:
	ld a,(wLoadedTreeGfxIndex)		; $1613
	or a			; $1616
	ret z			; $1617
;;
; @addr{1618}
refreshObjectGfx:
	ldh a,(<hRomBank)	; $1618
	push af			; $161a
	callfrombank0 bank3f.refreshObjectGfx_body		; $161b
	xor a			; $1625
	ld (wLoadedTreeGfxIndex),a		; $1626
	pop af			; $1629
	setrombank		; $162a
	ret			; $162f

;;
; @addr{1630}
reloadObjectGfx:
	ldh a,(<hRomBank)	; $1630
	push af			; $1632
	callfrombank0 bank3f.reloadObjectGfx	; $1633
	pop af			; $163d
	setrombank		; $163e
	ret			; $1643

;;
; Forces an object gfx header to be loaded into slot 4 (address 0:8800). Handy way to load
; extra graphics, but uses up object slots. Used by the pirate ship and various things in
; seasons, but apparently unused in ages.
;
; @param	e	Object gfx header (minus 1)
; @addr{1644}
loadObjectGfxHeaderToSlot4:
	ldh a,(<hRomBank)	; $1644
	push af			; $1646
	callfrombank0 bank3f.loadObjectGfxHeaderToSlot4_body		; $1647
	pop af			; $1651
	setrombank		; $1652
	ret			; $1657

;;
; @param	a	Tree gfx index
; @addr{1658}
loadTreeGfx:
	ld e,a			; $1658
	ldh a,(<hRomBank)	; $1659
	push af			; $165b
	callfrombank0 bank3f.loadTreeGfx_body	; $165c
	pop af			; $1666
	setrombank		; $1667
	ret			; $166c

;;
; @param	a	Uncompressed gfx header to load
; @addr{166d}
loadWeaponGfx:
	ld e,a			; $166d
	ldh a,(<hRomBank)	; $166e
	push af			; $1670
	callfrombank0 bank3f.loadWeaponGfx		; $1671
	pop af			; $167b
	setrombank		; $167c
	ret			; $1681

;;
; Loads $20 tiles of gfx data from the 3-byte pointer at hl.
; Ultimate gfx destination is (b<<8).
; Uses DMA, and buffers at 4:dc00 and 4:de00, for safe transfers.
;
; @param	b	High byte of destination to write gfx to (low byte is $00)
; @param	hl	Address to read from to get the index to load
; @addr{1682}
loadObjectGfx:
	ld d,b			; $1682
	ld e,$00		; $1683
	ldi a,(hl)		; $1685
;;
; @param a
; @param de
; @param hl
; @addr{1685}
loadObjectGfx2:
	ld c,a			; $1686
	ldi a,(hl)		; $1687
	ld l,(hl)		; $1688
	and $7f			; $1689
	ld h,a			; $168b

.ifdef ROM_AGES
	ld a,($cc20)		; $168c
	or a			; $168f
	jr nz,@label_00_192	; $1690
.endif

	push de			; $1692
	ld a,($cc07)		; $1693
	xor $ff			; $1696
	ld ($cc07),a		; $1698
	ld de,w4GfxBuf1 | :w4GfxBuf1	; $169b
	jr nz,+			; $169e
	ld de,w4GfxBuf2 | :w4GfxBuf2	; $16a0
+
	push de			; $16a3
	ld b,$1f		; $16a4
	call decompressGraphics		; $16a6
	pop hl			; $16a9
	pop de			; $16aa
	ld c,:w4GfxBuf1		; $16ab
	ld a,$01		; $16ad
	ld ($ff00+R_SVBK),a	; $16af
	ld a,$3f		; $16b1
	setrombank		; $16b3
	ld b,$1f		; $16b8
	jp queueDmaTransfer		; $16ba

.ifdef ROM_AGES

@label_00_192:
	ld a,d			; $16bd
	or $d0			; $16be
	ld d,a			; $16c0
	ld a,$05		; $16c1
	add e			; $16c3
	ld e,a			; $16c4
	ld b,$1f		; $16c5
	call decompressGraphics		; $16c7
	ld a,$01		; $16ca
	ld ($ff00+R_SVBK),a	; $16cc
	ld a,$3f		; $16ce
	setrombank		; $16d0
	ret			; $16d5
.endif

;;
; Load graphics for an item (as in, items on the inventory screen)
;
; @param a Item index
; @addr{16d6}
loadTreasureDisplayData:
	ld l,a			; $16d6
	ldh a,(<hRomBank)	; $16d7
	push af			; $16d9
	callfrombank0 bank3f.loadTreasureDisplayData		; $16da
	pop af			; $16e4
	setrombank		; $16e5
	ret			; $16ea

;;
; @param[out]	c
; @param[out]	zflag
; @addr{16eb}
func_16eb:
	ld c,a			; $16eb
	ldh a,(<hRomBank)	; $16ec
	push af			; $16ee
	callfrombank0 bank3f.func_4744	; $16ef
	pop af			; $16f9
	setrombank		; $16fa
	ld a,c			; $16ff
	cp $ff			; $1700
	ret			; $1702

;;
; Checks whether an item drop of a given type can spawn.
;
; @param	a	Item drop index (see constants/itemDrops.s)
; @param[out]	zflag	z if item cannot spawn (Link doesn't have it)
; @addr{1703}
checkItemDropUnavailable:
	ld c,a			; $1703
	ldh a,(<hRomBank)	; $1704
	push af			; $1706
	ld a,:bank3f.checkItemDropUnavailable_body		; $1707
	setrombank		; $1709
	ld a,c			; $170e
	call bank3f.checkItemDropUnavailable_body		; $170f
	pop af			; $1712
	setrombank		; $1713
	ld a,c			; $1718
	cp $ff			; $1719
	ret			; $171b

;;
; @param	a	Treasure for Link to obtain (see constants/treasure.s)
; @param	c	Parameter (ie. item level, ring index, etc...)
; @param[out]	a	Sound to play on obtaining the treasure (if nonzero)
; @addr{171c}
giveTreasure:
	ld b,a			; $171c
	ldh a,(<hRomBank)	; $171d
	push af			; $171f
	callfrombank0 bank3f.giveTreasure_body		; $1720
	pop af			; $172a
	setrombank		; $172b
	ld a,b			; $1730
	or a			; $1731
	ret			; $1732

;;
; @param	a	Treasure for Link to lose (see constants/treasure.s)
; @addr{1733}
loseTreasure:
	ld b,a			; $1733
	ldh a,(<hRomBank)	; $1734
	push af			; $1736
	callfrombank0 bank3f.loseTreasure_body		; $1737
	pop af			; $1741
	setrombank		; $1742
	ret			; $1747

;;
; @param	a	Item to check for (see constants/treasure.s)
; @param[out]	cflag	Set if you have that item
; @param[out]	a	The value of the treasure's "related variable" (ie. item level)
; @addr{1748}
checkTreasureObtained:
	push hl			; $1748
	ld l,a			; $1749
	or a			; $174a
	jr z,++			; $174b

	ldh a,(<hRomBank)	; $174d
	push af			; $174f
	callfrombank0 bank3f.checkTreasureObtained_body	; $1750
	pop af			; $175a
	setrombank		; $175b
	ld a,l			; $1760
	srl h			; $1761
++
	pop hl			; $1763
	ret			; $1764


.ifdef ROM_SEASONS
;;
; Same as below but for ore chunks.
cpOreChunkValue:
	ld hl,wNumOreChunks
	jr ++
.endif

;;
; Compares the current total rupee count with a value from the "getRupee" function.
;
; @param	a	Rupee type to compare with
; @param[out]	a	0 if Link has at least that many rupees, 1 otherwise
; @param[out]	zflag	Set if Link has that many rupees
; @addr{1765}
cpRupeeValue:
	ld hl,wNumRupees		; $1765
++
	call getRupeeValue		; $1768
	ldi a,(hl)		; $176b
	ld h,(hl)		; $176c
	ld l,a			; $176d
	call compareHlToBc		; $176e
	inc a			; $1771
	jr nz,+			; $1772

	inc a			; $1774
	ret			; $1775
+
	xor a			; $1776
	ret			; $1777


.ifdef ROM_SEASONS
;;
removeOreChunkValue:
	ld hl,wNumOreChunks
	jr ++
.endif

;;
; Remove the value of a kind of rupee from your wallet.
;
; @param	a	The type of rupee to lose (not the value)
; @addr{1778}
removeRupeeValue:
	ld hl,wNumRupees		; $1778
++
	call getRupeeValue		; $177b
	jp subDecimalFromHlRef		; $177e

;;
; @param	a	The "type" of rupee you're getting.
; @param[out]	bc	The amount of rupees you get from it
; @addr{1781}
getRupeeValue:
	push hl			; $1781
	cp RUPEEVAL_COUNT-1			; $1782
	jr c,+			; $1784
	ld a,RUPEEVAL_COUNT-1			; $1786
+
	ld hl,@rupeeValues		; $1788
	rst_addDoubleIndex			; $178b
	ldi a,(hl)		; $178c
	ld b,(hl)		; $178d
	ld c,a			; $178e
	pop hl			; $178f
	ret			; $1790

; Each number here corresponds to a value in constants/rupeeValues.s.
; @addr{1791}
@rupeeValues:
	.dw $0000 ; $00
	.dw $0001 ; $01
	.dw $0002 ; $02
	.dw $0005 ; $03
	.dw $0010 ; $04
	.dw $0020 ; $05
	.dw $0040 ; $06
	.dw $0030 ; $07
	.dw $0060 ; $08
	.dw $0070 ; $09
	.dw $0025 ; $0a
	.dw $0050 ; $0b
	.dw $0100 ; $0c
	.dw $0200 ; $0d
	.dw $0400 ; $0e
	.dw $0150 ; $0f
	.dw $0300 ; $10
	.dw $0500 ; $11
	.dw $0900 ; $12
	.dw $0080 ; $13
	.dw $0999 ; $14

;;
; @param	a	Seed type to decrement
; @addr{17bb}
decNumActiveSeeds:
	and $07			; $17bb
	ld hl,wNumEmberSeeds		; $17bd
	rst_addAToHl			; $17c0
	jr +				; $17c1

;;
; @addr{17c3}
decNumBombchus:
	ld hl,wNumBombchus		; $17c3
	jr +				; $17c6

;;
; @addr{17c8}
decNumBombs:
	ld hl,wNumBombs		; $17c8
+
	ld a,(hl)		; $17cb
	or a			; $17cc
	ret z			; $17cd

	call setStatusBarNeedsRefreshBit1		; $17ce
	ld a,(hl)		; $17d1
	sub $01			; $17d2
	daa			; $17d4
	ld (hl),a		; $17d5
	or h			; $17d6
	ret			; $17d7

;;
; @addr{17d8}
setStatusBarNeedsRefreshBit1:
	push hl			; $17d8
	ld hl,wStatusBarNeedsRefresh		; $17d9
	set 1,(hl)		; $17dc
	pop hl			; $17de
	ret			; $17df

;;
; Gets a random ring of the given tier ('c').
;
; The tier numbers are a bit different than in TourianTourist's guide (tiers 0-3 / 1-4 are
; reversed).
;
; @param	c	Ring tier
; @param[out]	a	TREASURE_RING (to be passed to "giveTreasure")
; @param[out]	c	Randomly chosen ring from the given tier (to be passed to
;			"giveTreasure")
; @addr{17e0}
getRandomRingOfGivenTier:
	ldh a,(<hRomBank)	; $17e0
	push af			; $17e2
	ld a,:bank3f.ringTierTable		; $17e3
	setrombank		; $17e5

	ld b,$01		; $17ea
	ld a,c			; $17ec
	cp $04			; $17ed
	jr z,+			; $17ef
	ld b,$07		; $17f1
+
	ld hl,bank3f.ringTierTable		; $17f3
	rst_addDoubleIndex			; $17f6
	ldi a,(hl)		; $17f7
	ld h,(hl)		; $17f8
	ld l,a			; $17f9

	call getRandomNumber		; $17fa
	and b			; $17fd
	ld c,a			; $17fe
	ld b,$00		; $17ff
	add hl,bc		; $1801
	ld c,(hl)		; $1802

	pop af			; $1803
	setrombank		; $1804

	ld a,TREASURE_RING		; $1809
	ret			; $180b

;;
; Fills the seed satchel with all seed types that Link currently has.
; @addr{180c}
refillSeedSatchel:
	ld e,TREASURE_EMBER_SEEDS		; $180c
--
	ld a,e			; $180e
	call checkTreasureObtained		; $180f
	jr nc,+			; $1812

	ld a,e			; $1814
	ld c,$99		; $1815
	call giveTreasure		; $1817
+
	inc e			; $181a
	ld a,e			; $181b
	cp TREASURE_MYSTERY_SEEDS+1			; $181c
	jr c,--			; $181e
	ret			; $1820

;;
; @param	a	Amount to add to wGashaMaturity
; @addr{1821}
addToGashaMaturity:
	push hl			; $1821
	ld hl,wGashaMaturity		; $1822
	add (hl)		; $1825
	ldi (hl),a		; $1826
	jr nc,+			; $1827

	inc (hl)		; $1829
	jr nz,+			; $182a

	ld a,$ff		; $182c
	ldd (hl),a		; $182e
	ld (hl),a		; $182f
+
	pop hl			; $1830
	ret			; $1831

;;
; @addr{1832}
makeActiveObjectFollowLink:
	ldh a,(<hRomBank)	; $1832
	push af			; $1834
	callfrombank0 bank1.makeActiveObjectFollowLink		; $1835
	pop af			; $183f
	setrombank		; $1840
	ret			; $1845

;;
; @addr{1846}
clearFollowingLinkObject:
	ld hl,wFollowingLinkObjectType		; $1846
	xor a			; $1849
	ldi (hl),a		; $184a
	ld (hl),a		; $184b
	ret			; $184c

;;
; @addr{184d}
stopTextThread:
	xor a			; $184d
	ld (wTextIsActive),a		; $184e
	ld (wTextboxFlags),a		; $1851
	ld a,THREAD_2		; $1854
	jp threadStop		; $1856

;;
; @addr{1859}
retIfTextIsActive:
	ld a,(wTextIsActive)		; $1859
	or a			; $185c
	ret z			; $185d
	pop af			; $185e
	ret			; $185f

;;
; @addr{1860}
showTextOnInventoryMenu:
	ld a,(wTextboxFlags)		; $1860
	set TEXTBOXFLAG_BIT_NOCOLORS,a			; $1863
	ld (wTextboxFlags),a		; $1865
	ld l,$00		; $1868
	ld e,$02		; $186a
	jr _label_00_204		; $186c

;;
; Displays text index bc while not being able to exit the textbox with button presses
;
; @addr{186e}
showTextNonExitable:
	ld l,TEXTBOXFLAG_NONEXITABLE	; $186e
	jr _label_00_203		; $1870

;;
; Displays text index bc
; @addr{1872}
showText:
	ld l,$00		; $1872
_label_00_203:
	ld e,$00		; $1874
_label_00_204:
	ld a,(wTextboxFlags)		; $1876
	or l			; $1879
	ld (wTextboxFlags),a		; $187a
	ld a,b			; $187d
	add $04			; $187e
	ld b,a			; $1880

	ld hl,wTextDisplayMode		; $1881
	ld (hl),e		; $1884
	inc l			; $1885
	ld (hl),c		; $1886
	inc l			; $1887
	ld a,b			; $1888
	ldi (hl),a		; $1889

	; wTextIndexH_backup
	ldi (hl),a		; $188a

	; wSelectedTextOption
	ld (hl),$ff		; $188b
	inc l			; $188d

	; wTextGfxColorIndex
	ld (hl),$02		; $188e
	inc l			; $1890

	; wTextMapAddress
	ld (hl),$98		; $1891

	ld a,$01		; $1893
	ld (wTextIsActive),a		; $1895

	ld bc,textThreadStart		; $1898
	ld a,THREAD_2		; $189b
	jp threadRestart		; $189d

;;
; @addr{18a0}
textThreadStart:
	ld a,(wScrollMode)		; $18a0
	or a			; $18a3
	jr z,@showText		; $18a4

	and $01			; $18a6
	jr nz,@showText		; $18a8

@dontShowText:
	xor a			; $18aa
	ld (wTextIsActive),a		; $18ab
	ld (wTextboxFlags),a		; $18ae
	jp stubThreadStart		; $18b1

@showText:
	callfrombank0 bank3f.initTextbox		; $18b4
-
	callfrombank0 bank3f.updateTextbox		; $18be
	call resumeThreadNextFrame		; $18c8
	jr -			; $18cb

;;
; Can only be called from bank $3f.
;
; @param	[w7TextGfxSource]	Table to use
; @param	a			Character
; @param	bc			Address to write data to
; @addr{18cd}
retrieveTextCharacter:
	push hl			; $18cd
	push de			; $18ce
	push bc			; $18cf
	call multiplyABy16		; $18d0
	ld a,(w7TextGfxSource)		; $18d3
	ld hl,@data		; $18d6
	rst_addDoubleIndex			; $18d9
	ldi a,(hl)		; $18da
	ld h,(hl)		; $18db
	ld l,a			; $18dc
	add hl,bc		; $18dd
	pop bc			; $18de
	ld a,:gfx_font		; $18df
	setrombank		; $18e1
	call @func_18fd		; $18e6

	ld a,BANK_3f		; $18e9
	setrombank		; $18eb

	xor a			; $18f0
	ld (w7TextGfxSource),a		; $18f1
	pop de			; $18f4
	pop hl			; $18f5
	ret			; $18f6

; @addr{18f7}
@data:
	.dw gfx_font_start
	.dw gfx_font_jp
	.dw gfx_font_tradeitems

;;
; @param bc
; @param hl
; @addr{18fd}
@func_18fd:
	ld e,$10		; $18fd

	; gfx_font_start+$140 is the heart character. It's always red?
	ld a,h			; $18ff
	cp >(gfx_font_start+$140)	; $1900
	jr nz,@notHeart		; $1902

	ld a,l			; $1904
	cp <(gfx_font_start+$140)	; $1905
	jr z,@color1		; $1907

@notHeart:
	ld a,(wTextGfxColorIndex)		; $1909
	and $0f			; $190c

	or a			; $190e
	jr z,@color0		; $190f

	dec a			; $1911
	jr z,@color1		; $1912

	dec a			; $1914
	jr z,@color2		; $1915

	; If [wTextGfxColorIndex] == 3, read the tile as 2bpp.
@2bpp:
	ld e,$20		; $1917
-
	ldi a,(hl)		; $1919
	ld (bc),a		; $191a
	inc bc			; $191b
	dec e			; $191c
	jr nz,-			; $191d

	ld a,(wTextGfxColorIndex)		; $191f
	and $f0			; $1922
	swap a			; $1924
	ld (wTextGfxColorIndex),a		; $1926
	ret			; $1929
@color0:
	ldi a,(hl)		; $192a
	ld (bc),a		; $192b
	inc c			; $192c
	ld (bc),a		; $192d
	inc bc			; $192e
	dec e			; $192f
	jr nz,@color0		; $1930
	ret			; $1932
@color1:
	ld a,$ff		; $1933
	ld (bc),a		; $1935
	inc c			; $1936
	ldi a,(hl)		; $1937
	ld (bc),a		; $1938
	inc bc			; $1939
	dec e			; $193a
	jr nz,@color1		; $193b
	ret			; $193d
@color2:
	ldi a,(hl)		; $193e
	ld (bc),a		; $193f
	inc c			; $1940
	ld a,$ff		; $1941
	ld (bc),a		; $1943
	inc bc			; $1944
	dec e			; $1945
	jr nz,@color2		; $1946
	ret			; $1948

;;
; Can only be called from bank $3f. Also assumes RAM bank 7 is loaded.
;
; @addr{1949}
readByteFromW7ActiveBank:
	push bc			; $1949
	ld a,(w7ActiveBank)		; $194a
	setrombank		; $194d
	ld b,(hl)		; $1952

	ld a,BANK_3f		; $1953
	setrombank		; $1955

	ld a,b			; $195a
	pop bc			; $195b
	ret			; $195c

;;
; Assumes RAM bank 7 is loaded.
;
; @addr{195d}
readByteFromW7TextTableBank:
	ldh a,(<hRomBank)	; $195d
	push af			; $195f
	ld a,(w7TextTableBank)		; $1960
	bit 7,h			; $1963
	jr z,+

	res 7,h			; $1967
	set 6,h			; $1969
	inc a			; $196b
+
	setrombank		; $196c
	ldi a,(hl)		; $1971
	ldh (<hFF8B),a	; $1972

	pop af			; $1974
	setrombank		; $1975
	ldh a,(<hFF8B)	; $197a
	ret			; $197c

;;
; @addr{197d}
getThisRoomFlags:
	ld a,(wActiveRoom)		; $197d
	push bc			; $1980
	ld b,a			; $1981
	ld a,(wActiveGroup)		; $1982
	call getRoomFlags		; $1985
	pop bc			; $1988
	ret			; $1989

;;
; @param	a	Group
; @param	b	Room
; @param[out]	a	Room flags
; @param[out]	hl	Address of room flags
; @addr{198a}
getRoomFlags:
	ld hl, flagLocationGroupTable	; $198a
	rst_addAToHl			; $198d
	ld h,(hl)		; $198e
	ld l,b			; $198f
	ld a,(hl)		; $1990
	ret			; $1991

;;
; @param[out]	zflag	z if unlinked
; @addr{1992}
checkIsLinkedGame:
	ld a,(wIsLinkedGame)		; $1992
	or a			; $1995
	ret			; $1996

;;
; @param	hl	Where to copy the values from for wWarpDestVariables
; @addr{1997}
setWarpDestVariables:
	push de			; $1997
	ld de,wWarpDestVariables	; $1998
	ld b,$05		; $199b
	call copyMemory		; $199d
	pop de			; $19a0
	ret			; $19a1

;;
; @addr{19a2}
setInstrumentsDisabledCounterAndScrollMode:
	ld a,$08		; $19a2
	ld (wInstrumentsDisabledCounter),a		; $19a4
	ld a,$01		; $19a7
	ld (wScrollMode),a		; $19a9
	ret			; $19ac

;;
; Clears all physical item objects (not parent items) and clears midair-related variables.
;
; @addr{19ad}
clearAllItemsAndPutLinkOnGround:
	push de			; $19ad
	call clearAllParentItems		; $19ae
	call dropLinkHeldItem		; $19b1

	xor a			; $19b4
	ld (wIsSeedShooterInUse),a		; $19b5

	ldde FIRST_ITEM_INDEX, Item.start		; $19b8

@nextItem:
	ld h,d			; $19bb

.ifdef ROM_AGES
	ld l,Item.id		; $19bc
	ld a,(hl)		; $19be
	cp ITEMID_18			; $19bf
	jr nz,@notSomariaBlock		; $19c1

; Somaria block creation

	ld l,Item.var2f		; $19c3
	set 5,(hl)		; $19c5
	set 4,(hl)		; $19c7
	ld l,Item.visible		; $19c9
	res 7,(hl)		; $19cb
	jr ++			; $19cd
.endif

@notSomariaBlock:
	ld l,e			; $19cf
	ld b,$40		; $19d0
	call clearMemory		; $19d2
++
	inc d			; $19d5
	ld a,d			; $19d6
	cp LAST_ITEM_INDEX+1			; $19d7
	jr c,@nextItem		; $19d9

	pop de			; $19db
	jp putLinkOnGround		; $19dc

;;
; @param	a			Character index
; @param	c			0 to use jp font, 1 to use english font
; @param	de			Where to write the character to
; @param	wFileSelect.fontXor	Value to xor every other byte with
; @addr{19df}
copyTextCharacterGfx:
	push hl			; $19df
	push bc			; $19e0
	ld hl,gfx_font_jp	; $19e1
	bit 0,c			; $19e4
	jr nz,+			; $19e6

	ld hl,gfx_font_start		; $19e8

	; Characters below $0e don't exist (or at least don't represent normal characters)
	cp $0e			; $19eb
	jr nc,+			; $19ed
	ld a,$20		; $19ef
+
	call multiplyABy16		; $19f1
	add hl,bc		; $19f4
	ldh a,(<hRomBank)	; $19f5
	push af			; $19f7
	ld a,:gfx_font		; $19f8
	setrombank		; $19fa
	ld a,(wFileSelect.fontXor)		; $19ff
	ld c,a			; $1a02
	ld b,$10		; $1a03
-
	ldi a,(hl)		; $1a05
	xor c			; $1a06
	ld (de),a		; $1a07
	inc de			; $1a08
	ld (de),a		; $1a09
	inc de			; $1a0a
	dec b			; $1a0b
	jr nz,-			; $1a0c

	pop af			; $1a0e
	setrombank		; $1a0f
	pop bc			; $1a14
	pop hl			; $1a15
	ret			; $1a16

;;
; @addr{1a17}
fileSelectThreadStart:
	ld hl,wTmpcbb3		; $1a17
	ld b,$10		; $1a1a
	call clearMemory		; $1a1c
-
	callfrombank0 bank2.b2_fileSelectScreen	; $1a1f
	call resumeThreadNextFrame		; $1a29
	jr -			; $1a2c

;;
; Calls a secret-related function based on parameter 'b' (see also the enum below):
;
; 0: Generate a secret
; 1: Unpack a secret in ascii form (input and output are both in wTmpcec0)
; 2: Verify that the gameID of an unpacked secret is valid
; 3: Generate a gameID for the current file
; 4: Loads the data associated with an unpacked secret (ie. for game-transfer secret, this
;    loads the player name, animal companion, etc. from the secret data).
;
; @param	b	Index of function to call
; @param	c	Secret type (in most cases)
; @param[out]	zflag	Generally set on success
; @addr{1a2e}
secretFunctionCaller:
	ldh a,(<hRomBank)	; $1a2e
	push af			; $1a30
	callfrombank0 secretFunctionCaller_body	; $1a31
	pop af			; $1a3b
	setrombank		; $1a3c
	ld a,b			; $1a41
	or a			; $1a42
	ret			; $1a43

.enum 0
	SECRETFUNC_GENERATE_SECRET	db ; 0
	SECRETFUNC_UNPACK_SECRET	db ; 1
	SECRETFUNC_VERIFY_SECRET_GAMEID	db ; 2
	SECRETFUNC_GENERATE_GAMEID	db ; 3
	SECRETFUNC_LOAD_UNPACKED_SECRET	db ; 4
.ende


;;
; Opens a secret input menu.
;
; @param	a	Secret type (0 = 20-char, 2 = 15-char, $80-$ff = 5-char?)
; @addr{1a44}
openSecretInputMenu:
	ld (wSecretInputType),a		; $1a44
	ld a,$01		; $1a47
	ld (wTextInputResult),a		; $1a49
	ld a,$06		; $1a4c
	jp openMenu		; $1a4e

;;
; @param[out]	zflag	Set if no menu is being displayed.
; @addr{1a51}
updateMenus:
	ld a,($ff00+R_SVBK)	; $1a51
	ld c,a			; $1a53
	ldh a,(<hRomBank)	; $1a54
	ld b,a			; $1a56
	push bc			; $1a57
	callfrombank0 bank2.b2_updateMenus	; $1a58
	pop bc			; $1a62
	ld a,b			; $1a63
	setrombank		; $1a64
	ld a,c			; $1a69
	ld ($ff00+R_SVBK),a	; $1a6a
	ld a,(wOpenedMenuType)		; $1a6c
	or a			; $1a6f
	ret			; $1a70

;;
; If wStatusBarNeedsRefresh is nonzero, this function dma's the status bar graphics to
; vram. It also reloads the item icon's graphics, if bit 0 is set.
;
; @addr{1a71}
checkReloadStatusBarGraphics:
	ld hl,wStatusBarNeedsRefresh		; $1a71
	ld a,(hl)		; $1a74
	or a			; $1a75
	ret z			; $1a76

	ld (hl),$00		; $1a77

	; If bit 0 is unset, just reload the status bar (w4StatusBarTileMap and
	; w4StatusBarAttributeMap); if bit 0 is set, also reload the item graphics
	; (w4ItemIconGfx).
	rrca			; $1a79
	ld a,UNCMP_GFXH_02		; $1a7a
	jr c,+			; $1a7c
	ld a,UNCMP_GFXH_03		; $1a7e
+
	jp loadUncompressedGfxHeader		; $1a80

;;
; Copy $20 bytes from bank b at hl to de.
;
; @param	b	Bank
; @param	de	Destination
; @param	hl	Source
; @addr{1a83}
copy20BytesFromBank:
	ldh a,(<hRomBank)	; $1a83
	push af			; $1a85
	ld a,b			; $1a86
	setrombank		; $1a87
	ld b,$20		; $1a8c
	call copyMemory		; $1a8e
	pop af			; $1a91
	setrombank		; $1a92
	ret			; $1a97

;;
; @addr{1a98}
loadCommonGraphics:
	ld h,$00		; $1a98
	jr +++			; $1a9a

;;
; Jumps to bank2._updateStatusBar.
; @addr{1a9c}
updateStatusBar:
	ld h,$01		; $1a9c
	jr +++			; $1a9e

;;
; @addr{1aa0}
hideStatusBar:
	ld h,$02		; $1aa0
	jr +++		; $1aa2

;;
; @addr{1aa4}
showStatusBar:
	ld h,$03		; $1aa4
	jr +++		; $1aa6

;;
; @addr{1aa8}
saveGraphicsOnEnterMenu:
	ld h,$04		; $1aa8
	jr +++		; $1aaa

;;
; @addr{1aac}
reloadGraphicsOnExitMenu:
	ld h,$05		; $1aac
	jr +++		; $1aae

;;
; @param	a	Type of menu to open (see wOpenedMenuType in wram.s)
; @addr{1ab0}
openMenu:
	ld h,$06		; $1ab0
	jr +++		; $1ab2

;;
; @addr{1ab4}
copyW2AreaBgPalettesToW4PaletteData:
	ld h,$07		; $1ab4
	jr +++		; $1ab6

;;
; @addr{1ab8}
copyW4PaletteDataToW2AreaBgPalettes:
	ld h,$08		; $1ab8
+++
	ld l,a			; $1aba
	ld a,($ff00+R_SVBK)	; $1abb
	ld c,a			; $1abd
	ldh a,(<hRomBank)	; $1abe
	ld b,a			; $1ac0
	push bc			; $1ac1
	callfrombank0 bank2.runBank2Function	; $1ac2
	pop bc			; $1acc
	ld a,b			; $1acd
	setrombank		; $1ace
	ld a,c			; $1ad3
	ld ($ff00+R_SVBK),a	; $1ad4
	ret			; $1ad6

;;
; @param[in]	b	Room
; @param[out]	b	Dungeon property byte for the given room (see
;			constants/dungeonRoomProperties.s)
; @addr{1ad7}
getRoomDungeonProperties:
	ldh a,(<hRomBank)	; $1ad7
	push af			; $1ad9
	ld a, :dungeonRoomPropertiesGroupTable
	setrombank		; $1adc
	ld a,(wActiveGroup)		; $1ae1
	and $01			; $1ae4
	ld hl, dungeonRoomPropertiesGroupTable
	rst_addDoubleIndex			; $1ae9
	ldi a,(hl)		; $1aea
	ld h,(hl)		; $1aeb
	ld l,a			; $1aec
	ld a,b			; $1aed
	rst_addAToHl			; $1aee
	ld b,(hl)		; $1aef
	pop af			; $1af0
	setrombank		; $1af1
	ret			; $1af6

;;
; @addr{1af7}
copy8BytesFromRingMapToCec0:
	ldh a,(<hRomBank)	; $1af7
	push af			; $1af9
	ld a,:map_rings		; $1afa
	setrombank		; $1afc
	ld de,wTmpcec0		; $1b01
	ld b,$08		; $1b04
	call copyMemory		; $1b06
	pop af			; $1b09
	setrombank		; $1b0a
	ret			; $1b0f

;;
; Runs game over screen?
;
; @addr{1b10}
thread_1b10:
	ld hl,wTmpcbb3		; $1b10
	ld b,$10		; $1b13
	call clearMemory		; $1b15
	ld a,$01		; $1b18
	ld (wTmpcbb4),a		; $1b1a
-
	callfrombank0 bank2.runSaveAndQuitMenu	; $1b1d
	call resumeThreadNextFrame		; $1b27
	jr -			; $1b2a

;;
; Calling this function allows an interaction to use the "checkabutton" command.
;
; @param	de	Variable to write $01 to when A button is pressed next to object
; @addr{1b2c}
objectAddToAButtonSensitiveObjectList:
	xor a			; $1b2c
	ld (de),a		; $1b2d
	ld hl,wAButtonSensitiveObjectList		; $1b2e
@next:
	ldi a,(hl)		; $1b31
	or (hl)			; $1b32
	jr z,@foundBlankEntry	; $1b33

	inc l			; $1b35
	ld a,l			; $1b36
	cp <wAButtonSensitiveObjectListEnd		; $1b37
	jr c,@next		; $1b39
	ret			; $1b3b
@foundBlankEntry:
	ld a,e			; $1b3c
	ldd (hl),a		; $1b3d
	ld (hl),d		; $1b3e
	scf			; $1b3f
	ret			; $1b40

;;
; @addr{1b41}
objectRemoveFromAButtonSensitiveObjectList:
	push de			; $1b41
	ld a,e			; $1b42
	and $c0			; $1b43
	ld e,a			; $1b45
	ld hl,wAButtonSensitiveObjectList		; $1b46
---
	ldi a,(hl)		; $1b49
	cp d			; $1b4a
	jr nz,@next		; $1b4b

	ld a,(hl)		; $1b4d
	and $c0			; $1b4e
	sub e			; $1b50
	jr nz,@next		; $1b51

	ldd (hl),a		; $1b53
	ldi (hl),a		; $1b54
@next:
	inc l			; $1b55
	ld a,l			; $1b56
	cp <wAButtonSensitiveObjectListEnd		; $1b57
	jr c,---		; $1b59

	pop de			; $1b5b
	ret			; $1b5c

;;
; Checks everything in wAButtonSensitiveObjectList (npcs mostly) and triggers them if the
; A button has been pressed near them.
;
; @param[out]	cflag	Set if Link just pressed A next to the object
; @addr{1b5d}
linkInteractWithAButtonSensitiveObjects:
	ld a,(wGameKeysJustPressed)		; $1b5d
	and BTN_A			; $1b60
	ret z			; $1b62

	; If he's in a shop, he can interact while holding something
	ld a,(wInShop)		; $1b63
	or a			; $1b66
	jr nz,+			; $1b67

	; If he's not in a shop, this should return if he's holding something
	ld a,(wLinkGrabState)		; $1b69
	or a			; $1b6c
	ret nz			; $1b6d
+
	push de			; $1b6e
	ld e,SpecialObject.direction		; $1b6f
	ld a,(de)		; $1b71
	ld hl,@positionOffsets		; $1b72
	rst_addDoubleIndex			; $1b75

	; Store y + offset into [hFF8D]
	ld e,SpecialObject.yh		; $1b76
	ld a,(de)		; $1b78
	add (hl)		; $1b79
	ldh (<hFF8D),a	; $1b7a

	; Store x + offset into [hFF8C]
	inc hl			; $1b7c
	ld e,SpecialObject.xh		; $1b7d
	ld a,(de)		; $1b7f
	add (hl)		; $1b80
	ldh (<hFF8C),a	; $1b81

	; Check all objects in the list
	ld de,wAButtonSensitiveObjectList		; $1b83
---
	; Get the object in hl
	ld a,(de)		; $1b86
	ld h,a			; $1b87
	inc e			; $1b88
	ld a,(de)		; $1b89
	ld l,a			; $1b8a
	or h			; $1b8b
	jr z,+			; $1b8c

	; Check if link is directly in front of the object
	push hl			; $1b8e
	ldh a,(<hFF8D)		; $1b8f
	ld b,a			; $1b91
	ldh a,(<hFF8C)		; $1b92
	ld c,a			; $1b94
	call objectHCheckContainsPoint		; $1b95
	pop hl			; $1b98
	jr nc,+			; $1b99

	; Link is next to the object; only trigger it if the "pressedAButton" variable is
	; not already set.
	bit 0,(hl)		; $1b9b
	jr z,@foundObject			; $1b9d
+
	inc e			; $1b9f
	ld a,e			; $1ba0
	cp <wAButtonSensitiveObjectListEnd			; $1ba1
	jr c,---		; $1ba3

	; No object found
	pop de			; $1ba5
	ret			; $1ba6

@foundObject:
	; Set the object's "pressedAButton" variable.
	set 0,(hl)		; $1ba7

	; For some reason, set Link's invincibility whenever triggering an object?
	ld hl,w1Link.invincibilityCounter		; $1ba9
	ld a,(hl)		; $1bac
	or a			; $1bad
	ld a,$fc		; $1bae
	jr z,++			; $1bb0

	bit 7,(hl)		; $1bb2
	jr nz,@negativeValue			; $1bb4

	; Link's invincibility already has a positive value ($01-$7f), meaning he's
	; flashing red from damage.
	; Make sure he stays invincible for at least 4 more frames?
	ld a,$04		; $1bb6
	cp (hl)			; $1bb8
	jr c,@doneWithInvincibility		; $1bb9
	jr ++			; $1bbb

	; Negative value for invincibility means he isn't flashing red.
	; Again, this makes sure he stays invincible for at least 4 more frames.
@negativeValue:
	cp (hl)			; $1bbd
	jr nc,@doneWithInvincibility		; $1bbe
++
	ld (hl),a		; $1bc0

@doneWithInvincibility:
	; Disable ring transformations for 8 frames? (He can't normally interact with
	; objects while transformed... so what's the point of this?)
	ld a,$08		; $1bc1
	ld (wDisableRingTransformations),a		; $1bc3

	; Disable pushing animation
	ld a,$80		; $1bc6
	ld (wForceLinkPushAnimation),a		; $1bc8

	ld hl,wLinkTurningDisabled		; $1bcb
	set 7,(hl)		; $1bce

	scf			; $1bd0
	pop de			; $1bd1
	ret			; $1bd2

@positionOffsets:
	.db $f6 $00 ; DIR_UP
	.db $00 $0a ; DIR_RIGHT
	.db $0a $00 ; DIR_DOWN
	.db $00 $f6 ; DIR_LEFT

;;
; @addr{1bdb}
objectCheckContainsPoint:
	ld h,d			; $1bdb
	ldh a,(<hActiveObjectType)	; $1bdc
	ld l,a			; $1bde
	jr objectHCheckContainsPoint			; $1bdf

;;
; @addr{1be1}
interactionCheckContainsPoint:
	ld h,d			; $1be1
	ld l,Interaction.start	; $1be2

;;
; Checks if an object contains a given point.
;
; @param	bc	Point to check
; @param	hl	The object to check (not object d as usual)
; @param[out]	cflag	Set if the point is contained in the object's collision box.
; @addr{1be4}
objectHCheckContainsPoint:
	ld a,l			; $1be4
	and $c0			; $1be5
	add Object.yh		; $1be7
	ld l,a			; $1be9
	ldi a,(hl)		; $1bea
	sub b			; $1beb
	jr nc,+			; $1bec
	cpl			; $1bee
	inc a			; $1bef
+
	ld b,a			; $1bf0

	inc l			; $1bf1
	ld a,(hl)		; $1bf2
	sub c			; $1bf3
	jr nc,+			; $1bf4
	cpl			; $1bf6
	inc a			; $1bf7
+
	ld c,a			; $1bf8

	ld a,l			; $1bf9
	add Object.collisionRadiusY-Object.xh			; $1bfa
	ld l,a			; $1bfc

	ld a,b			; $1bfd
	sub (hl)		; $1bfe
	ret nc			; $1bff
	inc l			; $1c00
	ld a,c			; $1c01
	sub (hl)		; $1c02
	ret			; $1c03

;;
; Check if 2 objects have collided.
;
; @param	bc	YX position of object 1
; @param	de	Address of object 1's collisionRadiusY variable
; @param	hl	Address of object 2's collisionRadiusY variable
; @param	ff8e	X position object 2
; @param	ff8f	Y position object 2
; @param[out]	cflag	Set if collision, unset if no collision
; @addr{1c04}
checkObjectsCollidedFromVariables:
	ld a,b			; $1c04
	ldh (<hFF8D),a	; $1c05
	ld a,c			; $1c07
	ldh (<hFF8C),a	; $1c08
	ld a,(de)		; $1c0a
	add (hl)		; $1c0b
	ld b,a			; $1c0c
	ldh a,(<hFF8F)	; $1c0d
	ld c,a			; $1c0f
	ldh a,(<hFF8D)	; $1c10
	sub c			; $1c12
	add b			; $1c13
	sla b			; $1c14
	cp b			; $1c16
	ret nc			; $1c17

	inc e			; $1c18
	inc hl			; $1c19
	ld a,(de)		; $1c1a
	add (hl)		; $1c1b
	ld b,a			; $1c1c
	ldh a,(<hFF8E)	; $1c1d
	ld c,a			; $1c1f
	ldh a,(<hFF8C)	; $1c20
	sub c			; $1c22
	add b			; $1c23
	sla b			; $1c24
	cp b			; $1c26
	ret			; $1c27

;;
; @addr{1c28}
objectCheckCollidedWithLink_notDeadAndNotGrabbing:
	ld a,(wLinkGrabState)		; $1c28
	and $be			; $1c2b
	ret nz			; $1c2d
;;
; @addr{1c2e}
objectCheckCollidedWithLink_notDead:
	ld a,(wLinkDeathTrigger)		; $1c2e
	or a			; $1c31
	ret nz			; $1c32
	jr objectCheckCollidedWithLink		; $1c33

;;
; @addr{1c35}
objectCheckCollidedWithLink_onGround:
	ld a,(wLinkInAir)		; $1c35
	or a			; $1c38
	ret nz			; $1c39
	ld a,(w1Link.zh)		; $1c3a
	or a			; $1c3d
	ret nz			; $1c3e
	jr objectCheckCollidedWithLink_notDead		; $1c3f

;;
; @param[out]	cflag	Set if the object is touching Link.
; @addr{1c41}
objectCheckCollidedWithLink:
	ldh a,(<hActiveObjectType)	; $1c41
	add Object.zh		; $1c43
	ld l,a			; $1c45
	ld h,d			; $1c46

;;
; @param	hl	Address of an object's zh variable
; @addr{1c47}
_checkCollidedWithLink:
	ld a,(wLinkObjectIndex)		; $1c47
	ld b,a			; $1c4a

	; Check if the object is within 7 z-units of link
	ld c,Object.zh		; $1c4b
	ld a,(bc)		; $1c4d
	sub (hl)		; $1c4e
	add $07			; $1c4f
	cp $0e			; $1c51
	ret nc			; $1c53

	; Set l to Object.xh
	dec l			; $1c54
	dec l			; $1c55
---
	ldd a,(hl)		; $1c56
	ldh (<hFF8E),a	; $1c57
	dec l			; $1c59
	ld a,(hl)		; $1c5a
	ldh (<hFF8F),a	; $1c5b
	ld a,l			; $1c5d
	add $1b			; $1c5e
	ld e,a			; $1c60
	ld a,(wLinkObjectIndex)		; $1c61
	ld h,a			; $1c64
	ld l,<w1Link.yh		; $1c65
	ld b,(hl)		; $1c67
	ld l,<w1Link.xh		; $1c68
	ld c,(hl)		; $1c6a
	ld l,<w1Link.collisionRadiusY	; $1c6b
	jr checkObjectsCollidedFromVariables		; $1c6d

;;
; @param[out]	cflag	Set if the object is touching Link.
; @addr{1c6f}
objectCheckCollidedWithLink_ignoreZ:
	ldh a,(<hActiveObjectType)	; $1c6f
	add Object.xh		; $1c71
	ld l,a			; $1c73
	ld h,d			; $1c74
	jr ---			; $1c75

;;
; Unused?
;
; @addr{1c77}
hObjectCheckCollidedWithLink:
	push de			; $1c77
	ld d,h			; $1c78
	ld a,l			; $1c79
	and $c0			; $1c7a
	add Object.zh		; $1c7c
	ld l,a			; $1c7e
	call _checkCollidedWithLink	; $1c7f
	pop de			; $1c82
	ret			; $1c83

;;
; Unused?
;
; @addr{1c84}
func_1c84:
	ld a,(w1ReservedItemC.enabled)		; $1c84
	or a			; $1c87
	ret nz			; $1c88

;;
; @param[out]	cflag	Set on collision
; @addr{1c89}
objectHCheckCollisionWithLink:
	push de			; $1c89
	push hl			; $1c8a
	call _getLinkPositionPlusDirectionOffset		; $1c8b
	pop hl			; $1c8e
	ld a,l			; $1c8f
	and $c0			; $1c90
	call _checkCollisionWithHAndD		; $1c92
	pop de			; $1c95
	ret			; $1c96

;;
; Checks whether link is close enough to a grabbable object to grab it.
; If so, this also sets a few of the object's variables.
; This function is only called after the A button is pressed.
;
; @param	d	Link object?
; @param[out]	cflag	Set on collision
; @addr{1c97}
checkGrabbableObjects:
	; Check that something isn't already being carried around
	ld a,(w1ReservedItemC.enabled)		; $1c97
	or a			; $1c9a
	ret nz			; $1c9b

	push de			; $1c9c

	; This call sets up hFF8E and hFF8F for collision function calls
	call _getLinkPositionPlusDirectionOffset		; $1c9d

	ld hl,wGrabbableObjectBuffer		; $1ca0

@objectLoop:
	inc l			; $1ca3
	bit 7,(hl)		; $1ca4
	jr z,@nextObject	; $1ca6

	push hl			; $1ca8
	dec l			; $1ca9
	ldi a,(hl)		; $1caa
	ld h,(hl)		; $1cab
	call _checkCollisionWithHAndD		; $1cac
	jr c,@collision		; $1caf
	pop hl			; $1cb1
@nextObject:
	inc l			; $1cb2
	ld a,l			; $1cb3
	cp <wGrabbableObjectBufferEnd			; $1cb4
	jr c,@objectLoop	; $1cb6

	pop de			; $1cb8
	xor a			; $1cb9
	ret			; $1cba

	; At this point, hl = the shop object that is grabbed
@collision:
	pop af			; $1cbb

	ld e,Item.relatedObj2+1		; $1cbc
	ld a,h			; $1cbe
	ld (de),a		; $1cbf
	dec e			; $1cc0
	ld a,l			; $1cc1
	and $c0			; $1cc2
	ld (de),a		; $1cc4

	; l = Object.enabled
	ld l,a			; $1cc5
	set 1,(hl)		; $1cc6

	; l = Object.state
	add Object.state-Object.enabled			; $1cc8
	ld l,a			; $1cca
	ld (hl),ENEMYSTATE_GRABBED ; TODO: Better name? it's not just for enemies

	; l = Object.state2
	inc l			; $1ccd
	ld (hl),$00		; $1cce

	pop de			; $1cd0
	scf			; $1cd1
	ret			; $1cd2

;;
; Gets link's position plus 5 pixels in the direction he's facing.
;
; @param[out]	hFF8E	Link X
; @param[out]	hFF8F	Link Y
; @param[out]	hFF91	Link Z (subtracted by 3)
; @addr{1cd3}
_getLinkPositionPlusDirectionOffset:
	ld a,(w1Link.direction)		; $1cd3
	ld hl,@positionOffsets		; $1cd6
	rst_addDoubleIndex			; $1cd9
	ld de,w1Link.yh		; $1cda
	ld a,(de)		; $1cdd
	add (hl)		; $1cde
	ldh (<hFF8F),a	; $1cdf
	inc hl			; $1ce1
	ld e,<w1Link.xh		; $1ce2
	ld a,(de)		; $1ce4
	add (hl)		; $1ce5
	ldh (<hFF8E),a	; $1ce6
	ld e,<w1Link.zh		; $1ce8
	ld a,(de)		; $1cea
	sub $03			; $1ceb
	ldh (<hFF91),a	; $1ced
	ret			; $1cef

; @addr{1cf0}
@positionOffsets:
	.dw $00fa ; DIR_UP
	.dw $0500 ; DIR_RIGHT
	.dw $0005 ; DIR_DOWN
	.dw $fa00 ; DIR_LEFT

;;
; @param	a	Object.start variable for object h
; @param	d	Link/Item object
; @param	h	Any object
; @param	[hFF8E]	Object d's x position
; @param	[hFF8F]	Object d's y position
; @param[out]	cflag	Set if collision, unset if no collision
; @addr{1cf8}
_checkCollisionWithHAndD:
	add Object.var2a			; $1cf8
	ld l,a			; $1cfa
	bit 7,(hl)		; $1cfb
	ret nz			; $1cfd

	; Check Z position within 7 pixels
	sub Object.var2a-Object.zh	; $1cfe
	ld l,a			; $1d00
	ldh a,(<hFF91)	; $1d01
	sub (hl)		; $1d03
	add $07			; $1d04
	cp $0e			; $1d06
	ret nc			; $1d08

	; Get Object.yh / Object.xh into bc
	dec l			; $1d09
	dec l			; $1d0a
	ldd a,(hl)		; $1d0b
	dec l			; $1d0c
	ld b,(hl)		; $1d0d
	ld c,a			; $1d0e

	ld a,l			; $1d0f
	add Object.collisionRadiusY-Object.yh		; $1d10
	ld l,a			; $1d12
	ld e,Item.collisionRadiusY		; $1d13
	jp checkObjectsCollidedFromVariables		; $1d15

;;
; Checks link's ID is 0, and checks various other things impeding game control
; (wLinkDeathTrigger, wLinkInAir, and link being in a spinner?)
;
; @param[out]	cflag	Set if any checks fail.
; @addr{1d18}
checkLinkID0AndControlNormal:
	ld a,(w1Link.id)		; $1d18
	or a			; $1d1b
	jr z,+++		; $1d1c
	xor a			; $1d1e
	ret			; $1d1f

;;
; @addr{1d20}
checkLinkVulnerableAndIDZero:

.ifdef ROM_AGES
	ld a,(w1Link.id)		; $1d20
	or a			; $1d23
	jr z,checkLinkVulnerable			; $1d24
	xor a			; $1d26
	ret			; $1d27
.endif

;;
; Check if link should respond to collisions, perhaps other things?
;
; @param[out]	cflag	Set if link is vulnerable
; @addr{1d28}
checkLinkVulnerable:
	; Check var2a, invincibilityCounter, knockbackCounter
	ld hl,w1Link.var2a		; $1d28
	ldi a,(hl)		; $1d2b
	or (hl)			; $1d2c
	ld l,<w1Link.knockbackCounter		; $1d2d
	or (hl)			; $1d2f
	jr nz,checkLinkCollisionsEnabled@noCarry		; $1d30

;;
; Check if link should respond to collisions, perhaps other things?
;
; @param[out]	cflag
; @addr{1d32}
checkLinkCollisionsEnabled:
	ld a,(w1Link.collisionType)		; $1d32
	rlca			; $1d35
	jr nc,@noCarry		; $1d36

	ld a,(wDisableLinkCollisionsAndMenu)		; $1d38
	or a			; $1d3b
	jr nz,@noCarry		; $1d3c

	ld a,(wMenuDisabled)		; $1d3e
	or a			; $1d41
	jr nz,@noCarry		; $1d42
+++
	ld a,(wLinkDeathTrigger)		; $1d44
	or a			; $1d47
	jr nz,@noCarry		; $1d48

	; Check if in a spinner
	ld a,(wcc95)		; $1d4a
	rlca			; $1d4d
	jr c,@noCarry		; $1d4e

	ld a,(wLinkInAir)		; $1d50
	rlca			; $1d53
	jr c,@noCarry		; $1d54

	scf			; $1d56
	ret			; $1d57
@noCarry:
	xor a			; $1d58
	ret			; $1d59

;;
; Check if objects d and h have collided.
;
; @param[in]	d	Object 1
; @param[in]	h	Object 2
; @param[out]	cflag	Set if collision, unset if no collision
; @addr{1d5a}
checkObjectsCollided:
	; Everything here is just setting up variables for the jump at the end
	ld a,l			; $1d5a
	and $c0			; $1d5b
	ld l,a			; $1d5d
	push hl			; $1d5e

	ld h,d			; $1d5f
	ldh a,(<hActiveObjectType)	; $1d60
	add Object.yh		; $1d62
	ld l,a			; $1d64
	ldi a,(hl)		; $1d65
	ldh (<hFF8F),a	; $1d66
	inc l			; $1d68
	ld a,(hl)		; $1d69
	ldh (<hFF8E),a	; $1d6a

	ld a,l			; $1d6c
	add Object.collisionRadiusY - Object.xh		; $1d6d
	ld e,a			; $1d6f
	pop hl			; $1d70
	ld a,l			; $1d71
	add Object.yh		; $1d72
	ld l,a			; $1d74
	ld b,(hl)		; $1d75
	inc l			; $1d76
	inc l			; $1d77
	ld c,(hl)		; $1d78
	add Object.collisionRadiusY - Object.yh			; $1d79
	ld l,a			; $1d7b
	jp checkObjectsCollidedFromVariables		; $1d7c

;;
; Prevents Object 2 (usually Link) from passing through Object 1 (usually an npc).
;
; If Object 2 is Link, consider using "objectPreventLinkFromPassing" instead.
;
; @param	d	Object 1 (Npc, minecart)
; @param	h	Object 2 (Link)
; @param[out]	cflag	Set if there's a collision
; @addr{1d7f}
preventObjectHFromPassingObjectD:
	ld a,l			; $1d7f
	and $c0			; $1d80
	ldh (<hFF8B),a	; $1d82

	call checkObjectsCollided		; $1d84
	ret nc			; $1d87
	call @checkCollisionDirection		; $1d88
	jr nc,+			; $1d8b

	; Vertical collision: get the sum of both objects' collisionRadiusY in c
	ld b,Object.yh		; $1d8d
	ldh a,(<hFF8D)	; $1d8f
	ld c,a			; $1d91
	jr ++			; $1d92
+
	; Horizontal collision: get the sum of both objects' collisionRadiusX in c
	ld b,Object.xh		; $1d94
	ldh a,(<hFF8C)	; $1d96
	ld c,a			; $1d98
	jr ++			; $1d99
++
	; Check which direction the objects are relative to each other...
	call @setBothObjectVariables		; $1d9b
	ld a,(de)		; $1d9e
	sub (hl)		; $1d9f
	ld a,c			; $1da0
	jr c,+			; $1da1

	cpl			; $1da3
	inc a			; $1da4
+
	; Now lock object h's position to prevent it from moving any further
	ld b,a			; $1da5
	ld a,(de)		; $1da6
	add b			; $1da7
	ld (hl),a		; $1da8
	scf			; $1da9
	ret			; $1daa

;;
; Checks the direction of a collision. (Doesn't check for the collision itself)
;
; @param[out]	hFF8C	Sum of both objects' collisionRadiusX variables
; @param[out]	hFF8D	Sum of both objects' collisionRadiusY variables
; @param[out]	cflag	Set if the collision was predominantly from a vertical direction
; @addr{1dab}
@checkCollisionDirection:
	ld b,Object.yh		; $1dab
	call @setBothObjectVariables		; $1dad
	ld a,(de)		; $1db0
	sub (hl)		; $1db1
	jr nc,+			; $1db2

	cpl			; $1db4
	inc a			; $1db5
+
	; c will hold the difference in y positions
	ld c,a			; $1db6

	ld b,Object.collisionRadiusY		; $1db7
	call @setBothObjectVariables		; $1db9
	ld a,(de)		; $1dbc
	add (hl)		; $1dbd
	ldh (<hFF8D),a	; $1dbe

	; hFF8F will be >0 if the objects collided vertically
	sub c			; $1dc0
	ldh (<hFF8F),a	; $1dc1

	ld b,Object.xh		; $1dc3
	call @setBothObjectVariables		; $1dc5
	ld a,(de)		; $1dc8
	sub (hl)		; $1dc9
	jr nc,+			; $1dca

	cpl			; $1dcc
	inc a			; $1dcd
+
	; c will hold the difference in x positions
	ld c,a			; $1dce

	ld b,Object.collisionRadiusX		; $1dcf
	call @setBothObjectVariables		; $1dd1
	ld a,(de)		; $1dd4
	add (hl)		; $1dd5
	ldh (<hFF8C),a	; $1dd6
	sub c			; $1dd8

	; Compare horizontal component of collision to vertical component.
	; Will set the carry flag if the collision occurred from a vertical direction.
	ld b,a			; $1dd9
	ldh a,(<hFF8F)	; $1dda
	cp b			; $1ddc
	ret			; $1ddd

;;
; Makes both objects de and hl point to a particular variable.
;
; @param	b	The variable to make both objects point to
; @addr{1dde}
@setBothObjectVariables:
	ldh a,(<hActiveObjectType)	; $1dde
	or b			; $1de0
	ld e,a			; $1de1
	ldh a,(<hFF8B)	; $1de2
	or b			; $1de4
	ld l,a			; $1de5
	ret			; $1de6

;;
; @addr{1de7}
checkEnemyAndPartCollisionsIfTextInactive:
	call retIfTextIsActive		; $1de7
	ldh a,(<hRomBank)	; $1dea
	push af			; $1dec
	callfrombank0 bank7.checkEnemyAndPartCollisions		; $1ded
	pop af			; $1df7
	setrombank		; $1df8
	ret			; $1dfd

;;
; Searches a table at hl where each entry is a pointer for a group.
; This pointer points to data formatted as follows:
; 	room id (byte), value (byte)
; If it finds room id A in the list, it sets the carry flag and returns the value.
; Otherwise, it returns with the carry flag unset.
;
; @param	a	Room index
; @param	hl	Table address
; @addr{1dfe}
findRoomSpecificData:
	ld e,a			; $1dfe
	ld a,(wActiveGroup)		; $1dff
	rst_addDoubleIndex			; $1e02
	ldi a,(hl)		; $1e03
	ld h,(hl)		; $1e04
	ld l,a			; $1e05
;;
; Returns the "value" of a "key" E. hl points to a "dictionary" structure with
; the following format:
; 	key (byte), value (byte)
;
; The "dictionary" ends when the key equals zero.
;
; @param	e	Key to check for in table
; @param	hl	Table address
; @param[out]	a	The "value" associated with the key.
; @param[out]	cflag	Set on success (the key is in the table).
; @addr{1e06}
lookupKey:
	ldi a,(hl)		; $1e06
	or a			; $1e07
	ret z			; $1e08
	cp e			; $1e09
	ldi a,(hl)		; $1e0a
	jr nz, lookupKey
	scf			; $1e0d
	ret			; $1e0e

;;
; Unused?
;
; @param a
; @addr{1e0f}
findByteInGroupTable:
	ld e,a			; $1e0f
	ld a,(wActiveGroup)		; $1e10
	rst_addDoubleIndex			; $1e13
	ldi a,(hl)		; $1e14
	ld h,(hl)		; $1e15
	ld l,a			; $1e16

;;
; Search through zero-terminated list of bytes at hl, return when one equals e.
;
; @param	e	Value to match
; @param[in]	hl	Start address to search
; @param[out]	cflag	Set if match found
; @addr{1e17}
findByteAtHl:
	ldi a,(hl)		; $1e17
	or a			; $1e18
	ret z			; $1e19

	cp e			; $1e1a
	jr nz,findByteAtHl		; $1e1b

	scf			; $1e1d
	ret			; $1e1e

;;
; @param	a	Tile to lookup
; @param	hl	Table
; @param[out]	cflag	Set on success.
; @addr{1e1f}
lookupCollisionTable:
	ld e,a			; $1e1f

;;
; @param	e	Tile to lookup
; @param	hl	Table
; @param[out]	cflag	Set on success.
; @addr{1e20}
lookupCollisionTable_paramE:
	ld a,(wActiveCollisions)		; $1e20
	rst_addDoubleIndex			; $1e23
	ldi a,(hl)		; $1e24
	ld h,(hl)		; $1e25
	ld l,a			; $1e26
	jr lookupKey		; $1e27

;;
; @param	a	Key
; @param[out]	cflag	Set if match found
; @addr{1e29}
findByteInCollisionTable:
	ld e,a			; $1e29

;;
; @param e
; @addr{1e2a}
findByteInCollisionTable_paramE:
	ld a,(wActiveCollisions)		; $1e2a
	rst_addDoubleIndex			; $1e2d
	ldi a,(hl)		; $1e2e
	ld h,(hl)		; $1e2f
	ld l,a			; $1e30
	jr findByteAtHl		; $1e31

;;
; @addr{1e33}
objectSetVisiblec0:
	ldh a,(<hActiveObjectType)	; $1e33
	add Object.visible			; $1e35
	ld e,a			; $1e37
	ld a,$c0		; $1e38
	ld (de),a		; $1e3a
	ret			; $1e3b
;;
; @addr{1e3c}
objectSetVisiblec1:
	ldh a,(<hActiveObjectType)	; $1e3c
	add Object.visible			; $1e3e
	ld e,a			; $1e40
	ld a,$c1		; $1e41
	ld (de),a		; $1e43
	ret			; $1e44
;;
; @addr{1e45}
objectSetVisiblec2:
	ldh a,(<hActiveObjectType)	; $1e45
	add Object.visible			; $1e47
	ld e,a			; $1e49
	ld a,$c2		; $1e4a
	ld (de),a		; $1e4c
	ret			; $1e4d
;;
; @addr{1e4e}
objectSetVisiblec3:
	ldh a,(<hActiveObjectType)	; $1e4e
	add Object.visible			; $1e50
	ld e,a			; $1e52
	ld a,$c3		; $1e53
	ld (de),a		; $1e55
	ret			; $1e56
;;
; @addr{1e57}
objectSetVisible80:
	ldh a,(<hActiveObjectType)	; $1e57
	add Object.visible			; $1e59
	ld e,a			; $1e5b
	ld a,$80		; $1e5c
	ld (de),a		; $1e5e
	ret			; $1e5f
;;
; @addr{1e60}
objectSetVisible81:
	ldh a,(<hActiveObjectType)	; $1e60
	add Object.visible			; $1e62
	ld e,a			; $1e64
	ld a,$81		; $1e65
	ld (de),a		; $1e67
	ret			; $1e68
;;
; @addr{1e69}
objectSetVisible82:
	ldh a,(<hActiveObjectType)	; $1e69
	add Object.visible			; $1e6b
	ld e,a			; $1e6d
	ld a,$82		; $1e6e
	ld (de),a		; $1e70
	ret			; $1e71
;;
; @addr{1e72}
objectSetVisible83:
	ldh a,(<hActiveObjectType)	; $1e72
	add Object.visible			; $1e74
	ld e,a			; $1e76
	ld a,$83		; $1e77
	ld (de),a		; $1e79
	ret			; $1e7a

;;
; @addr{1e7b}
objectSetInvisible:
	ldh a,(<hActiveObjectType)	; $1e7b
	add Object.visible			; $1e7d
	ld l,a			; $1e7f
	ld h,d			; $1e80
	res 7,(hl)		; $1e81
	ret			; $1e83
;;
; @addr{1e84}
objectSetVisible:
	ldh a,(<hActiveObjectType)	; $1e84
	add Object.visible			; $1e86
	ld l,a			; $1e88
	ld h,d			; $1e89
	set 7,(hl)		; $1e8a
	ret			; $1e8c

;;
; @addr{1e8d}
objectSetReservedBit1:
	ldh a,(<hActiveObjectType)	; $1e8d
	ld l,a			; $1e8f
	ld h,d			; $1e90
	set 1,(hl)		; $1e91
	ret			; $1e93

;;
; @addr{1e94}
objectGetAngleTowardEnemyTarget:
	ldh a,(<hEnemyTargetY)	; $1e94
	ld b,a			; $1e96
	ldh a,(<hEnemyTargetX)	; $1e97
	ld c,a			; $1e99
	jr objectGetRelativeAngle		; $1e9a

;;
; @addr{1e9c}
objectGetAngleTowardLink:
	ld a,(w1Link.yh)		; $1e9c
	ld b,a			; $1e9f
	ld a,(w1Link.xh)		; $1ea0
	ld c,a			; $1ea3
;;
; Get the angle needed to move an object toward a position.
;
; @param	bc	YX position to get the direction toward
; @param	d	Current object
; @param[out]	a	An angle value pointing towards bc
; @addr{1ea4}
objectGetRelativeAngle:

; Internal variables:
;  hFF8E: X
;  hFF8F: Y

	ldh a,(<hActiveObjectType)	; $1ea4
	or Object.yh			; $1ea6
	ld e,a			; $1ea8

;;
; @param	bc	YX position to get the direction toward
; @param	de	Address of an object's Y position
; @addr{1ea9}
getRelativeAngle:
	ld a,(de)		; $1ea9
	ldh (<hFF8F),a	; $1eaa
	inc e			; $1eac
	inc e			; $1ead
	ld a,(de)		; $1eae
	ldh (<hFF8E),a	; $1eaf
;;
; @param	bc	YX position to get the direction toward
; @param	d	Current object
; @param	hFF8E	X position of object
; @param	hFF8F	Y position of object
; @addr{1eb1}
objectGetRelativeAngleWithTempVars:
	ld e,$08		; $1eb1
	ld a,b			; $1eb3
	add e			; $1eb4
	ld b,a			; $1eb5
	ld a,c			; $1eb6
	add e			; $1eb7
	ld c,a			; $1eb8
	ld e,$00		; $1eb9
	ldh a,(<hFF8F)	; $1ebb
	add $08			; $1ebd
	sub b			; $1ebf
	jr nc,+			; $1ec0

	cpl			; $1ec2
	inc a			; $1ec3
	ld e,$04		; $1ec4
+
	ld h,a			; $1ec6
	ldh a,(<hFF8E)	; $1ec7
	add $08			; $1ec9
	sub c			; $1ecb
	jr nc,+			; $1ecc

	cpl			; $1ece
	inc a			; $1ecf
	inc e			; $1ed0
	inc e			; $1ed1
+
	cp h			; $1ed2
	jr nc,+			; $1ed3

	inc e			; $1ed5
	ld l,a			; $1ed6
	ld a,h			; $1ed7
	ld h,l			; $1ed8
+
	ld c,e			; $1ed9
	ld b,$00		; $1eda
	srl a			; $1edc
	srl a			; $1ede
	srl a			; $1ee0
	add a			; $1ee2
	ld l,a			; $1ee3
	cp h			; $1ee4
	jr nc,++		; $1ee5

	inc b			; $1ee7
	add l			; $1ee8
	cp h			; $1ee9
	jr nc,++		; $1eea

	inc b			; $1eec
	add l			; $1eed
	cp h			; $1eee
	jr nc,++		; $1eef

	inc b			; $1ef1
	add l			; $1ef2
	cp h			; $1ef3
	jr nc,++		; $1ef4
	inc b			; $1ef6
++
	ld a,c			; $1ef7
	add a			; $1ef8
	add a			; $1ef9
	add a			; $1efa
	add b			; $1efb
	ld c,a			; $1efc
	ld b,$00		; $1efd
	ld hl,pushDirectionData	; $1eff
	add hl,bc		; $1f02
	ld a,(hl)		; $1f03
	ret			; $1f04

; @addr{1f05}
pushDirectionData:
	.db $18 $19 $1a $1b $1c $00 $00 $00
	.db $00 $1f $1e $1d $1c $00 $00 $00
	.db $08 $07 $06 $05 $04 $00 $00 $00
	.db $00 $01 $02 $03 $04 $00 $00 $00
	.db $18 $17 $16 $15 $14 $00 $00 $00
	.db $10 $11 $12 $13 $14 $00 $00 $00
	.db $08 $09 $0a $0b $0c $00 $00 $00
	.db $10 $0f $0e $0d $0c $00 $00 $00

;;
; @param	a	Z Acceleration (gravity)
; @param[out]	hl	Object.speedZ variable
; @param[out]	zflag	Set if resulting position is below or on the ground
; @addr{1f45}
objectUpdateSpeedZ:
	ld c,a			; $1f45
;;
; @param	c	Z Acceleration (gravity)
; @param[out]	hl	Object.speedZ variable
; @param[out]	zflag	Set if resulting position is below or on the ground
; @addr{1f46}
objectUpdateSpeedZ_paramC:
	ldh a,(<hActiveObjectType)	; $1f46
	add Object.z			; $1f48
	ld e,a			; $1f4a
	add Object.speedZ - Object.z			; $1f4b
	ld l,a			; $1f4d
	ld h,d			; $1f4e
	call add16BitRefs		; $1f4f
	bit 7,a			; $1f52
	jr z,@belowGround

; Above ground
	dec l			; $1f56
	ld a,c			; $1f57
	add (hl)		; $1f58
	ldi (hl),a		; $1f59
	ld a,$00		; $1f5a
	adc (hl)		; $1f5c
	ld (hl),a		; $1f5d
	or d			; $1f5e
	ret			; $1f5f

; Can't be below ground, set z position to 0
@belowGround:
	xor a			; $1f60
	ld (de),a		; $1f61
	dec e			; $1f62
	ld (de),a		; $1f63
	xor a			; $1f64
	ret			; $1f65

;;
; Updates an object's speedZ in a way that works with sidescrolling areas. This assumes
; that the object's width has a particular value (8 pixels?), but its height can be
; specified with the 'b' parameter.
;
; @param	a	Gravity (amount to add to Object.speedZ)
; @param[out]	cflag	Set if the object has landed.
; @param[out]	hl	Object.speedZ+1
; @addr{1f66}
objectUpdateSpeedZ_sidescroll:
	ld b,$06		; $1f66

;;
; @param	a	Gravity (amount to add to Object.speedZ)
; @param	b	Y offset for collision check
; @param[out]	cflag	Set if the object has landed.
; @param[out]	hl	Object.speedZ+1
; @addr{1f68}
objectUpdateSpeedZ_sidescroll_givenYOffset:
	ldh (<hFF8B),a	; $1f68
	ldh a,(<hActiveObjectType)	; $1f6a
	add Object.speedZ+1			; $1f6c
	ld l,a			; $1f6e
	ld h,d			; $1f6f
	bit 7,(hl)		; $1f70
	jr nz,@notLanded	; $1f72

; speedZ is positive; return with carry flag set if the object collides with a tile.

	; Set b to object's y position (plus offset)
	add Object.yh-(Object.speedZ+1)			; $1f74
	ld l,a			; $1f76
	ldi a,(hl)		; $1f77
	add b			; $1f78
	ld b,a			; $1f79

	; hl = Object.xh
	inc l			; $1f7a
	ld a,(hl)		; $1f7b

	; Check left side of object (assumes 8 pixel width?)
	sub $04			; $1f7c
	ld c,a			; $1f7e
	call checkTileCollisionAt_allowHoles		; $1f7f
	ret c			; $1f82

	; Check right side of object (assumes 8 pixel width?)
	ld a,c			; $1f83
	add $07			; $1f84
	ld c,a			; $1f86
	call checkTileCollisionAt_allowHoles		; $1f87
	ret c			; $1f8a

@notLanded:
	; Add speedZ to y position
	ldh a,(<hActiveObjectType)	; $1f8b
	add Object.y			; $1f8d
	ld e,a			; $1f8f
	add Object.speedZ-Object.y			; $1f90
	ld l,a			; $1f92
	ld h,d			; $1f93
	call add16BitRefs		; $1f94

	; Apply gravity (increase speedZ by amount passed to function)
	dec l			; $1f97
	ldh a,(<hFF8B)	; $1f98
	add (hl)		; $1f9a
	ldi (hl),a		; $1f9b
	ld a,$00		; $1f9c
	adc (hl)		; $1f9e
	ld (hl),a		; $1f9f

	; Clear carry flag
	or d			; $1fa0
	ret			; $1fa1

;;
; Checks if Link is within the distance given to the object (valid area is a square).
;
; Returns the direction Link is in relative to the object, in a slightly different format
; than normal?
;
; @param	c	How close Link should be to the object
; @param[out]	a	Direction Link is in relative to the object? (divide by 2 to get
;			a standard direction value)
; @param[out]	cflag	c if Link is within the specified distance. If unset, 'a' won't
;			be calculated properly.
; @addr{1fa2}
objectCheckLinkWithinDistance:
	ldh a,(<hActiveObjectType)	; $1fa2

	; Get the difference between the object's and link's y positions
	add Object.yh			; $1fa4
	ld l,a			; $1fa6
	ld h,d			; $1fa7
	ld e,$04		; $1fa8
	ld a,(w1Link.yh)		; $1faa
	sub (hl)		; $1fad
	jr nc,+			; $1fae
	cpl			; $1fb0
	inc a			; $1fb1
	ld e,$00		; $1fb2
+
	ld b,a			; $1fb4
	ld a,c			; $1fb5
	sub b			; $1fb6
	ccf			; $1fb7
	ret nc			; $1fb8

	; Get the difference between the object's and link's x positions
	ld c,a			; $1fb9
	inc l			; $1fba
	inc l			; $1fbb
	set 5,e			; $1fbc
	ld a,(w1Link.xh)		; $1fbe
	sub (hl)		; $1fc1
	jr nc,+			; $1fc2

	cpl			; $1fc4
	inc a			; $1fc5
	set 6,e			; $1fc6
+
	cp c			; $1fc8
	ret nc			; $1fc9
	cp b			; $1fca
	jr c,+			; $1fcb
	swap e			; $1fcd
+
	ld a,e			; $1fcf
	and $06			; $1fd0
	scf			; $1fd2
	ret			; $1fd3

;;
; Increments or decrements an object's angle by one unit toward the given value.
;
; @param	a	Angle value to move toward
; @addr{1fd4}
objectNudgeAngleTowards:
	ld c,a			; $1fd4
	ldh a,(<hActiveObjectType)	; $1fd5
	add Object.angle			; $1fd7
	ld e,a			; $1fd9
	ld a,(de)		; $1fda
	ld b,a			; $1fdb

	sub c			; $1fdc
	jr z,++			; $1fdd

	and $1f			; $1fdf
	cp $10			; $1fe1
	jr nc,+			; $1fe3

	dec b			; $1fe5
	jr ++			; $1fe6
+
	inc b			; $1fe8
++
	ld a,b			; $1fe9
	and $1f			; $1fea
	ld (de),a		; $1fec
	ret			; $1fed

;;
; Checks if link is centered within 'b' pixels compared to another object (horizontally or
; vertically).
;
; @param	b	Distance threshold
; @param	d	Object to compare with
; @param[out]	cflag	Set if link is centered within the threshold given.
; @addr{1fee}
objectCheckCenteredWithLink:
	ld c,b			; $1fee
	sla c			; $1fef
	inc c			; $1ff1

	; Check Y
	ld h,d			; $1ff2
	ldh a,(<hActiveObjectType)	; $1ff3
	add Object.yh			; $1ff5
	ld l,a			; $1ff7
	ld a,(w1Link.yh)		; $1ff8
	sub (hl)		; $1ffb
	add b			; $1ffc
	cp c			; $1ffd
	ret c			; $1ffe

	; Check X
	inc l			; $1fff
	inc l			; $2000
	ld a,(w1Link.xh)		; $2001
	sub (hl)		; $2004
	add b			; $2005
	cp c			; $2006
	ret			; $2007

;;
; This function reads Object.speed differently than most places (ie. objectApplySpeed). It
; adds variables $10-$11 to Object.y as a 16-bit value, and $12-$13 to Object.x.
;
; @addr{2008}
objectApplyComponentSpeed:
	ldh a,(<hActiveObjectType)	; $2008
	add Object.y			; $200a
	ld l,a			; $200c
	add Object.speed-Object.y			; $200d
	ld e,a			; $200f
	ld h,d			; $2010
	call @addSpeedComponent		; $2011
	inc e			; $2014

;;
; @addr{2015}
@addSpeedComponent:
	ld a,(de)		; $2015
	add (hl)		; $2016
	ldi (hl),a		; $2017
	inc e			; $2018
	ld a,(de)		; $2019
	adc (hl)		; $201a
	ldi (hl),a		; $201b
	ret			; $201c

;;
; Uses the object's speed and angle variables to update its position.
;
; @param[out]	a	New value of object.xh
; @addr{201d}
objectApplySpeed:
	ld h,d			; $201d
	ldh a,(<hActiveObjectType)	; $201e
	add Object.angle		; $2020
	ld e,a			; $2022
	ld l,a			; $2023
	ld c,(hl)		; $2024
	add Object.speed-Object.angle		; $2025
	ld l,a			; $2027
	ld b,(hl)		; $2028

;;
; @param	b	speed value
; @param	c	angle value
; @param	de	Address of an object's angle variable (will only read/write the
;			Y and X values which follow that, not the angle itself).
; @param[out]	a	New value of object.xh
; @addr{2029}
objectApplyGivenSpeed:
	call getPositionOffsetForVelocity		; $2029
	ret z			; $202c

	; Add to Object.y
	inc e			; $202d
	ld a,(de)		; $202e
	add (hl)		; $202f
	ld (de),a		; $2030
	inc e			; $2031
	inc l			; $2032
	ld a,(de)		; $2033
	adc (hl)		; $2034
	ld (de),a		; $2035

	; Add to Object.x
	inc e			; $2036
	inc l			; $2037
	ld a,(de)		; $2038
	add (hl)		; $2039
	ld (de),a		; $203a
	inc e			; $203b
	inc l			; $203c
	ld a,(de)		; $203d
	adc (hl)		; $203e
	ld (de),a		; $203f
	ret			; $2040

;;
; Takes a speed and an angle, and calculates the values to add to an object's y and
; x positions.
;
; @param	b	speed (should be a multiple of 5)
; @param	c	angle (value from $00-$1f)
; @param[out]	hl	Pointer to 4 bytes of data to be added to Y and X positions.
;			It always points to wTmpcec0.
; @param[out]	zflag	Set if the speed / angle was invalid (or speed is zero)
; @addr{2041}
getPositionOffsetForVelocity:
	bit 7,c			; $2041
	jr nz,@invalid		; $2043

	swap b			; $2045
	jr z,@invalid		; $2047

	ld a,b			; $2049
	ld hl,objectSpeedTable-$50		; $204a
	sla c			; $204d
	ld b,$00		; $204f
	add hl,bc		; $2051

	ld b,a			; $2052
	and $f0			; $2053
	ld c,a			; $2055
	ld a,b			; $2056
	and $0f			; $2057
	ld b,a			; $2059
	add hl,bc		; $205a
	ldh a,(<hRomBank)	; $205b
	push af			; $205d
	ld a,:objectSpeedTable		; $205e
	setrombank		; $2060

	; Get Y values
	ld bc,wTmpcec0		; $2065
	ldi a,(hl)		; $2068
	ld (bc),a		; $2069
	inc c			; $206a
	ldi a,(hl)		; $206b
	ld (bc),a		; $206c

	; Get X values
	inc c			; $206d
	ld a,$0e		; $206e
	rst_addAToHl			; $2070

	ldi a,(hl)		; $2071
	ld (bc),a		; $2072
	inc c			; $2073
	ldi a,(hl)		; $2074
	ld (bc),a		; $2075

	pop af			; $2076
	setrombank		; $2077

	ld hl,wTmpcec0		; $207c
	or h			; $207f
	ret			; $2080

@invalid:
	ld hl,wTmpcec0+3		; $2081
	xor a			; $2084
	ldd (hl),a		; $2085
	ldd (hl),a		; $2086
	ldd (hl),a		; $2087
	ld (hl),a		; $2088
	ret			; $2089

;;
; @param[out]	bc	Object's position
; @addr{208a}
objectGetPosition:
	ldh a,(<hActiveObjectType)	; $208a
	add Object.yh		; $208c
	ld e,a			; $208e
	ld a,(de)		; $208f
	ld b,a			; $2090
	inc e			; $2091
	inc e			; $2092
	ld a,(de)		; $2093
	ld c,a			; $2094
	ret			; $2095

;;
; @param[out]	a	Object's position (short form)
; @addr{2096}
objectGetShortPosition:
	ldh a,(<hActiveObjectType)	; $2096
	add Object.yh		; $2098
	ld e,a			; $209a
;;
; @addr{209b}
getShortPositionFromDE:
	ld a,(de)		; $209b
--
	and $f0			; $209c
	ld b,a			; $209e
	inc e			; $209f
	inc e			; $20a0
	ld a,(de)		; $20a1
	swap a			; $20a2
	and $0f			; $20a4
	or b			; $20a6
	ret			; $20a7

;;
; @param	a	Value to add to the object's Y position before calculating
; @param[out]	a	Object's position (short form)
; @addr{20a8}
objectGetShortPosition_withYOffset:
	ld b,a			; $20a8
	ldh a,(<hActiveObjectType)	; $20a9
	add Object.yh			; $20ab
	ld e,a			; $20ad
	ld a,(de)		; $20ae
	add b			; $20af
	jr --			; $20b0

;;
; Writes $0f to the collision value of the tile the object is standing on.
;
; @addr{20b2}
objectMakeTileSolid:
	call objectGetTileCollisions		; $20b2
	ld (hl),$0f		; $20b5
	ret			; $20b7

;;
; @param	a	Short-form position
; @param	hl	Address to write to (usually an Object.yh)
; @addr{20b8}
setShortPosition:
	ld c,a			; $20b8
;;
; @param	c	Short-form position
; @param	hl	Address to write to (usually an Object.yh)
; @addr{20b9}
setShortPosition_paramC:
	push bc			; $20b9
	call convertShortToLongPosition_paramC		; $20ba
	ld (hl),b		; $20bd
	inc l			; $20be
	inc l			; $20bf
	ld (hl),c		; $20c0
	pop bc			; $20c1
	ret			; $20c2

;;
; Set an object's position.
;
; @param	c	Short-form position
; @addr{20c3}
objectSetShortPosition:
	ld h,d			; $20c3
	ldh a,(<hActiveObjectType)	; $20c4
	add Object.yh		; $20c6
	ld l,a			; $20c8
	jr setShortPosition_paramC		; $20c9

;;
; @param	a	Short-form position (YX)
; @param[out]	bc	Long-form position (YYXX)
; @addr{20cb}
convertShortToLongPosition:
	ld c,a			; $20cb
;;
; @param	c	Short-form position (YX)
; @param[out]	bc	Long-form position (YYXX)
; @addr{20cc}
convertShortToLongPosition_paramC:
	ld a,c			; $20cc
	and $f0			; $20cd
	or $08			; $20cf
	ld b,a			; $20d1
	ld a,c			; $20d2
	swap a			; $20d3
	and $f0			; $20d5
	or $08			; $20d7
	ld c,a			; $20d9
	ret			; $20da

;;
; @addr{20db}
objectCenterOnTile:
	ldh a,(<hActiveObjectType)	; $20db
	add Object.y		; $20dd
	ld l,a			; $20df
	ld h,d			; $20e0

;;
; Adjust 16-bit coordinates to the center of a tile.
;
; @param	hl
; @addr{20e1}
centerCoordinatesOnTile:
	; Center Y
	xor a			; $20e1
	ldi (hl),a		; $20e2
	ld a,(hl)		; $20e3
	and $f0			; $20e4
	or $08			; $20e6
	ldi (hl),a		; $20e8

	; Center X
	xor a			; $20e9
	ldi (hl),a		; $20ea
	ld a,(hl)		; $20eb
	and $f0			; $20ec
	or $08			; $20ee
	ld (hl),a		; $20f0
	ret			; $20f1

;;
; Checks to see if a certain number of part slots are available.
;
; @param	b	Number of part slots to check for
; @param[out]	zflag	Set if there are at least 'b' part slots available.
; @addr{20f2}
checkBPartSlotsAvailable:
	ldhl FIRST_PART_INDEX, Part.enabled		; $20f2
	jr checkBEnemySlotsAvailable@nextSlot

;;
; @addr{20f7}
checkBEnemySlotsAvailable:
	ldhl FIRST_ENEMY_INDEX, Enemy.enabled		; $20f7

@nextSlot:
	call @checkSlotAvailable		; $20fa
	jr c,@nextSlot
	ret nz			; $20ff
	dec b			; $2100
	jr nz,@nextSlot
	ret			; $2103

;;
; @addr{2104}
@checkSlotAvailable:
	ld a,(hl)		; $2104
	inc h			; $2105
	or a			; $2106
	ret z			; $2107
	ld a,h			; $2108
	cp $e0			; $2109
	ret c			; $210b
	or h			; $210c
	ret			; $210d

;;
; Places an object 'a' units away from a specified position, where one unit is one pixel,
; or the equivalent of one pixel for diagonal angles. Useful for placing an object along
; the perimeter of a circle.
;
; Used, for instance, by the sparkles after telling a secret to Farore. "bc" is the
; position of the chest (the center of the circle), "a" is how far away they are from the
; chest, and "de" points to their current angle from the chest.
;
; @param	a	Distance away from bc to put the object
; @param	bc	Relative offset ("center of the circle")
; @param	de	Pointer to the object's angle value
; @param[out]	de	Object.xh
; @addr{210e}
objectSetPositionInCircleArc:
	push bc			; $210e
	ld h,d			; $210f
	ld l,e			; $2110
	ld c,(hl)		; $2111
	ld b,SPEED_100		; $2112
	call getScaledPositionOffsetForVelocity		; $2114
	pop bc			; $2117

	; Add Y offset
	ldh a,(<hActiveObjectType)	; $2118
	add Object.yh		; $211a
	ld e,a			; $211c
	ld a,(wTmpcec0+1)		; $211d
	add b			; $2120
	ld (de),a		; $2121

	; Add X offset
	inc e			; $2122
	inc e			; $2123
	ld a,(wTmpcec0+3)		; $2124
	add c			; $2127
	ld (de),a		; $2128
	ret			; $2129

;;
; This appears to multiply a position offset by a certain amount.
;
; @param	a		Amount to multiply the resulting position offsets by
; @param	b		Speed
; @param	c		Angle
; @param[out]	wTmpcec0	The scaled values are stored here (4 bytes total).
; @param[out]	hl		wTmpcec0+3
; @addr{212a}
getScaledPositionOffsetForVelocity:
	ldh (<hFF8B),a	; $212a
	call getPositionOffsetForVelocity		; $212c

	call @scaleComponent		; $212f
	inc l			; $2132

;;
; @param	hl	Address of position offset to scale
; @param	hFF8B	Amount to scale the position offsets by
; @addr{2133}
@scaleComponent:
	push hl			; $2133
	ldi a,(hl)		; $2134
	ld c,a			; $2135
	ld b,(hl)		; $2136

	; Multiply 'bc' by [hFF8B], storing the result in 'hl'?
	ld e,$08		; $2137
	ld hl,$0000		; $2139
	ldh a,(<hFF8B)	; $213c
--
	add hl,hl		; $213e
	rlca			; $213f
	jr nc,+			; $2140
	add hl,bc		; $2142
+
	dec e			; $2143
	jr nz,--		; $2144

	; Store the scaled values
	ld a,l			; $2146
	ld b,h			; $2147
	pop hl			; $2148
	ldi (hl),a		; $2149
	ld (hl),b		; $214a
	ret			; $214b

;;
; Set's an object's "component speed" (separate x/y speed variables) via the given speed
; & angle values.
;
; @param	a	Amount to multiply speed by
; @param	b	Speed
; @param	c	Angle
; @addr{214c}
objectSetComponentSpeedByScaledVelocity:
	call getScaledPositionOffsetForVelocity		; $214c

	ldh a,(<hActiveObjectType)	; $214f
	or Object.speedX+1			; $2151

	; X speed
	ld e,a			; $2153
	ldd a,(hl)		; $2154
	ld (de),a		; $2155
	dec e			; $2156
	ldd a,(hl)		; $2157
	ld (de),a		; $2158

	; Y speed
	dec e			; $2159
	ldd a,(hl)		; $215a
	ld (de),a		; $215b
	dec e			; $215c
	ld a,(hl)		; $215d
	ld (de),a		; $215e
	ret			; $215f

;;
; Gets the address of a variable in relatedObj1.
;
; @param	a	Which variable to get for relatedObj1
; @param[out]	hl	Address of the variable
; @addr{2160}
objectGetRelatedObject1Var:
	ld l,Object.relatedObj1		; $2160
	jr ++

;;
; @addr{2164}
objectGetRelatedObject2Var:
	ld l,Object.relatedObj2		; $2164
++
	ld h,a			; $2166
	ldh a,(<hActiveObjectType)	; $2167
	add l			; $2169
	ld e,a			; $216a
	ld a,(de)		; $216b
	add h			; $216c
	ld l,a			; $216d
	inc e			; $216e
	ld a,(de)		; $216f
	ld h,a			; $2170
	ret			; $2171

;;
; Returns a Z position such that the object would be immediately above the screen if
; assigned this value.
;
; @param[out]	a	Z position
; @addr{2172}
objectGetZAboveScreen:
	ldh a,(<hActiveObjectType)	; $2172
	add Object.yh		; $2174
	ld e,a			; $2176
	ld a,(de)		; $2177
	ld b,a			; $2178
	ldh a,(<hCameraY)	; $2179
	sub b			; $217b
	sub $08			; $217c
	cp $80			; $217e
	ret nc			; $2180

	ld a,$80		; $2181
	ret			; $2183

;;
; Checks if the object is within the screen. Note the screen size may be smaller than the
; room size (in dungeons).
;
; Seems to give leeway of 8 pixels in either direction, unless that's somehow part of the
; calculation. (Is it expecting 16x16-size objects?)
;
; @param[out]	cflag	Set if the object is within the screen boundary
; @addr{2184}
objectCheckWithinScreenBoundary:
	ldh a,(<hCameraY)	; $2184
	ld b,a			; $2186
	ldh a,(<hCameraX)	; $2187
	ld c,a			; $2189
	ldh a,(<hActiveObjectType)	; $218a
	add Object.yh			; $218c
	ld e,a			; $218e
	ld a,(de)		; $218f
	sub b			; $2190
	add $07			; $2191
	cp $90-1			; $2193
	ret nc			; $2195

	inc e			; $2196
	inc e			; $2197
	ld a,(de)		; $2198
	sub c			; $2199
	add $07			; $219a
	cp $b0-1			; $219c
	ret			; $219e

;;
; @param[out]	cflag	Set if the object is within the room boundary
; @addr{219f}
objectCheckWithinRoomBoundary:
	ldh a,(<hActiveObjectType)	; $219f
	add Object.yh			; $21a1
	ld e,a			; $21a3
	ld hl,wRoomEdgeY		; $21a4
	ld a,(de)		; $21a7
	cp (hl)			; $21a8
	ret nc			; $21a9

	inc e			; $21aa
	inc e			; $21ab
	inc l			; $21ac
	ld a,(de)		; $21ad
	cp (hl)			; $21ae
	ret			; $21af

;;
; Deletes the object (clears its memory), then replaces its ID with the new value.
;
; The new object keeps its former yh, xh, zh, and enabled values.
;
; @param	bc	New object ID
; @addr{21b0}
objectReplaceWithID:
	ld h,d			; $21b0
	push bc			; $21b1

	; Store Object.enabled, Y position
	ldh a,(<hActiveObjectType)	; $21b2
	ld l,a			; $21b4
	ld b,(hl)		; $21b5
	add Object.yh			; $21b6
	ld l,a			; $21b8
	ld c,(hl)		; $21b9
	push bc			; $21ba

	; Store X, Z
	inc l			; $21bb
	inc l			; $21bc
	ld b,(hl)		; $21bd
	inc l			; $21be
	inc l			; $21bf
	ld c,(hl)		; $21c0
	push bc			; $21c1

	; Delete object
	call objectDelete_useActiveObjectType		; $21c2

	; Restore X/Y/Z positions
	pop bc			; $21c5
	ld h,d			; $21c6
	ldh a,(<hActiveObjectType)	; $21c7
	add Object.zh			; $21c9
	ld l,a			; $21cb
	ld (hl),c		; $21cc
	dec l			; $21cd
	dec l			; $21ce
	ld (hl),b		; $21cf
	pop bc			; $21d0
	dec l			; $21d1
	dec l			; $21d2
	ld (hl),c		; $21d3

	; Restore Object.enabled (only first 2 bits?)
	ldh a,(<hActiveObjectType)	; $21d4
	ld l,a			; $21d6
	ld a,b			; $21d7
	and $03			; $21d8
	ldi (hl),a		; $21da

	; Set Object.id, subid
	pop bc			; $21db
	ld (hl),b		; $21dc
	inc l			; $21dd
	ld (hl),c		; $21de
	ret			; $21df

;;
; @addr{21e0}
objectDelete_useActiveObjectType:
	ldh a,(<hActiveObjectType)	; $21e0
	ld e,a			; $21e2

;;
; @addr{21e3}
objectDelete_de:
	ld a,e			; $21e3
	and $c0			; $21e4
	ld e,a			; $21e6
	ld l,a			; $21e7
	ld h,d			; $21e8
	ld b,$10		; $21e9
	xor a			; $21eb
--
	ldi (hl),a		; $21ec
	ldi (hl),a		; $21ed
	ldi (hl),a		; $21ee
	ldi (hl),a		; $21ef
	dec b			; $21f0
	jr nz,--		; $21f1
	jp objectRemoveFromAButtonSensitiveObjectList		; $21f3

;;
; Check if Link is over a pit (water, hole, or lava). If he's riding dimitri, this check
; always comes up false.
;
; Note: this overwrites the current hActiveObject.
;
; @param[out]	a	$01 if water, $02 if hole, $04 if lava
; @param[out]	cflag	Set if Link is on one of the above tiles.
; @addr{21f6}
checkLinkIsOverHazard:
	ld a,(wLinkObjectIndex)		; $21f6
	ld d,a			; $21f9
	ldh (<hActiveObject),a	; $21fa
	xor a			; $21fc
	ldh (<hActiveObjectType),a	; $21fd

	ld e,SpecialObject.id		; $21ff
	ld a,(de)		; $2201
	sub SPECIALOBJECTID_DIMITRI			; $2202
	ret z			; $2204

	push bc			; $2205
	push hl			; $2206
	call objectCheckIsOverHazard		; $2207
	pop hl			; $220a
	pop bc			; $220b
	ret			; $220c

;;
; Check if an object is on water, lava, or a hole. Same as the below function, except if
; the object is in midair, it doesn't count.
;
; @param[out]	a	$01 if water, $02 if hole, $04 if lava
; @param[out]	cflag	Set if the object is on one of these tiles.
; @addr{220d}
objectCheckIsOnHazard:
	ldh a,(<hActiveObjectType)	; $220d
	add Object.zh			; $220f
	ld e,a			; $2211
	ld a,(de)		; $2212
	and $80			; $2213
	ret nz			; $2215
;;
; Check if an object is over water, lava, or a hole.
;
; @param[out]	a	$01 if water, $02 if hole, $04 if lava
; @param[out]	cflag	Set if the object is on one of these tiles.
; @addr{2216}
objectCheckIsOverHazard:
	ld bc,$0500		; $2216
	call objectGetRelativeTile		; $2219
.ifdef ROM_AGES
	ld (wObjectTileIndex),a		; $221c
.endif
	ld hl,hazardCollisionTable	; $221f
	jp lookupCollisionTable		; $2222

;;
; If the object is over a pit, this replaces it with an appropriate animation.
;
; @param[out]	cflag	Set if the object was on a pit.
; @addr{2225}
objectReplaceWithAnimationIfOnHazard:
	call objectCheckIsOnHazard		; $2225
	ret nc			; $2228

	rrca			; $2229
	jr c,objectReplaceWithSplash		; $222a

	rrca			; $222c
	jr c,objectReplaceWithFallingDownHoleInteraction		; $222d

	ld b,INTERACID_LAVASPLASH		; $222f
	jr objectReplaceWithSplash@create			; $2231

;;
; @addr{2233}
objectReplaceWithFallingDownHoleInteraction:
	call objectCreateFallingDownHoleInteraction		; $2233
	jr objectReplaceWithSplash@delete			; $2236

;;
; @addr{2238}
objectReplaceWithSplash:
	ld b,INTERACID_SPLASH		; $2238
@create:
	call objectCreateInteractionWithSubid00		; $223a
@delete:
	call objectDelete_useActiveObjectType		; $223d
	scf			; $2240
	ret			; $2241

;;
; Copies xyz position of object d to object h.
;
; @param[out]	de	Object d's 'zh' variable
; @param[out]	hl	Object h's 'speed' variable (one past 'zh')
; @addr{2242}
objectCopyPosition:
	ldh a,(<hActiveObjectType)	; $2242
	add Object.yh		; $2244
	ld e,a			; $2246
;;
; Copies the xyz position at address de to object h.
;
; @addr{2247}
objectCopyPosition_rawAddress:
	ld a,l			; $2247
	and $c0			; $2248
	add Object.yh		; $224a
	ld l,a			; $224c
	ld a,(de)		; $224d
	ldi (hl),a		; $224e
	inc e			; $224f
	inc e			; $2250
	inc l			; $2251
	ld a,(de)		; $2252
	ldi (hl),a		; $2253
	inc e			; $2254
	inc e			; $2255
	inc l			; $2256
	ld a,(de)		; $2257
	ldi (hl),a		; $2258
	ret			; $2259

;;
; Copies xyz position of object d to object h and adds an offset.
;
; @param	bc	YX offset
; @addr{225a}
objectCopyPositionWithOffset:
	ldh a,(<hActiveObjectType)	; $225a
	add Object.yh		; $225c
	ld e,a			; $225e
	ld a,l			; $225f
	and $c0			; $2260
	add Object.yh		; $2262
	ld l,a			; $2264

	ld a,(de)		; $2265
	add b			; $2266
	ldi (hl),a		; $2267

	inc e			; $2268
	inc e			; $2269
	inc l			; $226a
	ld a,(de)		; $226b
	add c			; $226c
	ldi (hl),a		; $226d
	inc e			; $226e
	inc e			; $226f
	inc l			; $2270

	ld a,(de)		; $2271
	ldi (hl),a		; $2272
	ret			; $2273

;;
; Object 'd' takes the xyz position of object 'h'.
;
; @addr{2274}
objectTakePosition:
	ld bc,$0000		; $2274
;;
; Object 'd' takes the xyz position of object 'h', plus an offset.
;
; @param	b	Y offset
; @param	c	X offset
; @param[out]	a	Z position
; @param[out]	de	Address of this object's zh variable
; @param[out]	hl	Address of object h's zh variable
; @addr{2277}
objectTakePositionWithOffset:
	ldh a,(<hActiveObjectType)	; $2277
	add Object.yh			; $2279
	ld e,a			; $227b
	ld a,l			; $227c
	and $c0			; $227d
	add Object.yh			; $227f
	ld l,a			; $2281

	ldi a,(hl)		; $2282
	add b			; $2283
	ld (de),a		; $2284

	inc e			; $2285
	inc e			; $2286
	inc l			; $2287
	ldi a,(hl)		; $2288
	add c			; $2289
	ld (de),a		; $228a

	inc e			; $228b
	inc e			; $228c
	inc l			; $228d
	ld a,(hl)		; $228e
	ld (de),a		; $228f
	ret			; $2290

;;
; Changes a tile, and creates a "falling down hole" interaction.
;
; @param	a	Value to change the tile to
; @param	c	Position of tile to change, and where to put the interaction
; @addr{2291}
breakCrackedFloor:
	push bc			; $2291
	call setTile		; $2292
	pop bc			; $2295

	ld a,SND_RUMBLE		; $2296
	call playSound		; $2298

	call getFreeInteractionSlot		; $229b
	ret nz			; $229e
	ld (hl),INTERACID_FALLDOWNHOLE		; $229f

	; Disable interaction's sound effect
	inc l			; $22a1
	ld (hl),$80		; $22a2

	ld l,Interaction.yh		; $22a4
	jp setShortPosition_paramC		; $22a6

;;
; @param[out]	cflag	Set if the tile at the object's position is water (even shallow
;			water)
; @addr{22a9}
objectCheckTileAtPositionIsWater:
	call objectGetTileAtPosition		; $22a9
	sub $f9			; $22ac
	cp $05			; $22ae
	ret			; $22b0

;;
; This function is used by zoras, presumably to check which positions they can spawn at.
;
; @param	bc	Position of tile
; @param[out]	cflag	Set if the tile at that position is water (even shallow water)
; @addr{22b1}
checkTileAtPositionIsWater:
	call getTileAtPosition		; $22b1
	sub $f9			; $22b4
	cp $05			; $22b6
	ret			; $22b8

;;
; @param	c	An item ID to search for
; @param[out]	hl	Address of the id variable for the first item with ID 'c'
; @param[out]	zflag	Set on success
; @addr{22b9}
findItemWithID:
	ld h,FIRST_ITEM_INDEX		; $22b9
---
	ld l,Item.id		; $22bb
	ld a,(hl)		; $22bd
	cp c			; $22be
	ret z			; $22bf
;;
; @param	c	An item ID to search for
; @param	h	The index before the first item to check
; @param[out]	zflag	Set on success
; @addr{22c0}
findItemWithID_startingAfterH:
	inc h			; $22c0
	ld a,h			; $22c1
	cp $e0			; $22c2
	jr c,---		; $22c4
	or h			; $22c6
	ret			; $22c7

;;
; Searches for an object with the given ID of the same type as the current active object.
;
; @param	c	An object ID to search for
; @param[out]	hl	Address of the id variable for the first object with ID 'c'
; @param[out]	zflag	Set on success
; @addr{22c8}
objectFindSameTypeObjectWithID:
	ldh a,(<hActiveObject)	; $22c8
	and $f0			; $22ca
	ld h,a			; $22cc

	; l = Object.id
	ldh a,(<hActiveObjectType)	; $22cd
	inc a			; $22cf
	ld l,a			; $22d0
--
	ld a,(hl)		; $22d1
	cp c			; $22d2
	ret z			; $22d3

	inc h			; $22d4
	ld a,h			; $22d5
	cp $e0			; $22d6
	jr c,--			; $22d8
	or h			; $22da
	ret			; $22db

;;
; Sets object's priority based on y, z relative to link?
;
; @addr{22dc}
objectSetPriorityRelativeToLink:
	ld c,$80		; $22dc
	jr +			; $22de

;;
; Sets object's priority based on y, z relative to link?
;
; Also sets bit 6 of visible (unlike above) which enables terrain effects (ie. pond
; puddle)
;
; @param[out]	b	Value written to Object.visible
; @param[out]	de	Address of Object.visible
; @addr{22e0}
objectSetPriorityRelativeToLink_withTerrainEffects:
	ld c,$c0		; $22e0
+
	call @getPriority		; $22e2
	ldh a,(<hActiveObjectType)	; $22e5
	add Object.visible			; $22e7
	ld e,a			; $22e9
	ld a,c			; $22ea
	or b			; $22eb
	ld (de),a		; $22ec
	ret			; $22ed

;;
; Gets priority based on height relative to link?
;
; @param	d	Object
; @param[out]	b	Priority
; @addr{22ee}
@getPriority:
	ldh a,(<hActiveObjectType)	; $22ee
	add Object.zh			; $22f0
	ld e,a			; $22f2
	ld a,(de)		; $22f3
	; return if Z position is between 1 and 16
	dec a			; $22f4
	ld b,$03		; $22f5
	cp $10			; $22f7
	ret c			; $22f9

	dec b			; $22fa
	ld a,e			; $22fb
	add Object.yh-Object.zh			; $22fc
	ld e,a			; $22fe
	ld a,(de)		; $22ff
	ld e,a			; $2300

	ld a,(wLinkObjectIndex)		; $2301
	ld h,a			; $2304
	ld l,<w1Link.yh		; $2305
	ld a,(hl)		; $2307
	add $0b			; $2308

	; cp (w1Link.yh+$0b) to Object.yh
	cp e			; $230a
	ret nc			; $230b

	; decrement b if Object.y < w1Link.yh+$0b
	dec b			; $230c
	ret			; $230d

;;
; Pushes Link away from the object if they collide.
;
; This provides "light" collision for moving objects, allowing Link to still walk through
; them with some resistance.
;
; @param[out]	cflag	Set if the object collided with Link
; @addr{230e}
objectPushLinkAwayOnCollision:
	ld a,(wLinkObjectIndex)		; $230e
	ld h,a			; $2311
	ld l,SpecialObject.enabled		; $2312
	call checkObjectsCollided		; $2314
	ret nc			; $2317

	; They've collided; calculate the angle to push Link back at
	call objectGetAngleTowardEnemyTarget		; $2318
	ld c,a			; $231b
	ld b,SPEED_100		; $231c

;;
; @param	b	Speed
; @param	c	Angle
; @addr{231e}
updateLinkPositionGivenVelocity:
	ldh a,(<hRomBank)	; $231e
	push af			; $2320
	ld a,:bank5.specialObjectUpdatePositionGivenVelocity		; $2321
	setrombank		; $2323

	; Update Link's position
	push de			; $2328
	ld a,(wLinkObjectIndex)		; $2329
	ld d,a			; $232c
	ld e,SpecialObject.enabled		; $232d
	call bank5.specialObjectUpdatePositionGivenVelocity		; $232f
	pop de			; $2332

	pop af			; $2333
	setrombank		; $2334
	scf			; $2339
	ret			; $233a

;;
; Sets the object's oam variables to mimic a background tile. Also copies the
; corresponding background palette to sprite palette 6.
;
; The object will still need to load the correct animation.
;
; @param	a	Tile index
; @addr{233b}
objectMimicBgTile:
	; Get top-left flag value in 'b', top-left tile index in 'c'
	call getTileMappingData		; $233b

	; Set oamFlagsBackup & oamFlags to $0e
	ld h,d			; $233e
	ldh a,(<hActiveObjectType)	; $233f
	add Object.oamFlagsBackup			; $2341
	ld l,a			; $2343
	ld a,$0e		; $2344
	ldi (hl),a		; $2346
	ldi (hl),a		; $2347

	; Set Object.oamTileIndexBase to the value returned from the function call above
	ld (hl),c		; $2348

	; bc = w2AreaBgPalettes + (palette index) * 8
	ld a,b			; $2349
	and $07			; $234a
	swap a			; $234c
	rrca			; $234e
	ld bc,w2AreaBgPalettes		; $234f
	call addAToBc		; $2352

	ld a,($ff00+R_SVBK)	; $2355
	push af			; $2357
	ld a,:w2AreaBgPalettes		; $2358
	ld ($ff00+R_SVBK),a	; $235a

	; Copy the background palette to sprite palette 6
	ld hl,w2AreaSprPalettes+6*8		; $235c
	ld e,$08		; $235f
--
	ld a,(bc)		; $2361
	ldi (hl),a		; $2362
	inc c			; $2363
	dec e			; $2364
	jr nz,--		; $2365

	; Slate sprite palette 6 for reloading
	ld hl,hDirtySprPalettes		; $2367
	set 6,(hl)		; $236a

	pop af			; $236c
	ld ($ff00+R_SVBK),a	; $236d
	ret			; $236f

;;
; @param	c	Gravity
; @param[out]	cflag	c if the object will no longer bounce (speedZ is sufficiently low).
; @param[out]	zflag	z if the object touched the ground
; @addr{2370}
objectUpdateSpeedZAndBounce:
	call objectUpdateSpeedZ_paramC		; $2370
	ret nz			; $2373

;;
; Inverts an object's Z speed and halves it. Used for bombs when bouncing on the ground.
;
; Once it reaches a speed of less than 1 pixel per frame downwards, it stops.
;
; @param[out]	cflag	c if the object will no longer bounce (speedZ is sufficiently low).
; @param[out]	zflag	z if the object touched the ground
; @addr{2374}
objectNegateAndHalveSpeedZ:
	ld h,d			; $2374
	ldh a,(<hActiveObjectType)	; $2375
	or Object.speedZ			; $2377
	ld l,a			; $2379

	; Get -speedZ/2 in bc
	ldi a,(hl)		; $237a
	cpl			; $237b
	ld c,a			; $237c
	ld a,(hl)		; $237d
	cpl			; $237e
	ld b,a			; $237f

	inc bc			; $2380
	sra b			; $2381
	rr c			; $2383

	; Return if bc > $ff80 (original speed is less than 1 pixel per frame downward)
	ld hl,$ff80		; $2385
	call compareHlToBc		; $2388
	inc a			; $238b
	scf			; $238c
	ret z			; $238d

	ldh a,(<hActiveObjectType)	; $238e
	or Object.speedZ			; $2390
	ld e,a			; $2392

	; Store new speedZ
	ld a,c			; $2393
	ld (de),a		; $2394
	inc e			; $2395
	ld a,b			; $2396
	ld (de),a		; $2397

	; Set carry flag on return if speed is zero
	or c			; $2398
	scf			; $2399
	ret z			; $239a

	xor a			; $239b
	ret			; $239c

;;
; @param	bc	speedZ
; @addr{239d}
objectSetSpeedZ:
	ldh a,(<hActiveObjectType)	; $239d
	add Object.speedZ			; $239f
	ld l,a			; $23a1
	ld h,d			; $23a2
	ld (hl),c		; $23a3
	inc l			; $23a4
	ld (hl),b		; $23a5
	ret			; $23a6

;;
; Adds a 16-bit variable located at hl to a 16-bit variable at de
;
; @param	de	Address to add and write result to
; @param	hl	Address of value to add
; @param[out]	a	High byte of result
; @addr{23a7}
add16BitRefs:
	ld a,(de)		; $23a7
	add (hl)		; $23a8
	ld (de),a		; $23a9
	inc e			; $23aa
	inc hl			; $23ab
	ld a,(de)		; $23ac
	adc (hl)		; $23ad
	ld (de),a		; $23ae
	ret			; $23af

;;
; @param	a	The ring to check for.
; @param[out]	zflag	Set if the currently equipped ring equals 'a'.
; @addr{23b0}
cpActiveRing:
	push hl			; $23b0
	ld hl,wActiveRing		; $23b1
	cp (hl)			; $23b4
	pop hl			; $23b5
	ret			; $23b6

;;
; @addr{23b7}
disableActiveRing:
	push hl			; $23b7
	ld hl,wActiveRing		; $23b8
	set 6,(hl)		; $23bb
	pop hl			; $23bd
	ret			; $23be

;;
; @addr{23bf}
enableActiveRing:
	push hl			; $23bf
	ld hl,wActiveRing		; $23c0
	ld a,(hl)		; $23c3
	cp $ff			; $23c4
	jr z,+			; $23c6
	res 6,(hl)		; $23c8
+
	pop hl			; $23ca
	ret			; $23cb

;;
; @addr{23cc}
interactionDecCounter1:
	ld h,d			; $23cc
	ld l,Interaction.counter1		; $23cd
	dec (hl)		; $23cf
	ret			; $23d0
;;
; @addr{23d1}
interactionDecCounter2:
	ld h,d			; $23d1
	ld l,Interaction.counter2		; $23d2
	dec (hl)		; $23d4
	ret			; $23d5
;;
; @addr{23d6}
itemDecCounter1:
	ld h,d			; $23d6
	ld l,Item.counter1		; $23d7
	dec (hl)		; $23d9
	ret			; $23da
;;
; @addr{23db}
itemDecCounter2:
	ld h,d			; $23db
	ld l,Item.counter2		; $23dc
	dec (hl)		; $23de
	ret			; $23df
;;
; @addr{23e0}
interactionIncState:
	ld h,d			; $23e0
	ld l,Interaction.state		; $23e1
	inc (hl)		; $23e3
	ret			; $23e4
;;
; @addr{23e5}
interactionIncState2:
	ld h,d			; $23e5
	ld l,Interaction.state2		; $23e6
	inc (hl)		; $23e8
	ret			; $23e9
;;
; @addr{23ea}
itemIncState:
	ld h,d			; $23ea
	ld l,Item.state		; $23eb
	inc (hl)		; $23ed
	ret			; $23ee
;;
; @addr{23ef}
itemIncState2:
	ld h,d			; $23ef
	ld l,$05		; $23f0
	inc (hl)		; $23f2
	ret			; $23f3
;;
; Unused?
; @addr{23f4}
cpInteractionState:
	ld h,d			; $23f4
	ld l,Interaction.state		; $23f5
	cp (hl)			; $23f7
	ret			; $23f8
;;
; Unused?
; @addr{23f9}
cpInteractionState2:
	ld h,d			; $23f9
	ld l,Interaction.state2		; $23fa
	cp (hl)			; $23fc
	ret			; $23fd
;;
; @addr{23fe}
checkInteractionState:
	ld e,Interaction.state		; $23fe
	ld a,(de)		; $2400
	or a			; $2401
	ret			; $2402
;;
; @addr{2403}
checkInteractionState2:
	ld e,Interaction.state2		; $2403
	ld a,(de)		; $2405
	or a			; $2406
	ret			; $2407


; Lists the water, hole, and lava tiles for each collision mode.
;
; @addr{2408}
hazardCollisionTable:
	.dw @collisions0
	.dw @collisions1
	.dw @collisions2
	.dw @collisions3
	.dw @collisions4
	.dw @collisions5

.ifdef ROM_AGES

@collisions0:
@collisions4:
	.db $fa $01
	.db $fc $01
	.db $fe $01
	.db $ff $01
	.db $e0 $01
	.db $e1 $01
	.db $e2 $01
	.db $e3 $01
	.db $f3 $02
	.db $e4 $04
	.db $e5 $04
	.db $e6 $04
	.db $e7 $04
	.db $e8 $04
	.db $e9 $01
	.db $00

@collisions1:
@collisions2:
@collisions5:
	.db $fa $01
	.db $fc $01
	.db $f3 $02
	.db $f4 $02
	.db $f5 $02
	.db $f6 $02
	.db $f7 $02
	.db $61 $04
	.db $62 $04
	.db $63 $04
	.db $64 $04
	.db $65 $04
	.db $48 $02
	.db $49 $02
	.db $4a $02
	.db $4b $02
	.db $00

@collisions3:
	.db $1a $01
	.db $1b $01
	.db $1c $01
	.db $1d $01
	.db $1e $01
	.db $1f $01
	.db $00

.else ; ROM_SEASONS

@collisions0:
	.db $f3 $02
	.db $fd $01
	.db $fe $01
	.db $ff $01
	.db $d1 $01
	.db $d2 $01
	.db $d3 $01
	.db $d4 $01
	.db $7b $04
	.db $7c $04
	.db $7d $04
	.db $7e $04
	.db $7f $04
	.db $00

@collisions1:
	.db $f3 $02
	.db $f4 $02
	.db $7b $04
	.db $7c $04
	.db $7d $04
	.db $7e $04
	.db $7f $04
	.db $c0 $04
	.db $c1 $04
	.db $c2 $04
	.db $c3 $04
	.db $c4 $04
	.db $c5 $04
	.db $c6 $04
	.db $c7 $04
	.db $c8 $04
	.db $c9 $04
	.db $ca $04
	.db $cb $04
	.db $cc $04
	.db $cd $04
	.db $ce $04
	.db $cf $04
@collisions2:
	.db $00

@collisions3:
@collisions4:
	.db $f3 $02
	.db $f4 $02
	.db $f5 $02
	.db $f6 $02
	.db $f7 $02
	.db $48 $02
	.db $49 $02
	.db $4a $02
	.db $4b $02
	.db $d0 $42
	.db $61 $04
	.db $62 $04
	.db $63 $04
	.db $64 $04
	.db $65 $04
	.db $fd $01
	.db $00

@collisions5:
	.db $0c $04
	.db $0d $04
	.db $0e $04
	.db $1a $01
	.db $1b $01
	.db $1c $01
	.db $1d $01
	.db $1e $01
	.db $1f $01
	.db $00

.endif

; Takes an angle as an index.
;
; Used in bank6.specialObjectUpdatePosition. Has something to do with how Link "slides off" tiles
; when he approaches them from the side.
;
; @addr{2461}
slideAngleTable:
	.db $80 $80 $01 $02 $02 $02 $03 $24
	.db $24 $24 $05 $06 $06 $06 $07 $48
	.db $48 $48 $09 $0a $0a $0a $0b $1c
	.db $1c $1c $0d $0e $0e $0e $0f $80

; Takes an angle as an index.
;
; Used in bank6._checkTileIsPassableFromDirection for the specific purpose of determining
; whether an item can pass through a cliff facing a certain direction. Odd values can pass
; through 2 directions, whereas even values can only pass through the direction
; corresponding to the value divided by 2 (see constants/directions.s).
;
; @addr{2481}
angleTable:
	.db $00 $00 $00 $01 $01 $01 $02 $02
	.db $02 $02 $02 $03 $03 $03 $04 $04
	.db $04 $04 $04 $05 $05 $05 $06 $06
	.db $06 $06 $06 $07 $07 $07 $00 $00

;;
; Set an object's X and Y collide radii to 'a'.
;
; @param	a	Collision radius
; @addr{24a1}
objectSetCollideRadius:
	push bc			; $24a1
	ld b,a			; $24a2
	ld c,a			; $24a3
	call objectSetCollideRadii		; $24a4
	pop bc			; $24a7
	ret			; $24a8

;;
; Set an object's YX collide radii to bc.
;
; @param	b	Collide radius Y
; @param	c	Collide radius X
; @addr{24a9}
objectSetCollideRadii:
	ldh a,(<hActiveObjectType)	; $24a9
	add Object.collisionRadiusY	; $24ab
	ld l,a			; $24ad
	ld h,d			; $24ae
	ld (hl),b		; $24af
	inc l			; $24b0
	ld (hl),c		; $24b1
	ret			; $24b2

;;
; @addr{24b3}
decNumEnemies:
	ld hl,wNumEnemies		; $24b3
	ld a,(hl)		; $24b6
	or a			; $24b7
	ret z			; $24b8
	dec (hl)		; $24b9
	ret			; $24ba

;;
; @addr{24bb}
setScreenShakeCounter:
	ld hl,wScreenShakeCounterY		; $24bb
	ldi (hl),a		; $24be
	ld (hl),a		; $24bf
	ret			; $24c0

;;
; @addr{24c1}
objectCreatePuff:
	ld b,INTERACID_PUFF		; $24c1

;;
; @param	b	High byte of interaction
; @addr{24c3}
objectCreateInteractionWithSubid00:
	ld c,$00		; $24c3

;;
; Create an interaction at the current object's position.
;
; @param	bc	Interaction ID
; @param	d	The object to get the position from
; @param[out]	a	0
; @param[out]	hl	The new interaction's 'speed' variable (one past 'zh')
; @param[out]	zflag	nz if there wasn't a free slot for the interaction
; @addr{24c5}
objectCreateInteraction:
	call getFreeInteractionSlot		; $24c5
	ret nz			; $24c8
	ld (hl),b		; $24c9
	inc l			; $24ca
	ld (hl),c		; $24cb
	call objectCopyPosition		; $24cc
	xor a			; $24cf
	ret			; $24d0

;;
; @addr{24d1}
objectCreateFallingDownHoleInteraction:
	call getFreeInteractionSlot		; $24d1
	ret nz			; $24d4

	ld (hl),INTERACID_FALLDOWNHOLE		; $24d5

	; Store object type in Interaction.counter1
	ld l,Interaction.counter1		; $24d7
	ldh a,(<hActiveObjectType)	; $24d9
	ldi (hl),a		; $24db

	; Store Object.id in Interaction.counter2
	add Object.id			; $24dc
	ld e,a			; $24de
	ld a,(de)		; $24df
	ld (hl),a		; $24e0

	call objectCopyPosition		; $24e1
	xor a			; $24e4
	ret			; $24e5

.ifdef ROM_AGES

;;
; Makes the object invisible if (wFrameCounter&b) == 0.
;
; b=1 will flicker every frame, creating a sort of transparency.
;
; @param	b	Value to AND with [wFrameCounter].
; @addr{24e6}
objectFlickerVisibility:
	ld a,(wFrameCounter)		; $24e6
	and b			; $24e9
	jp z,objectSetInvisible		; $24ea
	jp objectSetVisible		; $24ed

;;
; Sets a bit in w2SolidObjectPositions based on the object's current position. Prevents
; you from timewarping on top of an npc.
;
; @addr{24f0}
objectMarkSolidPosition:
	call objectGetShortPosition		; $24f0
	ld b,a			; $24f3
	ld a,:w2SolidObjectPositions		; $24f4
	ld ($ff00+R_SVBK),a	; $24f6
	ld a,b			; $24f8
	ld hl,w2SolidObjectPositions		; $24f9
	call setFlag		; $24fc
	ld a,$00		; $24ff
	ld ($ff00+R_SVBK),a	; $2501
	ret			; $2503

;;
; @addr{2504}
objectUnmarkSolidPosition:
	call objectGetShortPosition		; $2504
	ld b,a			; $2507
	ld a,:w2SolidObjectPositions		; $2508
	ld ($ff00+R_SVBK),a	; $250a
	ld a,b			; $250c
	ld hl,w2SolidObjectPositions		; $250d
	call unsetFlag		; $2510
	ld a,$00		; $2513
	ld ($ff00+R_SVBK),a	; $2515
	ret			; $2517

.else ; ROM_SEASONS

; Placeholder labels for now (delete these later)
objectFlickerVisibility:
objectMarkSolidPosition:
objectUnmarkSolidPosition:

.endif

;;
; @addr{2518}
_interactionActuallyRunScript:
	ldh a,(<hRomBank)	; $2518
	push af			; $251a
	ld a,:runScriptCommand	; $251b
	setrombank		; $251d
--
	ld a,(hl)		; $2522
	or a			; $2523
	jr z,++			; $2524

	call runScriptCommand	; $2526
	jr c,--			; $2529

	pop af			; $252b
	setrombank		; $252c
	xor a			; $2531
	ret			; $2532
++
	pop af			; $2533
	setrombank		; $2534
	scf			; $2539
	ret			; $253a

;;
; @addr{253b}
interactionSetHighTextIndex:
	ld e,Interaction.textID+1	; $253b
	ld (de),a		; $253d
	ld e,Interaction.useTextID	; $253e
	set 7,a			; $2540
	ld (de),a		; $2542
	ret			; $2543

;;
; Sets the interaction's script to hl, also resets Interaction.counter variables.
;
; @param	hl	The address of the script
; @param[out]	a	0 (this is assumed by INTERACID_MAMAMU_DOG due to an apparent bug...)
; @addr{2544}
interactionSetScript:
	ld e,Interaction.scriptPtr		; $2544
	ld a,l			; $2546
	ld (de),a		; $2547
	inc e			; $2548
	ld a,h			; $2549
	ld (de),a		; $254a
	ld h,d			; $254b
	ld l,Interaction.counter1	; $254c
	xor a			; $254e
	ldi (hl),a		; $254f
	ldi (hl),a		; $2550
	ret			; $2551

;;
; @param[out]	cflag	Set when the script ends (ran a "scriptend" command)
; @addr{2552}
interactionRunScript:
	ld a,(wLinkDeathTrigger)		; $2552
	or a			; $2555
	ret nz			; $2556

	ld a,(wTextIsActive)		; $2557
	add a			; $255a
	jr c,+			; $255b
	ret nz			; $255d
+
	; Wait for counter1 to reach 0
	ld h,d			; $255e
	ld l,Interaction.counter1	; $255f
	ld a,(hl)		; $2561
	or a			; $2562
	jr z,+			; $2563
	dec (hl)		; $2565
	ret nz			; $2566
+
	; Wait for counter2 to reach 0
	ld l,Interaction.counter2	; $2567
	ld a,(hl)		; $2569
	or a			; $256a
	jr z,+			; $256b

	; If counter2 is nonzero, still update the object's position?
	dec (hl)		; $256d
	call nz,objectApplySpeed		; $256e
	xor a			; $2571
	ret			; $2572
+
	ld h,d			; $2573
	ld l,Interaction.scriptPtr	; $2574
	ldi a,(hl)		; $2576
	ld h,(hl)		; $2577
	ld l,a			; $2578
	call _interactionActuallyRunScript		; $2579
	jr c,+			; $257c

	call _interactionSaveScriptAddress		; $257e
	xor a			; $2581
	ret			; $2582
+
	call _interactionSaveScriptAddress		; $2583
	scf			; $2586
	ret			; $2587

;;
; @param	hl	Script address
; @addr{2588}
_interactionSaveScriptAddress:
	ld e,Interaction.scriptPtr	; $2588
	ld a,l			; $258a
	ld (de),a		; $258b
	inc e			; $258c
	ld a,h			; $258d
	ld (de),a		; $258e
	ret			; $258f

;;
; @addr{2590}
scriptCmd_asmCall:
	pop hl			; $2590
	call _scriptFunc_setupAsmCall		; $2591
	jr ++			; $2594

;;
; @addr{2596}
scriptCmd_asmCallWithParam:
	pop hl			; $2596
	call _scriptFunc_setupAsmCall		; $2597
	ldi a,(hl)		; $259a
	ld e,a			; $259b
++
	ldh a,(<hRomBank)	; $259c
	push af			; $259e
	ld a,d			; $259f
	setrombank		; $25a0
	push hl			; $25a5
	ld hl,_scriptCmd_asmRetFunc		; $25a6
	push hl			; $25a9
	ldh a,(<hActiveObject)	; $25aa
	ld d,a			; $25ac
	ld h,b			; $25ad
	ld l,c			; $25ae
	ld a,e			; $25af
	jp hl			; $25b0

;;
; @addr{25b1}
_scriptCmd_asmRetFunc:
	pop hl			; $25b1
	pop af			; $25b2
	setrombank		; $25b3
	ldh a,(<hActiveObject)	; $25b8
	ld d,a			; $25ba
	scf			; $25bb
	ret			; $25bc

;;
; @addr{25bd}
_scriptFunc_setupAsmCall:
	inc hl			; $25bd
	ld d,$15		; $25be
	ldi a,(hl)		; $25c0
	ld c,a			; $25c1
	ldi a,(hl)		; $25c2
	ld b,a			; $25c3
	ret			; $25c4


.ifdef ROM_AGES

; Looks like the management of script addresses differs between games?

;;
; Same as scriptFunc_jump but sets the carry flag.
;
; @param	hl	Current address of script, whose contents point to the address to
;			jump to
; @addr{25c5}
scriptFunc_jump_scf:
	call scriptFunc_jump		; $25c5
	scf			; $25c8
	ret			; $25c9

;;
; A script can call this to jump to the address at (hl). This can also handle
; relative jumps in scripts loaded in wBigBuffer, but only within those $100
; bytes.
;
; @param	hl	Current address of script, whose contents point to the address to
;			jump to
; @addr{25ca}
scriptFunc_jump:
	ld a,h			; $25ca
	cp $80			; $25cb
	jr c,++			; $25cd

	ldh a,(<hScriptAddressL)	; $25cf
	ld c,a			; $25d1
	ldh a,(<hScriptAddressH)	; $25d2
	ld b,a			; $25d4
	ldi a,(hl)		; $25d5
	sub c			; $25d6
	ld e,a			; $25d7
	ldd a,(hl)		; $25d8
	sbc b			; $25d9
	or a			; $25da
	jr nz,++		; $25db

	ld l,e			; $25dd
	ld h,>wBigBuffer		; $25de
	ret			; $25e0
++
	ldi a,(hl)		; $25e1
	ld h,(hl)		; $25e2
	ld l,a			; $25e3
	ldh a,(<hActiveObject)	; $25e4
	ld d,a			; $25e6
	xor a			; $25e7
	ret			; $25e8

.else ; ROM_SEASONS

;;
scriptFunc_jump_scf:
	scf
	jr ++

;;
scriptFunc_jump:
	xor a
++
	ldi a,(hl)
	ld h,(hl)
	ld l,a
	ldh a,(<hActiveObject)
	ld d,a
	ret

.endif

;;
; @addr{25e9}
scriptFunc_add3ToHl_scf:
	scf			; $25e9
;;
; @addr{25ea}
scriptFunc_add3ToHl:
	inc hl			; $25ea
	inc hl			; $25eb
	inc hl			; $25ec
	ret			; $25ed

;;
; @addr{25ee}
scriptCmd_loadScript:
	pop hl			; $25ee
	inc hl			; $25ef
	ldi a,(hl)		; $25f0
	ld e,a			; $25f1
	ldi a,(hl)		; $25f2
	ld c,a			; $25f3
.ifdef ROM_AGES
	ldh (<hScriptAddressL),a	; $25f4
.endif
	ldi a,(hl)		; $25f6
	ld b,a			; $25f7
.ifdef ROM_AGES
	ldh (<hScriptAddressH),a	; $25f8
.endif
	ldh a,(<hRomBank)	; $25fa
	push af			; $25fc
	ld a,e			; $25fd
	setrombank		; $25fe
	ld h,b			; $2603
	ld l,c			; $2604
	ld de,wBigBuffer		; $2605
	ld b,$00		; $2608
	call copyMemory		; $260a
	pop af			; $260d
	setrombank		; $260e
	ldh a,(<hActiveObject)	; $2613
	ld d,a			; $2615
	ld hl,wBigBuffer		; $2616
	scf			; $2619
	ret			; $261a

;;
; @addr{261b}
interactionAnimate:
	ld h,d			; $261b
	ld l,Interaction.animCounter	; $261c
	dec (hl)		; $261e
	ret nz			; $261f

	ldh a,(<hRomBank)	; $2620
	push af			; $2622
	ld a,:interactionAnimationTable		; $2623
	setrombank		; $2625
	ld l,Interaction.animPointer	; $262a
	jr _interactionNextAnimationFrame		; $262c

;;
; @param	a	Animation index
; @addr{262e}
interactionSetAnimation:
	add a			; $262e
	ld c,a			; $262f
	ld b,$00		; $2630
	ldh a,(<hRomBank)	; $2632
	push af			; $2634
	ld a,:interactionAnimationTable		; $2635
	setrombank		; $2637
	ld e,Interaction.id		; $263c
	ld a,(de)		; $263e
	ld hl,interactionAnimationTable		; $263f
	rst_addDoubleIndex			; $2642
	ldi a,(hl)		; $2643
	ld h,(hl)		; $2644
	ld l,a			; $2645
	add hl,bc		; $2646

;;
; @addr{2647}
_interactionNextAnimationFrame:
	ldi a,(hl)		; $2647
	ld h,(hl)		; $2648
	ld l,a			; $2649

	; Byte 0: how many frames to hold it (or $ff to loop)
	ldi a,(hl)		; $264a
	cp $ff			; $264b
	jr nz,++		; $264d

	; If $ff, animation loops
	ld b,a			; $264f
	ld c,(hl)		; $2650
	add hl,bc		; $2651
	ldi a,(hl)		; $2652
++
	ld e,Interaction.animCounter	; $2653
	ld (de),a		; $2655

	; Byte 1: frame index (store in bc for now)
	ldi a,(hl)		; $2656
	ld c,a			; $2657
	ld b,$00		; $2658

	; Interaction.animParameter
	inc e			; $265a
	; Byte 2: general-purpose information on animation state? No specific
	; purpose? Some interactions use this to delete themselves when their
	; animation finishes.
	ldi a,(hl)		; $265b
	ld (de),a		; $265c

	; Interaction.animPointer
	inc e			; $265d
	; Save the current position in the animation
	ld a,l			; $265e
	ld (de),a		; $265f
	inc e			; $2660
	ld a,h			; $2661
	ld (de),a		; $2662

	ld e,Interaction.id		; $2663
	ld a,(de)		; $2665
	ld hl,interactionOamDataTable		; $2666
	rst_addDoubleIndex			; $2669
	ldi a,(hl)		; $266a
	ld h,(hl)		; $266b
	ld l,a			; $266c
	add hl,bc		; $266d

	; Set the address of the oam data
	ld e,Interaction.oamDataAddress		; $266e
	ldi a,(hl)		; $2670
	ld (de),a		; $2671
	inc e			; $2672
	ldi a,(hl)		; $2673
	and $3f			; $2674
	or $40			; $2676
	ld (de),a		; $2678

	pop af			; $2679
	setrombank		; $267a
	ret			; $267f

;;
; Stops Link from passing through the object.
;
; Used for minecarts, other things?
;
; Also prevents Dimitri from passing through npcs when thrown.
;
; @param[out]	cflag	Set if there's a collision with Link
; @addr{2680}
objectPreventLinkFromPassing:
	ld a,(wLinkCanPassNpcs)		; $2680
	or a			; $2683
	ret nz			; $2684

	ld l,a			; $2685
	ld a,(wLinkObjectIndex)		; $2686
	ld h,a			; $2689
	call preventObjectHFromPassingObjectD		; $268a
	push af			; $268d

	; If Dimitri is active, we can't let him pass either while being thrown.
	ld hl,w1Companion.id		; $268e
	ld a,(hl)		; $2691
	cp SPECIALOBJECTID_DIMITRI			; $2692
	jr nz,@end		; $2694

	ld l,<w1Companion.state		; $2696
	ld a,(hl)		; $2698
	cp $02			; $2699
	jr nz,@end		; $269b

	call preventObjectHFromPassingObjectD		; $269d
	jr nc,@end		; $26a0

	ld a,$01		; $26a2
	ld (wDimitriHitNpc),a		; $26a4
@end:
	pop af			; $26a7
	ret			; $26a8

;;
; @addr{26a9}
npcFaceLinkAndAnimate:
	ld e,Interaction.knockbackAngle		; $26a9
	ld a,$01		; $26ab
	ld (de),a		; $26ad

	; Wait for this counter to reach 0 before changing directions again
	ld e,Interaction.invincibilityCounter		; $26ae
	ld a,(de)		; $26b0
	or a			; $26b1
	jr nz,+++		; $26b2

	; Face towards Link if within a certain distance, otherwise face down
	ld c,$28		; $26b4
	call objectCheckLinkWithinDistance		; $26b6
	jr c,++			; $26b9
	ld l,Interaction.knockbackAngle		; $26bb
	dec (hl)		; $26bd
	ld a,DIR_DOWN*2		; $26be
++
	; Convert direction value to angle
	ld b,a			; $26c0
	add a			; $26c1
	add a			; $26c2
	ld h,d			; $26c3
	ld l,Interaction.angle		; $26c4
	cp (hl)			; $26c6
	jr z,interactionAnimateAsNpc	; $26c7

	ld (hl),a		; $26c9

	; Set animation
	srl b			; $26ca
	ld e,Interaction.var37		; $26cc
	ld a,(de)		; $26ce
	add b			; $26cf
	call interactionSetAnimation		; $26d0

	; Don't change directions again for another 30 frames
	ld e,Interaction.invincibilityCounter		; $26d3
	ld a,30		; $26d5
+++
	dec a			; $26d7
	ld (de),a		; $26d8
	jr interactionAnimateAsNpc		; $26d9


.ifdef ROM_SEASONS
;;
seasonsFunc_2678:
	ld e,Interaction.id		; $2678
	ld a,(de)		; $267a
	sub $24			; $267b
	cp $24			; $267d
	ret nc			; $267f
	ld e,Interaction.var37		; $2680
	ld a,(de)		; $2682
	add b			; $2683
	ld b,a			; $2684
	ret			; $2685
.endif

;;
; Update animations, push Link away, update draw priority relative to Link, and enable
; "terrain effects" (puddles on water, etc).
; @addr{26db}
interactionAnimateAsNpc:
	call interactionAnimate		; $26db

;;
; @addr{26de}
interactionPushLinkAwayAndUpdateDrawPriority:
	call objectPreventLinkFromPassing		; $26de
	jp objectSetPriorityRelativeToLink_withTerrainEffects		; $26e1

;;
; Return if screen scrolling is disabled?
;
; @addr{26e4}
returnIfScrollMode01Unset:
	ld a,(wScrollMode)		; $26e4
	and SCROLLMODE_01	; $26e7
	ret nz			; $26e9
	pop hl			; $26ea
	ret			; $26eb

;;
; Deletes the interaction and returns from the caller if [Interaction.enabled]&3 == 2.
;
; @addr{26ec}
interactionDeleteAndRetIfEnabled02:
	ld e,Interaction.enabled		; $26ec
	ld a,(de)		; $26ee
	and $03			; $26ef
	cp $02			; $26f1
	ret nz			; $26f3
	pop hl			; $26f4
	jp interactionDelete		; $26f5

;;
; Converts the angle value at 'de' to a direction value. Diagonals get rounded to the
; closest cardinal direction.
;
; @param	de	Address of an "angle" value
; @param[out]	a	Corresponding "direction" value
; @addr{26f8}
convertAngleDeToDirection:
	ld a,(de)		; $26f8

;;
; Converts given angle value to a direction value. Diagonals get rounded to the closest
; cardinal direction.
;
; @param	a	Angle value
; @param[out]	a	Corresponding "direction" value
; @addr{26f9}
convertAngleToDirection:
	add $04			; $26f9
	add a			; $26fb
	swap a			; $26fc
	and $03			; $26fe
	ret			; $2700

;;
; Sets bit 7 of Interaction.enabled, indicating that the interaction should update even
; when scrolling, when textboxes are up, and when bit 1 of wActiveObjects is set.
; @addr{2701}
interactionSetAlwaysUpdateBit:
	ld h,d			; $2701
	ld l,Interaction.enabled	; $2702
	set 7,(hl)		; $2704
	ret			; $2706

;;
; Checks if link is centered within 4 pixels of the given object, among other things. This
; is used for minecarts to check whether he's in position to get on, although it may also
; be used for other things.
;
; @param[out]	cflag	Set if centered correctly (and various other checks pass)
; @addr{2707}
objectCheckLinkPushingAgainstCenter:
	ld a,(w1Link.id)		; $2707
	or a			; $270a
	ret nz			; $270b

	; Check a directional button is pressed?
	ld a,(wLinkAngle)		; $270c
	cp $ff			; $270f
	ret z			; $2711

	; Return if A or B is pressed
	ld a,(wGameKeysPressed)		; $2712
	and BTN_A|BTN_B			; $2715
	ret nz			; $2717

	ld b,$04		; $2718
	jp objectCheckCenteredWithLink		; $271a

;;
; Checks whether the tile adjacent to the interaction (based on its current "angle" value)
; is solid or not.
;
; @param[out]	zflag	Set if the adjacent tile is not solid.
; @addr{271d}
interactionCheckAdjacentTileIsSolid:
	ld e,Interaction.angle		; $271d
	ld a,(de)		; $271f
	call convertAngleDeToDirection		; $2720
	jr ++			; $2723

;;
; Unused?
;
; @addr{2725}
interactionCheckAdjacentTileIsSolid_viaDirection:
	ld e,Interaction.direction		; $2725
	ld a,(de)		; $2727
	sra a			; $2728
++
	ld hl,@dirOffsets		; $272a
	rst_addAToHl			; $272d
	call objectGetShortPosition		; $272e
	add (hl)		; $2731
	ld h,>wRoomCollisions		; $2732
	ld l,a			; $2734
	ld a,(hl)		; $2735
	or a			; $2736
	ret			; $2737

; @addr{2738}
@dirOffsets:
	.db $f0 $01 $10 $ff



.ifdef ROM_AGES

;;
; @param[out]	zflag	z when counter1 reaches 0 (and text is inactive)
; @addr{273c}
interactionDecCounter1IfTextNotActive:
	ld a,(wTextIsActive)		; $273c
	or a			; $273f
	ret nz			; $2740
	jp interactionDecCounter1		; $2741

;;
; @addr{2744}
interactionDecCounter1IfPaletteNotFading:
	ld a,(wPaletteThread_mode)		; $2744
	or a			; $2747
	ret nz			; $2748
	jp interactionDecCounter1		; $2749

;;
; Unused?
;
; @addr{274c}
interactionAnimate4Times:
	call interactionAnimate		; $274c

;;
; @addr{274f}
interactionAnimate3Times:
	call interactionAnimate		; $274f

;;
; @addr{2752}
interactionAnimate2Times:
	call interactionAnimate		; $2752
	jp interactionAnimate		; $2755

;;
; Updates an interaction's animation based on its speed. The faster it is, the faster the
; animation goes.
;
; If counter2 is nonzero, it updates the animation at the slowest speed.
;
; @addr{2758}
interactionAnimateBasedOnSpeed:
	call interactionAnimate		; $2758
	ld e,Interaction.counter2		; $275b
	ld a,(de)		; $275d
	or a			; $275e
	ret z			; $275f

	ld e,Interaction.speed		; $2760
	ld a,(de)		; $2762
	cp SPEED_100			; $2763
	ret c			; $2765

	cp SPEED_200			; $2766
	jp c,interactionAnimate		; $2768

	cp SPEED_300			; $276b
	jp c,interactionAnimate2Times		; $276d
	jp interactionAnimate3Times		; $2770

;;
; @param	bc	Position
; @addr{2773}
interactionSetPosition:
	ld h,d			; $2773

;;
; @param	bc	Position
; @addr{2774}
interactionHSetPosition:
	ld l,Interaction.yh	; $2774
	ld (hl),b		; $2776
	ld l,Interaction.xh
	ld (hl),c		; $2779
	ret			; $277a

;;
; Unused?
;
; @addr{277b}
interactionUnsetAlwaysUpdateBit:
	ld h,d			; $277b
	ld l,Interaction.enabled		; $277c
	res 7,(hl)		; $277e
	ret			; $2780

;;
; @addr{2781}
interactionLoadExtraGraphics:
	ld e,Interaction.id		; $2781
	ld a,(de)		; $2783
	ld (wInteractionIDToLoadExtraGfx),a		; $2784

	; Why... what does this accomplish, other than possibly trashing tree graphics?
	ld (wLoadedTreeGfxIndex),a		; $2787

	ret			; $278a

;;
; Unused?
;
; @addr{278b}
interactionFunc_278b:
	ld l,Interaction.scriptPtr		; $278b
	ld (hl),c		; $278d
	inc l			; $278e
	ld (hl),b		; $278f
	ret			; $2790

;;
; This isn't used with standard scripts; see the function below.
;
; @param[out]	hl	Value of Interaction.scriptPtr
; @addr{2791}
interactionGetMiniScript:
	ld h,d			; $2791
	ld l,Interaction.scriptPtr		; $2792
	ldi a,(hl)		; $2794
	ld h,(hl)		; $2795
	ld l,a			; $2796
	ret			; $2797

;;
; This function seems to be used when interactions code their own, simplistic scripting
; formats. It doesn't seem use standard scripting functions. That said, the contents of
; this function are mostly the same as "interactionSetScript".
;
; Not to be confused with "interactionSetSimpleScript" and related functions later on,
; which is also a very simplistic scripting alternative, but the implementation is defined
; in bank 0 instead of by the "user".
;
; @param	hl	Address of script (it gets written to Interaction.scriptPtr)
; @addr{2798}
interactionSetMiniScript:
	ld e,Interaction.scriptPtr		; $2798
	ld a,l			; $279a
	ld (de),a		; $279b
	inc e			; $279c
	ld a,h			; $279d
	ld (de),a		; $279e
	ret			; $279f


.else ; ROM_SEASONS

; Placeholder labels
interactionDecCounter1IfTextNotActive:
interactionDecCounter1IfPaletteNotFading:
interactionAnimate4Times:
interactionAnimate3Times:
interactionAnimate2Times:
interactionAnimateBasedOnSpeed:
interactionSetPosition:
interactionHSetPosition:
interactionUnsetAlwaysUpdateBit:
interactionLoadExtraGraphics:
interactionFunc_278b:
interactionGetMiniScript:
interactionSetMiniScript:

.endif


;;
; Oscillates an object's Z position up and down? (used by Maple)
;
; @addr{27a0}
objectOscillateZ:
	ldh a,(<hRomBank)	; $27a0
	push af			; $27a2
	callfrombank0 interactionBank2.objectOscillateZ_body		; $27a3
	pop af			; $27ad
	setrombank		; $27ae
	ret			; $27b3

;;
; @param	b	Ring to give (overrides the treasure subid?)
; @param	c	var03 for TREASURE_RING (determines if it's in a chest or not,
;			how it spawns in, etc). This should usually be $00?
; @param[out]	zflag	Set if the treasure was given successfully.
; @addr{27b4}
giveRingToLink:
	call createRingTreasure		; $27b4
	ret nz			; $27b7
	push de			; $27b8
	ld de,w1Link.yh		; $27b9
	call objectCopyPosition_rawAddress		; $27bc
	pop de			; $27bf
	xor a			; $27c0
	ret			; $27c1

;;
; Creates a "ring" treasure. Doesn't set X/Y coordinates.
;
; @param	b	Ring to give (overrides the treasure subid?)
; @param	c	Subid for TREASURE_RING (determines if it's in a chest or not,
;			how it spawns in, etc)
; @param[out]	zflag	Set if the treasure was created successfully.
; @addr{27c2}
createRingTreasure:
	call getFreeInteractionSlot		; $27c2
	ret nz			; $27c5
	ld (hl),INTERACID_TREASURE		; $27c6
	inc l			; $27c8
	ld (hl),TREASURE_RING		; $27c9
	inc l			; $27cb
	ld (hl),c		; $27cc
	ld l,Interaction.var38		; $27cd
	set 6,b			; $27cf
	ld (hl),b		; $27d1
	xor a			; $27d2
	ret			; $27d3

;;
; Creates a "treasure" interaction (INTERACID_TREASURE). Doesn't initialize X/Y.
;
; @param	bc	Treasure to create (b = main id, c = subid)
; @param[out]	zflag	Set if the treasure was created successfully.
; @addr{27d4}
createTreasure:
	call getFreeInteractionSlot		; $27d4
	ret nz			; $27d7
	ld (hl),INTERACID_TREASURE		; $27d8
	inc l			; $27da
	ld (hl),b		; $27db
	inc l			; $27dc
	ld (hl),c		; $27dd
	xor a			; $27de
	ret			; $27df

;;
; Creates an "exclamation mark" interaction, complete with sound effect. Its position is
; at an offset from the current object.
;
; @param	a	How long to show the exclamation mark for (0 or $ff for
;                       indefinitely).
; @param	bc	Offset from the object to create the exclamation mark at.
; @param	d	The object to use for the base position of the exclamation mark.
; @addr{27e0}
objectCreateExclamationMark:
	ldh (<hFF8B),a	; $27e0
	ldh a,(<hRomBank)	; $27e2
	push af			; $27e4
	ld a,:objectCreateExclamationMark_body		; $27e5
	setrombank		; $27e7
	ldh a,(<hFF8B)	; $27ec
	call objectCreateExclamationMark_body		; $27ee
	pop af			; $27f1
	setrombank		; $27f2
	ret			; $27f7

;;
; Creates a floating "Z" letter like someone is snoring.
;
; Unused? (probably used in Seasons for talon)
;
; @param	a	0 to float left, nonzero to float right
; @param	bc	Offset relative to object
; @addr{27f8}
objectCreateFloatingSnore:
	ldh (<hFF8B),a	; $27f8
	ld a,$00		; $27fa
	jr ++			; $27fc

;;
; @param	a	0 to float left, nonzero to float right
; @param	bc	Offset relative to object
; @addr{27fe}
objectCreateFloatingMusicNote:
	ldh (<hFF8B),a	; $27fe
	ld a,$01		; $2800
++
	ldh (<hFF8D),a	; $2802
	ldh a,(<hRomBank)	; $2804
	push af			; $2806
	callfrombank0 objectCreateFloatingImage		; $2807
	pop af			; $2811
	setrombank		; $2812
	ret			; $2817

;;
; @addr{2818}
enemyAnimate:
	ld h,d			; $2818
	ld l,Enemy.animCounter		; $2819
	dec (hl)		; $281b
	ret nz			; $281c

	ldh a,(<hRomBank)	; $281d
	push af			; $281f
	ld a,:enemyAnimationTable		; $2820
	setrombank		; $2822
	ld l,Enemy.animPointer		; $2827
	jr _enemyNextAnimationFrame		; $2829

;;
; @param a Animation index
;
; @addr{282b}
enemySetAnimation:
	add a			; $282b
	ld c,a			; $282c
	ld b,$00		; $282d
	ldh a,(<hRomBank)	; $282f
	push af			; $2831
	ld a,:enemyAnimationTable		; $2832
	setrombank		; $2834
	ld e,Enemy.id		; $2839
	ld a,(de)		; $283b
	ld hl,enemyAnimationTable		; $283c
	rst_addDoubleIndex			; $283f
	ldi a,(hl)		; $2840
	ld h,(hl)		; $2841
	ld l,a			; $2842
	add hl,bc		; $2843

;;
; @addr{2844}
_enemyNextAnimationFrame:
	ldi a,(hl)		; $2844
	ld h,(hl)		; $2845
	ld l,a			; $2846

	; Byte 0: how many frames to hold it (or $ff to loop)
	ldi a,(hl)		; $2847
	cp $ff			; $2848
	jr nz,++			; $284a

	; If $ff, animation loops
	ld b,a			; $284c
	ld c,(hl)		; $284d
	add hl,bc		; $284e
	ldi a,(hl)		; $284f
++
	ld e,Enemy.animCounter		; $2850
	ld (de),a		; $2852

	; Byte 1: frame index (store in bc for now)
	ldi a,(hl)		; $2853
	ld c,a			; $2854
	ld b,$00		; $2855

	; Enemy.animParameter
	inc e			; $2857
	ldi a,(hl)		; $2858
	ld (de),a		; $2859

	; Enemy.animPointer
	inc e			; $285a
	; Save the current position in the animation
	ld a,l			; $285b
	ld (de),a		; $285c
	inc e			; $285d
	ld a,h			; $285e
	ld (de),a		; $285f

	ld e,Enemy.id		; $2860
	ld a,(de)		; $2862
	ld hl,enemyOamDataTable		; $2863
	rst_addDoubleIndex			; $2866
	ldi a,(hl)		; $2867
	ld h,(hl)		; $2868
	ld l,a			; $2869
	add hl,bc		; $286a

	; Set the address of the oam data
	ld e,Enemy.oamDataAddress		; $286b
	ldi a,(hl)		; $286d
	ld (de),a		; $286e
	inc e			; $286f
	ldi a,(hl)		; $2870
	and $3f			; $2871
	ld (de),a		; $2873

	pop af			; $2874
	setrombank		; $2875
	ret			; $287a

;;
; See the below functions.
;
; @addr{287b}
enemyDie_uncounted_withoutItemDrop:
	ld b,$80		; $287b
	jr ++		; $287d

;;
; Like enemyDie, but there is no random item drop.
;
; @addr{287f}
enemyDie_withoutItemDrop:
	ld b,$81		; $287f
	jr ++		; $2881

;;
; Like enemyDie, but wNumEnemies is not decremented. Other kill counters are incremented
; as normal.
;
; @addr{2883}
enemyDie_uncounted:
	ld b,$00		; $2883
	jr ++		; $2885

;;
; Kills an enemy in a puff of smoke. wNumEnemies will be decremented, and there will be
; a random item drop (depending on the enemy id?)
;
; @addr{2887}
enemyDie:
	ld b,$01		; $2887
++
	call @enemyCreateDeathPuff		; $2889
	bit 0,b			; $288c
	call nz,markEnemyAsKilledInRoom		; $288e

	; Update wTotalEnemiesKilled if 1000 have not yet been killed
	ld a,GLOBALFLAG_1000_ENEMIES_KILLED		; $2891
	call checkGlobalFlag		; $2893
	jr nz,++		; $2896

	ld l,<wTotalEnemiesKilled		; $2898
	call incHlRef16WithCap		; $289a
	ldi a,(hl)		; $289d
	ld h,(hl)		; $289e
	ld l,a			; $289f
	ld bc,1000		; $28a0
	call compareHlToBc		; $28a3
	rlca			; $28a6
	ld a,GLOBALFLAG_1000_ENEMIES_KILLED		; $28a7
	call nc,setGlobalFlag		; $28a9
++
	; Update maple kill counter
	ld hl,wMapleKillCounter		; $28ac
	call incHlRefWithCap		; $28af

	; Update all gasha kill counters
	ld a,GASHA_RING		; $28b2
	call cpActiveRing		; $28b4
	ld a,$ff		; $28b7
	jr z,+			; $28b9
	xor a			; $28bb
+
	ld l,<wGashaSpotKillCounters		; $28bc
	ld c,NUM_GASHA_SPOTS		; $28be
--
	; Increment [hl] once, or twice if gasha ring is equipped
	rlca			; $28c0
	call c,incHlRefWithCap		; $28c1
	call incHlRefWithCap		; $28c4
	inc l			; $28c7
	dec c			; $28c8
	jr nz,--		; $28c9

	; Increment some counter
	ld a,$03		; $28cb
	call addToGashaMaturity		; $28cd

	jp enemyDelete		; $28d0

;;
; @param	b	Bit 0 set if wNumEnemies should be decremented,
;			Bit 7 set if there should be an item drop.
; @addr{28d3}
@enemyCreateDeathPuff:
	; Kill instantly instead of in a puff of smoke if bit 7 of var3f is set
	ld e,Enemy.var3f		; $28d3
	ld a,(de)		; $28d5
	rlca			; $28d6
	jp c,decNumEnemies		; $28d7

	call getFreePartSlot		; $28da
	ret nz			; $28dd

	; [Part.enabled] = [Enemy.enabled & 3]
	ld e,Enemy.enabled		; $28de
	ld a,(de)		; $28e0
	and $03			; $28e1
	dec l			; $28e3
	ldi (hl),a		; $28e4

	; Part.id
	ld (hl),PARTID_ENEMY_DESTROYED		; $28e5

	; [Part.subid] = [Enemy.id]
	inc l			; $28e7
	ld e,Enemy.id		; $28e8
	ld a,(de)		; $28ea
	ld (hl),a		; $28eb

	ld l,Part.knockbackCounter		; $28ec
	ld e,Enemy.knockbackCounter		; $28ee
	ld a,(de)		; $28f0
	ld (hl),a		; $28f1

	call objectCopyPosition		; $28f2

	; Use counter2 to tell the part whether to decrement wNumEnemies, and whether to
	; drop a random item.
	ld l,Part.counter2		; $28f5
	ld (hl),b		; $28f7

	ld a,SND_KILLENEMY		; $28f8
	jp playSound		; $28fa

;;
; This function is called for every enemy before calling their regular code.
;
; Knockback and stun counters are updated, and various values are returned in 'c' based on
; the enemy's current status.
;
; The returned value of 'c' from here is moved to 'a' before the enemy-specific code is
; called, so that code can check the return value of this function.
;
; @param[out]	c	"Enemy status" (see constants/enemyStates.s).
;			$00 normally
;			$02 if stunned
;			$03 if health is 0
;			$04 if something hit the enemy?
;			$05 if the enemy is experiencing knockback
; @addr{28fd}
enemyStandardUpdate:
	ld h,d			; $28fd
	ld l,Enemy.state	; $28fe
	ld a,(hl)		; $2900
	or a			; $2901
	jr z,@uninitialized	; $2902

	ld l,Enemy.var2a		; $2904
	bit 7,(hl)		; $2906
	jr nz,@ret04		; $2908

	ld e,Enemy.knockbackCounter		; $290a
	ld a,(de)		; $290c
	and $7f			; $290d
	jr nz,@knockback	; $290f

	; Enemy.health
	dec l			; $2911
	ld a,(hl)		; $2912
	or a			; $2913
	jr z,@healthZero	; $2914

	; Enemy.stunCounter
	inc e			; $2916
	ld a,(de)		; $2917
	or a			; $2918
	jr nz,@stunned		; $2919

@ret00:
	ld c,$00		; $291b
	ret			; $291d

@uninitialized:
	callab bank3f.enemyLoadGraphicsAndProperties		; $291e
	call getRandomNumber_noPreserveVars		; $2926
	ld e,Enemy.var3d		; $2929
	ld (de),a		; $292b
	inc e			; $292c
	ld a,$01		; $292d
	ld (de),a		; $292f
	jr @ret00		; $2930

@ret04:
	ld c,$04		; $2932
	ret			; $2934

@knockback:
	ld l,e			; $2935
	dec (hl)		; $2936
	ld c,$05		; $2937
	ret			; $2939

@healthZero:
	ld l,Enemy.var3f		; $293a
	bit 1,(hl)		; $293c
	jr nz,@ret00		; $293e
	ld c,$03		; $2940
	ret			; $2942

@stunned:
	ld a,(wFrameCounter)		; $2943
	rrca			; $2946
	jr nc,++		; $2947

	; Decrement Enemy.stunCounter
	ld l,e			; $2949
	dec (hl)		; $294a

	; With 30 frames before being unstunned, make the enemy shake back and forth
	ld a,(hl)		; $294b
	cp 30			; $294c
	jr nc,++		; $294e
	rrca			; $2950
	jr nc,++		; $2951

	ld l,Enemy.xh		; $2953
	ld a,(hl)		; $2955
	xor $01			; $2956
	ld (hl),a		; $2958
++
	; Have the enemy fall down to the ground and bounce

	ld l,Enemy.state		; $2959
	ld a,(hl)		; $295b
	cp $08			; $295c
	jr c,@reachedGround	; $295e

	ld l,Enemy.zh		; $2960
	ld a,(hl)		; $2962
	dec a			; $2963
	cp $08			; $2964
	jr c,@reachedGround	; $2966

	ld c,$20		; $2968
	call objectUpdateSpeedZAndBounce		; $296a
	jr nc,@ret02		; $296d

	ld h,d			; $296f

@reachedGround:
	ld l,Enemy.speedZ		; $2970
	xor a			; $2972
	ldi (hl),a		; $2973
	ld (hl),a		; $2974

@ret02:
	ld c,$02		; $2975
	ret			; $2977

;;
; @addr{2978}
partAnimate:
	ld h,d			; $2978
	ld l,Part.animCounter		; $2979
	dec (hl)		; $297b
	ret nz			; $297c
	ld a,:partAnimationTable		; $297d
	setrombank		; $297f
	ld l,Part.animPointer		; $2984
	jr _partNextAnimationFrame		; $2986

;;
; @addr{2988}
partSetAnimation:
	add a			; $2988
	ld c,a			; $2989
	ld b,$00		; $298a
	ld a,:partAnimationTable		; $298c
	setrombank		; $298e
	ld e,$c1		; $2993
	ld a,(de)		; $2995
	ld hl,partAnimationTable		; $2996
	rst_addDoubleIndex			; $2999
	ldi a,(hl)		; $299a
	ld h,(hl)		; $299b
	ld l,a			; $299c
	add hl,bc		; $299d

;;
; Note: this sets the ROM bank to $11 before returning.
;
; @addr{299e}
_partNextAnimationFrame:
	ldi a,(hl)		; $299e
	ld h,(hl)		; $299f
	ld l,a			; $29a0

	; Byte 0: how many frames to hold it (or $ff to loop)
	ldi a,(hl)		; $29a1
	cp $ff			; $29a2
	jr nz,+			; $29a4

	; If $ff, animation loops
	ld b,a			; $29a6
	ld c,(hl)		; $29a7
	add hl,bc		; $29a8
	ldi a,(hl)		; $29a9
+
	ld e,Part.animCounter		; $29aa
	ld (de),a		; $29ac

	; Byte 1: frame index (store in bc for now)
	ldi a,(hl)		; $29ad
	ld c,a			; $29ae
	ld b,$00		; $29af

	; Item.animParameter
	inc e			; $29b1
	ldi a,(hl)		; $29b2
	ld (de),a		; $29b3

	; Item.animPointer
	inc e			; $29b4
	; Save the current position in the animation
	ld a,l			; $29b5
	ld (de),a		; $29b6
	inc e			; $29b7
	ld a,h			; $29b8
	ld (de),a		; $29b9

	ld e,Part.id		; $29ba
	ld a,(de)		; $29bc
	ld hl,partOamDataTable		; $29bd
	rst_addDoubleIndex			; $29c0
	ldi a,(hl)		; $29c1
	ld h,(hl)		; $29c2
	ld l,a			; $29c3
	add hl,bc		; $29c4

	; Set the address of the oam data
	ld e,Part.oamDataAddress		; $29c5
	ldi a,(hl)		; $29c7
	ld (de),a		; $29c8
	inc e			; $29c9
	ldi a,(hl)		; $29ca
	and $3f			; $29cb
	or $40			; $29cd
	ld (de),a		; $29cf

	ld a,$11		; $29d0
	setrombank		; $29d2
	ret			; $29d7

;;
; Creates an energy swirl going towards the given point.
;
; @param	bc	Center of the swirl
; @param	a	Duration of swirl ($ff and $00 are infinite?)
; @addr{29d8}
createEnergySwirlGoingIn:
	ld l,a			; $29d8
	ldh a,(<hRomBank)	; $29d9
	push af			; $29db
	callfrombank0 createEnergySwirlGoingIn_body		; $29f1
	pop af			; $29e6
	setrombank		; $29e7
	ret			; $29ec

;;
; Creates an energy swirl going away from the given point.
;
; @param	bc	Center of the swirl
; @param	a	Duration of swirl ($ff and $00 are infinite?)
; @addr{29ed}
createEnergySwirlGoingOut:
	ld l,a			; $29ed
	ldh a,(<hRomBank)	; $29ee
	push af			; $29f0
	callfrombank0 createEnergySwirlGoingOut_body		; $29f1
	pop af			; $29fb
	setrombank		; $29fc
	ret			; $2a01

;;
; Reads wLinkAngle, and returns in 'a' the value that would correspond to the direction
; buttons for moving in that direction.
;
; Why not read directly from wGameKeysPressed? Well, there may be scenarios where it
; doesn't match up with what you want, such as when Link's movement is reversed in the
; final fight.
;
; @param[out]	a	Direction buttons that correspond to wLinkAngle
; @addr{2a02}
convertLinkAngleToDirectionButtons:
	ld a,(wLinkAngle)		; $2a02
	add a			; $2a05
	jr c,+			; $2a06

	add a			; $2a08
	swap a			; $2a09
	push hl			; $2a0b
	ld hl,@data		; $2a0c
	rst_addAToHl			; $2a0f
	ld a,(hl)		; $2a10
	pop hl			; $2a11
	ret			; $2a12
+
	xor a			; $2a13
	ret			; $2a14

@data:
	.db BTN_UP
	.db BTN_UP|BTN_RIGHT
	.db BTN_RIGHT
	.db BTN_DOWN|BTN_RIGHT
	.db BTN_DOWN
	.db BTN_DOWN|BTN_LEFT
	.db BTN_LEFT
	.db BTN_UP|BTN_LEFT

;;
; Sets wSimulatedInputAddress/Bank to the given values, and initializes everything to
; start reading from there.
;
; @param	a 	Simulated input bank
; @param	hl	Simulated input address
; @addr{2a1d}
setSimulatedInputAddress:
	ld de,wSimulatedInputBank		; $2a1d
	ld (de),a		; $2a20
	inc e			; $2a21
	ld a,l			; $2a22
	ld (de),a		; $2a23
	inc e			; $2a24
	ld a,h			; $2a25
	ld (de),a		; $2a26

	; [wSimulatedInputCounter] = 0
	ld e,<(wSimulatedInputCounter+1)		; $2a27
	xor a			; $2a29
	ld (de),a		; $2a2a
	dec e			; $2a2b
	ld (de),a		; $2a2c

	; [wUseSimulatedInput] = 1
	dec e			; $2a2d
	inc a			; $2a2e
	ld (de),a		; $2a2f

	jp clearPegasusSeedCounter		; $2a30

;;
; Returns preset input values. Used for cutscenes (ie. the intro).
;
; @param[out]	a	Value to be written to wGameKeysPressed
; @addr{2a33}
getSimulatedInput:
	ld a,(wPaletteThread_mode)		; $2a33
	or a			; $2a36
	ret nz			; $2a37

	ld a,(wUseSimulatedInput)		; $2a38
	rlca			; $2a3b
	jr c,@returnInput	; $2a3c

	ld hl,wSimulatedInputCounter		; $2a3e
	call decHlRef16WithCap		; $2a41
	jr nz,@returnInput	; $2a44

	ldh a,(<hRomBank)	; $2a46
	push af			; $2a48
	ld hl,wSimulatedInputBank		; $2a49
	ldi a,(hl)		; $2a4c
	setrombank		; $2a4d
	ldi a,(hl)		; $2a52
	ld h,(hl)		; $2a53
	ld l,a			; $2a54

	ldi a,(hl)		; $2a55
	ld (wSimulatedInputCounter),a		; $2a56
	ldi a,(hl)		; $2a59
	ld (wSimulatedInputCounter+1),a		; $2a5a

	; If the counter (frames to wait) was $8000 or greater, stop reading inputs.
	bit 7,a			; $2a5d
	jr z,+			; $2a5f

	ld a,$ff		; $2a61
	ld (wUseSimulatedInput),a		; $2a63
	jr ++			; $2a66
+
	ldi a,(hl)		; $2a68
	ld (wSimulatedInputValue),a		; $2a69
++
	pop af			; $2a6c
	setrombank		; $2a6d

	ld a,l			; $2a72
	ld (wSimulatedInputAddressL),a		; $2a73
	ld a,h			; $2a76
	ld (wSimulatedInputAddressH),a		; $2a77

@returnInput:
	ld a,(wSimulatedInputValue)		; $2a7a
	ret			; $2a7d

;;
; Sets Item.state to 'a', and Item.state2 to 0.
;
; @param	a	Value for Item.state
; @addr{2a7e}
itemSetState:
	ld h,d			; $2a7e
	ld l,Item.state		; $2a7f
	ldi (hl),a		; $2a81
	ld (hl),$00		; $2a82
	ret			; $2a84

;;
; @addr{2a85}
clearPegasusSeedCounter:
	ld hl,wPegasusSeedCounter		; $2a85
	xor a			; $2a88
	ldi (hl),a		; $2a89
	ld (hl),a		; $2a8a
	ret			; $2a8b

;;
; Resets some Link variables - primarily his Z position - and resets his animation?
;
; @addr{2a8c}
putLinkOnGround:
	; Return if Link is riding something
	ld a,(wLinkObjectIndex)		; $2a8c
	rrca			; $2a8f
	ret c			; $2a90

	push de			; $2a91

	; Put Link on the ground
	xor a			; $2a92
	ld (wLinkInAir),a		; $2a93
	ld hl,w1Link.speedZ		; $2a96
	ldi (hl),a		; $2a99
	ldi (hl),a		; $2a9a
	ld l,<w1Link.z		; $2a9b
	ldi (hl),a		; $2a9d
	ldi (hl),a		; $2a9e

	ld l,<w1Link.id		; $2a9f
	ld a,(hl)		; $2aa1
	or a			; $2aa2
	jr nz,@end		; $2aa3

	ld d,h			; $2aa5
	ld a,LINK_ANIM_MODE_WALK		; $2aa6
	call specialObjectSetAnimation		; $2aa8
@end:
	pop de			; $2aab
	ret			; $2aac

;;
; Sets wLinkForceState to LINK_STATE_08.
;
; @addr{2aad}
setLinkForceStateToState08:
	xor a			; $2aad

;;
; Sets wLinkForceState to LINK_STATE_08, and wcc50 to the given value.
;
; @param	a	Value for wcc50
; @addr{2aae}
setLinkForceStateToState08_withParam:
	push hl			; $2aae

	; Clear wcc50, it seems to be used differently based on the state
	ld hl,wcc50		; $2aaf
	ldd (hl),a		; $2ab2

	; Set wLinkForceState
	ld (hl),LINK_STATE_08		; $2ab3
	pop hl			; $2ab5
	ret			; $2ab6

;;
; Reads w1Link.damageToApply and applies that to his health.
;
; Parameter 'd' does not need to be passed as the Link object.
;
; @addr{2ab7}
linkApplyDamage:
	push de			; $2ab7
	ldh a,(<hRomBank)	; $2ab8
	push af			; $2aba
	ld d,>w1Link		; $2abb
	callfrombank0 bank5.linkApplyDamage_b5		; $2abd
	pop af			; $2ac7
	setrombank		; $2ac8
	pop de			; $2acd
	ret			; $2ace

;;
; This will force Link's ID to change next time "updateSpecialObjects" is called. Also
; clears subid, var03, state, and state2.
;
; @param	a	Link ID value (see constants/specialObjectTypes.s)
; @addr{2acf}
setLinkIDOverride:
	or $80			; $2acf
	ld (wLinkIDOverride),a		; $2ad1
	ld hl,w1Link.subid		; $2ad4
	jr ++			; $2ad7

;;
; Sets link's ID and clears w1Link.subid, var03, state, state2.
;
; @param	a	New value for w1Link.id
; @addr{2ad9}
setLinkID:
	ld hl,w1Link.id		; $2ad9
	ldi (hl),a		; $2adc
++
	xor a			; $2add
	ldi (hl),a		; $2ade
	ldi (hl),a		; $2adf
	ldi (hl),a		; $2ae0
	ldi (hl),a		; $2ae1
	ret			; $2ae2

;;
; Sends Link back to his spawn point for the room. Also damages him maybe?
;
; @addr{2ae3}
respawnLink:
	ld a,LINK_STATE_RESPAWNING		; $2ae3
	ld (wLinkForceState),a		; $2ae5
	ld a,$02		; $2ae8
	ld (wLinkStateParameter),a		; $2aea
	or d			; $2aed
	ret			; $2aee

;;
; @param	d	Special object index (link or companion)
; @addr{2aef}
specialObjectAnimate:
	ld h,d			; $2aef
	ld l,SpecialObject.animCounter	; $2af0
	dec (hl)		; $2af2
	ret nz			; $2af3

	ldh a,(<hRomBank)	; $2af4
	push af			; $2af6
	ld a,:bank6.specialObjectNextAnimationFrame		; $2af7
	setrombank		; $2af9
	ld l,SpecialObject.animPointer		; $2afe
	call bank6.specialObjectNextAnimationFrame		; $2b00
	pop af			; $2b03
	setrombank		; $2b04
	ret			; $2b09

;;
; @param	a	Animation (see constants/linkAnimations.s)
; @param	d	Special object index
; @addr{2b0a}
specialObjectSetAnimation:
	ld e,SpecialObject.animMode		; $2b0a
	ld (de),a		; $2b0c
	add a			; $2b0d
	ld c,a			; $2b0e
	ld b,$00		; $2b0f
	ldh a,(<hRomBank)	; $2b11
	push af			; $2b13
	callfrombank0 bank6.specialObjectSetAnimation_body		; $2b14
	pop af			; $2b1e
	setrombank		; $2b1f
	ret			; $2b24

;;
; @addr{2b25}
loadLinkAndCompanionAnimationFrame:
	ldh a,(<hRomBank)	; $2b25
	push af			; $2b27
	callfrombank0 bank6.loadLinkAndCompanionAnimationFrame_body		; $2b28
	pop af			; $2b32
	setrombank		; $2b33
	ret			; $2b38

;;
; Check if link is pushing against a wall. This is checked to set his animation as well as
; whether he should do a sword poke.
;
; @param[out]	cflag	Set if link is pushing against a wall.
; @addr{2b39}
checkLinkPushingAgainstWall:
	push hl			; $2b39
	ld a,(w1Link.direction)		; $2b3a
	ld hl,@collisionDirections		; $2b3d
	rst_addDoubleIndex			; $2b40

	; Check that he's facing a wall
	ld a,(w1Link.adjacentWallsBitset)		; $2b41
	and (hl)		; $2b44
	cp (hl)			; $2b45
	jr nz,++		; $2b46

	; Check that he's trying to move towards the wall
	inc hl			; $2b48
	ld a,(wGameKeysPressed)		; $2b49
	and (hl)		; $2b4c
	jr z,++			; $2b4d

	pop hl			; $2b4f
	scf			; $2b50
	ret			; $2b51
++
	pop hl			; $2b52
	xor a			; $2b53
	ret			; $2b54

; @addr{2b55}
@collisionDirections:
	.db $c0 $40
	.db $03 $10
	.db $30 $80
	.db $0c $20

;;
; Updates w1Companion.direction based on wLinkAngle.
;
; @param[out]	cflag	Set if direction changed.
; @addr{2b5d}
updateCompanionDirectionFromAngle:
	push bc			; $2b5d
	push hl			; $2b5e
	ld hl,w1Companion.direction		; $2b5f
	jr ++			; $2b62

;;
; Updates w1Link.direction based on wLinkAngle.
;
; @param[out]	cflag	Set if direction changed.
; @addr{2b64}
updateLinkDirectionFromAngle:
	push bc			; $2b64
	push hl			; $2b65
	ld hl,w1Link.direction		; $2b66
++
	ld b,(hl)		; $2b69
	ld a,(wLinkAngle)		; $2b6a
	cp $ff			; $2b6d
	jr z,@end		; $2b6f

	; Reduce the angle to the 8 directions you can move in
	and $1c			; $2b71
	rrca			; $2b73
	rrca			; $2b74

	; Check for diagonal movement
	rra			; $2b75
	jr nc,++		; $2b76

	; If diagonal, check whether the current direction makes up one of the components
	; of the diagonal; if so, don't modify it.
	ld c,a			; $2b78
	sub b			; $2b79
	inc a			; $2b7a
	and $02			; $2b7b
	jr z,@end		; $2b7d
	ld a,c			; $2b7f
++
	cp (hl)			; $2b80
	jr z,@end		; $2b81
	ld (hl),a		; $2b83
	ld b,a			; $2b84
	scf			; $2b85
@end:
	ld a,b			; $2b86
	pop hl			; $2b87
	pop bc			; $2b88
	ret			; $2b89

;;
; @addr{2b8a}
specialObjectSetCoordinatesToRespawnYX:
	ld h,d			; $2b8a
	ld l,SpecialObject.direction		; $2b8b
	ld a,(wLinkLocalRespawnDir)		; $2b8d
	ldi (hl),a		; $2b90

	; SpecialObject.angle = $ff
	ld a,$ff		; $2b91
	ldi (hl),a		; $2b93

	ld (wLinkPathIndex),a		; $2b94

	; Copy respawn coordinates to y/x
	ld l,SpecialObject.yh		; $2b97
	ld a,(wLinkLocalRespawnY)		; $2b99
	ldi (hl),a		; $2b9c
	inc l			; $2b9d
	ld a,(wLinkLocalRespawnX)		; $2b9e
	ldi (hl),a		; $2ba1

	; Set z position to 0
	xor a			; $2ba2
	ldi (hl),a		; $2ba3
	ldi (hl),a		; $2ba4

	ld l,SpecialObject.knockbackCounter		; $2ba5
	ld (hl),a		; $2ba7
	ret			; $2ba8

;;
; Clear variables related to link's invincibility, knockback, etc.
; @addr{2ba9}
resetLinkInvincibility:
	ld hl,w1Link.oamFlagsBackup		; $2ba9
	ldi a,(hl)		; $2bac
	ld (hl),a		; $2bad

	; Clear collisionType, damageToApply
	ld l,<w1Link.collisionType		; $2bae
	xor a			; $2bb0
	ldi (hl),a		; $2bb1
	ldi (hl),a		; $2bb2

	ld l,<w1Link.damage		; $2bb3
	ldi (hl),a		; $2bb5

	; Clear:
	; var2a
	; invincibilityCounter
	; knockbackAngle
	; knockbackCounter
	; stunCounter
	inc l			; $2bb6
	ldi (hl),a		; $2bb7
	ldi (hl),a		; $2bb8
	ldi (hl),a		; $2bb9
	ldi (hl),a		; $2bba
	ldi (hl),a		; $2bbb
	ret			; $2bbc

;;
; Decrements wPegasusSeedCounter. This decrements it twice unless the Pegasus Ring is
; equipped, which doubles their duration.
;
; @param[out]	zflag	Set if wPegasusSeedCounter is zero.
; @addr{2bbd}
decPegasusSeedCounter:
	ld hl,wPegasusSeedCounter+1	; $2bbd
	res 7,(hl)		; $2bc0
	dec l			; $2bc2
	ld b,$00		; $2bc3
	ld c,$07		; $2bc5
	ld a,PEGASUS_RING		; $2bc7
	call cpActiveRing		; $2bc9
	jr z,+			; $2bcc

	ld c,$0f		; $2bce
	call decHlRef16WithCap		; $2bd0
	ret z			; $2bd3
	ld a,(hl)		; $2bd4
	and c			; $2bd5
	jr nz,+			; $2bd6
	ld b,$80		; $2bd8
+
	call decHlRef16WithCap		; $2bda
	ret z			; $2bdd
	ldi a,(hl)		; $2bde
	and c			; $2bdf
	jr nz,+			; $2be0
	ld b,$80		; $2be2
+
	; Set bit 15 of wPegasusSeedCounter when dust should be created at Link's feet
	ld a,(hl)		; $2be4
	or b			; $2be5
	ldd (hl),a		; $2be6
	ret			; $2be7

;;
; @param[out]	a	The high byte of wPegasusSeedCounter
; @param[out]	zflag	Set if wPegasusSeedCounter is zero
; @addr{2be8}
checkPegasusSeedCounter:
	ld hl,wPegasusSeedCounter		; $2be8
	ldi a,(hl)		; $2beb
	or (hl)			; $2bec
	ldd a,(hl)		; $2bed
	ret			; $2bee

;;
; Try to break a tile at the given item's position.
;
; @param	a	The type of collision (see constants/breakableTileSources.s)
; @param[out]	cflag	Set if the tile was broken (or can be broken)
; @addr{2bef}
itemTryToBreakTile:
	ld h,d			; $2bef
	ld l,Item.yh		; $2bf0
	ld b,(hl)		; $2bf2
	ld l,Item.xh		; $2bf3
	ld c,(hl)		; $2bf5
;;
; See bank6.tryToBreakTile for a better description.
;
; @param	a	The type of collision (see constants/breakableTileSources.s)
;			If bit 7 is set, it will only check if the tile is breakable; it
;			won't actually break it.
; @param	bc	The YYXX position
; @param[out]	cflag	Set if the tile was broken (or can be broken)
; @addr{2bf6}
tryToBreakTile:
	ldh (<hFF8F),a	; $2bf6
	ldh a,(<hRomBank)	; $2bf8
	push af			; $2bfa
	callfrombank0 bank6.tryToBreakTile_body		; $2bfb
	rl e			; $2c05
	pop af			; $2c07
	setrombank		; $2c08
	rr e			; $2c0d
	ret			; $2c0f

;;
; Calls bank6._clearAllParentItems.
; @addr{2c10}
clearAllParentItems:
	ld c,$00		; $2c10
	jr ++			; $2c12

;;
; Calls bank6._updateParentItemButtonAssignment_body.
;
; Updates var03 of a parent item to correspond to the equipped A or B button item. This is
; called after closing a menu (since button assignments may be changed).
;
; @addr{2c14}
updateParentItemButtonAssignment:
	ld c,$01		; $2c14
	jr ++			; $2c16

;;
; Calls bank6.checkUseItems, which checks the A and B buttons and creates corresponding
; item objects if necessary.
;
; @addr{2c18}
checkUseItems:
	ld c,$02		; $2c18
++
	ldh a,(<hRomBank)	; $2c1a
	push af			; $2c1c
	callfrombank0 bank6.functionCaller		; $2c1d
	pop af			; $2c27
	setrombank		; $2c28
	ret			; $2c2d

;;
; @addr{2c2e}
objectAddToGrabbableObjectBuffer:
	ld hl,wGrabbableObjectBuffer		; $2c2e
--
	inc l			; $2c31
	bit 7,(hl)		; $2c32
	jr z,++			; $2c34

	inc l			; $2c36
	ld a,l			; $2c37
	cp <wGrabbableObjectBufferEnd			; $2c38
	jr c,--			; $2c3a
	ret			; $2c3c
++
	ld a,d			; $2c3d
	ldd (hl),a		; $2c3e
	ldh a,(<hActiveObjectType)	; $2c3f
	ld (hl),a		; $2c41
	ret			; $2c42

;;
; Drops an item being held by Link?
;
; @addr{2c43}
dropLinkHeldItem:
	ld a,(wInShop)		; $2c43
	or a			; $2c46
	jr nz,@end		; $2c47

	; Check that 2 <= [wLinkGrabState]&7 < 4
	ld a,(wLinkGrabState)		; $2c49
	and $07			; $2c4c
	sub $02			; $2c4e
	cp $02			; $2c50
	jr nc,@end		; $2c52

	; Get the object Link is holding in hl
	ld hl,w1Link.relatedObj2		; $2c54
	ldi a,(hl)		; $2c57
	ld h,(hl)		; $2c58
	add Object.state			; $2c59
	ld l,a			; $2c5b

	; Check Object.state
	ldi a,(hl)		; $2c5c
	cp $02			; $2c5d
	jr nz,@end		; $2c5f

	; Write $03 to Object.state2 (means it's no longer being held?)
	ld a,$03		; $2c61
	ld (hl),a		; $2c63

	ld a,l			; $2c64
	add Object.angle-Object.state2			; $2c65
	ld l,a			; $2c67
	ld (hl),$ff		; $2c68
@end:
	xor a			; $2c6a
	ld (wLinkGrabState),a		; $2c6b
	ld (wLinkGrabState2),a		; $2c6e
	ret			; $2c71

;;
; Clears var3f for w1ParentItem2-5. Relates to the animation link does as he uses the
; item?
;
; @addr{2c72}
clearVar3fForParentItems:
	ld hl,w1ParentItem2.var3f		; $2c72
--
	ld (hl),$00		; $2c75
	inc h			; $2c77
	ld a,h			; $2c78
	cp WEAPON_ITEM_INDEX			; $2c79
	jr c,--			; $2c7b
	ret			; $2c7d

;;
; Creates a spash at Link's position. Whether it's normal water or lava depends on the
; wLinkSwimmingState variable.
;
; @param	d	Link object
; @addr{2c7e}
linkCreateSplash:
	ld b,INTERACID_SPLASH		; $2c7e

	; Check if in lava; if so, set b to INTERACID_LAVASPLASH.
	ld a,(wLinkSwimmingState)		; $2c80
	bit 6,a			; $2c83
	jr z,+			; $2c85
	inc b			; $2c87
+
	ld a,(wAreaFlags)		; $2c88
	and AREAFLAG_SIDESCROLL			; $2c8b
	jp z,objectCreateInteractionWithSubid00		; $2c8d

	; If in a sidescrolling area, create the interaction at an offset to Link's
	; position.
	call getFreeInteractionSlot		; $2c90
	ret nz			; $2c93
	ld (hl),b		; $2c94
	ld bc,$fd00		; $2c95
	jp objectCopyPositionWithOffset		; $2c98

;;
; @addr{2c9b}
clearVariousLinkVariables:
	xor a			; $2c9b
	ld (w1Link.var36),a		; $2c9c
	ld (w1Link.speed),a		; $2c9f
	ld (w1Link.var3e),a		; $2ca2
	ld (w1Link.var12),a		; $2ca5
	dec a			; $2ca8
	ld (w1Link.angle),a		; $2ca9
	ret			; $2cac

;;
; LINK_STATE_SPINNING_FROM_GALE
;
; Not sure why this is in bank 0 instead of bank 5.
;
; @addr{2cad}
linkState07:
	ld e,SpecialObject.state2		; $2cad
	ld a,(de)		; $2caf
	rst_jumpTable			; $2cb0
.dw @substate0
.dw specialObjectAnimate
.dw @substate2


; Initialization (just touched a gale seed)
@substate0:
	; Cancel item usage
	call bank5.linkCancelAllItemUsageAndClearAdjacentWallsBitset		; $2cb7

	call itemIncState2		; $2cba

	xor a			; $2cbd
	ld l,SpecialObject.collisionType		; $2cbe
	ld (hl),a		; $2cc0

	call clearVariousLinkVariables		; $2cc1

	ld a,$80		; $2cc4
	ld (wLinkInAir),a		; $2cc6
	ld a,LINK_ANIM_MODE_GALE		; $2cc9
	jp specialObjectSetAnimation		; $2ccb

; Falling down after cancelling from the gale seed menu
@substate2:
	xor a			; $2cce
	ld (wLinkInAir),a		; $2ccf
	ld a,TRANSITION_DEST_FALL		; $2cd2
	ld (wWarpTransition),a		; $2cd4

	ld e,SpecialObject.yh		; $2cd7
	ld a,(de)		; $2cd9
	add $04			; $2cda
	ld (de),a		; $2cdc

	ld a,LINK_STATE_WARPING		; $2cdd
	jp bank5.linkSetState		; $2cdf

;;
; @addr{2ce2}
itemDelete:
	ld h,d			; $2ce2
	ld l,Item.start		; $2ce3
	ld b,$10		; $2ce5
	xor a			; $2ce7
--
	ldi (hl),a		; $2ce8
	ldi (hl),a		; $2ce9
	ldi (hl),a		; $2cea
	ldi (hl),a		; $2ceb
	dec b			; $2cec
	jr nz,--		; $2ced
	ret			; $2cef

;;
; Updates an item's angle based on its direction.
;
; @param[out]	hl	Item.direction
; @addr{2cf0}
itemUpdateAngle:
	ld h,d			; $2cf0
	ld l,Item.direction		; $2cf1
	ldi a,(hl)		; $2cf3
	swap a			; $2cf4
	rrca			; $2cf6
	ldd (hl),a		; $2cf7
	ret			; $2cf8

;;
; @param[out]	zflag	nz on failure.
; @addr{2cf9}
getFreeItemSlot:
	ldhl FIRST_DYNAMIC_ITEM_INDEX, Item.start		; $2cf9
-
	ld a,(hl)		; $2cfc
	or a			; $2cfd
	ret z			; $2cfe

	inc h			; $2cff
	ld a,h			; $2d00
	cp LAST_DYNAMIC_ITEM_INDEX+1			; $2d01
	jr c,-

	or h			; $2d05
	ret			; $2d06

;;
; @addr{2d07}
introThreadStart:
	ld hl,wIntro.frameCounter		; $2d07
	inc (hl)		; $2d0a
	callfrombank0 runIntro	; $2d0b
	call resumeThreadNextFrame		; $2d15
	jr introThreadStart		; $2d18

;;
; This runs everything after the "nintendo/capcom" logo and before the titlescreen.
; @addr{2d1a}
intro_cinematic:
	ldh a,(<hRomBank)	; $2d1a
	push af			; $2d1c

	callfrombank0 runIntroCinematic		; $2d1d
	callfrombank0 bank5.updateSpecialObjects		; $2d27
	call          loadLinkAndCompanionAnimationFrame		; $2d31
	callfrombank0 updateAnimations
	call          updateInteractionsAndDrawAllSprites		; $2d3e

	pop af			; $2d41
	setrombank		; $2d42
	ret			; $2d47

;;
; Relates to the movement of the triforce pieces in the intro?
;
; @param	b
; @param[out]	b
; @addr{2d48}
func_2d48:
	ldh a,(<hRomBank)	; $2d48
	push af			; $2d4a

	ld a,:bank3f.data_5951		; $2d4b
	setrombank		; $2d4d
	ld a,b			; $2d52
	ld hl,bank3f.data_5951		; $2d53
	rst_addAToHl			; $2d56
	ld b,(hl)		; $2d57

	pop af			; $2d58
	setrombank		; $2d59
	ret			; $2d5e

;;
; wram bank 1 loaded on return.
; @addr{2d5f}
clearFadingPalettes:
	ldh a,(<hRomBank)	; $2d5f
	push af			; $2d61
	callfrombank0 clearFadingPalettes_body		; $2d62
	pop af			; $2d6c
	setrombank		; $2d6d
	ret			; $2d72

;;
; This function causes the screen to flash white. Based on parameter 'b', which acts as
; the "index" if the data to use, this will read through the predefined data to see on
; what frames it should turn the screen white, and on what frames it should restore the
; screen to normal.
;
; @param	b	Index of "screen flashing" data
; @param	hl	Counter to use (should start at 0?)
; @param[out]	zflag	nz if the flashing is complete (all data has been read).
; @addr{2d73}
flashScreen:
	ldh a,(<hRomBank)	; $2d73
	push af			; $2d75
	callfrombank0 flashScreen_body		; $2d76
	ld b,$01		; $2d80
	jr nz,+			; $2d82
	dec b			; $2d84
+
	pop af			; $2d85
	setrombank		; $2d86
	ld a,b			; $2d8b
	or a			; $2d8c
	ret			; $2d8d

;;
; SpecialObject code for IDs $0f-$12
;
; @addr{2d8e}
specialObjectCode_companionCutscene:
	ldh a,(<hRomBank)	; $2d8e
	push af			; $2d90
	callfrombank0 bank6.specialObjectCode_companionCutscene		; $2d91
	pop af			; $2d9b
	setrombank		; $2d9c
	ret			; $2da1

;;
; @addr{2da2}
specialObjectCode_linkInCutscene:

.ifdef ROM_SEASONS

	ldh a,(<hRomBank)
	push af
	callfrombank0 bank6.specialObjectCode_linkInCutscene
	pop af
	setrombank
	ret

.else ; ROM_AGES
	jpab bank6.specialObjectCode_linkInCutscene		; $2da2
.endif

;;
; Load dungeon layout if currently in a dungeon.
;
; @addr{2daa}
loadDungeonLayout:
	ld a,(wAreaFlags)		; $2daa
	and AREAFLAG_DUNGEON		; $2dad
	ret z			; $2daf

	ldh a,(<hRomBank)	; $2db0
	push af			; $2db2
	callfrombank0 bank1.loadDungeonLayout_b01	; $2db3
	pop af			; $2dbd
	setrombank		; $2dbe
	ret			; $2dc3

;;
; @addr{2dc4}
initializeDungeonStuff:
	xor a			; $2dc4
	ld (wToggleBlocksState),a		; $2dc5
	ld (wSwitchState),a		; $2dc8
	ld (wSpinnerState),a		; $2dcb
	jp loadStaticObjects		; $2dce

;;
; @addr{2dd1}
setVisitedRoomFlag:
	call getThisRoomFlags		; $2dd1
	set ROOMFLAG_BIT_VISITED, (hl)		; $2dd4
	ret			; $2dd6

;;
; Sets wDungeonRoomProperties to this room's dungeon flag value, also returns
; value in a
;
; @param[out]	a	Dungeon properties
; @addr{2dd7}
getThisRoomDungeonProperties:
	ldh a,(<hRomBank)	; $2dd7
	push af			; $2dd9
	ld a, :dungeonRoomPropertiesGroupTable
	setrombank		; $2ddc
	ld a,(wActiveGroup)		; $2de1
	sub $04			; $2de4
	and $01			; $2de6
	ld hl, dungeonRoomPropertiesGroupTable
	rst_addDoubleIndex			; $2deb
	ldi a,(hl)		; $2dec
	ld h,(hl)		; $2ded
	ld l,a			; $2dee
	ld a,(wActiveRoom)		; $2def
	ld b,$00		; $2df2
	ld c,a			; $2df4
	add hl,bc		; $2df5
	ld a,(hl)		; $2df6
	ld (wDungeonRoomProperties),a		; $2df7
	pop af			; $2dfa
	setrombank		; $2dfb
	ret			; $2e00

;;
; Get the address of the dungeon layout in RAM in hl (wram bank 2)
;
; @addr{2e01}
getDungeonLayoutAddress:
	push bc			; $2e01
	push de			; $2e02
	ld a,(wDungeonFloor)		; $2e03
	ld c,$40		; $2e06
	call multiplyAByC		; $2e08
	ld bc, w2DungeonLayout
	add hl,bc		; $2e0e
	pop de			; $2e0f
	pop bc			; $2e10
	ret			; $2e11

;;
; Get the current room index.
;
; @param[out]	a	Current room index
; @addr{2e12}
getActiveRoomFromDungeonMapPosition:
	ld a,(wDungeonMapPosition)		; $2e12

;;
; Get the room at minimap position A on the current floor.
;
; @param	a	Minimap position
; @param[out]	a,l	Room at that position
; @addr{2e15}
getRoomInDungeon:
	ldh (<hFF8B),a	; $2e15
	ld a, :w2DungeonLayout
	ld ($ff00+R_SVBK),a	; $2e19
	call getDungeonLayoutAddress		; $2e1b
	ldh a,(<hFF8B)	; $2e1e
	rst_addAToHl			; $2e20
	ld l,(hl)		; $2e21
	xor a			; $2e22
	ld ($ff00+R_SVBK),a	; $2e23
	ld a,l			; $2e25
	ret			; $2e26


.ifdef ROM_SEASONS
	.include "code/code_3035.s"
.endif


;;
; @addr{2e27}
getFreeEnemySlot:
	call getFreeEnemySlot_uncounted		; $2e27
	ret nz			; $2e2a
	ld a,(wNumEnemies)		; $2e2b
	inc a			; $2e2e
	ld (wNumEnemies),a		; $2e2f
	xor a			; $2e32
	ret			; $2e33

;;
; @addr{2e34}
getFreeEnemySlot_uncounted:
	ldhl FIRST_ENEMY_INDEX, Enemy.start		; $2e34
--
	ld a,(hl)		; $2e37
	or a			; $2e38
	jr z,+
	inc h			; $2e3b
	ld a,h			; $2e3c
	cp LAST_ENEMY_INDEX+1			; $2e3d
	jr c,--
	or h			; $2e41
	ret			; $2e42
+
	inc a			; $2e43
	ldi (hl),a		; $2e44
	xor a			; $2e45
	ret			; $2e46

;;
; @addr{2e47}
enemyDelete:
	ld e,Enemy.enabled		; $2e47
	call objectRemoveFromAButtonSensitiveObjectList		; $2e49
	ld l,e			; $2e4c
	ld h,d			; $2e4d
	ld b,$10		; $2e4e
	xor a			; $2e50
-
	ldi (hl),a		; $2e51
	ldi (hl),a		; $2e52
	ldi (hl),a		; $2e53
	ldi (hl),a		; $2e54
	dec b			; $2e55
	jr nz,-
	ret			; $2e58

;;
; Deletes the enemy (clears its memory), then replaces its ID with the new value.
;
; The new object keeps its former yh, xh, zh, and enabled values.
;
; Mostly equivalent to the "objectReplaceWithID" function, but only for enemies.
;
; @param	bc	New enemy ID
; @addr{2e59}
enemyReplaceWithID:
	ld h,d			; $2e59
	push bc			; $2e5a

	; Store Enemy.enabled, Y position
	ld l,Enemy.enabled		; $2e5b
	ld b,(hl)		; $2e5d
	ld l,Enemy.yh		; $2e5e
	ld c,(hl)		; $2e60
	push bc			; $2e61

	; Store X, Z
	ld l,Enemy.xh		; $2e62
	ld b,(hl)		; $2e64
	ld l,Enemy.zh		; $2e65
	ld c,(hl)		; $2e67
	push bc			; $2e68

	; Delete enemy
	call enemyDelete		; $2e69

	; Restore X/Y/Z positions
	pop bc			; $2e6c
	ld l,Enemy.zh		; $2e6d
	ld (hl),c		; $2e6f
	ld l,Enemy.xh		; $2e70
	ld (hl),b		; $2e72
	pop bc			; $2e73
	ld l,Enemy.yh		; $2e74
	ld (hl),c		; $2e76

	; Restore Enemy.enabled (not all bits?)
	ld l,Enemy.enabled		; $2e77
	ld a,b			; $2e79
	and $73			; $2e7a
	ldi (hl),a		; $2e7c

	; Set Enemy.id, subid
	pop bc			; $2e7d
	ld (hl),b		; $2e7e
	inc l			; $2e7f
	ld (hl),c		; $2e80
	ret			; $2e81

;;
; Update all enemies with 'state' variables equal to 0.
;
; @addr{2e82}
_updateEnemiesIfStateIsZero:
	ld a,Enemy.start		; $2e82
	ldh (<hActiveObjectType),a	; $2e84
	ld d,FIRST_ENEMY_INDEX	; $2e86
	ld a,d			; $2e88
--
	ldh (<hActiveObject),a	; $2e89
	ld h,d			; $2e8b
	ld l,Enemy.enabled		; $2e8c
	ld a,(hl)		; $2e8e
	or a			; $2e8f
	jr z,@next		; $2e90

	ld l,Enemy.state	; $2e92
	ldi a,(hl)		; $2e94
	or (hl)			; $2e95
	call z,updateEnemy		; $2e96
	ld e,Enemy.oamFlagsBackup		; $2e99
	ld a,(de)		; $2e9b
	inc e			; $2e9c
	ld (de),a		; $2e9d
@next:
	inc d			; $2e9e
	ld a,d			; $2e9f
	cp $e0			; $2ea0
	jr c,--			; $2ea2
	ret			; $2ea4

;;
; Update all enemies by calling their enemy-specific code and doing other common enemy
; stuff.
;
; @addr{2ea5}
updateEnemies:
	ld a,(wScrollMode)		; $2ea5
	and $0e			; $2ea8
	jr nz,_updateEnemiesIfStateIsZero	; $2eaa

	ld a,(wTextIsActive)		; $2eac
	or a			; $2eaf
	jr nz,_updateEnemiesIfStateIsZero	; $2eb0

	ld a,(wDisabledObjects)		; $2eb2
	and $84			; $2eb5
	jr nz,_updateEnemiesIfStateIsZero	; $2eb7

	ld a,(wPaletteThread_mode)		; $2eb9
	or a			; $2ebc
	jr nz,_updateEnemiesIfStateIsZero	; $2ebd

	ld a,Enemy.start	; $2ebf
	ldh (<hActiveObjectType),a	; $2ec1
	ld d,FIRST_ENEMY_INDEX	; $2ec3
	ld a,d			; $2ec5
--
	ldh (<hActiveObject),a	; $2ec6

	ld e,Enemy.enabled	; $2ec8
	ld a,(de)		; $2eca
	or a			; $2ecb
	jr z,@next		; $2ecc

	call updateEnemy		; $2ece

	; Reset bit 7 of var2a to indicate that, if any collision has occurred, it's no
	; longer the first frame of the collision.
	ld h,d			; $2ed1
	ld l,Enemy.var2a		; $2ed2
	res 7,(hl)		; $2ed4

	; Increment/decrement invincibilityCounter if applicable, update palette
	inc l			; $2ed6
	ld a,(hl) ; a = [enemy.invincibilityCounter]
	or a			; $2ed8
	jr z,@label_00_349	; $2ed9

	rlca			; $2edb
	jr c,@label_00_348	; $2edc

	dec (hl)		; $2ede
	jr z,@label_00_349	; $2edf

	ld a,(wFrameCounter)		; $2ee1
	bit 2,a			; $2ee4
	jr nz,@label_00_349	; $2ee6

	ld b,$05		; $2ee8
	ld l,Enemy.oamFlagsBackup		; $2eea
	ldi a,(hl)		; $2eec
	and $07			; $2eed
	cp b			; $2eef
	jr nz,+			; $2ef0
	ld b,$02		; $2ef2
+
	ld a,(hl)		; $2ef4
	and $f8			; $2ef5
	or b			; $2ef7
	ld (hl),a		; $2ef8
	jr @next		; $2ef9

@label_00_348:
	inc (hl)		; $2efb
@label_00_349:
	ld l,Enemy.oamFlagsBackup		; $2efc
	ldi a,(hl)		; $2efe
	ld (hl),a		; $2eff
@next:
	inc d			; $2f00
	ld a,d			; $2f01
	cp LAST_ENEMY_INDEX+1			; $2f02
	jr c,--			; $2f04
	ret			; $2f06

;;
; @param	d	Enemy to update
; @addr{2f07}
updateEnemy:
	call enemyStandardUpdate		; $2f07
	ld e,Enemy.id		; $2f0a
	ld a,(de)		; $2f0c

.ifdef ROM_AGES
	; Calculate bank number in 'b'
	ld b,$0f		; $2f0d
	cp $70			; $2f0f
	jr nc,++			; $2f11
	dec b			; $2f13
	cp $30			; $2f14
	jr nc,++			; $2f16
	dec b			; $2f18
	cp $08			; $2f19
	jr nc,++			; $2f1b
	ld b,$10		; $2f1d

.else ; ROM_SEASONS

	ld b,$0f
	cp $08
	jr c,+
	dec b
	cp $70
	jr nc,+
	dec b
	cp $30
	jr nc,+
	dec b
+
	; Seasons sets the rom bank here instead of later, for no particular reason...?
	ld e,a
	ld a,b
	setrombank
	ld a,e
.endif

++
	; hl = enemyCodeTable + a*2
	add a			; $2f1f
	add <enemyCodeTable	; $2f20
	ld l,a			; $2f22
	ld a,$00		; $2f23
	adc >enemyCodeTable	; $2f25
	ld h,a			; $2f27

	ldi a,(hl)		; $2f28
	ld h,(hl)		; $2f29
	ld l,a			; $2f2a
.ifdef ROM_AGES
	ld a,b			; $2f2b
	setrombank		; $2f2c
.endif
	ld a,c			; $2f31
	or a			; $2f32
	jp hl			; $2f33

; @addr{2f34}
enemyCodeTable:
	.dw bank10.enemyCode00 ; 0x00
	.dw bank10.enemyCode01 ; 0x01
	.dw bank10.enemyCode02 ; 0x02
	.dw bank10.enemyCode03 ; 0x03
	.dw bank10.enemyCode04 ; 0x04
	.dw bank10.enemyCode05 ; 0x05
	.dw bank10.enemyCode06 ; 0x06
	.dw bank10.enemyCode07 ; 0x07
	.dw bank0d.enemyCode08 ; 0x08
	.dw bank0d.enemyCode09 ; 0x09
	.dw bank0d.enemyCode0a ; 0x0a
	.dw bank0d.enemyCode0b ; 0x0b
	.dw bank0d.enemyCode0c ; 0x0c
	.dw bank0d.enemyCode0d ; 0x0d
	.dw bank0d.enemyCode0e ; 0x0e
	.dw bank0d.enemyCode0f ; 0x0f
	.dw bank0d.enemyCode10 ; 0x10
	.dw bank0d.enemyCode11 ; 0x11
	.dw bank0d.enemyCode12 ; 0x12
	.dw bank0d.enemyCode13 ; 0x13
	.dw bank0d.enemyCode14 ; 0x14
	.dw bank0d.enemyCode15 ; 0x15
	.dw bank0d.enemyCode16 ; 0x16
	.dw bank0d.enemyCode17 ; 0x17
	.dw bank0d.enemyCode18 ; 0x18
	.dw bank0d.enemyCode19 ; 0x19
	.dw bank0d.enemyCode1a ; 0x1a
	.dw bank0d.enemyCode1b ; 0x1b
	.dw bank0d.enemyCode1c ; 0x1c
	.dw bank0d.enemyCode1d ; 0x1d
	.dw bank0d.enemyCode1e ; 0x1e
	.dw bank0d.enemyCode1f ; 0x1f
	.dw bank0d.enemyCode20 ; 0x20
	.dw bank0d.enemyCode21 ; 0x21
	.dw bank0d.enemyCode22 ; 0x22
	.dw bank0d.enemyCode23 ; 0x23
	.dw bank0d.enemyCode24 ; 0x24
	.dw bank0d.enemyCode25 ; 0x25
	.dw bank0d.enemyCode26 ; 0x26
	.dw bank0d.enemyCode27 ; 0x27
	.dw bank0d.enemyCode28 ; 0x28
	.dw bank0d.enemyCode29 ; 0x29
	.dw bank0d.enemyCode2a ; 0x2a
	.dw bank0d.enemyCode2b ; 0x2b
	.dw bank0d.enemyCode2c ; 0x2c
	.dw bank0d.enemyCode2d ; 0x2d
	.dw bank0d.enemyCode2e ; 0x2e
	.dw bank0d.enemyCode2f ; 0x2f
	.dw bank0e.enemyCode30 ; 0x30
	.dw bank0e.enemyCode31 ; 0x31
	.dw bank0e.enemyCode32 ; 0x32
	.dw bank0e.enemyCode33 ; 0x33
	.dw bank0e.enemyCode34 ; 0x34
	.dw bank0e.enemyCode35 ; 0x35
	.dw bank0e.enemyCode36 ; 0x36
	.dw bank0e.enemyCode37 ; 0x37
	.dw bank0e.enemyCode38 ; 0x38
	.dw bank0e.enemyCode39 ; 0x39
	.dw bank0e.enemyCode3a ; 0x3a
	.dw bank0e.enemyCode3b ; 0x3b
	.dw bank0e.enemyCode3c ; 0x3c
	.dw bank0e.enemyCode3d ; 0x3d
	.dw bank0e.enemyCode3e ; 0x3e
	.dw bank0e.enemyCode3f ; 0x3f
	.dw bank0e.enemyCode40 ; 0x40
	.dw bank0e.enemyCode41 ; 0x41
	.dw bank0e.enemyCode42 ; 0x42
	.dw bank0e.enemyCode43 ; 0x43
	.dw enemyCodeNil       ; 0x44
	.dw bank0e.enemyCode45 ; 0x45
	.dw enemyCodeNil       ; 0x46
	.dw bank0e.enemyCode47 ; 0x47
	.dw bank0e.enemyCode48 ; 0x48
	.dw bank0e.enemyCode49 ; 0x49
	.dw bank0e.enemyCode4a ; 0x4a
	.dw bank0e.enemyCode4b ; 0x4b
	.dw bank0e.enemyCode4c ; 0x4c
	.dw bank0e.enemyCode4d ; 0x4d
	.dw bank0e.enemyCode4e ; 0x4e
	.dw bank0e.enemyCode4f ; 0x4f
	.dw bank0e.enemyCode50 ; 0x50
	.dw bank0e.enemyCode51 ; 0x51
	.dw bank0e.enemyCode52 ; 0x52
	.dw bank0e.enemyCode53 ; 0x53
	.dw bank0e.enemyCode54 ; 0x54
	.dw bank0e.enemyCode55 ; 0x55
	.dw bank0e.enemyCode56 ; 0x56
	.dw enemyCodeNil       ; 0x57
	.dw bank0e.enemyCode58 ; 0x58
	.dw bank0e.enemyCode59 ; 0x59
	.dw bank0e.enemyCode5a ; 0x5a
	.dw enemyCodeNil       ; 0x5b
	.dw enemyCodeNil       ; 0x5c
	.dw bank0e.enemyCode5d ; 0x5d
	.dw bank0e.enemyCode5e ; 0x5e
	.dw bank0e.enemyCode5f ; 0x5f
	.dw bank0e.enemyCode60 ; 0x60
	.dw bank0e.enemyCode61 ; 0x61
	.dw bank0e.enemyCode62 ; 0x62
	.dw bank0e.enemyCode63 ; 0x63
	.dw bank0e.enemyCode64 ; 0x64
	.dw enemyCodeNil       ; 0x65
	.dw enemyCodeNil       ; 0x66
	.dw enemyCodeNil       ; 0x67
	.dw enemyCodeNil       ; 0x68
	.dw enemyCodeNil       ; 0x69
	.dw enemyCodeNil       ; 0x6a
	.dw enemyCodeNil       ; 0x6b
	.dw enemyCodeNil       ; 0x6c
	.dw enemyCodeNil       ; 0x6d
	.dw enemyCodeNil       ; 0x6e
	.dw enemyCodeNil       ; 0x6f
	.dw bank0f.enemyCode70 ; 0x70
	.dw bank0f.enemyCode71 ; 0x71
	.dw bank0f.enemyCode72 ; 0x72
	.dw bank0f.enemyCode73 ; 0x73
	.dw bank0f.enemyCode74 ; 0x74
	.dw bank0f.enemyCode75 ; 0x75
	.dw bank0f.enemyCode76 ; 0x76
	.dw bank0f.enemyCode77 ; 0x77
	.dw bank0f.enemyCode78 ; 0x78
	.dw bank0f.enemyCode79 ; 0x79
	.dw bank0f.enemyCode7a ; 0x7a
	.dw bank0f.enemyCode7b ; 0x7b
	.dw bank0f.enemyCode7c ; 0x7c
	.dw bank0f.enemyCode7d ; 0x7d
	.dw bank0f.enemyCode7e ; 0x7e
	.dw bank0f.enemyCode7f ; 0x7f
	; Could there be over 0x80 enemies? Code at _enemyGetObjectGfxIndex will need to
	; be modified for that, perhaps there are other obstacles

;;
; @addr{3034}
enemyCodeNil:
	ret			; $3034


.ifdef ROM_AGES
	.include "code/code_3035.s"
.endif


.ifdef ROM_AGES

;;
; Same as "addSpritesToOam", except this changes the bank first.
;
; @param	e	Bank where the OAM data is
; @param	hl	OAM data
; @addr{30eb}
addSpritesFromBankToOam:
	ldh a,(<hRomBank)	; $30eb
	push af			; $30ed
	ld a,e			; $30ee
	setrombank		; $30ef
	call addSpritesToOam		; $30f4
	pop af			; $30f7
	setrombank		; $30f8
	ret			; $30fd

.else ; ROM_SEASONS

; Placeholder label
addSpritesFromBankToOam:

.endif

;;
; Called when loading a room.
;
; Note: ages doesn't save the bank number properly when something calls this, so it only
; works when called from bank 1 (same bank as "checkLoadPirateShip").
;
; @addr{30fe}
initializeRoom:

.ifdef ROM_AGES
	callab bank1.clearSolidObjectPositions		; $30fe

	ld a,(wSentBackByStrangeForce)		; $3106
	dec a			; $3109
	jr nz,+			; $310a

	ld b,INTERACID_SCREEN_DISTORTION		; $310c
	jp objectCreateInteractionWithSubid00		; $310e
+
	callab bank2.calculateRoomStateModifier		; $3111
	call   refreshObjectGfx		; $3119
	callab roomSpecificCode.runRoomSpecificCode
	callab bank2.createSeaEffectsPartIfApplicable		; $3124
	callab bank1.checkLoadPirateShip		; $312c

	ldh a,(<hRomBank)	; $3134
	push af			; $3136
	ld a,:bank2.checkAndSpawnMaple		; $3137
	setrombank		; $3139

	call checkSpawnTimeportalInteraction		; $313e

	ld a,(wcc05)		; $3141
	bit 2,a			; $3144
	call nz,bank2.loadRememberedCompanion		; $3146

	ld a,(wcc05)		; $3149
	bit 3,a			; $314c
	call nz,bank2.checkAndSpawnMaple		; $314e

	ld a,:objectData.parseObjectData
	setrombank		; $3153
	ld a,(wcc05)		; $3158
	bit 0,a			; $315b
	call nz,objectData.parseObjectData
	callfrombank0 bank16.parseStaticObjects	; $3160

.else ; ROM_SEASONS

	ldh a,(<hRomBank)
	push af

	call          refreshObjectGfx
	callfrombank0 bank10.loadRememberedCompanion
	call          bank10.checkAndSpawnMaple
	call          bank10.updateRosaDateStatus
	callfrombank0 $11 $58b5
	callfrombank0 $15 $4e35

.endif

	pop af			; $316a
	setrombank		; $316b
	ret			; $3170


;;
; @param	hl	Address of interaction data to parse
; @addr{3171}
parseGivenObjectData:
	ldh a,(<hRomBank)	; $3171
	push af			; $3173
	ld a, :objectData.parseGivenObjectData
	setrombank		; $3176
	push de			; $317b
	ld d,h			; $317c
	ld e,l			; $317d
	call objectData.parseGivenObjectData		; $317e
	pop de			; $3181
	pop af			; $3182
	setrombank		; $3183
	ret			; $3188

;;
; Checks if there are any "static objects" in the room to load.
;
; @addr{3189}
loadStaticObjects:
	ldh a,(<hRomBank)	; $3189
	push af			; $318b
	ld a,:bank16.loadStaticObjects_body	; $318c
	setrombank		; $318e
	push de			; $3193
	call bank16.loadStaticObjects_body		; $3194
	pop de			; $3197
	pop af			; $3198
	setrombank		; $3199
	ret			; $319e

;;
; @addr{319f}
clearStaticObjects:
	ld hl,wStaticObjects		; $319f
	ld b,_sizeof_wStaticObjects	; $31a2
	jp clearMemory		; $31a4

;;
; Search wStaticObjects to find a slot (8 bytes) which is unused.
;
; @param[out]	hl	Address of free slot (if successful)
; @param[out]	zflag	Set on success
; @addr{31a7}
findFreeStaticObjectSlot:
	ld hl,wStaticObjects		; $31a7
.ifdef ROM_AGES
	ld b,$08		; $31aa
.endif
--
	ld a,(hl)		; $31ac
	or a			; $31ad
	ret z			; $31ae

	ld a,$08		; $31af
	add l			; $31b1
	ld l,a			; $31b2
.ifdef ROM_AGES
	dec b			; $31b3
.endif
	jr nz,--		; $31b4

	or h			; $31b6
	ret			; $31b7

;;
; Deletes the object which the relatedObj1 variable points to, assuming it points to
; a "static" object (stored in wStaticObjects).
;
; @addr{31b8}
objectDeleteRelatedObj1AsStaticObject:
	ldh a,(<hActiveObjectType)	; $31b8
	add Object.relatedObj1			; $31ba
	ld l,a			; $31bc
	ld h,d			; $31bd
	ldi a,(hl)		; $31be
	ld h,(hl)		; $31bf
	ld e,l			; $31c0
	ld l,a			; $31c1
	or h			; $31c2
	ret z			; $31c3

	; de still points to relatedObj1; clear it
	xor a			; $31c4
	ld (de),a		; $31c5
	dec e			; $31c6
	ld (de),a		; $31c7

	; Delete the related object (only 8 bytes since it's a static object)
	ld e,$08		; $31c8
--
	ldi (hl),a		; $31ca
	dec e			; $31cb
	jr nz,--		; $31cc
	ret			; $31ce

;;
; Saves an object to a "static object" slot, which persists between rooms.
;
; @param	a	Static object type (see constants/staticObjectTypes.s)
; @param	d	Object
; @param	hl	Address in wStaticObjects
; @addr{31cf}
objectSaveAsStaticObject:
	ld (hl),a		; $31cf
	ldh a,(<hActiveObjectType)	; $31d0
	add Object.relatedObj1			; $31d2
	ld e,a			; $31d4

	ld a,l			; $31d5
	ld (de),a		; $31d6
	inc e			; $31d7
	ld a,h			; $31d8
	ld (de),a		; $31d9

	ld a,(wActiveRoom)		; $31da
	inc hl			; $31dd
	ldi (hl),a		; $31de

	; Store Object.id
	ldh a,(<hActiveObjectType)	; $31df
	inc a			; $31e1
	ld e,a			; $31e2
	ld a,(de)		; $31e3
	ldi (hl),a		; $31e4

	; Store Object.subid
	inc e			; $31e5
	ld a,(de)		; $31e6
	ldi (hl),a		; $31e7

	; Store y,x
	ld a,e			; $31e8
	add Object.yh-Object.subid			; $31e9
	ld e,a			; $31eb
	ld a,(de)		; $31ec
	ldi (hl),a		; $31ed
	inc e			; $31ee
	inc e			; $31ef
	ld a,(de)		; $31f0
	ldi (hl),a		; $31f1
	ret			; $31f2

;;
; @param	a	Global flag to check (see constants/globalFlags.s)
; @addr{31f3}
checkGlobalFlag:
	ld hl,wGlobalFlags		; $31f3
	jp checkFlag		; $31f6

;;
; @param	a	Global flag to set
; @addr{31f9}
setGlobalFlag:
	ld hl,wGlobalFlags		; $31f9
	jp setFlag		; $31fc

;;
; @param	a	Global flag to unset
; @addr{31ff}
unsetGlobalFlag:
	ld hl,wGlobalFlags		; $31ff
	jp unsetFlag		; $3202


;;
; Calls bank2._clearEnemiesKilledList.
;
; @addr{3205}
clearEnemiesKilledList:
	ld h,$00		; $3205
	.ifdef ROM_AGES
	jr ++		; $3207
	.else
	jp ++
	.endif

;;
; Calls bank2._addRoomToEnemiesKilledList.
;
; @addr{3209}
addRoomToEnemiesKilledList:
	ld h,$01		; $3209
	.ifdef ROM_AGES
	jr ++		; $320b
	.else
	jp ++
	.endif

;;
; Marks an enemy as killed so it doesn't respawn for a bit.
; Calls bank2._markEnemyAsKilledInRoom.
;
; @addr{320d}
markEnemyAsKilledInRoom:
	ld h,$02		; $320d
	.ifdef ROM_AGES
	jr ++		; $320f
	.else
	jp ++
	.endif

;;
; Calls bank2._stub_02_77f4. (Unused)
;
; @addr{3211}
func_3211:
	ld h,$03		; $3211
	.ifdef ROM_AGES
	jr ++		; $3213
	.else
	jp ++
	.endif

;;
; Places the numbers $00-$ff into w4RandomBuffer in a random order.
; Calls bank2.generateRandomBuffer.
;
; @addr{3215}
generateRandomBuffer:
	ld h,$04		; $3215
	.ifdef ROM_AGES
	jr ++		; $3217
	.else
	jp ++
	.endif

;;
; Get a random position for an enemy and store it in wEnemyPlacement.enemyPos.
; Calls bank2._getRandomPositionForEnemy.
;
; @param	hFF8B	"Flags" (set when placing an enemy in the editor)
; @addr{3219}
getRandomPositionForEnemy:
	ld h,$05		; $3219
	.ifdef ROM_AGES
	jr ++		; $321b
	.else
	jp ++
	.endif


.ifdef ROM_AGES

;;
; Calls bank2._checkSpawnTimeportalInteraction.
;
; @addr{321d}
checkSpawnTimeportalInteraction:
	ld h,$06		; $321d

.endif

++
	ld l,a			; $321f
	ldh a,(<hRomBank)	; $3220
	push af			; $3222
	callfrombank0 bank2.functionCaller		; $3223
	rl c			; $322d
	pop af			; $322f
	setrombank		; $3230
	srl c			; $3235
	ret			; $3237

;;
; @addr{3238}
clearPaletteFadeVariablesAndRefreshPalettes:
	ld a,$ff		; $3238
	ldh (<hDirtyBgPalettes),a	; $323a
	ldh (<hDirtySprPalettes),a	; $323c
;;
; @addr{323e}
clearPaletteFadeVariables:
	xor a			; $323e
	ld (wPaletteThread_mode),a		; $323f
	ld (wPaletteThread_fadeOffset),a		; $3242
	ldh (<hBgPaletteSources),a	; $3245
	ldh (<hSprPaletteSources),a	; $3247
	ld (wPaletteThread_updateRate),a		; $3249
	ld (wLockBG7Color3ToBlack),a		; $324c
	ld hl,wDirtyFadeBgPalettes		; $324f
	ldi (hl),a		; $3252
	ldi (hl),a		; $3253
	ldi (hl),a		; $3254
	ld (hl),a		; $3255
	ret			; $3256

;;
; @param	a	Amount to divide the speed of the fadeout by
; @addr{3257}
fadeoutToWhiteWithDelay:
	call setPaletteThreadDelay		; $3257
	ld a,$09		; $325a
	ld (wPaletteThread_mode),a		; $325c
	ld a,$01		; $325f
	jr ++			; $3261

;;
; @addr{3263}
fastFadeoutToWhite:
	ld a,$01		; $3263
	ld (wPaletteThread_mode),a		; $3265
	ld a,$03		; $3268
	jr ++			; $326a
;;
; @addr{326c}
fadeoutToWhite:
	ld a,$01		; $326c
	ld (wPaletteThread_mode),a		; $326e
	ld a,$01		; $3271
++
	ld (wPaletteThread_speed),a		; $3273
	xor a			; $3276
	ld (wPaletteThread_fadeOffset),a		; $3277

;;
; Configure all palettes to update from w2FadingBg/SprPalettes, and mark the palettes as
; dirty.
; @addr{327a}
makeAllPaletteUseFading:
	ld a,$ff		; $327a
	ld hl,wDirtyFadeBgPalettes		; $327c
	ldi (hl),a		; $327f
	ldi (hl),a		; $3280
	ldi (hl),a		; $3281
	ld (hl),a		; $3282
	ret			; $3283

;;
; @param	a	Amount to divide the speed of the fadein by
; @addr{3284}
fadeinFromWhiteWithDelay:
	call setPaletteThreadDelay		; $3284
	ld a,$0a		; $3287
	ld (wPaletteThread_mode),a		; $3289
	ld a,$01		; $328c
	jr ++			; $328e

;;
; @addr{3290}
fastFadeinFromWhite:
	ld a,$02		; $3290
	ld (wPaletteThread_mode),a		; $3292
	ld a,$03		; $3295
	jr ++			; $3297

;;
; @addr{3299}
fadeinFromWhite:
	ld a,$02		; $3299
	ld (wPaletteThread_mode),a		; $329b
	ld a,$01		; $329e
++
	ld (wPaletteThread_speed),a		; $32a0
	ld a,$20		; $32a3
	ld (wPaletteThread_fadeOffset),a		; $32a5
	jp makeAllPaletteUseFading		; $32a8

;;
; @param	a	Amount to divide the speed of the fadeout by
; @addr{32ab}
fadeoutToBlackWithDelay:
	call setPaletteThreadDelay		; $32ab
	ld a,$0b		; $32ae
	ld (wPaletteThread_mode),a		; $32b0
	ld a,$01		; $32b3
	jr ++			; $32b5

;;
; @addr{32b7}
fastFadeoutToBlack:
	ld a,$03		; $32b7
	ld (wPaletteThread_mode),a		; $32b9
	ld a,$03		; $32bc
	jr ++			; $32be

;;
; @addr{32c0}
fadeoutToBlack:
	ld a,$03		; $32c0
	ld (wPaletteThread_mode),a		; $32c2
	ld a,$01		; $32c5
++
	ld (wPaletteThread_speed),a		; $32c7
	xor a			; $32ca
	ld (wPaletteThread_fadeOffset),a		; $32cb
	jp makeAllPaletteUseFading		; $32ce

;;
; @param	a	Amount to divide the speed of the fadein by
; @addr{32d1}
fadeinFromBlackWithDelay:
	call setPaletteThreadDelay		; $32d1
	ld a,$0c		; $32d4
	ld (wPaletteThread_mode),a		; $32d6
	ld a,$01		; $32d9
	jr ++			; $32db

;;
; @addr{32dd}
fastFadeinFromBlack:
	ld a,$04		; $32dd
	ld (wPaletteThread_mode),a		; $32df
	ld a,$03		; $32e2
	jr ++			; $32e4

;;
; @addr{32e6}
fadeinFromBlack:
	ld a,$04		; $32e6
	ld (wPaletteThread_mode),a		; $32e8
	ld a,$01		; $32eb
++
	ld (wPaletteThread_speed),a		; $32ed
	ld a,$e0		; $32f0
	ld (wPaletteThread_fadeOffset),a		; $32f2
	jp makeAllPaletteUseFading		; $32f5



.ifdef ROM_AGES

; Room darkening-related code was slightly rewritten in Ages, compared to Seasons?

;;
; Darkens a room half as much as "darkenRoomLightly".
; @addr{32f8}
darkenRoomLightly:
	ld b,$f7		; $32f8
	jr _darkenRoomHelper		; $32fa

;;
; Unused?
;
; @param	a	How much to slow down palette thread
; @addr{32fc}
func_32fc:
	call setPaletteThreadDelay		; $32fc
	ld a,$0d		; $32ff
	ld b,$f0		; $3301
	ld (wPaletteThread_mode),a		; $3303
	ld a,$01		; $3306
	jr _setDarkeningVariables		; $3308

;;

; @param	a	Speed of darkening
; @addr{330a}
darkenRoomWithSpeed:
	ld b,$f0		; $330a
	call _setDarkeningVariables		; $330c
	ld a,$05		; $330f
	ld (wPaletteThread_mode),a		; $3311
	ret			; $3314


;;
; Darkens a room twice as much as "darkenRoomLightly".
; @addr{3315}
darkenRoom:
	ld b,$f0		; $3315

;;
; @param	b	Amount to darken
; @addr{3317}
_darkenRoomHelper:
	ld a,$05		; $3317
	ld (wPaletteThread_mode),a		; $3319
	ld a,$01		; $331c


;;
; @param	a	Speed of darkening
; @param	b	Amount to darken
; @addr{331e}
_setDarkeningVariables:
	ld (wPaletteThread_speed),a		; $331e
	ld a,(wPaletteThread_parameter)		; $3321
	ld (wPaletteThread_fadeOffset),a		; $3324
	ld a,b			; $3327
	ld (wPaletteThread_parameter),a		; $3328

	; Mark BG palettes 2-7 as needing refresh
	ld a,$fc		; $332b
	ld hl,wDirtyFadeBgPalettes		; $332d
	ldi (hl),a		; $3330
	ld (hl),$00		; $3331
	inc l			; $3333
	ldi (hl),a ; [wFadeBgPaletteSources] = $fc
	ld (hl),$00		; $3335
	ret			; $3337

;;
; @addr{3338}
brightenRoomLightly:
	ld b,$f7		; $3338
	ld a,$01		; $333a
	jr _brightenRoomHelper			; $333c

;;
; Unused?
;
; @param	a
; @addr{333e}
func_333e:
	call setPaletteThreadDelay		; $333e
	ld a,$0e		; $3341
	ld b,$00		; $3343
	ld (wPaletteThread_mode),a		; $3345
	ld a,$01		; $3348
	jr _setDarkeningVariables		; $334a

;;
; @param	a	Speed of brightening
; @addr{334c}
brightenRoomWithSpeed:
	ld b,$00		; $334c
	jr _brightenRoomHelper			; $334e

;;
; @addr{3350}
brightenRoom:
	ld b,$00		; $3350
	ld a,$01		; $3352

;;
; @param	a	Speed of brightening
; @param	b	Amount to brighten
; @addr{3354}
_brightenRoomHelper:
	call _setDarkeningVariables		; $3354
	ld a,$06		; $3357
	ld (wPaletteThread_mode),a		; $3359
	ret			; $335c


.else; ROM_SEASONS

;;
darkenRoomLightly:
	ld b,$f7
	jr _darkenRoomHelper

;;
darkenRoom:
	ld b,$f0

;;
_darkenRoomHelper:
	ld a,$05
	ld (wPaletteThread_mode),a
_label_331c:
	ld a,(wPaletteThread_parameter)


;;
; @param	a	Start of darkening
; @param	b	Amount to darken
_setDarkeningVariables:
	ld (wPaletteThread_fadeOffset),a
	ld a,b
	ld (wPaletteThread_parameter),a
	ld a,$01
	ld (wPaletteThread_speed),a
	ld a,$fc
	ld hl,wDirtyFadeBgPalettes
	ldi (hl),a
	ld (hl),$00
	inc l
	ldi (hl),a
	ld (hl),$00
	ret

;;
brightenRoomLightly:
	ld b,$f7
	jr ++

;;
brightenRoom:
	ld b,$00
++
	ld a,$06
	ld (wPaletteThread_mode),a
	jr _label_331c


; Placeholders
func_32fc:
darkenRoomWithSpeed:
brightenRoomWithSpeed:


.endif; ROM_SEASONS



;;
; Almost identical to "fastFadeinFromWhite", but uses palette fade mode 7 which checks if
; a room should be dark? (wPaletteThread_parameter should be set accordingly?)
;
; Also uses a value of $1e instead of $20 for initial fadeOffset; maybe because it's
; a multiple of 3, which is the value for wPaletteThread_speed?
;
; @addr{335d}
fastFadeinFromWhiteToRoom:
	call fastFadeinFromWhite		; $335d
	ld a,$1e		; $3360
	ld (wPaletteThread_fadeOffset),a		; $3362
--
	ld a,$07		; $3365
	ld (wPaletteThread_mode),a		; $3367
	ret			; $336a

;;
; @addr{336b}
fadeinFromWhiteToRoom:
	call fadeinFromWhite		; $336b
	jr --			; $336e

;;
; Fades between the palettes in w2ColorComponentBuffer1 and w2ColorComponentBuffer2. The
; colors in these palettes apply to the palettes BG2-7.
;
; @addr{3370}
startFadeBetweenTwoPalettes:
	ld a,$08		; $3370
	ld (wPaletteThread_mode),a		; $3372
	ld a,$20		; $3375
	ld (wPaletteThread_fadeOffset),a		; $3377
	ret			; $337a

;;
; @param	a	A value which acts to slow down certain palette fades the higher
;			it is. (Acts like division.)
; @addr{337b}
setPaletteThreadDelay:
	ld (wPaletteThread_counterRefill),a		; $337b
	ld a,$01		; $337e
	ld (wPaletteThread_counter),a		; $3380
	ret			; $3383

;;
; @addr{3384}
paletteFadeThreadStart:
	ld a,:w2AreaBgPalettes	; $3384
	ld ($ff00+R_SVBK),a	; $3386

	callfrombank0 bank1.paletteFadeHandler	; $3388
	call          bank1.checkLockBG7Color3ToBlack		; $3392

	; Resume this thread in [wPaletteThread_updateRate] frames.
	ld a,(wPaletteThread_updateRate)		; $3395
	or a			; $3398
	jr nz,+			; $3399
	inc a			; $339b
+
	call resumeThreadInAFrames		; $339c
	jr paletteFadeThreadStart		; $339f


;;
; This thread runs all of the interesting, in-game stuff.
;
; @addr{33a1}
mainThreadStart:
	call restartSound		; $33a1
	call stopTextThread		; $33a4

@mainThread:
	; Increment wPlaytimeCounter, the 4-byte counter
	ld hl,wPlaytimeCounter		; $33a7
	inc (hl)		; $33aa
	ldi a,(hl)		; $33ab
	ld (wFrameCounter),a		; $33ac
	jr nz,++
	inc (hl)		; $33b1
	jr nz,++
	inc l			; $33b4
	inc (hl)		; $33b5
	jr nz,++
	inc l			; $33b8
	inc (hl)		; $33b9
++
	callfrombank0 bank1.runGameLogic	; $33ba
	call          drawAllSprites		; $33c4
	call          checkReloadStatusBarGraphics		; $33c7
	call          resumeThreadNextFrame		; $33ca

	jr           @mainThread



.ifdef ROM_SEASONS

seasonsFunc_3276:
	ldh a,(<hRomBank)
	push af
	ld a,:groupMusicPointerTable
	setrombank

	; bank 4
	call $575e
	pop af
	setrombank
	ret
.endif

;;
; Sets wActiveMusic2 to the appropriate value, and sets wLoadingRoomPack (for present/past
; overworlds only)
;
; @addr{33cf}
loadScreenMusic:
	ldh a,(<hRomBank)	; $33cf
	push af			; $33d1
	ld a,:groupMusicPointerTable
	setrombank		; $33d4

	ld a,(wActiveGroup)		; $33d9
	ld hl,groupMusicPointerTable
	rst_addDoubleIndex			; $33df
	ldi a,(hl)		; $33e0
	ld h,(hl)		; $33e1
	ld l,a			; $33e2
	ld a,(wActiveRoom)		; $33e3
	rst_addAToHl			; $33e6
	ldi a,(hl)		; $33e7
	ld (wActiveMusic2),a		; $33e8

.ifdef ROM_AGES
	ld a,(wActiveGroup)		; $33eb
	cp $02			; $33ee
	jr nc,++

	ld b,a			; $33f2
	ld a,(wActiveRoom)		; $33f3
	ld c,a			; $33f6
	ld hl,roomPackData		; $33f7
	add hl,bc		; $33fa
	ldi a,(hl)		; $33fb
	ld (wLoadingRoomPack),a		; $33fc
++
	pop af			; $33ff
	setrombank		; $3400
	ret			; $3405

.else; ROM_SEASONS

	ld a,(wActiveGroup)
	or a
	jr nz,++

	ld a,(wActiveRoom)
	ld hl,roomPackData
	rst $10
	ldi a,(hl)
	ld (wLoadingRoomPack),a
++
	pop af
	setrombank
	ret
.endif


;;
applyWarpDest:
	ldh a,(<hRomBank)	; $32be
	push af			; $32c0
	callfrombank0 applyWarpDest_b04		; $32c1

.ifdef ROM_SEASONS
	callfrombank0 $01 $578d		; $32cb
.endif

	pop af			; $32d5
	setrombank		; $32d6
	ret			; $32db


;;
; - Calls loadScreenMusic
; - Copies wActiveRoom to wLoadingRoom
; - Copies wLoadingRoomPack to wRoomPack (for group 0 only)
;
; @addr{341a}
loadScreenMusicAndSetRoomPack:
	call loadScreenMusic		; $341a
	ld a,(wActiveRoom)		; $341d
	ld (wLoadingRoom),a		; $3420
	ld a,(wActiveGroup)		; $3423
	or a			; $3426
	ret nz			; $3427

	ld a,(wLoadingRoomPack)		; $3428
.ifdef ROM_AGES
	and $7f			; $342b
.endif
	ld (wRoomPack),a		; $342d
	ret			; $3430

;;
; @addr{3431}
dismountCompanionAndSetRememberedPositionToScreenCenter:
	ldh a,(<hRomBank)	; $3431
	push af			; $3433
	ld a,:bank5.companionDismount		; $3434
	setrombank		; $3436

	ld de,w1Companion		; $343b
	ld a,e			; $343e
	ldh (<hActiveObjectType),a	; $343f
	ld a,d			; $3441
	ldh (<hActiveObject),a	; $3442

	call bank5.companionDismount		; $3444
	call bank5.saveLinkLocalRespawnAndCompanionPosition		; $3447

	; After saving the companion's position, overwrite it with values for the center
	; of the screen?
	ld a,$38		; $344a
	ld (wRememberedCompanionY),a		; $344c
	ld a,$50		; $344f
	ld (wRememberedCompanionX),a		; $3451

	pop af			; $3454
	setrombank		; $3455
	ret			; $345a

.ifdef ROM_SEASONS

seasonsFunc_331b:
	ld a,($ff00+$97)	; $331b
	push af			; $331d
	ld a,$0f		; $331e
	ld ($ff00+$97),a	; $3320
	ld ($2222),a		; $3322
	call $6f75		; $3325
	pop af			; $3328
	ld ($ff00+$97),a	; $3329
	ld ($2222),a		; $332b
	ret			; $332e

seasonsFunc_332f:
	ld a,($ff00+$97)	; $332f
	push af			; $3331
	ld a,$0f		; $3332
	ld ($ff00+$97),a	; $3334
	ld ($2222),a		; $3336
	call $704d		; $3339
	call $7182		; $333c
	pop af			; $333f
	ld ($ff00+$97),a	; $3340
	ld ($2222),a		; $3342
	ret			; $3345

seasonsFunc_3346:
	ld a,($ff00+$97)	; $3346
	push af			; $3348
	ld a,$03		; $3349
	ld ($ff00+$97),a	; $334b
	ld ($2222),a		; $334d
	call $6dfd		; $3350
	pop af			; $3353
	ld ($ff00+$97),a	; $3354
	ld ($2222),a		; $3356
	ret			; $3359

seasonsFunc_335a:
	ld a,($ff00+$97)	; $335a
	push af			; $335c
	ld a,$03		; $335d
	ld ($ff00+$97),a	; $335f
	ld ($2222),a		; $3361
	call $6e05		; $3364
	pop af			; $3367
	ld ($ff00+$97),a	; $3368
	ld ($2222),a		; $336a
	ret			; $336d

seasonsFunc_336e:
	ld a,($ff00+$97)	; $336e
	push af			; $3370
	ld a,$03		; $3371
	ld ($ff00+$97),a	; $3373
	ld ($2222),a		; $3375
	call $6e0d		; $3378
	pop af			; $337b
	ld ($ff00+$97),a	; $337c
	ld ($2222),a		; $337e
	ret			; $3381

.endif

;;
; TODO: give this a better name
;
; @addr{345b}
updateAllObjects:
	ldh a,(<hRomBank)	; $345b
	push af			; $345d
	callfrombank0 bank5.updateSpecialObjects		; $3465
	callfrombank0 itemCode.updateItems		; $346f
	call          setEnemyTargetToLinkPosition		; $3472
	callfrombank0 updateEnemies		; $347c
	callfrombank0 updateParts		; $3486
	callfrombank0 updateInteractions		; $3490
	callfrombank0 bank1.func_4000		; $349a

	; Call func_410d if Link is riding something
	ld a,:bank5.func_410d		; $349d
	setrombank		; $349f
	ld a,(wLinkObjectIndex)		; $34a4
	rrca			; $34a7
	call c,bank5.func_410d		; $34a8

	ld a,:bank6.updateGrabbedObjectPosition		; $34ab
	setrombank		; $34ad
	ld a,(wLinkGrabState)		; $34b2
	rlca			; $34b5
	call c,bank6.updateGrabbedObjectPosition		; $34b6

	call loadLinkAndCompanionAnimationFrame		; $34b9

	callfrombank0 itemCode.updateItemsPost		; $34c3
	callfrombank0 bank1.checkUpdateFollowingLinkObject		; $34cd
	callfrombank0 updateCamera		; $34d7
	callfrombank0 updateChangedTileQueue		; $34e1
	callfrombank0 updateAnimations		; $34eb

	xor a			; $34ee
	ld (wc4b6),a		; $34ef
	pop af			; $34f2
	setrombank		; $34f3
	ret			; $34f8

;;
; @addr{34f9}
updateSpecialObjectsAndInteractions:
	ldh a,(<hRomBank)	; $34f9
	push af			; $34fb
	callfrombank0 bank5.updateSpecialObjects		; $34fc
	callfrombank0 updateInteractions	; $350d
	call          loadLinkAndCompanionAnimationFrame		; $3510
	xor a			; $3513
	ld (wc4b6),a		; $3514
	pop af			; $3517
	setrombank		; $3518
	ret			; $351d

;;
; @addr{351e}
updateInteractionsAndDrawAllSprites:
	ldh a,(<hRomBank)	; $351e
	push af			; $3520
	callfrombank0 updateInteractions		; $3528
	call drawAllSprites		; $352b
	xor a			; $352e
	ld (wc4b6),a		; $352f
	pop af			; $3532
	setrombank		; $3533
	ret			; $3538

;;
; Similar to updateAllObjects but calls a bit less
;
; @addr{3539}
func_3539:
	ldh a,(<hRomBank)	; $3539
	push af			; $353b
	callfrombank0 bank5.updateSpecialObjects		; $353c
.ifdef ROM_AGES
	callfrombank0 itemCode.updateItems		; $3546
.endif
	callfrombank0 updateEnemies		; $3557
	callfrombank0 updateParts		; $355a
	callfrombank0 updateInteractions		; $356b
.ifdef ROM_AGES
	callfrombank0 itemCode.updateItemsPost		; $356e
	callfrombank0 loadLinkAndCompanionAnimationFrame		; $3578
.endif
	callfrombank0 updateAnimations
	xor a			; $358c
	ld (wc4b6),a		; $358d
	pop af			; $3590
	setrombank		; $3591
	ret			; $3596

.ifdef ROM_SEASONS

;;
seasonsFunc_34a0:
	ld a,($ff00+$97)	; $34a0
	push af			; $34a2
	callfrombank0 $05 $4000		; $34a3
	callfrombank0 $07 $485a		; $34ad
	callfrombank0 updateEnemies		; $34b7
	callfrombank0 $10 $61dc		; $34c1
	callfrombank0 updateInteractions		; $34cb
	callfrombank0 $0f $7159		; $34d5

	ld a,$06		; $34df
	setrombank		; $34e1
	ld a,($cc75)		; $34e6
	rlca			; $34e9
	call c,$5429		; $34ea

	call loadLinkAndCompanionAnimationFrame		; $34ed
	callfrombank0 $07 $4902		; $34f0
	callfrombank0 $0f $7182		; $34fa
	callfrombank0 $04 $6b25		; $3504

	xor a			; $350e
	ld ($c4b6),a		; $350f

	pop af			; $3512
	setrombank		; $3513
	ret			; $3518

.endif

;;
; @addr{3597}
clearWramBank1:
	xor a			; $3597
	ld ($ff00+R_SVBK),a	; $3598
	ld hl,$d000		; $359a
	ld bc,$1000		; $359d
	jp clearMemoryBc		; $35a0

;;
; Clear $30 bytes of ram related to information about the current screen, as
; well as clearing wram bank 1.
; @addr{35a3}
clearScreenVariablesAndWramBank1:
	call clearWramBank1		; $35a3
;;
; @addr{35a6}
clearScreenVariables:
	ld hl,wScreenVariables	; $35a6
	ld b,wScreenVariables.size	; $35a9
	call clearMemory		; $35ab
	ld a,$ff		; $35ae
	ld (wLoadedAreaUniqueGfx),a		; $35b0
	ld (wLoadedAreaTileset),a		; $35b3
	ld (wLoadedAreaAnimation),a		; $35b6
	ret			; $35b9

;;
; @addr{35ba}
clearLinkObject:
	ld hl,w1Link		; $35ba
	ld b,$40		; $35bd
	jp clearMemory		; $35bf

;;
; @addr{35c2}
clearReservedInteraction0:
	ld hl,w1ReservedInteraction0		; $35c2
	ld b,$40		; $35c5
	call clearMemory		; $35c7

;;
; Unused?
;
; @addr{35ca}
clearReservedInteraction1:
	ld hl,w1ReservedInteraction1		; $35ca
	ld b,$40		; $35cd
	jp clearMemory		; $35cf

;;
; Clear all interactions except wReservedInteraction0 and wReservedInteraction1.
;
; @addr{35d2}
clearDynamicInteractions:
	ldde FIRST_DYNAMIC_INTERACTION_INDEX, Interaction.start	; $35d2
--
	ld h,d			; $35d5
.ifdef ROM_AGES
	ld l,e			; $35d6
.else
	ld l,Interaction.start
.endif
	ld b,$40		; $35d7
	call clearMemory		; $35d9
	inc d			; $35dc
	ld a,d			; $35dd
	cp $e0			; $35de
	jr c,--			; $35e0
	ret			; $35e2

;;
; @addr{35e3}
clearItems:
	ldde FIRST_ITEM_INDEX, Item.start	; $35e3
--
	ld h,d			; $35e6
.ifdef ROM_AGES
	ld l,e			; $35e7
.else
	ld l,Item.start
.endif
	ld b,$40		; $35e8
	call clearMemory		; $35ea
	inc d			; $35ed
	ld a,d			; $35ee
	cp $e0			; $35ef
	jr c,--			; $35f1
	ret			; $35f3

;;
; @addr{35f4}
clearEnemies:
	ldde FIRST_ENEMY_INDEX, Enemy.start	; $35f4
--
	ld h,d			; $35f7
.ifdef ROM_AGES
	ld l,e			; $35f8
.else
	ld l,Enemy.start
.endif
	ld b,$40		; $35f9
	call clearMemory		; $35fb
	inc d			; $35fe
	ld a,d			; $35ff
	cp $e0			; $3600
	jr c,--			; $3602
	ret			; $3604

;;
; @addr{3605}
clearParts:
	ldde FIRST_PART_INDEX, Part.start		; $3605
--
	ld h,d			; $3608
.ifdef ROM_AGES
	ld l,e			; $3609
.else
	ld l,Part.start
.endif
	ld b,$40		; $360a
	call clearMemory		; $360c
	inc d			; $360f
	ld a,d			; $3610
	cp $e0			; $3611
	jr c,--			; $3613
	ret			; $3615

;;
; @addr{3616}
setEnemyTargetToLinkPosition:
	ld a,(wLinkObjectIndex)		; $3616
	ld h,a			; $3619
	ld l,<w1Link.yh		; $361a
	ldi a,(hl)		; $361c
	ldh (<hEnemyTargetY),a	; $361d
	inc l			; $361f
	ld a,(hl)		; $3620
	ldh (<hEnemyTargetX),a	; $3621
	ld a,(wScentSeedActive)		; $3623
	or a			; $3626
	ret nz			; $3627

	ld l,<w1Link.yh		; $3628
	ldi a,(hl)		; $362a
	ldh (<hFFB2),a	; $362b
	inc l			; $362d
	ld a,(hl)		; $362e
	ldh (<hFFB3),a	; $362f
	ret			; $3631

;;
; @addr{3632}
getEntryFromObjectTable2:

.ifdef ROM_AGES
	ldh a,(<hRomBank)	; $3632
	push af			; $3634
	ld a, :objectData.objectTable2
	setrombank		; $3637
	ld a,b			; $363c
	ld hl, objectData.objectTable2
	rst_addDoubleIndex			; $3640
	ldi a,(hl)		; $3641
	ld h,(hl)		; $3642
	ld l,a			; $3643
	pop af			; $3644
	setrombank		; $3645
	ret			; $364a

.else ; ROM_SEASONS

seasonsFunc_35b8:
	ld a,($ff00+$97)	; $35b8
	push af			; $35ba
	ld a,$03		; $35bb
	ld ($ff00+$97),a	; $35bd
	ld ($2222),a		; $35bf
	call $72ff		; $35c2
	pop af			; $35c5
	ld ($ff00+$97),a	; $35c6
	ld ($2222),a		; $35c8
	ret			; $35cb

.endif


.ifdef ROM_AGES

;;
; Check if a dungeon uses those toggle blocks with the orbs.
;
; @param[out]	z	Set if the dungeon does not use toggle blocks.
; @addr{364b}
checkDungeonUsesToggleBlocks:
	ld a,(wDungeonIndex)		; $364b
	cp $ff			; $364e
	ret z			; $3650

	ld hl,dungeonsUsingToggleBlocks		; $3651
	jp checkFlag		; $3654

	.include "data/dungeonsUsingToggleBlocks.s"

.else ; ROM_SEASONS

	ld a,($ff00+$70)	; $35cc
	ld c,a			; $35ce
	ld a,($ff00+$97)	; $35cf
	ld b,a			; $35d1
	push bc			; $35d2
	ld a,$02		; $35d3
	ld ($ff00+$70),a	; $35d5
	ld a,$01		; $35d7
	ld ($ff00+$97),a	; $35d9
	ld ($2222),a		; $35db
	call $5683		; $35de
	pop bc			; $35e1
	ld a,b			; $35e2
	ld ($ff00+$97),a	; $35e3
	ld ($2222),a		; $35e5
	ld a,c			; $35e8
	ld ($ff00+$70),a	; $35e9
	ret			; $35eb

	ld a,($ff00+$97)	; $35ec
	push af			; $35ee
	ld a,$01		; $35ef
	ld ($ff00+$97),a	; $35f1
	ld ($2222),a		; $35f3
	call $565d		; $35f6
	pop af			; $35f9
	ld ($ff00+$97),a	; $35fa
	ld ($2222),a		; $35fc
	ret			; $35ff

; Placeholder
checkDungeonUsesToggleBlocks:

.endif

;;
; Load data into wAnimationState, wAnimationPointerX, etc.
;
; @param	a	Value of wAreaAnimation
; @addr{3659}
loadAnimationData:
	ld b,a			; $3659
	ldh a,(<hRomBank)	; $365a
	push af			; $365c
	ld a,:animationGroupTable
	setrombank		; $365f
	ld a,b			; $3664
	ld hl,animationGroupTable		; $3665
	rst_addDoubleIndex			; $3668
	ldi a,(hl)		; $3669
	ld h,(hl)		; $366a
	ld l,a			; $366b
	ldi a,(hl)		; $366c
	ld (wAnimationState),a		; $366d
	push de			; $3670
	ld de,wAnimationCounter1		; $3671
	call @helper		; $3674
	ld de,wAnimationCounter2		; $3677
	call @helper		; $367a
	ld de,wAnimationCounter3		; $367d
	call @helper		; $3680
	ld de,wAnimationCounter4		; $3683
	call @helper		; $3686
	pop de			; $3689
	pop af			; $368a
	setrombank		; $368b
	xor a			; $3690
	ld (wAnimationQueueHead),a		; $3691
	ld (wAnimationQueueTail),a		; $3694
	ret			; $3697

;;
; @addr{3698}
@helper:
	push hl			; $3698
	ldi a,(hl)		; $3699
	ld h,(hl)		; $369a
	ld l,a			; $369b
	ldi a,(hl)		; $369c
	ld (de),a		; $369d
	inc de			; $369e
	ld a,l			; $369f
	ld (de),a		; $36a0
	inc de			; $36a1
	ld a,h			; $36a2
	ld (de),a		; $36a3
	pop hl			; $36a4
	inc hl			; $36a5
	inc hl			; $36a6
	ret			; $36a7


.ifdef ROM_SEASONS

seasonsFunc_364f:
	ld a,($ff00+$97)	; $364f
	push af			; $3651
	ld a,$09		; $3652
	ld ($ff00+$97),a	; $3654
	ld ($2222),a		; $3656
	call $53f0		; $3659
	pop af			; $365c
	ld ($ff00+$97),a	; $365d
	ld ($2222),a		; $365f
	ret			; $3662

.endif

;;
; See the comments for bank2.getIndexOfGashaSpotInRoom_body.
;
; @param	a	Room
; @param[out]	c	Bit 7 set if something is planted in the given room.
;			(This is the value of the 'f' register after the function call.)
; @addr{36a8}
getIndexOfGashaSpotInRoom:
	ld c,a			; $36a8
	ldh a,(<hRomBank)	; $36a9
	push af			; $36ab

	ld a,:bank2.getIndexOfGashaSpotInRoom_body		; $36ac
	setrombank		; $36ae
	ld a,c			; $36b3
	call bank2.getIndexOfGashaSpotInRoom_body		; $36b4

	push af			; $36b7
	pop bc			; $36b8
	pop af			; $36b9
	setrombank		; $36ba
	ret			; $36bf


.ifdef ROM_AGES

;;
; The name is a bit of a guess.
;
; Returns 2 if an event is triggered in part of the forest (map $90?), 1 if the maku
; tree has spoken to you outside d3, 0 otherwise.
;
; @param[out]	a	Black tower progress (0-2)
; @param[out]	zflag	z if black tower is still in early stages (npcs hanging around)
; @addr{36c0}
getBlackTowerProgress:
	push bc			; $36c0
	ld c,$02		; $36c1
	ld a,(wPresentRoomFlags+$90)		; $36c3
	bit ROOMFLAG_BIT_40,a			; $36c6
	jr nz,++		; $36c8

	dec c			; $36ca
	ld a,(wPresentRoomFlags+$ba)		; $36cb
	bit ROOMFLAG_BIT_40,a			; $36ce
	jr nz,++		; $36d0

	dec c			; $36d2
++
	ld a,c			; $36d3
	pop bc			; $36d4
	ret			; $36d5

.else ; ROM_SEASONS

; Placeholder
getBlackTowerProgress:

.endif

; A table of addresses in vram. The index is a row (of 16 pixels), and the corresponding
; value is the address of the start of that row.
; @addr{36d6}
vramBgMapTable:
	.dw $9800 $9840 $9880 $98c0
	.dw $9900 $9940 $9980 $99c0
	.dw $9a00 $9a40 $9a80 $9ac0
	.dw $9b00 $9b40 $9b80 $9bc0

;;
; Force-load a room?
;
; @param	a	Value for wRoomStateModifier (only lower 2 bits are used)
; @param	b	Value for wActiveGroup
; @param	c	Value for wActiveRoom
; @addr{36f6}
func_36f6:
	and $03			; $36f6
	ld (wRoomStateModifier),a		; $36f8
	ld a,b			; $36fb
	ld (wActiveGroup),a		; $36fc
	ld a,c			; $36ff
	ld (wActiveRoom),a		; $3700
	call loadScreenMusicAndSetRoomPack		; $3703
	call loadAreaData		; $3706
	call loadAreaGraphics		; $3709
	call loadTilesetAndRoomLayout		; $370c
	jp generateVramTilesWithRoomChanges		; $370f

;;
; Loads the tileset (assumes wAreaTileset is already set to the desired value).
;
; End result: w3TileMappingData is loaded with the tile indices and attributes for all
; tiles in the tileset.
;
; @addr{3712}
loadAreaTileset:
	ld a,(wAreaTileset)		; $3712
	call loadTileset		; $3715
	ld a,:tileMappingTable
	setrombank		; $371a

	ld a,:w3TileMappingData
	ld ($ff00+R_SVBK),a	; $3721
	ld hl,w3TileMappingIndices
	ld de,w3TileMappingData
	ld b,$00		; $3729
-
	push bc			; $372b
	call @helper		; $372c
	pop bc			; $372f
	dec b			; $3730
	jr nz,-

.ifdef ROM_SEASONS
	xor a
	ld ($ff00+R_SVBK),a
	ret

.else ; ROM_AGES
	jpab func_04_6e63		; $3733
.endif

;;
; @addr{373b}
@helper:
	; bc = tile mapping index
	ldi a,(hl)		; $373b
	ld c,a			; $373c
	ldi a,(hl)		; $373d
	ld b,a			; $373e

	; Get address of pointers to tile indices / attributes
	push hl			; $373f
	ld hl, tileMappingTable
	add hl,bc		; $3743
	add hl,bc		; $3744
	add hl,bc		; $3745

	; Load tile indices
	ldi a,(hl)		; $3746
	ld c,a			; $3747
	ld a,(hl)		; $3748
	swap a			; $3749
	and $0f			; $374b
	ld b,a			; $374d
	push hl			; $374e
	ld hl,tileMappingIndexDataPointer
	ldi a,(hl)		; $3752
	ld h,(hl)		; $3753
	ld l,a			; $3754
	add hl,bc		; $3755
	add hl,bc		; $3756
	add hl,bc		; $3757
	add hl,bc		; $3758
	ld b,$04		; $3759
	call copyMemory		; $375b

	; Load tile attributes
	pop hl			; $375e
	ldi a,(hl)		; $375f
	and $0f			; $3760
	ld b,a			; $3762
	ld c,(hl)		; $3763
	ld hl,tileMappingAttributeDataPointer
	ldi a,(hl)		; $3767
	ld h,(hl)		; $3768
	ld l,a			; $3769
	add hl,bc		; $376a
	add hl,bc		; $376b
	add hl,bc		; $376c
	add hl,bc		; $376d
	ld b,$04		; $376e
	call copyMemory		; $3770

	pop hl			; $3773
	ret			; $3774


;;
; Loads the address of unique header gfx (a&$7f) into wUniqueGfxHeaderAddress.
;
; @param	a	Unique gfx header (see constants/uniqueGfxHeaders.s).
;			Bit 7 is ignored.
; @addr{3775}
loadUniqueGfxHeader:
	and $7f			; $3775
	ld b,a			; $3777
	ldh a,(<hRomBank)	; $3778
	push af			; $377a
	ld a,:uniqueGfxHeaderTable	; $377b
	setrombank		; $377d
	ld a,b			; $3782
	ld hl,uniqueGfxHeaderTable		; $3783
	rst_addDoubleIndex			; $3786
	ldi a,(hl)		; $3787
	ld (wUniqueGfxHeaderAddress),a		; $3788
	ld a,(hl)		; $378b
	ld (wUniqueGfxHeaderAddress+1),a		; $378c
	pop af			; $378f
	setrombank		; $3790
	ret			; $3795

;;
; Load all graphics based on wArea variables.
;
; @addr{3796}
loadAreaGraphics:
	ldh a,(<hRomBank)	; $3796
	push af			; $3798

	ld a,(wAreaGfx)		; $3799
	call loadGfxHeader		; $379c
	ld a,(wAreaPalette)		; $379f
	call loadPaletteHeader		; $37a2

	call          loadAreaUniqueGfx		; $37a5
	callfrombank0 initializeAnimations	; $37a8

.ifdef ROM_AGES
	callab        bank2.func_02_7a77		; $37b2
	callab        bank2.checkLoadPastSignAndChestGfx		; $37ba
.endif

	ld a,(wAreaUniqueGfx)		; $37c2
	ld (wLoadedAreaUniqueGfx),a		; $37c5
	ld a,(wAreaPalette)		; $37c8
	ld (wLoadedAreaPalette),a		; $37cb
	ld a,(wAreaAnimation)		; $37ce
	ld (wLoadedAreaAnimation),a		; $37d1

	pop af			; $37d4
	setrombank		; $37d5
	ret			; $37da

;;
; Loads one entry from the gfx header if [wAreaUniqueGfx] != [wLoadedAreaUniqueGfx].
;
; This should be called repeatedly (once per frame, to avoid overloading vblank) until all
; entries in the header are read.
;
; @param	wUniqueGfxHeaderAddress	Where to read the header from (will be updated)
; @param[out]	cflag			Set if there are more entries to load.
; @addr{37db}
updateAreaUniqueGfx:
	ld a,(wAreaUniqueGfx)		; $37db
	or a			; $37de
	ret z			; $37df

	ld b,a			; $37e0
	ld a,(wLoadedAreaUniqueGfx)		; $37e1
	cp b			; $37e4
	ret z			; $37e5

	ldh a,(<hRomBank)	; $37e6
	push af			; $37e8

	ld hl,wUniqueGfxHeaderAddress		; $37e9
	ldi a,(hl)		; $37ec
	ld h,(hl)		; $37ed
	ld l,a			; $37ee
	ld a,:uniqueGfxHeadersStart
	setrombank		; $37f1
	call loadUniqueGfxHeaderEntry		; $37f6
	ld c,a			; $37f9
	ld a,l			; $37fa
	ld (wUniqueGfxHeaderAddress),a		; $37fb
	ld a,h			; $37fe
	ld (wUniqueGfxHeaderAddress+1),a		; $37ff

	pop af			; $3802
	setrombank		; $3803
	ld a,c			; $3808
	add a			; $3809
	ret			; $380a

;;
; Load just the first entry of a unique gfx header?
;
; Unused?
;
; @param	a	Unique gfx header index
; @addr{380b}
uniqueGfxFunc_380b:
	ld b,a			; $380b
	ldh a,(<hRomBank)	; $380c
	push af			; $380e

	ld a,:uniqueGfxHeadersStart
	setrombank		; $3811
	ld a,b			; $3816
	ld hl,uniqueGfxHeaderTable		; $3817
	rst_addDoubleIndex			; $381a
	ldi a,(hl)		; $381b
	ld h,(hl)		; $381c
	ld l,a			; $381d
	call loadUniqueGfxHeaderEntry		; $381e

	pop af			; $3821
	setrombank		; $3822
	ret			; $3827

;;
; @addr{3828}
loadAreaUniqueGfx:
	ld a,:uniqueGfxHeaderTable	; $3828
	setrombank		; $382a
	ld a,(wAreaUniqueGfx)		; $382f
	and $7f			; $3832
	ret z			; $3834

	ld hl,uniqueGfxHeaderTable		; $3835
	rst_addDoubleIndex			; $3838
	ldi a,(hl)		; $3839
	ld h,(hl)		; $383a
	ld l,a			; $383b
-
	call loadUniqueGfxHeaderEntry		; $383c
	add a			; $383f
	jr c,-
	ret			; $3842

;;
; Loads a single gfx header entry at hl. This should be called multiple times until all
; entries are read.
;
; If the first byte (bank+mode) is zero, it loads a palette instead.
;
; @param[out]	a	Last byte of the entry (bit 7 set if there's another entry)
; @addr{3843}
loadUniqueGfxHeaderEntry:
	ldi a,(hl)		; $3843
	or a			; $3844
	jr z,@loadPaletteIndex

	ld c,a			; $3847
	ldh (<hFF8C),a	; $3848
	ldi a,(hl)		; $384a
	ld b,a			; $384b
	ldi a,(hl)		; $384c
	ld c,a			; $384d
	ldi a,(hl)		; $384e
	ld d,a			; $384f
	ldi a,(hl)		; $3850
	ld e,a			; $3851
	ld a,(hl)		; $3852
	and $7f			; $3853
	ldh (<hFF8D),a	; $3855
	push hl			; $3857
	push de			; $3858
	ld l,c			; $3859
	ld h,b			; $385a
	ld b,a			; $385b
	ldh a,(<hFF8C)	; $385c
	ld c,a			; $385e
	ld de,$d807		; $385f
	call decompressGraphics		; $3862
	pop de			; $3865
	ld hl,$d800		; $3866
	ld c,$07		; $3869
	ldh a,(<hFF8D)	; $386b
	ld b,a			; $386d
	call queueDmaTransfer		; $386e
	pop hl			; $3871
	ld a,$00		; $3872
	ld ($ff00+R_SVBK),a	; $3874
	ld a,:uniqueGfxHeaderTable	; $3876
	setrombank		; $3878
	ldi a,(hl)		; $387d
	ret			; $387e

@loadPaletteIndex:
	push hl			; $387f
	ld a,(hl)		; $3880
	and $7f			; $3881
	call loadPaletteHeader		; $3883
	pop hl			; $3886
	ldi a,(hl)		; $3887
	ret			; $3888

;;
; @addr{3889}
loadAreaData:
	ldh a,(<hRomBank)	; $3889
	push af			; $388b

	callfrombank0 loadAreaData_body
	callab        bank2.updateAreaFlagsForIndoorRoomInAltWorld		; $3896

	pop af			; $389e
	setrombank		; $389f
	ret			; $38a4

;;
; @addr{38a5}
loadTilesetAndRoomLayout:
	ldh a,(<hRomBank)	; $38a5
	push af			; $38a7

	; Reload tileset if necessary
	ld a,(wLoadedAreaTileset)		; $38a8
	ld b,a			; $38ab
	ld a,(wAreaTileset)		; $38ac
	cp b			; $38af
	ld (wLoadedAreaTileset),a		; $38b0
	call nz,loadAreaTileset		; $38b3

.ifdef ROM_SEASONS
	call seasonsFunc_3870
.endif
	; Load the room layout and apply any dynamic changes necessary
	call          loadRoomLayout		; $38b6

	callfrombank0 applyAllTileSubstitutions		; $38b9

	; Copy wRoomLayout to w3RoomLayoutBuffer
	ld a,:w3RoomLayoutBuffer		; $38c3
	ld ($ff00+R_SVBK),a	; $38c5
	ld hl,w3RoomLayoutBuffer		; $38c7
	ld de,wRoomLayout		; $38ca
	ld b,_sizeof_wRoomLayout		; $38cd
	call copyMemoryReverse		; $38cf

	xor a			; $38d2
	ld ($ff00+R_SVBK),a	; $38d3
	pop af			; $38d5
	setrombank		; $38d6
	ret			; $38db

.ifdef ROM_SEASONS

seasonsFunc_3870:
	ld a,GLOBALFLAG_S_15		; $3870
	call checkGlobalFlag		; $3872
	ret z			; $3875
	callfrombank0 $04 $6cff		; $3876
	ret nc			; $3880
	ld a,($cc4e)		; $3881
	ld hl,@data		; $3884
	rst $10			; $3887
	ld a,($cc4c)		; $3888
	add (hl)		; $388b
	ld ($cc4b),a		; $388c
	ret			; $388f

@data:
	.db $bc $c0 $c4 $c8

.endif


;;
; Load room layout into wRoomLayout using the relevant RAM addresses (wAreaLayoutGroup,
; wLoadingRoom, etc)
;
; @addr{38dc}
loadRoomLayout:
	ld hl,wRoomLayout		; $38dc
	ld b,(LARGE_ROOM_HEIGHT+1)*16		; $38df
	call clearMemory		; $38e1
	ld a,:roomLayoutGroupTable
	setrombank		; $38e6
	ld a,(wAreaLayoutGroup)		; $38eb
	add a			; $38ee
	add a			; $38ef
	ld hl,roomLayoutGroupTable
	rst_addDoubleIndex			; $38f3
	ldi a,(hl)		; $38f4
	ld b,a			; $38f5
	ldi a,(hl)		; $38f6
	ldh (<hFF8D),a	; $38f7
	ldi a,(hl)		; $38f9
	ldh (<hFF8E),a	; $38fa
	ldi a,(hl)		; $38fc
	ldh (<hFF8F),a	; $38fd
	ldi a,(hl)		; $38ff
	ldh (<hFF8C),a	; $3900
	ldi a,(hl)		; $3902
	ld h,(hl)		; $3903
	ld l,a			; $3904
	ldh a,(<hFF8C)	; $3905
	setrombank		; $3907
	push hl			; $390c
	ld a,b			; $390d
	rst_jumpTable			; $390e
	.dw @loadLargeRoomLayout
	.dw @loadSmallRoomLayout

;;
; @addr{3913}
@loadLargeRoomLayoutHlpr:
	ld d,b			; $3913
	ld a,b			; $3914
	and $0f			; $3915
	ld b,a			; $3917

	; Get relative offset in hl
	ldh a,(<hFF8F)	; $3918
	ld h,a			; $391a
	ldh a,(<hFF8E)	; $391b
	ld l,a			; $391d

	add hl,bc		; $391e
	ld a,d			; $391f
	swap a			; $3920
	and $0f			; $3922
	add $03			; $3924
	ld b,a			; $3926
	ret			; $3927

;;
; @addr{3928}
@loadLargeRoomLayout:
	ldh a,(<hFF8F)	; $3928
	ld h,a			; $392a
	ldh a,(<hFF8E)	; $392b
	ld l,a			; $392d
	ld bc,$1000		; $392e
	add hl,bc		; $3931
	ldh a,(<hFF8D)	; $3932
	setrombank		; $3934

	ld a,(wLoadingRoom)		; $3939
	rst_addDoubleIndex			; $393c
	ldi a,(hl)		; $393d
	ld h,(hl)		; $393e
	ld l,a			; $393f

	pop bc			; $3940
	add hl,bc		; $3941
	ld bc,-$200		; $3942
	add hl,bc		; $3945
	call @loadLayoutData		; $3946
	ld de,wRoomLayout		; $3949
@next8:
	ldi a,(hl)		; $394c
	ld b,$08		; $394d
@next:
	rrca			; $394f
	ldh (<hFF8B),a	; $3950
	jr c,+
	ldi a,(hl)		; $3954
	ld (de),a		; $3955
	inc e			; $3956
	ld a,e			; $3957
	cp LARGE_ROOM_HEIGHT*16			; $3958
	ret z			; $395a
--
	ldh a,(<hFF8B)	; $395b
	dec b			; $395d
	jr nz,@next
	jr @next8
+
	push bc			; $3962
	ldi a,(hl)		; $3963
	ld c,a			; $3964
	ldi a,(hl)		; $3965
	ld b,a			; $3966
	push hl			; $3967
	call @loadLargeRoomLayoutHlpr		; $3968
	ld d,>wRoomLayout		; $396b
	ldh a,(<hFF8D) ; Relative offset bank number
	setrombank		; $396f
-
	ldi a,(hl)		; $3974
	ld (de),a		; $3975
	inc e			; $3976
	ld a,e			; $3977
	cp LARGE_ROOM_HEIGHT*16			; $3978
	jr z,+
	dec b			; $397c
	jr nz,-
	pop hl			; $397f
	pop bc			; $3980
	jr --
+
	pop hl			; $3983
	pop bc			; $3984
	ret			; $3985

;;
; @addr{3986}
@loadSmallRoomLayout:
	ldh a,(<hFF8D)	; $3986
	setrombank		; $3988
	ldh a,(<hFF8E)	; $398d
	ld l,a			; $398f
	ldh a,(<hFF8F)	; $3990
	ld h,a			; $3992
	ld a,(wLoadingRoom)		; $3993
	rst_addDoubleIndex			; $3996

	; Get relative offset of layout data in hl
	ldi a,(hl)		; $3997
	ld c,a			; $3998
	ld a,(hl)		; $3999
	ld e,a			; $399a
	and $3f			; $399b
	ld b,a			; $399d

	; Add relative offset with base offset
	pop hl			; $399e
	add hl,bc		; $399f
	call @loadLayoutData		; $39a0

	; Upper bits of relative offset specify compression
	bit 7,e			; $39a3
	jr nz,@decompressLayoutMode2	; $39a5
	bit 6,e			; $39a7
	jr nz,@decompressLayoutMode1

	; Uncompressed; just copy to wRoomLayout unmodified
	ld de,wRoomLayout		; $39ab
	ldbc SMALL_ROOM_WIDTH, SMALL_ROOM_HEIGHT		; $39ae
--
	push bc			; $39b1
-
	ldi a,(hl)		; $39b2
	ld (de),a		; $39b3
	inc e			; $39b4
	dec b			; $39b5
	jr nz,-

	ld a,e			; $39b8
	add $10-SMALL_ROOM_WIDTH			; $39b9
	ld e,a			; $39bb
	pop bc			; $39bc
	dec c			; $39bd
	jr nz,--
	ret			; $39c0

;;
; @addr{39c1}
@decompressLayoutMode2:
	ld de,wRoomLayout		; $39c1
	ld a,(SMALL_ROOM_WIDTH*SMALL_ROOM_HEIGHT)/16		; $39c4
-
	push af			; $39c6
	call @decompressLayoutMode2Helper		; $39c7
	pop af			; $39ca
	dec a			; $39cb
	jr nz,-
	ret			; $39ce

;;
; Decompresses layout to wRoomLayout.
;
; Format: word where each bit means "repeat" or "don't repeat"; byte to repeat; remaining data
;
; @addr{39cf}
@decompressLayoutMode2Helper:
	ldi a,(hl)		; $39cf
	ld c,a			; $39d0
	ldi a,(hl)		; $39d1
	ldh (<hFF8A),a	; $39d2
	or c			; $39d4
	ld b,$10		; $39d5
	jr z,@layoutCopyBytes	; $39d7
	ldi a,(hl)		; $39d9
	ldh (<hFF8B),a	; $39da
	call @decompressLayoutHelper		; $39dc
	ldh a,(<hFF8A)	; $39df
	ld c,a			; $39e1
	jr @decompressLayoutHelper		; $39e2

;;
; @addr{39e7}
@decompressLayoutMode1:
	ld de,wRoomLayout
	ld a,(SMALL_ROOM_WIDTH*SMALL_ROOM_HEIGHT)/8		; $39e7
-
	push af			; $39e9
	call @decompressLayoutMode1Helper		; $39ea
	pop af			; $39ed
	dec a			; $39ee
	jr nz,-
	ret			; $39f1

;;
; @addr{39f2}
@decompressLayoutMode1Helper:
	ldi a,(hl)		; $39f2
	ld c,a			; $39f3
	or a			; $39f4
	ld b,$08		; $39f5
	jr z,@layoutCopyBytes	; $39f7
	ldi a,(hl)		; $39f9
	ldh (<hFF8B),a	; $39fa
	jr @decompressLayoutHelper		; $39fc

;;
; Copy b bytes to wRoomLayout, while keeping de in bounds
;
; @addr{39fe}
@layoutCopyBytes:
	ldi a,(hl)		; $39fe
	ld (de),a		; $39ff
	inc e			; $3a00
	call @checkDeNextLayoutRow		; $3a01
	dec b			; $3a04
	jr nz,@layoutCopyBytes	; $3a05
	ret			; $3a07

;;
; @addr{3a08}
@checkDeNextLayoutRow:
	ld a,e			; $3a08
	and $0f			; $3a09
	cp SMALL_ROOM_WIDTH			; $3a0b
	ret c			; $3a0d
	ld a,$10-SMALL_ROOM_WIDTH		; $3a0e
	add e			; $3a10
	ld e,a			; $3a11
	ret			; $3a12

;;
; @addr{3a13}
@decompressLayoutHelper:
	ld b,$08		; $3a13
--
	srl c			; $3a15
	jr c,+
	ldi a,(hl)		; $3a19
	jr ++
+
	ldh a,(<hFF8B)	; $3a1c
++
	ld (de),a		; $3a1e
	inc e			; $3a1f
	call @checkDeNextLayoutRow		; $3a20
	dec b			; $3a23
	jr nz,--
	ret			; $3a26

;;
; Load the compressed layout data into wRoomCollisions (temporarily)
; @addr{3a27}
@loadLayoutData:
	push de			; $3a27
	ldh a,(<hFF8C)	; $3a28
.ifdef ROM_AGES
	ld e,a			; $3a2a
.endif
-
	bit 7,h			; $3a2b
	jr z,+
	ld a,h			; $3a2f
.ifdef ROM_AGES
	sub $40			; $3a30
.else
	xor $c0
.endif
	ld h,a			; $3a32

.ifdef ROM_SEASONS
	ldh a,(<hFF8C)
	inc a
	ldh (<hFF8C),a
.else
	inc e			; $3a33
	jr -
+
	ld a,e			; $3a36
.endif
+
	setrombank		; $3a37
	ld b,LARGE_ROOM_HEIGHT*16		; $3a3c
	ld de,wRoomCollisions		; $3a3e
-
	call readByteSequential		; $3a41
	ld (de),a		; $3a44
	inc e			; $3a45
	dec b			; $3a46
	jr nz,-

	ld hl,wRoomCollisions		; $3a49
	pop de			; $3a4c
	ret			; $3a4d


;;
; Generates w3VramTiles and w3VramAttributes, and calls the function for room-specific
; changes to them.
;
; @addr{3a4e}
generateVramTilesWithRoomChanges:
	ld a,($ff00+R_SVBK)	; $3a4e
	ld c,a			; $3a50
	ldh a,(<hRomBank)	; $3a51
	ld b,a			; $3a53
	push bc			; $3a54

	callfrombank0 generateW3VramTilesAndAttributes		; $3a55
.ifdef ROM_AGES
	callab        bank2.applyRoomSpecificTileChangesAfterGfxLoad		; $3a5f
.else
	call        applyRoomSpecificTileChangesAfterGfxLoad
.endif

	pop bc			; $3a67
	ld a,b			; $3a68
	setrombank		; $3a69
	ld a,c			; $3a6e
	ld ($ff00+R_SVBK),a	; $3a6f
	ret			; $3a71

;;
; Gets the mapping data for a tile (the values to form the 2x2 tile).
;
; Tile indices go to $cec0-$cec3, and flag values go to $cec4-$cec7.
;
; @param	a	Tile to get mapping data for
; @param[out]	b	Top-left flag value
; @param[out]	c	Top-left tile index
; @addr{3a72}
getTileMappingData:
	ld c,a			; $3a72
	ld a,($ff00+R_SVBK)	; $3a73
	push af			; $3a75

	ld a,:w3TileMappingData		; $3a76
	ld ($ff00+R_SVBK),a	; $3a78

	ld a,c			; $3a7a
	call setHlToTileMappingDataPlusATimes8		; $3a7b

	push de			; $3a7e
	ld de,wTmpcec0		; $3a7f
	ld b,$08		; $3a82

.ifdef ROM_AGES
	call copyMemory		; $3a84
.else
--
	ldi a,(hl)
	ld (de),a
	inc e
	dec b
	jr nz,--
.endif

	pop de			; $3a87
	ld a,($cec4)		; $3a88
	ld b,a			; $3a8b
	ld a,(wTmpcec0)		; $3a8c
	ld c,a			; $3a8f
	pop af			; $3a90
	ld ($ff00+R_SVBK),a	; $3a91
	ret			; $3a93

;;
; @addr{3a94}
setHlToTileMappingDataPlusATimes8:
	call multiplyABy8		; $3a94
	ld hl,w3TileMappingData		; $3a97
	add hl,bc		; $3a9a
	ret			; $3a9b

;;
; Sets tile 'c' to the value of 'a'.
;
; @param	a	New tile index
; @param	c	Position of tile to change
; @param[out]	zflag	Set on failure (w2ChangedTileQueue is full)
; @addr{3a9c}
setTile:
	ld b,a			; $3a9c
	ld a,(wChangedTileQueueTail)		; $3a9d
	inc a			; $3aa0
	and $1f			; $3aa1
	ld e,a			; $3aa3

	; Return if w2ChangedTileQueue is full
	ld a,(wChangedTileQueueHead)		; $3aa4
	cp e			; $3aa7
	ret z			; $3aa8

	; Tail of the queue gets incremented
	ld a,e			; $3aa9
	ld (wChangedTileQueueTail),a		; $3aaa

	ld a,($ff00+R_SVBK)	; $3aad
	push af			; $3aaf
	ld a,:w2ChangedTileQueue		; $3ab0
	ld ($ff00+R_SVBK),a	; $3ab2

	; Populate the new entry for the queue
	ld a,e			; $3ab4
	add a			; $3ab5
	ld hl,w2ChangedTileQueue		; $3ab6
	rst_addAToHl			; $3ab9
	ld (hl),b		; $3aba
	inc l			; $3abb
	ld (hl),c		; $3abc

	; This will update wRoomLayout and wRoomCollisions
	ld a,b			; $3abd
	call setTileWithoutGfxReload		; $3abe

	pop af			; $3ac1
	ld ($ff00+R_SVBK),a	; $3ac2
	or h			; $3ac4
	ret			; $3ac5

;;
; Calls "setTile" and "setTileInRoomLayoutBuffer".
;
; @param	a	New tile index
; @param	c	Position of tile to change
; @addr{3ac6}
setTileInAllBuffers:

.ifdef ROM_AGES
	ld e,a			; $3ac6
	ld b,a			; $3ac7
	call setTileInRoomLayoutBuffer		; $3ac8
	ld a,e			; $3acb
	jp setTile		; $3acc
.endif

;;
; Mixes two tiles together by using some subtiles from one, and some subtiles from the
; other. Used for example by shutter doors, which would combine the door and floor tiles
; for the partway-closed part of the animation.
;
; Tile 2 uses its tiles from the same "half" that tile 1 uses. For example, if tile 1 was
; placed on the right side, both tiles would use the right halves of their subtiles.
;
; @param	a	0: Top is tile 2, bottom is tile 1
;			1: Left is tile 1, right is tile 2
;			2: Top is tile 1, bottom is tile 2
;			3: Left is tile 2, right is tile 1
; @param	hFF8C	Position of tile to change
; @param	hFF8F	Tile index 1
; @param	hFF8E	Tile index 2
; @addr{3acf}
setInterleavedTile:
	push de			; $3acf
	ld e,a			; $3ad0
	ld a,($ff00+R_SVBK)	; $3ad1
	ld c,a			; $3ad3
	ldh a,(<hRomBank)	; $3ad4
	ld b,a			; $3ad6
	push bc			; $3ad7

	ld a,:setInterleavedTile_body		; $3ad8
	setrombank		; $3ada
	ld a,e			; $3adf
	call setInterleavedTile_body		; $3ae0

	pop bc			; $3ae3
	ld a,b			; $3ae4
	setrombank		; $3ae5
	ld a,c			; $3aea
	ld ($ff00+R_SVBK),a	; $3aeb
	pop de			; $3aed
	ret			; $3aee

.ifdef ROM_SEASONS

seasonsFunc_3a9c:
	ld b,a			; $3a9c
	ld a,($cc49)		; $3a9d
	or a			; $3aa0
	ret nz			; $3aa1
	ld a,($cc4d)		; $3aa2
	cp $f1			; $3aa5
	ret nc			; $3aa7
	ld a,b			; $3aa8
	ld ($cc4e),a		; $3aa9
	ld a,$02		; $3aac
	ld ($cc68),a		; $3aae
	ret			; $3ab1

seasonsFunc_3ab2:
	ld a,($ff00+$97)	; $3ab2
	push af			; $3ab4
	callfrombank0 bank1.seasonsFunc_7e6e		; $3ab5
	pop af			; $3abf
	ld ($ff00+$97),a	; $3ac0
	ld ($2222),a		; $3ac2
	ret			; $3ac5

.endif

;;
; @param[out]	hl	Address of a free interaction slot (on the id byte)
; @param[out]	zflag	Set if a free slot was found
; @addr{3aef}
getFreeInteractionSlot:
	ld hl,FIRST_DYNAMIC_INTERACTION_INDEX<<8 | $40		; $3aef
--
	ld a,(hl)		; $3af2
	or a			; $3af3
	jr z,++

	inc h			; $3af6
	ld a,h			; $3af7
	cp $e0			; $3af8
	jr c,--

	or h			; $3afc
	ret			; $3afd
++
	inc (hl)		; $3afe
	inc l			; $3aff
	xor a			; $3b00
	ret			; $3b01


;;
; @addr{3b02}
interactionDeleteAndUnmarkSolidPosition:

.ifdef ROM_AGES
	call objectUnmarkSolidPosition		; $3b02
.endif

;;
; @addr{3b05}
interactionDelete:
	ld h,d			; $3b05
	ld l,Interaction.start		; $3b06
	ld b,$10		; $3b08
	xor a			; $3b0a
-
	ldi (hl),a		; $3b0b
	ldi (hl),a		; $3b0c
	ldi (hl),a		; $3b0d
	ldi (hl),a		; $3b0e
	dec b			; $3b0f
	jr nz,-
	ret			; $3b12

;;
; @addr{3b13}
_updateInteractionsIfStateIsZero:
	ld a,Interaction.start		; $3b13
	ldh (<hActiveObjectType),a	; $3b15
	ld a,FIRST_INTERACTION_INDEX		; $3b17
--
	ldh (<hActiveObject),a	; $3b19
	ld d,a			; $3b1b
	ld e,Interaction.enabled		; $3b1c
	ld a,(de)		; $3b1e
	or a			; $3b1f
	jr z,@next		; $3b20

	rlca			; $3b22
	jr c,+			; $3b23

	ld e,Interaction.state	; $3b25
	ld a,(de)		; $3b27
	or a			; $3b28
	jr nz,@next		; $3b29
+
	call updateInteraction		; $3b2b
@next:
	ldh a,(<hActiveObject)	; $3b2e
	inc a			; $3b30
	cp LAST_INTERACTION_INDEX+1			; $3b31
	jr c,--			; $3b33
	ret			; $3b35

;;
; @addr{3b36}
updateInteractions:
	ld a,(wScrollMode)		; $3b36
	cp $08			; $3b39
	jr z,_updateInteractionsIfStateIsZero		; $3b3b

	ld a,(wDisabledObjects)		; $3b3d
	and $02			; $3b40
	jr nz,_updateInteractionsIfStateIsZero		; $3b42

	ld a,(wTextIsActive)		; $3b44
	or a			; $3b47
	jr nz,_updateInteractionsIfStateIsZero		; $3b48

	ld a,Interaction.start		; $3b4a
	ldh (<hActiveObjectType),a	; $3b4c
	ld a,FIRST_INTERACTION_INDEX		; $3b4e
@next:
	ldh (<hActiveObject),a	; $3b50
	ld d,a			; $3b52
	ld e,Interaction.enabled		; $3b53
	ld a,(de)		; $3b55
	or a			; $3b56
	call nz,updateInteraction		; $3b57
	ldh a,(<hActiveObject)	; $3b5a
	inc a			; $3b5c
	cp LAST_INTERACTION_INDEX+1			; $3b5d
	jr c,@next		; $3b5f
	ret			; $3b61

;;
; Run once per frame for each interaction.
;
; @param	d	Interaction to update
; @addr{3b62}
updateInteraction:
	ld e,Interaction.id		; $3b62
	ld a,(de)		; $3b64

.ifdef ROM_AGES
	; Get the bank number in 'b'
	ld b,$08		; $3b65
	cp $3e			; $3b67
	jr c,@cnt		; $3b69
	inc b			; $3b6b
	cp $67			; $3b6c
	jr c,@cnt		; $3b6e
	inc b			; $3b70
	cp $98			; $3b71
	jr c,@cnt		; $3b73
	inc b			; $3b75
	cp $dc			; $3b76
	jr c,@cnt		; $3b78
	ld b,$10		; $3b7a

.else ; ROM_SEASONS

	ld b,$08
	cp $5e
	jr c,@cnt
	inc b
	cp $89
	jr c,@cnt
	inc b
	cp $c8
	jr c,@cnt
	ld b,$0f
	cp $d8
	jr c,@cnt
	ld b,$15
.endif

@cnt:
	ld a,b			; $3b7c
	setrombank		; $3b7d
	ld a,(de)		; $3b82
	ld hl,interactionCodeTable	; $3b83
	rst_addDoubleIndex			; $3b86
	ldi a,(hl)		; $3b87
	ld h,(hl)		; $3b88
	ld l,a			; $3b89
	jp hl			; $3b8a

interactionCodeTable: ; $3b8b
	.dw interactionBank1.interactionCode00 ; 0x00
	.dw interactionBank1.interactionCode01 ; 0x01
	.dw interactionBank1.interactionCode02 ; 0x02
	.dw interactionBank1.interactionCode03 ; 0x03
	.dw interactionBank1.interactionCode04 ; 0x04
	.dw interactionBank1.interactionCode05 ; 0x05
	.dw interactionBank1.interactionCode06 ; 0x06
	.dw interactionBank1.interactionCode07 ; 0x07
	.dw interactionBank1.interactionCode08 ; 0x08
	.dw interactionBank1.interactionCode09 ; 0x09
	.dw interactionBank1.interactionCode0a ; 0x0a
	.dw interactionBank1.interactionCode0b ; 0x0b
	.dw interactionBank1.interactionCode0c ; 0x0c
	.dw                  interactionDelete ; 0x0d
	.dw                  interactionDelete ; 0x0e
	.dw interactionBank1.interactionCode0f ; 0x0f
	.dw interactionBank1.interactionCode10 ; 0x10
	.dw interactionBank1.interactionCode11 ; 0x11
	.dw interactionBank1.interactionCode12 ; 0x12
	.dw interactionBank1.interactionCode13 ; 0x13
	.dw interactionBank1.interactionCode14 ; 0x14
	.dw interactionBank1.interactionCode15 ; 0x15
	.dw interactionBank1.interactionCode16 ; 0x16
	.dw interactionBank1.interactionCode17 ; 0x17
	.dw interactionBank1.interactionCode18 ; 0x18
	.dw interactionBank1.interactionCode19 ; 0x19
	.dw interactionBank1.interactionCode1a ; 0x1a
	.dw interactionBank1.interactionCode1b ; 0x1b
	.dw interactionBank1.interactionCode1c ; 0x1c
	.dw                  interactionDelete ; 0x1d
	.dw interactionBank1.interactionCode1e ; 0x1e
	.dw interactionBank1.interactionCode1f ; 0x1f
	.dw interactionBank1.interactionCode20 ; 0x20
	.dw interactionBank1.interactionCode21 ; 0x21
	.dw interactionBank1.interactionCode22 ; 0x22
	.dw interactionBank1.interactionCode23 ; 0x23
	.dw interactionBank1.interactionCode24 ; 0x24
	.dw interactionBank1.interactionCode25 ; 0x25
	.dw                  interactionDelete ; 0x26
	.dw                  interactionDelete ; 0x27
	.dw interactionBank1.interactionCode28 ; 0x28
	.dw interactionBank1.interactionCode29 ; 0x29
	.dw interactionBank1.interactionCode2a ; 0x2a
	.dw interactionBank1.interactionCode2b ; 0x2b
	.dw interactionBank1.interactionCode2c ; 0x2c
	.dw interactionBank1.interactionCode2d ; 0x2d
	.dw interactionBank1.interactionCode2e ; 0x2e
	.dw interactionBank1.interactionCode2f ; 0x2f
	.dw interactionBank1.interactionCode30 ; 0x30
	.dw interactionBank1.interactionCode31 ; 0x31
	.dw interactionBank1.interactionCode32 ; 0x32
	.dw interactionBank1.interactionCode33 ; 0x33
	.dw interactionBank1.interactionCode34 ; 0x34
	.dw interactionBank1.interactionCode35 ; 0x35
	.dw interactionBank1.interactionCode36 ; 0x36
	.dw interactionBank1.interactionCode37 ; 0x37
	.dw interactionBank1.interactionCode38 ; 0x38
	.dw interactionBank1.interactionCode39 ; 0x39
	.dw interactionBank1.interactionCode3a ; 0x3a
	.dw interactionBank1.interactionCode3b ; 0x3b
	.dw interactionBank1.interactionCode3c ; 0x3c
	.dw interactionBank1.interactionCode3d ; 0x3d
	.dw interactionBank2.interactionCode3e ; 0x3e
	.dw interactionBank2.interactionCode3f ; 0x3f
	.dw interactionBank2.interactionCode40 ; 0x40
	.dw interactionBank2.interactionCode41 ; 0x41
	.dw interactionBank2.interactionCode42 ; 0x42
	.dw interactionBank2.interactionCode43 ; 0x43
	.dw interactionBank2.interactionCode44 ; 0x44
	.dw interactionBank2.interactionCode45 ; 0x45
	.dw interactionBank2.interactionCode46 ; 0x46
	.dw interactionBank2.interactionCode47 ; 0x47
	.dw interactionBank2.interactionCode48 ; 0x48
	.dw interactionBank2.interactionCode49 ; 0x49
	.dw interactionBank2.interactionCode4a ; 0x4a
	.dw interactionBank2.interactionCode4b ; 0x4b
	.dw interactionBank2.interactionCode4c ; 0x4c
	.dw interactionBank2.interactionCode4d ; 0x4d
	.dw interactionBank2.interactionCode4e ; 0x4e
	.dw interactionBank2.interactionCode4f ; 0x4f
	.dw                  interactionDelete ; 0x50
	.dw interactionBank2.interactionCode51 ; 0x51
	.dw interactionBank2.interactionCode52 ; 0x52
	.dw interactionBank2.interactionCode53 ; 0x53
	.dw interactionBank2.interactionCode54 ; 0x54
	.dw interactionBank2.interactionCode55 ; 0x55
	.dw interactionBank2.interactionCode56 ; 0x56
	.dw interactionBank2.interactionCode57 ; 0x57
	.dw interactionBank2.interactionCode58 ; 0x58
	.dw interactionBank2.interactionCode59 ; 0x59
	.dw interactionBank2.interactionCode5a ; 0x5a
	.dw interactionBank2.interactionCode5b ; 0x5b
	.dw interactionBank2.interactionCode5c ; 0x5c
	.dw interactionBank2.interactionCode5d ; 0x5d
	.dw interactionBank2.interactionCode5e ; 0x5e
	.dw interactionBank2.interactionCode5f ; 0x5f
	.dw interactionBank2.interactionCode60 ; 0x60
	.dw interactionBank2.interactionCode61 ; 0x61
	.dw interactionBank2.interactionCode62 ; 0x62
	.dw interactionBank2.interactionCode63 ; 0x63
	.dw interactionBank2.interactionCode64 ; 0x64
	.dw interactionBank2.interactionCode65 ; 0x65
	.dw interactionBank2.interactionCode66 ; 0x66
	.dw interactionCode67 ; 0x67
	.dw interactionCode68 ; 0x68
	.dw interactionCode69 ; 0x69
	.dw interactionCode6a ; 0x6a
	.dw interactionCode6b ; 0x6b
	.dw interactionCode6c ; 0x6c
	.dw interactionCode6d ; 0x6d
	.dw interactionCode6e ; 0x6e
	.dw interactionCode6f ; 0x6f
	.dw interactionCode70 ; 0x70
	.dw interactionCode71 ; 0x71
	.dw interactionCode72 ; 0x72
	.dw interactionCode73 ; 0x73
	.dw interactionCode74 ; 0x74
	.dw interactionCode75 ; 0x75
	.dw interactionCode76 ; 0x76
	.dw interactionCode77 ; 0x77
	.dw interactionCode78 ; 0x78
	.dw interactionCode79 ; 0x79
	.dw interactionCode7a ; 0x7a
	.dw interactionCode7b ; 0x7b
	.dw interactionCode7c ; 0x7c
	.dw interactionCode7d ; 0x7d
	.dw interactionCode7e ; 0x7e
	.dw interactionCode7f ; 0x7f
	.dw interactionCode80 ; 0x80
	.dw interactionCode81 ; 0x81
	.dw interactionCode82 ; 0x82
	.dw interactionCode83 ; 0x83
	.dw interactionCode84 ; 0x84
	.dw interactionDelete ; 0x85
	.dw interactionCode86 ; 0x86
	.dw interactionCode87 ; 0x87
	.dw interactionCode88 ; 0x88
	.dw interactionCode89 ; 0x89
	.dw interactionCode8a ; 0x8a
	.dw interactionCode8b ; 0x8b
	.dw interactionCode8c ; 0x8c
	.dw interactionCode8d ; 0x8d
	.dw interactionCode8e ; 0x8e
	.dw interactionCode8f ; 0x8f
	.dw interactionCode90 ; 0x90
	.dw interactionCode91 ; 0x91
	.dw interactionCode92 ; 0x92
	.dw interactionCode93 ; 0x93
	.dw interactionCode94 ; 0x94
	.dw interactionCode95 ; 0x95
	.dw interactionCode96 ; 0x96
	.dw interactionCode97 ; 0x97
	.dw interactionCode98 ; 0x98
	.dw interactionCode99 ; 0x99
	.dw interactionCode9a ; 0x9a
	.dw interactionCode9b ; 0x9b
	.dw interactionCode9c ; 0x9c
	.dw interactionCode9d ; 0x9d
	.dw interactionCode9e ; 0x9e
	.dw interactionCode9f ; 0x9f
	.dw interactionCodea0 ; 0xa0
	.dw interactionCodea1 ; 0xa1
	.dw interactionCodea2 ; 0xa2
	.dw interactionCodea3 ; 0xa3
	.dw interactionCodea4 ; 0xa4
	.dw interactionCodea5 ; 0xa5
	.dw interactionCodea6 ; 0xa6
	.dw interactionCodea7 ; 0xa7
	.dw interactionCodea8 ; 0xa8
	.dw interactionCodea9 ; 0xa9
	.dw interactionCodeaa ; 0xaa
	.dw interactionCodeab ; 0xab
	.dw interactionCodeac ; 0xac
	.dw interactionCodead ; 0xad
	.dw interactionCodeae ; 0xae
	.dw interactionCodeaf ; 0xaf
	.dw interactionCodeb0 ; 0xb0
	.dw interactionCodeb1 ; 0xb1
	.dw interactionCodeb2 ; 0xb2
	.dw interactionCodeb3 ; 0xb3
	.dw interactionCodeb4 ; 0xb4
	.dw interactionCodeb5 ; 0xb5
	.dw interactionCodeb6 ; 0xb6
	.dw interactionCodeb7 ; 0xb7
	.dw interactionCodeb8 ; 0xb8
	.dw interactionCodeb9 ; 0xb9
	.dw interactionCodeba ; 0xba
	.dw interactionCodebb ; 0xbb
	.dw interactionCodebc ; 0xbc
	.dw interactionCodebd ; 0xbd
	.dw interactionCodebe ; 0xbe
	.dw interactionCodebf ; 0xbf
	.dw interactionCodec0 ; 0xc0
	.dw interactionCodec1 ; 0xc1
	.dw interactionCodec2 ; 0xc2
	.dw interactionCodec3 ; 0xc3
	.dw interactionCodec4 ; 0xc4
	.dw interactionCodec5 ; 0xc5
	.dw interactionCodec6 ; 0xc6
	.dw interactionCodec7 ; 0xc7
	.dw interactionCodec8 ; 0xc8
	.dw interactionCodec9 ; 0xc9
	.dw interactionCodeca ; 0xca
	.dw interactionCodecb ; 0xcb
	.dw interactionCodecc ; 0xcc
	.dw interactionCodecd ; 0xcd
	.dw interactionCodece ; 0xce
	.dw interactionCodecf ; 0xcf
	.dw interactionCoded0 ; 0xd0
	.dw interactionCoded1 ; 0xd1
	.dw interactionCoded2 ; 0xd2
	.dw interactionCoded3 ; 0xd3
	.dw interactionCoded4 ; 0xd4
	.dw interactionCoded5 ; 0xd5
	.dw interactionCoded6 ; 0xd6
	.dw interactionCoded7 ; 0xd7
	.dw interactionCoded8 ; 0xd8
	.dw interactionCoded9 ; 0xd9
	.dw interactionCodeda ; 0xda
	.dw interactionCodedb ; 0xdb
	.dw interactionCodedc ; 0xdc
	.dw interactionCodedd ; 0xdd
	.dw interactionCodede ; 0xde
	.dw interactionCodedf ; 0xdf
	.dw interactionCodee0 ; 0xe0
	.dw interactionCodee1 ; 0xe1
	.dw interactionCodee2 ; 0xe2
	.dw interactionCodee3 ; 0xe3
	.dw interactionDelete ; 0xe4
	.dw interactionCodee5 ; 0xe5
	.dw interactionCodee6 ; 0xe6
.ifdef ROM_SEASONS
	.dw 0
.endif


.ifdef ROM_SEASONS

seasonsFunc_3d30:
	ld a,(wFrameCounter)		; $3d30
	and $3f			; $3d33
	ret nz			; $3d35
	ld b,$fa		; $3d36
	ld c,$fc		; $3d38
	jp objectCreateFloatingSnore		; $3d3a

seasonsFunc_3d3d:
	ldh a,(<hRomBank)	; $3d3d
	push af			; $3d3f
	callfrombank0 $0a $7a7b		; $3d40
	push af			; $3d4a
	pop bc			; $3d4b
	pop af			; $3d4c
	setrombank		; $3d4d
	ret			; $3d52

; Placeholders
checkObjectIsCloseToPosition:
checkNpcShouldExistAtGameStage:
tokayIslandStolenItems:


.else ; ROM_AGES

;;
; Checks that an object is within [hFF8B] pixels of a position on both axes.
;
; @param	bc	Target position
; @param	hl	Object's Y position
; @param	hFF8B	Range we must be within on each axis
; @param[out]	cflag	c if the object is within [hFF8B] pixels of the position
; @addr{3d59}
checkObjectIsCloseToPosition:
	ldh (<hFF8B),a	; $3d59
	ldh a,(<hRomBank)	; $3d5b
	push af			; $3d5d

	callfrombank0 interactionBank1.checkObjectIsCloseToPosition		; $3d5e
	ld b,$00		; $3d68
	jr nc,+			; $3d6a
	inc b			; $3d6c
+
	pop af			; $3d6d
	setrombank		; $3d6e

	ld a,b			; $3d73
	or a			; $3d74
	ret z			; $3d75
	scf			; $3d76
	ret			; $3d77

;;
; Contains some preset data for checking whether certain interactions should exist at
; certain points in the game?
;
; @param	a	Index of preset data to check
; @param	b	Return value from "getGameProgress_1" or "getGameProgress_2"?
; @param	c	Subid "base"
; @param[out]	zflag	Set if the npc should exist
; @addr{3d78}
checkNpcShouldExistAtGameStage:
	ldh (<hFF8B),a	; $3d78
	ldh a,(<hRomBank)	; $3d7a
	push af			; $3d7c
	ld a,:interactionBank2.checkNpcShouldExistAtGameStage_body		; $3d7d
	setrombank		; $3d7f
	ldh a,(<hFF8B)	; $3d84
	call interactionBank2.checkNpcShouldExistAtGameStage_body		; $3d86
	ld c,$00		; $3d89
	jr z,+			; $3d8b
	inc c			; $3d8d
+
	pop af			; $3d8e
	setrombank		; $3d8f
	ld a,c			; $3d94
	or a			; $3d95
	ret			; $3d96

; @addr{3d97}
tokayIslandStolenItems:
	.db TREASURE_SWORD
	.db TREASURE_SHOVEL
	.db TREASURE_HARP
	.db TREASURE_FLIPPERS
	.db TREASURE_SEED_SATCHEL
	.db TREASURE_SHIELD
	.db TREASURE_BOMBS
	.db TREASURE_BRACELET
	.db TREASURE_FEATHER

.endif

;;
; This function is identical to "interactionSetMiniScript", but is used in different
; contexts. See "include/simplescript_commands.s".
;
; @addr{3da0}
interactionSetSimpleScript:
	ld e,Interaction.scriptPtr		; $3da0
	ld a,l			; $3da2
	ld (de),a		; $3da3
	inc e			; $3da4
	ld a,h			; $3da5
	ld (de),a		; $3da6
	ret			; $3da7

;;
; @param[out]	cflag	Set if the script has ended.
; @addr{3da8}
interactionRunSimpleScript:
	ldh a,(<hRomBank)	; $3da8
	push af			; $3daa
	ld a,SCRIPT_BANK		; $3dab
	setrombank		; $3dad

	ld h,d			; $3db2
	ld l,Interaction.scriptPtr		; $3db3
	ldi a,(hl)		; $3db5
	ld h,(hl)		; $3db6
	ld l,a			; $3db7
--
	ld a,(hl)		; $3db8
	or a			; $3db9
	jr z,@scriptEnd			; $3dba
	call @runCommand		; $3dbc
	jr c,--			; $3dbf

	call interactionSetSimpleScript		; $3dc1
	pop af			; $3dc4
	setrombank		; $3dc5
	xor a			; $3dca
	ret			; $3dcb

@scriptEnd:
	pop af			; $3dcc
	setrombank		; $3dcd
	scf			; $3dd2
	ret			; $3dd3

;;
; @addr{3dd4}
@runCommand:
	ldi a,(hl)		; $3dd4
	push hl			; $3dd5
	rst_jumpTable			; $3dd6
	.dw @command0
	.dw @command1
	.dw @command2
	.dw @command3
	.dw @command4
.ifdef ROM_SEASONS
	.dw @command5
	.dw @command6
	.dw @command7
	.dw @command8
.endif

;;
; This doesn't get executed, value $00 is checked for above.
;
; @addr{3de1}
@command0:
	pop hl			; $3de1
	ret			; $3de2

;;
; Set counter1
;
; @addr{3de3}
@command1:
	pop hl			; $3de3
	ldi a,(hl)		; $3de4
	ld e,Interaction.counter1		; $3de5
	ld (de),a		; $3de7
	xor a			; $3de8
	ret			; $3de9

;;
; Call playSound
;
; @addr{3dea}
@command2:
	pop hl			; $3dea
	ldi a,(hl)		; $3deb
	push hl			; $3dec
	call playSound		; $3ded
	pop hl			; $3df0
	ret			; $3df1

;;
; Call setTile
;
; @addr{3df2}
@command3:
	pop hl			; $3df2
	ldi a,(hl)		; $3df3
	ld c,a			; $3df4
	ldi a,(hl)		; $3df5
	push hl			; $3df6
	call setTile		; $3df7
	pop hl			; $3dfa
	scf			; $3dfb
	ret			; $3dfc

;;
; Call setInterleavedTile
;
; @addr{3dfd}
@command4:
	pop hl			; $3dfd
	ldi a,(hl)		; $3dfe
	ldh (<hFF8C),a	; $3dff
	ldi a,(hl)		; $3e01
	ldh (<hFF8F),a	; $3e02
	ldi a,(hl)		; $3e04
	ldh (<hFF8E),a	; $3e05
	ldi a,(hl)		; $3e07
	push hl			; $3e08
	call setInterleavedTile		; $3e09
	pop hl			; $3e0c
	scf			; $3e0d
	ret			; $3e0e


.ifdef ROM_SEASONS

@command5:
	pop hl			; $3dca
	ldi a,(hl)		; $3dcb
	ld b,a			; $3dcc
	ldi a,(hl)		; $3dcd
	ld c,a			; $3dce
	ldi a,(hl)		; $3dcf
	ld ($ff00+$8b),a	; $3dd0
	push hl			; $3dd2
--
	push bc			; $3dd3
	ld a,($ff00+$8b)	; $3dd4
	call setTile		; $3dd6
	pop bc			; $3dd9
	inc c			; $3dda
	dec b			; $3ddb
	jr nz,--		; $3ddc
	pop hl			; $3dde
	scf			; $3ddf
	ret			; $3de0

@command7:
	pop hl			; $3de1
	ldi a,(hl)		; $3de2
	ld b,a			; $3de3
	ldi a,(hl)		; $3de4
	ld ($ff00+$8c),a	; $3de5
	ldi a,(hl)		; $3de7
	ld ($ff00+$8e),a	; $3de8
	ldi a,(hl)		; $3dea
	ld ($ff00+$8d),a	; $3deb
	push hl			; $3ded
--
	push bc			; $3dee
	ld b,$cf		; $3def
	ld a,($ff00+$8c)	; $3df1
	ld c,a			; $3df3
	ld a,(bc)		; $3df4
	ld ($ff00+$8f),a	; $3df5
	ld a,($ff00+$8d)	; $3df7
	call setInterleavedTile		; $3df9
	ld hl,$ff8c		; $3dfc
	inc (hl)		; $3dff
	pop bc			; $3e00
	dec b			; $3e01
	jr nz,--		; $3e02
	pop hl			; $3e04
	scf			; $3e05

@command6:
@command8:
	ret			; $3e06

.endif


.ifdef ROM_AGES

;;
; Gets object data for tokays in the wild tokay game.
;
; @param	b	Index (0/1: Tokay on left; 2: tokay on right; 3: both sides)
; @param[out]	hl	Address of object data
; @addr{3e0f}
getWildTokayObjectDataIndex:
	ldh a,(<hRomBank)	; $3e0f
	push af			; $3e11
	ld a,:objectData.wildTokayObjectTable
	setrombank		; $3e14
	ld a,b			; $3e19
	ld hl,objectData.wildTokayObjectTable
	rst_addDoubleIndex			; $3e1d
	ldi a,(hl)		; $3e1e
	ld h,(hl)		; $3e1f
	ld l,a			; $3e20
	pop af			; $3e21
	setrombank		; $3e22
	ret			; $3e27

;;
; Create a sparkle at the current object's position.
;
; @addr{3e28}
objectCreateSparkle:
	call getFreeInteractionSlot		; $3e28
	ret nz			; $3e2b
	ld (hl),INTERACID_SPARKLE		; $3e2c
	inc l			; $3e2e
	ld (hl),$00		; $3e2f
	jp objectCopyPositionWithOffset		; $3e31

;;
; Create a sparkle at the current object's position that moves up briefly.
;
; Unused?
;
; @addr{3e34}
objectCreateSparkleMovingUp:
	call getFreeInteractionSlot		; $3e34
	ret nz			; $3e37
	ld (hl),INTERACID_SPARKLE		; $3e38
	inc l			; $3e3a
	ld (hl),$02		; $3e3b
	ld l,$50		; $3e3d
	ld (hl),$80		; $3e3f
	inc l			; $3e41
	ld (hl),$ff		; $3e42
	jp objectCopyPositionWithOffset		; $3e44

;;
; Create a red and blue decorative orb.
;
; Unused?
;
; @addr{3e47}
objectCreateRedBlueOrb:
	call getFreeInteractionSlot		; $3e47
	ret nz			; $3e4a
	ld (hl),INTERACID_SPARKLE		; $3e4b
	inc l			; $3e4d
	ld (hl),$04		; $3e4e
	jp objectCopyPositionWithOffset		; $3e50

;;
; @addr{3e53}
incMakuTreeState:
	ld a,(wMakuTreeState)		; $3e53
	inc a			; $3e56
	cp $11			; $3e57
	jr c,+			; $3e59
	ld a,$10		; $3e5b
+
	ld (wMakuTreeState),a		; $3e5d
	ret			; $3e60

;;
; Sets w1Link.direction, as well as w1Companion.direction if Link is riding something.
;
; @addr{3e61}
setLinkDirection:
	ld b,a			; $3e61
	ld a,(wLinkObjectIndex)		; $3e62
	ld h,a			; $3e65
	ld l,SpecialObject.direction		; $3e66
	ld (hl),b		; $3e68
	ld h,>w1Link		; $3e69
	ld (hl),b		; $3e6b
	ret			; $3e6c

.else ; ROM_SEASONS

seasonsFunc_3e07:
	ld a,($ff00+$97)	; $3e07
	push af			; $3e09
	callfrombank0 $08 $57db		; $3e0a
	ld c,$01		; $3e14
	jr c,+			; $3e16
	dec c			; $3e18
+
	pop af			; $3e19
	setrombank		; $3e1a
	ret			; $3e1f

seasonsFunc_3e20:
	ld a,($ff00+$97)	; $3e20
	push af			; $3e22
	callfrombank0 $09 $7d8b		; $3e23
	callfrombank0 $15 $60fc		; $3e2d
	pop af			; $3e37
	setrombank		; $3e38
	ret			; $3e3d

seasonsFunc_3e3e:
	ld a,($ff00+$97)	; $3e3e
	push af			; $3e40
	callfrombank0 $08 $5874		; $3e41
	pop af			; $3e4b
	setrombank		; $3e4c
	ret			; $3e51

seasonsFunc_3e52:
	ld a,($ff00+$97)	; $3e52
	push af			; $3e54
	callfrombank0 $0a $69d4 		; $3e55
	ld a,$01		; $3e5f
	call $69e7		; $3e61
	call $6a0a		; $3e64
	pop af			; $3e67
	setrombank		; $3e68
	ret			; $3e6d

; Placeholders
getWildTokayObjectDataIndex:
objectCreateSparkle:
objectCreateSparkleMovingUp:
objectCreateRedBlueOrb:
incMakuTreeState:
setLinkDirection:

.endif ; ROM_SEASONS


;;
; Used during the end credits. Seems to load the credit text into OAM.
;
; @addr{3e6d}
interactionFunc_3e6d:
	push de			; $3e6d
	ld l,Interaction.var03		; $3e6e
	ld e,(hl)		; $3e70

	ldh a,(<hRomBank)	; $3e71
	push af			; $3e73
	ld a,:bank16.data_4556		; $3e74
	setrombank		; $3e76

	ld a,e			; $3e7b
	ld hl,bank16.data_4556		; $3e7c
	rst_addDoubleIndex			; $3e7f
	ldi a,(hl)		; $3e80
	ld h,(hl)		; $3e81
	ld l,a			; $3e82
	call addSpritesToOam_withOffset		; $3e83
	pop af			; $3e86
	setrombank		; $3e87
	pop de			; $3e8c
	ret			; $3e8d


.ifdef ROM_SEASONS

seasonsFunc_3e8f:
	ld a,($ff00+$97)	; $3e8f
	push af			; $3e91
	callfrombank0 $04 $7655	; $3e92
	ld a,(hl)		; $3e9c
	ld ($cc64),a		; $3e9d
	pop af			; $3ea0
	setrombank		; $3ea1
	ret			; $3ea6

.endif

;;
; @param[out]	hl	Address of part slot ("id" byte)
; @param[out]	zflag	nz if no free slot was available
; @addr{3e8e}
getFreePartSlot:
	ldhl FIRST_PART_INDEX, Part.start		; $3e8e
--
	ld a,(hl)		; $3e91
	or a			; $3e92
	jr z,++
	inc h			; $3e95
	ld a,h			; $3e96
	cp LAST_PART_INDEX+1			; $3e97
	jr c,--
	or h			; $3e9b
	ret			; $3e9c
++
	inc a			; $3e9d
	ldi (hl),a		; $3e9e
	xor a			; $3e9f
	ret			; $3ea0

;;
; @addr{3ea1}
partDelete:
	ld h,d			; $3ea1
	ld l,Part.start		; $3ea2
	ld b,$10		; $3ea4
	xor a			; $3ea6
-
	ldi (hl),a		; $3ea7
	ldi (hl),a		; $3ea8
	ldi (hl),a		; $3ea9
	ldi (hl),a		; $3eaa
	dec b			; $3eab
	jr nz,-
	ret			; $3eae


.ifdef ROM_AGES

;;
; @param[out]	cflag
; @addr{3eaf}
checkLinkCanSurface:
	ld a,(wAreaFlags)		; $3eaf
	and AREAFLAG_UNDERWATER			; $3eb2
	ret z			; $3eb4
	callab checkLinkCanSurface_isUnderwater
	srl c			; $3ebd
	ret			; $3ebf

;;
; Copy $100 bytes from a specified bank.
;
; This DOES NOT set the bank back to its previous value, so it's not very useful.
;
; In fact, it's unused.
;
; @param	c	ROM Bank to copy from
; @param	d	High byte of address to copy to
; @param	e	WRAM Bank
; @param	hl	Address to copy from
; @addr{3ec0}
copy256BytesFromBank:
	ld a,e			; $3ec0
	ld ($ff00+R_SVBK),a	; $3ec1
	ld a,c			; $3ec3
	setrombank		; $3ec4
	ld e,$00		; $3ec9
	ld b,$00		; $3ecb
	jp copyMemory		; $3ecd

;;
; @addr{3ed0}
func_3ed0:
	ldh a,(<hRomBank)	; $3ed0
	push af			; $3ed2
	callfrombank0 func_03_7841		; $3ed3
	pop af			; $3edd
	setrombank		; $3ede
	ret			; $3ee3

;;
; @addr{3ee4}
func_3ee4:
	ldh a,(<hRomBank)	; $3ee4
	push af			; $3ee6
	callfrombank0 func_03_7849		; $3ee7
	pop af			; $3ef1
	setrombank		; $3ef2
	ret			; $3ef7

.else ; ROM_SEASONS

; Placeholder
checkLinkCanSurface:
copy256BytesFromBank:
func_3ed0:
func_3ee4:

.endif


.ENDS

.BANK $01 SLOT 1
.ORG 0

	.include "code/bank1.s"


.BANK $02 SLOT 1
.ORG 0

	.include "code/bank2.s"


.BANK $03 SLOT 1
.ORG 0

;;
; This is the first thing the game jumps to on startup.
; @addr{4000}
init:
	di			; $4000
	xor a			; $4001
	ld ($ff00+R_IF),a	; $4002
	ld ($ff00+R_IE),a	; $4004
	ld ($ff00+R_STAT),a	; $4006
	ld ($ff00+R_TAC),a	; $4008
	ld ($ff00+R_SC),a	; $400a
	xor a			; $400c
	ld ($1111),a		; $400d

	call disableLcd		; $4010

	ldh a,(<hGameboyType)	; $4013
	or a			; $4015
	jr z,+			; $4016

	; Initialize CGB registers
	xor a			; $4018
	ld ($ff00+R_RP),a	; $4019
	ld ($ff00+R_SVBK),a	; $401b
	ld ($ff00+R_VBK),a	; $401d
	call _setCpuToDoubleSpeed		; $401f
+
	ld hl,hActiveFileSlot		; $4022
	ld b,hramEnd-hActiveFileSlot		; $4025
	call clearMemory		; $4027

	; Clear all memory after the stacks
	ld hl,wThread3StackTop		; $402a
	ld bc,$dfff-wThread3StackTop		; $402d
	call clearMemoryBc		; $4030

	call clearVram		; $4033

	; Copy DMA function to hram
	ld hl,_oamDmaFunction		; $4036
	ld de,hOamFunc		; $4039
	ld b,_oamDmaFunctionEnd-_oamDmaFunction		; $403c
	call copyMemory		; $403e

	; Initialize DMG palettes
	ld a,%11100100		; $4041
	ld ($ff00+R_BGP),a	; $4043
	ld ($ff00+R_OBP0),a	; $4045
	ld a,%01101100		; $4047
	ld ($ff00+R_OBP1),a	; $4049

	call initSound		; $404b

	ld a,$c7		; $404e
	ld ($ff00+R_LYC),a	; $4050
	ld a,$40		; $4052
	ld ($ff00+R_STAT),a	; $4054

	xor a			; $4056
	ld ($ff00+R_IF),a	; $4057
	ld a,$0f		; $4059
	ld ($ff00+R_IE),a	; $405b

	callab bank3f.initGbaModePaletteData		; $405d
	ei			; $4065
	callab bank2.checkDisplayDmgModeScreen		; $4066

	jp startGame		; $406e

;;
; @addr{4071}
_setCpuToDoubleSpeed:
	ld a,($ff00+R_KEY1)	; $4071
	rlca			; $4073
	ret c			; $4074

	xor a			; $4075
	ld ($ff00+R_IF),a	; $4076
	ld ($ff00+R_IE),a	; $4078
	ld a,$01		; $407a
	ld ($ff00+R_KEY1),a	; $407c
	ld a,$30		; $407e
	ld ($ff00+R_P1),a	; $4080
	stop			; $4082
	nop			; $4083
-
	ld a,($ff00+R_KEY1)	; $4084
	rlca			; $4086
	jr nc,-			; $4087

	xor a			; $4089
	ld ($ff00+R_P1),a	; $408a
	ld ($ff00+R_IF),a	; $408c
	ld ($ff00+R_IE),a	; $408e
	ret			; $4090

;;
; This is copied to RAM and run from there.
; @addr{4091}
_oamDmaFunction:
	ld a,>wOam		; $4091
	ld ($ff00+R_DMA),a	; $4093
	ld a,$28		; $4095
-
	dec a			; $4097
	jr nz,-			; $4098
	ret			; $409a
_oamDmaFunctionEnd:


; Speed table for objects.
;
; It's organized in a sort of complicated way which allows it to reuse certain sin and cos
; values for certain angles, ie. an angle of $08 (right) uses the same values for its
; Y speed as angle $00 (up) does for its X speed. Due to this, there is an extra .dwsin
; line at the end of each repetition which is used for angle $18-$1f's X positions only.
;
; @addr{409b}
objectSpeedTable:
	.define TMP_SPEED $20

	.rept 24
		; Calculate 8 sin/cos values per line at increments of 11.25 degrees
		.dwsin 090 7 11.25 (-TMP_SPEED) 0 ; $00 <- angle
		.dwcos 090 7 11.25 (-TMP_SPEED) 0 ; $08
		.dwsin 270 7 11.25 (-TMP_SPEED) 0 ; $10
		.dwcos 270 7 11.25 (-TMP_SPEED) 0 ; $18
		.dwsin 090 7 11.25 (-TMP_SPEED) 0

		.redefine TMP_SPEED TMP_SPEED+$20
	.endr

	.undefine TMP_SPEED


;;
; Calculates the game-transfer secret's text?
; @addr{481b}
generateGameTransferSecret:
	ld hl,wFileIsLinkedGame		; $481b
	ldi a,(hl)		; $481e
	ld b,(hl)		; $481f
	ld c,a			; $4820
	push bc			; $4821

	; When generating a game-transfer secret: if this file is either linked or
	; a hero's file, mark the secret as a "hero's secret"; otherwise, it's just
	; linked? (so basically, only the secret from the first game is marked as
	; linked...)
	or b			; $4822
	ldd (hl),a		; $4823
	xor $01			; $4824
	or b			; $4826
	ld (hl),a		; $4827

	ldbc $00,$00		; $4828
	call secretFunctionCaller_body		; $482b

	pop bc			; $482e
	ld hl,wFileIsLinkedGame		; $482f
	ld (hl),c		; $4832
	inc l			; $4833
	ld (hl),b		; $4834
	ret			; $4835

;;
; Calls a secret-related function based on parameter 'b':
;
; 0: Generate a secret
; 1: Unpack a secret in ascii form (input and output are both in wTmpcec0)
; 2: Verify that the gameID of an unpacked secret is valid
; 3: Generate a gameID for the current file
; 4: Loads the data associated with an unpacked secret (ie. for game-transfer secret, this
;    loads the player name, animal companion, etc. from the secret data).
;
; @param	b	Function to call
; @param	c	Secret type
; @param[out]	zflag	Generally set on success
; @addr{4836}
secretFunctionCaller_body:
	push de			; $4836
	ld a,($ff00+R_SVBK)	; $4837
	push af			; $4839
	ld a,TEXT_BANK		; $483a
	ld ($ff00+R_SVBK),a	; $483c

	call @jumpTable		; $483e

	pop af			; $4841
	ld ($ff00+R_SVBK),a	; $4842
	pop de			; $4844
	ret			; $4845

@jumpTable:
	ld a,b			; $4846
	rst_jumpTable			; $4847
	.dw _generateSecret
	.dw _unpackSecret
	.dw _verifyUnpackedSecretGameID
	.dw _generateGameIDIfNeeded
	.dw _loadUnpackedSecretData

;;
; Generates a secret. If this is one of the 5-letter secrets, then wShortSecretIndex
; should be set to the corresponding secret's index (?) before calling this.
;
; @param	c	Value for wSecretType
; @addr{4852}
_generateSecret:
	ld hl,w7SecretText1		; $4852
	ld b,$40		; $4855
	call clearMemory		; $4857

	call _andCWith3		; $485a
	call _generateGameIDIfNeeded		; $485d

	call @determineXorCipher		; $4860
	ld hl,wSecretXorCipherIndex		; $4863
	ldi (hl),a		; $4866
	ld (hl),c ; hl = wSecretType

	ld a,$04 ; Encode the gameID
	call _encodeSecretData		; $486a
	; Encode everything else (c is unmodified from before)
	call _encodeSecretData_paramC		; $486d

	; Calculate checksum (4 bits) and insert it at the end
	ld b,$04		; $4870
	xor a			; $4872
	call _insertBitsIntoSecretGenerationBuffer		; $4873
	call _getSecretBufferChecksum		; $4876
	ld hl,w7SecretGenerationBuffer+19		; $4879
	or (hl)			; $487c
	ld (hl),a		; $487d

	call _shiftSecretBufferContentsToFront		; $487e
	call _runXorCipherOnSecretBuffer		; $4881
	jp _convertSecretBufferToText		; $4884

;;
; Decides which xor cipher to use based on GameID (and, for 5-letter secrets, based on
; which secret it is).
;
; @param	c
; @param[out]	a	Which xor cipher to use (from 0-7)
; @addr{4887}
@determineXorCipher:
	push bc			; $4887
	ld hl,wGameID		; $4888
	ldi a,(hl)		; $488b
	add (hl)
	ld b,a			; $488d
	ld a,c			; $488e
	cp $03			; $488f
	ld a,b			; $4891
	jr nz,@ret		; $4892

	ld l,<wShortSecretIndex		; $4894
	ld a,(hl)		; $4896
	swap a			; $4897
	and $0f			; $4899
	add b			; $489b
	ld b,a			; $489c
	ld a,(hl)		; $489d
	and $01			; $489e
	rlca			; $48a0
	rlca			; $48a1
	xor b			; $48a2
@ret:
	and $07			; $48a3
	pop bc			; $48a5
	ret			; $48a6

;;
; @param	c	Secret type to encode (0-4)
; @addr{48a7}
_encodeSecretData_paramC:
	ld a,c			; $48a7

;;
; Encodes data into a secret by shifting in the required bits.
;
; @param	a	Secret type to encode (0-4)
; @addr{48a8}
_encodeSecretData:
	push bc			; $48a8
	ld hl,_secretDataToEncodeTable		; $48a9
	rst_addDoubleIndex			; $48ac
	ldi a,(hl)		; $48ad
	ld h,(hl)		; $48ae
	ld l,a			; $48af

	ldi a,(hl)		; $48b0
	ld c,a			; $48b1
--
	ldi a,(hl)		; $48b2
	ld e,a			; $48b3
	ldi a,(hl)		; $48b4
	ld b,a			; $48b5
	ld d,>wc600Block		; $48b6
	ld a,(de)		; $48b8
	call _insertBitsIntoSecretGenerationBuffer		; $48b9
	dec c			; $48bc
	jr nz,--		; $48bd
	pop bc			; $48bf
	ret			; $48c0

;;
; Encodes the given bits into w7SecretGenerationBuffer.
;
; It works by shifting each individual bit in, starting from the end of the buffer. If
; anything overflows it will be lost.
;
; @param	a	Byte to encode
; @param	b	Number of bits to encode
; @addr{48c1}
_insertBitsIntoSecretGenerationBuffer:
	push hl			; $48c1
	push bc			; $48c2
	ld c,a			; $48c3
---
	ld hl,w7SecretGenerationBuffer+19		; $48c4
	ld e,20			; $48c7
	srl c			; $48c9
--
	ld a,(hl)		; $48cb
	rla			; $48cc
	ldd (hl),a		; $48cd
	rla			; $48ce
	rla			; $48cf
	dec e			; $48d0
	jr nz,--		; $48d1
	dec b			; $48d3
	jr nz,---		; $48d4

	; Iterate through all characters to remove anything in the upper 2 bits
	ld hl,w7SecretGenerationBuffer		; $48d6
	ldde $3f,20		; $48d9
--
	ld a,(hl)		; $48dc
	and d			; $48dd
	ldi (hl),a		; $48de
	dec e			; $48df
	jr nz,--		; $48e0

	pop bc			; $48e2
	pop hl			; $48e3
	ret			; $48e4

;;
; Unpacks a secret's data to wTmpcec0. (each entry in "_secretDataToEncodeTable" gets
; a separate byte in the output.)
;
; Input (the secret in ascii) and output (the unpacked data) are both in wTmpcec0.
;
; @param	c	Secret type
; @param[out]	b	$00 if secret was valid, $01 otherwise
; @addr{48e5}
_unpackSecret:
	ld hl,w7SecretText1		; $48e5
	ld b,$40		; $48e8
	call clearMemory		; $48ea
	call _andCWith3		; $48ed
	call _loadSecretBufferFromText		; $48f0
	jr c,@fail			; $48f3

	call _runXorCipherOnSecretBuffer		; $48f5

	; Retrieve checksum in 'e', then remove the checksum bits from the secret buffer
	call _getNumCharactersForSecretType		; $48f8
	ld hl,w7SecretGenerationBuffer-1		; $48fb
	rst_addAToHl			; $48fe
	ld a,(hl)		; $48ff
	and $0f			; $4900
	ld e,a			; $4902
	xor (hl)		; $4903
	ld (hl),a		; $4904

	call _getSecretBufferChecksum		; $4905
	cp e			; $4908
	jr nz,@fail	; $4909

	call @unpackSecretData		; $490b

	; Check the value of "wSecretType" stored in the secret, make sure it's correct
	ld a,(wTmpcec0+1)		; $490e
	cp c			; $4911
	jr nz,@fail	; $4912

	ld b,$00		; $4914
	ret			; $4916
@fail:
	ld b,$01		; $4917
	ret			; $4919

;;
; @addr{491a}
@unpackSecretData:
	ld de,wTmpcec0		; $491a
	ld a,$04 ; Unpack gameID, etc
	call @unpack		; $491f

	ld a,c ; Unpack the meat of the data

;;
; @param	a	Secret type
; @param	de	Address to write the extracted data to
; @addr{4923}
@unpack:
	ld hl,_secretDataToEncodeTable		; $4923
	rst_addDoubleIndex			; $4926
	ldi a,(hl)		; $4927
	ld h,(hl)		; $4928
	ld l,a			; $4929

	ldi a,(hl)		; $492a
	ld b,a			; $492b
@@nextEntry:
	inc hl			; $492c
	ldi a,(hl)		; $492d
	call @readBits		; $492e
	ld (de),a		; $4931
	inc de			; $4932
	dec b			; $4933
	jr nz,@@nextEntry		; $4934
	ret			; $4936

;;
; @param	a	Number of bits to read from the start of w7SecretGenerationBuffer
; @param[out]	a	The value of the bits retrieved
; @addr{4937}
@readBits:
	push bc			; $4937
	push de			; $4938
	push hl			; $4939
	ld b,a			; $493a
	ld c,a			; $493b
	ld d,$00		; $493c
---
	; Rotate the entire buffer left one bit
	ld hl,w7SecretGenerationBuffer+19		; $493e
	ld e,20			; $4941
--
	rl (hl)			; $4943
	ld a,(hl)		; $4945
	rla			; $4946
	rla			; $4947
	dec hl			; $4948
	dec e			; $4949
	jr nz,--		; $494a

	rr d ; Rotate leftmost bit into d
	dec b			; $494e
	jr nz,---		; $494f

	; Result is now in the upper bits of 'd'. We still need to shift it into the lower
	; bits.
	ld a,$08		; $4951
	sub c			; $4953
	ld b,a			; $4954
	ld a,d			; $4955
	jr z,@@end		; $4956
--
	rrca			; $4958
	dec b			; $4959
	jr nz,--		; $495a
@@end:
	pop hl			; $495c
	pop de			; $495d
	pop bc			; $495e
	ret			; $495f

;;
; Loads the data associated with an unpacked secret (ie. for game-transfer secrets, copies
; over player name, animal companion, game type, etc.)
;
; @addr{4960}
_loadUnpackedSecretData:
	call _andCWith3		; $4960
	rst_jumpTable			; $4963
	.dw @type0
	.dw @type1
	.dw @type2
	.dw @type3

@type0: ; Game-transfer secret
@type1:
	ld hl,_secretDataToEncodeTable@entry0		; $496c
	ldi a,(hl)		; $496f
	ld b,a			; $4970
	ld de,wTmpcec0+4 ; Start from +4 to skip the "header"
--
	ld a,(de)		; $4974
	push de			; $4975
	ld e,(hl)		; $4976
	ld d,>wc600Block		; $4977
	ld (de),a		; $4979
	pop de			; $497a
	inc de			; $497b
	inc hl			; $497c
	inc hl			; $497d
	dec b			; $497e
	jr nz,--		; $497f

	; Copy the secret's game ID
	ld hl,wGameID		; $4981
	ld a,(wTmpcec0+2)		; $4984
	ldi (hl),a		; $4987
	ld a,(wTmpcec0+3)		; $4988
	ld (hl),a		; $498b

@type3: ; 5-letter secret
	ret			; $498c

@type2: ; Ring secret
	ld hl,_secretDataToEncodeTable@entry2+1		; $498d
	ld b,$08		; $4990
	ld de,wTmpcec0+4 ; Start from +4 to skip the "header"
--
	ldi a,(hl)		; $4995
	push hl			; $4996
	ld l,a			; $4997
	ld h,>wc600Block		; $4998
	ld a,(de)		; $499a
	or (hl)			; $499b
	ld (hl),a		; $499c
	pop hl			; $499d
	inc de			; $499e
	inc hl			; $499f
	dec b			; $49a0
	jr nz,--		; $49a1
	ret			; $49a3

;;
; @addr{49a4}
_verifyUnpackedSecretGameID:
	; Get the gameID of an unpacked secret
	ld hl,wTmpcec0+2		; $49a4
	ldi a,(hl)		; $49a7
	ld d,(hl)		; $49a8
	ld e,a			; $49a9

	; If the GameID is zero, accept the secret.
	; This means that any secret encoded with GameID 0 works on EVERY file, regardless
	; of that file's game ID. Was this intentional?
	or d			; $49aa
	jr z,@success		; $49ab

	; If nonzero, check that it matches this game's gameID
	ld hl,wGameID		; $49ad
	ldi a,(hl)		; $49b0
	cp e			; $49b1
	jr nz,@fail		; $49b2
	ldi a,(hl)		; $49b4
	cp d			; $49b5
	jr z,@success		; $49b6
@fail:
	ld b,$01		; $49b8
	ret			; $49ba
@success:
	ld b,$00		; $49bb
	ret			; $49bd

;;
; Generates a gameID if one hasn't been calculated yet.
; @addr{49be}
_generateGameIDIfNeeded:
	ld hl,wGameID		; $49be
	ldi a,(hl)		; $49c1
	or (hl)			; $49c2
	ret nz			; $49c3

	; Base the ID on wPlaytimeCounter (which should be pseudo-random).
	ld l,<wPlaytimeCounter+1		; $49c4
	ldd a,(hl)		; $49c6
	and $7f			; $49c7
	ld b,a			; $49c9
	ld a,(hl)		; $49ca
	jr nz,+			; $49cb
--
	; The GameID can't be 0, so read from R_DIV until we get a nonzero value.
	or a			; $49cd
	jr nz,+			; $49ce
	ld a,($ff00+R_DIV)	; $49d0
	jr --			; $49d2
+
	ld l,<wGameID		; $49d4
	ldi (hl),a		; $49d6
	ld (hl),b		; $49d7
	ret			; $49d8

;;
; Copies the data from w7SecretGenerationBuffer to w7SecretText1. The former consists of
; "raw bytes", while the latter is ascii.
;
; @addr{49d9}
_convertSecretBufferToText:
	ld a,c			; $49d9
	ld hl,@secretSpacingData		; $49da
	rst_addDoubleIndex			; $49dd
	ldi a,(hl)		; $49de
	ld b,(hl)		; $49df
	ld c,a			; $49e0
	ld de,w7SecretGenerationBuffer		; $49e1
	ld hl,w7SecretText1		; $49e4
@nextGroup:
	ld a,(bc)		; $49e7
	and $0f			; $49e8
	ret z			; $49ea

	push bc			; $49eb
	ld b,a			; $49ec
@nextSymbol:
	ld a,(de)		; $49ed
	push hl			; $49ee
	ld hl,secretSymbols		; $49ef
	rst_addAToHl			; $49f2
	ld a,(hl)		; $49f3
	pop hl			; $49f4
	ldi (hl),a		; $49f5
	inc de			; $49f6
	dec b			; $49f7
	jr nz,@nextSymbol	; $49f8

	pop bc			; $49fa
	ld a,(bc)		; $49fb
	and $f0			; $49fc
	ldi (hl),a		; $49fe
	inc bc			; $49ff
	jr @nextGroup		; $4a00


; For each secret type, this data tells the above function how to format it (in groups of
; X characters followed by a gap character).
@secretSpacingData:
	.dw @entry0
	.dw @entry1
	.dw @entry2
	.dw @entry3

; Upper digit: character to print after the X characters are copied
; Lower digit: number of characters to copy (0 to stop)

@entry0:
@entry1:
	.db $25 $05 $25 $05 $00
@entry2:
	.db $25 $05 $25 $00
@entry3:
	.db $05 $00


;;
; Loads w7SecretGenerationBuffer based on a secret in ASCII format.
;
; @param	wTmpcec0	Buffer with the secret in text format
; @param[out]	cflag		Set if there's a problem with the secret (invalid char)
; @addr{4a15}
_loadSecretBufferFromText:
	call _getNumCharactersForSecretType		; $4a15
	ld hl,wTmpcec0		; $4a18
	ld de,w7SecretGenerationBuffer		; $4a1b
--
	ldi a,(hl)		; $4a1e
	call @textCharacterToByte		; $4a1f
	ret c			; $4a22
	ld (de),a		; $4a23
	inc de			; $4a24
	dec b			; $4a25
	jr nz,--		; $4a26
	ret			; $4a28

;;
; @param	a	Ascii symbol
; @param[out]	a	Byte corresponding to value
; @param[out]	cflag	Set if there's no byte corresponding to it
; @addr{4a29}
@textCharacterToByte:
	push hl			; $4a29
	push bc			; $4a2a
	ld hl,secretSymbols		; $4a2b
	ldbc $40,$00		; $4a2e
--
	cp (hl)			; $4a31
	jr z,@end		; $4a32
	inc hl			; $4a34
	inc c			; $4a35
	dec b			; $4a36
	jr nz,--		; $4a37
	scf			; $4a39
@end:
	ld a,c			; $4a3a
	pop bc			; $4a3b
	pop hl			; $4a3c
	ret			; $4a3d

;;
; This xors all bytes in w7SecretGenerationBuffer with the corresponding cipher
; (determined by the first 3 bits in the secret buffer).
;
; @addr{4a3e}
_runXorCipherOnSecretBuffer:
	call _getNumCharactersForSecretType		; $4a3e

	; Determine cipher ID from the first 3 bits of the secret (corresponds to
	; wSecretXorCipherIndex)
	ld a,(w7SecretGenerationBuffer)		; $4a41
	and $38			; $4a44
	rrca			; $4a46
	ld de,_secretXorCipher		; $4a47
	call addAToDe		; $4a4a

	ld hl,w7SecretGenerationBuffer		; $4a4d
	ld a,(de)		; $4a50

	; For the first byte only, don't xor the upper bits so that the cipher ID remains
	; intact.
	and $07
--
	xor (hl)		; $4a53
	ldi (hl),a		; $4a54
	inc de			; $4a55
	ld a,(de)		; $4a56
	dec b			; $4a57
	jr nz,--		; $4a58
	ret			; $4a5a

;;
; @param[out]	a	The last 4 bits of the sum of all bytes in w7SecretGenerationBuffer
; @addr{4a5b}
_getSecretBufferChecksum:
	ld hl,w7SecretGenerationBuffer		; $4a5b
	ld b,20			; $4a5e
	xor a			; $4a60
--
	add (hl)		; $4a61
	inc hl			; $4a62
	dec b			; $4a63
	jr nz,--		; $4a64
	and $0f			; $4a66
	ret			; $4a68

;;
; For smaller secrets (length < 20), this shifts the contents of the secret to the front
; of the buffer.
;
; @param	c	Secret type
; @addr{4a69}
_shiftSecretBufferContentsToFront:
	call _getNumCharactersForSecretType		; $4a69
	ld a,20		; $4a6c
	sub b			; $4a6e
	ret z			; $4a6f

	ld de,w7SecretGenerationBuffer		; $4a70
	ld h,d			; $4a73
	ld l,e			; $4a74
	rst_addAToHl			; $4a75
--
	ldi a,(hl)		; $4a76
	ld (de),a		; $4a77
	inc de			; $4a78
	dec b			; $4a79
	jr nz,--		; $4a7a
	ret			; $4a7c

;;
; @addr{4a7d}
_andCWith3:
	ld a,c			; $4a7d
	and $03			; $4a7e
	ld c,a			; $4a80
	ret			; $4a81


; This lists the data that a particular secret type must encode.
_secretDataToEncodeTable:
	.dw @entry0
	.dw @entry1
	.dw @entry2
	.dw @entry3
	.dw @header

; Data format:
;   b0: the byte to encode (somewhere in the $c6XX region)
;   b1: the number of bits from that byte to encode

@header: ; Prefixed to every secret type
	.db $04
	.db <wSecretXorCipherIndex	$03
	.db <wSecretType		$02
	.db <wGameID			$08
	.db <wGameID+1			$07

	; Totals to 20 bits

@entry0: ; "Game transfer" secret
@entry1:
	.db $11                     ; Bit number:
	.db <wFileIsHeroGame	$01 ; 20
	.db <wWhichGame		$01 ; 21
	.db <wLinkName		$08 ; 22
	.db <wKidName		$08 ; 30
	.db <wLinkName+1	$08 ; 38
	.db <wKidName+1		$08 ; 46
	.db <wChildStatus	$06 ; 54
	.db <wLinkName+2	$08 ; 60
	.db <wKidName+2		$08 ; 68
	.db <wObtainedRingBox	$01 ; 76
	.db <wLinkName+3	$08 ; 77
	.db <wAnimalCompanion	$04 ; 85
	.db <wLinkName+4	$08 ; 89
	.db <wKidName+3		$08 ; 97
	.db <wFileIsLinkedGame	$01 ; 105
	.db <wKidName+4		$08 ; 106
	.db <wLinkName+5	$02 ; 114 (This is always 00)

	; Totals to 96 bits
	; (plus 20 from header, plus 4 for checksum = 120 bits = 20 6-bit characters)

@entry2: ; Ring secret
	.db $09
	.db <wRingsObtained+1 $08
	.db <wRingsObtained+5 $08
	.db <wRingsObtained+7 $08
	.db <wRingsObtained+3 $08
	.db <wRingsObtained+0 $08
	.db <wRingsObtained+4 $08
	.db <wRingsObtained+2 $08
	.db <wRingsObtained+6 $08
	.db <wLinkName+5 $02 ; This is always 0

	; Totals to 66 bits

@entry3: ; Normal secret
	.db $01
	.db <wShortSecretIndex $06

;;
; @param	c	Secret type
; @param[out]	a,b	Number of characters in secret
; @addr{4ace}
_getNumCharactersForSecretType:
	ld a,c			; $4ace
	ld hl,@lengths		; $4acf
	rst_addAToHl			; $4ad2
	ld a,(hl)		; $4ad3
	ld b,a			; $4ad4
	ret			; $4ad5

@lengths:
	.db 20 20 15 5

; The xor cipher works by starting at position [wSecretXorCipherIndex]*4 in this dataset
; and subsequently xoring every byte in the secret with the proceeding values.
; (The bits corresponding to the cipher index in the secret are not xored, though, so that
; it can be deciphered properly.)
_secretXorCipher:
	.db $15 $23 $2e $04 $0d $3f $1a $10
	.db $3a $2f $1e $20 $0f $3e $36 $37
	.db $09 $29 $3b $31 $02 $16 $3d $38
	.db $28 $13 $34 $32 $01 $0b $0a $35
	.db $0e $1b $12 $2c $21 $2d $25 $30
	.db $19 $2a $06 $39 $3c $17 $33 $18


;;
; Used for CUTSCENE_FLAMES_FLICKERING and CUTSCENE_TWINROVA_SACRIFICE.
;
; @addr{4b0a}
twinrovaCutsceneCaller:
	ld a,c			; $4b0a
	rst_jumpTable			; $4b0b
	.dw _cutscene18_body
	.dw _cutscene19_body

;;
; @addr{4b10}
_incCutsceneState:
	ld hl,wCutsceneState		; $4b10
	inc (hl)		; $4b13
	ret			; $4b14

;;
; Unused
; @addr{4b15}
_incTmpcbb3:
	ld hl,wTmpcbb3		; $4b15
	inc (hl)		; $4b18
	ret			; $4b19

;;
; @addr{4b1a}
_decTmpcbb4:
	ld hl,wTmpcbb4		; $4b1a
	dec (hl)		; $4b1d
	ret			; $4b1e

;;
; @addr{4b1f}
_setScreenShakeCounterTo255:
	ld a,$ff		; $4b1f
	jp setScreenShakeCounter		; $4b21

;;
; State 0: screen fadeout
; @addr{4b24}
_twinrovaCutscene_state0:
	ld a,$04		; $4b24
	call fadeoutToWhiteWithDelay		; $4b26
	ld hl,wTmpcbb3		; $4b29
	ld b,$10		; $4b2c
	call clearMemory		; $4b2e
	jr _incCutsceneState		; $4b31

;;
; State 1: fading out, then initialize fadein to zelda sacrifice room
; @addr{4b33}
_twinrovaCutscene_state1:
	ld a,(wPaletteThread_mode)		; $4b33
	or a			; $4b36
	ret nz			; $4b37

	call _incCutsceneState		; $4b38

	ld a,$f1 ; Room with zelda and torches
	ld (wActiveRoom),a		; $4b3d
	call _twinrovaCutscene_fadeinToRoom		; $4b40

	call refreshObjectGfx		; $4b43

	ld hl,w1Link.yh		; $4b46
	ld (hl),$38		; $4b49
	inc l			; $4b4b
	inc l			; $4b4c
	ld (hl),$78		; $4b4d

	call resetCamera		; $4b4f

	ld hl,objectData.objectData4022
	call parseGivenObjectData		; $4b55

	ld a,PALH_ac		; $4b58
	call loadPaletteHeader		; $4b5a

	ld a,$01		; $4b5d
	ld (wScrollMode),a		; $4b5f

	call loadCommonGraphics		; $4b62

	ld a,$04		; $4b65
	call fadeinFromWhiteWithDelay		; $4b67
	ld a,$02		; $4b6a
	jp loadGfxRegisterStateIndex		; $4b6c

;;
; @addr{4b6f}
_twinrovaCutscene_fadeinToRoom:
	call disableLcd		; $4b6f
	call clearScreenVariablesAndWramBank1		; $4b72
	call loadScreenMusicAndSetRoomPack		; $4b75
	call loadAreaData		; $4b78
	call loadAreaGraphics		; $4b7b
	jp func_131f		; $4b7e

;;
; CUTSCENE_FLAMES_FLICKERING
; @addr{4b81}
_cutscene18_body:
	ld a,(wCutsceneState)		; $4b81
	rst_jumpTable			; $4b84
	.dw _twinrovaCutscene_state0
	.dw _twinrovaCutscene_state1
	.dw _twinrovaCutscene_state2
	.dw _twinrovaCutscene_state3
	.dw _cutscene18_state4
	.dw _cutscene18_state5

;;
; State 2: waiting for fadein to finish
; @addr{4b91}
_twinrovaCutscene_state2:
	ld a,(wPaletteThread_mode)		; $4b91
	or a			; $4b94
	ret nz			; $4b95
	ld a,$01		; $4b96
	ld (wTmpcbb4),a		; $4b98
	jp _incCutsceneState		; $4b9b

;;
; State 3: initializes stuff for state 4
; @addr{4b9e}
_twinrovaCutscene_state3:
	call _decTmpcbb4		; $4b9e
	ret nz			; $4ba1

	ld (hl),180 ; Wait in state 4 for 180 frames

	call _twinrovaCutscene_deleteAllInteractionsExceptFlames		; $4ba4
	call _twinrovaCutscene_loadAngryFlames		; $4ba7
	ld a,SND_OPENING		; $4baa
	call playSound		; $4bac
	jp _incCutsceneState		; $4baf

;;
; State 4: screen shaking, flames flickering with zelda on pedestal
; @addr{4bb2}
_cutscene18_state4:
	call _setScreenShakeCounterTo255		; $4bb2
	ld a,(wFrameCounter)		; $4bb5
	and $3f			; $4bb8
	jr nz,+			; $4bba
	ld a,SND_OPENING		; $4bbc
	call playSound		; $4bbe
+
	call _decTmpcbb4		; $4bc1
	ret nz			; $4bc4

	; Fadeout
	ld a,$04		; $4bc5
	call fadeoutToWhiteWithDelay		; $4bc7

	jp _incCutsceneState		; $4bca

;;
; State 5: fading out again. When done, it fades in to the next room, and the cutscene's
; over.
; @addr{4bcd}
_cutscene18_state5:
	call _setScreenShakeCounterTo255		; $4bcd
	ld a,(wPaletteThread_mode)		; $4bd0
	or a			; $4bd3
	ret nz			; $4bd4

	; Load twinrova fight room, start a fadein, then exit cutscene
	ld a,$f5		; $4bd5
	ld (wActiveRoom),a		; $4bd7
	call _twinrovaCutscene_fadeinToRoom		; $4bda

	call getFreeEnemySlot		; $4bdd
	ld (hl),ENEMYID_TWINROVA		; $4be0
	ld l,Enemy.var03		; $4be2
	set 7,(hl)		; $4be4

	ld hl,w1Link.enabled		; $4be6
	ld (hl),$03		; $4be9
	ld l,<w1Link.yh		; $4beb
	ld (hl),$78		; $4bed
	inc l			; $4bef
	inc l			; $4bf0
	ld (hl),$78		; $4bf1

	call resetCamera		; $4bf3
	ld a,$01		; $4bf6
	ld (wCutsceneIndex),a		; $4bf8
	ld a,$01		; $4bfb
	ld (wScrollMode),a		; $4bfd
	call loadCommonGraphics		; $4c00

	ld a,$02		; $4c03
	call fadeinFromWhiteWithDelay		; $4c05
	ld a,$02		; $4c08
	jp loadGfxRegisterStateIndex		; $4c0a

;;
; @addr{4c0d}
_twinrovaCutscene_deleteAllInteractionsExceptFlames:
	ldhl FIRST_DYNAMIC_INTERACTION_INDEX, Interaction.start		; $4c0d
@next:
	ld l,Interaction.start		; $4c10
	ldi a,(hl)		; $4c12
	or a			; $4c13
	jr z,+			; $4c14
	ldi a,(hl)		; $4c16
	cp INTERACID_TWINROVA_FLAME			; $4c17
	call z,@delete		; $4c19
+
	inc h			; $4c1c
	ld a,h			; $4c1d
	cp $e0			; $4c1e
	jr c,@next		; $4c20
	ret			; $4c22

@delete:
	dec l			; $4c23
	ld b,$40		; $4c24
	jp clearMemory		; $4c26

;;
; Loads the "angry-looking" version of the flames.
; @addr{4c29}
_twinrovaCutscene_loadAngryFlames:
	ld a,PALH_af		; $4c29
	call loadPaletteHeader		; $4c2b
	ld hl,objectData.objectData402f		; $4c2e
	jp parseGivenObjectData		; $4c31

;;
; CUTSCENE_TWINROVA_SACRIFICE
; @addr{4c34}
_cutscene19_body:
	ld a,(wCutsceneState)		; $4c34
	rst_jumpTable			; $4c37
	.dw _twinrovaCutscene_state0
	.dw _twinrovaCutscene_state1
	.dw _twinrovaCutscene_state2
	.dw _twinrovaCutscene_state3
	.dw _cutscene19_state4
	.dw _cutscene19_state5
	.dw _cutscene19_state6
	.dw _cutscene19_state7
	.dw _cutscene19_state8
	.dw _cutscene19_state9

;;
; After fading in to zelda on the pedestal, this shows the "angry flames" and waits for
; 3 seconds before striking the first flame with lightning.
; @addr{4c4c}
_cutscene19_state4:
	call _decTmpcbb4		; $4c4c
	ret nz			; $4c4f

	ld (hl),20		; $4c50
	ld bc,$1878		; $4c52
_cutscene19_strikeFlameWithLightning:
	call _twinrovaCutscene_createLightningStrike		; $4c55
	jp _incCutsceneState		; $4c58

;;
; State 5: wait before striking the 2nd flame with lightning.
; @addr{4c5b}
_cutscene19_state5:
	call _decTmpcbb4		; $4c5b
	ret nz			; $4c5e

	ld (hl),20		; $4c5f
	ld bc,$48a8		; $4c61
	jr _cutscene19_strikeFlameWithLightning		; $4c64

;;
; State 6: wait before striking the 3rd flame with lightning.
; @addr{4c66}
_cutscene19_state6:
	call _decTmpcbb4		; $4c66
	ret nz			; $4c69

	ld (hl),40		; $4c6a
	ld bc,$4848		; $4c6c
	jr _cutscene19_strikeFlameWithLightning		; $4c6f

;;
; State 7: wait before shaking screen around
; @addr{4c71}
_cutscene19_state7:
	call _decTmpcbb4		; $4c71
	ret nz			; $4c74

	ld (hl),120		; $4c75
	ld a,SND_BOSS_DEAD		; $4c77
	call playSound		; $4c79
	jp _incCutsceneState		; $4c7c

;;
; State 8: shake the screen and repeatedly flash the screen white
; @addr{4c7f}
_cutscene19_state8:
	call _setScreenShakeCounterTo255		; $4c7f
	ld a,(wFrameCounter)		; $4c82
	and $07			; $4c85
	call z,fastFadeinFromWhite		; $4c87
	call _decTmpcbb4		; $4c8a
	ret nz			; $4c8d

	ld a,$04		; $4c8e
	call fadeoutToWhiteWithDelay		; $4c90
	ld a,SND_FADEOUT		; $4c93
	call playSound		; $4c95
	jp _incCutsceneState		; $4c98

;;
; State 9: wait before fading back to twinrova. Cutscene ends here.
; @addr{4c9b}
_cutscene19_state9:
	call _setScreenShakeCounterTo255		; $4c9b
	ld a,(wPaletteThread_mode)		; $4c9e
	or a			; $4ca1
	ret nz			; $4ca2

	call clearScreenVariablesAndWramBank1		; $4ca3
	ld a,CUTSCENE_INGAME		; $4ca6
	ld (wCutsceneIndex),a		; $4ca8
	ld a,$01		; $4cab
	ld (wScrollMode),a		; $4cad

	call getFreeEnemySlot		; $4cb0
	ld (hl),ENEMYID_GANON		; $4cb3

	ld a,SNDCTRL_STOPMUSIC		; $4cb5
	jp playSound		; $4cb7

;;
; @param	bc	Position to strike
; @addr{4cba}
_twinrovaCutscene_createLightningStrike:
	call getFreePartSlot		; $4cba
	ret nz			; $4cbd
	ld (hl),PARTID_LIGHTNING		; $4cbe
	inc l			; $4cc0
	inc (hl)		; $4cc1
	ld l,Part.yh		; $4cc2
	ld (hl),b		; $4cc4
	inc l			; $4cc5
	inc l			; $4cc6
	ld (hl),c		; $4cc7
	ret			; $4cc8

;;
; This function is part of the main loop until the player reaches the file select screen.
; @addr{4cc9}
runIntro:
	ldh a,(<hSerialInterruptBehaviour)	; $4cc9
	or a			; $4ccb
	jr z,+			; $4ccc

	call serialFunc_0c8d		; $4cce
	ld a,$09		; $4cd1
	ld (wTmpcbb4),a		; $4cd3
	jr @nextStage			; $4cd6
+
	call serialFunc_0c85		; $4cd8
	ld a,$03		; $4cdb
	ldh (<hFFBE),a	; $4cdd
	xor a			; $4cdf
	ldh (<hFFBF),a	; $4ce0
	ld a,(wKeysJustPressed)		; $4ce2
	and BTN_START		; $4ce5
	jr z,_intro_runStage		; $4ce7

@nextStage:
	ldh a,(<hIntroInputsEnabled)	; $4ce9
	add a			; $4ceb
	jr z,_intro_runStage		; $4cec

	ld a,(wIntroStage)		; $4cee
	cp $03			; $4cf1
	jr nz,_intro_gotoTitlescreen	; $4cf3

;;
; @addr{4cf5}
_intro_runStage:
	ld a,(wIntroStage)		; $4cf5
	rst_jumpTable			; $4cf8
	.dw _intro_uninitialized
	.dw _intro_capcomScreen
	.dw intro_cinematic
	.dw _intro_titlescreen
	.dw _intro_restart

;;
; Advance the intro to the next stage (eg. cinematic -> titlescreen)
; @addr{4d03}
_intro_gotoTitlescreen:
	call clearPaletteFadeVariables		; $4d03
	call _cutscene_clearObjects		; $4d06
	ld hl,wIntroVar		; $4d09
	xor a			; $4d0c
	ldd (hl),a		; $4d0d
	ldh (<hCameraY),a	; $4d0e
	ld (wTmpcbb6),a		; $4d10
	ld (hl),$03 ; hl = wIntroStage
	dec a			; $4d15
	ld (wAreaAnimation),a		; $4d16
	jr _intro_runStage	; $4d19

;;
; @addr{4d1b}
_intro_restart:
	xor a			; $4d1b
	ld (wIntroStage),a		; $4d1c
	ld (wIntroVar),a		; $4d1f
	ret			; $4d22

;;
; @addr{4d23}
_intro_gotoNextStage:
	call enableIntroInputs		; $4d23
	call clearDynamicInteractions		; $4d26
	ld hl,wIntroStage		; $4d29
	inc (hl)		; $4d2c
	inc l			; $4d2d
	ld (hl),$00 ; [wIntroVar] = 0
	jp clearPaletteFadeVariables		; $4d30

;;
; @addr{4d33}
_intro_incState:
	ld hl,wIntroVar		; $4d33
	inc (hl)		; $4d36
	ret			; $4d37

;;
; @addr{4d38}
_intro_uninitialized:
	ld hl,wIntroStage		; $4d38
	inc (hl)		; $4d3b
;;
; @addr{4d3c}
_intro_capcomScreen:
	ld a,(wIntroVar)		; $4d3c
	rst_jumpTable			; $4d3f
	.dw @state0
	.dw @state1
	.dw @state2

;;
; @addr{4d46}
@state0:
	call restartSound		; $4d46

	call clearVram		; $4d49
	ld a,$01		; $4d4c
	call loadGfxHeader		; $4d4e
	ld a,PALH_01		; $4d51
	call loadPaletteHeader		; $4d53

	ld hl,wTmpcbb3		; $4d56
	ld (hl),208		; $4d59
	inc hl			; $4d5b
	ld (hl),$00 ; [wTmpcbb4] = 0

	call _intro_incState		; $4d5e
	call fadeinFromWhite		; $4d61
	xor a			; $4d64
	jp loadGfxRegisterStateIndex		; $4d65

;;
; Fading in, waiting
; @addr{4d68}
@state1:
	ld hl,wTmpcbb3		; $4d68
	call decHlRef16WithCap		; $4d6b
	ret nz			; $4d6e

	call _intro_incState		; $4d6f
	jp fadeoutToWhite		; $4d72

;;
; Fading out
; @addr{4d75}
@state2:
	ld a,(wPaletteThread_mode)		; $4d75
	or a			; $4d78
	ret nz			; $4d79

	xor a			; $4d7a
	ld hl,wIntroStage		; $4d7b
	ld (hl),$02		; $4d7e
	inc l			; $4d80
	ld (hl),a ; [wIntroVar] = 0
	ld (wIntro.cinematicState),a		; $4d82
	jp enableIntroInputs		; $4d85

;;
; @addr{4d88}
_intro_titlescreen:
	call getRandomNumber_noPreserveVars		; $4d88
	call @runState		; $4d8b
	call clearOam		; $4d8e

.ifdef ROM_AGES
	ld hl,bank3f.titlescreenMakuSeedSprite		; $4d91
	ld e,:bank3f.titlescreenMakuSeedSprite		; $4d94
	call addSpritesFromBankToOam		; $4d96

	ld a,(wTmpcbb3)		; $4d99
	and $20			; $4d9c
	ret nz			; $4d9e
	ld hl,bank3f.titlescreenPressStartSprites		; $4d9f
	ld e,:bank3f.titlescreenPressStartSprites		; $4da2
	jp addSpritesFromBankToOam		; $4da4

.else; ROM_SEASONS

	ld hl,titlescreenMakuSeedSprite
	call addSpritesToOam

	ld a,(wTmpcbb3)
	and $20
	ret nz
	ld hl,titlescreenPressStartSprites
	jp addSpritesToOam
.endif


;;
; @addr{4da7}
@runState:
	ld a,(wIntroVar)		; $4da7
	rst_jumpTable			; $4daa
	.dw _intro_titlescreen_state0
	.dw _intro_titlescreen_state1
	.dw _intro_titlescreen_state2
	.dw _intro_titlescreen_state3

;;
; @addr{4db3}
_intro_titlescreen_state0:
	call restartSound		; $4db3

	; Stop any irrelevant threads.
	ld a,THREAD_1		; $4db6
	call threadStop		; $4db8
	call stopTextThread		; $4dbb

	call disableLcd		; $4dbe
	ld a,GFXH_02		; $4dc1
	call loadGfxHeader		; $4dc3
	ld a,PALH_03		; $4dc6
	call loadPaletteHeader		; $4dc8

	; cbb3-cbb4 used as a 2-byte counter until automatically exiting
	ld hl,wTmpcbb3		; $4dcb
	ld a,$60		; $4dce
	ldi (hl),a		; $4dd0
	ld a,$09		; $4dd1
	ldi (hl),a ; [wTmpcbb4] = $09

	call _intro_incState		; $4dd4

	ld a,MUS_TITLESCREEN		; $4dd7
	call playSound		; $4dd9

	ld a,$04		; $4ddc
	jp loadGfxRegisterStateIndex		; $4dde

;;
; State 1: waiting for player to press start
; @addr{4de1}
_intro_titlescreen_state1:
	ld a,(wKeysJustPressed)		; $4de1
	and BTN_START			; $4de4
	jr nz,@pressedStart	; $4de6

	; Check to automatically exit the titlescreen
	ld hl,wTmpcbb3		; $4de8
	call decHlRef16WithCap		; $4deb
	ret nz			; $4dee
	ld a,$02		; $4def
	jr @gotoState		; $4df1

@pressedStart:
	ld a,SND_SELECTITEM		; $4df3
	call playSound		; $4df5
	call serialFunc_0c7e		; $4df8
	ld a,$03		; $4dfb
@gotoState:
	ld (wIntroVar),a		; $4dfd
	ld a,SNDCTRL_FAST_FADEOUT		; $4e00
	call playSound		; $4e02
	jp fadeoutToWhite		; $4e05

;;
; State 2: fading out to replay intro cinematic
; @addr{4e08}
_intro_titlescreen_state2:
	ld a,(wPaletteThread_mode)		; $4e08
	or a			; $4e0b
	ret nz			; $4e0c
	jp _intro_gotoNextStage		; $4e0d

;;
; State 3: fading out to go to file select
; @addr{4e10}
_intro_titlescreen_state3:
	ld a,(wPaletteThread_mode)		; $4e10
	or a			; $4e13
	ret nz			; $4e14

	; Initialize file select thread, stop this thread
	ld a,THREAD_1		; $4e15
	ld bc,fileSelectThreadStart		; $4e17
	call threadRestart		; $4e1a
	jp stubThreadStart		; $4e1d

.ifdef ROM_SEASONS

; In Ages these sprites are located elsewhere

titlescreenMakuSeedSprite:
	.db $12
	.db $51 $7a $56 $04
	.db $50 $82 $74 $04
	.db $58 $7a $6a $07
	.db $58 $82 $6c $07
	.db $58 $8a $6e $07
	.db $48 $90 $62 $06
	.db $44 $8d $68 $06
	.db $54 $8a $54 $03
	.db $54 $82 $52 $03
	.db $54 $7a $50 $03
	.db $40 $85 $66 $06
	.db $40 $7f $64 $06
	.db $41 $70 $60 $06
	.db $54 $76 $5a $06
	.db $44 $68 $5e $26
	.db $64 $7a $70 $03
	.db $64 $82 $72 $03
	.db $64 $8a $70 $23

titlescreenPressStartSprites:
	.db $0a
	.db $80 $2c $38 $00
	.db $80 $34 $3a $00
	.db $80 $3c $3c $00
	.db $80 $44 $3e $00
	.db $80 $4c $3e $00
	.db $80 $5c $3e $00
	.db $80 $64 $40 $00
	.db $80 $6c $42 $00
	.db $80 $74 $3a $00
	.db $80 $7c $40 $00


.endif

;;
; @addr{4e20}
runIntroCinematic:
	ld a,(wIntro.cinematicState)
	rst_jumpTable			; $4e23
	.dw _introCinematic_ridingHorse
	.dw _introCinematic_inTemple
	.dw _introCinematic_preTitlescreen

.ifdef ROM_AGES

;;
; Covers intro sections after the capcom screen and before the temple scene.
; @addr{4e2a}
_introCinematic_ridingHorse:
	ld a,(wIntroVar)		; $4e2a
	rst_jumpTable			; $4e2d
	.dw _introCinematic_ridingHorse_state0
	.dw _introCinematic_ridingHorse_state1
	.dw _introCinematic_ridingHorse_state2
	.dw _introCinematic_ridingHorse_state3
	.dw _introCinematic_ridingHorse_state4
	.dw _introCinematic_ridingHorse_state5
	.dw _introCinematic_ridingHorse_state6
	.dw _introCinematic_ridingHorse_state7
	.dw _introCinematic_ridingHorse_state8
	.dw _introCinematic_ridingHorse_state9
	.dw _introCinematic_ridingHorse_state10

;;
; State 0: initialization
; @addr{4e44}
_introCinematic_ridingHorse_state0:
	call disableLcd		; $4e44
	ld hl,wOamEnd		; $4e47
	ld bc,$d000-wOamEnd	; $4e4a
	call clearMemoryBc		; $4e4d

	ld a,:w4TileMap		; $4e50
	ld ($ff00+R_SVBK),a	; $4e52
	ld hl,w4TileMap		; $4e54
	ld bc,$0120		; $4e57
	call clearMemoryBc		; $4e5a

	ld hl,w4AttributeMap		; $4e5d
	ld bc,$0120		; $4e60
	call clearMemoryBc		; $4e63
	ld a,$01		; $4e66
	ld ($ff00+R_SVBK),a	; $4e68

	call clearOam		; $4e6a
	ld a,<wOam+$10		; $4e6d
	ldh (<hOamTail),a	; $4e6f

	ld a,GFXH_9b		; $4e71
	call loadGfxHeader		; $4e73
	ld a,PALH_90		; $4e76
	call loadPaletteHeader		; $4e78

	; Use cbb3-cbb4 as a 2-byte counter; wait for 0x15e=350 frames
	ld hl,wTmpcbb3		; $4e7b
	ld (hl),$5e		; $4e7e
	inc hl			; $4e80
	ld (hl),$01		; $4e81

	ld a,$20		; $4e83
	ld ($cbb8),a		; $4e85
	ld a,$10		; $4e88
	ld (wTmpcbb9),a		; $4e8a
	ld a,$22		; $4e8d
	ld (wTmpcbb6),a		; $4e8f
	xor a			; $4e92
	ld (wTmpcbba),a		; $4e93

	ld a,MUS_INTRO_1		; $4e96
	call playSound		; $4e98

	ld a,$0b		; $4e9b
	call fadeinFromWhiteWithDelay		; $4e9d

	; The "bars" at the top and bottom need to be black
	ld hl,wLockBG7Color3ToBlack		; $4ea0
	ld (hl),$01		; $4ea3

	; Load Link and Bird objects
	ld hl,objectData.objectData4037		; $4ea5
	call parseGivenObjectData		; $4ea8

	ld a,$17		; $4eab
	call loadGfxRegisterStateIndex		; $4ead

	ld a,(wGfxRegs2.LCDC)		; $4eb0
	ld (wGfxRegs6.LCDC),a		; $4eb3
	xor a			; $4eb6
	ldh (<hCameraX),a	; $4eb7
	jp _intro_incState		; $4eb9

;;
; State 1: fading into the sunset
; @addr{4ebc}
_introCinematic_ridingHorse_state1:
	call _introCinematic_moveBlackBarsIn		; $4ebc
	ld hl,wTmpcbb3		; $4ebf
	call decHlRef16WithCap		; $4ec2
	ret nz			; $4ec5

	ld (hl),$06		; $4ec6
	call clearPaletteFadeVariablesAndRefreshPalettes		; $4ec8
	ld a,$06		; $4ecb
	ldh (<hNextLcdInterruptBehaviour),a	; $4ecd
	jp _intro_incState		; $4ecf

;;
; State 2: scrolling down to reveal Link on horse
; @addr{4ed2}
_introCinematic_ridingHorse_state2:
	call _introCinematic_ridingHorse_updateScrollingGround		; $4ed2
	call decCbb3		; $4ed5
	ret nz			; $4ed8

	; Set counter to 6 frames (so screen scrolls down once every 6 frames)
	ld (hl),$06		; $4ed9

	ld hl,wGfxRegs2.SCY		; $4edb
	inc (hl)		; $4ede
	ld a,(hl)		; $4edf
	ldh (<hCameraY),a ; Must set CameraY for sprites to scroll correctly

	; Go to next state once we scroll this far down
	cp $48			; $4ee2
	ret nz			; $4ee4
	ld a,126		; $4ee5
	ld (wTmpcbb3),a		; $4ee7
	jp _intro_incState		; $4eea

;;
; Decrements the SCX value for the scrolling ground, and recalculates the value of LYC to
; use for producing the scrolling effect for the ground.
; @addr{4eed}
_introCinematic_ridingHorse_updateScrollingGround:
	ld a,$a8		; $4eed
	ld hl,wGfxRegs2.SCY		; $4eef
	sub (hl)		; $4ef2
	cp $78			; $4ef3
	jr c,+			; $4ef5
	ld a,$c7		; $4ef7
+
	ld (wGfxRegs2.LYC),a		; $4ef9
	ld a,(hl)		; $4efc
	ld hl,wGfxRegs6.SCY		; $4efd
	ldi (hl),a ; SCY should not change at hblank, so copy the value

	ld a,(wIntro.frameCounter) ; Only decrement SCX every other frame
	and $01			; $4f04
	ret nz			; $4f06
	dec (hl) ; hl = wGfxRegs6.SCX
	ret			; $4f08

;;
; State 3: camera has scrolled all the way down; not doing anything for a bit
; @addr{4f09}
_introCinematic_ridingHorse_state3:
	call _introCinematic_ridingHorse_updateScrollingGround		; $4f09
	call decCbb3		; $4f0c
	ret nz			; $4f0f

	; Initialize stuff for state 4

	ld (hl),$20		; $4f10
	inc hl			; $4f12
	ld (hl),$01		; $4f13

	ld a,PALH_96		; $4f15
	call loadPaletteHeader		; $4f17
	ld a,UNCMP_GFXH_38		; $4f1a
	call loadUncompressedGfxHeader		; $4f1c

	ld a,$18		; $4f1f
	ld (wTmpcbba),a		; $4f21
	call loadGfxRegisterStateIndex		; $4f24

	xor a			; $4f27
	ldh (<hCameraY),a	; $4f28
	ld (wTmpcbbc),a		; $4f2a

	ldbc INTERACID_INTRO_SPRITE, $03		; $4f2d
	call _createInteraction		; $4f30

	ld a,$0d		; $4f33
	ld (wTmpcbb6),a		; $4f35
	ld a,$3c		; $4f38
	ld (wTmpcbbb),a		; $4f3a
	ld a,$03		; $4f3d
	ldh (<hNextLcdInterruptBehaviour),a	; $4f3f
	jp _intro_incState		; $4f41

;;
; State 4: Link riding horse toward camera
; @addr{4f44}
_introCinematic_ridingHorse_state4:
	call @drawLinkOnHorseAndScrollScreen		; $4f44
	ld hl,wTmpcbb3		; $4f47
	call decHlRef16WithCap		; $4f4a
	ret nz			; $4f4d

	ld a,UNCMP_GFXH_36		; $4f4e
	call loadUncompressedGfxHeader		; $4f50

	; After calling "loadUncompressedGfxHeader", hl points to rom. They almost
	; certainly didn't intend to write there. They probably intended for hl to point
	; to wTmpcbb3, and set the counter for the next state?
	; It makes no difference, though, since the next state doesn't use wTmpcbb3.
	ld (hl),90		; $4f53

	ld a,PALH_9b		; $4f55
	call loadPaletteHeader		; $4f57
	call clearDynamicInteractions		; $4f5a
	call clearOam		; $4f5d
	ld a,$19		; $4f60
	call loadGfxRegisterStateIndex		; $4f62

	ld a,$48		; $4f65
	ld (wGfxRegs1.LYC),a		; $4f67
	ld (wGfxRegs2.WINY),a		; $4f6a
	jp _intro_incState		; $4f6d

;;
; @addr{4f70}
@drawLinkOnHorseAndScrollScreen:
	ld hl,bank3f.linkOnHorseFacingCameraSprite		; $4f70
	ld e,:bank3f.linkOnHorseFacingCameraSprite		; $4f73
	call addSpritesFromBankToOam		; $4f75

	; Scroll the top, cloudy layer right every 32 frames
	ld a,(wIntro.frameCounter)		; $4f78
	and $1f			; $4f7b
	jr nz,+			; $4f7d
	ld hl,wGfxRegs1.SCX		; $4f7f
	dec (hl)		; $4f82
+
	; Scroll the mountain layer right every 6 frames
	ld hl,wTmpcbb6		; $4f83
	dec (hl)		; $4f86
	jr nz,+			; $4f87
	ld (hl),$0d		; $4f89
	ld hl,wGfxRegs2.SCX		; $4f8b
	dec (hl)		; $4f8e
+
	; Change link's palette every 60 frames to gradually get lighter
	ld hl,wTmpcbbb		; $4f8f
	dec (hl)		; $4f92
	ret nz			; $4f93
	ld (hl),60		; $4f94
	inc hl			; $4f96
	ld a,(hl)		; $4f97
	cp $03			; $4f98
	ret z			; $4f9a

	inc (hl)		; $4f9b
	ld hl,@linkPalettes		; $4f9c
	rst_addAToHl			; $4f9f
	ld a,(hl)		; $4fa0
	jp loadPaletteHeader		; $4fa1

@linkPalettes:
	.db PALH_a4
	.db PALH_a5
	.db PALH_a6

;;
; State 5: closeup of Link's face; face is moving left
; @addr{4fa7}
_introCinematic_ridingHorse_state5:
	call _introCinematic_moveBlackBarsOut		; $4fa7
	ld hl,wGfxRegs2.SCX		; $4faa
	ld a,(hl)		; $4fad
	add $08			; $4fae
	ld (hl),a		; $4fb0
	cp $60			; $4fb1
	ret c			; $4fb3

	ld (hl),$60		; $4fb4
	call _intro_incState		; $4fb6

	ld hl,wTmpcbb3		; $4fb9
	ld (hl),24 ; Linger for another 24 frames

	ldbc INTERACID_INTRO_SPRITE, $04		; $4fbe
	jp _createInteraction		; $4fc1

;;
; State 6: closeup of Link's face; screen staying still for a moment
; @addr{4fc4}
_introCinematic_ridingHorse_state6:
	ld hl,wTmpcbb3		; $4fc4
	call decHlRef16WithCap		; $4fc7
	ret nz			; $4fca

	call disableLcd		; $4fcb
	ld a,PALH_92		; $4fce
	call loadPaletteHeader		; $4fd0
	ld a,GFXH_9c		; $4fd3
	call loadGfxHeader		; $4fd5
	call clearDynamicInteractions		; $4fd8
	ld a,$0a		; $4fdb
	call loadGfxRegisterStateIndex		; $4fdd
	jp _intro_incState		; $4fe0


.else; ROM_SEASONS

;;
; Covers intro sections after the capcom screen and before the temple scene.
; @addr{4e2a}
_introCinematic_ridingHorse:
	ld a,(wIntroVar)
	rst_jumpTable

	.dw _introCinematic_ridingHorse_state0 ; First 3 states in Seasons are unique
	.dw _introCinematic_ridingHorse_state1
	.dw _introCinematic_ridingHorse_state2

	.dw _introCinematic_ridingHorse_state7 ; Last 4 are the same as in Ages
	.dw _introCinematic_ridingHorse_state8
	.dw _introCinematic_ridingHorse_state9
	.dw _introCinematic_ridingHorse_state10

;;
; State 0: initialization
_introCinematic_ridingHorse_state0:
	call disableLcd
	ld hl,wOamEnd
	ld bc,$d000-wOamEnd
	call clearMemoryBc

	ld a,$10
	ldh (<hOamTail),a
	ld a,GFXH_9b
	call loadGfxHeader
	ld a,PALH_90
	call loadPaletteHeader

	; Use cbb3-cbb4 as a 2-byte counter; wait for 0x37e=894 frames
	ld hl,$cbb3
	ld (hl),$7e
	inc hl
	ld (hl),$03

	ld a,$20
	ld ($cbb8),a
	ld a,$10
	ld (wTmpcbb9),a
	ld a,$22
	ld (wTmpcbb6),a
	ld a,$01
	ld (wTmpcbba),a

	ld a,$08
	call loadGfxRegisterStateIndex

	ld a,MUS_INTRO_1
	call playSound

	call getFreeInteractionSlot
	jr nz,++
	ld (hl),INTERACID_INTRO_SPRITE
	inc l
	ld (hl),$00
++
	ld a,$14
	call fadeinFromWhiteWithDelay
	ld hl,wLockBG7Color3ToBlack
	ld (hl),$01
	jp _intro_incState

;;
; State 1: screen fading in as Link rides closer
_introCinematic_ridingHorse_state1:
	call _introCinematic_moveBlackBarsIn
	ld hl,wTmpcbb3
	call decHlRef16WithCap
	ret nz

	call clearPaletteFadeVariablesAndRefreshPalettes
	ld a,PALH_96
	call loadPaletteHeader
	ld a,$0c
	call loadGfxRegisterStateIndex
	ld a,(wGfxRegs1.LYC)
	ld (wTmpcbbb),a
	ld a,(wGfxRegs2.SCX)
	ld (wTmpcbbc),a
	call _introCinematic_ridingHorse_drawLinkOnHorseCloseupSprites_1
	ld hl,wTmpcbb3
	ld (hl),$58
	inc hl
	ld (hl),$01
	jp _intro_incState

;;
; State 2: Image of Link bobbing up and down on horse
_introCinematic_ridingHorse_state2:
	ld hl,wTmpcbb3
	call decHlRef16WithCap
	jr nz,++

	call disableLcd
	ld a,PALH_92
	call loadPaletteHeader
	ld a,GFXH_9c
	call loadGfxHeader
	ld a,$0a
	call loadGfxRegisterStateIndex
	call _intro_incState
	jr _introCinematic_ridingHorse_drawLinkOnHorseCloseupSprites_2
++
	call _seasonsFunc_03_5367

	; Fall through

;;
; Draw the sprites that complement the image of Link on the horse (the 1st image)
_introCinematic_ridingHorse_drawLinkOnHorseCloseupSprites_1:
	ld hl,wGfxRegs2.SCY
	ldi a,(hl)
	cpl
	inc a
	ld b,a
	ld a,(hl)
	cpl
	inc a
	ld c,a
	xor a
	ldh (<hOamTail),a
	ld hl,linkOnHorseCloseupSprites_1
	jp addSpritesToOam_withOffset

.endif; ROM_SEASONS

;;
; State 7 (3 in seasons): scrolling up on the link+horse shot
; @addr{4fe3}
_introCinematic_ridingHorse_state7:
	ld hl,wGfxRegs1.SCY		; $4fe3
	dec (hl)		; $4fe6
	jr nz,_introCinematic_ridingHorse_drawLinkOnHorseCloseupSprites_2

	ld a,204 ; Linger on this shot for another 204 frames
	ld (wTmpcbb6),a		; $4feb
	call _intro_incState		; $4fee

;;
; Draw the sprites that complement the image of Link on the horse (the 2nd image in
; seasons; the only such image in ages)
; @addr{4ff1}
_introCinematic_ridingHorse_drawLinkOnHorseCloseupSprites_2:
	; Calculate offset for sprites
	ld a,(wGfxRegs1.SCY)		; $4ff1
	cpl			; $4ff4
	inc a			; $4ff5
	ld b,a			; $4ff6
	xor a			; $4ff7
	ldh (<hOamTail),a	; $4ff8
	ld c,a			; $4ffa

.ifdef ROM_AGES
	ld hl,bank3f.linkOnHorseCloseupSprites_2		; $4ffb
	ld e,:bank3f.linkOnHorseCloseupSprites_2		; $4ffe
	jp addSpritesFromBankToOam_withOffset		; $5000

.else; ROM_SEASONS

	ld hl,linkOnHorseCloseupSprites_2
	jp addSpritesToOam_withOffset
.endif

;;
; State 8 (4 in seasons): lingering on the link+horse shot
; @addr{5003}
_introCinematic_ridingHorse_state8:
	ld hl,wTmpcbb6		; $5003
	dec (hl)		; $5006
	jr nz,_introCinematic_ridingHorse_drawLinkOnHorseCloseupSprites_2	; $5007

	ld a,PALH_93		; $5009
	call loadPaletteHeader		; $500b
	call disableLcd		; $500e
	call clearOam		; $5011
	ld a,$10		; $5014
	ldh (<hOamTail),a	; $5016
	ld a,GFXH_9d		; $5018
	call loadGfxHeader		; $501a

	; Screen should be shifted a pixel every 5 frames next state
	ld a,$05		; $501d
	ld (wTmpcbbb),a		; $501f

	; Wait for $0190=400 frames in the next state
	ld hl,wTmpcbb3		; $5022
	ld (hl),$90		; $5025
	inc hl			; $5027
	ld (hl),$01		; $5028

	; How long to scroll the screen in the next state
	ld a,$b4		; $502a
	ld (wTmpcbb6),a		; $502c

	call clearPaletteFadeVariablesAndRefreshPalettes		; $502f
	ld a,$0b		; $5032
	call loadGfxRegisterStateIndex		; $5034
	call _introCinematic_ridingHorse_drawTempleSprites		; $5037

	; Create 2 interactions of type INTERACID_INTRO_SPRITE with subid's 2 and 1.
	; (These are the horse and cliff sprites.)
	ld b,$02		; $503a
--
	call getFreeInteractionSlot		; $503c
	jr nz,++		; $503f
	ld (hl),INTERACID_INTRO_SPRITE		; $5041
	inc l			; $5043
	ld (hl),b		; $5044
	dec b			; $5045
	jr nz,--		; $5046
++
	jp _intro_incState		; $5048

;;
; State 9 (5 in seasons): showing Link on a cliff overlooking the temple
; @addr{504b}
_introCinematic_ridingHorse_state9:
	ld hl,wTmpcbb3		; $504b
	call decHlRef16WithCap		; $504e
	jr nz,+			; $5051
	call fadeoutToWhite		; $5053
	call _intro_incState		; $5056
	jr _introCinematic_ridingHorse_drawTempleSprites		; $5059
+
	ld hl,wTmpcbb6		; $505b
	ld a,(hl)		; $505e
	or a			; $505f
	jr z,_introCinematic_ridingHorse_drawTempleSprites	; $5060

	; Check if the screen is done moving
	dec (hl)		; $5062
	ld a,(wGfxRegs1.SCX)		; $5063
	or a			; $5066
	jr z,_introCinematic_ridingHorse_drawTempleSprites	; $5067

	; Shift screen once every 5 frames
	ld hl,wTmpcbbb		; $5069
	dec (hl)		; $506c
	jr nz,_introCinematic_ridingHorse_drawTempleSprites	; $506d
	ld (hl),$05		; $506f
	ld hl,wGfxRegs1.SCX		; $5071
	dec (hl)		; $5074

;;
; In the scene overlooking the temple, a few sprites are used to touch up the appearance
; of the temple, even though it's mostly drawn on the background.
; @addr{5075}
_introCinematic_ridingHorse_drawTempleSprites:
	xor a			; $5075
	ldh (<hOamTail),a	; $5076
	ld b,a			; $5078
	ld a,(wGfxRegs1.SCX)		; $5079
	cpl			; $507c
	inc a			; $507d
	ld c,a			; $507e

.ifdef ROM_AGES
	ld hl,bank3f.introTempleSprites		; $507f
	ld e,:bank3f.introTempleSprites		; $5082
	jp addSpritesFromBankToOam_withOffset		; $5084

.else; ROM_SEASONS

	ld hl,introTempleSprites
	jp addSpritesToOam_withOffset
.endif

;;
; State 10 (6 in seasons): fading out, then proceed to next cinematic state (temple)
; @addr{5087}
_introCinematic_ridingHorse_state10:
	ld a,(wPaletteThread_mode)		; $5087
	or a			; $508a
	jr nz,_introCinematic_ridingHorse_drawTempleSprites	; $508b

	call clearDynamicInteractions		; $508d
	jr _incIntroCinematicState		; $5090

;;
; @param[out]	zflag	nz if there's no more scrolling to be done
; @addr{5092}
_introCinematic_preTitlescreen_updateScrollingTree:
	ld hl,wTmpcbb6		; $5092
	dec (hl)		; $5095
	ret nz			; $5096

	ld a,(wTmpcbba)		; $5097
	ld (wTmpcbb6),a		; $509a
	ld hl,wGfxRegs1.SCY		; $509d
	dec (hl)		; $50a0
	ld a,(hl)		; $50a1
	cp $88			; $50a2
	ret z			; $50a4

	cp $10			; $50a5
	jr nz,@label_03_063	; $50a7

	ld a,UNCMP_GFXH_0d		; $50a9
	call loadUncompressedGfxHeader		; $50ab
	ld b,$04		; $50ae
--
	call getFreeInteractionSlot		; $50b0
	jr nz,@ret		; $50b3
	ld (hl),INTERACID_TITLESCREEN_CLOUDS		; $50b5
	inc l			; $50b7
	dec b			; $50b8
	ld (hl),b		; $50b9
	jr nz,--		; $50ba
	jr @ret			; $50bc

@label_03_063:
	cp $b0			; $50be
	jr nz,@ret		; $50c0
	ld a,UNCMP_GFXH_2a		; $50c2
	call loadUncompressedGfxHeader		; $50c4
@ret:
	or $01			; $50c7
	ret			; $50c9

;;
; @addr{50ca}
_incIntroCinematicState:
	ld hl,wIntro.cinematicState		; $50ca
	inc (hl)		; $50cd
	xor a			; $50ce
	ld (wIntroVar),a		; $50cf
	ret			; $50d2

;;
; @addr{50d3}
_introCinematic_inTemple:
	ld a,(wIntroVar)		; $50d3
	rst_jumpTable			; $50d6
	.dw _introCinematic_inTemple_state0
	.dw _introCinematic_inTemple_state1
.ifdef ROM_SEASONS
	.dw _introCinematic_inTemple_state1.5 ; Seasons has a pointless extra state
.endif
	.dw _introCinematic_inTemple_state2
	.dw _introCinematic_inTemple_state3
	.dw _introCinematic_inTemple_state4
	.dw _introCinematic_inTemple_state5
	.dw _introCinematic_inTemple_state6
	.dw _introCinematic_inTemple_state7
	.dw _introCinematic_inTemple_state8
	.dw _introCinematic_inTemple_state9
	.dw _introCinematic_inTemple_state10

;;
; State 0: Load the room
; @addr{50ed}
_introCinematic_inTemple_state0:
	call disableLcd		; $50ed
	call clearOam		; $50f0
	ld a,$10		; $50f3
	ldh (<hOamTail),a	; $50f5

	ld a,GFXH_9e		; $50f7
	call loadGfxHeader		; $50f9
	ld a,PALH_91		; $50fc
	call loadPaletteHeader		; $50fe

	ld a,$09		; $5101
	call loadGfxRegisterStateIndex		; $5103

	ld a,(wGfxRegs1.SCY)		; $5106
	ldh (<hCameraY),a	; $5109

	ld a,$10		; $510b
	ld (wAreaAnimation),a		; $510d
	call loadAnimationData		; $5110

	ld a,$01		; $5113
	ld (wScrollMode),a		; $5115

	ld a,SPECIALOBJECTID_LINK_CUTSCENE		; $5118
	call setLinkID		; $511a
	ld l,<w1Link.enabled		; $511d
	ld (hl),$01		; $511f

	ld l,<w1Link.yh		; $5121
	ld a,(wGfxRegs1.SCY)		; $5123
	add $60			; $5126
	ld (hl),a		; $5128
	ld l,<w1Link.xh		; $5129
	ld (hl),$50		; $512b

	ld hl,templeIntro_simulatedInput		; $512d
	ld a,:templeIntro_simulatedInput		; $5130
	call setSimulatedInputAddress		; $5132

	; Spawn the 3 pieces of triforce
	ld b,$03		; $5135
	ld c,$30		; $5137
@nextTriforce:
	call getFreeInteractionSlot		; $5139
	jr nz,@doneSpawningTriforce	; $513c
	ld (hl),INTERACID_INTRO_SPRITES_1		; $513e
	inc l			; $5140
	ld a,b			; $5141
	dec a			; $5142
	ld (hl),a		; $5143

	ld l,Interaction.yh		; $5144
	ld (hl),$19		; $5146
	ld a,c			; $5148
	ld l,Interaction.xh		; $5149
	ld (hl),a		; $514b
	add $20			; $514c
	ld c,a			; $514e
	ld a,c			; $514f
	dec b			; $5150
	jr nz,@nextTriforce	; $5151

@doneSpawningTriforce:
	ld hl,wMenuDisabled		; $5153
	ld (hl),$01		; $5156
	call fadeinFromWhite		; $5158
	xor a			; $515b
	ld (wTmpcbb9),a		; $515c
	jp _intro_incState		; $515f

;;
; State 1: walking up to triforce
; @addr{5162}
_introCinematic_inTemple_state1:
	ld a,(wPaletteThread_mode)		; $5162
	or a			; $5165
	ret nz			; $5166

.ifdef ROM_SEASONS

	; Seasons has a pointless extra state; the devs removed this in Ages.
	jp _intro_incState

_introCinematic_inTemple_state1.5:

.endif

	; Check if simulated input is done (bit 7 set)
	ld a,(wUseSimulatedInput)		; $5167
	rlca			; $516a
	jp nc,_introCinematic_inTemple_updateCamera		; $516b
	xor a			; $516e
	ld (wUseSimulatedInput),a		; $516f
	call _introCinematic_inTemple_updateCamera		; $5172
	jp _intro_incState		; $5175

;;
; State 2: waiting for cutscene objects to do their thing (nothing to be done here)
; @addr{5178}
_introCinematic_inTemple_state2:
	; The "link cutscene object" will write to wIntro.triforceState eventually
	ld a,(wIntro.triforceState)		; $5178
	cp $03			; $517b
	ret nz			; $517d

	call fadeoutToWhite		; $517e
	jp _intro_incState		; $5181

;;
; State 3: screen fading out temporarily
; @addr{5184}
_introCinematic_inTemple_state3:
	ld a,(wPaletteThread_mode)		; $5184
	or a			; $5187
	ret nz			; $5188

	; Initialize variables needed to make the screen "wavy"
	ld a,$01		; $5189
	ld (wGfxRegs1.LYC),a		; $518b
	inc a			; $518e
	ld (wGfxRegs2.LYC),a		; $518f
	ld a,$00		; $5192
	ldh (<hNextLcdInterruptBehaviour),a	; $5194
	ld a,$20		; $5196
	call initWaveScrollValues		; $5198
	call fadeinFromWhite		; $519b
	call _intro_incState		; $519e

	; Fall through

;;
; @addr{51a1}
_introCinematic_inTemple_updateWave:
	ld hl,wFrameCounter		; $51a1
	inc (hl)		; $51a4
	ld a,$02		; $51a5
	jp loadBigBufferScrollValues		; $51a7

;;
; State 4: screen fading back in
; @addr{51aa}
_introCinematic_inTemple_state4:
	call _introCinematic_inTemple_updateWave		; $51aa
	ld a,(wPaletteThread_mode)		; $51ad
	or a			; $51b0
	ret nz			; $51b1
	ld hl,wTmpcbb6		; $51b2
	ld (hl),120		; $51b5
	jp _intro_incState		; $51b7

;;
; State 5: waving the screen around
; @addr{51ba}
_introCinematic_inTemple_state5:
	call _introCinematic_inTemple_updateWave		; $51ba
	ld hl,wTmpcbb6		; $51bd
	dec (hl)		; $51c0
	ret nz			; $51c1

	; a=0 here
	ld (wTmpcbb6),a		; $51c2
	dec a			; $51c5
	ld (wTmpcbba),a		; $51c6

	call _intro_incState		; $51c9

	; Fall through

;;
; State 6: this is the instant where Link "falls"?
; @addr{51cc}
_introCinematic_inTemple_state6:
	call _introCinematic_inTemple_updateWave		; $51cc
	ld hl,wTmpcbb6		; $51cf
	ld b,$00		; $51d2
	call flashScreen_body		; $51d4
	ret z			; $51d7

	call clearPaletteFadeVariablesAndRefreshPalettes		; $51d8
	ld a,$06		; $51db
	ld (wTmpcbb9),a		; $51dd
	ld a,SND_FAIRYCUTSCENE		; $51e0
	call playSound		; $51e2
	jp _intro_incState		; $51e5

;;
; State 7: link is in the process of falling
; @addr{51e8}
_introCinematic_inTemple_state7:
	call _introCinematic_inTemple_updateWave		; $51e8
	ld a,(wTmpcbb9)		; $51eb
	cp $07			; $51ee
	ret nz			; $51f0

	; Finished falling; delete Link
	call clearLinkObject		; $51f1
	ld b,$08		; $51f4
	call func_2d48		; $51f6
	ld a,b			; $51f9
	ld (wTmpcbb6),a		; $51fa
	jp _intro_incState		; $51fd

;;
; State 8: waiting?
; @addr{5200}
_introCinematic_inTemple_state8:
	call _introCinematic_inTemple_updateWave		; $5200
	ld hl,wTmpcbb6		; $5203
	dec (hl)		; $5206
	ret nz			; $5207
	ld (hl),$3c		; $5208
	jp _intro_incState		; $520a

;;
; State 9: waiting?
; @addr{520d}
_introCinematic_inTemple_state9:
	call _introCinematic_inTemple_updateWave		; $520d
	ld hl,wTmpcbb6		; $5210
	dec (hl)		; $5213
	ret nz			; $5214
	ld a,SND_FADEOUT		; $5215
	call playSound		; $5217
	call fadeoutToWhite		; $521a
	jp _intro_incState		; $521d

;;
; State 10: screen fading out, then moves on to the next cinematic state
; @addr{5220}
_introCinematic_inTemple_state10:
	call _introCinematic_inTemple_updateWave		; $5220
	ld a,(wPaletteThread_mode)		; $5223
	or a			; $5226
	ret nz			; $5227
	call clearDynamicInteractions		; $5228
	jp _incIntroCinematicState		; $522b

;;
; This function causes the screen to flash white. Based on parameter 'b', which acts as
; the "index" if the data to use, this will read through the predefined data to see on
; what frames it should turn the screen white, and on what frames it should restore the
; screen to normal.
;
; @param	b	Index of "screen flashing" data
; @param	hl	Counter to use (should start at 0?)
; @param[out]	zflag	nz if the flashing is complete (all data has been read).
; @addr{522e}
flashScreen_body:
	ld a,b			; $522e
	inc (hl)		; $522f
	ld b,(hl)		; $5230
	ld hl,_screenFlashingData		; $5231
	rst_addDoubleIndex			; $5234
	ldi a,(hl)		; $5235
	ld h,(hl)		; $5236
	ld l,a			; $5237
	ld c,$00		; $5238
--
	ld a,(hl)		; $523a
	bit 7,a			; $523b
	ret nz			; $523d
	cp b			; $523e
	jr nc,+			; $523f

	inc hl			; $5241
	inc c			; $5242
	jr --			; $5243
+
	; Check if the index has changed from last time?
	ld a,c			; $5245
	and $01			; $5246
	ld c,a			; $5248
	ld a,(wTmpcbba)		; $5249
	cp c			; $524c
	ret z			; $524d
	ld a,c			; $524e
	ld (wTmpcbba),a		; $524f

	or a			; $5252
	jr z,clearFadingPalettes_body	; $5253
	call clearPaletteFadeVariablesAndRefreshPalettes		; $5255
	xor a			; $5258
	ret			; $5259

;;
; Clears w2FadingBgPalettes, w2FadingSprPalettes (fills contents with $ff), and marks all
; palettes as needing refresh?
; @addr{525a}
clearFadingPalettes_body:
	ld a,:w2FadingBgPalettes		; $525a
	ld ($ff00+R_SVBK),a	; $525c
	ld b,$80		; $525e
	ld hl,w2FadingBgPalettes		; $5260
	ld a,$ff		; $5263
	call fillMemory		; $5265

	ld a,$ff		; $5268
	ldh (<hSprPaletteSources),a	; $526a
	ldh (<hBgPaletteSources),a	; $526c
	ldh (<hDirtySprPalettes),a	; $526e
	ldh (<hDirtyBgPalettes),a	; $5270
	xor a			; $5272
	ld ($ff00+R_SVBK),a	; $5273
	ret			; $5275

.ifdef ROM_AGES

	_screenFlashingData:
		.dw @data0
		.dw @data1
		.dw @data2
		.dw @data3
		.dw @data4
		.dw @data5

	; Data format:
	;  Even bytes are the frame numbers on which to turn the screen white; odd bytes
	;  are when to restore it to normal? $ff signals end of data.

	; Used by "raftwreck" cutscene before tokay island (INTERACID_RAFTWRECK_CUTSCENE)
	@data1:
		.db $02 $04 $06 $08 $0a $0c $ff

	@data0:
		.db $02 $04 $06 $0c $0e $ff

	; Used by ambi subid $03 (cutscene atop black tower after d7)
	@data2:
		.db $02 $04 $06 $08 $0a $0c $0e $ff

	@data3:
		.db $01 $05 $06 $0a $0b $0f $11 $15
		.db $16 $1a $1c $20 $22 $26 $28 $ff
	@data4:
		.db $03 $05 $07 $0a $0c $10 $12 $17
		.db $19 $ff
	@data5:
		.db $01 $02 $04 $06 $08 $0a $0c $ff

.else; ROM_SEASONS

	_screenFlashingData:
		.dw @data0
		.dw @data1
		.dw @data2
		.dw @data3
		.dw @data4

		.db $03 ; ???

	@data1:
		.db $02 $04 $06 $08 $0c $0e $10 $ff
	@data0:
		.db $02 $04 $06 $0c $0e $ff
	@data2:
		.db $02 $04 $06 $08 $0a $0c $0e $ff
	@data3:
		.db $01 $05 $06 $0a $0b $0f $11 $15
		.db $16 $1a $1c $20 $22 $26 $28 $ff
	@data4:
		.db $01 $02 $04 $06 $08 $0a $0c $ff

.endif


;;
; @addr{52b9}
_introCinematic_preTitlescreen:
	ld a,(wIntroVar)		; $52b9
	rst_jumpTable			; $52bc
	.dw _introCinematic_preTitlescreen_state0
	.dw _introCinematic_preTitlescreen_state1
	.dw _introCinematic_preTitlescreen_state2
	.dw _introCinematic_preTitlescreen_state3

;;
; State 0: load tree graphics
; @addr{52c5}
_introCinematic_preTitlescreen_state0:
	call disableLcd		; $52c5

	ld a,$ff		; $52c8
	ld (wAreaAnimation),a		; $52ca
	ld a,GFXH_9f		; $52cd
	call loadGfxHeader		; $52cf
	ld a,PALH_94		; $52d2
	call loadPaletteHeader		; $52d4
	call refreshObjectGfx		; $52d7
	ld a,$0a		; $52da
	call loadGfxRegisterStateIndex		; $52dc

	; Create the "tree branches" object
	call getFreeInteractionSlot		; $52df
	jr nz,++		; $52e2
	ld (hl),INTERACID_INTRO_SPRITES_1		; $52e4
	inc l			; $52e6
	ld (hl),$08		; $52e7
	ld l,Interaction.y		; $52e9
	ld a,$60		; $52eb
	ldi (hl),a		; $52ed
	ldi (hl),a		; $52ee
	ld a,$3d		; $52ef
	inc l			; $52f1
	ldi (hl),a		; $52f2
++

	; Spawn birds
	ld b,$08		; $52f3
--
	call getFreeInteractionSlot		; $52f5
	jr nz,++		; $52f8
	ld (hl),INTERACID_INTRO_BIRD		; $52fa
	inc l			; $52fc
	dec b			; $52fd
	ld (hl),b		; $52fe
	jr nz,--		; $52ff
++
	ld a,$03		; $5301
	ld (wTmpcbba),a		; $5303
	ld (wTmpcbb6),a		; $5306
	call fadeinFromWhite		; $5309
	xor a			; $530c
	ldh (<hCameraY),a	; $530d

	ld a,MUS_INTRO_2		; $530f
	call playSound		; $5311

	jp _intro_incState		; $5314

;;
; State 1: scrolling up the tree
; @addr{5317}
_introCinematic_preTitlescreen_state1:
	call _introCinematic_preTitlescreen_updateScrollingTree		; $5317
	ret nz			; $531a

	; Initialize stuff for state 2.

	call _intro_incState		; $531b
	ld hl,wTmpcbb3		; $531e
	ld (hl),$02		; $5321
	inc hl			; $5323
	xor a			; $5324
	ld (hl),a		; $5325

	; wTmpcbb6 = counter until the sound effect should be played
	ld hl,wTmpcbb6		; $5326
	ld (hl),$10		; $5329

	inc a			; $532b
	ld (wGfxRegs1.LYC),a		; $532c
	inc a			; $532f
	ld (wGfxRegs2.LYC),a		; $5330
	ld a,$01		; $5333
	ldh (<hNextLcdInterruptBehaviour),a	; $5335

	; wBigBuffer will contain separate scrollY values for each line on the screen, in
	; order to produce the effect introducing the title.
	; Initialize it with normal values for scrollY for now.
	ld a,(wGfxRegs1.SCY)		; $5337
	ld b,$90		; $533a
	ld hl,wBigBuffer		; $533c
--
	ldi (hl),a		; $533f
	dec b			; $5340
	jr nz,--		; $5341

	ld a,$01		; $5343

	; Fall through

;;
; Updates the effect where the title comes into view.
;
; @param	a	Number of pixels of the title to show (divided by two)
; @addr{5345}
_introCinematic_preTitlescreen_updateScrollForTitle:
	ld b,a			; $5345

	; Calculate c=$18/b (the amount that the title needs to be shrunk)
	xor a			; $5346
	ld c,a			; $5347
--
	inc c			; $5348
	add b			; $5349
	cp $18			; $534a
	jr z,+			; $534c
	ret nc ; Should never return if given a valid parameter
	jr --			; $534f
+
	; Calculate SCY values for the top half of the title
	push bc			; $5351
	ld a,$38 ; vertical center of title
	sub b			; $5354
	ld h,>wBigBuffer		; $5355
	ld l,a			; $5357
	xor a			; $5358
--
	push af			; $5359
	sub l			; $535a
	add $58 ; SCY value that would be needed to draw the title at top of screen
	ldi (hl),a		; $535d
	pop af			; $535e
	add c			; $535f
	dec b			; $5360
	jr nz,--		; $5361

	; Calculate SCY values for the bottom half of the title
	pop bc			; $5363
	ld a,$37		; $5364
	add b			; $5366
	ld l,a			; $5367
	ld a,$2f		; $5368
--
	push af			; $536a
	sub l			; $536b
	add $58 ; SCY value that would be needed to draw the title at top of screen
	ldd (hl),a		; $536e
	pop af			; $536f
	sub c			; $5370
	dec b			; $5371
	jr nz,--		; $5372
	ret			; $5374

;;
; State 2: game title coming into view
; @addr{5375}
_introCinematic_preTitlescreen_state2:
	; Check whether to play the sound effect
	ld hl,wTmpcbb6		; $5375
	ld a,(hl)		; $5378
	or a			; $5379
	jr z,+			; $537a
	dec a			; $537c
	ld (hl),a		; $537d
	ld a,SND_SWORD_OBTAINED		; $537e
	call z,playSound		; $5380
+
	; Only update every other frame?
	ld a,(wIntro.frameCounter)		; $5383
	and $01			; $5386
	ld hl,wTmpcbb4		; $5388
	ret nz			; $538b

	ld a,(hl)		; $538c
	cp $08			; $538d
	jr nc,@titleDone	; $538f
	inc a			; $5391
	ld (hl),a		; $5392
	ld hl,_introCinematic_preTitlescreen_titleSizeData		; $5393
	rst_addAToHl			; $5396
	ld a,(hl)		; $5397
	jp _introCinematic_preTitlescreen_updateScrollForTitle		; $5398

@titleDone:
	xor a			; $539b
	ld (wTmpcbb6),a		; $539c
	dec a			; $539f
	ld (wTmpcbba),a		; $53a0
	jp _intro_incState		; $53a3

;;
; State 3: title fully in view; wait a bit, then go to the titlescreen.
; @addr{53a6}
_introCinematic_preTitlescreen_state3:
	ld hl,wTmpcbb6		; $53a6
	ld b,$01		; $53a9
	call flashScreen_body		; $53ab
	ret z			; $53ae
	jp _intro_gotoTitlescreen		; $53af

; Each byte is the number of pixels of the title to show on a particular frame, divided by
; two.
_introCinematic_preTitlescreen_titleSizeData:
	.db $01 $02 $03 $04 $06 $08 $0c $18

;;
; Updates camera position based on link's Y position.
; @addr{53ba}
_introCinematic_inTemple_updateCamera:
	ld a,(wGfxRegs1.SCY)		; $53ba
	ld b,a			; $53bd
	ld de,w1Link.yh		; $53be
	ld a,(de)		; $53c1
	sub b			; $53c2
	sub $40			; $53c3
	ld b,a			; $53c5
	ld a,(wGfxRegs1.SCY)		; $53c6
	add b			; $53c9
	cp $70			; $53ca
	ret nc			; $53cc
	ld (wGfxRegs1.SCY),a		; $53cd
	ldh (<hCameraY),a	; $53d0
	ret			; $53d2

;;
; Moves the black bars in the intro cinematic in by 2 pixels, until it covers 24 pixels on
; each end.
; @addr{53d3}
_introCinematic_moveBlackBarsIn:
	ld hl,wGfxRegs1.LYC		; $53d3
	inc (hl)		; $53d6
	inc (hl)		; $53d7
	ld a,(hl)		; $53d8
	cp $17			; $53d9
	jr c,+			; $53db
	ld (hl),$17		; $53dd
+
	ld hl,wGfxRegs2.WINY		; $53df
	dec (hl)		; $53e2
	dec (hl)		; $53e3
	ld a,(hl)		; $53e4
	cp $90-$18			; $53e5
	ret nc			; $53e7
	ld (hl),$90-$18		; $53e8
	ret			; $53ea


.ifdef ROM_AGES

;;
; Moves the black bars out until a certain area in the center of the screen is visible.
; Used for the closeup of Link's face.
; @addr{53eb}
_introCinematic_moveBlackBarsOut:
	ld hl,wGfxRegs1.LYC		; $53eb
	dec (hl)		; $53ee
	dec (hl)		; $53ef
	ld a,(hl)		; $53f0
	cp $2f			; $53f1
	jr nc,+			; $53f3
	ld (hl),$2f		; $53f5
+
	ld hl,wGfxRegs2.WINY		; $53f7
	inc (hl)		; $53fa
	inc (hl)		; $53fb
	ld a,(hl)		; $53fc
	cp $90-$30			; $53fd
	ret c			; $53ff
	ld (hl),$90-$30		; $5400
	ret			; $5402

.else; ROM_SEASONS

;;
; @addr{5367}
_seasonsFunc_03_5367:
	call @func
	ld bc,$0506
	jr nz,+
	ld bc,$0000
+
	ld hl,wTmpcbbb
	ldi a,(hl)
	add b
	ld (wGfxRegs2.SCY),a
	ld a,(hl)
	add c
	ld (wGfxRegs2.SCX),a
	ret

;;
; @param[out]	zflag
@func:
	ld a,($cbb6)
	dec a
	jr nz,++
	ld a,($cbba)
	xor $01
	ld ($cbba),a
	ld a,$05
	jr z,++
	ld a,$22
++
	ld ($cbb6),a
	ld a,($cbba)
	or a
	ret

.endif ; ROM_SEASONS


;;
; @addr{5403}
_cutscene_clearObjects:
	call clearDynamicInteractions		; $5403
	call clearLinkObject		; $5406
	jp refreshObjectGfx		; $5409


.ifdef ROM_AGES

;;
; @param	bc	ID of interaction to create
; @addr{540c}
_createInteraction:
	call getFreeInteractionSlot		; $540c
	ret nz			; $540f
	ld (hl),b		; $5410
	inc l			; $5411
	ld (hl),c		; $5412
	ret			; $5413

.endif


.ifdef ROM_SEASONS

; Placeholder label
_createInteraction:


; In Ages these sprites are located elsewhere

; Sprites used on the closeup shot of Link on the horse in the intro
linkOnHorseCloseupSprites_2:
	.db $26
	.db $80 $80 $40 $06
	.db $80 $50 $42 $00
	.db $80 $58 $44 $00
	.db $68 $40 $46 $06
	.db $b8 $3d $20 $02
	.db $b8 $45 $22 $02
	.db $b8 $4d $24 $02
	.db $b8 $55 $26 $02
	.db $b8 $5d $28 $02
	.db $90 $28 $2c $02
	.db $90 $30 $2e $02
	.db $80 $30 $2a $02
	.db $20 $78 $48 $05
	.db $58 $68 $00 $02
	.db $58 $70 $02 $02
	.db $68 $68 $04 $02
	.db $48 $70 $06 $02
	.db $5a $40 $08 $01
	.db $5a $48 $0a $01
	.db $5a $50 $0c $01
	.db $38 $88 $0e $04
	.db $30 $78 $10 $04
	.db $30 $80 $12 $04
	.db $40 $80 $14 $04
	.db $50 $76 $16 $04
	.db $50 $7e $18 $04
	.db $41 $62 $1a $03
	.db $80 $28 $1c $02
	.db $a8 $59 $1e $02
	.db $98 $20 $30 $02
	.db $98 $28 $32 $02
	.db $8c $38 $34 $07
	.db $a8 $41 $36 $02
	.db $a8 $49 $38 $02
	.db $a8 $51 $3a $02
	.db $90 $40 $3e $07
	.db $8a $5c $4a $00
	.db $8a $64 $4c $00

linkOnHorseCloseupSprites_1:
	.db $15
	.db $28 $78 $9c $08
	.db $20 $58 $80 $08
	.db $20 $60 $82 $08
	.db $20 $68 $84 $0a
	.db $20 $70 $d0 $09
	.db $20 $70 $86 $0d
	.db $20 $78 $88 $09
	.db $20 $80 $8a $09
	.db $30 $58 $90 $0c
	.db $30 $80 $9e $09
	.db $4e $60 $94 $0c
	.db $58 $68 $96 $0c
	.db $68 $78 $98 $09
	.db $60 $80 $9a $0a
	.db $20 $88 $8c $09
	.db $20 $90 $8e $09
	.db $40 $72 $92 $0e
	.db $42 $62 $a0 $0e
	.db $70 $30 $b4 $0f
	.db $70 $38 $b6 $0f
	.db $78 $68 $b8 $0c

; Sprites used to touch up the appearance of the temple in the intro (the scene where
; Link's on a cliff with his horse)
introTempleSprites:
	.db $05
	.db $30 $28 $48 $02
	.db $30 $30 $4a $02
	.db $18 $38 $4c $03
	.db $10 $40 $4e $03
	.db $18 $48 $50 $03


.endif; ROM_SEASONS


;;
; Called from func_306c in bank 0.
;
; @param	e
; @addr{5414}
endgameCutsceneHandler_body:
	ld hl,wCutsceneState		; $5414
	bit 0,(hl)		; $5417
	jr nz,_label_03_084	; $5419
	inc (hl)		; $541b
	ld hl,wTmpcbb3		; $541c
	ld b,$10		; $541f
	call clearMemory		; $5421
_label_03_084:
	ld a,e			; $5424
	rst_jumpTable			; $5425
	.dw _endgameCutsceneHandler_09
	.dw _endgameCutsceneHandler_0a
	.dw _endgameCutsceneHandler_0f
	.dw _endgameCutsceneHandler_20

;;
; @addr{542e}
_clearFadingPalettes:
	; Clear w2FadingBgPalettes and w2FadingSprPalettes
	ld a,:w2FadingBgPalettes		; $542e
	ld ($ff00+R_SVBK),a	; $5430
	ld hl,w2FadingBgPalettes		; $5432
	ld b,$80		; $5435
	call clearMemory		; $5437

	xor a			; $543a
	ld ($ff00+R_SVBK),a	; $543b
	dec a			; $543d
	ldh (<hSprPaletteSources),a	; $543e
	ldh (<hDirtySprPalettes),a	; $5440
	ld a,$fd		; $5442
	ldh (<hBgPaletteSources),a	; $5444
	ldh (<hDirtyBgPalettes),a	; $5446
	ret			; $5448


;;
; CUTSCENE_BLACK_TOWER_ESCAPE
; @addr{5449}
_endgameCutsceneHandler_09:
	ld de,wGenericCutscene.cbc1		; $5449
	ld a,(de)		; $544c
	rst_jumpTable			; $544d
	.dw _endgameCutsceneHandler_09_state0
	.dw _endgameCutsceneHandler_09_state1

_endgameCutsceneHandler_09_state0:
	call updateStatusBar		; $5452
	call @runStates		; $5455
	jp updateAllObjects		; $5458

@runStates:
	ld de,wGenericCutscene.cbc2		; $545b
	ld a,(de)		; $545e
	rst_jumpTable			; $545f
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3
	.dw @state4
	.dw @state5
	.dw @state6
	.dw @state7
	.dw @state8
	.dw @state9
	.dw @stateA
	.dw @stateB
	.dw @stateC
	.dw @stateD
	.dw @stateE
	.dw @stateF
	.dw @state10
	.dw @state11
	.dw @state12
	.dw @state13
	.dw @state14
	.dw @state15

@state0:
	ld a,(wPaletteThread_mode)		; $548c
	or a			; $548f
	ret nz			; $5490
	call _cutscene_clearCFC0ToCFDF		; $5491
	call incCbc2		; $5494

	; Outside black tower
	ld bc,ROOM_176		; $5497
	call disableLcdAndLoadRoom		; $549a
	call resetCamera		; $549d

	ld a,SNDCTRL_FAST_FADEOUT		; $54a0
	call playSound		; $54a2
	call clearAllParentItems		; $54a5
	call dropLinkHeldItem		; $54a8

	ld hl,objectData.blackTowerEscape_nayruAndRalph		; $54ab
	call parseGivenObjectData		; $54ae
	ld hl,wGenericCutscene.cbb3		; $54b1
	ld (hl),60		; $54b4

	ld hl,_blackTowerEscapeCutscene_doorBlockReplacement		; $54b6
	call _cutscene_replaceListOfTiles		; $54b9

	call refreshObjectGfx		; $54bc
	ld a,$02		; $54bf
	call loadGfxRegisterStateIndex		; $54c1
	jp fadeinFromWhiteToRoom		; $54c4

@state1:
	call _cutscene_decCBB3IfNotFadingOut		; $54c7
	ret nz			; $54ca
	ld (hl),120		; $54cb
	ld l,<wGenericCutscene.cbb6		; $54cd
	ld (hl),$10		; $54cf
	jp incCbc2		; $54d1

@state2:
	call decCbb3		; $54d4
	jr nz,@updateExplosionSoundsAndScreenShake	; $54d7
	ld (hl),60		; $54d9
	jp incCbc2		; $54db

@updateExplosionSoundsAndScreenShake:
	ld hl,wTmpcbb6		; $54de
	dec (hl)		; $54e1
	ret nz			; $54e2
	ld (hl),$10		; $54e3
	ld a,SND_EXPLOSION		; $54e5
	call playSound		; $54e7
	ld a,$08		; $54ea
	call setScreenShakeCounter		; $54ec
	xor a			; $54ef
	ret			; $54f0

@state3:
	call decCbb3		; $54f1
	ret nz			; $54f4
	ld (hl),30		; $54f5
	ld bc,TX_1d0a		; $54f7
	call showText		; $54fa
	jp incCbc2		; $54fd

@state4:
	call _cutscene_decCBB3IfTextNotActive		; $5500
	ret nz			; $5503
	ld (hl),120		; $5504
	ld l,<wGenericCutscene.cbb6		; $5506
	ld (hl),$10		; $5508
	jp incCbc2		; $550a

@state5:
	call decCbb3		; $550d
	jr nz,@explosions	; $5510

	ld (hl),40		; $5512
	call incCbc2		; $5514

	ld hl,w1Link.enabled		; $5517
	ld (hl),$03		; $551a
	ld l,<w1Link.yh		; $551c
	ld (hl),$48		; $551e
	ld l,<w1Link.xh		; $5520
	ld (hl),$50		; $5522
	ld l,<w1Link.direction		; $5524
	ld (hl),DIR_DOWN		; $5526

	ld hl,blackTowerEscape_simulatedInput1		; $5528
	ld a,:blackTowerEscape_simulatedInput1		; $552b
	call setSimulatedInputAddress		; $552d

	ld hl,_blackTowerEscapeCutscene_doorOpenReplacement		; $5530
	jp _cutscene_replaceListOfTiles		; $5533

@explosions:
	call @updateExplosionSoundsAndScreenShake		; $5536
	ret nz			; $5539
	call getFreeInteractionSlot		; $553a
	ret nz			; $553d
	ld (hl),INTERACID_EXPLOSION_WITH_DEBRIS		; $553e
	inc l			; $5540
	inc l			; $5541
	inc (hl) ; [var03] = $01
	ld a,$01		; $5543
	ld (wTmpcfc0.genericCutscene.cfd0),a		; $5545
	ret			; $5548

@state6:
	call decCbb3		; $5549
	jr nz,@explosions	; $554c
	jp incCbc2		; $554e

@state7:
	; Wait for signal from an object?
	ld a,(wTmpcfc0.genericCutscene.cfd0)		; $5551
	cp $04			; $5554
	ret nz			; $5556

	call incCbc2		; $5557
	xor a			; $555a
	ld (wDisabledObjects),a		; $555b
	ld (wScrollMode),a		; $555e

	ld hl,blackTowerEscape_simulatedInput2		; $5561
	ld a,:blackTowerEscape_simulatedInput2		; $5564
	jp setSimulatedInputAddress		; $5566

@state8:
	ld a,(wTmpcfc0.genericCutscene.cfd0)		; $5569
	cp $05			; $556c
	ret nz			; $556e
	call incCbc2		; $556f
	jp fadeoutToWhite		; $5572

@state9:
	ld a,(wPaletteThread_mode)		; $5575
	or a			; $5578
	ret nz			; $5579

	call incCbc2		; $557a

	ld bc,ROOM_165		; $557d
	call disableLcdAndLoadRoom		; $5580

	call resetCamera		; $5583
	ld a,MUS_DISASTER		; $5586
	call playSound		; $5588

	ld a,$02		; $558b
	call loadGfxRegisterStateIndex		; $558d

	ld hl,objectData.blackTowerEscape_ambiAndGuards		; $5590
	call parseGivenObjectData		; $5593

	ld hl,wTmpcbb3		; $5596
	ld (hl),30		; $5599
	jp fadeinFromWhiteToRoom		; $559b

@stateA:
	call _cutscene_decCBB3IfNotFadingOut		; $559e
	ret nz			; $55a1

	call incCbc2		; $55a2

	ld hl,w1Link.enabled		; $55a5
	ld (hl),$03		; $55a8
	ld l,<w1Link.yh		; $55aa
	ld (hl),$88		; $55ac
	ld l,<w1Link.xh		; $55ae
	ld (hl),$50		; $55b0
	ld l,<w1Link.direction		; $55b2
	ld (hl),DIR_UP		; $55b4

	ld hl,blackTowerEscape_simulatedInput3		; $55b6
	ld a,:blackTowerEscape_simulatedInput3		; $55b9
	call setSimulatedInputAddress		; $55bb
	xor a			; $55be
	ld (wScrollMode),a		; $55bf
	ret			; $55c2

@stateB:
	ld a,(wTmpcfc0.genericCutscene.cfd0)		; $55c3
	cp $06			; $55c6
	ret nz			; $55c8
	call incCbc2		; $55c9
	ld hl,blackTowerEscape_simulatedInput4		; $55cc
	ld a,:blackTowerEscape_simulatedInput4		; $55cf
	jp setSimulatedInputAddress		; $55d1

@stateC:
	ld a,(wTmpcfc0.genericCutscene.cfd0)		; $55d4
	cp $0a			; $55d7
	ret nz			; $55d9
	call incCbc2		; $55da

	; TODO: what is this?
	ld hl,wTmpcfc0.genericCutscene.cfde		; $55dd
	ld (hl),$08		; $55e0
	inc l			; $55e2
	ld (hl),$00		; $55e3

	jp fadeoutToWhite		; $55e5

@stateD:
	ld a,(wPaletteThread_mode)		; $55e8
	or a			; $55eb
	ret nz			; $55ec
	call incCbc2		; $55ed
	call _cutscene_loadObjectSetAndFadein		; $55f0
	xor a			; $55f3
	ld (wTmpcfc0.genericCutscene.cfd1),a		; $55f4
	ld (wTmpcfc0.genericCutscene.cfdf),a		; $55f7
	ld a,$02		; $55fa
	jp loadGfxRegisterStateIndex		; $55fc

@stateE:
	ld a,(wPaletteThread_mode)		; $55ff
	or a			; $5602
	ret nz			; $5603
	ld hl,wTmpcfc0.genericCutscene.cfdf		; $5604
	ld a,(hl)		; $5607
	cp $ff			; $5608
	ret nz			; $560a
	xor a			; $560b

	ldd (hl),a ; wTmpcfc0.genericCutscene.cfdf
	inc (hl) ; wTmpcfc0.genericCutscene.cfde
	ld a,(hl)		; $560e
	cp $0a			; $560f
	ld a,$0d		; $5611
	jr nz,+			; $5613
	ld a,$0f		; $5615
+
	ld hl,wGenericCutscene.cbc2		; $5617
	ld (hl),a		; $561a
	jp fadeoutToWhite		; $561b

@stateF:
	ld a,(wPaletteThread_mode)		; $561e
	or a			; $5621
	ret nz			; $5622

	call incCbc2		; $5623
	call _cutscene_loadObjectSetAndFadein		; $5626

	ld hl,w1Link.enabled		; $5629
	ld (hl),$03		; $562c
	ld l,<w1Link.yh		; $562e
	ld (hl),$48		; $5630
	ld l,<w1Link.xh		; $5632
	ld (hl),$60		; $5634
	ld l,<w1Link.direction		; $5636

	ld (hl),DIR_UP		; $5638
	ld a,$0b		; $563a
	ld (wTmpcfc0.genericCutscene.cfd0),a		; $563c
	ld a,$02		; $563f
	jp loadGfxRegisterStateIndex		; $5641

@state10:
	call checkIsLinkedGame		; $5644
	jr nz,@@linked	; $5647

	ld a,(wTmpcfc0.genericCutscene.cfd0)		; $5649
	cp $10			; $564c
	ret nz			; $564e
	call incCbc2		; $564f
	jp fadeoutToWhite		; $5652

@@linked:
	ld a,(wTmpcfc0.genericCutscene.cfd0)		; $5655
	cp $12			; $5658
	ret nz			; $565a
	ld hl,wGenericCutscene.cbc2		; $565b
	ld (hl),$14		; $565e
	ret			; $5660

@state11:
	ld a,(wPaletteThread_mode)		; $5661
	or a			; $5664
	ret nz			; $5665

	call incCbc2		; $5666
	ld hl,wTmpcbb3		; $5669
	ld (hl),60		; $566c

	ld a,$ff		; $566e
	ld (wAreaAnimation),a		; $5670
	call disableLcd		; $5673

	ld a,GFXH_2b		; $5676
	call loadGfxHeader		; $5678
	ld a,PALH_9d		; $567b
	call loadPaletteHeader		; $567d

	call _cutscene_clearObjects		; $5680
	call _cutscene_resetOamWithSomething2		; $5683
	ld a,$04		; $5686
	call loadGfxRegisterStateIndex		; $5688
	jp fadeinFromWhite		; $568b

@state12:
	call _cutscene_resetOamWithSomething2		; $568e
	call _cutscene_decCBB3IfNotFadingOut		; $5691
	ret nz			; $5694

	call incCbc2		; $5695
	ld hl,wMenuDisabled		; $5698
	ld (hl),$01		; $569b
	ld hl,wTmpcbb3		; $569d
	ld (hl),60		; $56a0

	ld bc,TX_1312		; $56a2
	ld a,TEXTBOXFLAG_NOCOLORS	; $56a5
	ld (wTextboxFlags),a		; $56a7
	jp showText		; $56aa

@state13:
	call _cutscene_resetOamWithSomething2		; $56ad
	call _cutscene_decCBB3IfTextNotActive		; $56b0
	ret nz			; $56b3
	call cutscene_clearTmpCBB3		; $56b4
	ld a,$01		; $56b7
	ld (wGenericCutscene.cbc1),a		; $56b9
	jp fadeoutToWhite		; $56bc

@state14:
	ld a,(wTextIsActive)		; $56bf
	rlca			; $56c2
	ret nc			; $56c3
	ld a,(wKeysJustPressed)		; $56c4
	or a			; $56c7
	ret z			; $56c8
	call incCbc2		; $56c9
	ld a,$04		; $56cc
	jp fadeoutToWhiteWithDelay		; $56ce

@state15:
	ld a,(wPaletteThread_mode)		; $56d1
	or a			; $56d4
	ret nz			; $56d5
	xor a			; $56d6
	ld (wTextIsActive),a		; $56d7
	ld a,CUTSCENE_ZELDA_KIDNAPPED		; $56da
	ld (wCutsceneTrigger),a		; $56dc
	ret			; $56df


_endgameCutsceneHandler_09_state1:
	call $56e6		; $56e0
	jp updateAllObjects		; $56e3

	ld de,$cbc2		; $56e6
	ld a,(de)		; $56e9
	rst_jumpTable			; $56ea
.dw $56ff
.dw $572c
.dw $5744
.dw $5761
.dw $5777
.dw $578a
.dw $57a6
.dw $57bb
.dw $57d2
.dw $5828

	call _cutscene_resetOamWithSomething2		; $56ff
	ld a,(wPaletteThread_mode)		; $5702
	or a			; $5705
	ret nz			; $5706
	call incCbc2		; $5707
	ld hl,wTmpcbb3		; $570a
	ld (hl),$3c		; $570d
	call disableLcd		; $570f
	call clearOam		; $5712
	ld a,$2c		; $5715
	call loadGfxHeader		; $5717
	ld a,PALH_9e		; $571a
	call loadPaletteHeader		; $571c
	ld a,$04		; $571f
	call loadGfxRegisterStateIndex		; $5721
	ld a,MUS_DISASTER		; $5724
	call playSound		; $5726
	jp fadeinFromWhite		; $5729
	ld a,TEXTBOXFLAG_NOCOLORS	; $572c
	ld (wTextboxFlags),a		; $572e
	ld a,$3c		; $5731
	ld bc,$280b		; $5733
	call _cutscene_decCBB3IfNotFadingOut		; $5736
	ret nz			; $5739
	call incCbc2		; $573a
	ld a,e			; $573d
	ld (wTmpcbb3),a		; $573e
	jp showText		; $5741
	call _cutscene_decCBB3IfTextNotActive		; $5744
	ret nz			; $5747
	call incCbc2		; $5748
	ld hl,wTmpcbb5		; $574b
	ld (hl),$d0		; $574e
_label_03_089:
	ld hl,$4d05		; $5750
	ld e,$16		; $5753
_label_03_090:
	ld b,$30		; $5755
	push de			; $5757
	ld de,wTmpcbb5		; $5758
	ld a,(de)		; $575b
	pop de			; $575c
	ld c,a			; $575d
	jp $60b8		; $575e
	ld hl,wTmpcbb5		; $5761
	inc (hl)		; $5764
	jr nz,_label_03_089	; $5765
	call clearOam		; $5767
	ld a,UNCMP_GFXH_0a		; $576a
	call loadUncompressedGfxHeader		; $576c
	ld hl,wTmpcbb3		; $576f
	ld (hl),$1e		; $5772
	jp incCbc2		; $5774
	call decCbb3		; $5777
	ret nz			; $577a
	call incCbc2		; $577b
	ld hl,wTmpcbb5		; $577e
	ld (hl),$d0		; $5781
	ld hl,$4d9e		; $5783
	ld e,$16		; $5786
	jr _label_03_090		; $5788
	call $5783		; $578a
	ld hl,wTmpcbb5		; $578d
	dec (hl)		; $5790
	ld a,(hl)		; $5791
	sub $a0			; $5792
	ret nz			; $5794
	ld (wScreenOffsetY),a		; $5795
	ld (wScreenOffsetX),a		; $5798
	ld a,$1e		; $579b
	ld (wTmpcbb3),a		; $579d
	ld (wOpenedMenuType),a		; $57a0
	jp incCbc2		; $57a3
	call $5783		; $57a6
	call decCbb3		; $57a9
	ret nz			; $57ac
	ld hl,wTmpcbb3		; $57ad
	ld (hl),$14		; $57b0
	ld bc,$280c		; $57b2
	call $56a5		; $57b5
	jp incCbc2		; $57b8
	call $5783		; $57bb
	call _cutscene_decCBB3IfTextNotActive		; $57be
	ret nz			; $57c1
	xor a			; $57c2
	ld (wOpenedMenuType),a		; $57c3
	dec a			; $57c6
	ld (wTmpcbba),a		; $57c7
	ld a,SND_LIGHTNING		; $57ca
	call playSound		; $57cc
	jp incCbc2		; $57cf
	call $5783		; $57d2
	ld hl,wTmpcbb3		; $57d5
	ld b,$02		; $57d8
	call flashScreen		; $57da
	ret z			; $57dd
	call incCbc2		; $57de
	ld hl,wTmpcbb3		; $57e1
	ld (hl),$1e		; $57e4
	call disableLcd		; $57e6
	call clearOam		; $57e9
	xor a			; $57ec
	ld ($ff00+R_VBK),a	; $57ed
	ld hl,$8000		; $57ef
	ld bc,$2000		; $57f2
	call clearMemoryBc		; $57f5
	xor a			; $57f8
	ld ($ff00+R_VBK),a	; $57f9
	ld hl,$9c00		; $57fb
	ld bc,$0400		; $57fe
	call clearMemoryBc		; $5801
	ld a,$01		; $5804
	ld ($ff00+R_VBK),a	; $5806
	ld hl,$9c00		; $5808
	ld bc,$0400		; $580b
	call clearMemoryBc		; $580e
	ld a,$2d		; $5811
	call loadGfxHeader		; $5813
	ld a,PALH_9c		; $5816
	call loadPaletteHeader		; $5818
	ld a,$04		; $581b
	call loadGfxRegisterStateIndex		; $581d
	ld a,SND_LIGHTNING		; $5820
	call playSound		; $5822
	jp clearPaletteFadeVariablesAndRefreshPalettes		; $5825
	call decCbb3		; $5828
	ret nz			; $582b
	ld a,$0a		; $582c
	ld (wCutsceneIndex),a		; $582e
	call cutscene_clearTmpCBB3		; $5831
	ld hl,wRoomLayout		; $5834
	ld bc,$00c0		; $5837
	call clearMemoryBc		; $583a
	ld hl,wRoomCollisions		; $583d
	ld bc,$00c0		; $5840
	call clearMemoryBc		; $5843
	ldh (<hCameraY),a	; $5846
	ldh (<hCameraX),a	; $5848
	ld hl,wTmpcbb3		; $584a
	ld (hl),$3c		; $584d
	ld a,$03		; $584f
	jp fadeoutToBlackWithDelay		; $5851

;;
; CUTSCENE_FLAME_OF_DESPAIR
; @addr{5854}
_endgameCutsceneHandler_20:
	call $585a		; $5854
	jp updateAllObjects		; $5857
	ld de,$cbc1		; $585a
	ld a,(de)		; $585d
	rst_jumpTable			; $585e
.dw $588d
.dw $58bf
.dw $58d6
.dw $58e6
.dw $5938
.dw $594e
.dw $5964
.dw $596b
.dw $5979
.dw $59c1
.dw $5a02
.dw $5a28
.dw $5a3f
.dw $5a51
.dw $5ab9
.dw $5ad9
.dw $5ae1
.dw $5aed
.dw $5af5
.dw $5afa
.dw $5b0e
.dw $5b25
.dw $5b40

	ld a,$0b		; $588d
	ld ($cfde),a		; $588f
	call _cutscene_loadObjectSetAndFadein		; $5892
	call hideStatusBar		; $5895
	ld a,PALH_ac		; $5898
	call loadPaletteHeader		; $589a
	xor a			; $589d
	ld (wPaletteThread_mode),a		; $589e
	call _clearFadingPalettes		; $58a1
	ld hl,wTmpcbb3		; $58a4
	ld (hl),$1e		; $58a7
	ld a,$13		; $58a9
	call loadGfxRegisterStateIndex		; $58ab
	ld hl,wGfxRegs1.SCY		; $58ae
	ldi a,(hl)		; $58b1
	ldh (<hCameraY),a	; $58b2
	ld a,(hl)		; $58b4
	ldh (<hCameraX),a	; $58b5
	ld a,$00		; $58b7
	ld (wScrollMode),a		; $58b9
	jp incCbc1		; $58bc
	call decCbb3		; $58bf
_label_03_091:
	ret nz			; $58c2
	call incCbc1		; $58c3
	ld hl,wTmpcbb3		; $58c6
	ld (hl),$28		; $58c9
	ld a,TEXTBOXFLAG_ALTPALETTE1		; $58cb
	ld (wTextboxFlags),a		; $58cd
	ld bc,$2825		; $58d0
	jp showText		; $58d3
	call _cutscene_decCBB3IfTextNotActive		; $58d6
	ret nz			; $58d9
	call incCbc1		; $58da
	ld a,$20		; $58dd
	ld hl,wTmpcbb3		; $58df
	ldi (hl),a		; $58e2
	xor a			; $58e3
	ld (hl),a		; $58e4
	ret			; $58e5
	call _cutscene_decCBB3IfNotFadingOut		; $58e6
	ret nz			; $58e9
	ld hl,wTmpcbb3		; $58ea
	ld (hl),$20		; $58ed
	inc hl			; $58ef
	ld a,(hl)		; $58f0
	cp $03			; $58f1
	jr nc,_label_03_092	; $58f3
	ld b,a			; $58f5
	push hl			; $58f6
	ld a,SND_LIGHTTORCH		; $58f7
	call playSound		; $58f9
	pop hl			; $58fc
	ld a,b			; $58fd
_label_03_092:
	inc (hl)		; $58fe
	ld hl,$5932		; $58ff
	rst_addAToHl			; $5902
	ld a,(hl)		; $5903
	or a			; $5904
	ld b,a			; $5905
	jr nz,_label_03_093	; $5906
	call fadeinFromBlack		; $5908
	ld a,$01		; $590b
	ld (wDirtyFadeSprPalettes),a		; $590d
	ld (wFadeSprPaletteSources),a		; $5910
	ld hl,wTmpcbb3		; $5913
	ld (hl),$3c		; $5916
	ld a,MUS_ROOM_OF_RITES		; $5918
	call playSound		; $591a
	jp incCbc1		; $591d
_label_03_093:
	call fastFadeinFromBlack		; $5920
	ld a,b			; $5923
	ld (wDirtyFadeSprPalettes),a		; $5924
	ld (wFadeSprPaletteSources),a		; $5927
	xor a			; $592a
	ld (wDirtyFadeBgPalettes),a		; $592b
	ld (wFadeBgPaletteSources),a		; $592e
	ret			; $5931
	ld b,b			; $5932
	stop			; $5933
	add b			; $5934
	jr z,_label_03_094	; $5935
	nop			; $5937
	ld e,$28		; $5938
	ld bc,$2826		; $593a
_label_03_094:
	call $5943		; $593d
	jp $6078		; $5940
	ld a,TEXTBOXFLAG_DONTCHECKPOSITION		; $5943
	ld (wTextboxFlags),a		; $5945
	ld a,$03		; $5948
	ld (wTextboxPosition),a		; $594a
	ret			; $594d
	ld e,$28		; $594e
	ld bc,$2827		; $5950
_label_03_095:
	call _cutscene_decCBB3IfTextNotActive		; $5953
	ret nz			; $5956
	call incCbc1		; $5957
	ld hl,wTmpcbb3		; $595a
	ld (hl),e		; $595d
	call $5943		; $595e
	jp showText		; $5961
	ld e,$3c		; $5964
	ld bc,$2828		; $5966
	jr _label_03_095		; $5969
	ld e,$b4		; $596b
	call _cutscene_decCBB3IfTextNotActive		; $596d
	ret nz			; $5970
	call incCbc1		; $5971
	ld hl,wTmpcbb3		; $5974
	ld (hl),e		; $5977
	ret			; $5978
	call $5995		; $5979
	call $609b		; $597c
	call decCbb3		; $597f
	ret nz			; $5982
	ld a,SNDCTRL_STOPSFX		; $5983
	call playSound		; $5985
	ld a,SNDCTRL_MEDIUM_FADEOUT		; $5988
	call playSound		; $598a
	call incCbc1		; $598d
	ld a,$04		; $5990
	jp fadeoutToWhiteWithDelay		; $5992
	ld hl,wGfxRegs1.SCY		; $5995
	ldh a,(<hCameraY)	; $5998
	ldi (hl),a		; $599a
	ldh a,(<hCameraX)	; $599b
	ldi (hl),a		; $599d
	ld hl,$59ab		; $599e
	ld de,wGfxRegs1.SCY		; $59a1
	call $59b3		; $59a4
	inc de			; $59a7
	jp $59b3		; $59a8
	rst $38			; $59ab
	ld bc,$0100		; $59ac
	nop			; $59af
	nop			; $59b0
	rst $38			; $59b1
	nop			; $59b2
	push hl			; $59b3
	call getRandomNumber		; $59b4
	and $07			; $59b7
	rst_addAToHl			; $59b9
	ld a,(hl)		; $59ba
	ld b,a			; $59bb
	ld a,(de)		; $59bc
	add b			; $59bd
	ld (de),a		; $59be
	pop hl			; $59bf
	ret			; $59c0
	call $5995		; $59c1
	ld a,(wPaletteThread_mode)		; $59c4
	or a			; $59c7
	ret nz			; $59c8
	call incCbc1		; $59c9
	ld a,$0c		; $59cc
	ld ($cfde),a		; $59ce
	call _cutscene_loadObjectSetAndFadein		; $59d1
	ld hl,$d000		; $59d4
	ld (hl),$03		; $59d7
	ld l,$0b		; $59d9
	ld (hl),$48		; $59db
	ld l,$0d		; $59dd
	ld (hl),$60		; $59df
	ld l,$08		; $59e1
	ld (hl),$00		; $59e3
	ld a,$81		; $59e5
	ld (wDisabledObjects),a		; $59e7
	ld (wMenuDisabled),a		; $59ea
	call _cutscene_clearCFC0ToCFDF		; $59ed
	call showStatusBar		; $59f0
	ld a,SNDCTRL_STOPSFX		; $59f3
	call playSound		; $59f5
	ld a,SNDCTRL_STOPMUSIC		; $59f8
	call playSound		; $59fa
	ld a,$02		; $59fd
	jp loadGfxRegisterStateIndex		; $59ff
	call updateStatusBar		; $5a02
	ld a,($cfd0)		; $5a05
	cp $01			; $5a08
	ret nz			; $5a0a
	call incCbc1		; $5a0b
	ld c,$40		; $5a0e
	ld a,$29		; $5a10
	call giveTreasure		; $5a12
	ld a,$08		; $5a15
	call setLinkIDOverride		; $5a17
	ld l,$02		; $5a1a
	ld (hl),$0c		; $5a1c
	ld hl,wTmpcbb3		; $5a1e
	ld (hl),$5a		; $5a21
	ld a,MUS_PRECREDITS		; $5a23
	jp playSound		; $5a25
	call updateStatusBar		; $5a28
	call decCbb3		; $5a2b
	ret nz			; $5a2e
	call incCbc1		; $5a2f
	ld hl,wTmpcbb3		; $5a32
	ld (hl),$b4		; $5a35
	ld bc,$4860		; $5a37
	ld a,$ff		; $5a3a
	jp createEnergySwirlGoingOut		; $5a3c
	call updateStatusBar		; $5a3f
	call decCbb3		; $5a42
	ret nz			; $5a45
	call incCbc1		; $5a46
	ld hl,wTmpcbb3		; $5a49
	ld (hl),$3c		; $5a4c
	jp fadeoutToWhite		; $5a4e
	call _cutscene_decCBB3IfNotFadingOut		; $5a51
	ret nz			; $5a54
	call incCbc1		; $5a55
	call disableLcd		; $5a58
	call clearOam		; $5a5b
	call clearScreenVariablesAndWramBank1		; $5a5e
	call refreshObjectGfx		; $5a61
	call hideStatusBar		; $5a64
	ld a,$02		; $5a67
	ld ($ff00+R_SVBK),a	; $5a69
	ld hl,$de90		; $5a6b
	ld b,$08		; $5a6e
	ld a,$ff		; $5a70
	call fillMemory		; $5a72
	xor a			; $5a75
	ld ($ff00+R_SVBK),a	; $5a76
	ld a,$07		; $5a78
	ldh (<hDirtyBgPalettes),a	; $5a7a
	call getFreeInteractionSlot		; $5a7c
	jr nz,_label_03_096	; $5a7f
	ld (hl),$36		; $5a81
	inc l			; $5a83
	ld (hl),$12		; $5a84
	call getFreeInteractionSlot		; $5a86
	jr nz,_label_03_096	; $5a89
	ld (hl),$aa		; $5a8b
	inc l			; $5a8d
	ld (hl),$02		; $5a8e
_label_03_096:
	ld a,$02		; $5a90
	ld (wOpenedMenuType),a		; $5a92
	call $6e9a		; $5a95
	ld a,$02		; $5a98
	call $6ed6		; $5a9a
	ld hl,wTmpcbb3		; $5a9d
	ld (hl),$1e		; $5aa0
	ld a,$04		; $5aa2
	call loadGfxRegisterStateIndex		; $5aa4
	ld a,$10		; $5aa7
	ldh (<hCameraY),a	; $5aa9
	xor a			; $5aab
	ldh (<hCameraX),a	; $5aac
	ld a,$00		; $5aae
	ld (wScrollMode),a		; $5ab0
	ld bc,$1d1a		; $5ab3
	jp showText		; $5ab6
	call _cutscene_decCBB3IfTextNotActive		; $5ab9
	ret nz			; $5abc
	call incCbc1		; $5abd
	ld b,$04		; $5ac0
	call fadeinFromWhite		; $5ac2
	ld a,b			; $5ac5
	ld (wDirtyFadeSprPalettes),a		; $5ac6
	ld (wFadeSprPaletteSources),a		; $5ac9
	xor a			; $5acc
	ld (wDirtyFadeBgPalettes),a		; $5acd
	ld (wFadeBgPaletteSources),a		; $5ad0
	ld hl,wTmpcbb3		; $5ad3
	ld (hl),$3c		; $5ad6
	ret			; $5ad8
	ld e,$1e		; $5ad9
	ld bc,$1d1b		; $5adb
	jp $6078		; $5ade
	call _cutscene_decCBB3IfTextNotActive		; $5ae1
	ret nz			; $5ae4
	call incCbc1		; $5ae5
	ld b,$12		; $5ae8
	jp $5ac2		; $5aea
	ld e,$1e		; $5aed
	ld bc,$1d1c		; $5aef
	jp $6078		; $5af2
	ld e,$3c		; $5af5
	jp $596d		; $5af7
	call decCbb3		; $5afa
	ret nz			; $5afd
	call incCbc1		; $5afe
	ld hl,wTmpcbb3		; $5b01
	ld (hl),$f0		; $5b04
	ld a,$ff		; $5b06
	ld bc,$4850		; $5b08
	jp createEnergySwirlGoingOut		; $5b0b
	call decCbb3		; $5b0e
	ret nz			; $5b11
	ld hl,wTmpcbb3		; $5b12
	ld (hl),$5a		; $5b15
	call fadeoutToWhite		; $5b17
	ld a,$fc		; $5b1a
	ld (wDirtyFadeBgPalettes),a		; $5b1c
	ld (wFadeBgPaletteSources),a		; $5b1f
	jp incCbc1		; $5b22
	call _cutscene_decCBB3IfNotFadingOut		; $5b25
	ret nz			; $5b28
	call incCbc1		; $5b29
	call clearDynamicInteractions		; $5b2c
	call clearParts		; $5b2f
	call clearOam		; $5b32
	ld hl,wTmpcbb3		; $5b35
	ld (hl),$3c		; $5b38
	ld bc,$1d1d		; $5b3a
	jp showTextNonExitable		; $5b3d
	ld a,(wTextIsActive)		; $5b40
	rlca			; $5b43
	ret nc			; $5b44
	call decCbb3		; $5b45
	ret nz			; $5b48
	call showStatusBar		; $5b49
	xor a			; $5b4c
	ld (wOpenedMenuType),a		; $5b4d
	dec a			; $5b50
	ld (wActiveMusic),a		; $5b51
	ld a,SNDCTRL_FAST_FADEOUT		; $5b54
	call playSound		; $5b56
	ld hl,$5b5f		; $5b59
	jp setWarpDestVariables		; $5b5c
	add l			; $5b5f
.DB $f4				; $5b60
	rrca			; $5b61
	ld d,a			; $5b62
	inc bc			; $5b63


;;
; CUTSCENE_ROOM_OF_RITES_COLLAPSE
; @addr{5b64}
_endgameCutsceneHandler_0f:
	ld de,$cbc1		; $5b64
	ld a,(de)		; $5b67
	rst_jumpTable			; $5b68
.dw $5b6d
.dw $5cbe

	call updateStatusBar		; $5b6d
	call $5b76		; $5b70
	jp updateAllObjects		; $5b73
	ld de,$cbc2		; $5b76
	ld a,(de)		; $5b79
	rst_jumpTable			; $5b7a
.dw $5b97
.dw $5bc0
.dw $5bd1
.dw $5be3
.dw $5bfd
.dw $5c11
.dw $5c20
.dw $5c34
.dw $5c46
.dw $5c58
.dw $5c6d
.dw $5c72
.dw $5c8c
.dw $5c9e

	ld a,$01		; $5b97
	ld (de),a		; $5b99
	ld hl,wActiveRing		; $5b9a
	ld (hl),$ff		; $5b9d
	xor a			; $5b9f
	ldh (<hActiveObjectType),a	; $5ba0
	ld de,$d000		; $5ba2
	ld bc,$f8f0		; $5ba5
	ld a,$28		; $5ba8
	call objectCreateExclamationMark		; $5baa
	ld a,$28		; $5bad
	call objectCreateExclamationMark		; $5baf
	ld l,$4b		; $5bb2
	ld (hl),$30		; $5bb4
	inc l			; $5bb6
	inc l			; $5bb7
	ld (hl),$78		; $5bb8
	ld hl,wTmpcbb3		; $5bba
	ld (hl),$0a		; $5bbd
	ret			; $5bbf
	call decCbb3		; $5bc0
	ret nz			; $5bc3
	ld hl,wTmpcbb3		; $5bc4
	ld (hl),$1e		; $5bc7
	ld a,SNDCTRL_STOPMUSIC		; $5bc9
	call playSound		; $5bcb
	jp incCbc2		; $5bce
	call $6096		; $5bd1
	call decCbb3		; $5bd4
	ret nz			; $5bd7
	call incCbc2		; $5bd8
	ld hl,wTmpcbb3		; $5bdb
	ld (hl),$96		; $5bde
	jp $5cb0		; $5be0
	call $6096		; $5be3
	call decCbb3		; $5be6
	ret nz			; $5be9
	call incCbc2		; $5bea
	ld a,SNDCTRL_STOPSFX		; $5bed
	call playSound		; $5bef
	ld hl,wTmpcbb3		; $5bf2
	ld (hl),$3c		; $5bf5
	ld bc,$3d0e		; $5bf7
	jp showText		; $5bfa
	call _cutscene_decCBB3IfTextNotActive		; $5bfd
	ret nz			; $5c00
	call incCbc2		; $5c01
	ld a,MUS_DISASTER		; $5c04
	call playSound		; $5c06
	ld hl,wTmpcbb3		; $5c09
	ld (hl),$3c		; $5c0c
	jp $5cb0		; $5c0e
	call $6096		; $5c11
	call decCbb3		; $5c14
	ret nz			; $5c17
	ld hl,wTmpcbb3		; $5c18
	ld (hl),$5a		; $5c1b
	jp incCbc2		; $5c1d
	call $6096		; $5c20
	call decCbb3		; $5c23
	ret nz			; $5c26
	call incCbc2		; $5c27
	ld hl,wTmpcbb3		; $5c2a
	ld (hl),$3c		; $5c2d
	ld a,SNDCTRL_STOPSFX		; $5c2f
	jp playSound		; $5c31
	call decCbb3		; $5c34
	ret nz			; $5c37
	call incCbc2		; $5c38
	ld hl,wTmpcbb3		; $5c3b
	ld (hl),$3c		; $5c3e
	ld bc,$3d0f		; $5c40
	jp showText		; $5c43
	call _cutscene_decCBB3IfTextNotActive		; $5c46
	ret nz			; $5c49
	call incCbc2		; $5c4a
	ld hl,wTmpcbb3		; $5c4d
	ld (hl),$68		; $5c50
	inc hl			; $5c52
	ld (hl),$01		; $5c53
	jp $5cb7		; $5c55
	ld hl,wTmpcbb3		; $5c58
	call decHlRef16WithCap		; $5c5b
	ret nz			; $5c5e
	call incCbc2		; $5c5f
	ld hl,wTmpcbb3		; $5c62
	ld (hl),$3c		; $5c65
	ld bc,$0563		; $5c67
	jp showText		; $5c6a
	ld e,$1e		; $5c6d
	jp $605c		; $5c6f
	call $6096		; $5c72
	call decCbb3		; $5c75
	ret nz			; $5c78
	call incCbc2		; $5c79
	call $5cb0		; $5c7c
	ld a,$8c		; $5c7f
	ld (wTmpcbb3),a		; $5c81
	ld a,$ff		; $5c84
	ld bc,$4478		; $5c86
	jp createEnergySwirlGoingOut		; $5c89
	call $6096		; $5c8c
	call decCbb3		; $5c8f
	ret nz			; $5c92
	call incCbc2		; $5c93
	ld hl,wTmpcbb3		; $5c96
	ld (hl),$3c		; $5c99
	jp $5cb0		; $5c9b
	call $6096		; $5c9e
	call decCbb3		; $5ca1
	ret nz			; $5ca4
	call incCbc1		; $5ca5
	inc l			; $5ca8
	xor a			; $5ca9
	ld (hl),a		; $5caa
	ld a,$03		; $5cab
	jp fadeoutToWhiteWithDelay		; $5cad
	call getFreePartSlot		; $5cb0
	ret nz			; $5cb3
	ld (hl),$54		; $5cb4
	ret			; $5cb6
	call getFreeInteractionSlot		; $5cb7
	ret nz			; $5cba
	ld (hl),$62		; $5cbb
	ret			; $5cbd
	call updateStatusBar		; $5cbe
	call $5cc7		; $5cc1
	jp updateAllObjects		; $5cc4
	ld de,$cbc2		; $5cc7
	ld a,(de)		; $5cca
	rst_jumpTable			; $5ccb
.dw $5ce2
.dw $5d10
.dw $5d24
.dw $5d33
.dw $5d4e
.dw $5d69
.dw $5d76
.dw $5d91
.dw $5d9f
.dw $5dcc
.dw $5de0

	call $6096		; $5ce2
	ld a,(wPaletteThread_mode)		; $5ce5
	or a			; $5ce8
	ret nz			; $5ce9
	call incCbc2		; $5cea
	ld a,$11		; $5ced
	ld ($cfde),a		; $5cef
	call _cutscene_loadObjectSetAndFadein		; $5cf2
	ld a,$04		; $5cf5
	ld b,$02		; $5cf7
	call $6056		; $5cf9
	ld a,SNDCTRL_STOPSFX		; $5cfc
	call playSound		; $5cfe
	ld a,SNDCTRL_FAST_FADEOUT		; $5d01
	call playSound		; $5d03
	ld hl,wTmpcbb3		; $5d06
	ld (hl),$3c		; $5d09
	ld a,$02		; $5d0b
	jp loadGfxRegisterStateIndex		; $5d0d
	call _cutscene_decCBB3IfNotFadingOut		; $5d10
	ret nz			; $5d13
	call incCbc2		; $5d14
	ld a,$3c		; $5d17
	ld (wTmpcbb3),a		; $5d19
	ld a,$64		; $5d1c
	ld bc,$4850		; $5d1e
	jp createEnergySwirlGoingIn		; $5d21
	call decCbb3		; $5d24
	ret nz			; $5d27
	xor a			; $5d28
	ld (wTmpcbb3),a		; $5d29
	dec a			; $5d2c
	ld (wTmpcbba),a		; $5d2d
	jp incCbc2		; $5d30
	ld hl,wTmpcbb3		; $5d33
	ld b,$01		; $5d36
	call flashScreen		; $5d38
	ret z			; $5d3b
	call incCbc2		; $5d3c
	ld hl,wTmpcbb3		; $5d3f
	ld (hl),$3c		; $5d42
	ld a,$01		; $5d44
	ld ($cfc0),a		; $5d46
	ld a,$03		; $5d49
	jp fadeinFromWhiteWithDelay		; $5d4b
	call _cutscene_decCBB3IfNotFadingOut		; $5d4e
	ret nz			; $5d51
	call refreshObjectGfx		; $5d52
	ld a,$04		; $5d55
	ld b,$02		; $5d57
	call $603a		; $5d59
	ld a,MUS_CREDITS_1		; $5d5c
	call playSound		; $5d5e
	ld hl,wTmpcbb3		; $5d61
	ld (hl),$3c		; $5d64
	jp incCbc2		; $5d66
	call decCbb3		; $5d69
	ret nz			; $5d6c
	call incCbc2		; $5d6d
	ld hl,wTmpcbb3		; $5d70
	ld (hl),$1e		; $5d73
	ret			; $5d75
	call decCbb3		; $5d76
	ret nz			; $5d79
	call refreshObjectGfx		; $5d7a
	ld a,$04		; $5d7d
	ld b,$02		; $5d7f
	call $603a		; $5d81
	ld hl,wTmpcbb3		; $5d84
	ld (hl),$3c		; $5d87
	ld hl,$cfc0		; $5d89
	ld (hl),$02		; $5d8c
	jp incCbc2		; $5d8e
	ld a,($cfc0)		; $5d91
	cp $09			; $5d94
	ret nz			; $5d96
	call incCbc2		; $5d97
	ld a,$03		; $5d9a
	jp fadeoutToWhiteWithDelay		; $5d9c
	ld a,(wPaletteThread_mode)		; $5d9f
	or a			; $5da2
	ret nz			; $5da3
	call incCbc2		; $5da4
	call disableLcd		; $5da7
	call clearScreenVariablesAndWramBank1		; $5daa
	call hideStatusBar		; $5dad
	ld a,$3c		; $5db0
	call loadGfxHeader		; $5db2
	ld a,PALH_c9		; $5db5
	call loadPaletteHeader		; $5db7
	ld hl,wTmpcbb3		; $5dba
	ld (hl),$f0		; $5dbd
	ld a,$04		; $5dbf
	call loadGfxRegisterStateIndex		; $5dc1
	call _cutscene_resetOamWithSomething1		; $5dc4
	ld a,$03		; $5dc7
	jp fadeinFromWhiteWithDelay		; $5dc9
	call _cutscene_resetOamWithSomething1		; $5dcc
	call _cutscene_decCBB3IfNotFadingOut		; $5dcf
	ret nz			; $5dd2
	call incCbc2		; $5dd3
	ld hl,wTmpcbb3		; $5dd6
	ld (hl),$10		; $5dd9
	ld a,$03		; $5ddb
	jp fadeoutToBlackWithDelay		; $5ddd
	call _cutscene_resetOamWithSomething1		; $5de0
	call _cutscene_decCBB3IfNotFadingOut		; $5de3
	ret nz			; $5de6
	ld a,$0a		; $5de7
	ld (wCutsceneIndex),a		; $5de9
	call cutscene_clearTmpCBB3		; $5dec
	ld hl,wRoomLayout		; $5def
	ld bc,$00c0		; $5df2
	call clearMemoryBc		; $5df5
	ld hl,wRoomCollisions		; $5df8
	ld bc,$00c0		; $5dfb
	call clearMemoryBc		; $5dfe
	xor a			; $5e01
	ldh (<hCameraY),a	; $5e02
	ldh (<hCameraX),a	; $5e04
	ld hl,wTmpcbb3		; $5e06
	ld (hl),$3c		; $5e09
	ld a,SNDCTRL_MEDIUM_FADEOUT		; $5e0b
	jp playSound		; $5e0d

;;
; CUTSCENE_CREDITS
; @addr{5e10}
_endgameCutsceneHandler_0a:
	call $5e16		; $5e10
	jp func_3539		; $5e13
	ld de,$cbc1		; $5e16
	ld a,(de)		; $5e19
	rst_jumpTable			; $5e1a
.dw $5e23
.dw $5e88
.dw $5fd5
.dw $5fdd

	ld de,$cbc2		; $5e23
	ld a,(de)		; $5e26
	rst_jumpTable			; $5e27
.dw $5e2e
.dw $5e4d
.dw $5e69

	call _cutscene_decCBB3IfNotFadingOut		; $5e2e
	ret nz			; $5e31
	call func_60e0		; $5e32
	call incCbc2		; $5e35
	call clearOam		; $5e38
	ld hl,wTmpcbb3		; $5e3b
	ld (hl),$b4		; $5e3e
	inc hl			; $5e40
	ld (hl),$00		; $5e41
	ld hl,wGfxRegs1.LCDC		; $5e43
	set 3,(hl)		; $5e46
	ld a,MUS_CREDITS_2		; $5e48
	jp playSound		; $5e4a
	ld hl,wTmpcbb3		; $5e4d
	call decHlRef16WithCap		; $5e50
	ret nz			; $5e53
	call incCbc2		; $5e54
	ld hl,wTmpcbb3		; $5e57
	ld (hl),$48		; $5e5a
	inc hl			; $5e5c
	ld (hl),$03		; $5e5d
	ld a,PALH_04		; $5e5f
	call loadPaletteHeader		; $5e61
	ld a,$06		; $5e64
	jp fadeinFromBlackWithDelay		; $5e66
	ld hl,wTmpcbb3		; $5e69
	call decHlRef16WithCap		; $5e6c
	ret nz			; $5e6f
	call incCbc1		; $5e70
	inc l			; $5e73
	ld (hl),a		; $5e74
	ld b,$00		; $5e75
	call checkIsLinkedGame		; $5e77
	jr z,_label_03_097	; $5e7a
	ld b,$04		; $5e7c
_label_03_097:
	ld hl,$cfde		; $5e7e
	ld (hl),b		; $5e81
	inc l			; $5e82
	ld (hl),$00		; $5e83
	jp fadeoutToWhite		; $5e85
	ld de,$cbc2		; $5e88
	ld a,(de)		; $5e8b
	rst_jumpTable			; $5e8c
.dw $5e97
.dw $5f30
.dw $5f45
.dw $5f89
.dw $5fa3

	xor a			; $5e97
	ldh (<hOamTail),a	; $5e98
	ld a,(wPaletteThread_mode)		; $5e9a
	or a			; $5e9d
	ret nz			; $5e9e
	call disableLcd		; $5e9f
	call incCbc2		; $5ea2
	call clearDynamicInteractions		; $5ea5
	call clearOam		; $5ea8
	ld a,$10		; $5eab
	ldh (<hOamTail),a	; $5ead
	ld a,($cfde)		; $5eaf
	ld c,a			; $5eb2
	call _cutscene_clearCFC0ToCFDF		; $5eb3
	ld a,c			; $5eb6
	ld ($cfde),a		; $5eb7
	cp $04			; $5eba
	jr nc,_label_03_098	; $5ebc
	ld hl,$5f1c		; $5ebe
	rst_addDoubleIndex			; $5ec1
	ld b,(hl)		; $5ec2
	inc hl			; $5ec3
	ld c,(hl)		; $5ec4
	ld a,$00		; $5ec5
	call func_36f6		; $5ec7
	ld a,($cfde)		; $5eca
	ld hl,$5f24		; $5ecd
	rst_addAToHl			; $5ed0
	ldi a,(hl)		; $5ed1
	call loadUncompressedGfxHeader		; $5ed2
_label_03_098:
	ld a,($cfde)		; $5ed5
	add a			; $5ed8
	add $85			; $5ed9
	call loadGfxHeader		; $5edb
	ld a,PALH_0f		; $5ede
	call loadPaletteHeader		; $5ee0
	ld a,($cfde)		; $5ee3
	ld b,$ff		; $5ee6
	or a			; $5ee8
	jr z,_label_03_099	; $5ee9
	cp $07			; $5eeb
	jr z,_label_03_099	; $5eed
	ld b,$01		; $5eef
_label_03_099:
	ld c,a			; $5ef1
	ld a,b			; $5ef2
	ld (wAreaAnimation),a		; $5ef3
	call loadAnimationData		; $5ef6
	ld a,c			; $5ef9
	ld hl,$5f28		; $5efa
	rst_addAToHl			; $5efd
	ldi a,(hl)		; $5efe
	call loadPaletteHeader		; $5eff
	call reloadObjectGfx		; $5f02
	ld a,$01		; $5f05
	ld (wScrollMode),a		; $5f07
	xor a			; $5f0a
	ldh (<hCameraX),a	; $5f0b
	ld hl,$cfde		; $5f0d
	ld b,(hl)		; $5f10
	call $601a		; $5f11
	ld a,$04		; $5f14
	call loadGfxRegisterStateIndex		; $5f16
	jp fadeinFromWhite		; $5f19
	nop			; $5f1c
	jr c,_label_03_100	; $5f1d
_label_03_100:
	ldd a,(hl)		; $5f1f
	nop			; $5f20
	ld c,d			; $5f21
	ld bc,$2d16		; $5f22
	rrca			; $5f25
	dec l			; $5f26
	rrca			; $5f27
	jr nc,_label_03_101	; $5f28
	dec l			; $5f2a
	daa			; $5f2b
	jp z,$caca		; $5f2c
	xor (hl)		; $5f2f
	ld a,(wPaletteThread_mode)		; $5f30
	or a			; $5f33
	ret nz			; $5f34
	ld a,($cfdf)		; $5f35
	or a			; $5f38
	ret z			; $5f39
	call incCbc2		; $5f3a
	ld a,$ff		; $5f3d
	ld (wAreaAnimation),a		; $5f3f
	jp fadeoutToWhite		; $5f42
	ld a,(wPaletteThread_mode)		; $5f45
	or a			; $5f48
	ret nz			; $5f49
	call incCbc2		; $5f4a
	call disableLcd		; $5f4d
	call clearWramBank1		; $5f50
	ld a,($cfde)		; $5f53
	add a			; $5f56
_label_03_101:
	add $86			; $5f57
	call loadGfxHeader		; $5f59
	ld hl,wTmpcbb3		; $5f5c
	ld (hl),$5a		; $5f5f
	ld a,PALH_a1		; $5f61
	call loadPaletteHeader		; $5f63
	ld a,$04		; $5f66
	call loadGfxRegisterStateIndex		; $5f68
	ld a,($cfde)		; $5f6b
	ld hl,$5f81		; $5f6e
	rst_addAToHl			; $5f71
	ld a,(hl)		; $5f72
	ld (wGfxRegs1.SCX),a		; $5f73
	ld a,$10		; $5f76
	ldh (<hCameraX),a	; $5f78
	xor a			; $5f7a
	ld ($cfdf),a		; $5f7b
	jp fadeinFromWhite		; $5f7e
	nop			; $5f81
	ret nc			; $5f82
	nop			; $5f83
	ret nc			; $5f84
	nop			; $5f85
	ret nc			; $5f86
	nop			; $5f87
	ret nc			; $5f88
	ld a,(wPaletteThread_mode)		; $5f89
	or a			; $5f8c
	ret nz			; $5f8d
	call decCbb3		; $5f8e
	ret nz			; $5f91
	call incCbc2		; $5f92
	call getFreeInteractionSlot		; $5f95
	ret nz			; $5f98
	ld (hl),$ae		; $5f99
	inc l			; $5f9b
	ld a,($cfde)		; $5f9c
	ldi (hl),a		; $5f9f
	ld (hl),$00		; $5fa0
	ret			; $5fa2
	ld a,(wPaletteThread_mode)		; $5fa3
	or a			; $5fa6
	ret nz			; $5fa7
	xor a			; $5fa8
	ldh (<hOamTail),a	; $5fa9
	ld a,($cfdf)		; $5fab
	or a			; $5fae
	ret z			; $5faf
	ld b,$03		; $5fb0
	call checkIsLinkedGame		; $5fb2
	jr z,_label_03_102	; $5fb5
	ld b,$07		; $5fb7
_label_03_102:
	ld hl,$cfde		; $5fb9
	ld a,(hl)		; $5fbc
	cp b			; $5fbd
	jr nc,_label_03_103	; $5fbe
	inc (hl)		; $5fc0
	xor a			; $5fc1
	ld ($cbc2),a		; $5fc2
	jr _label_03_104		; $5fc5
_label_03_103:
	call cutscene_clearTmpCBB3		; $5fc7
	call _cutscene_clearCFC0ToCFDF		; $5fca
	ld a,$02		; $5fcd
	ld ($cbc1),a		; $5fcf
_label_03_104:
	jp fadeoutToWhite		; $5fd2
	ld hl,$70f6		; $5fd5
	ld e,$10		; $5fd8
	jp interBankCall		; $5fda
	ld hl,$7298		; $5fdd
	ld e,$10		; $5fe0
	jp interBankCall		; $5fe2

;;
; Called from disableLcdAndLoadRoom in bank 0.
;
; @addr{5fe5}
disableLcdAndLoadRoom_body:
	ld a,b			; $5fe5
	ld (wActiveGroup),a		; $5fe6
	ld a,c			; $5fe9
	ld (wActiveRoom),a		; $5fea
	call disableLcd		; $5fed
	call clearScreenVariablesAndWramBank1		; $5ff0
	ld hl,wLinkInAir		; $5ff3
	ld b,wcce9-wLinkInAir		; $5ff6
	call clearMemory		; $5ff8
	call initializeVramMaps		; $5ffb
	call loadScreenMusicAndSetRoomPack		; $5ffe
	call loadAreaData		; $6001
	call loadAreaGraphics		; $6004
	call func_131f		; $6007
	ld a,$01		; $600a
	ld (wScrollMode),a		; $600c
	call loadCommonGraphics		; $600f
	call clearOam		; $6012
	ld a,$10		; $6015
	ldh (<hOamTail),a	; $6017
	ret			; $6019

	call getEntryFromObjectTable1		; $601a
	call parseGivenObjectData		; $601d
	call refreshObjectGfx		; $6020
	jp $6026		; $6023
	ld a,($cfde)		; $6026
	cp $00			; $6029
	jr z,_label_03_108	; $602b
	cp $01			; $602d
	jr z,_label_03_107	; $602f
	cp $02			; $6031
	jr z,_label_03_106	; $6033
	cp $04			; $6035
	jr z,_label_03_107	; $6037
	ret			; $6039
	ld hl,wLoadedObjectGfx		; $603a
_label_03_105:
	ldi (hl),a		; $603d
	inc a			; $603e
	ld (hl),$01		; $603f
	inc l			; $6041
	dec b			; $6042
	jr nz,_label_03_105	; $6043
	ret			; $6045
_label_03_106:
	ld a,$24		; $6046
	ld b,$02		; $6048
	jr _label_03_109		; $604a
_label_03_107:
	ld a,$26		; $604c
	ld b,$02		; $604e
	jr _label_03_109		; $6050
_label_03_108:
	ld a,$04		; $6052
	ld b,$02		; $6054
_label_03_109:
	call $603a		; $6056
	jp reloadObjectGfx		; $6059
	call _cutscene_decCBB3IfTextNotActive		; $605c
	ret nz			; $605f
	call incCbc2		; $6060
	ld hl,wTmpcbb3		; $6063
	ld (hl),e		; $6066
	ret			; $6067

;;
; @addr{6068}
_cutscene_decCBB3IfTextNotActive:
	ld a,(wTextIsActive)		; $6068
	or a			; $606b
	ret nz			; $606c
	jp decCbb3		; $606d

;;
; @addr{6070}
_cutscene_decCBB3IfNotFadingOut:
	ld a,(wPaletteThread_mode)		; $6070
	or a			; $6073
	ret nz			; $6074
	jp decCbb3		; $6075


	call _cutscene_decCBB3IfNotFadingOut		; $6078
	ret nz			; $607b
	call incCbc1		; $607c
	ld a,e			; $607f
	ld (wTmpcbb3),a		; $6080
	jp showText		; $6083

;;
; @addr{6086}
cutscene_clearTmpCBB3:
	ld hl,wTmpcbb3		; $6086
	ld b,$10		; $6089
	jp clearMemory		; $608b

;;
; @addr{608e}
_cutscene_clearCFC0ToCFDF:
	ld b,$20		; $608e
	ld hl,$cfc0		; $6090
	jp clearMemory		; $6093


	ld a,$04		; $6096
	call setScreenShakeCounter		; $6098
	ld a,(wFrameCounter)		; $609b
	and $0f			; $609e
	ld a,SND_RUMBLE2		; $60a0
	jp z,playSound		; $60a2
	ret			; $60a5


;;
; @addr{60a6}
_cutscene_resetOamWithSomething1:
	ld hl,$4f73		; $60a6
	ld e,$16		; $60a9
	ld bc,$3038		; $60ab
	jr ++			; $60ae

;;
; @addr{60b0}
_cutscene_resetOamWithSomething2:
	ld hl,$4e37		; $60b0
	ld e,$16		; $60b3
	ld bc,$3038		; $60b5
++
	xor a			; $60b8
	ldh (<hOamTail),a	; $60b9
	jp addSpritesFromBankToOam_withOffset		; $60bb

;;
; @param	hl	List of tiles (see below for example of format)
; @addr{60be}
_cutscene_replaceListOfTiles:
	ld b,(hl)		; $60be
	inc hl			; $60bf
@loop:
	ld c,(hl)		; $60c0
	inc hl			; $60c1
	ldi a,(hl)		; $60c2
	push bc			; $60c3
	push hl			; $60c4
	call setTile		; $60c5
	pop hl			; $60c8
	pop bc			; $60c9
	dec b			; $60ca
	jr nz,@loop	; $60cb
	ret			; $60cd

_blackTowerEscapeCutscene_doorBlockReplacement:
	.db $04     ; # of entries
	.db $44 $83 ; Position, New Tile Value
	.db $45 $83
	.db $54 $83
	.db $55 $83

_blackTowerEscapeCutscene_doorOpenReplacement:
	.db $04 
	.db $44 $df
	.db $45 $ed
	.db $54 $80
	.db $55 $80

;;
; @addr{60e0}
func_60e0:
	ld hl,wLinkHealth		; $60e0
	ld (hl),$04		; $60e3
	ld l,<wInventoryB		; $60e5
	ldi a,(hl)		; $60e7
	ld b,(hl)		; $60e8
	ld hl,$cde3		; $60e9
	ldi (hl),a		; $60ec
	ld (hl),b		; $60ed
	jp disableActiveRing		; $60ee

;;
; @addr{60f1}
func_60f1:
	ld hl,wLinkMaxHealth		; $60f1
	ldd a,(hl)		; $60f4
	ld (hl),a		; $60f5
	ld hl,$cde3		; $60f6
	ldi a,(hl)		; $60f9
	ld b,(hl)		; $60fa
	ld hl,wInventoryB		; $60fb
	ldi (hl),a		; $60fe
	ld (hl),b		; $60ff
	jp enableActiveRing		; $6100

;;
; @addr{6103}
func_03_6103:
	ld a,($cfd1)		; $6103
	cp $07			; $6106
	jp z,$61f2		; $6108
	ld a,(wCutsceneState)		; $610b
	rst_jumpTable			; $610e
.dw $6127
.dw $613c
.dw $6175
.dw $6188
.dw $6196
.dw $619f
.dw $6188
.dw $61a8
.dw $61b1
.dw $6188
.dw $61bb
.dw $61dc

	ld hl,wTmpcbb3		; $6127
	ld a,(w1Link.yh)		; $612a
	ldi (hl),a		; $612d
	ld a,(w1Link.xh)		; $612e
	ldi (hl),a		; $6131
	ld a,(w1Link.direction)		; $6132
	ld (hl),a		; $6135
	call fadeoutToWhite		; $6136
	jp $6270		; $6139
	ld a,(wPaletteThread_mode)		; $613c
	or a			; $613f
	ret nz			; $6140
	ld a,$81		; $6141
_label_03_112:
	ld (wActiveRoom),a		; $6143
	call $6270		; $6146
	xor a			; $6149
	ld ($cfd2),a		; $614a
	call disableLcd		; $614d
	call clearScreenVariablesAndWramBank1		; $6150
	call initializeVramMaps		; $6153
	call loadScreenMusicAndSetRoomPack		; $6156
	call loadAreaData		; $6159
	call loadAreaGraphics		; $615c
	call func_131f		; $615f
	ld a,$01		; $6162
	ld (wScrollMode),a		; $6164
	call refreshObjectGfx		; $6167
	call loadCommonGraphics		; $616a
	ld a,$02		; $616d
	call loadGfxRegisterStateIndex		; $616f
	jp fadeinFromWhite		; $6172
	ld a,(wPaletteThread_mode)		; $6175
	or a			; $6178
	ret nz			; $6179
	ld b,$0c		; $617a
_label_03_113:
	call getFreeInteractionSlot		; $617c
	ret nz			; $617f
	ld (hl),$49		; $6180
	ld l,$43		; $6182
	ld (hl),b		; $6184
	jp $6270		; $6185
	ld hl,$cfd2		; $6188
	ld a,(hl)		; $618b
	or a			; $618c
	ret z			; $618d
	ld (hl),$00		; $618e
	call $6270		; $6190
	jp fadeoutToWhite		; $6193
	ld a,(wPaletteThread_mode)		; $6196
	or a			; $6199
	ret nz			; $619a
	ld a,$80		; $619b
	jr _label_03_112		; $619d
	ld a,(wPaletteThread_mode)		; $619f
	or a			; $61a2
	ret nz			; $61a3
	ld b,$0d		; $61a4
	jr _label_03_113		; $61a6
	ld a,(wPaletteThread_mode)		; $61a8
	or a			; $61ab
	ret nz			; $61ac
	ld a,$91		; $61ad
	jr _label_03_112		; $61af
	ld a,(wPaletteThread_mode)		; $61b1
	or a			; $61b4
	ret nz			; $61b5
	ld b,$0e		; $61b6
	jp $617c		; $61b8
	ld a,(wPaletteThread_mode)		; $61bb
	or a			; $61be
	ret nz			; $61bf
	ld a,$82		; $61c0
	call $6143		; $61c2
	ld hl,$d000		; $61c5
	ld (hl),$03		; $61c8
	ld l,$0b		; $61ca
	ld a,(wTmpcbb3)		; $61cc
	ldi (hl),a		; $61cf
	inc l			; $61d0
	ld a,(wTmpcbb4)		; $61d1
	ld (hl),a		; $61d4
	ld a,(wTmpcbb5)		; $61d5
	ld l,$08		; $61d8
	ld (hl),a		; $61da
	ret			; $61db
	ld a,(wPaletteThread_mode)		; $61dc
	or a			; $61df
	ret nz			; $61e0
	xor a			; $61e1
	ld (wDisabledObjects),a		; $61e2
	ld (wMenuDisabled),a		; $61e5
	inc a			; $61e8
	ld (wCutsceneIndex),a		; $61e9
	ld bc,$1104		; $61ec
	jp showText		; $61ef
	ld a,(wCutsceneState)		; $61f2
	rst_jumpTable			; $61f5
.dw $6202
.dw $6210
.dw $6225
.dw $6231
.dw $624c
.dw $625a

	ld a,(wPaletteThread_mode)		; $6202
	or a			; $6205
	ret nz			; $6206
	ld bc,$110a		; $6207
	call showText		; $620a
	jp $6270		; $620d
_label_03_114:
	ld a,(wTextIsActive)		; $6210
	or a			; $6213
	ret nz			; $6214
	call $6270		; $6215
	ld a,$0c		; $6218
	ld (wTmpcbb6),a		; $621a
	ld a,SND_MYSTERY_SEED		; $621d
	call playSound		; $621f
	jp fastFadeinFromWhite		; $6222
	ld a,(wPaletteThread_mode)		; $6225
	or a			; $6228
	ret nz			; $6229
	ld hl,wTmpcbb6		; $622a
	dec (hl)		; $622d
	ret nz			; $622e
	jr _label_03_114		; $622f
	ld a,(wPaletteThread_mode)		; $6231
	or a			; $6234
	ret nz			; $6235
	ld hl,wTmpcbb6		; $6236
	dec (hl)		; $6239
	ret nz			; $623a
	call $6270		; $623b
	xor a			; $623e
	ld ($cfd0),a		; $623f
	ld a,SND_MYSTERY_SEED		; $6242
	call playSound		; $6244
	ld a,$08		; $6247
	jp fadeinFromWhiteWithDelay		; $6249
	ld a,(wPaletteThread_mode)		; $624c
	or a			; $624f
	ret nz			; $6250
	call $6270		; $6251
	ld bc,$110b		; $6254
	jp showText		; $6257
	ld a,GLOBALFLAG_WON_FAIRY_HIDING_GAME		; $625a
	call setGlobalFlag		; $625c
	ld a,GLOBALFLAG_FOREST_UNSCRAMBLED		; $625f
	call setGlobalFlag		; $6261
	xor a			; $6264
	ld (wMenuDisabled),a		; $6265
	ld (wDisabledObjects),a		; $6268
	inc a			; $626b
	ld (wCutsceneIndex),a		; $626c
	ret			; $626f
	ld hl,wCutsceneState		; $6270
	inc (hl)		; $6273
	ret			; $6274

;;
; @addr{6275}
func_03_6275:
	ld a,(wCutsceneState)		; $6275
	rst_jumpTable			; $6278
.dw $6283
.dw $6288
.dw $62cd
.dw $62d9
.dw $62ec

	call fadeoutToWhite		; $6283
	jr _label_03_115		; $6286
	ld a,(wPaletteThread_mode)		; $6288
	or a			; $628b
	ret nz			; $628c
	call clearAllParentItems		; $628d
	call dropLinkHeldItem		; $6290
	ld a,$01		; $6293
	ld (wActiveGroup),a		; $6295
	ld a,$46		; $6298
	ld (wActiveRoom),a		; $629a
	call disableLcd		; $629d
	call clearOam		; $62a0
	call clearScreenVariablesAndWramBank1		; $62a3
	call initializeVramMaps		; $62a6
	call loadScreenMusicAndSetRoomPack		; $62a9
	call loadAreaData		; $62ac
	call loadAreaGraphics		; $62af
	call func_131f		; $62b2
	ld a,$01		; $62b5
	ld (wScrollMode),a		; $62b7
	call loadCommonGraphics		; $62ba
	call initializeRoom		; $62bd
	call fadeinFromWhite		; $62c0
	ld a,$02		; $62c3
	call loadGfxRegisterStateIndex		; $62c5
_label_03_115:
	ld hl,wCutsceneState		; $62c8
	inc (hl)		; $62cb
	ret			; $62cc
	ld a,$03		; $62cd
	ld ($d000),a		; $62cf
	ld a,$0f		; $62d2
	ld (wLinkForceState),a		; $62d4
	jr _label_03_115		; $62d7
	ld a,(wPaletteThread_mode)		; $62d9
	or a			; $62dc
	ret nz			; $62dd
	ld a,($d005)		; $62de
	cp $02			; $62e1
	ret nz			; $62e3
	ld bc,$590a		; $62e4
	call showText		; $62e7
	jr _label_03_115		; $62ea
	ld a,(wTextIsActive)		; $62ec
	or a			; $62ef
	ret nz			; $62f0
	ld (wMenuDisabled),a		; $62f1
	ld (wDisabledObjects),a		; $62f4
	ld (wDisableScreenTransitions),a		; $62f7
	ld (wCutsceneIndex),a		; $62fa
	ld a,(wActiveMusic2)		; $62fd
	ld (wActiveMusic),a		; $6300
	jp playSound		; $6303

;;
; @addr{6306}
func_03_6306:
	ld a,c			; $6306
	rst_jumpTable			; $6307
.dw $6318
.dw $6564
.dw $65b3
.dw $677c
.dw $6a8e
.dw $6b77
.dw $6d0b
.dw $69b5

	call $6328		; $6318
	ld hl,wCutsceneState		; $631b
	ld a,(hl)		; $631e
	cp $02			; $631f
	ret z			; $6321
	cp $03			; $6322
	ret z			; $6324
	jp updateAllObjects		; $6325
	ld de,wCutsceneState		; $6328
	ld a,(de)		; $632b
	rst_jumpTable			; $632c
.dw $6351
.dw $6359
.dw $63aa
.dw $63ed
.dw $640e
.dw $6420
.dw $6432
.dw $6443
.dw $6454
.dw $6474
.dw $6488
.dw $6496
.dw $64a5
.dw $64b5
.dw $64df
.dw $64fe
.dw $6538
.dw $654f

	ld a,$01		; $6351
	ld (de),a		; $6353
	ld a,SND_CLOSEMENU		; $6354
	jp playSound		; $6356
	ld a,$ff		; $6359
	ld (wAreaAnimation),a		; $635b
	ld a,$08		; $635e
	ld ($cfd0),a		; $6360
	ld hl,wMenuDisabled		; $6363
	ld (hl),$01		; $6366
	ld hl,$d01a		; $6368
	res 7,(hl)		; $636b
	call saveGraphicsOnEnterMenu		; $636d
	ld a,$0c		; $6370
	call loadGfxHeader		; $6372
	ld a,PALH_95		; $6375
	call loadPaletteHeader		; $6377
	ld a,$04		; $637a
	call loadGfxRegisterStateIndex		; $637c
	ld hl,wTmpcbb3		; $637f
	ld (hl),$58		; $6382
	inc hl			; $6384
	ld (hl),$02		; $6385
	ld hl,wTmpcbb6		; $6387
	ld (hl),$28		; $638a
	call fastFadeinFromWhite		; $638c
	call $6f8c		; $638f
	ld hl,wTmpcbb5		; $6392
	ld (hl),$02		; $6395
	call clearOam		; $6397
	ld b,$00		; $639a
	ld a,(wGfxRegs1.SCX)		; $639c
	cpl			; $639f
	inc a			; $63a0
	ld c,a			; $63a1
	ld hl,bank3f.oamData_7249		; $63a2
	ld e,:bank3f.oamData_7249		; $63a5
	jp addSpritesFromBankToOam_withOffset		; $63a7
	ld a,(wPaletteThread_mode)		; $63aa
	or a			; $63ad
	jp nz,$6397		; $63ae
	ret nz			; $63b1
	call $63db		; $63b2
	call $6397		; $63b5
	ld hl,wTmpcbb3		; $63b8
	call decHlRef16WithCap		; $63bb
	jr z,_label_03_117	; $63be
	ldi a,(hl)		; $63c0
	ld h,(hl)		; $63c1
	ld l,a			; $63c2
	ld bc,$00f0		; $63c3
	call compareHlToBc		; $63c6
	ret nc			; $63c9
	ld a,(wKeysJustPressed)		; $63ca
	and $01			; $63cd
	ret z			; $63cf
_label_03_117:
	ld a,SND_CLOSEMENU		; $63d0
	call playSound		; $63d2
	call $6f8c		; $63d5
	jp fastFadeoutToWhite		; $63d8
	ld a,(wFrameCounter)		; $63db
	and $07			; $63de
	ret nz			; $63e0
	ld hl,wTmpcbb6		; $63e1
	ld a,(hl)		; $63e4
	or a			; $63e5
	ret z			; $63e6
	dec (hl)		; $63e7
	ld hl,wGfxRegs1.SCX		; $63e8
	inc (hl)		; $63eb
	ret			; $63ec
	ld a,(wPaletteThread_mode)		; $63ed
	or a			; $63f0
	jp nz,$6397		; $63f1
	ret nz			; $63f4
	xor a			; $63f5
	ld (wAreaAnimation),a		; $63f6
	ld hl,$d01a		; $63f9
	set 7,(hl)		; $63fc
	ld a,$09		; $63fe
	ld ($cfd0),a		; $6400
	call $6f8c		; $6403
	ld hl,wTmpcbb3		; $6406
	ld (hl),$aa		; $6409
	jp reloadGraphicsOnExitMenu		; $640b
	ld a,($cfd0)		; $640e
	cp $0f			; $6411
	ret nz			; $6413
	call $6f8c		; $6414
	ld hl,$de90		; $6417
.ifdef ROM_AGES
	ld bc,paletteData44a8		; $641a
.else
	ld bc,$44a8
.endif
	jp func_13c6		; $641d
	ld a,(wPaletteThread_mode)		; $6420
	or a			; $6423
	ret nz			; $6424
	ld a,PALH_99		; $6425
	call loadPaletteHeader		; $6427
	ld a,$10		; $642a
	ld ($cfd0),a		; $642c
	jp $6f8c		; $642f
	ld a,($cfd0)		; $6432
	cp $14			; $6435
	ret nz			; $6437
	call $6f8c		; $6438
	ld hl,wTmpcbb3		; $643b
	ld (hl),$3c		; $643e
	jp fadeoutToWhite		; $6440
	call _cutscene_decCBB3IfNotFadingOut		; $6443
	ret nz			; $6446
	call $6f8c		; $6447
	ld a,$15		; $644a
	ld ($cfd0),a		; $644c
	ld a,$03		; $644f
	jp fadeinFromWhiteWithDelay		; $6451
	ld a,($cfd0)		; $6454
	cp $18			; $6457
	ret nz			; $6459
	call $6f8c		; $645a
	xor a			; $645d
	ld ($cfd2),a		; $645e
	call getFreePartSlot		; $6461
	ret nz			; $6464
	ld (hl),$27		; $6465
	inc l			; $6467
	inc (hl)		; $6468
	inc l			; $6469
	inc (hl)		; $646a
	ld l,$cb		; $646b
	ld (hl),$24		; $646d
	ld l,$cd		; $646f
	ld (hl),$28		; $6471
	ret			; $6473
	ld a,($cfd2)		; $6474
	or a			; $6477
	ret z			; $6478
	call $6f8c		; $6479
	call getThisRoomFlags		; $647c
	set 6,(hl)		; $647f
	ld c,$22		; $6481
	ld a,$d7		; $6483
	jp setTile		; $6485
	ld a,($cfd0)		; $6488
	cp $1d			; $648b
	ret nz			; $648d
	ld hl,wTmpcbb3		; $648e
	ld (hl),$78		; $6491
	jp $6f8c		; $6493
	call decCbb3		; $6496
	ret nz			; $6499
	ld (hl),$5a		; $649a
	call $6f8c		; $649c
	ld bc,$5607		; $649f
	jp showText		; $64a2
	call _cutscene_decCBB3IfTextNotActive		; $64a5
	ret nz			; $64a8
	call $6f8c		; $64a9
	xor a			; $64ac
	ld hl,$cfde		; $64ad
	ldi (hl),a		; $64b0
	ld (hl),a		; $64b1
	jp fadeoutToWhite		; $64b2
	ld a,(wPaletteThread_mode)		; $64b5
	or a			; $64b8
	ret nz			; $64b9
	call $6f8c		; $64ba
	call _cutscene_loadObjectSetAndFadein		; $64bd
	ld a,$02		; $64c0
	jp loadGfxRegisterStateIndex		; $64c2

;;
; @addr{64c5}
_cutscene_loadObjectSetAndFadein:
	ld hl,wTmpcfc0.genericCutscene.cfde		; $64c5
	ld a,(hl)		; $64c8
	push af			; $64c9
	call _cutscene_getObjectSetIndexAndSomething		; $64ca
	pop af			; $64cd
	ld b,a			; $64ce
	call getEntryFromObjectTable2		; $64cf
	call parseGivenObjectData		; $64d2
	call refreshObjectGfx		; $64d5
	xor a			; $64d8
	ld (wTmpcfc0.genericCutscene.cfd1),a		; $64d9
	jp fadeinFromWhite		; $64dc

	ld a,(wPaletteThread_mode)		; $64df
	or a			; $64e2
	ret nz			; $64e3
	ld hl,$cfdf		; $64e4
	ld a,(hl)		; $64e7
	cp $ff			; $64e8
	ret nz			; $64ea
	xor a			; $64eb
	ldd (hl),a		; $64ec
	inc (hl)		; $64ed
	ld a,(hl)		; $64ee
	cp $03			; $64ef
	ld a,$0d		; $64f1
	jr nz,_label_03_118	; $64f3
	ld a,$0f		; $64f5
_label_03_118:
	ld hl,wCutsceneState		; $64f7
	ld (hl),a		; $64fa
	jp fadeoutToWhite		; $64fb
	ld a,(wPaletteThread_mode)		; $64fe
	or a			; $6501
	ret nz			; $6502
	call $6f8c		; $6503
	call _cutscene_loadObjectSetAndFadein		; $6506
	ld a,PALH_99		; $6509
	call loadPaletteHeader		; $650b
	ld a,$08		; $650e
	call setLinkIDOverride		; $6510
	ld l,$00		; $6513
	ld (hl),$03		; $6515
	ld l,$02		; $6517
	ld (hl),$04		; $6519
	ld a,SNDCTRL_MEDIUM_FADEOUT		; $651b
	call playSound		; $651d
	ld a,MUS_SADNESS		; $6520
	call playSound		; $6522
	xor a			; $6525
	ld (wPaletteThread_parameter),a		; $6526
	ld a,$24		; $6529
	ld b,$02		; $652b
	call $603a		; $652d
	call reloadObjectGfx		; $6530
	ld a,$02		; $6533
	jp loadGfxRegisterStateIndex		; $6535
	ld a,(wPaletteThread_mode)		; $6538
	or a			; $653b
	ret nz			; $653c
	ld a,($cfd0)		; $653d
	cp $1e			; $6540
	ret nz			; $6542
	call $6f8c		; $6543
	ld hl,$de90		; $6546
.ifdef ROM_AGES
	ld bc,paletteData4a30		; $6549
.else
	ld bc,$4a30
.endif
	jp func_13c6		; $654c
	ld a,(wPaletteThread_mode)		; $654f
	or a			; $6552
	ret nz			; $6553
	ld a,PALH_10		; $6554
	call loadPaletteHeader		; $6556
	ld a,$1f		; $6559
	ld ($cfd0),a		; $655b
	ld a,$01		; $655e
	ld (wCutsceneIndex),a		; $6560
	ret			; $6563
	call $656a		; $6564
	jp updateAllObjects		; $6567
	ld a,($cfc0)		; $656a
	or a			; $656d
	jr z,_label_03_119	; $656e
	ld a,SND_FADEOUT		; $6570
	call playSound		; $6572
	xor a			; $6575
	ld (wLinkStateParameter),a		; $6576
	ld (wMenuDisabled),a		; $6579
	ld a,GLOBALFLAG_0c		; $657c
	call setGlobalFlag		; $657e
	call getThisRoomFlags		; $6581
	set 0,(hl)		; $6584
	xor a			; $6586
	ld (wUseSimulatedInput),a		; $6587
	inc a			; $658a
	ld (wDisabledObjects),a		; $658b
	ld hl,$65aa		; $658e
	jp setWarpDestVariables		; $6591
_label_03_119:
	ld a,(wFrameCounter)		; $6594
	and $07			; $6597
	ret nz			; $6599
	ld hl,$cbb7		; $659a
	ld a,(hl)		; $659d
	inc a			; $659e
	and $03			; $659f
	ld (hl),a		; $65a1
	ld hl,$65af		; $65a2
	rst_addAToHl			; $65a5
	ld a,(hl)		; $65a6
	jp loadPaletteHeader		; $65a7
	add b			; $65aa
	jr c,_label_03_120	; $65ab
	ld b,l			; $65ad
	add e			; $65ae
	sbc d			; $65af
	call nz,$c58f		; $65b0
	call $65b9		; $65b3
	jp updateAllObjects		; $65b6
_label_03_120:
	ld a,($cbb8)		; $65b9
	rst_jumpTable			; $65bc
.dw $65c3
.dw $6664
.dw $66f0

	ld de,wCutsceneState		; $65c3
	ld a,(de)		; $65c6
	rst_jumpTable			; $65c7
.dw $65d0
.dw $662b
.dw $6651
.dw $6733

	ld a,(wPaletteThread_mode)		; $65d0
	or a			; $65d3
	ret nz			; $65d4
	call disableLcd		; $65d5
	call clearScreenVariablesAndWramBank1		; $65d8
	call clearOam		; $65db
	ld a,($cbb8)		; $65de
	ld hl,$6625		; $65e1
	rst_addDoubleIndex			; $65e4
	ldi a,(hl)		; $65e5
	push hl			; $65e6
	call loadGfxHeader		; $65e7
	pop hl			; $65ea
	ld a,(hl)		; $65eb
	call loadGfxHeader		; $65ec
	ld a,PALH_c3		; $65ef
	call loadPaletteHeader		; $65f1
	ld b,$78		; $65f4
	ld a,($cbb8)		; $65f6
	cp $02			; $65f9
	jr z,_label_03_121	; $65fb
	ld b,$3c		; $65fd
_label_03_121:
	ld hl,wTmpcbb3		; $65ff
	ld (hl),b		; $6602
	or a			; $6603
	ld a,MUS_DISASTER		; $6604
	call z,playSound		; $6606
	call $6f8c		; $6609
	xor a			; $660c
	ld (wTmpcbb9),a		; $660d
	call fadeinFromWhite		; $6610
	ld a,$70		; $6613
	ld (wScreenOffsetY),a		; $6615
	ld hl,$cc10		; $6618
	ld b,$08		; $661b
	call clearMemory		; $661d
	ld a,$09		; $6620
	jp loadGfxRegisterStateIndex		; $6622
	add d			; $6625
	cpl			; $6626
	add c			; $6627
	ld l,$80		; $6628
	ld l,$cd		; $662a
	rst $30			; $662c
	ld l,(hl)		; $662d
	call $6f44		; $662e
	ld a,(wPaletteThread_mode)		; $6631
	or a			; $6634
	ret nz			; $6635
	call decCbb3		; $6636
	ret nz			; $6639
	call $6f8c		; $663a
	ld bc,$1005		; $663d
	ld a,($cbb8)		; $6640
	or a			; $6643
	jr z,_label_03_122	; $6644
	ld bc,$1317		; $6646
_label_03_122:
	ld a,TEXTBOXFLAG_NOCOLORS		; $6649
	ld (wTextboxFlags),a		; $664b
	jp showText		; $664e
	call $6ef7		; $6651
	call $6f44		; $6654
	ld a,(wTextIsActive)		; $6657
	or a			; $665a
	ret nz			; $665b
	ld hl,wTmpcbb3		; $665c
	ld (hl),$3c		; $665f
	jp $6f8c		; $6661
	ld de,wCutsceneState		; $6664
	ld a,(de)		; $6667
	rst_jumpTable			; $6668
.dw $65d0
.dw $662b
.dw $6651
.dw $66fd
.dw $6725
.dw $6679
.dw $6689
.dw $66dc

	call $6ef7		; $6679
	call $6f44		; $667c
	call decCbb3		; $667f
	ret nz			; $6682
	call $6f8c		; $6683
	jp fadeoutToWhite		; $6686
	call $6f44		; $6689
	ld a,(wPaletteThread_mode)		; $668c
	or a			; $668f
	ret nz			; $6690
	call $6f8c		; $6691
	call clearDynamicInteractions		; $6694
	ld bc,$00ba		; $6697
	call disableLcdAndLoadRoom		; $669a
	call resetCamera		; $669d
	call getFreeInteractionSlot		; $66a0
	jr nz,_label_03_123	; $66a3
	ld (hl),$8a		; $66a5
	inc l			; $66a7
	ld (hl),$00		; $66a8
	inc l			; $66aa
	ld (hl),$04		; $66ab
_label_03_123:
	ld hl,$d000		; $66ad
	ld (hl),$03		; $66b0
	ld l,$0b		; $66b2
	ld (hl),$65		; $66b4
	ld l,$0d		; $66b6
	ld (hl),$58		; $66b8
	ld l,$08		; $66ba
	ld (hl),$02		; $66bc
	ld a,(wLoadingRoomPack)		; $66be
	ld (wRoomPack),a		; $66c1
	ld a,SNDCTRL_STOPMUSIC		; $66c4
	call playSound		; $66c6
	ld a,PALH_0f		; $66c9
	call loadPaletteHeader		; $66cb
	call fadeinFromWhiteToRoom		; $66ce
	call refreshObjectGfx		; $66d1
	call showStatusBar		; $66d4
	ld a,$02		; $66d7
	jp loadGfxRegisterStateIndex		; $66d9
	call updateStatusBar		; $66dc
	ld a,(wPaletteThread_mode)		; $66df
	or a			; $66e2
	ret nz			; $66e3
	ld a,$01		; $66e4
	ld (wMenuDisabled),a		; $66e6
	ld (wDisabledObjects),a		; $66e9
	ld (wCutsceneIndex),a		; $66ec
	ret			; $66ef
	ld de,wCutsceneState		; $66f0
	ld a,(de)		; $66f3
	rst_jumpTable			; $66f4
.dw $65d0
.dw $66fd
.dw $6725
.dw $6733

	call $6ef7		; $66fd
	call $6f44		; $6700
	ld a,(wPaletteThread_mode)		; $6703
	or a			; $6706
	ret nz			; $6707
	call decCbb3		; $6708
	ret nz			; $670b
	ld a,$04		; $670c
	ld (wTmpcbbb),a		; $670e
	ld (wTmpcbb6),a		; $6711
	ld a,($cbb8)		; $6714
	ld hl,$6722		; $6717
	rst_addAToHl			; $671a
	ld a,(hl)		; $671b
	ld (wTmpcbb3),a		; $671c
	jp $6f8c		; $671f
	ld bc,$b161		; $6722
	call $6ef7		; $6725
	call $6f26		; $6728
	jp nz,$6f44		; $672b
	ld (hl),$78		; $672e
	call $6f8c		; $6730
	call $6ef7		; $6733
	call $6f44		; $6736
	call decCbb3		; $6739
	ret nz			; $673c
	ld a,($cbb8)		; $673d
	rst_jumpTable			; $6740
.dw $6747
.dw $6747
.dw $6768

	ld hl,$6772		; $6747
	call setWarpDestVariables		; $674a
	ld a,($cfd3)		; $674d
	ld (wWarpDestPos),a		; $6750
	ld a,($cfd4)		; $6753
	ld (wcc50),a		; $6756
	ld a,$ff		; $6759
	ld (wActiveMusic),a		; $675b
	ld a,$01		; $675e
	ld ($cfc0),a		; $6760
	ld a,SNDCTRL_MEDIUM_FADEOUT		; $6763
	jp playSound		; $6765
	xor a			; $6768
	ld (wLinkStateParameter),a		; $6769
	ld hl,$6777		; $676c
	jp setWarpDestVariables		; $676f
	add c			; $6772
	add (hl)		; $6773
	inc c			; $6774
	ld (hl),l		; $6775
	inc bc			; $6776
	add h			; $6777
	or $0f			; $6778
	ld b,a			; $677a
	inc bc			; $677b
	call $6785		; $677c
	call updateStatusBar		; $677f
	jp updateAllObjects		; $6782
	ld de,wCutsceneState		; $6785
	ld a,(de)		; $6788
	rst_jumpTable			; $6789
.dw $67a4
.dw $67fc
.dw $680d
.dw $681a
.dw $684e
.dw $6855
.dw $686f
.dw $687f
.dw $68a3
.dw $68e8
.dw $6903
.dw $691a
.dw $696b

	ld a,(wPaletteThread_mode)		; $67a4
	or a			; $67a7
	ret nz			; $67a8
	call $6f8c		; $67a9
	call clearDynamicInteractions		; $67ac
	ld bc,$0038		; $67af
	call disableLcdAndLoadRoom		; $67b2
	call resetCamera		; $67b5
	ld b,$04		; $67b8
	call getEntryFromObjectTable2		; $67ba
	call parseGivenObjectData		; $67bd
	call refreshObjectGfx		; $67c0
	ld a,$04		; $67c3
	ld b,$02		; $67c5
	call $603a		; $67c7
	call reloadObjectGfx		; $67ca
	ld a,SNDCTRL_FAST_FADEOUT		; $67cd
	call playSound		; $67cf
	ld a,$02		; $67d2
	call loadGfxRegisterStateIndex		; $67d4
	ld hl,wTmpcbb3		; $67d7
	ld (hl),$3c		; $67da
	ld b,$20		; $67dc
	ld hl,$cfc0		; $67de
	call clearMemory		; $67e1
	ld a,$01		; $67e4
	ld (wDisabledObjects),a		; $67e6
	ld (wMenuDisabled),a		; $67e9
	ld a,SNDCTRL_STOPMUSIC		; $67ec
	call playSound		; $67ee
	ld a,MUS_MAKU_TREE		; $67f1
	call playSound		; $67f3
	call incMakuTreeState		; $67f6
	jp fadeinFromWhiteToRoom		; $67f9
	call $6f96		; $67fc
	ret nz			; $67ff
	ld (hl),$3c		; $6800
	call $6f8c		; $6802
	ld a,$68		; $6805
	ld bc,$5050		; $6807
	jp createEnergySwirlGoingIn		; $680a
	call decCbb3		; $680d
	ret nz			; $6810
	xor a			; $6811
	ld (hl),a		; $6812
	dec a			; $6813
	ld (wTmpcbba),a		; $6814
	jp $6f8c		; $6817
	ld hl,wTmpcbb3		; $681a
	ld b,$02		; $681d
	call flashScreen		; $681f
	ret z			; $6822
	call $6f8c		; $6823
	ld hl,wTmpcbb3		; $6826
	ld (hl),$3c		; $6829
	ld a,$01		; $682b
	ld ($cfd0),a		; $682d
	call $6838		; $6830
	ld a,$03		; $6833
	jp fadeinFromWhiteWithDelay		; $6835
	ld a,$00		; $6838
	call setLinkIDOverride		; $683a
	ld l,$00		; $683d
	ld (hl),$03		; $683f
	ld l,$0b		; $6841
	ld (hl),$68		; $6843
	ld l,$0d		; $6845
	ld (hl),$50		; $6847
	ld l,$08		; $6849
	ld (hl),$00		; $684b
	ret			; $684d
	call $6f96		; $684e
	ret nz			; $6851
	jp $6f8c		; $6852
	ld a,($cfd0)		; $6855
	cp $02			; $6858
	ret nz			; $685a
	call $6f8c		; $685b
	ld a,SNDCTRL_FAST_FADEOUT		; $685e
	call playSound		; $6860
	xor a			; $6863
	ld hl,$cfde		; $6864
	ld (hl),$05		; $6867
	inc l			; $6869
	ld (hl),$00		; $686a
	jp fadeoutToWhite		; $686c
	ld a,(wPaletteThread_mode)		; $686f
	or a			; $6872
	ret nz			; $6873
	call $6f8c		; $6874
	call _cutscene_loadObjectSetAndFadein		; $6877
	ld a,$02		; $687a
	jp loadGfxRegisterStateIndex		; $687c
	ld a,(wPaletteThread_mode)		; $687f
	or a			; $6882
	ret nz			; $6883
	ld hl,$cfdf		; $6884
	ld a,(hl)		; $6887
	cp $ff			; $6888
	ret nz			; $688a
	xor a			; $688b
	ldd (hl),a		; $688c
	inc (hl)		; $688d
	ld a,(hl)		; $688e
	cp $07			; $688f
	ld a,$06		; $6891
	jr nz,_label_03_124	; $6893
	ld a,$08		; $6895
	ld hl,$cfd0		; $6897
	ld (hl),$03		; $689a
_label_03_124:
	ld hl,wCutsceneState		; $689c
	ld (hl),a		; $689f
	jp fadeoutToWhite		; $68a0
	ld a,(wPaletteThread_mode)		; $68a3
	or a			; $68a6
	ret nz			; $68a7
	call $6f8c		; $68a8
	call _cutscene_loadObjectSetAndFadein		; $68ab
	call $6838		; $68ae
	ld a,$01		; $68b1
	ld (wDisabledObjects),a		; $68b3
	ld (wMenuDisabled),a		; $68b6
	ld a,$04		; $68b9
	ld b,$02		; $68bb
	call $603a		; $68bd
	ld a,$26		; $68c0
	ld b,$02		; $68c2
	call $603d		; $68c4
	ld a,$24		; $68c7
	ld b,$01		; $68c9
	call $603d		; $68cb
	ld b,l			; $68ce
	call checkIsLinkedGame		; $68cf
	jr z,_label_03_125	; $68d2
	call getFreeInteractionSlot		; $68d4
	jr nz,_label_03_125	; $68d7
	ld (hl),$93		; $68d9
_label_03_125:
	call reloadObjectGfx		; $68db
	ld a,MUS_MAKU_TREE		; $68de
	call playSound		; $68e0
	ld a,$02		; $68e3
	jp loadGfxRegisterStateIndex		; $68e5
	ld a,($cfd0)		; $68e8
	cp $07			; $68eb
	ret nz			; $68ed
	call $6f8c		; $68ee
	ld a,SNDCTRL_STOPSFX		; $68f1
	call playSound		; $68f3
	ld bc,$2800		; $68f6
	call checkIsLinkedGame		; $68f9
	jr z,_label_03_126	; $68fc
	ld c,$02		; $68fe
_label_03_126:
	jp showText		; $6900
	ld a,(wTextIsActive)		; $6903
	or a			; $6906
	ret nz			; $6907
	call $6f8c		; $6908
	ld hl,wTmpcbb3		; $690b
	ld (hl),$b4		; $690e
	ld a,$01		; $6910
	ld (w1Link.direction),a		; $6912
	ld ($cbb7),a		; $6915
	jr _label_03_131		; $6918
	call decCbb3		; $691a
	jr nz,_label_03_130	; $691d
	call checkIsLinkedGame		; $691f
	jr z,_label_03_127	; $6922
	ld a,$08		; $6924
	ld ($cfd0),a		; $6926
	jr _label_03_129		; $6929
_label_03_127:
	call getFreePartSlot		; $692b
	jr nz,_label_03_128	; $692e
	ld (hl),$27		; $6930
	inc l			; $6932
	inc (hl)		; $6933
	inc l			; $6934
	inc (hl)		; $6935
	ld l,$cb		; $6936
	ld (hl),$40		; $6938
	ld l,$cd		; $693a
	ld (hl),$88		; $693c
_label_03_128:
	call getFreeInteractionSlot		; $693e
	jr nz,_label_03_129	; $6941
	ld (hl),$8d		; $6943
_label_03_129:
	jp $6f8c		; $6945
_label_03_130:
	call $6f91		; $6948
	ret nz			; $694b
	ld l,$b7		; $694c
	ld a,(hl)		; $694e
	xor $02			; $694f
	ld (hl),a		; $6951
	call $6962		; $6952
_label_03_131:
	call getRandomNumber_noPreserveVars		; $6955
	and $03			; $6958
	add a			; $695a
	add a			; $695b
	add $10			; $695c
	ld (wTmpcbb6),a		; $695e
	ret			; $6961
_label_03_132:
	ld (w1Link.direction),a		; $6962
	ld a,$08		; $6965
	ld (wLinkForceState),a		; $6967
	ret			; $696a
	ld a,($cfd0)		; $696b
	cp $63			; $696e
	jr z,_label_03_133	; $6970
	call checkIsLinkedGame		; $6972
	ret z			; $6975
	ld a,($cfd0)		; $6976
	cp $09			; $6979
	ret nc			; $697b
	ld a,(wFrameCounter)		; $697c
	and $07			; $697f
	ret nz			; $6981
	callab func_0a_7877		; $6982
	ld de,w1Link.yh		; $698a
	call objectGetRelativeAngle		; $698d
	call convertAngleToDirection		; $6990
	ld h,d			; $6993
	ld l,$08		; $6994
	cp (hl)			; $6996
	ret z			; $6997
	jr _label_03_132		; $6998
_label_03_133:
	xor a			; $699a
	ld (wMenuDisabled),a		; $699b
	ld (wDisabledObjects),a		; $699e
	ld a,(wLoadingRoomPack)		; $69a1
	ld (wRoomPack),a		; $69a4
	ld a,GLOBALFLAG_SAVED_NAYRU		; $69a7
	call setGlobalFlag		; $69a9
	call refreshObjectGfx		; $69ac
	ld a,$01		; $69af
	ld (wCutsceneIndex),a		; $69b1
	ret			; $69b4
	call $69be		; $69b5
	call updateStatusBar		; $69b8
	jp updateAllObjects		; $69bb
	ld de,wCutsceneState		; $69be
	ld a,(de)		; $69c1
	rst_jumpTable			; $69c2
.dw $69cf
.dw $69d7
.dw $69e6
.dw $6a3c
.dw $6a52
.dw $6a8d

	ld a,$3c		; $69cf
	ld (wTmpcbb3),a		; $69d1
	jp $6f8c		; $69d4
	call decCbb3		; $69d7
	ret nz			; $69da
	call $6f8c		; $69db
	ld a,SNDCTRL_FAST_FADEOUT		; $69de
	call playSound		; $69e0
	jp fastFadeoutToBlack		; $69e3
	ld a,(wPaletteThread_mode)		; $69e6
	or a			; $69e9
	ret nz			; $69ea
	call hideStatusBar		; $69eb
	ld a,($ff00+R_SVBK)	; $69ee
	push af			; $69f0
	ld a,$02		; $69f1
	ld ($ff00+R_SVBK),a	; $69f3
	ld hl,$de90		; $69f5
	ld b,$30		; $69f8
	call clearMemory		; $69fa
	pop af			; $69fd
	ld ($ff00+R_SVBK),a	; $69fe
	callab bank1.checkDisableUnderwaterWaves		; $6a00
	xor a			; $6a08
	ld (wScrollMode),a		; $6a09
	ld (wAreaFlags),a		; $6a0c
	ld (wGfxRegs1.LYC),a		; $6a0f
	ld (wGfxRegs2.SCY),a		; $6a12
	ld ($d01a),a		; $6a15
	ld a,$10		; $6a18
	ld (wScreenOffsetY),a		; $6a1a
	call checkIsLinkedGame		; $6a1d
	jr z,_label_03_134	; $6a20
	call $6f8c		; $6a22
	ld hl,wTmpcbb3		; $6a25
	ld (hl),$1e		; $6a28
	ret			; $6a2a
_label_03_134:
	call clearWramBank1		; $6a2b
	call clearOam		; $6a2e
	ld a,$05		; $6a31
	ld (wCutsceneState),a		; $6a33
	ld bc,$8d01		; $6a36
	jp _createInteraction		; $6a39
	call decCbb3		; $6a3c
	ret nz			; $6a3f
	ld a,SND_LIGHTNING		; $6a40
	call playSound		; $6a42
	xor a			; $6a45
	ld hl,wTmpcbb3		; $6a46
	ld (hl),a		; $6a49
	dec a			; $6a4a
	ld hl,wTmpcbba		; $6a4b
	ld (hl),a		; $6a4e
	jp $6f8c		; $6a4f
	ld hl,wTmpcbb3		; $6a52
	ld b,$02		; $6a55
	call flashScreen		; $6a57
	ret z			; $6a5a
	call $6f8c		; $6a5b
	ld a,$10		; $6a5e
	ld ($cfde),a		; $6a60
	ld hl,_cutscene_loadObjectSetAndFadein		; $6a63
	ld e,$03		; $6a66
	call interBankCall		; $6a68
	call showStatusBar		; $6a6b
	ld a,MUS_DISASTER		; $6a6e
	call playSound		; $6a70
	ld a,PALH_ac		; $6a73
	call loadPaletteHeader		; $6a75
	ld a,$02		; $6a78
	call loadGfxRegisterStateIndex		; $6a7a
	xor a			; $6a7d
	ld (wScrollMode),a		; $6a7e
	ld a,$28		; $6a81
	ld (wGfxRegs2.SCX),a		; $6a83
	ldh (<hCameraX),a	; $6a86
	ld a,$f0		; $6a88
	ld (wGfxRegs2.SCY),a		; $6a8a
	ret			; $6a8d
	call $6a97		; $6a8e
	call updateStatusBar		; $6a91
	jp updateAllObjects		; $6a94
	ld de,wCutsceneState		; $6a97
	ld a,(de)		; $6a9a
	rst_jumpTable			; $6a9b
.dw $6aaa
.dw $6ac3
.dw $6ad3
.dw $6af2
.dw $6b16
.dw $6b22
.dw $6b66

	call $6f8c		; $6aaa
	ld b,$20		; $6aad
	ld hl,$cfc0		; $6aaf
	call clearMemory		; $6ab2
	ld a,$0d		; $6ab5
	ld hl,$cfde		; $6ab7
	ldi (hl),a		; $6aba
	ld (hl),$00		; $6abb
	call showStatusBar		; $6abd
	jp fadeoutToWhite		; $6ac0
	ld a,(wPaletteThread_mode)		; $6ac3
	or a			; $6ac6
	ret nz			; $6ac7
	call $6f8c		; $6ac8
	call _cutscene_loadObjectSetAndFadein		; $6acb
	ld a,$02		; $6ace
	jp loadGfxRegisterStateIndex		; $6ad0
	ld a,(wPaletteThread_mode)		; $6ad3
	or a			; $6ad6
	ret nz			; $6ad7
	ld hl,$cfdf		; $6ad8
	ld a,(hl)		; $6adb
	cp $ff			; $6adc
	ret nz			; $6ade
	xor a			; $6adf
	ldd (hl),a		; $6ae0
	inc (hl)		; $6ae1
	ld a,(hl)		; $6ae2
	cp $0f			; $6ae3
	ld a,$01		; $6ae5
	jr nz,_label_03_135	; $6ae7
	ld a,$03		; $6ae9
_label_03_135:
	ld hl,wCutsceneState		; $6aeb
	ld (hl),a		; $6aee
	jp fadeoutToWhite		; $6aef
	ld a,(wPaletteThread_mode)		; $6af2
	or a			; $6af5
	ret nz			; $6af6
	call $6ac3		; $6af7
	ld a,$08		; $6afa
	ld b,$28		; $6afc
	ld hl,hCameraY		; $6afe
	ldi (hl),a		; $6b01
	inc l			; $6b02
	ld (hl),b		; $6b03
	ld a,$f8		; $6b04
	ld hl,wGfxRegs2.SCY		; $6b06
	ldi (hl),a		; $6b09
	ld (hl),b		; $6b0a
	xor a			; $6b0b
	ld (wScrollMode),a		; $6b0c
	ld (wScreenOffsetY),a		; $6b0f
	ld (wScreenOffsetX),a		; $6b12
	ret			; $6b15
	ld a,($cfc0)		; $6b16
	cp $03			; $6b19
	ret nz			; $6b1b
	call $6f8c		; $6b1c
	jp fadeoutToWhite		; $6b1f
	ld a,(wPaletteThread_mode)		; $6b22
	or a			; $6b25
	ret nz			; $6b26
	call $6f8c		; $6b27
	call clearDynamicInteractions		; $6b2a
	ld bc,$0290		; $6b2d
	call disableLcdAndLoadRoom		; $6b30
	call resetCamera		; $6b33
	ld hl,objectData.objectData7798		; $6b36
	call parseGivenObjectData		; $6b39
	ld hl,$d000		; $6b3c
	ld (hl),$03		; $6b3f
	ld l,$0b		; $6b41
	ld (hl),$58		; $6b43
	ld l,$0d		; $6b45
	ld (hl),$50		; $6b47
	ld l,$08		; $6b49
	ld (hl),$02		; $6b4b
	call refreshObjectGfx		; $6b4d
	ld a,SNDCTRL_STOPMUSIC		; $6b50
	call playSound		; $6b52
	call showStatusBar		; $6b55
	ld a,$02		; $6b58
	call loadGfxRegisterStateIndex		; $6b5a
	ld a,(wLoadingRoomPack)		; $6b5d
	ld (wRoomPack),a		; $6b60
	jp fadeinFromWhiteToRoom		; $6b63
	ld a,(wPaletteThread_mode)		; $6b66
	or a			; $6b69
	ret nz			; $6b6a
	ld a,$01		; $6b6b
	ld (wMenuDisabled),a		; $6b6d
	ld (wDisabledObjects),a		; $6b70
	ld (wCutsceneIndex),a		; $6b73
	ret			; $6b76
	call $6b80		; $6b77
	call updateStatusBar		; $6b7a
	jp updateAllObjects		; $6b7d
	ld de,wCutsceneState		; $6b80
	ld a,(de)		; $6b83
	rst_jumpTable			; $6b84
.dw $6b99
.dw $6bc0
.dw $6bd5
.dw $6c09
.dw $6c1c
.dw $6c40
.dw $6c54
.dw $6c9d
.dw $6cbe
.dw $6cfc

	call $6f8c		; $6b99
	ld b,$20		; $6b9c
	ld hl,$cfc0		; $6b9e
	call clearMemory		; $6ba1
	ld a,SNDCTRL_STOPMUSIC		; $6ba4
	call playSound		; $6ba6
	ld hl,wTmpcbb3		; $6ba9
	ld (hl),$3c		; $6bac
	ld bc,$2810		; $6bae
	call checkIsLinkedGame		; $6bb1
	jr z,_label_03_136	; $6bb4
	ld c,$15		; $6bb6
_label_03_136:
	ld a,$02		; $6bb8
	ld ($cfc0),a		; $6bba
	jp showText		; $6bbd
	call _cutscene_decCBB3IfTextNotActive		; $6bc0
	ret nz			; $6bc3
	ld a,SNDCTRL_STOPMUSIC		; $6bc4
	call playSound		; $6bc6
	ld hl,wTmpcbb3		; $6bc9
	xor a			; $6bcc
	ld (hl),a		; $6bcd
	dec a			; $6bce
	ld (wTmpcbba),a		; $6bcf
	jp $6f8c		; $6bd2
	ld hl,wTmpcbb3		; $6bd5
	ld b,$01		; $6bd8
	call flashScreen		; $6bda
	ret z			; $6bdd
	call checkIsLinkedGame		; $6bde
	jr nz,_label_03_137	; $6be1
	call $6fb0		; $6be3
	jr _label_03_138		; $6be6
_label_03_137:
	call $6f9e		; $6be8
_label_03_138:
	ld a,$01		; $6beb
	ld (wDisabledObjects),a		; $6bed
	call clearDynamicInteractions		; $6bf0
	ld hl,objectData.objectData77b2		; $6bf3
	call checkIsLinkedGame		; $6bf6
	jr nz,_label_03_139	; $6bf9
	ld hl,wCutsceneState		; $6bfb
	ld (hl),$06		; $6bfe
	ld hl,objectData.objectData77a5		; $6c00
_label_03_139:
	call parseGivenObjectData		; $6c03
	jp $6f8c		; $6c06
	ld a,($cfc0)		; $6c09
	cp $03			; $6c0c
	ret nz			; $6c0e
	ld a,SNDCTRL_STOPMUSIC		; $6c0f
	call playSound		; $6c11
	ld a,SND_LIGHTNING		; $6c14
	call playSound		; $6c16
	jp $6bc9		; $6c19
	ld hl,wTmpcbb3		; $6c1c
	ld b,$04		; $6c1f
	call flashScreen		; $6c21
	ret z			; $6c24
	ld a,$12		; $6c25
	ld ($cfde),a		; $6c27
	call _cutscene_loadObjectSetAndFadein		; $6c2a
	call showStatusBar		; $6c2d
	call $6f8c		; $6c30
	ld a,MUS_ZELDA_SAVED		; $6c33
	call playSound		; $6c35
	ld a,$02		; $6c38
	call loadGfxRegisterStateIndex		; $6c3a
	jp resetCamera		; $6c3d
	ld hl,$cfdf		; $6c40
	ld a,(hl)		; $6c43
	cp $ff			; $6c44
	ret nz			; $6c46
	ld a,SND_LIGHTNING		; $6c47
	call playSound		; $6c49
	ld a,SNDCTRL_STOPMUSIC		; $6c4c
	call playSound		; $6c4e
	jp $6bc9		; $6c51
	ld hl,wTmpcbb3		; $6c54
	ld b,$01		; $6c57
	call flashScreen		; $6c59
	ret z			; $6c5c
	ld hl,$cfde		; $6c5d
	inc (hl)		; $6c60
	call _cutscene_loadObjectSetAndFadein		; $6c61
	ld hl,$d000		; $6c64
	ld (hl),$03		; $6c67
	ld l,$0b		; $6c69
	ld (hl),$68		; $6c6b
	ld l,$0d		; $6c6d
	ld (hl),$50		; $6c6f
	ld l,$08		; $6c71
	ld (hl),$00		; $6c73
	ld a,$2c		; $6c75
	ld b,$03		; $6c77
	call $603a		; $6c79
	call $6f8c		; $6c7c
	xor a			; $6c7f
	ld (wPaletteThread_mode),a		; $6c80
	ldh (<hVBlankFunctionQueueTail),a	; $6c83
	inc a			; $6c85
	ld (wDisabledObjects),a		; $6c86
	ld (wMenuDisabled),a		; $6c89
	ld a,(wLoadingRoomPack)		; $6c8c
	ld (wRoomPack),a		; $6c8f
	call reloadObjectGfx		; $6c92
	ld a,$02		; $6c95
	call loadGfxRegisterStateIndex		; $6c97
	jp $6fb0		; $6c9a
	ld a,($cfd0)		; $6c9d
	cp $09			; $6ca0
	ret nz			; $6ca2
	ld a,SNDCTRL_FAST_FADEOUT		; $6ca3
	call playSound		; $6ca5
	call fadeoutToBlack		; $6ca8
	ld a,$ff		; $6cab
	ld (wFadeSprPaletteSources),a		; $6cad
	ld (wDirtyFadeSprPalettes),a		; $6cb0
	ld a,$03		; $6cb3
	ld (wFadeBgPaletteSources),a		; $6cb5
	ld (wDirtyFadeBgPalettes),a		; $6cb8
	jp $6f8c		; $6cbb
	ld a,(wPaletteThread_mode)		; $6cbe
	or a			; $6cc1
	ret nz			; $6cc2
	call $6f8c		; $6cc3
	call showStatusBar		; $6cc6
	ld a,GLOBALFLAG_GOT_MAKU_SEED		; $6cc9
	call setGlobalFlag		; $6ccb
	ld a,$01		; $6cce
	ld (wScrollMode),a		; $6cd0
	xor a			; $6cd3
	ld (wScreenShakeCounterY),a		; $6cd4
	ld (wScreenShakeCounterX),a		; $6cd7
	ld a,$0f		; $6cda
	ld (wGfxRegs1.LYC),a		; $6cdc
	ld a,$f0		; $6cdf
	ld (wGfxRegs2.SCY),a		; $6ce1
	call fadeinFromBlack		; $6ce4
	ld bc,$8706		; $6ce7
	call _createInteraction		; $6cea
	ld bc,$4050		; $6ced
	call interactionHSetPosition		; $6cf0
	ld a,(wActiveMusic2)		; $6cf3
	ld (wActiveMusic),a		; $6cf6
	jp playSound		; $6cf9
	ld a,($cfc0)		; $6cfc
	cp $04			; $6cff
	ret nz			; $6d01
	call refreshObjectGfx		; $6d02
	ld a,$01		; $6d05
	ld (wCutsceneIndex),a		; $6d07
	ret			; $6d0a
	call $6d11		; $6d0b
	jp updateAllObjects		; $6d0e
	ld de,wCutsceneState		; $6d11
	ld a,(de)		; $6d14
	rst_jumpTable			; $6d15
.dw $6d30
.dw $6d76
.dw $6d84
.dw $6d88
.dw $6da7
.dw $6dc8
.dw $6dd8
.dw $6def
.dw $6e04
.dw $6e1a
.dw $6e26
.dw $6e75
.dw $6e86

	ld a,(wPaletteThread_mode)		; $6d30
	or a			; $6d33
	ret nz			; $6d34
	call checkIsLinkedGame		; $6d35
	jr nz,_label_03_140	; $6d38
	ld a,$0a		; $6d3a
	ld (de),a		; $6d3c
	jp $6e26		; $6d3d
_label_03_140:
	ld a,$01		; $6d40
	ld (de),a		; $6d42
	ld bc,$05f1		; $6d43
	call disableLcdAndLoadRoom		; $6d46
	call resetCamera		; $6d49
	ld a,PALH_ac		; $6d4c
	call loadPaletteHeader		; $6d4e
	ld hl,objectData.objectData77b6		; $6d51
	call parseGivenObjectData		; $6d54
	ld a,MUS_FINAL_DUNGEON		; $6d57
	call playSound		; $6d59
	ld hl,wTmpcbb3		; $6d5c
	ld (hl),$3c		; $6d5f
	ld a,$13		; $6d61
	call loadGfxRegisterStateIndex		; $6d63
	ld a,(wGfxRegs2.SCX)		; $6d66
	ldh (<hCameraX),a	; $6d69
	xor a			; $6d6b
	ldh (<hCameraY),a	; $6d6c
	ld a,$00		; $6d6e
	ld (wScrollMode),a		; $6d70
	jp _clearFadingPalettes		; $6d73
	ld e,$96		; $6d76
_label_03_141:
	call decCbb3		; $6d78
	ret nz			; $6d7b
	call $6f8c		; $6d7c
	ld hl,wTmpcbb3		; $6d7f
	ld (hl),e		; $6d82
	ret			; $6d83
	ld e,$3c		; $6d84
	jr _label_03_141		; $6d86
	call decCbb3		; $6d88
	ret nz			; $6d8b
	call $6f8c		; $6d8c
	call fastFadeinFromBlack		; $6d8f
	ld a,$40		; $6d92
	ld (wDirtyFadeSprPalettes),a		; $6d94
	ld (wFadeSprPaletteSources),a		; $6d97
	ld a,$03		; $6d9a
	ld (wDirtyFadeBgPalettes),a		; $6d9c
	ld (wFadeBgPaletteSources),a		; $6d9f
	ld a,SND_LIGHTTORCH		; $6da2
	jp playSound		; $6da4
	ld a,(wPaletteThread_mode)		; $6da7
	or a			; $6daa
	ret nz			; $6dab
	call $6f8c		; $6dac
	ld a,$0e		; $6daf
	ld (wTmpcbb3),a		; $6db1
	call fadeinFromBlack		; $6db4
	ld a,$bf		; $6db7
	ld (wDirtyFadeSprPalettes),a		; $6db9
	ld (wFadeSprPaletteSources),a		; $6dbc
	ld a,$fc		; $6dbf
	ld (wDirtyFadeBgPalettes),a		; $6dc1
	ld (wFadeBgPaletteSources),a		; $6dc4
	ret			; $6dc7
	call decCbb3		; $6dc8
	ret nz			; $6dcb
	xor a			; $6dcc
	ld (wPaletteThread_mode),a		; $6dcd
	ld a,$78		; $6dd0
	ld (wTmpcbb3),a		; $6dd2
	jp $6f8c		; $6dd5
	call decCbb3		; $6dd8
	ret nz			; $6ddb
	call $6f8c		; $6ddc
	ld a,TEXTBOXFLAG_DONTCHECKPOSITION		; $6ddf
	ld (wTextboxFlags),a		; $6de1
	ld a,$03		; $6de4
	ld (wTextboxPosition),a		; $6de6
	ld bc,$281a		; $6de9
	jp showText		; $6dec
	call retIfTextIsActive		; $6def
	call $6f8c		; $6df2
	ld (wTmpcbb3),a		; $6df5
	dec a			; $6df8
	ld (wTmpcbba),a		; $6df9
	call restartSound		; $6dfc
	ld a,SND_BIG_EXPLOSION_2		; $6dff
	jp playSound		; $6e01
	ld hl,wTmpcbb3		; $6e04
	ld b,$03		; $6e07
	call flashScreen		; $6e09
	ret z			; $6e0c
	call $6f8c		; $6e0d
	ld a,$3c		; $6e10
	ld (wTmpcbb3),a		; $6e12
	ld a,$02		; $6e15
	jp fadeoutToWhiteWithDelay		; $6e17
	ld a,(wPaletteThread_mode)		; $6e1a
	or a			; $6e1d
	ret nz			; $6e1e
	call decCbb3		; $6e1f
	ret nz			; $6e22
	jp $6f8c		; $6e23
	call disableLcd		; $6e26
	ld a,($ff00+R_SVBK)	; $6e29
	push af			; $6e2b
	ld a,$02		; $6e2c
	ld ($ff00+R_SVBK),a	; $6e2e
	ld hl,$de80		; $6e30
	ld b,$40		; $6e33
	call clearMemory		; $6e35
	pop af			; $6e38
	ld ($ff00+R_SVBK),a	; $6e39
	call clearScreenVariablesAndWramBank1		; $6e3b
	call clearOam		; $6e3e
	ld a,PALH_0f		; $6e41
	call loadPaletteHeader		; $6e43
	ld a,$02		; $6e46
	call $6e9a		; $6e48
	call $6eb7		; $6e4b
	ld a,MUS_ESSENCE_ROOM		; $6e4e
	call playSound		; $6e50
	ld a,$08		; $6e53
	call setLinkID		; $6e55
	ld l,$00		; $6e58
	ld (hl),$01		; $6e5a
	ld l,$02		; $6e5c
	ld (hl),$0b		; $6e5e
	ld a,$00		; $6e60
	ld (wScrollMode),a		; $6e62
	call $6f8c		; $6e65
	call clearPaletteFadeVariablesAndRefreshPalettes		; $6e68
	xor a			; $6e6b
	ldh (<hCameraY),a	; $6e6c
	ldh (<hCameraX),a	; $6e6e
	ld a,$15		; $6e70
	jp loadGfxRegisterStateIndex		; $6e72
	ld a,(wTmpcbb9)		; $6e75
	cp $07			; $6e78
	ret nz			; $6e7a
	call clearLinkObject		; $6e7b
	ld hl,wTmpcbb3		; $6e7e
	ld (hl),$3c		; $6e81
	jp $6f8c		; $6e83
	call decCbb3		; $6e86
	ret nz			; $6e89
	ld hl,wGameState		; $6e8a
	xor a			; $6e8d
	ldi (hl),a		; $6e8e
	ld (hl),a		; $6e8f
	ld a,SNDCTRL_STOPMUSIC		; $6e90
	call playSound		; $6e92
	ld a,GLOBALFLAG_3d		; $6e95
	jp setGlobalFlag		; $6e97
	ldh (<hFF8B),a	; $6e9a
	ld a,$01		; $6e9c
	ld ($ff00+R_VBK),a	; $6e9e
	ld hl,$9800		; $6ea0
	ld bc,$0400		; $6ea3
	ldh a,(<hFF8B)	; $6ea6
	call fillMemoryBc		; $6ea8
	xor a			; $6eab
	ld ($ff00+R_VBK),a	; $6eac
	ld hl,$9800		; $6eae
	ld bc,$0400		; $6eb1
	jp clearMemoryBc		; $6eb4
	ld a,($ff00+R_SVBK)	; $6eb7
	push af			; $6eb9
	ld a,$03		; $6eba
	ld ($ff00+R_SVBK),a	; $6ebc
	ld hl,$d800		; $6ebe
	ld bc,$0240		; $6ec1
	call clearMemoryBc		; $6ec4
	ld hl,$dc00		; $6ec7
	ld bc,$0240		; $6eca
	ld a,$02		; $6ecd
	call fillMemoryBc		; $6ecf
	pop af			; $6ed2
	ld ($ff00+R_SVBK),a	; $6ed3
	ret			; $6ed5
	ldh (<hFF8B),a	; $6ed6
	ld a,($ff00+R_SVBK)	; $6ed8
	push af			; $6eda
	ld a,$04		; $6edb
	ld ($ff00+R_SVBK),a	; $6edd
	ld hl,$d000		; $6edf
	ld bc,$0240		; $6ee2
	call clearMemoryBc		; $6ee5
	ld hl,$d400		; $6ee8
	ld bc,$0240		; $6eeb
	ldh a,(<hFF8B)	; $6eee
	call fillMemoryBc		; $6ef0
	pop af			; $6ef3
	ld ($ff00+R_SVBK),a	; $6ef4
	ret			; $6ef6
	ld a,(wTmpcbb9)		; $6ef7
	or a			; $6efa
	jr z,_label_03_142	; $6efb
	ld hl,$cbb7		; $6efd
	ld b,$01		; $6f00
	call flashScreen		; $6f02
	ret z			; $6f05
	xor a			; $6f06
	ld (wTmpcbb9),a		; $6f07
	ret			; $6f0a
_label_03_142:
	ld a,(wFrameCounter)		; $6f0b
	and $1f			; $6f0e
	ret nz			; $6f10
	call getRandomNumber		; $6f11
	and $07			; $6f14
	ret nz			; $6f16
	ld ($cbb7),a		; $6f17
	dec a			; $6f1a
	ld (wTmpcbb9),a		; $6f1b
	ld (wTmpcbba),a		; $6f1e
	ld a,SND_LIGHTNING		; $6f21
	jp playSound		; $6f23
	ld hl,wTmpcbb6		; $6f26
	dec (hl)		; $6f29
	ret nz			; $6f2a
	call decCbb3		; $6f2b
	ret z			; $6f2e
	ld a,(wTmpcbbb)		; $6f2f
	ld (wTmpcbb6),a		; $6f32
	ld hl,wGfxRegs1.SCY		; $6f35
	dec (hl)		; $6f38
	ld a,(hl)		; $6f39
	or a			; $6f3a
	ret nz			; $6f3b
	ld a,UNCMP_GFXH_34		; $6f3c
	call loadUncompressedGfxHeader		; $6f3e
	or $01			; $6f41
	ret			; $6f43
	ld a,(wGfxRegs1.SCY)		; $6f44
	cpl			; $6f47
	inc a			; $6f48
	ld b,a			; $6f49
	xor a			; $6f4a
	ldh (<hOamTail),a	; $6f4b
	ld c,a			; $6f4d
	ld a,($cbb8)		; $6f4e
	rst_jumpTable			; $6f51
.dw $6f58
.dw $6f60
.dw $6f70

	ld hl,bank3f.oamData_714c		; $6f58
	ld e,:bank3f.oamData_714c		; $6f5b
	jp addSpritesFromBankToOam_withOffset		; $6f5d
	ld hl,bank3f.oamData_718d		; $6f60
	ld e,:bank3f.oamData_718d		; $6f63
	call addSpritesFromBankToOam_withOffset		; $6f65
	ld hl,bank3f.oamData_71ce		; $6f68
	ld e,:bank3f.oamData_71ce		; $6f6b
	jp addSpritesFromBankToOam_withOffset		; $6f6d
	ld hl,bank3f.oamData_71f7		; $6f70
	ld e,:bank3f.oamData_71f7		; $6f73
	call addSpritesFromBankToOam_withOffset		; $6f75
	ld hl,bank3f.oamData_718d		; $6f78
	ld e,:bank3f.oamData_718d		; $6f7b
	ld a,(wGfxRegs1.SCY)		; $6f7d
	cp $71			; $6f80
	jr c,_label_03_143	; $6f82
	ld hl,bank3f.oamData_7220		; $6f84
	ld e,:bank3f.oamData_7220		; $6f87
_label_03_143:
	jp addSpritesFromBankToOam_withOffset		; $6f89
	ld hl,wCutsceneState		; $6f8c
	inc (hl)		; $6f8f
	ret			; $6f90
	ld hl,wTmpcbb6		; $6f91
	dec (hl)		; $6f94
	ret			; $6f95
	ld a,(wPaletteThread_mode)		; $6f96
	or a			; $6f99
	ret nz			; $6f9a
	jp decCbb3		; $6f9b
	ld a,($ff00+R_SVBK)	; $6f9e
	push af			; $6fa0
	ld a,$02		; $6fa1
	ld ($ff00+R_SVBK),a	; $6fa3
	ld hl,$de90		; $6fa5
	ld b,$30		; $6fa8
	call clearMemory		; $6faa
	pop af			; $6fad
	ld ($ff00+R_SVBK),a	; $6fae
	ld a,($ff00+R_SVBK)	; $6fb0
	push af			; $6fb2
	ld a,$02		; $6fb3
	ld ($ff00+R_SVBK),a	; $6fb5
	ld hl,$df80		; $6fb7
	ld b,$80		; $6fba
	call clearMemory		; $6fbc
	pop af			; $6fbf
	ld ($ff00+R_SVBK),a	; $6fc0
	call hideStatusBar		; $6fc2
	ld a,$fc		; $6fc5
	ldh (<hBgPaletteSources),a	; $6fc7
	ldh (<hDirtyBgPalettes),a	; $6fc9
	xor a			; $6fcb
	ld (wScrollMode),a		; $6fcc
	ld (wGfxRegs1.LYC),a		; $6fcf
	ld (wGfxRegs2.SCY),a		; $6fd2
	ret			; $6fd5

;;
; @param	a	Index?
; @param[out]	b	Index for "objectTable2"?
; @param[out]	c
; @addr{6fd6}
_cutscene_getObjectSetIndexAndSomething:
	ld hl,$6fe3		; $6fd6
	rst_addDoubleIndex			; $6fd9
	ld b,(hl)		; $6fda
	inc hl			; $6fdb
	ld c,(hl)		; $6fdc
	call disableLcdAndLoadRoom		; $6fdd
	jp resetCamera		; $6fe0

@data:
	.db $00 $98
	.db $00 $5a
	.db $02 $0e
	.db $00 $39
	.db $00 $39
	.db $02 $0e
	.db $00 $5a
	.db $00 $38
	.db $01 $49
	.db $01 $84
	.db $01 $65
	.db $05 $f1
	.db $01 $65
	.db $01 $49
	.db $01 $84
	.db $04 $f6
	.db $05 $f1
	.db $00 $38
	.db $01 $49
	.db $00 $38

	ld hl,$cbb4		; $700b
	dec (hl)		; $700e
	ret nz			; $700f
	ld (hl),30		; $7010
	ret			; $7012
_label_03_146:
	ld hl,wCutsceneState		; $7013
	inc (hl)		; $7016
	ret			; $7017
_label_03_147:
	ld hl,wTmpcbb3		; $7018
	inc (hl)		; $701b
	ret			; $701c

;;
; @addr{701d}
func_701d:
	ld a,(wDungeonIndex)		; $701d
	cp $08			; $7020
	jp z,$70b4		; $7022
	ld a,(wCutsceneState)		; $7025
	rst_jumpTable			; $7028
.dw $702d
.dw $7053

_label_03_148:
	ld a,$72		; $702d
	call loadGfxHeader		; $702f
	ld b,$10		; $7032
	ld hl,wTmpcbb3		; $7034
	call clearMemory		; $7037
	call reloadTileMap		; $703a
	call resetCamera		; $703d
	call getThisRoomFlags		; $7040
	set 6,(hl)		; $7043
	call loadTilesetAndRoomLayout		; $7045
	ld a,$3c		; $7048
	ld (wTmpcbb4),a		; $704a
	xor a			; $704d
	ld (wScrollMode),a		; $704e
	jr _label_03_146		; $7051
	ld a,(wTmpcbb3)		; $7053
	rst_jumpTable			; $7056
.dw $705b
.dw $7063

	call $700b		; $705b
	ret nz			; $705e
	ld (hl),$3c		; $705f
	jr _label_03_147		; $7061
	ld a,$3c		; $7063
	call setScreenShakeCounter		; $7065
	call $700b		; $7068
	ret nz			; $706b
	ld (hl),$19		; $706c
	callab generateW3VramTilesAndAttributes		; $706e
	ld bc,$260c		; $7076
	call $70f7		; $7079
	xor a			; $707c
	ld ($ff00+R_SVBK),a	; $707d
	call reloadTileMap		; $707f
	ld a,SND_DOORCLOSE		; $7082
	call playSound		; $7084
	ld hl,$cbb7		; $7087
	inc (hl)		; $708a
	ld a,(hl)		; $708b
	cp $0f			; $708c
	ret c			; $708e
	call $7098		; $708f
	ld a,$0f		; $7092
	ld ($ce5d),a		; $7094
	ret			; $7097
_label_03_149:
	ld a,SND_SOLVEPUZZLE		; $7098
	call playSound		; $709a
	ld a,$01		; $709d
	ld (wCutsceneIndex),a		; $709f
	ld a,$01		; $70a2
	ld (wScrollMode),a		; $70a4
	xor a			; $70a7
	ld (wDisabledObjects),a		; $70a8
	ld (wMenuDisabled),a		; $70ab
	call loadTilesetAndRoomLayout		; $70ae
	jp loadRoomCollisions		; $70b1
	ld a,(wCutsceneState)		; $70b4
	rst_jumpTable			; $70b7
.dw $70bc
.dw $70c1

	ld a,$73		; $70bc
	jp $702f		; $70be
	ld a,(wTmpcbb3)		; $70c1
	rst_jumpTable			; $70c4
.dw $705b
.dw $70c9

	ld a,$3c		; $70c9
	call setScreenShakeCounter		; $70cb
	call $700b		; $70ce
	ret nz			; $70d1
	ld (hl),$19		; $70d2
	callab generateW3VramTilesAndAttributes		; $70d4
	ld bc,$4d04		; $70dc
	call $70f7		; $70df
	xor a			; $70e2
	ld ($ff00+R_SVBK),a	; $70e3
	call reloadTileMap		; $70e5
	ld a,SND_DOORCLOSE		; $70e8
	call playSound		; $70ea
	ld hl,$cbb7		; $70ed
	inc (hl)		; $70f0
	ld a,(hl)		; $70f1
	cp $0b			; $70f2
	ret c			; $70f4
	jr _label_03_149		; $70f5
	ld a,c			; $70f7
	ldh (<hFF8C),a	; $70f8
	ld a,b			; $70fa
	ldh (<hFF8D),a	; $70fb
	swap a			; $70fd
	and $0f			; $70ff
	add a			; $7101
	ld e,a			; $7102
	ld a,($cbb7)		; $7103
	add e			; $7106
	ldh (<hFF93),a	; $7107
	ld c,$20		; $7109
	call multiplyAByC		; $710b
	ld bc,$d800		; $710e
	ldh a,(<hFF8D)	; $7111
	and $0f			; $7113
	call addDoubleIndexToBc		; $7115
	add hl,bc		; $7118
	ldh a,(<hFF8C)	; $7119
	ld b,a			; $711b
	ld a,$20		; $711c
	sub b			; $711e
	ldh (<hFF8E),a	; $711f
	push hl			; $7121
	ld c,d			; $7122
	ld de,$d000		; $7123
	call $712f		; $7126
	pop hl			; $7129
	set 2,h			; $712a
	ld de,$d400		; $712c
	ldh a,(<hFF93)	; $712f
	ld c,a			; $7131
	ld a,$14		; $7132
	sub c			; $7134
	ret c			; $7135
	ld c,a			; $7136
_label_03_150:
	ldh a,(<hFF8C)	; $7137
	ld b,a			; $7139
_label_03_151:
	ld a,$02		; $713a
	ld ($ff00+R_SVBK),a	; $713c
	ld a,(de)		; $713e
	inc de			; $713f
	ldh (<hFF8B),a	; $7140
	ld a,$03		; $7142
	ld ($ff00+R_SVBK),a	; $7144
	ldh a,(<hFF8B)	; $7146
	ldi (hl),a		; $7148
	dec b			; $7149
	jr nz,_label_03_151	; $714a
	ldh a,(<hFF8E)	; $714c
	call addAToDe		; $714e
	ldh a,(<hFF8E)	; $7151
	rst_addAToHl			; $7153
	dec c			; $7154
	jr nz,_label_03_150	; $7155
	ret			; $7157
	ld hl,wTmpcbb4		; $7158
	dec (hl)		; $715b
	ret nz			; $715c
	ret			; $715d
	ld hl,wCutsceneState		; $715e
	inc (hl)		; $7161
	ret			; $7162
	ld hl,wTmpcbb3		; $7163
	inc (hl)		; $7166
	ret			; $7167

;;
; @addr{7168}
func_7168:
	ld a,(wCutsceneState)		; $7168
	rst_jumpTable			; $716b
.dw $7176
.dw $7196
.dw $71b1
.dw $720b
.dw $7212

	ld b,$10		; $7176
	ld hl,wTmpcbb3		; $7178
	call clearMemory		; $717b
	call getThisRoomFlags		; $717e
	set 7,(hl)		; $7181
	ld l,$73		; $7183
	set 7,(hl)		; $7185
	xor a			; $7187
	ld (wScrollMode),a		; $7188
	ld a,$3c		; $718b
	ld (wTmpcbb4),a		; $718d
	call $715e		; $7190
	jp reloadTileMap		; $7193
	call $7158		; $7196
	ret nz			; $7199
	call $715e		; $719a
	call getFreeInteractionSlot		; $719d
	jr nz,_label_03_152	; $71a0
	ld (hl),$97		; $71a2
	ld l,$4b		; $71a4
	ld (hl),$2c		; $71a6
	ld l,$4d		; $71a8
	ld (hl),$58		; $71aa
_label_03_152:
	ld a,$50		; $71ac
	jp loadGfxHeader		; $71ae
	ld a,$0f		; $71b1
	call setScreenShakeCounter		; $71b3
	call $722f		; $71b6
	ld a,(wTmpcbb3)		; $71b9
	rst_jumpTable			; $71bc
.dw $71c5
.dw $71e2
.dw $71f0
.dw $71f4

_label_03_153:
	ld bc,bank2.rectangleData_02_7de1		; $71c5
	callab bank2.copyRectangleFromTmpGfxBuffer_paramBc		; $71c8
	ld a,UNCMP_GFXH_3c		; $71d0
	call loadUncompressedGfxHeader		; $71d2
	ld a,SND_DOORCLOSE		; $71d5
	call playSound		; $71d7
	ld a,$1e		; $71da
	ld (wTmpcbb4),a		; $71dc
	jp $7163		; $71df
	ld b,$51		; $71e2
_label_03_154:
	call $7158		; $71e4
	ret nz			; $71e7
	ld (hl),$1e		; $71e8
	ld a,b			; $71ea
	call loadGfxHeader		; $71eb
	jr _label_03_153		; $71ee
	ld b,$52		; $71f0
	jr _label_03_154		; $71f2
	call $7158		; $71f4
	ret nz			; $71f7
	callab bank2.drawCollapsedWingDungeon		; $71f8
	call $71d0		; $7200
	ld a,$3c		; $7203
	ld (wTmpcbb4),a		; $7205
	jp $715e		; $7208
	call $7158		; $720b
	ret nz			; $720e
	jp $715e		; $720f
	ld a,$01		; $7212
	ld (wCutsceneIndex),a		; $7214
	ld a,$01		; $7217
	ld (wScrollMode),a		; $7219
	ld hl,objectData.objectData7e69		; $721c
	call parseGivenObjectData		; $721f
	xor a			; $7222
	ld (wDisabledObjects),a		; $7223
	ld (wMenuDisabled),a		; $7226
	ld a,(wActiveMusic)		; $7229
	jp playSound		; $722c
	ret			; $722f
	nop			; $7230
	ld bc,$0000		; $7231
	ld hl,wTmpcbb4		; $7234
	dec (hl)		; $7237
	ret nz			; $7238
	ret			; $7239
	ld hl,wCutsceneState		; $723a
	inc (hl)		; $723d
	ret			; $723e
_label_03_155:
	ld hl,wTmpcbb3		; $723f
	inc (hl)		; $7242
	ret			; $7243

;;
; @addr{7244}
func_03_7244:
	ld a,(wCutsceneState)		; $7244
	rst_jumpTable			; $7247
.dw $7250
.dw $729d
.dw $7318
.dw $73b2

	ld b,$10		; $7250
	ld hl,wTmpcbb3		; $7252
	call clearMemory		; $7255
	call $723a		; $7258
	call stopTextThread		; $725b
	xor a			; $725e
	ld hl,wLoadedTreeGfxActive		; $725f
	ldi (hl),a		; $7262
	ld (hl),a		; $7263
	ld a,$01		; $7264
	ld ($cc20),a		; $7266
	dec a			; $7269
	ld (wScrollMode),a		; $726a
	ld a,$08		; $726d
	ld ($cbb7),a		; $726f
	ld hl,$4133		; $7272
	ld e,$3f		; $7275
	call interBankCall		; $7277
	callab bank6.specialObjectLoadAnimationFrameToBuffer		; $727a
	ld a,$6f		; $7282
	call loadGfxHeader		; $7284
	call fastFadeoutToBlack		; $7287
	xor a			; $728a
	ld (wDirtyFadeSprPalettes),a		; $728b
	dec a			; $728e
	ld (wFadeSprPaletteSources),a		; $728f
	ld hl,wLoadedObjectGfx		; $7292
	ld b,$10		; $7295
	call clearMemory		; $7297
	jp hideStatusBar		; $729a
	ld a,(wTmpcbb3)		; $729d
	rst_jumpTable			; $72a0
.dw $72ad
.dw $72b8
.dw $72bd
.dw $72c2
.dw $72c7
.dw $72d3

	ld hl,$d000		; $72ad
_label_03_156:
	call $7431		; $72b0
	call $745c		; $72b3
	jr _label_03_155		; $72b6
	ld hl,$d400		; $72b8
	jr _label_03_156		; $72bb
	ld hl,$d800		; $72bd
	jr _label_03_156		; $72c0
	ld hl,$dc00		; $72c2
	jr _label_03_156		; $72c5
	ld hl,$d000		; $72c7
	call $7431		; $72ca
	call $7456		; $72cd
	jp $723f		; $72d0
	ld hl,$d400		; $72d3
	call $7431		; $72d6
	call $7450		; $72d9
	ld hl,$cbb7		; $72dc
	dec (hl)		; $72df
	jr z,_label_03_157	; $72e0
	ld hl,$cbb8		; $72e2
	inc (hl)		; $72e5
	ld hl,wTmpcbb3		; $72e6
	ld (hl),$00		; $72e9
	ret			; $72eb
_label_03_157:
	xor a			; $72ec
	ld ($ff00+R_SVBK),a	; $72ed
	call clearItems		; $72ef
	call clearEnemies		; $72f2
	call clearParts		; $72f5
	call clearReservedInteraction0		; $72f8
	call clearDynamicInteractions		; $72fb
	ld de,$d100		; $72fe
	call objectDelete_de		; $7301
	ld a,$d0		; $7304
	ld (wLinkObjectIndex),a		; $7306
	call refreshObjectGfx		; $7309
	xor a			; $730c
	ld ($cc20),a		; $730d
	ld hl,wTmpcbb3		; $7310
	ld (hl),$00		; $7313
	jp $723a		; $7315
	ld a,(wTmpcbb3)		; $7318
	rst_jumpTable			; $731b
.dw $7326
.dw $7350
.dw $7375
.dw $739d
.dw $73a7

	ld a,(wcddf)		; $7326
	or a			; $7329
	jr nz,_label_03_158	; $732a
	callab func_04_6f07		; $732c
_label_03_158:
	ld a,$03		; $7334
	ld ($ff00+R_SVBK),a	; $7336
	ld bc,$02c0		; $7338
	ld hl,$d800		; $733b
	call clearMemoryBc		; $733e
	ld bc,$02c0		; $7341
	ld hl,$dc00		; $7344
	call clearMemoryBc		; $7347
	call reloadTileMap		; $734a
	jp $723f		; $734d
	call getFreeInteractionSlot		; $7350
	ld (hl),$dd		; $7353
	ld l,$46		; $7355
	ld a,$78		; $7357
	ld (hl),a		; $7359
	ld (wTmpcbb4),a		; $735a
	ld a,(wAreaFlags)		; $735d
	and $80			; $7360
	ld a,$02		; $7362
	jr nz,_label_03_159	; $7364
	dec a			; $7366
_label_03_159:
	ld l,$43		; $7367
	ld (hl),a		; $7369
	ld (wcc50),a		; $736a
.ifdef ROM_AGES
	ld a,SND_TIMEWARP_INITIATED		; $736d
.else
	ld a,$d1
.endif
	call playSound		; $736f
	jp $723f		; $7372
	call $7234		; $7375
	ret nz			; $7378
	ld (hl),$3c		; $7379
	call getFreeInteractionSlot		; $737b
	jr nz,_label_03_160	; $737e
	ld (hl),$dd		; $7380
	inc l			; $7382
	ld (hl),$02		; $7383
	ld de,w1Link.yh		; $7385
	call objectCopyPosition_rawAddress		; $7388
_label_03_160:
	ld de,w1Link.yh		; $738b
	call getShortPositionFromDE		; $738e
	ld (wTmpcbb9),a		; $7391
	ld de,$d000		; $7394
	call objectDelete_de		; $7397
	jp $723f		; $739a
	call $7234		; $739d
	ret nz			; $73a0
	call fastFadeinFromBlack		; $73a1
	jp $723f		; $73a4
	ld a,(wPaletteThread_mode)		; $73a7
	or a			; $73aa
	ret nz			; $73ab
	call fadeoutToWhite		; $73ac
	jp $723a		; $73af
	ld a,(wcddf)		; $73b2
	or a			; $73b5
	jr nz,_label_03_161	; $73b6
	callab func_04_6e9b		; $73b8
_label_03_161:
	ld a,(wActiveRoom)		; $73c0
	ld b,a			; $73c3
	ld a,(wActiveGroup)		; $73c4
	xor $01			; $73c7
	call getRoomFlags		; $73c9
	ld (wLinkStateParameter),a		; $73cc
	ld hl,wWarpDestGroup		; $73cf
	ld a,(wActiveGroup)		; $73d2
	xor $01			; $73d5
	or $80			; $73d7
	ldi (hl),a		; $73d9
	ld a,(wActiveRoom)		; $73da
	ldi (hl),a		; $73dd
	ld a,$06		; $73de
	ldi (hl),a		; $73e0
	ld a,(wActiveTilePos)		; $73e1
	ld (hl),a		; $73e4
	callab bank1.checkSolidObjectAtWarpDestPos		; $73e5
	srl c			; $73ed
	jr nc,_label_03_162	; $73ef
	ld a,(wTmpcbb9)		; $73f1
	ld (wWarpDestPos),a		; $73f4
_label_03_162:
	ld a,$03		; $73f7
	ld (wCutsceneIndex),a		; $73f9
	ld a,$ff		; $73fc
	ld (wActiveMusic),a		; $73fe
	ld a,(wActiveRoom)		; $7401
	ld hl,$7411		; $7404
	call checkFlag		; $7407
	ret z			; $740a
	ld a,$01		; $740b
	ld (wSentBackByStrangeForce),a		; $740d
	ret			; $7410
	nop			; $7411
	nop			; $7412
	nop			; $7413
	nop			; $7414
	nop			; $7415
	nop			; $7416
	nop			; $7417
	nop			; $7418
	nop			; $7419
	nop			; $741a
	nop			; $741b
	jr c,_label_03_163	; $741c
_label_03_163:
	jr c,_label_03_166	; $741e
	jr c,$60		; $7420
	stop			; $7422
	nop			; $7423
	nop			; $7424
	nop			; $7425
	nop			; $7426
	nop			; $7427
	nop			; $7428
	nop			; $7429
	nop			; $742a
	nop			; $742b
	nop			; $742c
	nop			; $742d
	nop			; $742e
	nop			; $742f
	nop			; $7430
	push hl			; $7431
	ld a,($cbb8)		; $7432
	and $07			; $7435
	ld hl,$7440		; $7437
	rst_addDoubleIndex			; $743a
	ldi a,(hl)		; $743b
	ld e,(hl)		; $743c
	ld d,a			; $743d
	pop hl			; $743e
	ret			; $743f
.DB $dd				; $7440
	rst $38			; $7441
.DB $dd				; $7442
	cp e			; $7443
	ld d,l			; $7444
	cp e			; $7445
	ld d,l			; $7446
	xor d			; $7447
	ld de,$11aa		; $7448
	adc b			; $744b
	nop			; $744c
	adc b			; $744d
	nop			; $744e
	nop			; $744f
	ld b,$2f		; $7450
	ld c,$06		; $7452
	jr _label_03_164		; $7454
	ld b,$3f		; $7456
	ld c,$06		; $7458
	jr _label_03_164		; $745a
	ld b,$3f		; $745c
	ld c,$05		; $745e
_label_03_164:
	push bc			; $7460
	push hl			; $7461
	ld a,c			; $7462
	ld ($ff00+R_SVBK),a	; $7463
	ld b,$00		; $7465
_label_03_165:
	ld a,(hl)		; $7467
	and d			; $7468
	ldi (hl),a		; $7469
	ld a,(hl)		; $746a
	and d			; $746b
	ldi (hl),a		; $746c
	ld a,(hl)		; $746d
	and e			; $746e
	ldi (hl),a		; $746f
	ld a,(hl)		; $7470
	and e			; $7471
	ldi (hl),a		; $7472
	dec b			; $7473
	jr nz,_label_03_165	; $7474
	pop hl			; $7476
	pop bc			; $7477
	ld a,c			; $7478
	sub $05			; $7479
	ld e,a			; $747b
	ld a,h			; $747c
	and $8f			; $747d
	ld d,a			; $747f
_label_03_166:
	jp queueDmaTransfer		; $7480
	ld hl,wTmpcbb4		; $7483
	dec (hl)		; $7486
	ret nz			; $7487
	ret			; $7488
	ld hl,wCutsceneState		; $7489
	inc (hl)		; $748c
	ret			; $748d
	ld hl,wTmpcbb3		; $748e
	inc (hl)		; $7491
	ret			; $7492

;;
; @addr{7493}
func_03_7493:
	ld a,(wCutsceneState)		; $7493
	rst_jumpTable			; $7496
.dw $749d
.dw $74de
.dw $7529

	ld a,(wPaletteThread_mode)		; $749d
	or a			; $74a0
	ret nz			; $74a1
	ld b,$08		; $74a2
	ld hl,wTmpcbb3		; $74a4
	call clearMemory		; $74a7
	ld a,$3c		; $74aa
	ld (wTmpcbb4),a		; $74ac
	call $7489		; $74af
	call disableLcd		; $74b2
	call clearOam		; $74b5
	call clearScreenVariablesAndWramBank1		; $74b8
	callab bank1.clearMemoryOnScreenReload		; $74bb
	call stopTextThread		; $74c3
	xor a			; $74c6
	ld bc,$0127		; $74c7
	call func_36f6		; $74ca
	call loadRoomCollisions		; $74cd
	call func_131f		; $74d0
	call loadCommonGraphics		; $74d3
	call fadeinFromWhite		; $74d6
	ld a,$02		; $74d9
	jp loadGfxRegisterStateIndex		; $74db
	ld a,(wTmpcbb3)		; $74de
	rst_jumpTable			; $74e1
.dw $74e6
.dw $751b

	ld a,(wPaletteThread_mode)		; $74e6
	or a			; $74e9
	ret nz			; $74ea
	call $7483		; $74eb
	ret nz			; $74ee
	ld (hl),$3e		; $74ef
	ld a,(wTmpcbbd)		; $74f1
	ld hl,$7513		; $74f4
	rst_addDoubleIndex			; $74f7
	ldi a,(hl)		; $74f8
	ld b,(hl)		; $74f9
	ld c,a			; $74fa
	call getFreeInteractionSlot		; $74fb
	ret nz			; $74fe
	ld (hl),$14		; $74ff
	ld l,$49		; $7501
	ld (hl),b		; $7503
	ld l,$4b		; $7504
	call setShortPosition_paramC		; $7506
	ld l,$4b		; $7509
	dec (hl)		; $750b
	dec (hl)		; $750c
	ld l,$70		; $750d
	ld (hl),c		; $750f
	jp $748e		; $7510
	inc sp			; $7513
	stop			; $7514
	inc (hl)		; $7515
	nop			; $7516
	dec (hl)		; $7517
	stop			; $7518
	ld (hl),$00		; $7519
	call $7483		; $751b
	ret nz			; $751e
	ld (hl),$1e		; $751f
	ld a,SND_SOLVEPUZZLE		; $7521
	call playSound		; $7523
	jp $7489		; $7526
	call $7483		; $7529
	ret nz			; $752c
	call getThisRoomFlags		; $752d
	ld a,(wTmpcbbb)		; $7530
	ld (wWarpDestIndex),a		; $7533
	ld l,a			; $7536
	set 7,(hl)		; $7537
	ld a,$81		; $7539
	ld (wWarpDestGroup),a		; $753b
	ld a,(wTmpcbbc)		; $753e
	ld (wWarpDestPos),a		; $7541
	ld a,$00		; $7544
	ld (wWarpTransition),a		; $7546
	ld a,$03		; $7549
	ld (wCutsceneIndex),a		; $754b
	xor a			; $754e
	ld (wMenuDisabled),a		; $754f
	jp fadeoutToWhite		; $7552
	ld hl,wTmpcbb4		; $7555
	dec (hl)		; $7558
	ret nz			; $7559
	ret			; $755a
_label_03_167:
	ld hl,wCutsceneState		; $755b
	inc (hl)		; $755e
	ret			; $755f
_label_03_168:
	ld hl,wTmpcbb3		; $7560
	inc (hl)		; $7563
	ret			; $7564

func_03_7565:
	ld a,(wCutsceneState)		; $7565
	rst_jumpTable			; $7568
.dw $756f
.dw $758f
.dw $75e9

	ld b,$10		; $756f
	ld hl,wTmpcbb3		; $7571
	call clearMemory		; $7574
	callab bank1.checkDisableUnderwaterWaves		; $7577
	call getThisRoomFlags		; $757f
	set 1,(hl)		; $7582
	ld a,$04		; $7584
	ld (wTmpcbb4),a		; $7586
	xor a			; $7589
	ld (wScrollMode),a		; $758a
	jr _label_03_167		; $758d
	ld a,(wTmpcbb3)		; $758f
	rst_jumpTable			; $7592
.dw $759b
.dw $75ae
.dw $75b6
.dw $75d7

	call $7555		; $759b
	ret nz			; $759e
	ld (hl),$3c		; $759f
	call reloadTileMap		; $75a1
	callab bank1.checkInitUnderwaterWaves		; $75a4
	jr _label_03_168		; $75ac
	call $7555		; $75ae
	ret nz			; $75b1
	ld (hl),$3c		; $75b2
	jr _label_03_168		; $75b4
	ld a,$3c		; $75b6
	call setScreenShakeCounter		; $75b8
	call $7555		; $75bb
	ret nz			; $75be
	ld (hl),$3c		; $75bf
	call $7560		; $75c1
	ld bc,$9701		; $75c4
	call objectCreateInteraction		; $75c7
	ld a,$74		; $75ca
_label_03_169:
	call loadGfxHeader		; $75cc
	call reloadTileMap		; $75cf
	ld a,SND_DOORCLOSE		; $75d2
	jp playSound		; $75d4
	ld a,$3c		; $75d7
	call setScreenShakeCounter		; $75d9
	call $7555		; $75dc
	ret nz			; $75df
	ld (hl),$3c		; $75e0
	call $755b		; $75e2
	ld a,$75		; $75e5
	jr _label_03_169		; $75e7
	call $7555		; $75e9
	ret nz			; $75ec
	ld a,SND_SOLVEPUZZLE		; $75ed
	call playSound		; $75ef
	ld a,$01		; $75f2
	ld (wCutsceneIndex),a		; $75f4
	ld a,$01		; $75f7
	ld (wScrollMode),a		; $75f9
	xor a			; $75fc
	ld (wDisabledObjects),a		; $75fd
	ld (wMenuDisabled),a		; $7600
	call loadTilesetAndRoomLayout		; $7603
	jp loadRoomCollisions		; $7606
	ld hl,wTmpcbb4		; $7609
	dec (hl)		; $760c
	ret nz			; $760d
	ret			; $760e
	ld hl,wCutsceneState		; $760f
	inc (hl)		; $7612
	ret			; $7613
	ld hl,wTmpcbb3		; $7614
	inc (hl)		; $7617
	ret			; $7618

;;
; @addr{7619}
func_03_7619:
	ld a,(wCutsceneState)		; $7619
	rst_jumpTable			; $761c
.dw $762b
.dw $767c
.dw $7702
.dw $772c
.dw $775d
.dw $779a
.dw $77d6

	ld a,(wPaletteThread_mode)		; $762b
	or a			; $762e
	ret nz			; $762f
	ld b,$10		; $7630
	ld hl,wTmpcbb3		; $7632
	call clearMemory		; $7635
	call clearScreenVariablesAndWramBank1		; $7638
	call refreshObjectGfx		; $763b
	ld a,MUS_FAIRY		; $763e
	call playSound		; $7640
	call $760f		; $7643
	xor a			; $7646
	ld bc,$01a5		; $7647
	push bc			; $764a
	call disableLcd		; $764b
	ld a,PALH_0f		; $764e
	call loadPaletteHeader		; $7650
	call clearOam		; $7653
	call clearScreenVariablesAndWramBank1		; $7656
	callab bank1.clearMemoryOnScreenReload		; $7659
	call stopTextThread		; $7661
	ld a,$01		; $7664
	ld (wDisabledObjects),a		; $7666
	ld (wMenuDisabled),a		; $7669
	xor a			; $766c
	pop bc			; $766d
	call func_36f6		; $766e
	call func_131f		; $7671
	call loadCommonGraphics		; $7674
	ld a,$02		; $7677
	jp loadGfxRegisterStateIndex		; $7679
	ld a,(wTmpcbb3)		; $767c
	rst_jumpTable			; $767f
.dw $7688
.dw $7695
.dw $76cb
.dw $76ea

	ld a,(wPaletteThread_mode)		; $7688
	or a			; $768b
	ret nz			; $768c
	ld a,$f0		; $768d
	ld (wTmpcbb4),a		; $768f
	jp $7614		; $7692
	ld a,(wFrameCounter)		; $7695
	and $07			; $7698
	jr nz,_label_03_170	; $769a
	call getFreePartSlot		; $769c
	jr nz,_label_03_170	; $769f
	ld (hl),$26		; $76a1
	call getRandomNumber		; $76a3
	and $7f			; $76a6
	ld c,a			; $76a8
	ld l,$cb		; $76a9
	call setShortPosition_paramC		; $76ab
_label_03_170:
	ld a,(wFrameCounter)		; $76ae
	and $1f			; $76b1
	ld a,SND_MAGIC_POWDER		; $76b3
	call z,playSound		; $76b5
	call $7609		; $76b8
	ret nz			; $76bb
	ld (hl),$78		; $76bc
	ld a,$04		; $76be
	call fadeoutToWhiteWithDelay		; $76c0
	ld a,SND_FADEOUT		; $76c3
	call playSound		; $76c5
	jp $7614		; $76c8
	ld a,(wPaletteThread_mode)		; $76cb
	or a			; $76ce
	ret nz			; $76cf
	call $782a		; $76d0
	call $782a		; $76d3
	call $782a		; $76d6
	call $782a		; $76d9
	ret z			; $76dc
	ld a,$04		; $76dd
	call fadeinFromWhiteWithDelay		; $76df
	ld a,SND_FAIRYCUTSCENE		; $76e2
	call playSound		; $76e4
	jp $7614		; $76e7
	ld a,(wPaletteThread_mode)		; $76ea
	or a			; $76ed
	ret nz			; $76ee
	call $7609		; $76ef
	ret nz			; $76f2
	ld (hl),$3c		; $76f3
	call $760f		; $76f5
	xor a			; $76f8
	ld (wTmpcbb3),a		; $76f9
	ld bc,$01d2		; $76fc
	jp $764a		; $76ff
	ld a,(wTmpcbb3)		; $7702
	rst_jumpTable			; $7705
.dw $7688
.dw $7695
.dw $76cb
.dw $770e

	ld a,(wPaletteThread_mode)		; $770e
	or a			; $7711
	ret nz			; $7712
	call $7609		; $7713
	ret nz			; $7716
	ld (hl),$3c		; $7717
	call $760f		; $7719
	xor a			; $771c
	ld (wTmpcbb3),a		; $771d
	ld bc,$03b1		; $7720
	call $764a		; $7723
	ld hl,objectData.objectData7e71		; $7726
	jp parseGivenObjectData		; $7729
	ld a,(wTmpcbb3)		; $772c
	rst_jumpTable			; $772f
.dw $7688
.dw $7695
.dw $76cb
.dw $7738

	ld a,(wPaletteThread_mode)		; $7738
	or a			; $773b
	ret nz			; $773c
	ld hl,$cfc0		; $773d
	bit 7,(hl)		; $7740
	ret z			; $7742
	res 7,(hl)		; $7743
	call $760f		; $7745
	xor a			; $7748
	ld (wTmpcbb3),a		; $7749
	ld a,$3c		; $774c
	ld (wTmpcbb4),a		; $774e
	ld bc,$03b0		; $7751
	call $764a		; $7754
	ld hl,objectData.objectData7e7b		; $7757
	jp parseGivenObjectData		; $775a
	ld a,(wTmpcbb3)		; $775d
	rst_jumpTable			; $7760
.dw $7688
.dw $7695
.dw $76cb
.dw $7769

	ld a,(wPaletteThread_mode)		; $7769
	or a			; $776c
	ret nz			; $776d
	ld hl,$cfc0		; $776e
	bit 7,(hl)		; $7771
	ret z			; $7773
	ld a,$3c		; $7774
	ld (wTmpcbb4),a		; $7776
	call $760f		; $7779
	xor a			; $777c
	ld (wTmpcbb3),a		; $777d
	ld bc,$01a3		; $7780
	call $764a		; $7783
	ld hl,$d000		; $7786
	ld (hl),$03		; $7789
	ld l,$0b		; $778b
	ld (hl),$38		; $778d
	ld l,$0d		; $778f
	ld (hl),$68		; $7791
	ld l,$08		; $7793
	ld (hl),$02		; $7795
	jp setLinkForceStateToState08		; $7797
	ld a,(wTmpcbb3)		; $779a
	ld e,a			; $779d
	or a			; $779e
	jr z,_label_03_172	; $779f
	ld a,(wFrameCounter)		; $77a1
	and $1f			; $77a4
	jr nz,_label_03_172	; $77a6
	ld a,(w1Link.direction)		; $77a8
	and $02			; $77ab
	xor $02			; $77ad
_label_03_171:
	or $01			; $77af
	ld (w1Link.direction),a		; $77b1
_label_03_172:
	ld a,e			; $77b4
	rst_jumpTable			; $77b5
.dw $7688
.dw $7695
.dw $76cb
.dw $77be

	ld a,(wPaletteThread_mode)		; $77be
	or a			; $77c1
	ret nz			; $77c2
	ld hl,$cfc0		; $77c3
	bit 7,(hl)		; $77c6
	ret z			; $77c8
	ld a,$3c		; $77c9
	ld (wTmpcbb4),a		; $77cb
	ld a,SND_SOLVEPUZZLE_2		; $77ce
	call playSound		; $77d0
	jp $760f		; $77d3
	call $7609		; $77d6
	ret nz			; $77d9
	ld a,$01		; $77da
	ld (wScrollMode),a		; $77dc
	callab bank1.calculateRoomEdge		; $77df
	callab bank1.func_49c9		; $77e7
	callab bank1.setObjectsEnabledTo2		; $77ef
	xor a			; $77f7
	ld (wMenuDisabled),a		; $77f8
	ld (wDisabledObjects),a		; $77fb
	ld a,(wLoadingRoomPack)		; $77fe
	ld (wRoomPack),a		; $7801
	ld a,(wActiveRoom)		; $7804
	ld (wLoadingRoom),a		; $7807
	ld a,MUS_CAVE		; $780a
	ld (wEnteredWarpPosition),a		; $780c
	ld a,(wActiveMusic2)		; $780f
	ld (wActiveMusic),a		; $7812
	call playSound		; $7815
	ld a,$00		; $7818
	ld (wCutsceneIndex),a		; $781a
	ld a,$02		; $781d
	ld (w1Link.direction),a		; $781f
	ld a,GLOBALFLAG_WATER_POLLUTION_FIXED		; $7822
	call setGlobalFlag		; $7824
	jp setDeathRespawnPoint		; $7827
	ld a,$eb		; $782a
	call findTileInRoom		; $782c
	ret nz			; $782f
	ld c,l			; $7830
	ld a,(wAreaFlags)		; $7831
	and $40			; $7834
	ld a,$fc		; $7836
	jr z,_label_03_173	; $7838
	ld a,$3a		; $783a
_label_03_173:
	call setTile		; $783c
	xor a			; $783f
	ret			; $7840

;;
; Called from "func_3ed0" in bank 0.
;
; @addr{7841}
func_03_7841:
	ld a,(wCutsceneState)		; $7841
	rst_jumpTable			; $7844
.dw _func_03_7851
.dw _func_03_786b

;;
; Called from "func_3ee4" in bank 0.
; @addr{7849}
func_03_7849:
	ld a,(wCutsceneState)		; $7849
	rst_jumpTable			; $784c
.dw _func_03_7851
.dw $797d

;;
; @addr{7851}
_func_03_7851:
	ld b,$10		; $7851
	ld hl,wTmpcbb3		; $7853
	call clearMemory		; $7856
	call clearWramBank1		; $7859
	xor a			; $785c
	ld (wDisabledObjects),a		; $785d
	ld a,$80		; $7860
	ld (wMenuDisabled),a		; $7862
	ld a,$01		; $7865
	ld (wCutsceneState),a		; $7867
	ret			; $786a

;;
; @addr{786b}
_func_03_786b:
	ld a,(wTmpcbb3)		; $786b
	rst_jumpTable			; $786e
.dw $7887
.dw $788f
.dw $78b8
.dw $78c7
.dw _func_03_78e1
.dw $78ef
.dw $7913
.dw $7936
.dw $793f
.dw $7948
.dw $7951
.dw $7960

	ld a,$28		; $7887
	ld (wTmpcbb5),a		; $7889
	jp $7b8b		; $788c
	call _func_03_7b95		; $788f
	ret nz			; $7892
	call $7bab		; $7893
	call getFreeInteractionSlot		; $7896
	jr nz,_label_03_174	; $7899
	ld (hl),$a9		; $789b
	inc l			; $789d
	ld (hl),$01		; $789e
_label_03_174:
	ld a,$13		; $78a0
	call loadGfxRegisterStateIndex		; $78a2
	ld a,SND_LIGHTNING		; $78a5
	call playSound		; $78a7
	xor a			; $78aa
	ld (wTmpcbb5),a		; $78ab
	ld (wTmpcbb6),a		; $78ae
	dec a			; $78b1
	ld (wTmpcbba),a		; $78b2
	call $7b8b		; $78b5
	ld hl,wTmpcbb5		; $78b8
	ld b,$05		; $78bb
	call flashScreen		; $78bd
	ret z			; $78c0
	call clearPaletteFadeVariablesAndRefreshPalettes		; $78c1
	jp $7b8b		; $78c4
	call getFreeInteractionSlot		; $78c7
	jr nz,_label_03_175	; $78ca
	ld (hl),$a9		; $78cc
_label_03_175:
	ld a,SNDCTRL_STOPMUSIC		; $78ce
	call playSound		; $78d0
	call _clearFadingPalettes		; $78d3
	ld a,$bf		; $78d6
	ldh (<hSprPaletteSources),a	; $78d8
	ldh (<hDirtySprPalettes),a	; $78da
	ld a,$04		; $78dc
	jp $7b88		; $78de

;;
; @addr{78e1}
_func_03_78e1:
	call _func_03_7b95		; $78e1
	ret nz			; $78e4

	ld a,TEXTBOXFLAG_ALTPALETTE1		; $78e5
	ld (wTextboxFlags),a		; $78e7
	ld c,$1b		; $78ea
	jp _func_03_7b81		; $78ec

	call $7b9a		; $78ef
	ret nz			; $78f2
	ld b,$10		; $78f3
	call $78fd		; $78f5
	ld a,$1e		; $78f8
	jp $7b88		; $78fa
	call fastFadeinFromBlack		; $78fd
	ld a,b			; $7900
	ld (wDirtyFadeSprPalettes),a		; $7901
	ld (wFadeSprPaletteSources),a		; $7904
	xor a			; $7907
	ld (wDirtyFadeBgPalettes),a		; $7908
	ld (wFadeBgPaletteSources),a		; $790b
	ld a,SND_LIGHTTORCH		; $790e
	jp playSound		; $7910
	call $7ba1		; $7913
	ret nz			; $7916
	call fadeinFromBlack		; $7917
	ld a,$af		; $791a
	ld (wDirtyFadeSprPalettes),a		; $791c
	ld (wFadeSprPaletteSources),a		; $791f
	call $7bd0		; $7922
	ld a,MUS_DISASTER		; $7925
	ld (wActiveMusic),a		; $7927
	call playSound		; $792a
	xor a			; $792d
	ld ($cfc6),a		; $792e
	ld a,$1e		; $7931
	jp $7b88		; $7933
	call $7ba1		; $7936
	ret nz			; $7939
	ld c,$29		; $793a
	jp _func_03_7b81		; $793c
	call $7b9a		; $793f
	ret nz			; $7942
	ld c,$1c		; $7943
	jp _func_03_7b81		; $7945
	call $7b9a		; $7948
	ret nz			; $794b
	ld c,$1d		; $794c
	jp _func_03_7b81		; $794e
	call $7b9a		; $7951
	ret nz			; $7954
	ld c,$1e		; $7955
	call _func_03_7b81		; $7957
	ld a,$3c		; $795a
	ld (wTmpcbb5),a		; $795c
	ret			; $795f
	call $7b9a		; $7960
	ret nz			; $7963
	xor a			; $7964
	ld (wMenuDisabled),a		; $7965
	ld hl,$7978		; $7968
	call setWarpDestVariables		; $796b
	ld a,$00		; $796e
	ld (wcc50),a		; $7970
	ld a,PALH_0f		; $7973
	jp loadPaletteHeader		; $7975
	add h			; $7978
	ld ($870c),a		; $7979
	add e			; $797c
	call $7983		; $797d
	jp updateStatusBar		; $7980
	ld a,(wTmpcbb3)		; $7983
	rst_jumpTable			; $7986
.dw $79b5
.dw $79d8
.dw $79e6
.dw $79f9
.dw $7a0b
.dw $7a19
.dw $7a2c
.dw $7a37
.dw $7a45
.dw $7a54
.dw $7a6d
.dw $7a8b
.dw $7a9a
.dw $7aa3
.dw $7aac
.dw $7ab8
.dw $7aca
.dw $7adf
.dw $7af6
.dw $7aff
.dw $7b08
.dw $7b1b
.dw $7b30

	ld a,(wPaletteThread_mode)		; $79b5
	or a			; $79b8
	ret nz			; $79b9
	ld a,$01		; $79ba
	ld (wLoadedTreeGfxIndex),a		; $79bc
	ld bc,$0149		; $79bf
	call disableLcdAndLoadRoom		; $79c2
	ld a,$02		; $79c5
	call loadGfxRegisterStateIndex		; $79c7
	call restartSound		; $79ca
	call $7c2a		; $79cd
	call fadeinFromWhite		; $79d0
	ld a,$3c		; $79d3
	jp $7b88		; $79d5
	call $7ba1		; $79d8
	ret nz			; $79db
	ld hl,$cfc0		; $79dc
	set 0,(hl)		; $79df
	ld a,$01		; $79e1
	jp $7b88		; $79e3
	ld hl,$cfc0		; $79e6
	bit 1,(hl)		; $79e9
	ret z			; $79eb
	call _func_03_7b95		; $79ec
	ret nz			; $79ef
	xor a			; $79f0
	call $7c68		; $79f1
	ld a,$1e		; $79f4
	jp $7b88		; $79f6
	call _func_03_7b95		; $79f9
	ret nz			; $79fc
	xor a			; $79fd
	call $7c83		; $79fe
	ld hl,$cfc0		; $7a01
	set 2,(hl)		; $7a04
	ld a,$1e		; $7a06
	jp $7b88		; $7a08
	call _func_03_7b95		; $7a0b
	ret nz			; $7a0e
	ld a,$01		; $7a0f
	call $7c68		; $7a11
	ld a,$1e		; $7a14
	jp $7b88		; $7a16
	call _func_03_7b95		; $7a19
	ret nz			; $7a1c
	ld a,$01		; $7a1d
	call $7c83		; $7a1f
	ld hl,$cfc0		; $7a22
	set 3,(hl)		; $7a25
	ld a,$1e		; $7a27
	jp $7b88		; $7a29
	ld hl,$cfc0		; $7a2c
	bit 4,(hl)		; $7a2f
	ret z			; $7a31
	ld a,$1e		; $7a32
	jp $7b88		; $7a34
	call _func_03_7b95		; $7a37
	ret nz			; $7a3a
	ld hl,$cfc0		; $7a3b
	set 5,(hl)		; $7a3e
	ld a,$28		; $7a40
	jp $7b88		; $7a42
	call _func_03_7b95		; $7a45
	ret nz			; $7a48
	ld c,$1f		; $7a49
	call _func_03_7b81		; $7a4b
	ld a,$5a		; $7a4e
	ld (wTmpcbb5),a		; $7a50
	ret			; $7a53
	call $7b9a		; $7a54
	jr z,_label_03_176	; $7a57
	ld a,$3c		; $7a59
	cp (hl)			; $7a5b
	ret nz			; $7a5c
	ld hl,$cfc0		; $7a5d
	set 6,(hl)		; $7a60
	ret			; $7a62
_label_03_176:
	ld hl,$cfc0		; $7a63
	set 7,(hl)		; $7a66
	ld a,$3c		; $7a68
	jp $7b88		; $7a6a
	call _func_03_7b95		; $7a6d
	ret nz			; $7a70
	call $7c1f		; $7a71
	call $7beb		; $7a74
	ld a,MUS_DISASTER		; $7a77
	ld (wActiveMusic),a		; $7a79
	call playSound		; $7a7c
	xor a			; $7a7f
	ld ($cfc0),a		; $7a80
	ld ($cfc6),a		; $7a83
	ld a,$1e		; $7a86
	jp $7b88		; $7a88
	ld a,($cfc0)		; $7a8b
	bit 0,a			; $7a8e
	ret z			; $7a90
	call _func_03_7b95		; $7a91
	ret nz			; $7a94
	ld c,$20		; $7a95
	jp _func_03_7b81		; $7a97
	call $7b9a		; $7a9a
	ret nz			; $7a9d
	ld c,$21		; $7a9e
	jp _func_03_7b81		; $7aa0
	call $7b9a		; $7aa3
	ret nz			; $7aa6
	ld c,$22		; $7aa7
	jp _func_03_7b81		; $7aa9
	call $7b9a		; $7aac
	ret nz			; $7aaf
	ld hl,$cfc0		; $7ab0
	res 0,(hl)		; $7ab3
	jp $7b8b		; $7ab5
	ld a,($cfc0)		; $7ab8
	bit 0,a			; $7abb
	ret z			; $7abd
	ld a,SND_LIGHTNING		; $7abe
	call playSound		; $7ac0
	xor a			; $7ac3
	ld (wTmpcbb4),a		; $7ac4
	call $7b8b		; $7ac7
	call $7b48		; $7aca
	ret nz			; $7acd
	call clearDynamicInteractions		; $7ace
	ld hl,$cfc0		; $7ad1
	res 0,(hl)		; $7ad4
	xor a			; $7ad6
	ld ($cfc6),a		; $7ad7
	ld a,$04		; $7ada
	jp $7b88		; $7adc
	call _func_03_7b95		; $7adf
	ret nz			; $7ae2
	call $7c1f		; $7ae3
	call $7bf6		; $7ae6
	call $7c2f		; $7ae9
	ld a,$04		; $7aec
	call fadeinFromWhiteWithDelay		; $7aee
	ld a,$1e		; $7af1
	jp $7b88		; $7af3
	call $7ba1		; $7af6
	ret nz			; $7af9
	ld c,$23		; $7afa
	jp _func_03_7b81		; $7afc
	call $7b9a		; $7aff
	ret nz			; $7b02
	ld c,$24		; $7b03
	jp _func_03_7b81		; $7b05
	call $7b9a		; $7b08
	ret nz			; $7b0b
	ld a,SND_BEAM2		; $7b0c
	call playSound		; $7b0e
	ld hl,$cfc0		; $7b11
	set 0,(hl)		; $7b14
	ld a,$5a		; $7b16
	jp $7b88		; $7b18
	call _func_03_7b95		; $7b1b
	ret nz			; $7b1e
	dec a			; $7b1f
	ld (wTmpcbba),a		; $7b20
	ld a,SND_LIGHTNING		; $7b23
	call playSound		; $7b25
	ld a,SNDCTRL_STOPMUSIC		; $7b28
	call playSound		; $7b2a
	jp $7b8b		; $7b2d
	ld hl,wTmpcbb5		; $7b30
	ld b,$02		; $7b33
	call flashScreen		; $7b35
	ret z			; $7b38
	ld a,GLOBALFLAG_FLAME_OF_DESPAIR_LIT		; $7b39
	call setGlobalFlag		; $7b3b
	xor a			; $7b3e
	ld (wMenuDisabled),a		; $7b3f
	ld a,CUTSCENE_FLAME_OF_DESPAIR		; $7b42
	ld (wCutsceneTrigger),a		; $7b44
	ret			; $7b47
	ld a,(wTmpcbb4)		; $7b48
	rst_jumpTable			; $7b4b
.dw $7b58
.dw $7b63
.dw $7b63
.dw $7b72
.dw $7b76
.dw $7b7e

	ld a,$0a		; $7b58
_label_03_177:
	ld (wTmpcbb5),a		; $7b5a
	call clearFadingPalettes		; $7b5d
	jp _func_03_7b90		; $7b60
	call _func_03_7b95		; $7b63
	ret nz			; $7b66
	ld a,$0a		; $7b67
_label_03_178:
	ld (wTmpcbb5),a		; $7b69
	call fastFadeoutToWhite		; $7b6c
	jp _func_03_7b90		; $7b6f
	ld a,$14		; $7b72
	jr _label_03_177		; $7b74
	call _func_03_7b95		; $7b76
	ret nz			; $7b79
	ld a,$1e		; $7b7a
	jr _label_03_178		; $7b7c
	jp $7ba1		; $7b7e

;;
; @param c Low byte of text index
; @addr{7b81}
_func_03_7b81:
	ld b,$28		; $7b81
	call showText		; $7b83
	ld a,$1e		; $7b86
	ld (wTmpcbb5),a		; $7b88
	ld hl,wTmpcbb3		; $7b8b
	inc (hl)		; $7b8e
	ret			; $7b8f

;;
; @addr{7b90}
_func_03_7b90:
	ld hl,wTmpcbb4		; $7b90
	inc (hl)		; $7b93
	ret			; $7b94

;;
; @addr{7b95}
_func_03_7b95:
	ld hl,wTmpcbb5		; $7b95
	dec (hl)		; $7b98
	ret			; $7b99

	ld a,(wTextIsActive)		; $7b9a
	or a			; $7b9d
	ret nz			; $7b9e
	jr _label_03_179		; $7b9f
	ld a,(wPaletteThread_mode)		; $7ba1
	or a			; $7ba4
	ret nz			; $7ba5
_label_03_179:
	ld hl,wTmpcbb5		; $7ba6
	dec (hl)		; $7ba9
	ret			; $7baa
	xor a			; $7bab
	ld bc,$05f1		; $7bac
	call disableLcdAndLoadRoom		; $7baf
	ld a,PALH_ac		; $7bb2
	call loadPaletteHeader		; $7bb4
	ld a,$28		; $7bb7
	ld (wGfxRegs1.SCX),a		; $7bb9
	ld (wGfxRegs2.SCX),a		; $7bbc
	ldh (<hCameraX),a	; $7bbf
	xor a			; $7bc1
	ldh (<hCameraY),a	; $7bc2
	ld a,$00		; $7bc4
	ld (wScrollMode),a		; $7bc6
	ld a,$10		; $7bc9
	ldh (<hOamTail),a	; $7bcb
	jp clearWramBank1		; $7bcd
	ld bc,$7be5		; $7bd0
	call $7bd9		; $7bd3
	ld bc,$7be8		; $7bd6
	call getFreeInteractionSlot		; $7bd9
	ret nz			; $7bdc
	ld (hl),$b0		; $7bdd
	inc l			; $7bdf
	ld a,(bc)		; $7be0
	inc bc			; $7be1
	ld (hl),a		; $7be2
	jr _label_03_181		; $7be3
	ld (bc),a		; $7be5
	ld c,h			; $7be6
	adc (hl)		; $7be7
	inc bc			; $7be8
	ld c,h			; $7be9
	ld h,d			; $7bea
	ld bc,$7c13		; $7beb
	call $7bff		; $7bee
	ld bc,$7c16		; $7bf1
	jr _label_03_180		; $7bf4
	ld bc,$7c19		; $7bf6
	call $7bff		; $7bf9
	ld bc,$7c1c		; $7bfc
_label_03_180:
	call getFreeInteractionSlot		; $7bff
	ret nz			; $7c02
	ld (hl),$bc		; $7c03
	inc l			; $7c05
	ld a,(bc)		; $7c06
	inc bc			; $7c07
	ld (hl),a		; $7c08
_label_03_181:
	ld l,$4b		; $7c09
	ld a,(bc)		; $7c0b
	inc bc			; $7c0c
	ld (hl),a		; $7c0d
	ld l,$4d		; $7c0e
	ld a,(bc)		; $7c10
	ld (hl),a		; $7c11
	ret			; $7c12
	nop			; $7c13
	nop			; $7c14
	ld b,b			; $7c15
	ld bc,$6000		; $7c16
	ld (bc),a		; $7c19
	ld d,b			; $7c1a
	ld l,b			; $7c1b
	inc bc			; $7c1c
	ld d,b			; $7c1d
	jr c,_label_03_183	; $7c1e
	ld bc,$18ea		; $7c20
	call z,$bc3e		; $7c23
	ld (wInteractionIDToLoadExtraGfx),a		; $7c26
	ret			; $7c29
	ld bc,$7c4e		; $7c2a
	jr _label_03_182		; $7c2d
	ld bc,$7c5d		; $7c2f
_label_03_182:
	ld a,(bc)		; $7c32
	or a			; $7c33
	ret z			; $7c34
	call getFreeInteractionSlot		; $7c35
	ret nz			; $7c38
	ld a,(bc)		; $7c39
	ldi (hl),a		; $7c3a
	inc bc			; $7c3b
	ld a,(bc)		; $7c3c
	ldi (hl),a		; $7c3d
	inc bc			; $7c3e
	ld a,(bc)		; $7c3f
	ldi (hl),a		; $7c40
	inc bc			; $7c41
	ld l,$4b		; $7c42
	ld a,(bc)		; $7c44
	ld (hl),a		; $7c45
	inc bc			; $7c46
	ld l,$4d		; $7c47
	ld a,(bc)		; $7c49
	ld (hl),a		; $7c4a
	inc bc			; $7c4b
	jr _label_03_182		; $7c4c
	inc a			; $7c4e
	rrca			; $7c4f
	inc bc			; $7c50
	ld c,b			; $7c51
	ld c,b			; $7c52
	ld sp,$0308		; $7c53
	ld c,b			; $7c56
	ld e,b			; $7c57
	xor l			; $7c58
	add hl,bc		; $7c59
	ld (bc),a		; $7c5a
	jr c,$50		; $7c5b
	ldd a,(hl)		; $7c5d
_label_03_183:
	ld c,$01		; $7c5e
	ld c,b			; $7c60
	jr c,_label_03_184	; $7c61
	rlca			; $7c63
	nop			; $7c64
	jr z,$78		; $7c65
	nop			; $7c67
	ld bc,$7c7f		; $7c68
	call addDoubleIndexToBc		; $7c6b
	call getFreePartSlot		; $7c6e
	ret nz			; $7c71
	ld (hl),$27		; $7c72
	inc l			; $7c74
	inc (hl)		; $7c75
	ld l,$cb		; $7c76
	ld a,(bc)		; $7c78
	ldi (hl),a		; $7c79
	inc bc			; $7c7a
	inc l			; $7c7b
	ld a,(bc)		; $7c7c
	ld (hl),a		; $7c7d
	ret			; $7c7e
	ld e,b			; $7c7f
	jr c,$48		; $7c80
	ld l,b			; $7c82
	ld bc,$7c7f		; $7c83
	call addDoubleIndexToBc		; $7c86
	call getFreeInteractionSlot		; $7c89
	ret nz			; $7c8c
	ld (hl),$6b		; $7c8d
	inc l			; $7c8f
	ld (hl),$16		; $7c90
	ld l,$46		; $7c92
	ld (hl),$78		; $7c94
	jp $7c09		; $7c96
	ld hl,wCutsceneState		; $7c99
	inc (hl)		; $7c9c
	ret			; $7c9d
	ld hl,wTmpcbb3		; $7c9e
	inc (hl)		; $7ca1
	ret			; $7ca2
	ld hl,wTmpcbb4		; $7ca3
_label_03_184:
	dec (hl)		; $7ca6
	ret			; $7ca7
	call disableLcd		; $7ca8
	call loadScreenMusicAndSetRoomPack		; $7cab
	call loadAreaData		; $7cae
	call loadAreaGraphics		; $7cb1
	jp func_131f		; $7cb4
;;
; @addr{7cb7}
func_03_7cb7:
	ld a,(wCutsceneState)		; $7cb7
	rst_jumpTable			; $7cba
.dw $7cc9
.dw $7d14
.dw $7d3d
.dw $7d6b
.dw $7d95
.dw $7ddf
.dw $7e1f

	ld a,(wActiveMusic2)		; $7cc9
	ld (wActiveMusic),a		; $7ccc
	call playSound		; $7ccf
	ld hl,wTmpcbb3		; $7cd2
	ld b,$10		; $7cd5
	call clearMemory		; $7cd7
	call clearWramBank1		; $7cda
	call refreshObjectGfx		; $7cdd
	ld a,$01		; $7ce0
	ld (wDisabledObjects),a		; $7ce2
	ld (wMenuDisabled),a		; $7ce5
	ld a,$3c		; $7ce8
	ld (wTmpcbb4),a		; $7cea
	call $7c99		; $7ced
	ld hl,$d000		; $7cf0
	ld (hl),$03		; $7cf3
	ld l,$0b		; $7cf5
	ld (hl),$58		; $7cf7
	inc l			; $7cf9
	inc l			; $7cfa
	ld (hl),$78		; $7cfb
	ld l,$08		; $7cfd
	ld (hl),$02		; $7cff
	call resetCamera		; $7d01
	ld a,$00		; $7d04
	ld (wScrollMode),a		; $7d06
	ld hl,objectData.objectData7e85		; $7d09
	call parseGivenObjectData		; $7d0c
	ld a,$04		; $7d0f
	jp fadeinFromWhiteWithDelay		; $7d11
	ld a,(wTmpcbb5)		; $7d14
	cp $04			; $7d17
	ret nz			; $7d19
	call $7ca3		; $7d1a
	jr z,_label_03_185	; $7d1d
	ld a,(hl)		; $7d1f
	cp $01			; $7d20
	ret nz			; $7d22
	ld a,$0b		; $7d23
	ld (wLinkForceState),a		; $7d25
	ld a,$50		; $7d28
	ld (wLinkStateParameter),a		; $7d2a
	ld a,$10		; $7d2d
	ld ($d009),a		; $7d2f
	ret			; $7d32
_label_03_185:
	ld (hl),$10		; $7d33
	call $7c99		; $7d35
	ld a,$04		; $7d38
	jp fadeoutToWhiteWithDelay		; $7d3a
	ld a,(wPaletteThread_mode)		; $7d3d
	or a			; $7d40
	ret nz			; $7d41
	ld a,SNDCTRL_STOPMUSIC		; $7d42
	call playSound		; $7d44
	call $7c99		; $7d47
	ld a,$f3		; $7d4a
	ld (wActiveRoom),a		; $7d4c
	call $7ca8		; $7d4f
	ld hl,w1Link.yh		; $7d52
	ld (hl),$78		; $7d55
	inc l			; $7d57
	inc l			; $7d58
	ld (hl),$78		; $7d59
	call resetCamera		; $7d5b
	call loadCommonGraphics		; $7d5e
	ld a,$04		; $7d61
	call fadeinFromWhiteWithDelay		; $7d63
	ld a,$02		; $7d66
	jp loadGfxRegisterStateIndex		; $7d68
	ld a,$00		; $7d6b
	ld (wScrollMode),a		; $7d6d
	ld a,$f8		; $7d70
	ld (w1Link.yh),a		; $7d72
	ld a,$05		; $7d75
	ld (wTmpcbb5),a		; $7d77
	ld a,(wPaletteThread_mode)		; $7d7a
	or a			; $7d7d
	ret nz			; $7d7e
	call $7ca3		; $7d7f
	ret nz			; $7d82
	ld a,$0b		; $7d83
	ld (wLinkForceState),a		; $7d85
	ld a,$60		; $7d88
	ld (wLinkStateParameter),a		; $7d8a
	ld a,$10		; $7d8d
	ld ($d009),a		; $7d8f
	jp $7c99		; $7d92
	ld a,(wTmpcbb5)		; $7d95
	cp $06			; $7d98
	ret nz			; $7d9a
	call $7e40		; $7d9b
	ld a,(wScreenShakeCounterY)		; $7d9e
	dec a			; $7da1
	jr z,_label_03_188	; $7da2
	and $1f			; $7da4
	ret nz			; $7da6
	ld a,(w1Link.direction)		; $7da7
	ld c,a			; $7daa
	rra			; $7dab
	xor c			; $7dac
	bit 0,a			; $7dad
	ld a,c			; $7daf
	jr z,_label_03_186	; $7db0
	xor $01			; $7db2
	jr _label_03_187		; $7db4
_label_03_186:
	xor $02			; $7db6
_label_03_187:
	ld (w1Link.direction),a		; $7db8
	ret			; $7dbb
_label_03_188:
	call getFreeInteractionSlot		; $7dbc
	ret nz			; $7dbf
	ld (hl),$9f		; $7dc0
	ld l,$46		; $7dc2
	ld a,$1e		; $7dc4
	ld (hl),a		; $7dc6
	ld (wTmpcbb4),a		; $7dc7
	ld a,(w1Link.yh)		; $7dca
	sub $10			; $7dcd
	ld l,$4b		; $7dcf
	ldi (hl),a		; $7dd1
	inc l			; $7dd2
	ld a,(w1Link.xh)		; $7dd3
	ld (hl),a		; $7dd6
	ld a,SND_CLINK		; $7dd7
	call playSound		; $7dd9
	call $7c99		; $7ddc
	call $7e40		; $7ddf
	call $7ca3		; $7de2
	ret nz			; $7de5
	ld a,$0b		; $7de6
	ld (wLinkForceState),a		; $7de8
	ld a,$10		; $7deb
	ld (wLinkStateParameter),a		; $7ded
	ld hl,w1Link.direction		; $7df0
	ld a,$02		; $7df3
	ldi (hl),a		; $7df5
	ld (hl),$10		; $7df6
	ld a,$07		; $7df8
	ld (wTmpcbb5),a		; $7dfa
	xor a			; $7dfd
	ld ($cfde),a		; $7dfe
	call getFreeInteractionSlot		; $7e01
	ld (hl),$92		; $7e04
	ld l,$43		; $7e06
	ld (hl),$01		; $7e08
	call getFreeInteractionSlot		; $7e0a
	ld (hl),$2c		; $7e0d
	ld l,$4b		; $7e0f
	ld a,(w1Link.yh)		; $7e11
	add $10			; $7e14
	ldi (hl),a		; $7e16
	ld a,(w1Link.xh)		; $7e17
	inc l			; $7e1a
	ld (hl),a		; $7e1b
	jp $7c99		; $7e1c
	call $7e40		; $7e1f
	ld a,(wTmpcbb5)		; $7e22
	cp $08			; $7e25
	ret nz			; $7e27
	ld a,SNDCTRL_STOPMUSIC		; $7e28
	call playSound		; $7e2a
	xor a			; $7e2d
	ld (wActiveMusic),a		; $7e2e
	inc a			; $7e31
	ld (wCutsceneIndex),a		; $7e32
	ld hl,$7e3b		; $7e35
	jp setWarpDestVariables		; $7e38
	add l			; $7e3b
	rst_addAToHl			; $7e3c
	dec b			; $7e3d
	ld (hl),a		; $7e3e
	inc bc			; $7e3f
	ld a,(wScreenShakeCounterY)		; $7e40
	and $0f			; $7e43
	ld a,SND_RUMBLE		; $7e45
	call z,playSound		; $7e47
	ld a,(wScreenShakeCounterY)		; $7e4a
	or a			; $7e4d
	ld a,$ff		; $7e4e
	jp z,setScreenShakeCounter		; $7e50
	ret			; $7e53

.ifdef BUILD_VANILLA

; Garbage functions appear to follow (corrupted repeats of the above functions).

;;
; @addr{7e54}
func_7e54:
	ld a,$10		; $7e54
	ld (wLinkStateParameter),a		; $7e56
	ld hl,w1Link.direction		; $7e59
	ld a,$02		; $7e5c
	ldi (hl),a		; $7e5e
	ld (hl),$10		; $7e5f
	ld a,$07		; $7e61
	ld (wTmpcbb5),a		; $7e63
	xor a			; $7e66
	ld ($cfde),a		; $7e67
	call $3b46		; $7e6a
	ld (hl),$92		; $7e6d
	ld l,$43		; $7e6f
	ld (hl),$01		; $7e71
	call $3b46		; $7e73
	ld (hl),$2c		; $7e76
	ld l,$4b		; $7e78
	ld a,(w1Link.yh)		; $7e7a
	add $10			; $7e7d
	ldi (hl),a		; $7e7f
	ld a,(w1Link.xh)		; $7e80
	inc l			; $7e83
	ld (hl),a		; $7e84
	jp $7d02		; $7e85

;;
; @addr{7e88}
func_7e88:
	call $7ea9		; $7e88
	ld a,(wTmpcbb5)		; $7e8b
	cp $08			; $7e8e
	ret nz			; $7e90
	ld a,$f0		; $7e91
	call $0cb1		; $7e93
	xor a			; $7e96
	ld (wActiveMusic),a		; $7e97
	inc a			; $7e9a
	ld (wCutsceneIndex),a		; $7e9b
	ld hl,$7ea4		; $7e9e
	jp $19c5		; $7ea1

;;
; @addr{7ea4}
func_7ea4:
	add l			; $7ea4
	rst_addAToHl			; $7ea5
	dec b			; $7ea6
	ld (hl),a		; $7ea7
	inc bc			; $7ea8
	ld a,(wScreenShakeCounterY)		; $7ea9
	and $0f			; $7eac
	ld a,$b3		; $7eae
	call z,$0cb1		; $7eb0
	ld a,(wScreenShakeCounterY)		; $7eb3
	or a			; $7eb6
	ld a,$ff		; $7eb7
	jp z,$24f8		; $7eb9
	ret			; $7ebc

.endif

.BANK $04 SLOT 1
.ORG 0

.include "code/bank4.s"


; roomPacks must be in the same bank as groupMusicPointerTable, etc.
.include "build/data/roomPacks.s"


groupMusicPointerTable: ; 495c
	.dw group0Music
	.dw group1Music
	.dw group2Music
	.dw group3Music
	.dw group4Music
	.dw group5Music
	.dw group6Music
	.dw group7Music

group0Music:
	.incbin "audio/ages/group0IDs.bin"
group1Music:
	.incbin "audio/ages/group1IDs.bin"
group2Music:
	.incbin "audio/ages/group2IDs.bin"
group3Music:
	.incbin "audio/ages/group3IDs.bin"
group4Music:
group6Music:
	.incbin "audio/ages/group4IDs.bin"
group5Music:
group7Music:
	.incbin "audio/ages/group5IDs.bin"


; Format:
; First byte indicates whether it's a dungeon or not (and consequently what compression it uses)
; 3 byte pointer to a table containing relative offsets for room data for each sector on the map
; 3 byte pointer to the base offset of the actual layout data
roomLayoutGroupTable: ; $4f6c
	.db $01
	3BytePointer roomLayoutGroup0Table
	3BytePointer room0000
	.db $00

	.db $01
	3BytePointer roomLayoutGroup1Table
	3BytePointer room0100
	.db $00

	.db $01
	3BytePointer roomLayoutGroup2Table
	3BytePointer room0200
	.db $00

	.db $01
	3BytePointer roomLayoutGroup3Table
	3BytePointer room0300
	.db $00

	.db $00
	3BytePointer roomLayoutGroup4Table
	3BytePointer room0400
	.db $00

	.db $00
	3BytePointer roomLayoutGroup5Table
	3BytePointer room0500
	.db $00

.include "build/data/areas.s"
.include "build/data/areaMappings.s"


;;
; @addr{58e4}
initializeAnimations:
	ld a,(wAreaAnimation)		; $58e4
	cp $ff			; $58e7
	ret z			; $58e9

	call loadAnimationData		; $58ea
	call @locFunc		; $58ed
	ld hl,wAnimationState		; $58f0
	set 7,(hl)		; $58f3
	call @locFunc		; $58f5
	ld hl,wAnimationState		; $58f8
	set 7,(hl)		; $58fb
@locFunc:
	call updateAnimationData		; $58fd
-
	call updateAnimationQueue		; $5900
	jr nz, -
	ret			; $5905

;;
; @addr{5906}
updateAnimations:
	ld hl,wAnimationState		; $5906
	res 6,(hl)		; $5909
	ld a,(wAreaAnimation)		; $590b
	inc a			; $590e
	ret z			; $590f

	ld a,(wScrollMode)		; $5910
	and $01			; $5913
	ret z			; $5915

	call updateAnimationQueue		; $5916
	jr updateAnimationData		; $5919

;;
; Read the next index off of the animation queue, set zero flag if there's
; nothing more to be read.
; @addr{591b}
updateAnimationQueue:
	ld a,(wAnimationQueueHead)		; $591b
	ld b,a			; $591e
	ld a,(wAnimationQueueTail)		; $591f
	cp b			; $5922
	ret z			; $5923

	inc b			; $5924
	ld a,b			; $5925
	and $1f			; $5926
	ld (wAnimationQueueHead),a		; $5928
	ld hl,w2AnimationQueue		; $592b
	rst_addAToHl			; $592e
	ld a,:w2AnimationQueue
	ld ($ff00+R_SVBK),a	; $5931
	ld b,(hl)		; $5933
	xor a			; $5934
	ld ($ff00+R_SVBK),a	; $5935
	ld a,b			; $5937
	call loadAnimationGfxIndex		; $5938
	ld hl,wAnimationState		; $593b
	set 6,(hl)		; $593e
	or h			; $5940
	ret			; $5941

;;
; @addr{5942}
updateAnimationData:
	ld hl,wAnimationCounter1		; $5942
	ld a,(wAnimationState)		; $5945
	bit 0,a			; $5948
	call nz,updateAnimationDataPointer		; $594a
	ld hl,wAnimationCounter2		; $594d
	ld a,(wAnimationState)		; $5950
	bit 1,a			; $5953
	call nz,updateAnimationDataPointer		; $5955
	ld hl,wAnimationCounter3		; $5958
	ld a,(wAnimationState)		; $595b
	bit 2,a			; $595e
	call nz,updateAnimationDataPointer		; $5960
	ld hl,wAnimationCounter4		; $5963
	ld a,(wAnimationState)		; $5966
	bit 3,a			; $5969
	call nz,updateAnimationDataPointer		; $596b

	; Unset force update bit
	ld a,(wAnimationState)		; $596e
	and $7f			; $5971
	ld (wAnimationState),a		; $5973
	ret			; $5976

;;
; Update animation data pointed to by hl
; @addr{5977}
updateAnimationDataPointer:
	; If bit 7 set, force update
	ld a,(wAnimationState)		; $5977
	bit 7,a			; $597a
	jr nz, +

	; Otherwise, decrement counter
	dec (hl)		; $597e
	ret nz			; $597f
+
	; Load hl with a pointer to the animationData structure
	push hl			; $5980
	inc hl			; $5981
	ldi a,(hl)		; $5982
	ld h,(hl)		; $5983
	ld l,a			; $5984

	; e = animation gfx index
	ld e,(hl)		; $5985
	inc hl			; $5986
	; If next byte is 0xff, it jumps several bytes back, otherwise the data
	; structure continues
	ldi a,(hl)		; $5987
	cp $ff			; $5988
	jr nz, +
	ld b,a			; $598c
	ld c,(hl)		; $598d
	add hl,bc		; $598e
	ldi a,(hl)		; $598f
+
	ld c,l			; $5990
	ld b,h			; $5991
	pop hl			; $5992
	ldi (hl),a		; $5993
	ld (hl),c		; $5994
	inc hl			; $5995
	ld (hl),b		; $5996

	; Set animation index to be loaded
	ld b,e			; $5997
	ld a,(wAnimationQueueTail)		; $5998
	inc a			; $599b
	and $1f			; $599c
	ld e,a			; $599e
	ld a,(wAnimationQueueHead)		; $599f
	cp e			; $59a2
	ret z			; $59a3

	ld a,e			; $59a4
	ld (wAnimationQueueTail),a		; $59a5
	ld a,:w2AnimationQueue
	ld ($ff00+R_SVBK),a	; $59aa
	ld a,e			; $59ac
	ld hl,w2AnimationQueue		; $59ad
	rst_addAToHl			; $59b0
	ld (hl),b		; $59b1
	xor a			; $59b2
	ld ($ff00+R_SVBK),a	; $59b3
	or h			; $59b5
	ret			; $59b6

;;
; Load animation index a
; @addr{59b7}
loadAnimationGfxIndex:
	ld c,$06		; $59b7
	call multiplyAByC		; $59b9
	ld bc, animationGfxHeaders
	add hl,bc		; $59bf
	ldi a,(hl)		; $59c0
	ld c,a			; $59c1
	ldi a,(hl)		; $59c2
	ld d,a			; $59c3
	ldi a,(hl)		; $59c4
	ld e,a			; $59c5
	push de			; $59c6
	ldi a,(hl)		; $59c7
	ld d,a			; $59c8
	ldi a,(hl)		; $59c9
	ld e,a			; $59ca
	ld b,(hl)		; $59cb
	pop hl			; $59cc
	jp queueDmaTransfer		; $59cd

.include "build/data/uniqueGfxHeaders.s"
.include "build/data/uniqueGfxHeaderPointers.s"
.include "build/data/animationGroups.s"
.include "build/data/animationGfxHeaders.s"
.include "build/data/animationData.s"

;;
; @addr{5fef}
applyAllTileSubstitutions:
	call replacePollutionWithWaterIfPollutionFixed		; $5fef
	call applySingleTileChanges		; $5ff2
	call applyStandardTileSubstitutions		; $5ff5
	call replaceOpenedChest		; $5ff8
	ld a,(wActiveGroup)		; $5ffb
	and $06			; $5ffe
	cp NUM_SMALL_GROUPS		; $6000
	jr nz,+			; $6002

	call replaceShutterForLinkEntering		; $6004
	call replaceSwitchTiles		; $6007
	call replaceToggleBlocks		; $600a
	call replaceJabuTilesIfUnderwater		; $600d
+
	call applyRoomSpecificTileChanges		; $6010
	ld a,(wActiveGroup)		; $6013
	cp $02			; $6016
	ret nc			; $6018

	; In the overworld

	call replaceBreakableTileOverPortal		; $6019
	call replaceBreakableTileOverLinkTimeWarpingIn		; $601c
	ld a,(wLinkTimeWarpTile)		; $601f
	or a			; $6022
	ret z			; $6023

	; If link was sent back from trying to travel through time, clear the
	; breakable tile at his position (if it exists) so he can safely
	; return.

	ld c,a			; $6024
	dec c			; $6025
	ld b,>wRoomLayout		; $6026
	ld a,(bc)		; $6028
	ld e,a			; $6029
	ld hl,@tileReplacementDict		; $602a
	call lookupKey		; $602d
	ret nc			; $6030

	ld (bc),a		; $6031
	ret			; $6032

@tileReplacementDict:
	.db $c0 $3a ; Rocks
	.db $c3 $3a
	.db $c5 $3a ; Bushes
	.db $c8 $3a
	.db $ce $3a ; Burnable bush
	.db $db $3a ; Switchhook diamond
	.db $f2 $3a ; Sign
	.db $cd $3a ; Dirt
	.db $04 $3a ; Flowers (in some areas)
	.db $00

;;
; @addr{6046}
replaceBreakableTileOverPortal:
	ld hl,wPortalGroup		; $6046
	ld a,(wActiveGroup)		; $6049
	cp (hl)			; $604c
	ret nz			; $604d

	inc l			; $604e
	ld a,(wActiveRoom)		; $604f
	cp (hl)			; $6052
	ret nz			; $6053

	inc l			; $6054
	ld c,(hl)		; $6055
_removeBreakableTileForTimeWarp:
	ld b,>wRoomLayout		; $6056
	ld a,(bc)		; $6058
	ld e,a			; $6059
	ld hl,@tileReplacementDict		; $605a
	call lookupKey		; $605d
	ret nc			; $6060

	ld (bc),a		; $6061
	ret			; $6062

; @addr{6063}
@tileReplacementDict:
	.db $c5 $3a
	.db $c8 $3a
	.db $04 $3a
	.db $00

;;
; @addr{606a}
replaceBreakableTileOverLinkTimeWarpingIn:
	ld a,(wWarpTransition)		; $606a
	and $0f			; $606d
	cp TRANSITION_DEST_TIMEWARP		; $606f
	ret nz			; $6071

	ld a,(wWarpDestPos)		; $6072
	ld c,a			; $6075
	jr _removeBreakableTileForTimeWarp		; $6076

;;
; @addr{6078}
replacePollutionWithWaterIfPollutionFixed:
	ld a,GLOBALFLAG_WATER_POLLUTION_FIXED		; $6078
	call checkGlobalFlag		; $607a
	ret z			; $607d

	ld a,(wAreaFlags)		; $607e
	bit AREAFLAG_BIT_OUTDOORS,a			; $6081
	ret z			; $6083

	ld de,@aboveWaterReplacement		; $6084
	and AREAFLAG_UNDERWATER		; $6087
	jr z,+			; $6089
	ld de,@belowWaterReplacement		; $608b
+
	jr replaceTiles		; $608e

; @addr{6090}
@aboveWaterReplacement:
	.db $fc $eb
	.db $00
; @addr{6093}
@belowWaterReplacement:
	.db $3b $eb
	.db $00

;;
; @param de Structure for tiles to replace
; (format: tile to replace with, tile to replace, repeat, $00 to end)
; @addr{6096}
replaceTiles:
	ld a,(de)		; $6096
	or a			; $6097
	ret z			; $6098

	ld b,a			; $6099
	inc de			; $609a
	ld a,(de)		; $609b
	inc de			; $609c
	call findTileInRoom		; $609d
	jr nz,replaceTiles	; $60a0

	ld (hl),b		; $60a2
	ld c,a			; $60a3
	ld a,l			; $60a4
	or a			; $60a5
	jr z,replaceTiles	; $60a6
--
	dec l			; $60a8
	ld a,c			; $60a9
	call backwardsSearch		; $60aa
	jr nz,replaceTiles	; $60ad

	ld (hl),b		; $60af
	ld c,a			; $60b0
	ld a,l			; $60b1
	or a			; $60b2
	jr z,replaceTiles	; $60b3
	jr --			; $60b5

;;
; Substitutes various tiles when particular room flag bits (0-3, 7) are set.
; @addr{60b7}
applyStandardTileSubstitutions:
	call getThisRoomFlags		; $60b7
	ldh (<hFF8B),a	; $60ba
	ld hl,@bit0		; $60bc
	bit 0,a			; $60bf
	call nz,@locFunc		; $60c1

	ld hl,@bit1		; $60c4
	ldh a,(<hFF8B)	; $60c7
	bit 1,a			; $60c9
	call nz,@locFunc		; $60cb

	ld hl,@bit2		; $60ce
	ldh a,(<hFF8B)	; $60d1
	bit 2,a			; $60d3
	call nz,@locFunc		; $60d5

	ld hl,@bit3		; $60d8
	ldh a,(<hFF8B)	; $60db
	bit 3,a			; $60dd
	call nz,@locFunc		; $60df

	ld hl,@bit7		; $60e2
	ldh a,(<hFF8B)	; $60e5
	bit 7,a			; $60e7
	ret z			; $60e9
@locFunc:
	ld a,(wActiveCollisions)		; $60ea
	rst_addDoubleIndex			; $60ed
	ldi a,(hl)		; $60ee
	ld h,(hl)		; $60ef
	ld l,a			; $60f0
	ld e,l			; $60f1
	ld d,h			; $60f2
	jr replaceTiles			; $60f3

; @addr{60f5}
@bit0:
	.dw @bit0Collisions0
	.dw @bit0Collisions1
	.dw @bit0Collisions2
	.dw @bit0Collisions3
	.dw @bit0Collisions4
	.dw @bit0Collisions5
; @addr{6101}
@bit1:
	.dw @bit1Collisions0
	.dw @bit1Collisions1
	.dw @bit1Collisions2
	.dw @bit1Collisions3
	.dw @bit1Collisions4
	.dw @bit1Collisions5
; @addr{610d}
@bit2:
	.dw @bit2Collisions0
	.dw @bit2Collisions1
	.dw @bit2Collisions2
	.dw @bit2Collisions3
	.dw @bit2Collisions4
	.dw @bit2Collisions5
; @addr{6119}
@bit3:
	.dw @bit3Collisions0
	.dw @bit3Collisions1
	.dw @bit3Collisions2
	.dw @bit3Collisions3
	.dw @bit3Collisions4
	.dw @bit3Collisions5
; @addr{6125}
@bit7:
	.dw @bit7Collisions0
	.dw @bit7Collisions1
	.dw @bit7Collisions2
	.dw @bit7Collisions3
	.dw @bit7Collisions4
	.dw @bit7Collisions5

@bit0Collisions0:
@bit0Collisions4:
@bit0Collisions5:
	.db $00
@bit0Collisions1:
@bit0Collisions2:
	.db $34 $30 ; Bombable walls, key doors (up)
	.db $34 $38
	.db $a0 $70
	.db $a0 $74
	.db $00
@bit0Collisions3:
	.db $00

@bit1Collisions0:
@bit1Collisions4:
@bit1Collisions5:
	.db $00
@bit1Collisions1:
@bit1Collisions2:
	.db $35 $31 ; Bombable walls, key doors (right)
	.db $35 $39
	.db $35 $68
	.db $a0 $71
	.db $a0 $75
@bit1Collisions3:
	.db $00

@bit2Collisions0:
@bit2Collisions5:
@bit2Collisions4:
	.db $00
@bit2Collisions1:
@bit2Collisions2:
	.db $36 $32 ; Bombable walls, key doors (down)
	.db $36 $3a
	.db $a0 $72
	.db $a0 $76
@bit2Collisions3:
	.db $00

@bit3Collisions0:
@bit3Collisions4:
@bit3Collisions5:
	.db $00
@bit3Collisions1:
@bit3Collisions2:
	.db $37 $33 ; Bombable walls, key doors (left)
	.db $37 $3b
	.db $37 $69
	.db $a0 $73
	.db $a0 $77
@bit3Collisions3:
	.db $00

@bit7Collisions0:
	.db $dd $c1 ; Cave door under rock? (Is this a bug?)
	.db $d2 $c2 ; Soil under rock
	.db $d7 $c4 ; Portal under rock
	.db $dc $c6 ; Grave pushed onto land
	.db $d2 $c7 ; Soil under bush
	.db $d7 $c9 ; Soil under bush
	.db $d2 $cb ; Soil under earth
	.db $dc $cf ; Stairs under burnable tree
	.db $dd $d1 ; Bombable cave door
@bit7Collisions1:
	.db $00
@bit7Collisions2:
	.db $a0 $1e ; Keyblock
	.db $44 $42 ; Appearing upward stairs
	.db $45 $43 ; Appearing downward stairs
	.db $46 $40 ; Appearing upward stairs in wall
	.db $47 $41 ; Appearing downward stairs in wall
@bit7Collisions3:
@bit7Collisions4:
@bit7Collisions5:
	.db $00

;;
; Updates the toggleable blocks to the correct state when loading a room.
; @addr{617c}
replaceToggleBlocks:
	call checkDungeonUsesToggleBlocks		; $617c
	ret z			; $617f

	callab bank2.func_02_7a77		; $6180
	ld de,@state1		; $6188
	ld a,(wToggleBlocksState)		; $618b
	or a			; $618e
	jr nz,+			; $618f
	ld de,@state2		; $6191
+
	jp replaceTiles		; $6194

; @addr{6197}
@state1:
	.db $0f $29
	.db $28 $0e
	.db $00
; @addr{619c}
@state2:
	.db $0e $28
	.db $29 $0f
	.db $00

;;
; Does the necessary tile changes if underwater in jabu-jabu.
; @addr{61a1}
replaceJabuTilesIfUnderwater:
	ld a,(wDungeonIndex)		; $61a1
	cp $07			; $61a4
	ret nz			; $61a6

	ld a,(wAreaFlags)		; $61a7
	and AREAFLAG_SIDESCROLL			; $61aa
	ret nz			; $61ac

	; Only substitute tiles if on the first non-underwater floor
	ld a,(wDungeonFloor)		; $61ad
	ld b,a			; $61b0
	ld a,(wJabuWaterLevel)		; $61b1
	and $07			; $61b4
	cp b			; $61b6
	ret nz			; $61b7

	ld de,@data1		; $61b8
	call replaceTiles		; $61bb
	ld de,@data2		; $61be
	jp replaceTiles		; $61c1

; @addr{61c4}
@data1:
	.db $fa $f3 ; holes -> shallow water
	.db $fa $f4
	.db $fa $f5
	.db $fa $f6
	.db $fa $f7
	.db $00

; @addr{61cf}
@data2:
	.db $fc $48 ; floor-transfer holes -> deep water
	.db $fc $49
	.db $fc $4a
	.db $fc $4b
	.db $00

;;
; Replaces a shutter link is about to walk on to with empty floor.
; @addr{61d8}
replaceShutterForLinkEntering:
	ldbc >wRoomLayout, (LARGE_ROOM_HEIGHT-1)<<4 + (LARGE_ROOM_WIDTH-1)	; $61d8
--
	ld a,(bc)		; $61db
	push bc			; $61dc
	sub $78			; $61dd
	cp $08			; $61df
	call c,@temporarilyOpenDoor		; $61e1
	pop bc			; $61e4
	dec c			; $61e5
	jr nz,--		; $61e6
	ret			; $61e8

; Replaces a door at position bc with empty floor, and adds an interaction to
; re-close it when link moves away (for minecart doors only)
@temporarilyOpenDoor:
	ld de,@shutterData		; $61e9
	call addDoubleIndexToDe		; $61ec
	ld a,(de)		; $61ef
	ldh (<hFF8B),a	; $61f0
	inc de			; $61f2
	ld a,(de)		; $61f3
	ld e,a			; $61f4
	ld a,(wScrollMode)		; $61f5
	and $08			; $61f8
	jr z,@doneReplacement	; $61fa

	ld a,(wLinkObjectIndex)		; $61fc
	ld h,a			; $61ff
	ld a,(wScreenTransitionDirection)		; $6200
	xor $02			; $6203
	ld d,a			; $6205
	ld a,e			; $6206
	and $03			; $6207
	cp d			; $6209
	ret nz			; $620a

	ld a,(wScreenTransitionDirection)		; $620b
	bit 0,a			; $620e
	jr nz,@horizontal			; $6210
; vertical
	and $02			; $6212
	ld l,<w1Link.xh		; $6214
	ld a,(hl)		; $6216
	jr nz,@down		; $6217
@up:
	and $f0			; $6219
	swap a			; $621b
	or $a0			; $621d
	jr @doReplacement		; $621f
@down:
	and $f0			; $6221
	swap a			; $6223
	jr @doReplacement		; $6225

@horizontal:
	and $02			; $6227
	ld l,<w1Link.yh		; $6229
	ld a,(hl)		; $622b
	jr nz,@left	; $622c
@right:
	and $f0			; $622e
	jr @doReplacement		; $6230
@left:
	and $f0			; $6232
	or $0e			; $6234

@doReplacement:
	; Only replace if link is standing on the tile.
	cp c			; $6236
	jr nz,@doneReplacement	; $6237

	push bc			; $6239
	ld c,a			; $623a
	ld a,(bc)		; $623b
	sub $78			; $623c
	cp $08			; $623e
	jr nc,+			; $6240

	ldh a,(<hFF8B)	; $6242
	ld (bc),a		; $6244
+
	pop bc			; $6245

@doneReplacement:
	; If bit 7 is set, don't add an auto-shutter interaction.
	ld a,e			; $6246
	bit 7,a			; $6247
	ret nz			; $6249

	and $7f			; $624a
	ld e,a			; $624c

	; If not in a dungeon, don't add an auto-shutter.
	ld a,(wAreaFlags)		; $624d
	bit AREAFLAG_BIT_DUNGEON,a			; $6250
	ret z			; $6252

	call getFreeInteractionSlot		; $6253
	ret nz			; $6256

	ld (hl),$1e		; $6257
	inc l			; $6259
	ld (hl),e		; $625a
	ld l,Interaction.yh		; $625b
	ld (hl),c		; $625d
	ret			; $625e

; Data format:
; Byte 1 - tile to replace shutter with
; Byte 2 - bit 7: don't auto-close, bits 0-6: low byte of interaction id
; @addr{625f}
@shutterData:
	.db $a0 $80 ; Normal shutters
	.db $a0 $81
	.db $a0 $82
	.db $a0 $83
	.db $5e $0c ; Minecart shutters
	.db $5d $0d
	.db $5e $0e
	.db $5d $0f

;;
; @addr{626f}
replaceOpenedChest:
	call getThisRoomFlags		; $626f
	bit ROOMFLAG_BIT_ITEM,a			; $6272
	ret z			; $6274

	call getChestData		; $6275
	ld d,>wRoomLayout		; $6278
	ld a,TILEINDEX_CHEST_OPENED	; $627a
	ld (de),a		; $627c
	ret			; $627d

;;
; Replaces switch tiles and whatever they control if the switch is set.
; Groups 4 and 5 only.
; @addr{627e}
replaceSwitchTiles:
	ld hl,@group4SwitchData		; $627e
	ld a,(wActiveGroup)		; $6281
	sub NUM_SMALL_GROUPS			; $6284
	jr z,+			; $6286

	dec a			; $6288
	ret nz			; $6289

	ld hl,@group5SwitchData		; $628a
+
	ld a,(wActiveRoom)		; $628d
	ld b,a			; $6290
	ld a,(wSwitchState)		; $6291
	ld c,a			; $6294
	ld d,>wRoomLayout		; $6295
@next:
	ldi a,(hl)		; $6297
	or a			; $6298
	ret z			; $6299

	; Check room
	cp b			; $629a
	jr nz,@skip3Bytes	; $629b

	; Check if corresponding bit of wSwitchState is set
	ldi a,(hl)		; $629d
	and c			; $629e
	jr z,@skip2Bytes	; $629f

	ldi a,(hl)		; $62a1
	ld e,(hl)		; $62a2
	inc hl			; $62a3
	ld (de),a		; $62a4
	jr @next		; $62a5

@skip3Bytes:
	inc hl			; $62a7
@skip2Bytes:
	inc hl			; $62a8
	inc hl			; $62a9
	jr @next		; $62aa

; Data format:
; Room, Switch bit, new tile index, position of tile to replace

; @addr{62ac}
@group4SwitchData:
	.db $2f $02 $0b $79
	.db $2f $02 $5a $6c
	.db $3b $20 $af $79
	.db $4c $01 $0b $38
	.db $4e $02 $0b $68
	.db $53 $04 $0b $6a
	.db $72 $01 $af $8d
	.db $89 $04 $0b $62
	.db $89 $04 $5d $67
	.db $8f $08 $0b $81
	.db $8f $08 $5e $52
	.db $c7 $01 $0b $68
	.db $00

; @addr{62dd}
@group5SwitchData:
	.db $00

;;
; @addr{62de}
applySingleTileChanges:
	ld a,(wActiveRoom)		; $62de
	ld b,a			; $62e1
	call getThisRoomFlags		; $62e2
	ld c,a			; $62e5
	ld d,>wRoomLayout		; $62e6
	ld a,(wActiveGroup)		; $62e8
	ld hl,singleTileChangeGroupTable		; $62eb
	rst_addDoubleIndex			; $62ee
	ldi a,(hl)		; $62ef
	ld h,(hl)		; $62f0
	ld l,a			; $62f1
@next:
	; Check room
	ldi a,(hl)		; $62f2
	cp b			; $62f3
	jr nz,@notMatch		; $62f4

	ld a,(hl)		; $62f6
	cp $f0			; $62f7
	jr z,@unlinkedOnly	; $62f9

	cp $f1			; $62fb
	jr z,@linkedOnly	; $62fd

	cp $f2			; $62ff
	jr z,@finishedGameOnly	; $6301

	ld a,(hl)		; $6303
	and c			; $6304
	jr z,@notMatch		; $6305

@match:
	inc hl			; $6307
	ldi a,(hl)		; $6308
	ld e,a			; $6309
	ldi a,(hl)		; $630a
	ld (de),a		; $630b
	jr @next		; $630c

@notMatch:
	ld a,(hl)		; $630e
	or a			; $630f
	ret z			; $6310

	inc hl			; $6311
	inc hl			; $6312
	inc hl			; $6313
	jr @next		; $6314

@unlinkedOnly:
	call checkIsLinkedGame		; $6316
	jr nz,@notMatch		; $6319
	jr @match			; $631b

@linkedOnly:
	call checkIsLinkedGame		; $631d
	jr z,@notMatch		; $6320
	jr @match			; $6322

@finishedGameOnly:
	ld a,GLOBALFLAG_FINISHEDGAME		; $6324
	push hl			; $6326
	call checkGlobalFlag		; $6327
	pop hl			; $632a
	ret z			; $632b
	jr @match		; $632c

.include "data/singleTileChanges.s"

;;
; @addr{642c}
applyRoomSpecificTileChanges:
	ld a,(wActiveRoom)		; $642c
	ld hl,roomTileChangerCodeGroupTable		; $642f
	call findRoomSpecificData		; $6432
	ret nc			; $6435
	rst_jumpTable			; $6436
	.dw tileReplacement_group5Mapf5 ; $00
	.dw tileReplacement_group4Map1b ; $01
	.dw tileReplacement_group2Map7e ; $02
	.dw tileReplacement_group4Map4c ; $03
	.dw tileReplacement_group4Map4e ; $04
	.dw tileReplacement_group4Map59 ; $05
	.dw tileReplacement_group4Map60 ; $06
	.dw tileReplacement_group4Map52 ; $07
	.dw tileReplacement_group0Map38 ; $08
	.dw tileReplacement_group1Map38 ; $09
	.dw tileReplacement_group5Map38 ; $0a
	.dw tileReplacement_group5Map25 ; $0b
	.dw tileReplacement_group5Map43 ; $0c
	.dw tileReplacement_group5Map4c ; $0d
	.dw tileReplacement_group5Map5c ; $0e
	.dw tileReplacement_group5Map4d ; $0f
	.dw tileReplacement_group5Map5d ; $10
	.dw tileReplacement_group7Map4a ; $11
	.dw tileReplacement_group5Map95 ; $12
	.dw tileReplacement_group5Mapc3 ; $13
	.dw tileReplacement_group0Map5c ; $14
	.dw tileReplacement_group2Mapf7 ; $15
	.dw tileReplacement_group0Map73 ; $16
	.dw tileReplacement_group0Map48 ; $17
	.dw tileReplacement_group0Mapac ; $18
	.dw tileReplacement_group0Map2c ; $19
	.dw tileReplacement_group0Map1c ; $1a
	.dw tileReplacement_group0Mapba ; $1b
	.dw tileReplacement_group0Mapaa ; $1c
	.dw tileReplacement_group0Mapcc ; $1d
	.dw tileReplacement_group0Mapbc ; $1e
	.dw tileReplacement_group0Mapda ; $1f
	.dw tileReplacement_group0Mapca ; $20
	.dw tileReplacement_group0Map61 ; $21
	.dw tileReplacement_group0Map51 ; $22
	.dw tileReplacement_group0Map54 ; $23
	.dw tileReplacement_group0Map25 ; $24
	.dw tileReplacement_group0Map3a ; $25
	.dw tileReplacement_group0Map0b ; $26
	.dw tileReplacement_group5Mapb9 ; $27
	.dw tileReplacement_group1Map27 ; $28
	.dw tileReplacement_group5Mapc2 ; $29
	.dw tileReplacement_group5Mape3 ; $2a
	.dw tileReplacement_group2Map90 ; $2b
	.dw tileReplacement_group1Map8c ; $2c
	.dw tileReplacement_group4Mapc7 ; $2d
	.dw tileReplacement_group4Mapc9 ; $2e
	.dw tileReplacement_group2Map9e ; $2f
	.dw tileReplacement_group0Mape0 ; $30
	.dw tileReplacement_group0Mape1 ; $31
	.dw tileReplacement_group0Mape2 ; $32
	.dw tileReplacement_group4Mapea ; $33
	.dw tileReplacement_group1Map58 ; $34
	.dw tileReplacement_group0Map98 ; $35
	.dw tileReplacement_group0Map76 ; $36
	.dw tileReplacement_group0Mapa5 ; $37

; @addr{$124a7}
roomTileChangerCodeGroupTable:
	.dw roomTileChangerCodeGroup0Data
	.dw roomTileChangerCodeGroup1Data
	.dw roomTileChangerCodeGroup2Data
	.dw roomTileChangerCodeGroup3Data
	.dw roomTileChangerCodeGroup4Data
	.dw roomTileChangerCodeGroup5Data
	.dw roomTileChangerCodeGroup6Data
	.dw roomTileChangerCodeGroup7Data

; @addr{$124b7}
roomTileChangerCodeGroup0Data:
	.db $38 $08
	.db $48 $17
	.db $5c $14
	.db $73 $16
	.db $ac $18
	.db $2c $19
	.db $1c $1a
	.db $ba $1b
	.db $aa $1c
	.db $cc $1d
	.db $bc $1e
	.db $da $1f
	.db $ca $20
	.db $61 $21
	.db $51 $22
	.db $54 $23
	.db $25 $24
	.db $3a $25
	.db $0b $26
	.db $e0 $30
	.db $e1 $31
	.db $e2 $32
	.db $98 $35
	.db $a5 $37
	.db $76 $36
	.db $00
; @addr{$124ea}
roomTileChangerCodeGroup1Data:
	.db $38 $09
	.db $27 $28
	.db $8c $2c
	.db $58 $34
	.db $00
; @addr{$124f3}
roomTileChangerCodeGroup2Data:
	.db $f7 $15
	.db $90 $2b
	.db $9e $2f
	.db $7e $02
	.db $00
; @addr{$124fc}
roomTileChangerCodeGroup3Data:
	.db $00
; @addr{$124fd}
roomTileChangerCodeGroup4Data:
	.db $1b $01
	.db $4c $03
	.db $4e $04
	.db $59 $05
	.db $60 $06
	.db $52 $07
	.db $c7 $2d
	.db $c9 $2e
	.db $ea $33
	.db $00
; @addr{$12510}
roomTileChangerCodeGroup5Data:
	.db $f5 $00
	.db $38 $0a
	.db $25 $0b
	.db $43 $0c
	.db $4c $0d
	.db $5c $0e
	.db $71 $0e
	.db $4d $0f
	.db $5d $10
	.db $72 $10
	.db $95 $12
	.db $c3 $13
	.db $b9 $27
	.db $c2 $29
	.db $e3 $2a
	.db $00
; @addr{$1252f}
roomTileChangerCodeGroup6Data:
	.db $00
; @addr{$12530}
roomTileChangerCodeGroup7Data:
	.db $4a $11
	.db $00

;;
; Opens advance shop
; @addr{6533}
tileReplacement_group1Map58:
	ldh a,(<hGameboyType)	; $6533
	rlca			; $6535
	ret nc			; $6536
	ld hl,wRoomLayout + $35		; $6537
	ld (hl),$de		; $653a
	ret			; $653c

;;
; Twinrova/ganon fight
; @addr{653d}
tileReplacement_group5Mapf5:
	ld a,(wTwinrovaTileReplacementMode)		; $653d
	or a			; $6540
	ret z			; $6541
	dec a			; $6542
	jr z,@val01		; $6543
	dec a			; $6545
	jr z,@fillWithIce		; $6546
	dec a			; $6548
	jr z,@val03		; $6549

	; Fill the room with the seizure tiles?
	xor a			; $654b
	ld (wTwinrovaTileReplacementMode),a		; $654c
	ld hl,@seizureTiles		; $654f
	jp fillRectInRoomLayout		; $6552

; @addr{6555}
@seizureTiles:
	.db $00, LARGE_ROOM_HEIGHT, LARGE_ROOM_WIDTH, $aa

@val03:
	ld (wTwinrovaTileReplacementMode),a		; $6559
	ld a,GFXH_b9		; $655c
	jp loadGfxHeader		; $655e

@fillWithIce:
	ld (wTwinrovaTileReplacementMode),a		; $6561
	ld hl,@iceTiles		; $6564
	jp fillRectInRoomLayout		; $6567

@iceTiles:
	.db $11, LARGE_ROOM_HEIGHT-2, LARGE_ROOM_WIDTH-2, $8a

@val01:
	ld (wTwinrovaTileReplacementMode),a		; $656e
	ld a,GFXH_b8		; $6571
	jp loadGfxHeader		; $6573

;;
; Dungeon 1 in the room where torches light up to make stairs appear
; @addr{6576}
tileReplacement_group4Map1b:
	call getThisRoomFlags		; $6576
	and $80			; $6579
	ret z			; $657b

	ld hl,wRoomLayout + $1a		; $657c
	ld a,TILEINDEX_LIT_TORCH		; $657f
	ldi (hl),a		; $6581
	inc l			; $6582
	ld (hl),a		; $6583

	; The programmers forgot a "ret" here! This causes a bug where chests
	; are inserted into dungeon 1 after buying everything from the secret
	; shop.

;;
; Secret shop: replace item area with blank floor and 2 chests, if you've
; already bought everything.
; @addr{6584}
tileReplacement_group2Map7e:
	ld a,(wBoughtShopItems1)		; $6584
	and $0f			; $6587
	cp $0f			; $6589
	ret nz			; $658b

	ld hl,@data		; $658c
	call fillRectInRoomLayout		; $658f
	ld a,TILEINDEX_CHEST		; $6592
	ld hl,wRoomLayout + $25		; $6594
	ld (hl),a		; $6597
	ld l,$27		; $6598
	ld (hl),a		; $659a
	ld l,$32		; $659b
	ld (hl),$a0		; $659d
	ret			; $659f

@data:
	.db $13 $03 $06 $a0

;;
; Hero's cave: make a bridge appear
; @addr{65a4}
tileReplacement_group4Mapc9:
	call getThisRoomFlags		; $65a4
	and ROOMFLAG_40			; $65a7
	ret z			; $65a9

	ld hl,wRoomLayout + $27		; $65aa
	ld a,$6d		; $65ad
	jp set4Bytes		; $65af

;;
; Hero's cave: make a bridge appear, make another disappear if a switch is set
; @addr{65b2}
tileReplacement_group4Mapc7:
	ld hl,wSwitchState		; $65b2
	bit 0,(hl)		; $65b5
	ret nz			; $65b7

	ld hl,wRoomLayout + $27		; $65b8
	ld a,$6d		; $65bb
	call set4Bytes		; $65bd
	ld a,$f4		; $65c0
	ld l,$3d		; $65c2
	ld (hl),a		; $65c4
	ld l,$4d		; $65c5
	ld (hl),a		; $65c7
	ld l,$5d		; $65c8
	ld (hl),a		; $65ca
	ld l,$6d		; $65cb
	ld (hl),a		; $65cd
	ret			; $65ce

;;
; D3, left of miniboss: deal with bridges
; @addr{65cf}
tileReplacement_group4Map4c:
	ld hl,wSwitchState		; $65cf
	bit 0,(hl)		; $65d2
	ret nz			; $65d4

	ld hl,wRoomLayout + $43		; $65d5
	ld a,$6a		; $65d8
	ld (hl),a		; $65da
	ld l,$53		; $65db
	ld (hl),a		; $65dd
	ld l,$63		; $65de
	ld (hl),a		; $65e0
	ld l,$76		; $65e1
	ld a,$f4		; $65e3
	jp set4Bytes		; $65e5

;;
; D3, left, down from miniboss: deal with bridges
; @addr{65e8}
tileReplacement_group4Map4e:
	ld hl,wSwitchState		; $65e8
	bit 1,(hl)		; $65eb
	ret z			; $65ed

	ld hl,wRoomLayout + $36		; $65ee
	ld a,$6d		; $65f1
	call set4Bytes		; $65f3
	ld a,$f4		; $65f6
	ld l,$42		; $65f8
	ld (hl),a		; $65fa
	ld l,$52		; $65fb
	ld (hl),a		; $65fd
	ld l,$62		; $65fe
	ld (hl),a		; $6600
	ld l,$4c		; $6601
	ld (hl),a		; $6603
	ld l,$5c		; $6604
	ld (hl),a		; $6606
	ld l,$6c		; $6607
	ld (hl),a		; $6609
	ret			; $660a

;;
; D3, right of seed shooter room: set torch lit
; @addr{660b}
tileReplacement_group4Map59:
	call getThisRoomFlags		; $660b
	and $80			; $660e
	ret z			; $6610

	ld de,@replacementTiles		; $6611
	jp replaceTiles		; $6614

; @addr{6617}
@replacementTiles:
	.db $09 $08 ; Replace unlit torch with lit
	.db $00

;;
; D3, upper spinner room: remove spinner if crystals broken (doesn't remove
; interaction itself)
; @addr{661a}
tileReplacement_group4Map60:
	ld a,GLOBALFLAG_D3_CRYSTALS		; $661a
	call checkGlobalFlag		; $661c
	ret z			; $661f

	ld hl,@rect		; $6620
	call fillRectInRoomLayout		; $6623
	call getThisRoomFlags		; $6626
	and ROOMFLAG_ITEM			; $6629
	ld a,TILEINDEX_CHEST_OPENED	; $662b
	jr nz,+			; $662d
	inc a			; $662f
+
	ld hl,wRoomLayout + $57		; $6630
	ld (hl),a		; $6633
	ld l,$34		; $6634
	ld (hl),$1d		; $6636
	ld l,$3a		; $6638
	ld (hl),$1d		; $663a
	ld l,$74		; $663c
	ld (hl),$1d		; $663e
	ld l,$7a		; $6640
	ld (hl),$1d		; $6642
	ret			; $6644
; @addr{6645}
@rect:
	.db $34 $05 $07 $a0

;;
; D3, lower spinner room: add spinner if crystals broken (doesn't add
; interaction itself)
; @addr{6649}
tileReplacement_group4Map52:
	ld a,GLOBALFLAG_D3_CRYSTALS		; $6649
	call checkGlobalFlag		; $664b
	ret z			; $664e

	; Load the room above instead of this room
	ld a,$60		; $664f
	ld (wLoadingRoom),a		; $6651
	callab loadRoomLayout		; $6654
	ret			; $665c

;;
; Maku tree present
; @addr{665d}
tileReplacement_group0Map38:
	ld a,GLOBALFLAG_MAKU_TREE_SAVED		; $665d
	call checkGlobalFlag		; $665f
	ret z			; $6662
	jr +			; $6663
;;
; Maku tree past
; @addr{6665}
tileReplacement_group1Map38:
	call getThisRoomFlags		; $6665
	bit 7,(hl)		; $6668
	ret z			; $666a
+
	; Clear barrier
	ld hl,wRoomLayout + $73		; $666b
	ld a,$f9		; $666e
	jp set4Bytes		; $6670

;;
; Present: Screen below maku tree
; @addr{6673}
tileReplacement_group0Map48:
	ld a,GLOBALFLAG_MAKU_TREE_SAVED		; $6673
	call checkGlobalFlag		; $6675
	ret z			; $6678

	; Clear barrier
	ld hl,wRoomLayout + $03		; $6679
	ld a,$3a		; $667c
	jp set4Bytes		; $667e

;;
; D6 before boss room: create bridge
; @addr{6681}
tileReplacement_group5Map38:
	call getThisRoomFlags		; $6681
	and ROOMFLAG_40			; $6684
	ret z			; $6686

	ld a,$6a		; $6687
	ld hl,wRoomLayout + $39		; $6689
	ld (hl),a		; $668c
	ld l,$49		; $668d
	ld (hl),a		; $668f
	ld l,$59		; $6690
	ld (hl),a		; $6692
	ld l,$69		; $6693
	ld (hl),a		; $6695
	ret			; $6696

;;
; D6 present: screen with retracting wall
; @addr{6697}
tileReplacement_group5Map25:
	call getThisRoomFlags		; $6697
	and $40			; $669a
	ret nz			; $669c

	ld hl,_d6RetractingWallRectPresent		; $669d
	call fillRectInRoomLayout		; $66a0
	jr ++			; $66a3

; @addr{66a5}
_d6RetractingWallRectPresent:
	.db $17 $09 $04 $a6
; @addr{66a9}
_d6RetractingWallRectPast:
	.db $17 $09 $04 $a7

;;
; D6 past: screen with retracting walls
; @addr{66ad}
tileReplacement_group5Map43:
	call getThisRoomFlags		; $66ad
	and $40			; $66b0
	jr nz,@pastRetracted		; $66b2

	ld hl,_d6RetractingWallRectPast		; $66b4
	call fillRectInRoomLayout		; $66b7
++
	ld hl,@wallEdge1		; $66ba
	call fillRectInRoomLayout		; $66bd
	ld hl,@wallEdge2		; $66c0
	jp fillRectInRoomLayout		; $66c3

@wallEdge1:
	.db $1b $09 $01 $b3

@wallEdge2:
	.db $16 $09 $01 $b1

; Light the torches.
@pastRetracted:
	ld de,@tilesToReplace		; $66ce
	jp replaceTiles		; $66d1

@tilesToReplace:
	.db $09 $08 ; Replace unlit torch with lit
	.db $00

;;
; D8: room with retracting wall
; @addr{66d7}
tileReplacement_group5Map95:
	call getThisRoomFlags		; $66d7
	and $40			; $66da
	ret nz			; $66dc

	ld hl,wRoomLayout + $4d		; $66dd
	ld (hl),$b4		; $66e0
	inc l			; $66e2
	ld (hl),$b2		; $66e3
	ld hl,@wallInterior		; $66e5
	call fillRectInRoomLayout		; $66e8
	ld hl,@wallEdge		; $66eb
	jp fillRectInRoomLayout		; $66ee

@wallInterior:
	.db $5e $05 $01 $a7
@wallEdge:
	.db $5d $05 $01 $b1

;;
; Past: cave with goron elder
; Gets rid of a boulder and creates a shortcut
; @addr{66f9}
tileReplacement_group5Mapc3:
	call @func_04_672e		; $66f9
	call getThisRoomFlags		; $66fc
	and ROOMFLAG_40			; $66ff
	ret z			; $6701

	ld bc,@boulderReplacementTiles		; $6702
	ld hl,wRoomLayout + $31		; $6705
	call @locFunc		; $6708
	ld l,$41		; $670b
	call @locFunc		; $670d
	ld l,$51		; $6710
@locFunc:
	ld a,$05		; $6712
--
	ldh (<hFF8D),a	; $6714
	ld a,(bc)		; $6716
	inc bc			; $6717
	ldi (hl),a		; $6718
	ldh a,(<hFF8D)	; $6719
	dec a			; $671b
	jr nz,--		; $671c
	ret			; $671e

; @addr{671f}
@boulderReplacementTiles:
	.db $a2 $a1 $a2 $a1 $a2
	.db $a1 $a2 $a1 $a2 $a1
	.db $a2 $a1 $a2 $a1 $a2


;;
; If d5 is beaten, remove a wall to make the area easier to traverse. (This
; does not remove the boulder)
; @addr{672e}
@func_04_672e:
	ld a,$04		; $672e
	ld hl,wEssencesObtained		; $6730
	call checkFlag		; $6733
	ret z			; $6736

	ld hl,@newTiles		; $6737
	ld bc,wRoomLayout + $06		; $673a
	ld a,$04		; $673d
---
	ldh (<hFF8D),a	; $673f
	ld a,$04		; $6741
--
	ldh (<hFF8C),a	; $6743
	ldi a,(hl)		; $6745
	or a			; $6746
	jr z,+			; $6747
	ld (bc),a		; $6749
+
	inc bc			; $674a
	ldh a,(<hFF8C)	; $674b
	dec a			; $674d
	jr nz,--		; $674e

	ld a,$0c		; $6750
	call addAToBc		; $6752
	ldh a,(<hFF8D)	; $6755
	dec a			; $6757
	jr nz,---		; $6758
	ret			; $675a

; 4x4 grid of new tiles to insert ($00 means unchanged).
; @addr{675b}
@newTiles:
	.db $b0 $b0 $b0 $b0
	.db $ef $00 $00 $ef
	.db $ef $00 $00 $ef
	.db $b4 $b2 $b2 $b2

;;
; Past: cave in goron mountain with 2 chests
; @addr{676b}
tileReplacement_group2Mapf7:
	call getThisRoomFlags		; $676b
	bit ROOMFLAG_BIT_ITEM,(hl)		; $676e
	jr z,++			; $6770

	ld a,TILEINDEX_CHEST_OPENED	; $6772
	ld c,$14		; $6774
	call setTile		; $6776
	ld a,TILEINDEX_CHEST_OPENED	; $6779
	ld c,$16		; $677b
	jp setTile		; $677d
++
	ld a,(hl)		; $6780
	and $c0			; $6781
	cp $c0			; $6783
	ret z			; $6785

	bit 6,(hl)		; $6786
	jr z,+			; $6788

	ld a,(wSeedTreeRefilledBitset)		; $678a
	bit 0,a			; $678d
	ret nz			; $678f
+
	ld hl,@wallInsertion	; $6790
	ld bc,wRoomLayout + $03		; $6793
	ld a,$04		; $6796
---
	ldh (<hFF8D),a	; $6798
	ld a,$05		; $679a
--
	ldh (<hFF8C),a	; $679c
	ldi a,(hl)		; $679e
	ld (bc),a		; $679f
	inc bc			; $67a0
	ldh a,(<hFF8C)	; $67a1
	dec a			; $67a3
	jr nz,--	; $67a4

	ld a,$0b		; $67a6
	call addAToBc		; $67a8
	ldh a,(<hFF8D)	; $67ab
	dec a			; $67ad
	jr nz,---		; $67ae
	ret			; $67b0

; @addr{67b1}
@wallInsertion:
	.db $b9 $a7 $a7 $a7 $b8
	.db $b1 $a7 $a7 $a7 $b3
	.db $b1 $a7 $a7 $a7 $b3
	.db $b6 $b0 $b0 $b0 $b7

;;
; D7: 1st platform on floor 1
; @addr{67c5}
tileReplacement_group5Map4c:
	ld a,(wJabuWaterLevel)		; $67c5
	and $07			; $67c8
	ret z			; $67ca

	ld hl,@rect		; $67cb
	call fillRectInRoomLayout		; $67ce

	; Staircase going down
	ld l,$57		; $67d1
	ld (hl),$45		; $67d3
	ret			; $67d5

; @addr{67d6}
@rect:
	.db $35 $05 $05 $a2

;;
; D7: 2nd platform on floor 1
; @addr{67da}
tileReplacement_group5Map4d:
	ld a,(wJabuWaterLevel)		; $67da
	and $07			; $67dd
	ret z			; $67df

	ld hl,@rect		; $67e0
	jp fillRectInRoomLayout		; $67e3

; @addr{67e6}
@rect:
	.db $12 $05 $05 $a2

;;
; D7: Used in room $55c and $571. Makes the 1st platform appear if the water
; level is correct.
; @addr{67ea}
tileReplacement_group5Map5c:
	ld a,(wDungeonFloor)		; $67ea
	ld b,a			; $67ed
	ld a,(wJabuWaterLevel)		; $67ee
	and $07			; $67f1
	cp b			; $67f3
	ret nz			; $67f4

	ld de,@platformRect		; $67f5
	jp drawRectInRoomLayout		; $67f8

; @addr{67fb}
@platformRect:
	.db $35 $05 $05
	.db $c5 $c3 $c3 $c3 $c6
	.db $c2 $a0 $a0 $a0 $c4
	.db $c2 $a0 $10 $a0 $c4
	.db $c2 $a0 $a0 $a0 $c4
	.db $c7 $c1 $c1 $c1 $c8

;;
; D7: used is room $55d and $572. Makes the 2nd platform appear if the water
; level is correct.
; @addr{6817}
tileReplacement_group5Map5d:
	ld a,(wDungeonFloor)		; $6817
	ld b,a			; $681a
	ld a,(wJabuWaterLevel)		; $681b
	and $07			; $681e
	cp b			; $6820
	ret nz			; $6821

	ld de,@platformRect		; $6822
	jp drawRectInRoomLayout		; $6825

@platformRect:
	.db $12 $05 $05
	.db $c5 $c3 $c3 $c3 $c6
	.db $c2 $91 $96 $90 $c4
	.db $c2 $95 $db $94 $c4
	.db $c2 $9b $92 $9a $c4
	.db $c7 $c1 $c1 $c1 $c8

;;
; D7 miniboss room (except it's group 7 instead of 5?)
; Creates a ladder if the miniboss has been murdered.
; @addr{6844}
tileReplacement_group7Map4a:
	call getThisRoomFlags		; $6844
	and $80			; $6847
	ret z			; $6849

	ld hl,@ladderRect		; $684a
	jp fillRectInRoomLayout		; $684d

; @addr{5850}
@ladderRect:
	.db $0d $0a $01 $18

;;
; Graveyard: Clear the fence if opened
; @addr{6854}
tileReplacement_group0Map5c:
	call getThisRoomFlags	; $6854
	and $80			; $6857
	ret z			; $6859

	ld hl,wRoomLayout + $34		; $685a
	ld a,$3a		; $685d
	ld (hl),a		; $685f
	ld l,$43		; $6860
	jp set3Bytes		; $6862

;;
; Present forest above d2: clear rubble
; @addr{6865}
tileReplacement_group0Map73:
	call getThisRoomFlags		; $6865
	and $80			; $6868
	ret z			; $686a

	ld hl,wRoomLayout + $73		; $686b
	ld (hl),$3a		; $686e
	inc l			; $6870
	ld (hl),$10		; $6871
	inc l			; $6873
	ld (hl),$11		; $6874
	inc l			; $6876
	ld (hl),$12		; $6877
	inc l			; $6879
	ld (hl),$3a		; $687a
	ret			; $687c

;;
; Present Tokay: remove scent tree if not planted
; @addr{687d}
tileReplacement_group0Mapac:
	call getThisRoomFlags		; $687d
	and $80			; $6880
	ret nz			; $6882

	ld hl,wRoomLayout + $33		; $6883
	ld a,$af		; $6886
	ldi (hl),a		; $6888
	ld (hl),a		; $6889
	ld l,$43		; $688a
	ldi (hl),a		; $688c
	ld (hl),a		; $688d
	ret			; $688e

;;
; Rolling ridge present screen with vine
; @addr{688f}
tileReplacement_group0Map2c:
	ld bc,$0017		; $688f
	call getVinePosition		; $6892
	jp nz,setTileToWitheredVine		; $6895
	ld l,$06		; $6898
	ld de,@vineEdgeReplacements	; $689a
	jp replaceVineTiles		; $689d

; @addr{68a0}
@vineEdgeReplacements:
	.db $5d $60
	.db $00

;;
; Rolling ridge present, above the screen with a vine
; @addr{68a3}
tileReplacement_group0Map1c:
	ld bc,$0017		; $68a3
	call getVinePosition		; $68a6
	ret nz			; $68a9
	ld l,$66		; $68aa
	ld de,@vineEdgeReplacements		; $68ac
	jp replaceVineTiles		; $68af

; @addr{68b2}
@vineEdgeReplacements:
	.db $5b $45
	.db $4d $55
	.db $00

;;
; Tokay island present, D3 entrance screen (has a vine)
; @addr{68b7}
tileReplacement_group0Mapba:
	ld bc,$0218		; $68b7
	call getVinePosition		; $68ba
	jp nz,setTileToWitheredVine		; $68bd
	ld l,$07		; $68c0
	ld de,@vineEdgeReplacements		; $68c2
	call replaceVineTiles		; $68c5
	ld a,$8b		; $68c8
	ld (wRoomLayout+$18),a		; $68ca
	ret			; $68cd

; @addr{68ce}
@vineEdgeReplacements:
	.db $61 $60
	.db $00

;;
; Tokay island present, above D3 entrance screen
; @addr{68d1}
tileReplacement_group0Mapaa:
	ld bc,$0218		; $68d1
	call getVinePosition		; $68d4
	ret nz			; $68d7

	ld l,$77		; $68d8
	ld de,@vineEdgeReplacements	; $68da
	jp replaceVineTiles		; $68dd

; @addr{68e0}
@vineEdgeReplacements:
	.db $46 $45
	.db $00

;;
; Tokay island present, 2nd vine screen
; @addr{68e3}
tileReplacement_group0Mapcc:
	ld bc,$0311		; $68e3
	call getVinePosition		; $68e6
	jp nz,setTileToWitheredVine		; $68e9

	ld l,$00		; $68ec
	ld de,@vineEdgeReplacements	; $68ee
	jp replaceVineTiles		; $68f1

; @addr{68f4}
@vineEdgeReplacements:
	.db $61 $5d
	.db $00

;;
; Tokay island present, above 2nd vine screen
; @addr{68f7}
tileReplacement_group0Mapbc:
	ld bc,$0311		; $68f7
	call getVinePosition		; $68fa
	ret nz			; $68fd

	ld l,$70		; $68fe
	ld de,@vineEdgeReplacements	; $6900
	jp replaceVineTiles		; $6903

; @addr{6906}
@vineEdgeReplacements:
	.db $46 $5c
	.db $00

;;
; Tokay island present, 3rd vine screen
; @addr{6909}
tileReplacement_group0Mapda:
	ld bc,$0418		; $6909
	call getVinePosition		; $690c
	jp nz,setTileToWitheredVine		; $690f

	ld l,$07		; $6912
	ld de,@vineEdgeReplacements	; $6914
	jp replaceVineTiles		; $6917

; @addr{691a}
@vineEdgeReplacements:
	.db $61 $60
	.db $00

;;
; Tokay island present, above 3rd vine screen
; @addr{691d}
tileReplacement_group0Mapca:
	ld bc,$0418		; $691d
	call getVinePosition		; $6920
	ret nz			; $6923

	ld l,$77		; $6924
	ld de,@videEdgeReplacements	; $6926
	jp replaceVineTiles		; $6929

; @addr{692c}
@videEdgeReplacements:
	.db $46 $45
	.db $00

;;
; Talus Peaks Present, has 2 vines
; @addr{692f}
tileReplacement_group0Map61:
	ld bc,$0122		; $692f
	call getVinePosition		; $6932
	jr z,@vine1			; $6935

	ld bc,$0127		; $6937
	call getVinePosition		; $693a
	jp nz,setTileToWitheredVine		; $693d
@vine2:
	ld hl,wRoomLayout + $06		; $6940
	ld (hl),$4d		; $6943
	inc l			; $6945
	ld (hl),$d5		; $6946
	inc l			; $6948
	ld (hl),$55		; $6949
	ld l,$16		; $694b
	ld (hl),$5d		; $694d
	inc l			; $694f
	ld (hl),$d6		; $6950
	inc l			; $6952
	ld (hl),$60		; $6953
	ld l,$27		; $6955
	ld (hl),$8d		; $6957
	ret			; $6959
@vine1:
	ld hl,wRoomLayout + $01		; $695a
	ld (hl),$56		; $695d
	inc l			; $695f
	ld (hl),$d5		; $6960
	inc l			; $6962
	ld (hl),$4d		; $6963
	ld l,$11		; $6965
	ld (hl),$61		; $6967
	inc l			; $6969
	ld (hl),$d6		; $696a
	inc l			; $696c
	ld (hl),$5d		; $696d
	ld l,$22		; $696f
	ld (hl),$8d		; $6971
	ret			; $6973

;;
; Screen above talus peaks vines
; @addr{6974}
tileReplacement_group0Map51:
	ld bc,$0122		; $6974
	call getVinePosition		; $6977
	jr z,@vines1		; $697a

	ld bc,$0127		; $697c
	call getVinePosition		; $697f
	ret nz			; $6982
@vines2:
	ld hl,wRoomLayout + $76		; $6983
	ld (hl),$5b		; $6986
	inc l			; $6988
	ld (hl),$d4		; $6989
	inc l			; $698b
	ld (hl),$45		; $698c
	ret			; $698e
@vines1:
	ld hl,wRoomLayout + $71		; $698f
	ld (hl),$46		; $6992
	inc l			; $6994
	ld (hl),$d4		; $6995
	inc l			; $6997
	ld (hl),$5c		; $6998
	ret			; $699a

;;
; Replaces tiles that should be turned into vines.
; @param de Data structure with values to replace the sides of the vine with.
; Format: left byte, right byte, repeat, $00 to end
; @param l Top-left of where to apply the data at de.
; @addr{699b}
replaceVineTiles:
	ld h,>wRoomLayout		; $699b
--
	ld a,(de)		; $699d
	or a			; $699e
	jr z,++			; $699f

	ld a,(de)		; $69a1
	inc de			; $69a2
	ldi (hl),a		; $69a3
	inc l			; $69a4
	ld a,(de)		; $69a5
	inc de			; $69a6
	ldi (hl),a		; $69a7
	ld a,$0d		; $69a8
	rst_addAToHl			; $69aa
	jr --			; $69ab
++
	ld de,@vineReplacements		; $69ad
	call replaceTiles		; $69b0

	; Find the vine base
	ld a,$d6		; $69b3
	call findTileInRoom		; $69b5
	ret nz			; $69b8

	; Set the tile below that to $8d which completes the vine base
	ld a,l			; $69b9
	add $10			; $69ba
	ld l,a			; $69bc
	ld (hl),$8d		; $69bd
	ret			; $69bf

; @addr{69c0}
@vineReplacements:
	.db $d4 $05 ; Top of cliff -> top of vine
	.db $d5 $8e ; Body
	.db $d6 $8f ; Bottom
	.db $00


;;
; Retrieve a position from [hl], set the tile at that position to a withered
; vine.
; @addr{69c7}
setTileToWitheredVine:
	ld l,(hl)		; $69c7
	ld h,>wRoomLayout		; $69c8
	ld a,(hl)		; $69ca
	push hl			; $69cb
	call retrieveTileCollisionValue		; $69cc
	pop hl			; $69cf
	or a			; $69d0
	ret nz			; $69d1
	ld (hl),$8c		; $69d2
	ret			; $69d4

;;
; Get the position of vine B and compare with C.
; @addr{69d5}
getVinePosition:
	ld a,b			; $69d5
	ld hl,wVinePositions		; $69d6
	rst_addAToHl			; $69d9
	ld a,(hl)		; $69da
	cp c			; $69db
	ret			; $69dc

;;
; @addr{69dd}
initializeVinePositions:
	ld hl,wVinePositions		; $69dd
	ld de,@defaultVinePositions	; $69e0
	ld b,$06		; $69e3
	jp copyMemoryReverse		; $69e5

@defaultVinePositions:
	.include "build/data/defaultVinePositions.s"

;;
; Present, bridge to nuun highlands
; @addr{69ee}
tileReplacement_group0Map54:
	xor a			; $69ee
	ld (wSwitchState),a		; $69ef
	call getThisRoomFlags		; $69f2
	and $40			; $69f5
	ret z			; $69f7

	ld a,$1d		; $69f8
	ld hl,wRoomLayout + $43		; $69fa
	ldi (hl),a		; $69fd
	ldi (hl),a		; $69fe
	ldi (hl),a		; $69ff
	ld a,$1e		; $6a00
	ld l,$53		; $6a02
	ldi (hl),a		; $6a04
	ldi (hl),a		; $6a05
	ld (hl),a		; $6a06
	ld a,$9e		; $6a07
	ld (wRoomLayout+$68),a		; $6a09
	ret			; $6a0c

;;
; Present, right side of bridge to symmetry city
; @addr{6a0d}
tileReplacement_group0Map25:
	ld a,GLOBALFLAG_SYMMETRY_BRIDGE_BUILT		; $6a0d
	call checkGlobalFlag		; $6a0f
	ret z			; $6a12

	ld a,$1d		; $6a13
	ld hl,wRoomLayout + $50		; $6a15
	ldi (hl),a		; $6a18
	ldi (hl),a		; $6a19
	ldi (hl),a		; $6a1a
	ld a,$1e		; $6a1b
	ld hl,wRoomLayout+$60		; $6a1d
	ldi (hl),a		; $6a20
	ldi (hl),a		; $6a21
	ld (hl),a		; $6a22
	ret			; $6a23

;;
; Present overworld, impa's house
; @addr{6a24}
tileReplacement_group0Map3a:
	ld a,GLOBALFLAG_INTRO_DONE		; $6a24
	call checkGlobalFlag		; $6a26
	ret z			; $6a29

	; Open door
	ld a,$ee		; $6a2a
	ld (wRoomLayout+$23),a		; $6a2c
	ret			; $6a2f

;;
; Present, screen right of d5 where a cave opens up
; @addr{6a30}
tileReplacement_group0Map0b:
	ld hl,wPresentRoomFlags+$0a		; $6a30
	bit ROOMFLAG_BIT_40,(hl)		; $6a33
	ret z			; $6a35

	ld hl,wRoomLayout+$43		; $6a36
	ld (hl),$dd		; $6a39
	ret			; $6a3b

;;
; Present cave with goron elder.
; Removes boulders after dungeon 4 is beaten.
; @addr{6a3c}
tileReplacement_group5Mapb9:
	; Must have beaten dungeon 4
	ld a,$03		; $6a3c
	ld hl,wEssencesObtained		; $6a3e
	call checkFlag		; $6a41
	ret z			; $6a44

	ld bc,@replacementTiles		; $6a45
	ld hl,wRoomLayout+$41		; $6a48
	call @locFunc		; $6a4b
	ld l,$51		; $6a4e
@locFunc:
	ld a,$05		; $6a50
--
	ldh (<hFF8D),a	; $6a52
	ld a,(bc)		; $6a54
	inc bc			; $6a55
	ldi (hl),a		; $6a56
	ldh a,(<hFF8D)	; $6a57
	dec a			; $6a59
	jr nz,--		; $6a5a
	ret			; $6a5c

@replacementTiles:
	.db $a1 $a1 $a1 $ef $a1
	.db $a2 $ef $a2 $a2 $a2

;;
; Past overworld, Ambi's Palace secret passage
; @addr{6a67}
tileReplacement_group1Map27:
	call getThisRoomFlags		; $6a67
	ld l,$15		; $6a6a
	bit 7,(hl)		; $6a6c
	jr z,+			; $6a6e

	ld de,$3343		; $6a70
	call @locFunc		; $6a73
+
	ld l,$17		; $6a76
	bit 7,(hl)		; $6a78
	jr z,+			; $6a7a

	ld de,$3424		; $6a7c
	call @locFunc		; $6a7f
+
	ld l,$35		; $6a82
	bit 7,(hl)		; $6a84
	jr z,+			; $6a86

	ld de,$3545		; $6a88
	call @locFunc		; $6a8b
+
	ld l,$37		; $6a8e
	bit 7,(hl)		; $6a90
	ret z			; $6a92

	ld de,$3626		; $6a93
@locFunc:
	ld b,>wRoomLayout		; $6a96
	ld c,d			; $6a98
	ld a,$3a		; $6a99
	ld (bc),a		; $6a9b
	ld c,e			; $6a9c
	ld a,$02		; $6a9d
	ld (bc),a		; $6a9f
	ret			; $6aa0

;;
; Present cave on the way to rolling ridge
; Has a bridge
; @addr{6aa1}
tileReplacement_group5Mapc2:
	call getThisRoomFlags		; $6aa1
	and $80			; $6aa4
	ret z			; $6aa6

	ld hl,wRoomLayout+$56		; $6aa7
	ld a,$6d		; $6aaa

;;
; Sets 4 bytes at hl to the value of a.
; @addr{6aac}
set4Bytes:
	ldi (hl),a		; $6aac
set3Bytes:
	ldi (hl),a		; $6aad
	ldi (hl),a		; $6aae
	ld (hl),a		; $6aaf
	ret			; $6ab0

;;
; Past cave on the way to the d6 area
; Has a bridge
; @addr{6ab1}
tileReplacement_group5Mape3:
	call getThisRoomFlags		; $6ab1
	and $80			; $6ab4
	ret z			; $6ab6

	ld hl,wRoomLayout+$26		; $6ab7
	ld a,$6d		; $6aba
	jr set3Bytes		; $6abc

;;
; Underwater, entrance to Jabu
; @addr{6abe}
tileReplacement_group2Map90:
	call getThisRoomFlags		; $6abe
	and $02			; $6ac1
	ret z			; $6ac3

	ld de,@rect		; $6ac4
	jp drawRectInRoomLayout		; $6ac7

; @addr{6aca}
@rect:
	.db $42 $02 $06
	.db $dd $de $df $ed $ee $ef
	.db $b9 $ba $bb $bc $bd $be

;;
; Past, area beneath the entrance to d8 maze
; @addr{6ad9}
tileReplacement_group1Map8c:
	call getThisRoomFlags		; $6ad9
	and $80			; $6adc
	ret z			; $6ade

	ld hl,wRoomLayout+$04		; $6adf
	ld (hl),$30		; $6ae2
	inc l			; $6ae4
	ld (hl),$32		; $6ae5
	ld a,$3a		; $6ae7
	ld l,$14		; $6ae9
	ldi (hl),a		; $6aeb
	ld (hl),a		; $6aec
	ld l,$34		; $6aed
	ld (hl),$02		; $6aef
	inc l			; $6af1
	ld (hl),$3a		; $6af2
	ret			; $6af4

;;
; Present, shortcut cave for tingle
; @addr{6af5}
tileReplacement_group2Map9e:
	xor a			; $6af5
	ld (wToggleBlocksState),a		; $6af6
	call getThisRoomFlags		; $6af9
	and $40			; $6afc
	ret z			; $6afe

	ld hl,wRoomLayout+$13		; $6aff
	ld a,$6d		; $6b02
	call set3Bytes		; $6b04
	inc l			; $6b07
	jp set3Bytes		; $6b08

;;
; Present, on top of maku tree (left end)
; @addr{6b0b}
tileReplacement_group0Mape0:
	ld a,(wEssencesObtained)		; $6b0b
	bit 4,a			; $6b0e
	ld l,$46		; $6b10
	call nz,_setTileToDoor		; $6b12
	ld c,$1b		; $6b15
;;
; @addr{6b17}
_createInteraction90:
	call getFreeInteractionSlot		; $6b17
	ret nz			; $6b1a

	ld (hl),INTERACID_MISC_PUZZLES		; $6b1b
	inc l			; $6b1d
	ld (hl),c		; $6b1e
	ret			; $6b1f

;;
; Present, on top of maku tree (middle)
; @addr{6b20}
tileReplacement_group0Mape1:
	ld c,$1c		; $6b20
	call _createInteraction90		; $6b22
	ld a,(wEssencesObtained)		; $6b25
	rrca			; $6b28
	ld l,$26		; $6b29
	call c,_setTileToDoor		; $6b2b
	rrca			; $6b2e
	ret nc			; $6b2f

	ld l,$53		; $6b30
	jr _setTileToDoor		; $6b32

;;
; Present, on top of maku tree (right)
; @addr{6b34}
tileReplacement_group0Mape2:
	ld c,$1d		; $6b34
	call _createInteraction90		; $6b36
	ld a,(wEssencesObtained)		; $6b39
	bit 2,a			; $6b3c
	ret z			; $6b3e

	ld l,$54		; $6b3f

;;
; @addr{6b41}
_setTileToDoor:
	ld h,>wRoomLayout		; $6b41
	ld (hl),$dd		; $6b43
	ret			; $6b45

;;
; Black Tower, room with 3 doors
; @addr{6b46}
tileReplacement_group4Mapea:
	call getThisRoomFlags		; $6b46
	and $40			; $6b49
	ret z			; $6b4b

	ld a,$a3		; $6b4c
	ld hl,wRoomLayout+$33		; $6b4e
	call set3Bytes		; $6b51
	ld l,$39		; $6b54
	call set3Bytes		; $6b56
	ld a,$b7		; $6b59
	ld l,$43		; $6b5b
	call set3Bytes		; $6b5d
	ld l,$49		; $6b60
	call set3Bytes		; $6b62
	ld a,$88		; $6b65
	ld l,$53		; $6b67
	call set3Bytes		; $6b69
	ld l,$59		; $6b6c
	jp set3Bytes		; $6b6e

;;
; Present, room where you find ricky's gloves
; @addr{6b71}
tileReplacement_group0Map98:
	ld a,(wRickyState)		; $6b71
	bit 5,a			; $6b74
	jr nz,@removeDirt		; $6b76

	and $01			; $6b78
	jr z,@removeDirt			; $6b7a

	ld a,TREASURE_RICKY_GLOVES		; $6b7c
	call checkTreasureObtained		; $6b7e
	ret nc			; $6b81

@removeDirt:
	ld a,$3a		; $6b82
	ld (wRoomLayout+$24),a		; $6b84
	ret			; $6b87

;;
; Present overworld, black tower entrance
; @addr{6b88}
tileReplacement_group0Map76:
	call checkIsLinkedGame		; $6b88
	ret z			; $6b8b

	call getBlackTowerProgress		; $6b8c
	dec a			; $6b8f
	ret nz			; $6b90

	ld hl,wRoomLayout+$54		; $6b91
	ld a,$a7		; $6b94
	ldi (hl),a		; $6b96
	ld (hl),a		; $6b97
	ret			; $6b98

;;
; Present library
; @addr{6b99}
tileReplacement_group0Mapa5:
	ld a,(wPastRoomFlags+$a5)		; $6b99
	bit 7,a			; $6b9c
	ret z			; $6b9e

	ld hl,wRoomLayout+$22		; $6b9f
	ld (hl),$ee		; $6ba2
	inc l			; $6ba4
	ld (hl),$ef		; $6ba5
	ret			; $6ba7

;;
; Unused?
; @addr{6ba8}
func_04_6ba8:
	ld d,>wRoomLayout		; $6ba8
	ldi a,(hl)		; $6baa
	ld c,a			; $6bab
--
	ldi a,(hl)		; $6bac
	cp $ff			; $6bad
	ret z			; $6baf

	ld e,a			; $6bb0
	ld a,c			; $6bb1
	ld (de),a		; $6bb2
	jr --			; $6bb3

;;
; Fills a square in wRoomLayout using the data at hl.
; Data format:
; - Top-left position (YX)
; - Height
; - Width
; - Tile value
; @addr{6bb5}
fillRectInRoomLayout:
	ldi a,(hl)		; $6bb5
	ld e,a			; $6bb6
	ldi a,(hl)		; $6bb7
	ld b,a			; $6bb8
	ldi a,(hl)		; $6bb9
	ld c,a			; $6bba
	ldi a,(hl)		; $6bbb
	ld d,a			; $6bbc
	ld h,>wRoomLayout		; $6bbd
--
	ld a,d			; $6bbf
	ld l,e			; $6bc0
	push bc			; $6bc1
-
	ldi (hl),a		; $6bc2
	dec c			; $6bc3
	jr nz,-			; $6bc4

	ld a,e			; $6bc6
	add $10			; $6bc7
	ld e,a			; $6bc9
	pop bc			; $6bca
	dec b			; $6bcb
	jr nz,--		; $6bcc
	ret			; $6bce

;;
; Like fillRect, but reads a series of bytes for the tile values instead of
; just one.
; @addr{6bcf}
drawRectInRoomLayout:
	ld a,(de)		; $6bcf
	inc de			; $6bd0
	ld h,>wRoomLayout		; $6bd1
	ld l,a			; $6bd3
	ldh (<hFF8B),a	; $6bd4
	ld a,(de)		; $6bd6
	inc de			; $6bd7
	ld c,a			; $6bd8
	ld a,(de)		; $6bd9
	inc de			; $6bda
	ldh (<hFF8D),a	; $6bdb
---
	ldh a,(<hFF8D)	; $6bdd
	ld b,a			; $6bdf
--
	ld a,(de)		; $6be0
	inc de			; $6be1
	ldi (hl),a		; $6be2
	dec b			; $6be3
	jr nz,--		; $6be4

	ldh a,(<hFF8B)	; $6be6
	add $10			; $6be8
	ldh (<hFF8B),a	; $6bea
	ld l,a			; $6bec
	dec c			; $6bed
	jr nz,---		; $6bee
	ret			; $6bf0

;;
; Generate the buffers at w3VramTiles and w3VramAttributes based on the tiles
; loaded in wRoomLayout.
; @addr{6bf1}
generateW3VramTilesAndAttributes:
	ld a,:w3VramTiles		; $6bf1
	ld ($ff00+R_SVBK),a	; $6bf3
	ld hl,wRoomLayout		; $6bf5
	ld de,w3VramTiles		; $6bf8
	ld c,$0b		; $6bfb
---
	ld b,$10		; $6bfd
--
	push bc			; $6bff
	ldi a,(hl)		; $6c00
	push hl			; $6c01
	call setHlToTileMappingDataPlusATimes8		; $6c02
	push de			; $6c05
	call write4BytesToVramLayout		; $6c06
	pop de			; $6c09
	set 2,d			; $6c0a
	call write4BytesToVramLayout		; $6c0c
	res 2,d			; $6c0f
	ld a,e			; $6c11
	sub $1f			; $6c12
	ld e,a			; $6c14
	pop hl			; $6c15
	pop bc			; $6c16
	dec b			; $6c17
	jr nz,--		; $6c18

	ld a,$20		; $6c1a
	call addAToDe		; $6c1c
	dec c			; $6c1f
	jr nz,---		; $6c20
	ret			; $6c22

;;
; Take 4 bytes from hl, write 2 to de, write the next 2 $20 bytes later.
; @addr{6c23}
write4BytesToVramLayout:
	ldi a,(hl)		; $6c23
	ld (de),a		; $6c24
	inc e			; $6c25
	ldi a,(hl)		; $6c26
	ld (de),a		; $6c27
	ld a,$1f		; $6c28
	add e			; $6c2a
	ld e,a			; $6c2b
	ldi a,(hl)		; $6c2c
	ld (de),a		; $6c2d
	inc e			; $6c2e
	ldi a,(hl)		; $6c2f
	ld (de),a		; $6c30
	ret			; $6c31

;;
; This updates up to 4 entries in w2ChangedTileQueue by writing a command to the vblank
; queue.
;
; @addr{6c32}
updateChangedTileQueue:
	ld a,(wScrollMode)		; $6c32
	and $0e			; $6c35
	ret nz			; $6c37

	; Update up to 4 tiles per frame
	ld b,$04		; $6c38
--
	push bc			; $6c3a
	call @handleSingleEntry		; $6c3b
	pop bc			; $6c3e
	dec b			; $6c3f
	jr nz,--		; $6c40

	xor a			; $6c42
	ld ($ff00+R_SVBK),a	; $6c43
	ret			; $6c45

;;
; @addr{6c46}
@handleSingleEntry:
	ld a,(wChangedTileQueueHead)		; $6c46
	ld b,a			; $6c49
	ld a,(wChangedTileQueueTail)		; $6c4a
	cp b			; $6c4d
	ret z			; $6c4e

	inc b			; $6c4f
	ld a,b			; $6c50
	and $1f			; $6c51
	ld (wChangedTileQueueHead),a		; $6c53
	ld hl,w2ChangedTileQueue		; $6c56
	rst_addDoubleIndex			; $6c59

	ld a,:w2ChangedTileQueue		; $6c5a
	ld ($ff00+R_SVBK),a	; $6c5c

	; b = New value of tile
	; c = position of tile
	ldi a,(hl)		; $6c5e
	ld c,(hl)		; $6c5f
	ld b,a			; $6c60

	ld a,c			; $6c61
	ldh (<hFF8C),a	; $6c62

	ld a,($ff00+R_SVBK)	; $6c64
	push af			; $6c66
	ld a,:w3VramTiles		; $6c67
	ld ($ff00+R_SVBK),a	; $6c69
	call getVramSubtileAddressOfTile		; $6c6b

	ld a,b			; $6c6e
	call setHlToTileMappingDataPlusATimes8		; $6c6f
	push hl			; $6c72

	; Write tile data
	push de			; $6c73
	call write4BytesToVramLayout		; $6c74
	pop de			; $6c77

	; Write mapping data
	ld a,$04		; $6c78
	add d			; $6c7a
	ld d,a			; $6c7b
	call write4BytesToVramLayout		; $6c7c

	ldh a,(<hFF8C)	; $6c7f
	pop hl			; $6c81
	call queueTileWriteAtVBlank		; $6c82

	pop af			; $6c85
	ld ($ff00+R_SVBK),a	; $6c86
	ret			; $6c88

;;
; @param	c	Tile index
; @param[out]	de	Address of tile c's top-left subtile in w3VramTiles
; @addr{6c89}
getVramSubtileAddressOfTile:
	ld a,c			; $6c89
	swap a			; $6c8a
	and $0f			; $6c8c
	ld hl,@addresses	; $6c8e
	rst_addDoubleIndex			; $6c91
	ldi a,(hl)		; $6c92
	ld h,(hl)		; $6c93
	ld l,a			; $6c94

	ld a,c			; $6c95
	and $0f			; $6c96
	add a			; $6c98
	rst_addAToHl			; $6c99
	ld e,l			; $6c9a
	ld d,h			; $6c9b
	ret			; $6c9c

@addresses:
	.dw w3VramTiles+$000
	.dw w3VramTiles+$040
	.dw w3VramTiles+$080
	.dw w3VramTiles+$0c0
	.dw w3VramTiles+$100
	.dw w3VramTiles+$140
	.dw w3VramTiles+$180
	.dw w3VramTiles+$1c0
	.dw w3VramTiles+$200
	.dw w3VramTiles+$240
	.dw w3VramTiles+$280

;;
; Called from "setInterleavedTile" in bank 0.
;
; Mixes two tiles together by using some subtiles from one, and some subtiles from the
; other. Used for example by shutter doors, which would combine the door and floor tiles
; for the partway-closed part of the animation.
;
; Tile 2 uses its tiles from the same "half" that tile 1 uses. For example, if tile 1 was
; placed on the right side, both tiles would use the right halves of their subtiles.
;
; @param	a	0: Top is tile 2, bottom is tile 1
;			1: Left is tile 1, right is tile 2
;			2: Top is tile 1, bottom is tile 2
;			3: Left is tile 2, right is tile 1
; @param	hFF8C	Position of tile to change
; @param	hFF8F	Tile index 1
; @param	hFF8E	Tile index 2
; @addr{6cb3}
setInterleavedTile_body:
	ldh (<hFF8B),a	; $6cb3

	ld a,($ff00+R_SVBK)	; $6cb5
	push af			; $6cb7
	ld a,:w3TileMappingData		; $6cb8
	ld ($ff00+R_SVBK),a	; $6cba

	ldh a,(<hFF8F)	; $6cbc
	call setHlToTileMappingDataPlusATimes8		; $6cbe
	ld de,$cec8		; $6cc1
	ld b,$08		; $6cc4
-
	ldi a,(hl)		; $6cc6
	ld (de),a		; $6cc7
	inc de			; $6cc8
	dec b			; $6cc9
	jr nz,-			; $6cca

	ldh a,(<hFF8E)	; $6ccc
	call setHlToTileMappingDataPlusATimes8		; $6cce
	ld de,$cec8		; $6cd1
	ldh a,(<hFF8B)	; $6cd4
	bit 0,a			; $6cd6
	jr nz,@interleaveDiagonally		; $6cd8

	bit 1,a			; $6cda
	jr nz,+			; $6cdc

	inc hl			; $6cde
	inc hl			; $6cdf
	call @copy2Bytes		; $6ce0
	jr ++			; $6ce3
+
	inc de			; $6ce5
	inc de			; $6ce6
	call @copy2Bytes		; $6ce7
++
	inc hl			; $6cea
	inc hl			; $6ceb
	inc de			; $6cec
	inc de			; $6ced
	call @copy2Bytes		; $6cee
	jr @queueWrite			; $6cf1

@copy2Bytes:
	ldi a,(hl)		; $6cf3
	ld (de),a		; $6cf4
	inc de			; $6cf5
	ldi a,(hl)		; $6cf6
	ld (de),a		; $6cf7
	inc de			; $6cf8
	ret			; $6cf9

@interleaveDiagonally:
	bit 1,a			; $6cfa
	jr nz,+			; $6cfc

	inc de			; $6cfe
	call @copy2BytesSeparated		; $6cff
	jr ++			; $6d02
+
	inc hl			; $6d04
	call @copy2BytesSeparated		; $6d05
++
	inc hl			; $6d08
	inc de			; $6d09
	call @copy2BytesSeparated		; $6d0a
	jr @queueWrite			; $6d0d

;;
; @addr{6d0f}
@copy2BytesSeparated:
	ldi a,(hl)		; $6d0f
	ld (de),a		; $6d10
	inc de			; $6d11
	inc hl			; $6d12
	inc de			; $6d13
	ldi a,(hl)		; $6d14
	ld (de),a		; $6d15
	inc de			; $6d16
	ret			; $6d17

;;
; @param	hFF8C	The position of the tile to refresh
; @param	$cec8	The data to write for that tile
; @addr{6d18}
@queueWrite:
	ldh a,(<hFF8C)	; $6d18
	ld hl,$cec8		; $6d1a
	call queueTileWriteAtVBlank		; $6d1d
	pop af			; $6d20
	ld ($ff00+R_SVBK),a	; $6d21
	ret			; $6d23

;;
; Set wram bank to 3 (or wherever hl is pointing to) before calling this.
;
; @param	a	Tile position
; @param	hl	Pointer to 8 bytes of tile data (usually somewhere in
;			w3TileMappingData)
; @addr{6d24}
queueTileWriteAtVBlank:
	push hl			; $6d24
	call @getTilePositionInVram		; $6d25
	add $20			; $6d28
	ld c,a			; $6d2a

	; Add a command to the vblank queue.
	ldh a,(<hVBlankFunctionQueueTail)	; $6d2b
	ld l,a			; $6d2d
	ld h,>wVBlankFunctionQueue
	ld a,(vblankCopyTileFunctionOffset)		; $6d30
	ldi (hl),a		; $6d33
	ld (hl),e		; $6d34
	inc l			; $6d35
	ld (hl),d		; $6d36
	inc l			; $6d37

	ld e,l			; $6d38
	ld d,h			; $6d39
	pop hl			; $6d3a
	ld b,$02		; $6d3b
--
	; Write 2 bytes to the command
	call @copy2Bytes		; $6d3d

	; Then give it the address for the lower half of the tile
	ld a,c			; $6d40
	ld (de),a		; $6d41
	inc e			; $6d42

	; Then write the next 2 bytes
	call @copy2Bytes		; $6d43
	dec b			; $6d46
	jr nz,--		; $6d47

	; Update the tail of the vblank queue
	ld a,e			; $6d49
	ldh (<hVBlankFunctionQueueTail),a	; $6d4a
	ret			; $6d4c

;;
; @addr{6d4d}
@copy2Bytes:
	ldi a,(hl)		; $6d4d
	ld (de),a		; $6d4e
	inc e			; $6d4f
	ldi a,(hl)		; $6d50
	ld (de),a		; $6d51
	inc e			; $6d52
	ret			; $6d53

;;
; @param	a	Tile position
; @param[out]	a	Same as 'e'
; @param[out]	de	Somewhere in the vram bg map
; @addr{6d54}
@getTilePositionInVram:
	ld e,a			; $6d54
	and $f0			; $6d55
	swap a			; $6d57
	ld d,a			; $6d59
	ld a,e			; $6d5a
	and $0f			; $6d5b
	add a			; $6d5d
	ld e,a			; $6d5e
	ld a,(wScreenOffsetX)		; $6d5f
	swap a			; $6d62
	add a			; $6d64
	add e			; $6d65
	and $1f			; $6d66
	ld e,a			; $6d68
	ld a,(wScreenOffsetY)		; $6d69
	swap a			; $6d6c
	add d			; $6d6e
	and $0f			; $6d6f
	ld hl,vramBgMapTable		; $6d71
	rst_addDoubleIndex			; $6d74
	ldi a,(hl)		; $6d75
	add e			; $6d76
	ld e,a			; $6d77
	ld d,(hl)		; $6d78
	ret			; $6d79

;;
; Called from loadAreaData in bank 0.
;
; @addr{6d7a}
loadAreaData_body:
	call getAdjustedRoomGroup		; $6d7a
	ld hl,roomAreasGroupTable
	rst_addDoubleIndex			; $6d80
	ldi a,(hl)		; $6d81
	ld h,(hl)		; $6d82
	ld l,a			; $6d83
	ld a,(wActiveRoom)		; $6d84
	rst_addAToHl			; $6d87
	ld a,(hl)		; $6d88
	ldh (<hFF8D),a	; $6d89
	call @func_6d94		; $6d8b
	call func_6de7		; $6d8e
	ret nc			; $6d91
	ldh a,(<hFF8D)	; $6d92
@func_6d94:
	and $80			; $6d94
	ldh (<hFF8B),a	; $6d96
	ldh a,(<hFF8D)	; $6d98
	and $7f			; $6d9a
	call multiplyABy8		; $6d9c
	ld hl,areaData
	add hl,bc		; $6da2
	ldi a,(hl)		; $6da3
	ld e,a			; $6da4
	ldi a,(hl)		; $6da5
	ld (wAreaFlags),a		; $6da6
	bit AREAFLAG_BIT_DUNGEON,a			; $6da9
	jr z,+

	ld a,e			; $6dad
	and $0f			; $6dae
	ld (wDungeonIndex),a		; $6db0
	jr ++
+
	ld a,$ff		; $6db5
	ld (wDungeonIndex),a		; $6db7
++
	ld a,e			; $6dba
	swap a			; $6dbb
	and $07			; $6dbd
	ld (wActiveCollisions),a		; $6dbf

	ld b,$06		; $6dc2
	ld de,wAreaUniqueGfx		; $6dc4
@copyloop:
	ldi a,(hl)		; $6dc7
	ld (de),a		; $6dc8
	inc e			; $6dc9
	dec b			; $6dca
	jr nz,@copyloop

	ld e,wAreaUniqueGfx&$ff
	ld a,(de)		; $6dcf
	ld b,a			; $6dd0
	ldh a,(<hFF8B)	; $6dd1
	or b			; $6dd3
	ld (de),a		; $6dd4
	ret			; $6dd5

;;
; Returns the group to load the room layout from, accounting for bit 0 of the room flag
; which tells it to use the underwater group
;
; @param[out]	a,b	The corrected group number
; @addr{6dd6}
getAdjustedRoomGroup:
	ld a,(wActiveGroup)		; $6dd6
	ld b,a			; $6dd9
	cp $02			; $6dda
	ret nc			; $6ddc
	call getThisRoomFlags		; $6ddd
	rrca			; $6de0
	jr nc,+
	set 1,b			; $6de3
+
	ld a,b			; $6de5
	ret			; $6de6

;;
; Modifies hFF8D to indicate changes to a room (ie. jabu flooding)?
; @addr{6de7}
func_6de7:
	call @func_04_6e0d		; $6de7
	ret c			; $6dea

	call @checkJabuFlooded		; $6deb
	ret c			; $6dee

	ld a,(wActiveGroup)		; $6def
	or a			; $6df2
	jr nz,@xor		; $6df3

	ld a,(wLoadingRoomPack)		; $6df5
	cp $7f			; $6df8
	jr nz,@xor		; $6dfa

	ld a,(wAnimalCompanion)		; $6dfc
	sub SPECIALOBJECTID_RICKY			; $6dff
	jr z,@xor		; $6e01

	ld b,a			; $6e03
	ldh a,(<hFF8D)	; $6e04
	add b			; $6e06
	ldh (<hFF8D),a	; $6e07
	scf			; $6e09
	ret			; $6e0a
@xor:
	xor a			; $6e0b
	ret			; $6e0c

;;
; @addr{6e0d}
@func_04_6e0d:
	ld a,(wActiveGroup)		; $6e0d
	or a			; $6e10
	ret nz			; $6e11

	ld a,(wActiveRoom)		; $6e12
	cp $38			; $6e15
	jr nz,+			; $6e17

	ld a,($c848)		; $6e19
	and $01			; $6e1c
	ret z			; $6e1e

	ld hl,hFF8D		; $6e1f
	inc (hl)		; $6e22
	inc (hl)		; $6e23
	scf			; $6e24
	ret			; $6e25
+
	xor a			; $6e26
	ret			; $6e27

;;
; @param[out]	cflag	Set if the current room is flooded in jabu-jabu?
; @addr{6e28}
@checkJabuFlooded:

.ifdef ROM_AGES
	ld a,(wDungeonIndex)		; $6e28
	cp $07			; $6e2b
	jr nz,++		; $6e2d

	ld a,(wAreaFlags)		; $6e2f
	and AREAFLAG_SIDESCROLL			; $6e32
	jr nz,++		; $6e34

	ld a,$11		; $6e36
	ld (wDungeonFirstLayout),a		; $6e38
	callab bank1.findActiveRoomInDungeonLayoutWithPointlessBankSwitch		; $6e3b
	ld a,(wJabuWaterLevel)		; $6e43
	and $07			; $6e46
	ld hl,@data		; $6e48
	rst_addAToHl			; $6e4b
	ld a,(wDungeonFloor)		; $6e4c
	ld bc,bitTable		; $6e4f
	add c			; $6e52
	ld c,a			; $6e53
	ld a,(bc)		; $6e54
	and (hl)		; $6e55
	ret z			; $6e56

	ldh a,(<hFF8D)	; $6e57
	inc a			; $6e59
	ldh (<hFF8D),a	; $6e5a
	scf			; $6e5c
	ret			; $6e5d
++
	xor a			; $6e5e
	ret			; $6e5f

; @addr{6e60}
@data:
	.db $00 $01 $03

.endif

;;
; @addr{6e63}
func_04_6e63:
	ld a,(wActiveCollisions)		; $6e63
	or a			; $6e66
	jr nz,@done		; $6e68

	ld a,(wAreaFlags)		; $6e6a
	and AREAFLAG_PAST			; $6e6d
	jr z,@done		; $6e6e

	ld a,(wActiveRoom)		; $6e70
	cp $38			; $6e73
	ret z			; $6e75

	ld a,$03		; $6e76
	ld ($ff00+R_SVBK),a	; $6e78
	ld hl,$d204		; $6e7a
	ld d,$06		; $6e7d
---
	ld b,$04		; $6e7f
--
	ld a,(hl)		; $6e81
	and $07			; $6e82
	cp d			; $6e84
	jr nz,+			; $6e85

	ld a,(hl)		; $6e87
	and $f8			; $6e88
	ld (hl),a		; $6e8a
+
	inc hl			; $6e8b
	dec b			; $6e8c
	jr nz,--		; $6e8d

	ld a,$04		; $6e8f
	rst_addAToHl			; $6e91
	ld a,h			; $6e92
	cp $d4			; $6e93
	jr c,---		; $6e95
@done:
	xor a			; $6e97
	ld ($ff00+R_SVBK),a	; $6e98
	ret			; $6e9a

;;
; @addr{6e9b}
func_04_6e9b:
	ld a,$02		; $6e9b
	ld ($ff00+R_SVBK),a	; $6e9d
	ld hl,wRoomLayout		; $6e9f
	ld de,$d000		; $6ea2
	ld b,$c0		; $6ea5
	call copyMemory		; $6ea7
	ld hl,wRoomCollisions		; $6eaa
	ld de,$d100		; $6ead
	ld b,$c0		; $6eb0
	call copyMemory		; $6eb2
	ld hl,$df00		; $6eb5
	ld de,$d200		; $6eb8
	ld b,$c0		; $6ebb
--
	ld a,$03		; $6ebd
	ld ($ff00+R_SVBK),a	; $6ebf
	ldi a,(hl)		; $6ec1
	ld c,a			; $6ec2
	ld a,$02		; $6ec3
	ld ($ff00+R_SVBK),a	; $6ec5
	ld a,c			; $6ec7
	ld (de),a		; $6ec8
	inc de			; $6ec9
	dec b			; $6eca
	jr nz,--		; $6ecb

	xor a			; $6ecd
	ld ($ff00+R_SVBK),a	; $6ece
	ret			; $6ed0

;;
; @addr{6ed1}
func_04_6ed1:
	ld a,$02		; $6ed1
	ld ($ff00+R_SVBK),a	; $6ed3
	ld hl,wRoomLayout		; $6ed5
	ld de,$d000		; $6ed8
	ld b,$c0		; $6edb
	call copyMemoryReverse		; $6edd
	ld hl,wRoomCollisions		; $6ee0
	ld de,$d100		; $6ee3
	ld b,$c0		; $6ee6
	call copyMemoryReverse		; $6ee8
	ld hl,$df00		; $6eeb
	ld de,$d200		; $6eee
	ld b,$c0		; $6ef1
--
	ld a,$02		; $6ef3
	ld ($ff00+R_SVBK),a	; $6ef5
	ld a,(de)		; $6ef7
	inc de			; $6ef8
	ld c,a			; $6ef9
	ld a,$03		; $6efa
	ld ($ff00+R_SVBK),a	; $6efc
	ld a,c			; $6efe
	ldi (hl),a		; $6eff
	dec b			; $6f00
	jr nz,--		; $6f01

	xor a			; $6f03
	ld ($ff00+R_SVBK),a	; $6f04
	ret			; $6f06

;;
; @addr{6f07}
func_04_6f07:
	ld hl,$d800		; $6f07
	ld de,$dc00		; $6f0a
	ld bc,$0200		; $6f0d
	call @locFunc		; $6f10
	ld hl,$dc00		; $6f13
	ld de,$de00		; $6f16
	ld bc,$0200		; $6f19
@locFunc:
	ld a,$03		; $6f1c
	ld ($ff00+R_SVBK),a	; $6f1e
	ldi a,(hl)		; $6f20
	ldh (<hFF8B),a	; $6f21
	ld a,$06		; $6f23
	ld ($ff00+R_SVBK),a	; $6f25
	ldh a,(<hFF8B)	; $6f27
	ld (de),a		; $6f29
	inc de			; $6f2a
	dec bc			; $6f2b
	ld a,b			; $6f2c
	or c			; $6f2d
	jr nz,@locFunc		; $6f2e
	ret			; $6f30

;;
; @addr{6f31}
func_04_6f31:
	ld hl,$dc00		; $6f31
	ld de,$d800		; $6f34
	ld bc,$0200		; $6f37
	call @locFunc		; $6f3a
	ld hl,$de00		; $6f3d
	ld de,$dc00		; $6f40
	ld bc,$0200		; $6f43
@locFunc:
	ld a,$06		; $6f46
	ld ($ff00+R_SVBK),a	; $6f48
	ldi a,(hl)		; $6f4a
	ldh (<hFF8B),a	; $6f4b
	ld a,$03		; $6f4d
	ld ($ff00+R_SVBK),a	; $6f4f
	ldh a,(<hFF8B)	; $6f51
	ld (de),a		; $6f53
	inc de			; $6f54
	dec bc			; $6f55
	ld a,b			; $6f56
	or c			; $6f57
	jr nz,@locFunc	; $6f58
	ret			; $6f5a

; .ORGA $6f5b

.include "build/data/warpData.s"


.ifdef BUILD_VANILLA

; Garbage data? Looks like a partial repeat of the last warp.
; @addr{7ede}
unknownData7ede:
	.db $ef $44 $43 $ff ; $7ede

.endif


.BANK $05 SLOT 1
.ORG 0

 m_section_force "Bank_5" NAMESPACE bank5

;;
; @addr{4000}
updateSpecialObjects:
	ld hl,wLinkIDOverride		; $4000
	ld a,(hl)		; $4003
	ld (hl),$00		; $4004
	or a			; $4006
	jr z,+			; $4007
	and $7f			; $4009
	ld (w1Link.id),a		; $400b
+
	ld hl,w1Link.var2f		; $400e
	ld a,(hl)		; $4011
	and $3f			; $4012
	ld (hl),a		; $4014

.ifdef ROM_AGES
	ld a,TREASURE_MERMAID_SUIT		; $4015
	call checkTreasureObtained		; $4017
	jr nc,+			; $401a
	set 6,(hl)		; $401c
+
	ld a,(wAreaFlags)		; $401e
	and AREAFLAG_UNDERWATER			; $4021
	jr z,+			; $4023
	set 7,(hl)		; $4025
+
.endif

	xor a			; $4027
	ld (wBraceletGrabbingNothing),a		; $4028
	ld (wcc92),a		; $402b
	ld (wForceLinkPushAnimation),a		; $402e

	ld hl,wcc95		; $4031
	ld a,(hl)		; $4034
	or $7f			; $4035
	ld (hl),a		; $4037

	ld hl,wLinkTurningDisabled		; $4038
	res 7,(hl)		; $403b

	call _updateGameKeysPressed		; $403d

	ld hl,w1Companion		; $4040
	call @updateSpecialObject		; $4043

	xor a			; $4046
	ld (wLinkClimbingVine),a		; $4047
	ld (wDisallowMountingCompanion),a		; $404a

	ld hl,w1Link		; $404d
	call @updateSpecialObject		; $4050

	call _updateLinkInvincibilityCounter		; $4053

	ld a,(wLinkPlayingInstrument)		; $4056
	ld (wLinkRidingObject),a		; $4059

	ld hl,wLinkImmobilized		; $405c
	ld a,(hl)		; $405f
	and $0f			; $4060
	ld (hl),a		; $4062

	xor a			; $4063
	ld (wcc67),a		; $4064
	ld (w1Link.var2a),a		; $4067
	ld (wccd8),a		; $406a

	ld hl,wInstrumentsDisabledCounter		; $406d
	ld a,(hl)		; $4070
	or a			; $4071
	jr z,+			; $4072
	dec (hl)		; $4074
+
	ld hl,wGrabbableObjectBuffer		; $4075
	ld b,$10		; $4078
	jp clearMemory		; $407a

;;
; @param hl Object to update (w1Link or w1Companion)
; @addr{407d}
@updateSpecialObject:
	ld a,(hl)		; $407d
	or a			; $407e
	ret z			; $407f

	ld a,l			; $4080
	ldh (<hActiveObjectType),a	; $4081
	ld a,h			; $4083
	ldh (<hActiveObject),a	; $4084
	ld d,h			; $4086

	ld l,Object.id		; $4087
	ld a,(hl)		; $4089
	rst_jumpTable			; $408a
	.dw  specialObjectCode_link
	.dw  specialObjectCode_transformedLink
	.dw  specialObjectCode_transformedLink
	.dw  specialObjectCode_transformedLink
	.dw  specialObjectCode_transformedLink
	.dw  specialObjectCode_transformedLink
	.dw  specialObjectCode_transformedLink
	.dw  specialObjectCode_transformedLink
	.dw  specialObjectCode_linkInCutscene
	.dw  specialObjectCode_linkRidingAnimal
	.dw _specialObjectCode_minecart
	.dw _specialObjectCode_ricky
	.dw _specialObjectCode_dimitri
	.dw _specialObjectCode_moosh
	.dw _specialObjectCode_maple
	.dw  specialObjectCode_companionCutscene
	.dw  specialObjectCode_companionCutscene
	.dw  specialObjectCode_companionCutscene
	.dw  specialObjectCode_companionCutscene
	.dw _specialObjectCode_raft

;;
; Updates wGameKeysPressed based on wKeysPressed, and updates wLinkAngle based on
; direction buttons pressed.
; @addr{40b3}
_updateGameKeysPressed:
	ld a,(wKeysPressed)		; $40b3
	ld c,a			; $40b6

	ld a,(wUseSimulatedInput)		; $40b7
	or a			; $40ba
	jr z,@updateKeysPressed_c	; $40bb

	cp $02			; $40bd
	jr z,@reverseMovement			; $40bf

	call getSimulatedInput		; $40c1
	jr @updateKeysPressed_a		; $40c4

	; This code is used in the Ganon fight where he reverses Link's movement?
@reverseMovement:
	xor a			; $40c6
	ld (wUseSimulatedInput),a		; $40c7
	ld a,BTN_DOWN | BTN_LEFT		; $40ca
	and c			; $40cc
	rrca			; $40cd
	ld b,a			; $40ce

	ld a,BTN_UP | BTN_RIGHT		; $40cf
	and c			; $40d1
	rlca			; $40d2
	or b			; $40d3
	ld b,a			; $40d4

	ld a,$0f		; $40d5
	and c			; $40d7
	or b			; $40d8

@updateKeysPressed_a:
	ld c,a			; $40d9
@updateKeysPressed_c:
	ld a,(wLinkDeathTrigger)		; $40da
	or a			; $40dd
	ld hl,wGameKeysPressed		; $40de
	jr nz,@dying		; $40e1

	; Update wGameKeysPressed, wGameKeysJustPressed based on the value of 'c'.
	ld a,(hl)		; $40e3
	cpl			; $40e4
	ld b,a			; $40e5
	ld a,c			; $40e6
	ldi (hl),a		; $40e7
	and b			; $40e8
	ldi (hl),a		; $40e9

	; Update Link's angle based on the direction buttons pressed.
	ld a,c			; $40ea
	and $f0			; $40eb
	swap a			; $40ed
	ld hl,@directionButtonToAngle		; $40ef
	rst_addAToHl			; $40f2
	ld a,(hl)		; $40f3
	ld (wLinkAngle),a		; $40f4
	ret			; $40f7

@dying:
	; Clear wGameKeysPressed, wGameKeysJustPressed
	xor a			; $40f8
	ldi (hl),a		; $40f9
	ldi (hl),a		; $40fa

	; Set wLinkAngle to $ff
	dec a			; $40fb
	ldi (hl),a		; $40fc
	ret			; $40fd

; Index is direction buttons pressed, value is the corresponding angle.
@directionButtonToAngle:
	.db $ff $08 $18 $ff $00 $04 $1c $ff
	.db $10 $0c $14 $ff $ff $ff $ff

;;
; This is called when Link is riding something (wLinkObjectIndex == $d1).
;
; @addr{410d}
func_410d:
	xor a			; $410d
	ldh (<hActiveObjectType),a	; $410e
	ld de,w1Companion.id		; $4110
	ld a,d			; $4113
	ldh (<hActiveObject),a	; $4114
	ld a,(de)		; $4116
	sub SPECIALOBJECTID_MINECART			; $4117
	rst_jumpTable			; $4119

	.dw @ridingMinecart
	.dw @ridingRicky
	.dw @ridingDimitri
	.dw @ridingMoosh
	.dw @invalid
	.dw @invalid
	.dw @invalid
	.dw @invalid
	.dw @invalid
	.dw @ridingRaft

@invalid:
	ret			; $412e

@ridingRicky:
	ld bc,$0000		; $412f
	jr @companion		; $4132

@ridingDimitri:
	ld e,<w1Companion.direction		; $4134
	ld a,(de)		; $4136
	rrca			; $4137
	ld bc,$f600		; $4138
	jr nc,@companion	; $413b

	ld c,$fb		; $413d
	rrca			; $413f
	jr nc,@companion	; $4140

	ld c,$05		; $4142
	jr @companion		; $4144

@ridingMoosh:
	ld e,SpecialObject.direction		; $4146
	ld a,(de)		; $4148
	rrca			; $4149
	ld bc,$f200		; $414a
	jr nc,@companion	; $414d
	ld b,$f0		; $414f

;;
; @param	bc	Position offset relative to companion to place Link at
; @addr{4151}
@companion:
	ld hl,w1Link.yh		; $4151
	call objectCopyPositionWithOffset		; $4154

	ld e,<w1Companion.direction		; $4157
	ld l,<w1Link.direction		; $4159
	ld a,(de)		; $415b
	ld (hl),a		; $415c
	ld a,$01		; $415d
	ld (wcc90),a		; $415f

	ld l,<w1Link.var2a		; $4162
	ldi a,(hl)		; $4164
	or (hl)			; $4165
	ld l,<w1Link.knockbackCounter		; $4166
	or (hl)			; $4168
	jr nz,@noDamage		; $4169
	ld l,<w1Link.damageToApply		; $416b
	ld e,l			; $416d
	ld a,(de)		; $416e
	or a			; $416f
	jr z,@noDamage		; $4170

	ldi (hl),a ; [w1Link.damageToApply] = [w1Companion.damageToApply]

	; Copy health, var2a, invincibilityCounter, knockbackAngle, knockbackCounter,
	; stunCounter from companion to Link.
	ld l,<w1Link.health		; $4173
	ld e,l			; $4175
	ld b,$06		; $4176
	call copyMemoryReverse		; $4178
	jr @label_05_010		; $417b

@noDamage:
	ld l,<w1Link.damageToApply		; $417d
	ld e,l			; $417f
	ld a,(hl)		; $4180
	ld (de),a		; $4181

	; Copy health, var2a, invincibilityCounter, knockbackAngle, knockbackCounter,
	; stunCounter from Link to companion.
	ld d,>w1Link		; $4182
	ld h,>w1Companion		; $4184
	ld l,SpecialObject.health		; $4186
	ld e,l			; $4188
	ld b,$06		; $4189
	call copyMemoryReverse		; $418b

@label_05_010:
	ld h,>w1Link		; $418e
	ld d,>w1Companion		; $4190
	ld l,<w1Link.oamFlags		; $4192
	ld a,(hl)		; $4194
	ld l,<w1Link.oamFlagsBackup		; $4195
	cp (hl)			; $4197
	jr nz,+			; $4198
	ld e,<w1Companion.oamFlagsBackup		; $419a
	ld a,(de)		; $419c
+
	ld e,<w1Companion.oamFlags		; $419d
	ld (de),a		; $419f
	ld l,<w1Link.visible		; $41a0
	ld e,l			; $41a2
	ld a,(de)		; $41a3
	and $83			; $41a4
	ld (hl),a		; $41a6
	ret			; $41a7

@ridingMinecart:
	ld h,d			; $41a8
	ld l,<w1Companion.direction		; $41a9
	ld a,(hl)		; $41ab
	ld l,<w1Companion.animParameter		; $41ac
	add (hl)		; $41ae
	ld hl,@linkOffsets		; $41af
	rst_addDoubleIndex			; $41b2
	ldi a,(hl)		; $41b3
	ld c,(hl)		; $41b4
	ld b,a			; $41b5
	ld hl,w1Link.yh		; $41b6
	call objectCopyPositionWithOffset		; $41b9

	; Disable terrain effects on Link
	ld l,<w1Link.visible		; $41bc
	res 6,(hl)		; $41be

	ret			; $41c0


; Data structure:
;   Each row corresponds to a frame of the minecart animation.
;   Each column corresponds to a direction.
;   Each 2 bytes are a position offset for Link relative to the minecart.
@linkOffsets:
;           --Up--   --Right-- --Down-- --Left--
	.db $f7 $00  $f7 $00   $f7 $00  $f7 $00
	.db $f7 $ff  $f8 $00   $f7 $ff  $f8 $00

;;
; @addr{41d1}
@ridingRaft:
	ld a,(wLinkForceState)		; $41d1
	cp LINK_STATE_RESPAWNING			; $41d4
	ret z			; $41d6

	ld hl,w1Link.state		; $41d7
	ldi a,(hl)		; $41da
	cp LINK_STATE_RESPAWNING			; $41db
	jr nz,++		; $41dd
	ldi a,(hl) ; Check w1Link.state2
	cp $03			; $41e0
	ret c			; $41e2
++
	; Disable terrain effects on Link
	ld l,<w1Link.visible		; $41e3
	res 6,(hl)		; $41e5

	; Set Link's position to be 5 or 6 pixels above the raft, depending on the frame
	; of animation
	ld bc,$fb00		; $41e7
	ld e,<w1Companion.animParameter		; $41ea
	ld a,(de)		; $41ec
	or a			; $41ed
	jr z,+			; $41ee
	dec b			; $41f0
+
	call objectCopyPositionWithOffset		; $41f1
	jp objectSetVisiblec3		; $41f4

;;
; Initializes SpecialObject.oamFlags and SpecialObject.oamTileIndexBase, according to the
; id of the object.
;
; @param	d	Object
; @addr{41f7}
specialObjectSetOamVariables:
	ld e,SpecialObject.var32		; $41f7
	ld a,$ff		; $41f9
	ld (de),a		; $41fb

	ld e,SpecialObject.id		; $41fc
	ld a,(de)		; $41fe
	ld hl,@data		; $41ff
	rst_addDoubleIndex			; $4202

	ld e,SpecialObject.oamTileIndexBase		; $4203
	ldi a,(hl)		; $4205
	ld (de),a		; $4206

	; Write to SpecialObject.oamFlags
	dec e			; $4207
	ldi a,(hl)		; $4208
	ld (de),a		; $4209

	; Write flags to SpecialObject.oamFlagsBackup as well
	dec e			; $420a
	ld (de),a		; $420b
	ret			; $420c

; 2 bytes for each SpecialObject id: oamTileIndexBase, oamFlags (palette).
; @addr{420d}
@data:
	.db $70 $08 ; 0x00 (Link)
	.db $70 $08 ; 0x01
	.db $70 $08 ; 0x02
	.db $70 $08 ; 0x03
	.db $70 $08 ; 0x04
	.db $70 $08 ; 0x05
	.db $70 $08 ; 0x06
	.db $70 $08 ; 0x07
	.db $70 $08 ; 0x08
	.db $70 $08 ; 0x09
	.db $60 $0c ; 0x0a (Minecart)
	.db $60 $0b ; 0x0b
	.db $60 $0a ; 0x0c
	.db $60 $09 ; 0x0d
	.db $60 $08 ; 0x0e
	.db $60 $0b ; 0x0f
	.db $60 $0a ; 0x10
	.db $60 $09 ; 0x11
	.db $60 $08 ; 0x12
	.db $60 $0b ; 0x13

;;
; Deals 4 points of damage (1/2 heart?) to link, and applies knockback in the opposite
; direction he is moving.
; @addr{4235}
_dealSpikeDamageToLink:
	ld a,(wLinkRidingObject)		; $4235
	ld b,a			; $4238
	ld h,d			; $4239
	ld l,SpecialObject.invincibilityCounter		; $423a
	or (hl)			; $423c
	ret nz			; $423d

	ld (hl),40 ; 40 frames invincibility

	; Get damage value (4 normally, 2 with red luck ring)
	ld a,RED_LUCK_RING		; $4240
	call cpActiveRing		; $4242
	ld a,-4		; $4245
	jr nz,+			; $4247
	sra a			; $4249
+
	ld l,SpecialObject.damageToApply		; $424b
	add (hl)		; $424d
	ld (hl),a		; $424e

	ld l,SpecialObject.var2a		; $424f
	ld (hl),$80		; $4251

	; 10 frames knockback
	ld l,SpecialObject.knockbackCounter		; $4253
	ld a,10		; $4255
	add (hl)		; $4257
	ld (hl),a		; $4258

	; Calculate knockback angle
	ld e,SpecialObject.angle		; $4259
	ld a,(de)		; $425b
	xor $10			; $425c
	ld l,SpecialObject.knockbackAngle		; $425e
	ld (hl),a		; $4260

	ld a,SND_DAMAGE_LINK		; $4261
	call playSound		; $4263
	jr linkApplyDamage_b5			; $4266

;;
; @addr{4268}
updateLinkDamageTaken:
	callab bank6.linkUpdateDamageToApplyForRings		; $4268

linkApplyDamage_b5:
	callab bank6.linkApplyDamage		; $4270
	ret			; $4278

;;
; @addr{4279}
_updateLinkInvincibilityCounter:
	ld hl,w1Link.invincibilityCounter		; $4279
	ld a,(hl)		; $427c
	or a			; $427d
	ret z			; $427e

	; If $80 or higher, invincibilityCounter goes up and Link doesn't flash red
	bit 7,a			; $427f
	jr nz,@incCounter	; $4281

	; Otherwise it goes down, and Link flashes red
	dec (hl)		; $4283
	jr z,@normalFlags	; $4284

	ld a,(wFrameCounter)		; $4286
	bit 2,a			; $4289
	jr nz,@normalFlags	; $428b

	; Set Link's palette to red
	ld l,SpecialObject.oamFlags		; $428d
	ld (hl),$0d		; $428f
	ret			; $4291

@incCounter:
	inc (hl)		; $4292

@normalFlags:
	ld l,SpecialObject.oamFlagsBackup		; $4293
	ldi a,(hl)		; $4295
	ld (hl),a		; $4296
	ret			; $4297

;;
; Updates wActiveTileIndex, wActiveTileType, and wLastActiveTileType.
;
; NOTE: wLastActiveTileType actually keeps track of the tile BELOW Link when in
; a sidescrolling section.
;
; @addr{4298}
_sidescrollUpdateActiveTile:
	call objectGetTileAtPosition		; $4298
	ld (wActiveTileIndex),a		; $429b

	ld hl,tileTypesTable		; $429e
	call lookupCollisionTable		; $42a1
	ld (wActiveTileType),a		; $42a4

	ld bc,$0800		; $42a7
	call objectGetRelativeTile		; $42aa
	ld hl,tileTypesTable		; $42ad
	call lookupCollisionTable		; $42b0
	ld (wLastActiveTileType),a		; $42b3
	ret			; $42b6

;;
; Does various things based on the tile type of the tile Link is standing on (see
; constants/tileTypes.s).
;
; @param	d	Link object
; @addr{42b7}
_linkApplyTileTypes:
	xor a			; $42b7
	ld (wIsTileSlippery),a		; $42b8
	ld a,(wLinkInAir)		; $42bb
	or a			; $42be
	jp nz,@tileType_normal		; $42bf

	ld (wLinkRaisedFloorOffset),a		; $42c2
	call @linkGetActiveTileType		; $42c5

	ld (wActiveTileType),a		; $42c8
	rst_jumpTable			; $42cb
	.dw @tileType_normal ; TILETYPE_NORMAL
	.dw @tileType_hole ; TILETYPE_HOLE
	.dw @tileType_warpHole ; TILETYPE_WARPHOLE
	.dw @tileType_crackedFloor ; TILETYPE_CRACKEDFLOOR
	.dw @tileType_vines ; TILETYPE_VINES
	.dw @notSwimming ; TILETYPE_GRASS
	.dw @notSwimming ; TILETYPE_STAIRS
	.dw @swimming ; TILETYPE_WATER
	.dw @tileType_stump ; TILETYPE_STUMP
	.dw @tileType_conveyor ; TILETYPE_UPCONVEYOR
	.dw @tileType_conveyor ; TILETYPE_RIGHTCONVEYOR
	.dw @tileType_conveyor ; TILETYPE_DOWNCONVEYOR
	.dw @tileType_conveyor ; TILETYPE_LEFTCONVEYOR
	.dw _dealSpikeDamageToLink ; TILETYPE_SPIKE
	.dw @tileType_nothing ; TILETYPE_NOTHING
	.dw @tileType_ice ; TILETYPE_ICE
	.dw @tileType_lava ; TILETYPE_LAVA
	.dw @tileType_puddle ; TILETYPE_PUDDLE
	.dw @tileType_current ; TILETYPE_UPCURRENT
	.dw @tileType_current ; TILETYPE_RIGHTCURRENT
	.dw @tileType_current ; TILETYPE_DOWNCURRENT
	.dw @tileType_current ; TILETYPE_LEFTCURRENT
	.dw @tiletype_raisableFloor ; TILETYPE_RAISABLE_FLOOR
	.dw @swimming ; TILETYPE_SEAWATER
	.dw @swimming ; TILETYPE_WHIRLPOOL

@tiletype_raisableFloor:
	ld a,-3		; $42fe
	ld (wLinkRaisedFloorOffset),a		; $4300

@tileType_normal:
	xor a			; $4303
	ld (wActiveTileType),a		; $4304
	ld (wStandingOnTileCounter),a		; $4307
	ld (wLinkSwimmingState),a		; $430a
	ret			; $430d

@tileType_puddle:
	ld h,d			; $430e
	ld l,SpecialObject.animParameter		; $430f
	bit 5,(hl)		; $4311
	jr z,@tileType_normal	; $4313

	res 5,(hl)		; $4315
	ld a,(wLinkImmobilized)		; $4317
	or a			; $431a
	ld a,SND_SPLASH		; $431b
	call z,playSound		; $431d
	jr @tileType_normal		; $4320

@tileType_stump:
	ld h,d			; $4322
	ld l,SpecialObject.adjacentWallsBitset		; $4323
	ld (hl),$ff		; $4325
	ld l,SpecialObject.collisionType		; $4327
	res 7,(hl)		; $4329
	jr @notSwimming		; $432b

@tileType_vines:
	call dropLinkHeldItem		; $432d
	ld a,$ff		; $4330
	ld (wLinkClimbingVine),a		; $4332

@notSwimming:
	xor a			; $4335
	ld (wLinkSwimmingState),a		; $4336
	ret			; $4339

@tileType_crackedFloor:
	ld a,ROCS_RING		; $433a
	call cpActiveRing		; $433c
	jr z,@tileType_normal	; $433f

	; Don't break the floor until Link has stood there for 32 frames
	ld a,(wStandingOnTileCounter)		; $4341
	cp 32			; $4344
	jr c,@notSwimming	; $4346

	ld a,(wActiveTilePos)		; $4348
	ld c,a			; $434b
	ld a,TILEINDEX_HOLE		; $434c
	call breakCrackedFloor		; $434e
	xor a			; $4351
	ld (wStandingOnTileCounter),a		; $4352

@tileType_hole:
@tileType_warpHole:
	ld a,(wAreaFlags)		; $4355
	and AREAFLAG_UNDERWATER			; $4358
	jr nz,@tileType_normal	; $435a

	xor a			; $435c
	ld (wLinkSwimmingState),a		; $435d

	ld a,(wLinkRidingObject)		; $4360
	or a			; $4363
	jr nz,@tileType_normal	; $4364

	ld a,(wMagnetGloveState)		; $4366
	bit 6,a			; $4369
	jr nz,@tileType_normal	; $436b

	; Jump if tile type has changed
	ld hl,wLastActiveTileType		; $436d
	ldd a,(hl)		; $4370
	cp (hl)			; $4371
	jr nz,++		; $4372

	; Jump if Link's position has not changed
	ld l,<wActiveTilePos		; $4374
	ldi a,(hl)		; $4376
	cp b			; $4377
	jr z,++			; $4378

	; [wStandingOnTileCounter] = $0e
	inc l			; $437a
	ld a,$0e		; $437b
	ld (hl),a		; $437d
++
	ld a,$80		; $437e
	ld (wcc92),a		; $4380
	jp _linkPullIntoHole		; $4383

@tileType_ice:
	ld a,SNOWSHOE_RING		; $4386
	call cpActiveRing		; $4388
	jr z,@notSwimming	; $438b

	ld hl,wIsTileSlippery		; $438d
	set 6,(hl)		; $4390
	jr @notSwimming		; $4392

@tileType_nothing:
	ret			; $4394

@swimming:
	ld a,(wLinkRidingObject)		; $4395
	or a			; $4398
	jp nz,@tileType_normal		; $4399

	; Run the below code only the moment he gets into the water
	ld a,(wLinkSwimmingState)		; $439c
	or a			; $439f
	ret nz			; $43a0

	ld a,(w1Link.var2f)		; $43a1
	bit 7,a			; $43a4
	ret nz			; $43a6

	xor a			; $43a7
	ld e,SpecialObject.var35		; $43a8
	ld (de),a		; $43aa
	ld e,SpecialObject.knockbackCounter		; $43ab
	ld (de),a		; $43ad

	inc a			; $43ae
	ld (wLinkSwimmingState),a		; $43af

	ld a,$80		; $43b2
	ld (wcc92),a		; $43b4
	ret			; $43b7

@tileType_lava:
	ld a,(wLinkRidingObject)		; $43b8
	or a			; $43bb
	jp nz,@tileType_normal		; $43bc

	ld a,$80		; $43bf
	ld (wcc92),a		; $43c1

	ld e,SpecialObject.knockbackCounter		; $43c4
	xor a			; $43c6
	ld (de),a		; $43c7

	ld a,(wLinkSwimmingState)		; $43c8
	or a			; $43cb
	ret nz			; $43cc

	xor a			; $43cd
	ld e,SpecialObject.var35		; $43ce
	ld (de),a		; $43d0

	ld a,$41		; $43d1
	ld (wLinkSwimmingState),a		; $43d3
	ret			; $43d6

@tileType_conveyor:
	ld a,(wLinkRidingObject)		; $43d7
	or a			; $43da
	jp nz,@tileType_normal		; $43db

	ld a,QUICKSAND_RING		; $43de
	call cpActiveRing		; $43e0
	jp z,@tileType_normal		; $43e3

	ldbc SPEED_80, TILETYPE_UPCONVEYOR		; $43e6

@adjustLinkOnConveyor:
	ld a,$01		; $43e9
	ld (wcc92),a		; $43eb

	; Get angle to move link in c
	ld a,(wActiveTileType)		; $43ee
	sub c			; $43f1
	ld hl,@conveyorAngles		; $43f2
	rst_addAToHl			; $43f5
	ld c,(hl)		; $43f6

	jp specialObjectUpdatePositionGivenVelocity		; $43f7

@conveyorAngles:
	.db $00 $08 $10 $18

@tileType_current:
	ldbc SPEED_c0, TILETYPE_UPCURRENT		; $43fe
	call @adjustLinkOnConveyor		; $4401
	jr @swimming		; $4404

;;
; Gets the tile type of the tile link is standing on (see constants/tileTypes.s).
; Also updates wActiveTilePos, wActiveTileIndex and wLastActiveTileType, but not
; wActiveTileType.
;
; @param	d	Link object
; @param[out]	a	Tile type
; @param[out]	b	Former value of wActiveTilePos
; @addr{4406}
@linkGetActiveTileType:
	ld bc,$0500		; $4406
	call objectGetRelativeTile		; $4409
	ld c,a			; $440c
	ld b,l			; $440d
	ld hl,wActiveTilePos		; $440e
	ldi a,(hl)		; $4411
	cp b			; $4412
	jr nz,+			; $4413

	ld a,(hl)		; $4415
	cp c			; $4416
	jr z,++			; $4417
+
	; Update wActiveTilePos
	ld l,<wActiveTilePos		; $4419
	ld a,(hl)		; $441b
	ld (hl),b		; $441c
	ld b,a			; $441d

	; Update wActiveTileIndex
	inc l			; $441e
	ld (hl),c		; $441f

	; Write $00 to wStandingOnTileCounter
	inc l			; $4420
	ld (hl),$00		; $4421
++
	ld l,<wStandingOnTileCounter		; $4423
	inc (hl)		; $4425

	; Copy wActiveTileType to wLastActiveTileType
	inc l			; $4426
	ldi a,(hl)		; $4427
	ld (hl),a		; $4428

	ld a,c			; $4429
	ld hl,tileTypesTable		; $442a
	jp lookupCollisionTable		; $442d

;;
; Same as below, but operates on SpecialObject.angle, not a given variable.
; @addr{4430}
_linkAdjustAngleInSidescrollingArea:
	ld l,SpecialObject.angle		; $4430

;;
; Adjusts Link's angle in sidescrolling areas when not on a staircase.
; This results in Link only moving in horizontal directions.
;
; @param	l	Angle variable to use
; @addr{4432}
_linkAdjustGivenAngleInSidescrollingArea:
	ld h,d			; $4432
	ld e,l			; $4433

	ld a,(wAreaFlags)		; $4434
	and AREAFLAG_SIDESCROLL			; $4437
	ret z			; $4439

	; Return if angle value >= $80
	bit 7,(hl)		; $443a
	ret nz			; $443c

	ld a,(hl)		; $443d
	ld hl,@horizontalAngleTable		; $443e
	rst_addAToHl			; $4441
	ld a,(hl)		; $4442
	ld (de),a		; $4443
	ret			; $4444

; This table converts an angle value such that it becomes purely horizontal.
@horizontalAngleTable:
	.db $ff $08 $08 $08 $08 $08 $08 $08
	.db $08 $08 $08 $08 $08 $08 $08 $08
	.db $ff $18 $18 $18 $18 $18 $18 $18
	.db $18 $18 $18 $18 $18 $18 $18 $18

;;
; Prevents link from passing object d.
;
; @param	d	The object that Link shall not pass.
; @addr{4465}
_companionPreventLinkFromPassing_noExtraChecks:
	ld hl,w1Link		; $4465
	jp preventObjectHFromPassingObjectD		; $4468

;;
; @addr{446b}
_companionUpdateMovement:
	call _companionCalculateAdjacentWallsBitset		; $446b
	call specialObjectUpdatePosition		; $446e

	; Don't attempt to break tile on ground if in midair
	ld h,d			; $4471
	ld l,SpecialObject.zh		; $4472
	ld a,(hl)		; $4474
	or a			; $4475
	ret nz			; $4476

;;
; Calculate position of the tile beneath the companion's feet, to see if it can be broken
; (just by walking on it)
; @addr{4477}
_companionTryToBreakTileFromMoving:
	ld h,d			; $4477
	ld l,SpecialObject.yh		; $4478
	ld a,(hl)		; $447a
	add $05			; $447b
	ld b,a			; $447d
	ld l,SpecialObject.xh		; $447e
	ld c,(hl)		; $4480

	ld a,BREAKABLETILESOURCE_13		; $4481
	jp tryToBreakTile		; $4483

;;
; @param	d	Special object
; @addr{4486}
_companionCalculateAdjacentWallsBitset:
	ld e,SpecialObject.adjacentWallsBitset		; $4486
	xor a			; $4488
	ld (de),a		; $4489
	ld h,d			; $448a
	ld l,SpecialObject.yh		; $448b
	ld b,(hl)		; $448d
	ld l,SpecialObject.xh		; $448e
	ld c,(hl)		; $4490

	ld a,$01		; $4491
	ldh (<hFF8B),a	; $4493
	ld hl,@offsets		; $4495
--
	ldi a,(hl)		; $4498
	add b			; $4499
	ld b,a			; $449a
	ldi a,(hl)		; $449b
	add c			; $449c
	ld c,a			; $449d
	push hl			; $449e
	call _checkCollisionForCompanion		; $449f
	pop hl			; $44a2
	ldh a,(<hFF8B)	; $44a3
	rla			; $44a5
	ldh (<hFF8B),a	; $44a6
	jr nc,--		; $44a8

	ld e,SpecialObject.adjacentWallsBitset		; $44aa
	ld (de),a		; $44ac
	ret			; $44ad

@offsets:
	.db $fb $fd
	.db $00 $07
	.db $0d $f9
	.db $00 $07
	.db $f5 $f7
	.db $09 $00
	.db $f7 $0b
	.db $09 $00

;;
; @param	bc	Position to check
; @param	d	A special object (should be a companion?)
; @param[out]	cflag	Set if a collision happened
; @addr{44be}
_checkCollisionForCompanion:
	; Animals can't pass through climbable vines
	call getTileAtPosition		; $44be
	ld a,(hl)		; $44c1
	cp TILEINDEX_VINE_BOTTOM			; $44c2
	jr z,@setCollision	; $44c4
	cp TILEINDEX_VINE_MIDDLE			; $44c6
	jr z,@setCollision	; $44c8

	; Check for collision on bottom half of this tile only
	cp TILEINDEX_VINE_TOP			; $44ca
	ld a,$03		; $44cc
	jp z,checkGivenCollision_allowHoles		; $44ce

	ld e,SpecialObject.id		; $44d1
	ld a,(de)		; $44d3
	cp SPECIALOBJECTID_RICKY			; $44d4
	jr nz,@notRicky		; $44d6

	; This condition appears to have no effect either way?
	ld e,SpecialObject.zh		; $44d8
	ld a,(de)		; $44da
	bit 7,a			; $44db
	jr z,@checkCollision	; $44dd
	ld a,(hl)		; $44df
	jr @checkCollision		; $44e0

@notRicky:
	cp SPECIALOBJECTID_DIMITRI			; $44e2
	jr nz,@checkCollision	; $44e4
	ld a,(hl)		; $44e6
	cp SPECIALCOLLISION_fe			; $44e7
	ret nc			; $44e9
	jr @checkCollision		; $44ea

@setCollision:
	scf			; $44ec
	ret			; $44ed

@checkCollision:
	jp checkCollisionPosition_disallowSmallBridges		; $44ee

;;
; @param	d	Special object
; @param	hl	Table which takes object's direction as an index
; @param[out]	a	Collision value of tile at object's position + offset
; @param[out]	b	Tile index at object's position + offset
; @param[out]	hl	Address of collision value
; @addr{44f1}
_specialObjectGetRelativeTileWithDirectionTable:
	ld e,SpecialObject.direction		; $44f1
	ld a,(de)		; $44f3
	rst_addDoubleIndex			; $44f4

;;
; @param	d	Special object
; @param	hl	Address of Y/X offsets to use relative to object
; @param[out]	a	Collision value of tile at object's position + offset
; @param[out]	b	Tile index at object's position + offset
; @param[out]	hl	Address of collision value
; @addr{44f5}
_specialObjectGetRelativeTileFromHl:
	ldi a,(hl)		; $44f5
	ld b,a			; $44f6
	ld c,(hl)		; $44f7
	call objectGetRelativeTile		; $44f8
	ld b,a			; $44fb
	ld h,>wRoomCollisions		; $44fc
	ld a,(hl)		; $44fe
	ret			; $44ff

;;
; @param[out]	zflag	nz if an object is moving away from a wall
; @addr{4500}
_specialObjectCheckMovingAwayFromWall:
	; Check that the object is trying to move
	ld h,d			; $4500
	ld l,SpecialObject.angle		; $4501
	ld a,(hl)		; $4503
	cp $ff			; $4504
	ret z			; $4506

	; Invert angle
	add $10			; $4507
	and $1f			; $4509
	ld (hl),a		; $450b

	call _specialObjectCheckFacingWall		; $450c
	ld c,a			; $450f

	; Uninvert angle
	ld l,SpecialObject.angle		; $4510
	ld a,(hl)		; $4512
	add $10			; $4513
	and $1f			; $4515
	ld (hl),a		; $4517

	ld a,c			; $4518
	or a			; $4519
	ret			; $451a

;;
; Checks if an object is directly against a wall and trying to move toward it
;
; @param	d	Special object
; @param[out]	a	The bits from adjacentWallsBitset corresponding to the direction
;			it's moving in
; @param[out]	zflag	nz if an object is moving toward a wall
; @addr{451b}
_specialObjectCheckMovingTowardWall:
	; Check that the object is trying to move
	ld h,d			; $451b
	ld l,SpecialObject.angle		; $451c
	ld a,(hl)		; $451e
	cp $ff			; $451f
	ret z			; $4521

;;
; @param	a	Should equal object's angle value
; @param	h	Special object
; @param[out]	a	The bits from adjacentWallsBitset corresponding to the direction
;			it's moving in
; @addr{4522}
_specialObjectCheckFacingWall:
	ld bc,$0000		; $4522

	; Check if straight left or right
	cp $08			; $4525
	jr z,@checkVertical	; $4527
	cp $18			; $4529
	jr z,@checkVertical	; $452b

	ld l,SpecialObject.adjacentWallsBitset		; $452d
	ld b,(hl)		; $452f
	add a			; $4530
	swap a			; $4531
	and $03
	ld a,$30		; $4535
	jr nz,+			; $4537
	ld a,$c0		; $4539
+
	and b			; $453b
	ld b,a			; $453c

@checkVertical:
	; Check if straight up or down
	ld l,SpecialObject.angle		; $453d
	ld a,(hl)		; $453f
	and $0f			; $4540
	jr z,@ret		; $4542

	ld a,(hl)		; $4544
	ld l,SpecialObject.adjacentWallsBitset		; $4545
	ld c,(hl)		; $4547
	bit 4,a ; Check if angle is to the left
	ld a,$03		; $454a
	jr z,+			; $454c
	ld a,$0c		; $454e
+
	and c			; $4550
	ld c,a			; $4551

@ret:
	ld a,b			; $4552
	or c			; $4553
	ret			; $4554

;;
; Create an item which deals damage 7.
;
; @param	bc	Item ID
; @addr{4555}
_companionCreateItem:
	call getFreeItemSlot		; $4555
	ret nz			; $4558
	jr ++			; $4559

;;
; Create the weapon item which deals damage 7.
;
; @param	bc	Item ID
; @addr{455b}
_companionCreateWeaponItem:
	ld hl,w1WeaponItem.enabled		; $455b
	ld a,(hl)		; $455e
	or a			; $455f
	ret nz			; $4560
++
	inc (hl)		; $4561
	inc l			; $4562
	ld (hl),b		; $4563
	inc l			; $4564
	ld (hl),c		; $4565
	ld l,Item.damage		; $4566
	ld (hl),-7		; $4568
	xor a			; $456a
	ret			; $456b

;;
; Animates a companion, also checks whether the animation needs to change based on
; direction.
;
; @param	c	Base animation index?
; @addr{456c}
_companionUpdateDirectionAndAnimate:
	ld e,SpecialObject.direction		; $456c
	ld a,(de)		; $456e
	ld (w1Link.direction),a		; $456f
	ld e,SpecialObject.state		; $4572
	ld a,(de)		; $4574
	cp $0c			; $4575
	jp z,specialObjectAnimate		; $4577

	call updateLinkDirectionFromAngle		; $457a
	ld hl,w1Companion.direction		; $457d
	cp (hl)			; $4580
	jp z,specialObjectAnimate		; $4581

;;
; Same as below, but updates the companion's direction based on its angle first?
;
; @param	c	Base animation index?
; @addr{4584}
_companionUpdateDirectionAndSetAnimation:
	ld e,SpecialObject.angle		; $4584
	ld a,(de)		; $4586
	add a			; $4587
	swap a			; $4588
	and $03			; $458a
	dec e			; $458c
	ld (de),a		; $458d

;;
; @param	c	Base animation index? (Added with direction, var38)
; @addr{458e}
_companionSetAnimation:
	ld h,d			; $458e
	ld a,c			; $458f
	ld l,SpecialObject.direction		; $4590
	add (hl)		; $4592
	ld l,SpecialObject.var38		; $4593
	add (hl)		; $4595
	jp specialObjectSetAnimation		; $4596

;;
; Relates to mounting a companion?
;
; @param[out]	zflag	Set if mounted successfully?
; @addr{4599}
_companionTryToMount:
	ld a,(wActiveTileType)		; $4599
	cp TILETYPE_HOLE			; $459c
	jr z,@cantMount	; $459e
	ld a,(wDisallowMountingCompanion)		; $45a0
	or a			; $45a3
	jr nz,@cantMount	; $45a4

	call checkLinkVulnerableAndIDZero		; $45a6
	jr c,@tryMounting	; $45a9

@cantMount:
	or d			; $45ab
	ret			; $45ac

@tryMounting:
	ld a,(w1Link.state)		; $45ad
	cp LINK_STATE_NORMAL			; $45b0
	ret nz			; $45b2
	ld a,(wLinkSwimmingState)		; $45b3
	or a			; $45b6
	ret nz			; $45b7
	ld a,(wLinkGrabState)		; $45b8
	or a			; $45bb
	ret nz			; $45bc
	ld a,(wLinkInAir)		; $45bd
	or a			; $45c0
	ret nz			; $45c1

	; Link can mount the companion. Set up all variables accordingly.

	inc a			; $45c2
	ld (wcc90),a		; $45c3
	ld (wWarpsDisabled),a		; $45c6
	ld e,SpecialObject.state		; $45c9
	ld a,$03		; $45cb
	ld (de),a		; $45cd

	ld a,$ff		; $45ce

;;
; Sets Link's speed and speedZ to be the values needed for mounting or dismounting
; a companion.
;
; @param	a	Link's angle
; @addr{45d0}
_setLinkMountingSpeed:
	ld (wLinkAngle),a		; $45d0
	ld a,$81		; $45d3
	ld (wLinkInAir),a		; $45d5
	ld (wDisableScreenTransitions),a		; $45d8
	ld hl,w1Link.angle		; $45db
	ld (hl),a		; $45de

	ld l,<w1Link.speed		; $45df
	ld (hl),SPEED_80		; $45e1

	ld l,<w1Link.speedZ		; $45e3
	ld (hl),$40		; $45e5
	inc l			; $45e7
	ld (hl),$fe		; $45e8
	xor a			; $45ea
	ret			; $45eb

;;
; @param[out]	a	Hazard type (see "objectCheckIsOnHazard")
; @param[out]	cflag	Set if the companion is on a hazard
; @addr{45ec}
_companionCheckHazards:
	call objectCheckIsOnHazard		; $45ec
	ld h,d			; $45ef
	ret nc			; $45f0

;;
; Sets a companion's state to 4, which handles falling in a hazard.
; @addr{45f1}
_companionGotoHazardHandlingState:
	push af			; $45f1
	ld l,SpecialObject.state		; $45f2
	ld a,$04		; $45f4
	ldi (hl),a		; $45f6
	xor a			; $45f7
	ldi (hl),a ; [state2] = 0
	ldi (hl),a ; [counter1] = 0

	ld l,SpecialObject.id		; $45fa
	ld a,(hl)		; $45fc
	cp SPECIALOBJECTID_DIMITRI			; $45fd
	jr z,@ret	; $45ff
	ld (wDisableScreenTransitions),a		; $4601
	ld a,SND_SPLASH		; $4604
	call playSound		; $4606
@ret:
	pop af			; $4609
	scf			; $460a
	ret			; $460b

;;
; @addr{460c}
companionDismountAndSavePosition:
	call companionDismount		; $460c

	; The below code checks your animal companion, but ultimately appears to do the
	; same thing in all cases.

	ld e,SpecialObject.id		; $460f
	ld a,(de)		; $4611
	ld hl,wAnimalCompanion		; $4612
	cp (hl)			; $4615
	jr z,@normalDismount	; $4616

	cp SPECIALOBJECTID_RICKY			; $4618
	jr z,@ricky		; $461a
	cp SPECIALOBJECTID_DIMITRI			; $461c
	jr z,@dimitri		; $461e
@moosh:
	jr @normalDismount		; $4620
@ricky:
	jr @normalDismount		; $4622
@dimitri:
	jr @normalDismount		; $4624

	; Unused code? (dismount and don't save companion's position)
	call saveLinkLocalRespawnAndCompanionPosition		; $4626
	xor a			; $4629
	ld (wRememberedCompanionId),a		; $462a
	ret			; $462d

@normalDismount:
	jr saveLinkLocalRespawnAndCompanionPosition		; $462e

;;
; Called when dismounting an animal companion
;
; @addr{4630}
companionDismount:
	lda SPECIALOBJECTID_LINK			; $4630
	call setLinkID		; $4631
	ld hl,w1Link.oamFlagsBackup		; $4634
	ldi a,(hl)		; $4637
	ldd (hl),a		; $4638

	ld h,d			; $4639
	ldi a,(hl)		; $463a
	ld (hl),a		; $463b

	xor a			; $463c
	ld l,SpecialObject.damageToApply		; $463d
	ld (hl),a		; $463f

	; Clear invincibilityCounter, knockbackAngle, knockbackCounter
	ld l,SpecialObject.invincibilityCounter		; $4640
	ldi (hl),a		; $4642
	ldi (hl),a		; $4643
	ld (hl),a		; $4644

	ld l,SpecialObject.var3c		; $4645
	ld (hl),a		; $4647

	ld (wLinkForceState),a		; $4648
	ld (wcc50),a		; $464b

	ld l,SpecialObject.enabled		; $464e
	ld (hl),$01		; $4650

	; Calculate angle based on direction
	ld l,SpecialObject.direction		; $4652
	ldi a,(hl)		; $4654
	swap a			; $4655
	srl a			; $4657
	ld (hl),a		; $4659

	call _setLinkMountingSpeed		; $465a

	ld hl,w1Link.angle		; $465d
	ld (hl),$ff		; $4660

	call objectCopyPosition		; $4662

	; Set w1Link.zh to $f8
	dec l			; $4665
	ld (hl),$f8		; $4666

	; Set wLinkObjectIndex to $d0 (no longer riding an animal)
	ld a,h			; $4668
	ld (wLinkObjectIndex),a		; $4669

	xor a			; $466c
	ld (wcc90),a		; $466d
	ld (wWarpsDisabled),a		; $4670
	ld (wForceCompanionDismount),a		; $4673
	ld (wDisableScreenTransitions),a		; $4676
	jp setCameraFocusedObjectToLink		; $4679

;;
; @addr{467c}
saveLinkLocalRespawnAndCompanionPosition:
	ld hl,wRememberedCompanionId		; $467c
	ld a,(w1Companion.id)		; $467f
	ldi (hl),a		; $4682

	ld a,(wActiveGroup)		; $4683
	ldi (hl),a		; $4686
	ld a,(wActiveRoom)		; $4687
	ldi (hl),a		; $468a

	ld a,(w1Companion.direction)		; $468b
	ld (wLinkLocalRespawnDir),a		; $468e

	ld a,(w1Companion.yh)		; $4691
	ldi (hl),a		; $4694
	ld (wLinkLocalRespawnY),a		; $4695

	ld a,(w1Companion.xh)		; $4698
	ldi (hl),a		; $469b
	ld (wLinkLocalRespawnX),a		; $469c
	ret			; $469f

;;
; @param[out]	zflag	Set if the companion has reached the center of the hole
; @addr{46a0}
_companionDragToCenterOfHole:
	ld e,SpecialObject.var3d		; $46a0
	ld a,(de)		; $46a2
	or a			; $46a3
	jr z,+			; $46a4
	xor a			; $46a6
	ret			; $46a7
+
	; Get the center of the hole tile in bc
	ld bc,$0500		; $46a8
	call objectGetRelativeTile		; $46ab
	ld c,l			; $46ae
	call convertShortToLongPosition_paramC		; $46af

	; Now drag the companion's X and Y values toward the hole by $40 subpixels per
	; frame (for X and Y).
@adjustX:
	ld e,SpecialObject.xh		; $46b2
	ld a,(de)		; $46b4
	cp c			; $46b5
	ld c,$00		; $46b6
	jr z,@adjustY		; $46b8

	ld hl, $40		; $46ba
	jr c,+			; $46bd
	ld hl,-$40		; $46bf
+
	; [SpecialObject.x] += hl
	dec e			; $46c2
	ld a,(de)		; $46c3
	add l			; $46c4
	ld (de),a		; $46c5
	inc e			; $46c6
	ld a,(de)		; $46c7
	adc h			; $46c8
	ld (de),a		; $46c9

	dec c			; $46ca

@adjustY:
	ld e,SpecialObject.yh		; $46cb
	ld a,(de)		; $46cd
	cp b			; $46ce
	jr z,@return		; $46cf

	ld hl, $40		; $46d1
	jr c,+			; $46d4
	ld hl,-$40		; $46d6
+
	; [SpecialObject.y] += hl
	dec e			; $46d9
	ld a,(de)		; $46da
	add l			; $46db
	ld (de),a		; $46dc
	inc e			; $46dd
	ld a,(de)		; $46de
	adc h			; $46df
	ld (de),a		; $46e0

	dec c			; $46e1

@return:
	ld h,d			; $46e2
	ld a,c			; $46e3
	or a			; $46e4
	ret			; $46e5

;;
; @addr{46e6}
_companionRespawn:
	xor a			; $46e6
	ld (wDisableScreenTransitions),a		; $46e7
	ld (wLinkForceState),a		; $46ea
	ld (wcc50),a		; $46ed

	; Set animal's position to respawn point, then check if the position is valid
	call specialObjectSetCoordinatesToRespawnYX		; $46f0
	call objectCheckSimpleCollision		; $46f3
	jr nz,@invalidPosition		; $46f6

	call objectGetPosition		; $46f8
	call _checkCollisionForCompanion		; $46fb
	jr c,@invalidPosition	; $46fe

	call objectCheckIsOnHazard		; $4700
	jr nc,@applyDamageAndSetState	; $4703

@invalidPosition:
	; Current position is invalid, so change respawn to the last animal mount point
	ld h,d			; $4705
	ld l,SpecialObject.yh		; $4706
	ld a,(wLastAnimalMountPointY)		; $4708
	ld (wLinkLocalRespawnY),a		; $470b
	ldi (hl),a		; $470e
	inc l			; $470f
	ld a,(wLastAnimalMountPointX)		; $4710
	ld (wLinkLocalRespawnX),a		; $4713
	ldi (hl),a		; $4716

@applyDamageAndSetState:
	; Apply damage to Link only if he's on the companion
	ld a,(wLinkObjectIndex)		; $4717
	rrca			; $471a
	ld a,$01		; $471b
	jr nc,@setState	; $471d

	ld a,-2			; $471f
	ld (w1Link.damageToApply),a		; $4721
	ld a,$40		; $4724
	ld (w1Link.invincibilityCounter),a		; $4726

	ld a,$05		; $4729
@setState:
	ld h,d			; $472b
	ld l,SpecialObject.state		; $472c
	ldi (hl),a		; $472e
	xor a			; $472f
	ld (hl),a ; [state2] = 0

	ld l,SpecialObject.var3d		; $4731
	ld (hl),a		; $4733
	ld (wDisableScreenTransitions),a		; $4734

	ld l,SpecialObject.collisionType		; $4737
	res 7,(hl)		; $4739
	ret			; $473b

;;
; Checks if a companion's moving toward a cliff from the top, to hop down if so.
;
; @param[out]	zflag	Set if the companion should hop down a cliff
; @addr{473c}
_companionCheckHopDownCliff:
	; Make sure we're not moving at an angle
	ld a,(wLinkAngle)		; $473c
	ld c,a			; $473f
	and $e7			; $4740
	ret nz			; $4742

	; Check that the companion's angle equals Link's angle?
	ld e,SpecialObject.angle		; $4743
	ld a,(de)		; $4745
	cp c			; $4746
	ret nz			; $4747

	call _specialObjectCheckMovingTowardWall		; $4748
	cp $03  ; Wall to the right?
	jr z,++			; $474d
	cp $0c  ; Wall to the left?
	jr z,++			; $4751
	cp $30  ; Wall below?
	ret nz			; $4755
++
	; Get offset from companion's position for tile to check
	ld e,SpecialObject.direction		; $4756
	ld a,(de)		; $4758
	ld hl,@directionOffsets		; $4759
	rst_addDoubleIndex			; $475c
	ldi a,(hl)		; $475d
	ld b,a			; $475e
	ld c,(hl)		; $475f

	call objectGetRelativeTile		; $4760
	cp TILEINDEX_VINE_TOP			; $4763
	jr z,@vineTop		; $4765

	ld hl,cliffTilesTable		; $4767
	call lookupCollisionTable		; $476a
	jr c,@cliffTile		; $476d

	or d			; $476f
	ret			; $4770

@vineTop:
	ld a,$10		; $4771

@cliffTile:
	; 'a' should contain the desired angle to be moving in
	ld h,d			; $4773
	ld l,SpecialObject.angle		; $4774
	cp (hl)			; $4776
	ret nz			; $4777

	; Initiate hopping down

	ld a,$80		; $4778
	ld (wLinkInAir),a		; $477a
	ld bc,-$2c0		; $477d
	call objectSetSpeedZ		; $4780

	ld l,SpecialObject.speed		; $4783
	ld (hl),SPEED_200		; $4785
	ld l,SpecialObject.counter1		; $4787
	ld a,$14		; $4789
	ldi (hl),a		; $478b
	xor a			; $478c
	ld (hl),a ; [counter2] = 0

	ld l,SpecialObject.state		; $478e
	ld a,$07		; $4790
	ldi (hl),a		; $4792
	xor a			; $4793
	ld (hl),a ; [state2] = 0
	ret			; $4795


@directionOffsets:
	.db $fa $00 ; DIR_UP
	.db $00 $04 ; DIR_RIGHT
	.db $08 $00 ; DIR_DOWN
	.db $00 $fb ; DIR_LEFT

;;
; Sets a bunch of variables the moment Link completes the mounting animation.
; @addr{479e}
_companionFinalizeMounting:
	ld h,d			; $479e
	ld l,SpecialObject.enabled		; $479f
	set 1,(hl)		; $47a1

	ld l,SpecialObject.state		; $47a3
	ld (hl),$05		; $47a5

	ld l,SpecialObject.angle		; $47a7
	ld a,$ff		; $47a9
	ld (hl),a		; $47ab
	ld l,SpecialObject.var3c		; $47ac
	ld (hl),a		; $47ae

	; Give companion draw priority 1
	ld l,SpecialObject.visible		; $47af
	ld a,(hl)		; $47b1
	and $c0			; $47b2
	or $01			; $47b4
	ld (hl),a		; $47b6

	xor a			; $47b7
	ld l,SpecialObject.var3d		; $47b8
	ld (hl),a		; $47ba
	ld (wLinkInAir),a		; $47bb
	ld (wDisableScreenTransitions),a		; $47be

	ld bc,wLastAnimalMountPointY		; $47c1
	ld l,SpecialObject.yh		; $47c4
	ldi a,(hl)		; $47c6
	ld (bc),a		; $47c7
	inc c			; $47c8
	inc l			; $47c9
	ld a,(hl)		; $47ca
	ld (bc),a		; $47cb

	ld a,d			; $47cc
	ld (wLinkObjectIndex),a		; $47cd
	call setCameraFocusedObjectToLink		; $47d0
	ld a,SPECIALOBJECTID_LINK_RIDING_ANIMAL		; $47d3
	jp setLinkID		; $47d5

;;
; Something to do with dismounting companions?
;
; @param[out]	zflag
; @addr{47d8}
_companionFunc_47d8:
	ld h,d			; $47d8
	ld l,SpecialObject.var3c		; $47d9
	ld a,(hl)		; $47db
	or a			; $47dc
	ret z			; $47dd
	ld a,(wLinkDeathTrigger)		; $47de
	or a			; $47e1
	ret z			; $47e2

	xor a			; $47e3
	ld (hl),a ; [var3c] = 0
	ld e,SpecialObject.z		; $47e5
	ldi (hl),a		; $47e7
	ldi (hl),a		; $47e8

	ld l,SpecialObject.state		; $47e9
	ld (hl),$09		; $47eb
	ld e,SpecialObject.oamFlagsBackup		; $47ed
	ldi a,(hl)		; $47ef
	ld (hl),a		; $47f0
	ld e,SpecialObject.visible		; $47f1
	xor a			; $47f3
	ld (de),a		; $47f4

	; Copy Link's position to companion
	ld h,>w1Link		; $47f5
	call objectCopyPosition		; $47f7
	ld a,h			; $47fa
	ld (wLinkObjectIndex),a		; $47fb
	call setCameraFocusedObjectToLink		; $47fe
	lda SPECIALOBJECTID_LINK			; $4801
	call setLinkID		; $4802
	or d			; $4805
	ret			; $4806

;;
; @addr{4807}
_companionGotoDismountState:
	ld e,SpecialObject.var38		; $4807
	ld a,(de)		; $4809
	or a			; $480a
	jr z,+			; $480b
	xor a			; $480d
	ld (wForceCompanionDismount),a		; $480e
	ret			; $4811
+
	; Go to state 6
	ld a,$06		; $4812
	jr ++			; $4814

;;
; Sets a companion's animation and returns to state 5, substate 0 (normal movement with
; Link)
;
; @param	c	Animation
; @addr{4816}
_companionSetAnimationAndGotoState5:
	call _companionSetAnimation		; $4816
	ld a,$05		; $4819
++
	ld e,SpecialObject.state		; $481b
	ld (de),a		; $481d
	inc e			; $481e
	xor a			; $481f
	ld (de),a		; $4820
	ret			; $4821

;;
; Called on initialization of companion. Checks if its current position is ok to spawn at?
; If so, this sets the companion's state to [var03]+1.
;
; May return from caller.
;
; @addr{4822}
_companionCheckCanSpawn:
	ld e,SpecialObject.state		; $4822
	ld a,(de)		; $4824
	or a			; $4825
	jr nz,@canSpawn		; $4826

	; Jump if [state2] != 0
	inc e			; $4828
	ld a,(de)		; $4829
	or a			; $482a
	jr nz,++		; $482b

	; Set [state2]=1, return from caller
	inc a			; $482d
	ld (de),a		; $482e
	pop af			; $482f
	ret			; $4830
++
	xor a			; $4831
	ld (de),a ; [state2] = 0

	; Delete self if there's already a solid object in its position
	call objectGetShortPosition		; $4833
	ld b,a			; $4836
	ld a,:w2SolidObjectPositions		; $4837
	ld ($ff00+R_SVBK),a	; $4839
	ld a,b			; $483b
	ld hl,w2SolidObjectPositions		; $483c
	call checkFlag		; $483f
	ld a,$00		; $4842
	ld ($ff00+R_SVBK),a	; $4844
	jr z,+			; $4846
	pop af			; $4848
	jp itemDelete		; $4849
+
	; If the tile at the animal's feet is not completely solid or a hole, it can
	; spawn here.
	ld e,SpecialObject.yh		; $484c
	ld a,(de)		; $484e
	add $05			; $484f
	ld b,a			; $4851
	ld e,SpecialObject.xh		; $4852
	ld a,(de)		; $4854
	ld c,a			; $4855
	call getTileCollisionsAtPosition		; $4856
	cp SPECIALCOLLISION_HOLE			; $4859
	jr z,+			; $485b
	cp $0f			; $485d
	jr nz,@canSpawn		; $485f
+
	; It can't spawn where it is, so try to spawn it somewhere else.
	ld hl,wLastAnimalMountPointY		; $4861
	ldi a,(hl)		; $4864
	ld e,SpecialObject.yh		; $4865
	ld (de),a		; $4867
	ld a,(hl)		; $4868
	ld e,SpecialObject.xh		; $4869
	ld (de),a		; $486b
	call objectGetTileCollisions		; $486c
	jr z,@canSpawn		; $486f
	pop af			; $4871
	jp itemDelete		; $4872

@canSpawn:
	call specialObjectSetOamVariables		; $4875

	ld hl,w1Companion.var03		; $4878
	ldi a,(hl)		; $487b
	inc a			; $487c
	ld (hl),a ; [state] = [var03]+1

	ld l,SpecialObject.collisionType		; $487e
	ld (hl),$80|ITEMCOLLISION_LINK		; $4880
	ret			; $4882

;;
; Returns from caller if the companion should not be updated right now.
;
; @addr{4883}
_companionRetIfInactive:
	; Always update when in state 0 (uninitialized)
	ld e,SpecialObject.state		; $4883
	ld a,(de)		; $4885
	or a			; $4886
	ret z			; $4887

	; Don't update when text is on-screen
	ld a,(wTextIsActive)		; $4888
	or a			; $488b
	jr nz,_companionRetIfInactiveWithoutStateCheck@ret	; $488c

;;
; @addr{488e}
_companionRetIfInactiveWithoutStateCheck:
	; Don't update when screen is scrolling, palette is fading, or wDisabledObjects is
	; set to something.
	ld a,(wScrollMode)		; $488e
	and $0e			; $4891
	jr nz,@ret	; $4893
	ld a,(wPaletteThread_mode)		; $4895
	or a			; $4898
	jr nz,@ret	; $4899
	ld a,(wDisabledObjects)		; $489b
	and (DISABLE_ALL_BUT_INTERACTIONS | DISABLE_COMPANION)			; $489e
	ret z			; $48a0
@ret:
	pop af			; $48a1
	ret			; $48a2

;;
; @addr{48a3}
_companionSetAnimationToVar3f:
	ld h,d			; $48a3
	ld l,SpecialObject.var3f		; $48a4
	ld a,(hl)		; $48a6
	ld l,SpecialObject.animMode		; $48a7
	cp (hl)			; $48a9
	jp nz,specialObjectSetAnimation		; $48aa
	ret			; $48ad

;;
; Manipulates a companion's oam flags to make it flash when charging an attack.
; @addr{48ae}
_companionFlashFromChargingAnimation:
	ld hl,w1Link.oamFlagsBackup		; $48ae
	ld a,(wFrameCounter)		; $48b1
	bit 2,a			; $48b4
	jr nz,++		; $48b6
	ldi a,(hl)		; $48b8
	and $f8			; $48b9
	or c			; $48bb
	ld (hl),a		; $48bc
	ret			; $48bd
++
	ldi a,(hl)		; $48be
	ld (hl),a		; $48bf
	ret			; $48c0

;;
; @param[out]	zflag	Set if complete
; @addr{48c1}
_companionCheckMountingComplete:
	; Check if something interrupted the mounting?
	ld a,(wDisallowMountingCompanion)		; $48c1
	or a			; $48c4
	jr nz,@stopMounting	; $48c5
	ld a,(w1Link.state)		; $48c7
	cp LINK_STATE_NORMAL			; $48ca
	jr nz,@stopMounting	; $48cc
	ld a,(wLinkGrabState)		; $48ce
	or a			; $48d1
	jr z,@continue	; $48d2

@stopMounting:
	xor a			; $48d4
	ld (wcc90),a		; $48d5
	ld (wWarpsDisabled),a		; $48d8
	ld (wDisableScreenTransitions),a		; $48db
	ld a,$01		; $48de
	ld e,SpecialObject.state		; $48e0
	ld (de),a		; $48e2
	or d			; $48e3
	ret			; $48e4

@continue:
	ld hl,w1Link.yh		; $48e5
	ld e,SpecialObject.yh		; $48e8
	ld a,(de)		; $48ea
	cp (hl)			; $48eb
	call nz,@nudgeLinkTowardCompanion		; $48ec

	ld e,SpecialObject.xh		; $48ef
	ld l,e			; $48f1
	ld a,(de)		; $48f2
	cp (hl)			; $48f3
	call nz,@nudgeLinkTowardCompanion		; $48f4

	; Check if Link has fallen far enough down to complete the mounting animation
	ld l,<w1Link.speedZ+1		; $48f7
	bit 7,(hl)		; $48f9
	ret nz			; $48fb
	ld l,SpecialObject.zh		; $48fc
	ld a,(hl)		; $48fe
	cp $fc			; $48ff
	ret c			; $4901
	xor a			; $4902
	ret			; $4903

@nudgeLinkTowardCompanion:
	jr c,+			; $4904
	inc (hl)		; $4906
	ret			; $4907
+
	dec (hl)		; $4908
	ret			; $4909

;;
; @addr{490a}
_companionCheckEnableTerrainEffects:
	ld h,d			; $490a
	ld l,SpecialObject.enabled		; $490b
	ld a,(hl)		; $490d
	or a			; $490e
	ret z			; $490f

	ld l,SpecialObject.var3c		; $4910
	ld a,(hl)		; $4912
	ld (wWarpsDisabled),a		; $4913

	; If in midair, enable terrain effects for shadows
	ld l,SpecialObject.zh		; $4916
	ldi a,(hl)		; $4918
	bit 7,a			; $4919
	jr nz,@enableTerrainEffects	; $491b

	; If on puddle, enable terrain effects for that
	ld bc,$0500		; $491d
	call objectGetRelativeTile		; $4920
	ld h,d			; $4923
	cp TILEINDEX_PUDDLE			; $4924
	jr nz,@label_05_067	; $4926

	; Disable terrain effects
	ld l,SpecialObject.visible		; $4928
	res 6,(hl)		; $492a
	ret			; $492c

@label_05_067:
	ld l,SpecialObject.zh		; $492d
	ld (hl),$00		; $492f

@enableTerrainEffects:
	ld l,SpecialObject.visible		; $4931
	set 6,(hl)		; $4933
	ret			; $4935

;;
; Set the animal's draw priority relative to Link's position.
; @addr{4936}
_companionSetPriorityRelativeToLink:
	call objectSetPriorityRelativeToLink_withTerrainEffects		; $4936
	dec b			; $4939
	and $c0			; $493a
	or b			; $493c
	ld (de),a		; $493d
	ret			; $493e

;;
; Decrements counter1, and once it reaches 0, it plays the "jump" sound effect.
;
; @param[out]	cflag	nc if counter1 has reached 0 (should jump down the cliff).
; @param[out]	zflag	Same as carry
; @addr{493f}
_companionDecCounter1ToJumpDownCliff:
	ld e,SpecialObject.counter1		; $493f
	ld a,(de)		; $4941
	or a			; $4942
	jr z,@animate		; $4943

	dec a			; $4945
	ld (de),a		; $4946
	ld a,SND_JUMP		; $4947
	scf			; $4949
	ret nz			; $494a
	call playSound		; $494b
	xor a			; $494e
	scf			; $494f
	ret			; $4950

@animate:
	call specialObjectAnimate		; $4951
	call objectApplySpeed		; $4954
	ld c,$40		; $4957
	call objectUpdateSpeedZ_paramC		; $4959
	or d			; $495c
	ret			; $495d

;;
; @addr{495e}
_companionDecCounter1IfNonzero:
	ld h,d			; $495e
	ld l,SpecialObject.counter1		; $495f
	ld a,(hl)		; $4961
	or a			; $4962
	ret z			; $4963
	dec (hl)		; $4964
	ret			; $4965

;;
; Updates animation, and respawns the companion when the animation is over (bit 7 of
; animParameter is set).
;
; @param[out]	cflag	Set if the animation finished and the companion has respawned.
; @addr{4966}
_companionAnimateDrowningOrFallingThenRespawn:
	call specialObjectAnimate		; $4966
	ld e,SpecialObject.animParameter		; $4969
	ld a,(de)		; $496b
	rlca			; $496c
	ret nc			; $496d

	call _companionRespawn		; $496e
	scf			; $4971
	ret			; $4972

;;
; @param[out]	hl	Companion's counter2 variable
; @addr{4973}
_companionInitializeOnEnteringScreen:
	call _companionCheckCanSpawn		; $4973
	ld l,SpecialObject.state		; $4976
	ld (hl),$0c		; $4978
	ld l,SpecialObject.var03		; $497a
	inc (hl)		; $497c
	ld l,SpecialObject.counter2		; $497d
	jp objectSetVisiblec1		; $497f

;;
; Used with dimitri and moosh when they're walking into the screen.
;
; @param	hl	Table of direction offsets
; @addr{4982}
_companionRetIfNotFinishedWalkingIn:
	; Check that the tile in front has collision value 0
	call _specialObjectGetRelativeTileWithDirectionTable		; $4982
	or a			; $4985
	ret nz			; $4986

	; Decrement counter2
	ld e,SpecialObject.counter2		; $4987
	ld a,(de)		; $4989
	dec a			; $498a
	ld (de),a		; $498b
	ret z			; $498c

	; Return from caller if counter2 is nonzero
	pop af			; $498d
	ret			; $498e

;;
; @addr{498f}
_companionForceMount:
	ld a,(wMenuDisabled)		; $498f
	push af			; $4992
	xor a			; $4993
	ld (wMenuDisabled),a		; $4994
	ld (w1Link.invincibilityCounter),a		; $4997
	call _companionTryToMount		; $499a
	pop af			; $499d
	ld (wMenuDisabled),a		; $499e
	ret			; $49a1

;;
; @addr{49a2}
_companionDecCounter1:
	ld h,d			; $49a2
	ld l,SpecialObject.counter1		; $49a3
	ld a,(hl)		; $49a5
	or a			; $49a6
	ret			; $49a7

;;
; @addr{49a8}
specialObjectTryToBreakTile_source05:
	ld h,d			; $49a8
	ld l,<w1Link.yh		; $49a9
	ldi a,(hl)		; $49ab
	inc l			; $49ac
	ld c,(hl)		; $49ad
	add $05		; $49ae
	ld b,a			; $49b0
	ld a,BREAKABLETILESOURCE_05		; $49b1
	jp tryToBreakTile		; $49b3

;;
; Update the link object.
; @param d Link object
; @addr{49b6}
specialObjectCode_link:
	ld e,<w1Link.state		; $49b6
	ld a,(de)		; $49b8
	rst_jumpTable			; $49b9
	.dw _linkState00
	.dw _linkState01
	.dw _linkState02
	.dw _linkState03
	.dw _linkState04
	.dw _linkState05
	.dw _linkState06
	.dw linkState07
	.dw _linkState08
	.dw _linkState09
	.dw _linkState0a
	.dw _linkState0b
	.dw _linkState0c
	.dw _linkState0d
	.dw _linkState0e
	.dw _linkState0f
	.dw _linkState10
	.dw _linkState11
	.dw _linkState12
	.dw _linkState13
	.dw _linkState14

;;
; LINK_STATE_00
; @addr{49e4}
_linkState00:
	call clearAllParentItems		; $49e4
	call specialObjectSetOamVariables		; $49e7
	ld a,LINK_ANIM_MODE_WALK		; $49ea
	call specialObjectSetAnimation		; $49ec

	; Enable collisions?
	ld h,d			; $49ef
	ld l,SpecialObject.collisionType		; $49f0
	ld a,$80		; $49f2
	ldi (hl),a		; $49f4

	; Set collisionRadiusY,X
	inc l			; $49f5
	ld a,$06		; $49f6
	ldi (hl),a		; $49f8
	ldi (hl),a		; $49f9

	; A non-dead default health?
	ld l,SpecialObject.health		; $49fa
	ld (hl),$01		; $49fc

	; Do a series of checks to see whether Link spawned in an invalid position.

	ld a,(wLinkForceState)		; $49fe
	cp LINK_STATE_WARPING			; $4a01
	jr z,+			; $4a03

	ld a,(wDisableRingTransformations)		; $4a05
	or a			; $4a08
	jr nz,+			; $4a09

	; Check if he's in a solid wall
	call objectGetTileCollisions		; $4a0b
	cp $0f			; $4a0e
	jr nz,+			; $4a10

	; If he's in a wall, move Link to wLastAnimalMountPointY/X?
	ld hl,wLastAnimalMountPointY		; $4a12
	ldi a,(hl)		; $4a15
	ld e,<w1Link.yh		; $4a16
	ld (de),a		; $4a18
	ld a,(hl)		; $4a19
	ld e,<w1Link.xh		; $4a1a
	ld (de),a		; $4a1c
+
	call objectSetVisiblec1		; $4a1d
	call _checkLinkForceState		; $4a20
	jp _initLinkStateAndAnimateStanding		; $4a23

;;
; LINK_STATE_WARPING
; @addr{4a26}
_linkState0a:
	ld a,(wWarpTransition)		; $4a26
	and $0f			; $4a29
	rst_jumpTable			; $4a2b
	.dw _warpTransition0
	.dw _warpTransition1
	.dw _warpTransition2
	.dw _warpTransition3
	.dw _warpTransition4
	.dw _warpTransition5
	.dw _warpTransition6
	.dw _warpTransition7
	.dw _warpTransition8
	.dw _warpTransition9
	.dw _warpTransition7
	.dw _warpTransitionB
	.dw _warpTransitionC
	.dw _warpTransition7
	.dw _warpTransitionE
	.dw _warpTransitionF

;;
; @addr{4a4c}
_warpTransition0:
	call _warpTransition_setLinkFacingDir		; $4a4c
;;
; @addr{4a4f}
_warpTransition7:
	jp _initLinkStateAndAnimateStanding		; $4a4f

;;
; Transition E shifts Link's X position left 8, but otherwise behaves like Transition 1
; @addr{4a52}
_warpTransitionE:
	call objectCenterOnTile		; $4a52
	ld a,(hl)		; $4a55
	and $f0			; $4a56
	ld (hl),a		; $4a58

;;
; Transition 1 behaves like transition 0, but saves link's deathwarp point
; @addr{4a59}
_warpTransition1:
	call _warpTransition_setLinkFacingDir		; $4a59

;;
; @addr{4a5c}
_warpUpdateRespawnPoint:
	ld a,(wActiveGroup)		; $4a5c
	cp NUM_UNIQUE_GROUPS		; $4a5f
	jr nc,_warpTransition0		; $4a61
	call setDeathRespawnPoint		; $4a63
	call updateLinkLocalRespawnPosition		; $4a66
	jp _initLinkStateAndAnimateStanding		; $4a69

;;
; Transition C behaves like transition 0, but sets link's facing direction in
; a way I don't understand
; @addr{4a6c}
_warpTransitionC:
	ld a,(wcc50)		; $4a6c
	and $03			; $4a6f
	ld e,<w1Link.direction	; $4a71
	ld (de),a		; $4a73
	jp _initLinkStateAndAnimateStanding		; $4a74

;;
; @addr{4a77}
_warpTransition_setLinkFacingDir:
	call objectGetTileAtPosition		; $4a77
	ld hl,_facingDirAfterWarpTable		; $4a7a
	call lookupCollisionTable		; $4a7d
	jr c,+			; $4a80
	ld a,DIR_DOWN		; $4a82
+
	ld e,<w1Link.direction	; $4a84
	ld (de),a		; $4a86
	ret			; $4a87

; @addr{4a88}
_facingDirAfterWarpTable:
	.dw @collisions0
	.dw @collisions1
	.dw @collisions2
	.dw @collisions3
	.dw @collisions4
	.dw @collisions5

@collisions1:
	.db $36 DIR_UP ; Cave opening?

@collisions2:
@collisions3:
	.db $44 DIR_LEFT  ; Up stairs
	.db $45 DIR_RIGHT ; Down stairs

@collisions0:
@collisions4:
@collisions5:
	.db $00


;;
; Transition 2 is used by warp sources to fade out the screen.
; @addr{4a9b}
_warpTransition2:
	ld a,$03		; $4a9b
	ld (wWarpTransition2),a		; $4a9d
	ld a,SND_ENTERCAVE	; $4aa0
	jp playSound		; $4aa2

;;
; Transition 3 is used by both sources and destinations for transitions where
; link walks off the screen (or comes in from off the screen). It saves link's
; deathwarp point.
; @addr{4aa5}
_warpTransition3:
	ld e,<w1Link.warpVar1	; $4aa5
	ld a,(de)		; $4aa7
	or a			; $4aa8
	jr nz,@eachFrame	; $4aa9

	; Initialization stuff
	ld h,d			; $4aab
	ld l,e			; $4aac
	inc (hl)		; $4aad
	ld l,<w1Link.warpVar2	; $4aae
	ld (hl),$10		; $4ab0

	; Set link speed, up or down
	ld a,(wWarpTransition)		; $4ab2
	and $40			; $4ab5
	swap a			; $4ab7
	rrca			; $4ab9
	ld bc,@directionTable	; $4aba
	call addAToBc		; $4abd
	ld l,<w1Link.direction	; $4ac0
	ld a,(bc)		; $4ac2
	ldi (hl),a		; $4ac3
	inc bc			; $4ac4
	ld a,(bc)		; $4ac5
	ld (hl),a		; $4ac6

	call updateLinkSpeed_standard		; $4ac7
	call _animateLinkStanding		; $4aca
	ld a,(wWarpTransition)		; $4acd
	rlca			; $4ad0
	jr c,@destInit	; $4ad1

	ld a,SND_ENTERCAVE	; $4ad3
	jp playSound		; $4ad5

@directionTable: ; $4ad8
	.db $00 $00
	.db $02 $10

@eachFrame:
	ld a,(wScrollMode)		; $4adc
	and $0a			; $4adf
	ret nz			; $4ae1

	ld a,$00		; $4ae2
	ld (wScrollMode),a		; $4ae4
	call specialObjectAnimate		; $4ae7
	call itemDecCounter1		; $4aea
	jp nz,specialObjectUpdatePosition		; $4aed

	; Counter has reached zero
	ld a,$01		; $4af0
	ld (wScrollMode),a		; $4af2
	xor a			; $4af5
	ld (wMenuDisabled),a		; $4af6

	; Update respawn point if this is a destination
	ld a,(wWarpTransition)		; $4af9
	bit 7,a			; $4afc
	jp nz,_warpUpdateRespawnPoint		; $4afe

	swap a			; $4b01
	and $03			; $4b03
	ld (wWarpTransition2),a		; $4b05
	ret			; $4b08

@destInit:
	ld h,d			; $4b09
	ld a,(wWarpDestPos)		; $4b0a
	cp $ff			; $4b0d
	jr z,@enterFromMiddleBottom	; $4b0f

	cp $f0			; $4b11
	jr nc,@enterFromBottom		; $4b13

	ld l,<w1Link.yh		; $4b15
	call setShortPosition		; $4b17
	ld l,<w1Link.warpVar2	; $4b1a
	ld (hl),$1c		; $4b1c
	jp _initLinkStateAndAnimateStanding		; $4b1e

@enterFromMiddleBottom:
	ld a,$01		; $4b21
	ld (wMenuDisabled),a		; $4b23
	ld l,<w1Link.warpVar2	; $4b26
	ld (hl),$1c		; $4b28
	ld a,(wWarpTransition)		; $4b2a
	and $40			; $4b2d
	swap a			; $4b2f
	ld b,a			; $4b31
	ld a,(wActiveGroup)		; $4b32
	and NUM_SMALL_GROUPS	; $4b35
	rrca			; $4b37
	or b			; $4b38
	ld bc,@linkPosTable		; $4b39
	call addAToBc		; $4b3c
	ld l,<w1Link.yh		; $4b3f
	ld a,(bc)		; $4b41
	ldi (hl),a		; $4b42
	inc bc			; $4b43
	inc l			; $4b44
	ld a,(bc)		; $4b45
	ld (hl),a		; $4b46
	ret			; $4b47

@enterFromBottom:
	call @enterFromMiddleBottom	; $4b48
	ld a,(wWarpDestPos)		; $4b4b
	swap a			; $4b4e
	and $f0			; $4b50
	ld b,a			; $4b52
	ld a,(wActiveGroup)		; $4b53
	and NUM_SMALL_GROUPS		; $4b56
	jr z,+			; $4b58

	rlca			; $4b5a
+
	or b			; $4b5b
	ld l,<w1Link.xh		; $4b5c
	ld (hl),a		; $4b5e
	ret			; $4b5f

@linkPosTable:
	.db $80 $50 ; small room, enter from bottom
	.db $b0 $78 ; large room, enter from bottom
	.db $f0 $50 ; small room, enter from top
	.db $f0 $78 ; large room, enter from top

;;
; @addr{4b68}
_warpTransition4:
	ld a,(wWarpTransition)		; $4b68
	rlca			; $4b6b
	jp c,_warpTransition0		; $4b6c

	ld a,$01		; $4b6f
	ld (wWarpTransition2),a		; $4b71
	ld a,SND_ENTERCAVE	; $4b74
	jp playSound		; $4b76

;;
; Link falls into the screen
; @addr{4b79}
_warpTransition5:
	ld e,<w1Link.warpVar1	; $4b79
	ld a,(de)		; $4b7b
	rst_jumpTable			; $4b7c
	.dw _warpTransition5_00
	.dw _warpTransition5_01
	.dw _warpTransition5_02

_warpTransition5_00:
	ld a,$01		; $4b83
	ld (de),a		; $4b85
	ld bc,$0020		; $4b86
	call objectSetSpeedZ		; $4b89
	call objectGetZAboveScreen		; $4b8c
	ld l,<w1Link.zh		; $4b8f
	ld (hl),a		; $4b91
	ld l,<w1Link.yh		; $4b92
	ld a,(hl)		; $4b94
	sub $04			; $4b95
	ld (hl),a		; $4b97
	ld l,<w1Link.direction	; $4b98
	ld (hl),DIR_DOWN	; $4b9a
	ld a,LINK_ANIM_MODE_FALL	; $4b9c
	jp specialObjectSetAnimation		; $4b9e

_warpTransition5_01:
	call specialObjectAnimate		; $4ba1
	ld c,$20		; $4ba4
	call objectUpdateSpeedZ_paramC		; $4ba6
	ret nz			; $4ba9
	ld hl,hazardCollisionTable		; $4baa
	call lookupCollisionTable		; $4bad
	jp nc,func_4bb6@label_4c05		; $4bb0
	jp _initLinkStateAndAnimateStanding		; $4bb3

;;
; Unused?
; @addr{4bb6}
func_4bb6:
	ld e,<w1Link.warpVar1	; $4bb6
	ld a,(de)		; $4bb8
	rst_jumpTable			; $4bb9
	.dw @warpVar0
	.dw @warpVar1
	.dw @warpVar2
	.dw @warpVar3

@warpVar0:
	ld a,$01		; $4bc2
	ld (de),a		; $4bc4

	ld h,d			; $4bc5
	ld l,<w1Link.direction	; $4bc6
	ld (hl),DIR_DOWN	; $4bc8
	inc l			; $4bca
	ld (hl),$10		; $4bcb
	ld l,<w1Link.speed		; $4bcd
	ld (hl),SPEED_100		; $4bcf

	ld l,<w1Link.visible	; $4bd1
	res 7,(hl)		; $4bd3

	ld l,<w1Link.warpVar2	; $4bd5
	ld (hl),$78		; $4bd7

	ld a,LINK_ANIM_MODE_FALL	; $4bd9
	call specialObjectSetAnimation		; $4bdb

	ld a,SND_LINK_FALL	; $4bde
	jp playSound		; $4be0

@warpVar1:
	call itemDecCounter1		; $4be3
	ret nz			; $4be6

	ld l,<w1Link.warpVar1	; $4be7
	inc (hl)		; $4be9
	ld l,<w1Link.visible		; $4bea
	set 7,(hl)		; $4bec
	ld l,<w1Link.warpVar2	; $4bee
	ld (hl),$30		; $4bf0
	ld a,$10		; $4bf2
	call setScreenShakeCounter		; $4bf4
	ld a,SND_SCENT_SEED	; $4bf7
	jp playSound		; $4bf9

;;
; @addr{4bfc}
@warpVar2:
	call specialObjectAnimate		; $4bfc
	call itemDecCounter1		; $4bff
	jp nz,specialObjectUpdatePosition		; $4c02
;;
; @addr{4c05}
@label_4c05:
	call itemIncState2		; $4c05
	ld l,<w1Link.warpVar2	; $4c08
	ld (hl),$1e		; $4c0a
	ld a,LINK_ANIM_MODE_COLLAPSED	; $4c0c
	call specialObjectSetAnimation		; $4c0e
	ld a,SND_SPLASH		; $4c11
	jp playSound		; $4c13

;;
; @addr{4c16}
@warpVar3:
	call setDeathRespawnPoint		; $4c16

_warpTransition5_02:
	call itemDecCounter1		; $4c19
	ret nz			; $4c1c
	jp _initLinkStateAndAnimateStanding		; $4c1d

;;
; @addr{4c20}
_linkIncrementDirectionOnOddFrames:
	ld a,(wFrameCounter)		; $4c20
	rrca			; $4c23
	ret nc			; $4c24

;;
; @addr{4c25}
_linkIncrementDirection:
	ld e,<w1Link.direction	; $4c25
	ld a,(de)		; $4c27
	inc a			; $4c28
	and $03			; $4c29
	ld (de),a		; $4c2b
	ret			; $4c2c

;;
; A subrosian warp portal?
; @addr{4c2d}
_warpTransition8:
	ld e,SpecialObject.state2		; $4c2d
	ld a,(de)		; $4c2f
	rst_jumpTable			; $4c30
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4
	.dw @substate5
	.dw @substate6
	.dw @substate7

@substate0:
	ld a,$01		; $4c41
	ld (de),a		; $4c43
	ld a,$ff		; $4c44
	ld (wDisabledObjects),a		; $4c46
	ld a,$80		; $4c49
	ld (wMenuDisabled),a		; $4c4b
	ld a,$15		; $4c4e
	ld (wCutsceneTrigger),a		; $4c50

	ld bc,$ff60		; $4c53
	call objectSetSpeedZ		; $4c56

	ld l,SpecialObject.counter1		; $4c59
	ld (hl),$30		; $4c5b

	call linkCancelAllItemUsage		; $4c5d
	call restartSound		; $4c60

	ld a,SND_FADEOUT		; $4c63
	call playSound		; $4c65
	jp objectCenterOnTile		; $4c68

@substate1:
	ld c,$02		; $4c6b
	call objectUpdateSpeedZ_paramC		; $4c6d
	ld a,(wFrameCounter)		; $4c70
	and $03			; $4c73
	jr nz,+			; $4c75
	ld hl,wTmpcbbc		; $4c77
	inc (hl)		; $4c7a
+
	ld a,(wFrameCounter)		; $4c7b
	and $03			; $4c7e
	call z,_linkIncrementDirection		; $4c80
	call itemDecCounter1		; $4c83
	ret nz			; $4c86
	jp itemIncState2		; $4c87

@substate2:
	ld c,$02		; $4c8a
	call objectUpdateSpeedZ_paramC		; $4c8c
	call _linkIncrementDirectionOnOddFrames		; $4c8f

	ld h,d			; $4c92
	ld l,SpecialObject.speedZ+1		; $4c93
	bit 7,(hl)		; $4c95
	ret nz			; $4c97

	ld l,SpecialObject.counter1		; $4c98
	ld (hl),$28		; $4c9a

	ld a,$02		; $4c9c
	call fadeoutToWhiteWithDelay		; $4c9e

	jp itemIncState2		; $4ca1

@substate3:
	call _linkIncrementDirectionOnOddFrames		; $4ca4
	call itemDecCounter1		; $4ca7
	ret nz			; $4caa
	ld hl,wTmpcbb3		; $4cab
	inc (hl)		; $4cae
	jp itemIncState2		; $4caf

@substate4:
	call _linkIncrementDirectionOnOddFrames		; $4cb2
	ld a,(wCutsceneState)		; $4cb5
	cp $02			; $4cb8
	ret nz			; $4cba
	call itemIncState2		; $4cbb
	ld l,SpecialObject.counter1		; $4cbe
	ld (hl),$28		; $4cc0
	ret			; $4cc2

@substate5:
	ld c,$02		; $4cc3
	call objectUpdateSpeedZ_paramC		; $4cc5
	call _linkIncrementDirectionOnOddFrames		; $4cc8
	call itemDecCounter1		; $4ccb
	ret nz			; $4cce
	jp itemIncState2		; $4ccf

@substate6:
	ld c,$02		; $4cd2
	call objectUpdateSpeedZ_paramC		; $4cd4
	ld a,(wFrameCounter)		; $4cd7
	and $03			; $4cda
	ret nz			; $4cdc

	call _linkIncrementDirection		; $4cdd
	ld hl,wTmpcbbc		; $4ce0
	dec (hl)		; $4ce3
	ret nz			; $4ce4

	ld hl,wTmpcbb3		; $4ce5
	inc (hl)		; $4ce8
	jp itemIncState2		; $4ce9

@substate7:
	ld a,(wDisabledObjects)		; $4cec
	and $81			; $4cef
	jr z,+			; $4cf1

	ld a,(wFrameCounter)		; $4cf3
	and $07			; $4cf6
	ret nz			; $4cf8
	jp _linkIncrementDirection		; $4cf9
+
	ld e,SpecialObject.direction		; $4cfc
	ld a,(de)		; $4cfe
	cp $02			; $4cff
	jp nz,_linkIncrementDirection		; $4d01
	ld a,(wActiveMusic2)		; $4d04
	ld (wActiveMusic),a		; $4d07
	call playSound		; $4d0a
	call setDeathRespawnPoint		; $4d0d
	call updateLinkLocalRespawnPosition		; $4d10
	call resetLinkInvincibility		; $4d13
	jp _initLinkStateAndAnimateStanding		; $4d16

;;
; @addr{4d19}
_warpTransition9:
	ld e,SpecialObject.state2		; $4d19
	ld a,(de)		; $4d1b
	rst_jumpTable			; $4d1c
	.dw @substate0
	.dw @substate1

@substate0:
	call itemIncState2		; $4d21

	ld l,SpecialObject.yh		; $4d24
	ld a,$08		; $4d26
	add (hl)		; $4d28
	ld (hl),a		; $4d29

	call objectCenterOnTile		; $4d2a
	call clearAllParentItems		; $4d2d

	ld a,LINK_ANIM_MODE_FALLINHOLE		; $4d30
	call specialObjectSetAnimation		; $4d32

	ld a,SND_LINK_FALL		; $4d35
	jp playSound		; $4d37

@substate1:
	ld e,SpecialObject.animParameter		; $4d3a
	ld a,(de)		; $4d3c
	inc a			; $4d3d
	jp nz,specialObjectAnimate		; $4d3e

	ld a,$03		; $4d41
	ld (wWarpTransition2),a		; $4d43
	ret			; $4d46

;;
; @addr{4d47}
_warpTransitionB:
	ld e,<w1Link.warpVar1	; $4d47
	ld a,(de)		; $4d49
	rst_jumpTable			; $4d4a
	.dw @warpVar0
	.dw @warpVar1
	.dw @warpVar2

@warpVar0:
	call itemIncState2		; $4d51

	call objectGetZAboveScreen		; $4d54
	ld l,<w1Link.zh		; $4d57
	ld (hl),a		; $4d59

	ld l,<w1Link.direction	; $4d5a
	ld (hl),DIR_DOWN	; $4d5c

	ld a,LINK_ANIM_MODE_FALL		; $4d5e
	jp specialObjectSetAnimation		; $4d60

@warpVar1:
	call specialObjectAnimate		; $4d63
	ld c,$0c		; $4d66
	call objectUpdateSpeedZ_paramC		; $4d68
	ret nz			; $4d6b

	call itemIncState2		; $4d6c
	call _animateLinkStanding		; $4d6f
	ld a,SND_SPLASH		; $4d72
	jp playSound		; $4d74

@warpVar2:
	ld a,(wDisabledObjects)		; $4d77
	and $81			; $4d7a
	ret nz			; $4d7c

	call objectSetVisiblec2		; $4d7d
	jp _initLinkStateAndAnimateStanding		; $4d80


;;
; @addr{4d83}
_warpTransitionF:
	call _checkLinkForceState		; $4d83
	jp objectSetInvisible		; $4d86

;;
; "Timewarp" transition
; @addr{4d89}
_warpTransition6:
	ld e,SpecialObject.state2		; $4d89
	ld a,(de)		; $4d8b
	rst_jumpTable			; $4d8c
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4
	.dw @substate5
	.dw @substate6
	.dw @substate7

;;
; @addr{4d9d}
@flickerVisibilityAndDecCounter1:
	ld b,$03		; $4d9d
	call objectFlickerVisibility		; $4d9f
	jp itemDecCounter1		; $4da2

;;
; @addr{4da5}
@createDestinationTimewarpAnimation:
	call getFreeInteractionSlot		; $4da5
	ret nz			; $4da8
	ld (hl),INTERACID_TIMEWARP		; $4da9
	inc l			; $4dab
	inc (hl)		; $4dac

	; [Interaction.var03] = [wcc50]
	ld a,(wcc50)		; $4dad
	inc l			; $4db0
	ld (hl),a		; $4db1
	ret			; $4db2

;;
; This function should center Link if it detects that he's warped into a 2-tile-wide
; doorway.
; Except, it doesn't work. There's a typo.
; @addr{4db3}
@centerLinkOnDoorway:
	call objectGetTileAtPosition		; $4db3
	push hl			; $4db6

	; This should be "ld e,a" instead of "ld a,e".
	ld a,e			; $4db7

	ld hl,@doorTiles		; $4db8
	call findByteAtHl		; $4dbb
	pop hl			; $4dbe
	ret nc			; $4dbf

	push hl			; $4dc0
	dec l			; $4dc1
	ld e,(hl)		; $4dc2
	ld hl,@doorTiles		; $4dc3
	call findByteAtHl		; $4dc6
	pop hl			; $4dc9
	jr nc,+			; $4dca

	ld e,SpecialObject.xh		; $4dcc
	ld a,(de)		; $4dce
	and $f0			; $4dcf
	ld (de),a		; $4dd1
	ret			; $4dd2
+
	inc l			; $4dd3
	ld e,(hl)		; $4dd4
	ld hl,@doorTiles		; $4dd5
	call findByteAtHl		; $4dd8
	ret nc			; $4ddb

	ld e,SpecialObject.xh		; $4ddc
	ld a,(de)		; $4dde
	add $08			; $4ddf
	ld (de),a		; $4de1
	ld hl,wEnteredWarpPosition		; $4de2
	inc (hl)		; $4de5
	ret			; $4de6

; List of tile indices that are "door tiles" which initiate warps.
@doorTiles:
	.db $dc $dd $de $df $ed $ee $ef
	.db $00


; Initialization
@substate0:
	call itemIncState2		; $4def

	ld l,SpecialObject.counter1		; $4df2
	ld (hl),$1e		; $4df4
	ld l,SpecialObject.direction		; $4df6
	ld (hl),DIR_DOWN		; $4df8

	ld a,d			; $4dfa
	ld (wLinkCanPassNpcs),a		; $4dfb
	ld (wMenuDisabled),a		; $4dfe

	call @centerLinkOnDoorway		; $4e01
	jp objectSetInvisible		; $4e04


; Waiting for palette to fade in and counter1 to reach 0
@substate1:
	ld a,(wPaletteThread_mode)		; $4e07
	or a			; $4e0a
	ret nz			; $4e0b
	call itemDecCounter1		; $4e0c
	ret nz			; $4e0f

; Create the timewarp animation, and go to substate 4 if Link is obstructed from warping
; in, otherwise go to substate 2.

	ld (hl),$10		; $4e10
	call @createDestinationTimewarpAnimation		; $4e12

	ld a,(wSentBackByStrangeForce)		; $4e15
	dec a			; $4e18
	jr z,@warpFailed			; $4e19

	callab bank1.checkLinkCanStandOnTile		; $4e1b
	srl c			; $4e23
	jr c,@warpFailed			; $4e25

	callab bank1.checkSolidObjectAtWarpDestPos		; $4e27
	srl c			; $4e2f
	jr c,@warpFailed			; $4e31

	jp itemIncState2		; $4e33

	; Link will be returned to the time he came from.
@warpFailed:
	ld e,SpecialObject.state2		; $4e36
	ld a,$04		; $4e38
	ld (de),a		; $4e3a
	ret			; $4e3b


; Waiting several frames before making Link visible and playing the sound effect
@substate2:
	call itemDecCounter1		; $4e3c
	ret nz			; $4e3f

	ld (hl),$1e		; $4e40

@makeLinkVisibleAndPlaySound:
.ifdef ROM_AGES
	ld a,SND_TIMEWARP_COMPLETED		; $4e42
.else
	ld a,$d4
.endif
	call playSound		; $4e44
	call objectSetVisiblec0		; $4e47
	jp itemIncState2		; $4e4a


@substate3:
	call @flickerVisibilityAndDecCounter1		; $4e4d
	ret nz			; $4e50

; Warp is completed; create a time portal if necessary, restore control to Link

	; Check if a time portal should be created
	ld a,(wLinkTimeWarpTile)		; $4e51
	or a			; $4e54
	jr nz,++	; $4e55

	; Create a time portal
	ld hl,wPortalGroup		; $4e57
	ld a,(wActiveGroup)		; $4e5a
	ldi (hl),a		; $4e5d
	ld a,(wActiveRoom)		; $4e5e
	ldi (hl),a		; $4e61
	ld a,(wWarpDestPos)		; $4e62
	ld (hl),a		; $4e65
	ld c,a			; $4e66
	call getFreeInteractionSlot		; $4e67
	jr nz,++	; $4e6a

	ld (hl),INTERACID_TIMEPORTAL		; $4e6c
	ld l,Interaction.yh		; $4e6e
	call setShortPosition_paramC		; $4e70
++
	; Check whether to show the "Sent back by strange force" text.
	ld a,(wSentBackByStrangeForce)		; $4e73
	or a			; $4e76
	jr z,+			; $4e77
	ld bc,TX_5112		; $4e79
	call showText		; $4e7c
+
	; Restore everything to normal, give control back to Link.
	xor a			; $4e7f
	ld (wLinkTimeWarpTile),a		; $4e80
	ld (wWarpTransition),a		; $4e83
	ld (wLinkCanPassNpcs),a		; $4e86
	ld (wMenuDisabled),a		; $4e89
	ld (wSentBackByStrangeForce),a		; $4e8c
	ld (wcddf),a		; $4e8f
	ld (wcde0),a		; $4e92

	ld e,SpecialObject.invincibilityCounter		; $4e95
	ld a,$88		; $4e97
	ld (de),a		; $4e99

	call updateLinkLocalRespawnPosition		; $4e9a
	call objectSetVisiblec2		; $4e9d
	jp _initLinkStateAndAnimateStanding		; $4ea0


; Substates 4-7: Warp failed, Link will be sent back to the time he came from

@substate4:
	call itemDecCounter1		; $4ea3
	ret nz			; $4ea6

	ld (hl),$78		; $4ea7
	jr @makeLinkVisibleAndPlaySound		; $4ea9

@substate5:
	call @flickerVisibilityAndDecCounter1		; $4eab
	ret nz			; $4eae

	ld (hl),$10		; $4eaf
	call @createDestinationTimewarpAnimation		; $4eb1
	jp itemIncState2		; $4eb4

@substate6:
	call @flickerVisibilityAndDecCounter1		; $4eb7
	ret nz			; $4eba

	ld (hl),$14		; $4ebb
	call objectSetInvisible		; $4ebd
	jp itemIncState2		; $4ec0

@substate7:
	call itemDecCounter1		; $4ec3
	ret nz			; $4ec6

; Initiate another warp sending Link back to the time he came from

	call objectGetTileAtPosition		; $4ec7
	ld c,l			; $4eca

	ld hl,wWarpDestGroup		; $4ecb
	ld a,(wActiveGroup)		; $4ece
	xor $01			; $4ed1
	or $80			; $4ed3
	ldi (hl),a		; $4ed5

	; wWarpDestIndex
	ld a,(wActiveRoom)		; $4ed6
	ldi (hl),a		; $4ed9

	; wWarpTransition
	ld a,TRANSITION_DEST_TIMEWARP		; $4eda
	ldi (hl),a		; $4edc

	; wWarpDestPos
	ld a,c			; $4edd
	ldi (hl),a		; $4ede

	inc a			; $4edf
	ld (wLinkTimeWarpTile),a		; $4ee0
	ld (wcddf),a		; $4ee3

	; wWarpTransition2
	ld a,$03		; $4ee6
	ld (hl),a		; $4ee8

	xor a			; $4ee9
	ld (wScrollMode),a		; $4eea

	ld hl,wSentBackByStrangeForce		; $4eed
	ld a,(hl)		; $4ef0
	or a			; $4ef1
	jr z,+			; $4ef2
	inc (hl)		; $4ef4
+
	ld a,(wLinkStateParameter)		; $4ef5
	bit 4,a			; $4ef8
	jr nz,+			; $4efa
	call getThisRoomFlags		; $4efc
	res 4,(hl)		; $4eff
+
.ifdef ROM_AGES
	ld a,SND_TIMEWARP_COMPLETED		; $4f01
.else
	ld a,$d4
.endif
	call playSound		; $4f03

	ld de,w1Link		; $4f06
	jp objectDelete_de		; $4f09

;;
; LINK_STATE_08
; @addr{4f0c}
_linkState08:
	ld e,SpecialObject.state2		; $4f0c
	ld a,(de)		; $4f0e
	rst_jumpTable			; $4f0f
	.dw @substate0
	.dw @substate1

@substate0:
	; Go to substate 1
	ld a,$01		; $4f14
	ld (de),a		; $4f16

	ld hl,wcc50		; $4f17
	ld a,(hl)		; $4f1a
	ld (hl),$00		; $4f1b
	or a			; $4f1d
	ret nz			; $4f1e

	call linkCancelAllItemUsageAndClearAdjacentWallsBitset		; $4f1f
	ld a,LINK_ANIM_MODE_WALK		; $4f22
	jp specialObjectSetAnimation		; $4f24

@substate1:
	call _checkLinkForceState		; $4f27

	ld hl,wcc50		; $4f2a
	ld a,(hl)		; $4f2d
	or a			; $4f2e
	jr z,+			; $4f2f
	ld (hl),$00		; $4f31
	call specialObjectSetAnimation		; $4f33
+
	ld a,(wcc63)		; $4f36
	or a			; $4f39
	call nz,checkUseItems		; $4f3a

	ld a,(wDisabledObjects)		; $4f3d
	or a			; $4f40
	ret nz			; $4f41

	jp _initLinkStateAndAnimateStanding		; $4f42

;;
; @addr{4f45}
linkCancelAllItemUsageAndClearAdjacentWallsBitset:
	ld e,SpecialObject.adjacentWallsBitset		; $4f45
	xor a			; $4f47
	ld (de),a		; $4f48
;;
; Drop any held items, cancels usage of sword, etc?
; @addr{4f49}
linkCancelAllItemUsage:
	call dropLinkHeldItem		; $4f49
	jp clearAllParentItems		; $4f4c

;;
; LINK_STATE_0e
; @addr{4f4f}
_linkState0e:
	ld e,SpecialObject.state2		; $4f4f
	ld a,(de)		; $4f51
	rst_jumpTable			; $4f52
	.dw @substate0
	.dw @substate1
	.dw @substate2

@substate0:
	call itemIncState2		; $4f59
	ld e,SpecialObject.var37		; $4f5c
	ld a,(wActiveRoom)		; $4f5e
	ld (de),a		; $4f61

@substate1:
	call objectCheckWithinScreenBoundary		; $4f62
	ret c			; $4f65
	call itemIncState2		; $4f66
	call objectSetInvisible		; $4f69

@substate2:
	ld h,d			; $4f6c
	ld l,SpecialObject.var37		; $4f6d
	ld a,(wActiveRoom)		; $4f6f
	cp (hl)			; $4f72
	ret nz			; $4f73

	call objectCheckWithinScreenBoundary		; $4f74
	ret nc			; $4f77

	ld e,SpecialObject.state2		; $4f78
	ld a,$01		; $4f7a
	ld (de),a		; $4f7c
	jp objectSetVisiblec2		; $4f7d

;;
; LINK_STATE_TOSSED_BY_GUARDS
; @addr{4f80}
_linkState0f:
	ld a,(wTextIsActive)		; $4f80
	or a			; $4f83
	ret nz			; $4f84

	ld e,SpecialObject.state2		; $4f85
	ld a,(de)		; $4f87
	rst_jumpTable			; $4f88
	.dw @substate0
	.dw @substate1
	.dw @substate2

@substate0:
	call itemIncState2		; $4f8f

	; [SpecialObject.counter1] = $14
	inc l			; $4f92
	ld (hl),$14		; $4f93

	ld l,SpecialObject.angle		; $4f95
	ld (hl),$10		; $4f97
	ld l,SpecialObject.yh		; $4f99
	ld (hl),$38		; $4f9b
	ld l,SpecialObject.xh		; $4f9d
	ld (hl),$50		; $4f9f
	ld l,SpecialObject.speed		; $4fa1
	ld (hl),SPEED_100		; $4fa3

	ld l,SpecialObject.speedZ		; $4fa5
	ld a,$80		; $4fa7
	ldi (hl),a		; $4fa9
	ld (hl),$fe		; $4faa

	ld a,LINK_ANIM_MODE_COLLAPSED		; $4fac
	call specialObjectSetAnimation		; $4fae

	jp objectSetVisiblec2		; $4fb1

@substate1:
	call objectApplySpeed		; $4fb4

	ld c,$20		; $4fb7
	call objectUpdateSpeedZAndBounce		; $4fb9
	ret nc ; Return if Link can still bounce

	jp itemIncState2		; $4fbd

@substate2:
	call itemDecCounter1		; $4fc0
	ret nz			; $4fc3
	jp _initLinkStateAndAnimateStanding		; $4fc4

;;
; LINK_STATE_FORCE_MOVEMENT
; @addr{4fc7}
_linkState0b:
	ld e,SpecialObject.state2		; $4fc7
	ld a,(de)		; $4fc9
	rst_jumpTable			; $4fca
	.dw @substate0
	.dw @substate1

@substate0:
	ld a,$01		; $4fcf
	ld (de),a		; $4fd1

	ld e,SpecialObject.counter1		; $4fd2
	ld a,(wLinkStateParameter)		; $4fd4
	ld (de),a		; $4fd7

	call clearPegasusSeedCounter		; $4fd8
	call linkCancelAllItemUsageAndClearAdjacentWallsBitset		; $4fdb
	call updateLinkSpeed_standard		; $4fde

	ld a,LINK_ANIM_MODE_WALK		; $4fe1
	call specialObjectSetAnimation		; $4fe3

@substate1:
	call specialObjectAnimate		; $4fe6
	call itemDecCounter1		; $4fe9
	ld l,SpecialObject.adjacentWallsBitset		; $4fec
	ld (hl),$00		; $4fee
	jp nz,specialObjectUpdatePosition		; $4ff0

	; When counter1 reaches 0, go back to LINK_STATE_NORMAL.
	jp _initLinkStateAndAnimateStanding		; $4ff3


;;
; LINK_STATE_04
; @addr{4ff6}
_linkState04:
	ld e,SpecialObject.state2		; $4ff6
	ld a,(de)		; $4ff8
	rst_jumpTable			; $4ff9
	.dw @substate0
	.dw @substate1

@substate0:
	; Go to substate 1
	ld a,$01		; $4ffe
	ld (de),a		; $5000

	call linkCancelAllItemUsage		; $5001

	ld e,SpecialObject.animMode		; $5004
	ld a,(de)		; $5006
	ld ($cc52),a		; $5007

	ld a,(wcc50)		; $500a
	and $0f			; $500d
	add $0e			; $500f
	jp specialObjectSetAnimation		; $5011

@substate1:
	call retIfTextIsActive		; $5014
	ld a,(wcc50)		; $5017
	rlca			; $501a
	jr c,+			; $501b

	ld a,(wDisabledObjects)		; $501d
	and $81			; $5020
	ret nz			; $5022
+
	ld e,SpecialObject.state		; $5023
	ld a,LINK_STATE_NORMAL		; $5025
	ld (de),a		; $5027
	ld a,($cc52)		; $5028
	jp specialObjectSetAnimation		; $502b

;;
; @addr{502e}
setLinkStateToDead:
	ld a,LINK_STATE_DYING		; $502e
	call linkSetState		; $5030
;;
; LINK_STATE_DYING
; @addr{5033}
_linkState03:
	xor a			; $5033
	ld (wLinkHealth),a		; $5034
	ld e,SpecialObject.state2		; $5037
	ld a,(de)		; $5039
	rst_jumpTable			; $503a
	.dw @substate0
	.dw @substate1

; Link just started dying (initialization)
@substate0:
	call _specialObjectUpdateAdjacentWallsBitset		; $503f

	ld e,SpecialObject.knockbackCounter		; $5042
	ld a,(de)		; $5044
	or a			; $5045
	jp nz,_linkUpdateKnockback		; $5046

	ld h,d			; $5049
	ld l,SpecialObject.state2		; $504a
	inc (hl)		; $504c

	ld l,SpecialObject.counter1		; $504d
	ld (hl),$04		; $504f

	call linkCancelAllItemUsage		; $5051

	ld a,LINK_ANIM_MODE_SPIN		; $5054
	call specialObjectSetAnimation		; $5056
	ld a,SND_LINK_DEAD		; $5059
	jp playSound		; $505b

; Link is in the process of dying (spinning around)
@substate1:
	call resetLinkInvincibility		; $505e
	call specialObjectAnimate		; $5061

	ld h,d			; $5064
	ld l,SpecialObject.animParameter		; $5065
	ld a,(hl)		; $5067
	add a			; $5068
	jr nz,@triggerGameOver		; $5069
	ret nc			; $506b

; When animParameter is $80 or above, change link's animation to "unconscious"
	ld l,SpecialObject.counter1		; $506c
	dec (hl)		; $506e
	ret nz			; $506f
	ld a,LINK_ANIM_MODE_COLLAPSED		; $5070
	jp specialObjectSetAnimation		; $5072

@triggerGameOver:
	ld a,$ff		; $5075
	ld (wGameOverScreenTrigger),a		; $5077
	ret			; $507a

;;
; LINK_STATE_RESPAWNING
;
; This state behaves differently depending on wLinkStateParameter:
;  0: Fall down a hole
;  1: Fall down a hole without centering Link on the tile
;  2: Respawn instantly
;  3: Fall down a hole, different behaviour?
;  4: Drown
; @addr{507b}
_linkState02:
	ld a,$ff		; $507b
	ld (wGameKeysPressed),a		; $507d

	; Disable the push animation
	ld a,$80		; $5080
	ld (wForceLinkPushAnimation),a		; $5082

	ld e,SpecialObject.state2		; $5085
	ld a,(de)		; $5087
	rst_jumpTable			; $5088
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4
	.dw @substate5

; Initialization
@substate0:
	call linkCancelAllItemUsage		; $5095

	ld a,(wLinkStateParameter)		; $5098
	rst_jumpTable			; $509b
	.dw @parameter_fallDownHole
	.dw @parameter_fallDownHoleWithoutCentering
	.dw @respawn
	.dw @parameter_3
	.dw @parameter_drown

@parameter_drown:
	ld e,SpecialObject.state2		; $50a6
	ld a,$05		; $50a8
	ld (de),a		; $50aa
	ld a,LINK_ANIM_MODE_DROWN		; $50ab
	jp specialObjectSetAnimation		; $50ad

@parameter_fallDownHole:
	call objectCenterOnTile		; $50b0

@parameter_fallDownHoleWithoutCentering:
	call itemIncState2		; $50b3
	jr ++			; $50b6

@parameter_3:
	ld e,SpecialObject.state2		; $50b8
	ld a,$04		; $50ba
	ld (de),a		; $50bc
++
	; Disable collisions
	ld h,d			; $50bd
	ld l,SpecialObject.collisionType		; $50be
	res 7,(hl)		; $50c0

	; Do the "fall in hole" animation
	ld a,LINK_ANIM_MODE_FALLINHOLE		; $50c2
	call specialObjectSetAnimation		; $50c4
	ld a,SND_LINK_FALL		; $50c7
	jp playSound		; $50c9


; Doing a "falling down hole" animation, waiting for it to finish
@substate1:
	; Wait for the animation to finish
	ld h,d			; $50cc
	ld l,SpecialObject.animParameter		; $50cd
	bit 7,(hl)		; $50cf
	jp z,specialObjectAnimate		; $50d1

	ld a,(wActiveTileType)		; $50d4
	cp TILETYPE_WARPHOLE			; $50d7
	jr nz,@respawn		; $50d9

.ifdef ROM_AGES
	; Check if the current room is the moblin keep with the crumbling floors
	ld a,(wActiveGroup)		; $50db
	cp $02			; $50de
	jr nz,+			; $50e0
	ld a,(wActiveRoom)		; $50e2
	cp $9f			; $50e5
	jr nz,+			; $50e7

	jpab bank1.warpToMoblinKeepUnderground		; $50e9
+
.endif
	; This function call will only work in dungeons.
	jpab bank1.initiateFallDownHoleWarp		; $50f1

@respawn:
	call specialObjectSetCoordinatesToRespawnYX		; $50f9
	ld l,SpecialObject.state2		; $50fc
	ld a,$02		; $50fe
	ldi (hl),a		; $5100

	; [SpecialObject.counter1] = $02
	ld (hl),a		; $5101

	call specialObjectTryToBreakTile_source05		; $5102

	; Set wEnteredWarpPosition, which prevents Link from instantly activating a warp
	; tile if he respawns on one.
	call objectGetTileAtPosition		; $5105
	ld a,l			; $5108
	ld (wEnteredWarpPosition),a		; $5109

	jp objectSetInvisible		; $510c


; Waiting for counter1 to reach 0 before having Link reappear.
@substate2:
	ld h,d			; $510f
	ld l,SpecialObject.counter1		; $5110

	; Check if the screen is scrolling?
	ld a,(wScrollMode)		; $5112
	and $80			; $5115
	jr z,+			; $5117
	ld (hl),$04		; $5119
	ret			; $511b
+
	dec (hl)		; $511c
	ret nz			; $511d

	; Counter has reached 0; make Link reappear, apply damage

	xor a			; $511e
	ld (wLinkInAir),a		; $511f
	ld (wLinkSwimmingState),a		; $5122

	ld a,GOLD_LUCK_RING		; $5125
	call cpActiveRing		; $5127
	ld a,$fc		; $512a
	jr nz,+			; $512c
	sra a			; $512e
+
	call itemIncState2		; $5130

	ld l,SpecialObject.damageToApply		; $5133
	ld (hl),a		; $5135
	ld l,SpecialObject.invincibilityCounter		; $5136
	ld (hl),$3c		; $5138

	ld l,SpecialObject.counter1		; $513a
	ld (hl),$10		; $513c

	call linkApplyDamage		; $513e
	call objectSetVisiblec1		; $5141
	call _specialObjectUpdateAdjacentWallsBitset		; $5144
	jp _animateLinkStanding		; $5147


; Waiting for counter1 to reach 0 before switching back to LINK_STATE_NORMAL.
@substate3:
	call itemDecCounter1		; $514a
	ret nz			; $514d

	; Enable collisions
	ld l,SpecialObject.collisionType		; $514e
	set 7,(hl)		; $5150

	jp _initLinkStateAndAnimateStanding		; $5152


@substate4:
	ld h,d			; $5155
	ld l,SpecialObject.animParameter		; $5156
	bit 7,(hl)		; $5158
	jp z,specialObjectAnimate		; $515a
	call objectSetInvisible		; $515d
	jp _checkLinkForceState		; $5160


; Drowning instead of falling into a hole
@substate5:
	ld e,SpecialObject.animParameter		; $5163
	ld a,(de)		; $5165
	rlca			; $5166
	jp nc,specialObjectAnimate		; $5167
	jr @respawn		; $516a

;;
; Makes Link surface from an underwater area if he's pressed B.
; @addr{516c}
_checkForUnderwaterTransition:
	ld a,(wDisableScreenTransitions)		; $516c
	or a			; $516f
	ret nz			; $5170
	ld a,(wAreaFlags)		; $5171
	and AREAFLAG_UNDERWATER			; $5174
	ret z			; $5176
	ld a,(wGameKeysJustPressed)		; $5177
	and BTN_B			; $517a
	ret z			; $517c

	ld a,(wActiveTilePos)		; $517d
	ld l,a			; $5180
	ld h,>wRoomLayout		; $5181
	ld a,(hl)		; $5183
	ld hl,tileTypesTable		; $5184
	call lookupCollisionTable		; $5187

	; Don't allow surfacing on whirlpools
	cp TILETYPE_WHIRLPOOL			; $518a
	ret z			; $518c

	; Move down instead of up when over a "warp hole" (only used in jabu-jabu?)
	cp TILETYPE_WARPHOLE			; $518d
	jr z,@levelDown		; $518f

	; Return if Link can't surface here
	call checkLinkCanSurface		; $5191
	ret nc			; $5194

	; Return from the caller (_linkState01)
	pop af			; $5195

	ld a,(wAreaFlags)		; $5196
	and AREAFLAG_DUNGEON			; $5199
	jr nz,@dungeon		; $519b

	; Not in a dungeon

	; Set 'c' to the value to add to wActiveGroup.
	; Set 'a' to the room index to end up in.
	ld c,$fe		; $519d
	ld a,(wActiveRoom)		; $519f
	jr @initializeWarp		; $51a2

@dungeon:
	; Increment the floor you're on, get the new room index
	ld a,(wDungeonFloor)		; $51a4
	inc a			; $51a7
	ld (wDungeonFloor),a		; $51a8
	call getActiveRoomFromDungeonMapPosition		; $51ab
	ld c,$00		; $51ae
	jr @initializeWarp		; $51b0

	; Go down a level instead of up one
@levelDown:
	; Return from caller
	pop af			; $51b2

	ld a,(wAreaFlags)		; $51b3
	and AREAFLAG_DUNGEON			; $51b6
	jr nz,+			; $51b8

	; Not in a dungeon: add 2 to wActiveGroup.
	ld c,$02		; $51ba
	ld a,(wActiveRoom)		; $51bc
	jr @initializeWarp		; $51bf
+
	; In a dungeon: decrement the floor you're on, get the new room index
	ld a,(wDungeonFloor)		; $51c1
	dec a			; $51c4
	ld (wDungeonFloor),a		; $51c5
	call getActiveRoomFromDungeonMapPosition		; $51c8
	ld c,$00		; $51cb
	jr @initializeWarp		; $51cd

@initializeWarp:
	ld (wWarpDestIndex),a		; $51cf

	ld a,(wActiveGroup)		; $51d2
	add c			; $51d5
	or $80			; $51d6
	ld (wWarpDestGroup),a		; $51d8

	ld a,(wActiveTilePos)		; $51db
	ld (wWarpDestPos),a		; $51de

	ld a,$00		; $51e1
	ld (wWarpTransition),a		; $51e3

	ld a,$03		; $51e6
	ld (wWarpTransition2),a		; $51e8
	ret			; $51eb

;;
; LINK_STATE_GRABBED_BY_WALLMASTER
; @addr{51ec}
_linkState0c:
	ld e,SpecialObject.state2		; $51ec
	ld a,(de)		; $51ee
	rst_jumpTable			; $51ef
	.dw @substate0
	.dw @substate1
	.dw @substate2

@substate0:
	; Go to substate 1
	ld a,$01		; $51f6
	ld (de),a		; $51f8

	ld (wWarpsDisabled),a		; $51f9

	xor a			; $51fc
	ld e,SpecialObject.collisionType		; $51fd
	ld (de),a		; $51ff

	ld a,$00		; $5200
	ld (wScrollMode),a		; $5202

	call linkCancelAllItemUsage		; $5205

	ld a,SND_BOSS_DEAD		; $5208
	jp playSound		; $520a


; The wallmaster writes [w1Link.state2] = 2 when Link is fully dragged off-screen.
@substate2:
	xor a			; $520d
	ld (wWarpsDisabled),a		; $520e

	ld hl,wWarpDestGroup		; $5211
	ld a,(wActiveGroup)		; $5214
	or $80			; $5217
	ldi (hl),a		; $5219

	; wWarpDestIndex
	ld a,(wDungeonWallmasterDestRoom)		; $521a
	ldi (hl),a		; $521d

	; wWarpDestTransition
	ld a,TRANSITION_DEST_FALL		; $521e
	ldi (hl),a		; $5220

	; wWarpDestPos
	ld a,$87		; $5221
	ldi (hl),a		; $5223

	; wWarpDestTransition2
	ld (hl),$03		; $5224

; Substate 1: waiting for the wallmaster to increment w1Link.state2.
@substate1:
	ret			; $5226

;;
; LINK_STATE_STONE
; Only used in Seasons for the Medusa boss
; @addr{5227}
_linkState13:
	ld a,$80		; $5227
	ld (wForceLinkPushAnimation),a		; $5229

	ld e,SpecialObject.state2		; $522c
	ld a,(de)		; $522e
	rst_jumpTable			; $522f
	.dw @substate0
	.dw @substate1

@substate0:
	call itemIncState2		; $5234

	; [SpecialObject.counter1] = $b4
	inc l			; $5237
	ld (hl),$b4		; $5238

	ld l,SpecialObject.oamFlagsBackup		; $523a
	ld a,$0f		; $523c
	ldi (hl),a		; $523e
	ld (hl),a		; $523f

	ld a,PALH_7f		; $5240
	call loadPaletteHeader		; $5242

	xor a			; $5245
	ld (wcc50),a		; $5246
	ret			; $5249


; This is used by both _linkState13 and _linkState14.
; Waits for counter1 to reach 0, then restores Link to normal.
@substate1:
	ld c,$40		; $524a
	call objectUpdateSpeedZ_paramC		; $524c
	ld a,(wcc50)		; $524f
	or a			; $5252
	jr z,+			; $5253

	call updateLinkDirectionFromAngle		; $5255

	ld l,SpecialObject.var2a		; $5258
	ld a,(hl)		; $525a
	or a			; $525b
	jr nz,@restoreToNormal		; $525c
+
	; Restore Link to normal more quickly when pressing any button.
	ld c,$01		; $525e
	ld a,(wGameKeysJustPressed)		; $5260
	or a			; $5263
	jr z,+			; $5264
	ld c,$04		; $5266
+
	ld l,SpecialObject.counter1		; $5268
	ld a,(hl)		; $526a
	sub c			; $526b
	ld (hl),a		; $526c
	ret nc			; $526d

@restoreToNormal:
	ld l,SpecialObject.oamFlagsBackup		; $526e
	ld a,$08		; $5270
	ldi (hl),a		; $5272
	ld (hl),a		; $5273

	ld l,SpecialObject.knockbackCounter		; $5274
	ld (hl),$00		; $5276

	xor a			; $5278
	ld (wLinkForceState),a		; $5279
	jp _initLinkStateAndAnimateStanding		; $527c

;;
; LINK_STATE_COLLAPSED
; @addr{527f}
_linkState14:
	ld e,SpecialObject.state2		; $527f
	ld a,(de)		; $5281
	rst_jumpTable			; $5282
	.dw @substate0
	.dw _linkState13@substate1

@substate0:
	call itemIncState2		; $5287

	ld l,SpecialObject.counter1		; $528a
	ld (hl),$f0		; $528c
	call linkCancelAllItemUsage		; $528e

	ld a,(wcc50)		; $5291
	or a			; $5294
	ld a,LINK_ANIM_MODE_COLLAPSED		; $5295
	jr z,+			; $5297
	ld a,LINK_ANIM_MODE_WALK		; $5299
+
	jp specialObjectSetAnimation		; $529b

;;
; LINK_STATE_GRABBED
; Grabbed by Like-like, Gohma, Veran spider form?
; @addr{529e}
_linkState0d:
	ld a,$80		; $529e
	ld (wcc92),a		; $52a0
	ld e,SpecialObject.state2		; $52a3
	ld a,(de)		; $52a5
	rst_jumpTable			; $52a6
	.dw @substate0
	.dw updateLinkDamageTaken
	.dw @substate2
	.dw @substate3
	.dw @substate4

; Initialization
@substate0:
	ld a,$01		; $52b1
	ld (de),a		; $52b3
	ld (wWarpsDisabled),a		; $52b4

	ld e,SpecialObject.animMode		; $52b7
	xor a			; $52b9
	ld (de),a		; $52ba

	jp linkCancelAllItemUsage		; $52bb

; Link has been released, now he's about to fly downwards
@substate2:
	ld a,$03		; $52be
	ld (de),a		; $52c0

	ld h,d			; $52c1
	ld l,SpecialObject.counter1		; $52c2
	ld (hl),$1e		; $52c4

	ld l,SpecialObject.speedZ		; $52c6
	ld a,$20		; $52c8
	ldi (hl),a		; $52ca
	ld (hl),$fe		; $52cb

	; Face up
	ld l,SpecialObject.direction		; $52cd
	xor a			; $52cf
	ldi (hl),a		; $52d0

	; [SpecialObject.angle] = $10 (move down)
	ld (hl),$10		; $52d1

	ld l,SpecialObject.speed		; $52d3
	ld (hl),SPEED_180		; $52d5
	ld a,LINK_ANIM_MODE_GALE		; $52d7
	jp specialObjectSetAnimation		; $52d9

; Continue moving downwards until counter1 reaches 0
@substate3:
	call itemDecCounter1		; $52dc
	jr z,++			; $52df

	ld c,$20		; $52e1
	call objectUpdateSpeedZ_paramC		; $52e3
	call _specialObjectUpdateAdjacentWallsBitset		; $52e6
	call specialObjectUpdatePosition		; $52e9
	jp specialObjectAnimate		; $52ec


; Link is released without anything special.
; ENEMYID_LIKE_LIKE sends Link to this state directly upon release.
@substate4:
	ld h,d			; $52ef
	ld l,SpecialObject.invincibilityCounter		; $52f0
	ld (hl),$94		; $52f2
++
	xor a			; $52f4
	ld (wWarpsDisabled),a		; $52f5
	jp _initLinkStateAndAnimateStanding		; $52f8

;;
; LINK_STATE_SLEEPING
; @addr{52fb}
_linkState05:
	ld e,SpecialObject.state2		; $52fb
	ld a,(de)		; $52fd
	rst_jumpTable			; $52fe
	.dw @substate0
	.dw @substate1
	.dw @substate2

; Just touched the bed
@substate0:
	call itemIncState2		; $5305

	ld l,SpecialObject.speed		; $5308
	ld (hl),SPEED_80		; $530a

	; Set destination position (var37 / var38)
	ld l,$18		; $530c
	ld a,$02		; $530e
	call _specialObjectSetVar37AndVar38		; $5310

	ld bc,-$180		; $5313
	call objectSetSpeedZ		; $5316

	ld a,$81		; $5319
	ld (wLinkInAir),a		; $531b

	ld a,LINK_ANIM_MODE_SLEEPING		; $531e
	jp specialObjectSetAnimation		; $5320

; Jumping into the bed
@substate1:
	call specialObjectAnimate		; $5323
	call _specialObjectSetAngleRelativeToVar38		; $5326
	call objectApplySpeed		; $5329

	ld c,$20		; $532c
	call objectUpdateSpeedZ_paramC		; $532e
	ret nz			; $5331

	call itemIncState2		; $5332
	jp _specialObjectSetPositionToVar38IfSet		; $5335

; Sleeping; do various things depending on "animParameter".
@substate2:
	call specialObjectAnimate		; $5338
	ld h,d			; $533b
	ld l,SpecialObject.animParameter		; $533c
	ld a,(hl)		; $533e
	ld (hl),$00		; $533f
	rst_jumpTable			; $5341
	.dw @animParameter0
	.dw @animParameter1
	.dw @animParameter2
	.dw @animParameter3
	.dw @animParameter4

@animParameter1:
	call darkenRoomLightly		; $534c
	ld a,$06		; $534f
	ld (wPaletteThread_updateRate),a		; $5351
	ret			; $5354

@animParameter2:
	ld hl,wLinkMaxHealth		; $5355
	ldd a,(hl)		; $5358
	ld (hl),a		; $5359

@animParameter0:
	ret			; $535a

@animParameter3:
	jp brightenRoom		; $535b

@animParameter4:
	ld bc,-$180		; $535e
	call objectSetSpeedZ		; $5361

	ld l,SpecialObject.direction		; $5364
	ld (hl),DIR_LEFT		; $5366

	; [SpecialObject.angle] = $18
	inc l			; $5368
	ld (hl),$18		; $5369

	ld l,SpecialObject.speed		; $536b
	ld (hl),SPEED_80		; $536d

	ld a,$81		; $536f
	ld (wLinkInAir),a		; $5371
	jp _initLinkStateAndAnimateStanding		; $5374

;;
; LINK_STATE_06
; Moves Link up until he's no longer in a solid wall?
; @addr{5377}
_linkState06:
	ld e,SpecialObject.state2		; $5377
	ld a,(de)		; $5379
	rst_jumpTable			; $537a
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate0:
	; Go to substate 1
	ld a,$01		; $5383
	ld (de),a		; $5385

	ld h,d			; $5386
	ld l,SpecialObject.counter1		; $5387
	ld (hl),$08		; $5389
	ld l,SpecialObject.speed		; $538b
	ld (hl),SPEED_200		; $538d

	; Set angle to "up"
	ld l,SpecialObject.angle		; $538f
	ld (hl),$00		; $5391

	ld a,$81		; $5393
	ld (wLinkInAir),a		; $5395
	ld a,SND_JUMP		; $5398
	call playSound		; $539a

@substate1:
	call specialObjectUpdatePositionWithoutTileEdgeAdjust		; $539d
	call itemDecCounter1		; $53a0
	ret nz			; $53a3

	; Go to substate 2
	ld l,SpecialObject.state2		; $53a4
	inc (hl)		; $53a6

	ld l,SpecialObject.direction		; $53a7
	ld (hl),$00		; $53a9
	ld a,LINK_ANIM_MODE_FALL		; $53ab
	call specialObjectSetAnimation		; $53ad

@substate2:
	call specialObjectAnimate		; $53b0
	ld a,(wScrollMode)		; $53b3
	and $01			; $53b6
	ret z			; $53b8

	call objectCheckTileCollision_allowHoles		; $53b9
	jp c,specialObjectUpdatePositionWithoutTileEdgeAdjust		; $53bc

	ld bc,-$200		; $53bf
	call objectSetSpeedZ		; $53c2

	; Go to substate 3
	ld l,SpecialObject.state2		; $53c5
	inc (hl)		; $53c7

	ld l,SpecialObject.speed		; $53c8
	ld (hl),SPEED_40		; $53ca
	ld a,LINK_ANIM_MODE_JUMP		; $53cc
	call specialObjectSetAnimation		; $53ce

@substate3:
	call specialObjectAnimate		; $53d1
	call _specialObjectUpdateAdjacentWallsBitset		; $53d4
	call specialObjectUpdatePosition		; $53d7
	ld c,$18		; $53da
	call objectUpdateSpeedZ_paramC		; $53dc
	ret nz			; $53df

	xor a			; $53e0
	ld (wLinkInAir),a		; $53e1
	ld (wWarpsDisabled),a		; $53e4
	jp _initLinkStateAndAnimateStanding		; $53e7

;;
; LINK_STATE_AMBI_POSSESSED_CUTSCENE
; This state is used during the cutscene in the black tower where Ambi gets un-possessed.
; @addr{53ea}
_linkState09:
	ld e,SpecialObject.state2		; $53ea
	ld a,(de)		; $53ec
	rst_jumpTable			; $53ed
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4
	.dw @substate5


; Initialization
@substate0:
	call itemIncState2		; $53fa

; Backing up to the right

	ld l,SpecialObject.speed		; $53fd
	ld (hl),SPEED_100		; $53ff
	ld l,SpecialObject.direction		; $5401
	ld (hl),DIR_LEFT		; $5403

	; [SpecialObject.angle] = $08
	inc l			; $5405
	ld (hl),$08		; $5406

	ld l,SpecialObject.counter1		; $5408
	ld (hl),$0c		; $540a

@substate1:
	call itemDecCounter1		; $540c
	jr nz,@animate	; $540f

; Moving back left

	ld (hl),$0c		; $5411

	; Go to substate 2
	ld l,e			; $5413
	inc (hl)		; $5414

	ld l,SpecialObject.angle		; $5415
	ld (hl),$18		; $5417

@substate2:
	call itemDecCounter1		; $5419
	jr nz,@animate	; $541c

; Looking down

	ld (hl),$32		; $541e

	; Go to substate 3
	ld l,e			; $5420
	inc (hl)		; $5421

	ld l,SpecialObject.direction		; $5422
	ld (hl),DIR_DOWN		; $5424

@substate3:
	call itemDecCounter1		; $5426
	ret nz			; $5429

; Looking up with an exclamation mark

	; Go to substate 4
	ld l,e			; $542a
	inc (hl)		; $542b

	ld l,SpecialObject.direction		; $542c
	ld (hl),DIR_UP		; $542e

	; [SpecialObject.angle] = $10
	inc l			; $5430
	ld (hl),$10		; $5431

	ld l,SpecialObject.counter1		; $5433
	ld a,$1e		; $5435
	ld (hl),a		; $5437

	ld bc,$f4f8		; $5438
	jp objectCreateExclamationMark		; $543b

@substate4:
	call itemDecCounter1		; $543e
	ret nz			; $5441

; Jumping away

	; Go to substate 5
	ld l,e			; $5442
	inc (hl)		; $5443

	ld bc,-$180		; $5444
	call objectSetSpeedZ		; $5447

	ld a,LINK_ANIM_MODE_JUMP		; $544a
	call specialObjectSetAnimation		; $544c
	ld a,SND_JUMP		; $544f
	jp playSound		; $5451

@substate5:
	ld c,$18		; $5454
	call objectUpdateSpeedZ_paramC		; $5456
	jr nz,@animate	; $5459

	; a is 0 at this point
	ld l,SpecialObject.state2		; $545b
	ldd (hl),a		; $545d
	ld (hl),SpecialObject.direction		; $545e
	ret			; $5460

@animate:
	call specialObjectAnimate		; $5461
	jp specialObjectUpdatePositionWithoutTileEdgeAdjust		; $5464

;;
; LINK_STATE_SQUISHED
; @addr{5467}
_linkState11:
	ld e,SpecialObject.state2		; $5467
	ld a,(de)		; $5469
	rst_jumpTable			; $546a
	.dw @substate0
	.dw @substate1
	.dw @substate2

@substate0:
	ld a,$01		; $5471
	ld (de),a		; $5473

	call linkCancelAllItemUsage		; $5474

	xor a			; $5477
	ld e,SpecialObject.collisionType		; $5478
	ld (de),a		; $547a

	ld a,SND_DAMAGE_ENEMY		; $547b
	call playSound		; $547d

	; Check whether to do the horizontal or vertical squish animation
	ld a,(wcc50)		; $5480
	and $7f			; $5483
	ld a,LINK_ANIM_MODE_SQUISHX		; $5485
	jr z,+			; $5487
	inc a			; $5489
+
	call specialObjectSetAnimation		; $548a

@substate1:
	call specialObjectAnimate		; $548d

	; Wait for the animation to finish
	ld e,SpecialObject.animParameter		; $5490
	ld a,(de)		; $5492
	inc a			; $5493
	ret nz			; $5494

	call itemIncState2		; $5495
	ld l,SpecialObject.counter1		; $5498
	ld (hl),$14		; $549a

@substate2:
	call specialObjectAnimate		; $549c

	; Invisible every other frame
	ld a,(wFrameCounter)		; $549f
	rrca			; $54a2
	jp c,objectSetInvisible		; $54a3

	call objectSetVisible		; $54a6
	call itemDecCounter1		; $54a9
	ret nz			; $54ac

	ld a,(wcc50)		; $54ad
	bit 7,a			; $54b0
	jr nz,+			; $54b2

	call respawnLink		; $54b4
	jr _checkLinkForceState		; $54b7
+
	ld a,LINK_STATE_DYING		; $54b9
	ld (wLinkForceState),a		; $54bb
	jr _checkLinkForceState		; $54be

;;
; Checks wLinkForceState, and sets Link's state to that value if it's nonzero.
; This also returns from the function that called it if his state changed.
; @addr{54c0}
_checkLinkForceState:
	ld hl,wLinkForceState		; $54c0
	ld a,(hl)		; $54c3
	or a			; $54c4
	ret z			; $54c5

	ld (hl),$00		; $54c6
	pop hl			; $54c8

;;
; Sets w1Link.state to the given value, and w1Link.state2 to $00.
; For some reason, this also runs the code for the state immediately if it's
; LINK_STATE_WARPING, LINK_STATE_GRABBED_BY_WALLMASTER, or LINK_STATE_GRABBED.
;
; @param	a	New value for w1Link.state
; @param	d	Link object
; @addr{54c9}
linkSetState:
	ld h,d			; $54c9
	ld l,SpecialObject.state		; $54ca
	ldi (hl),a		; $54cc
	ld (hl),$00		; $54cd
	cp LINK_STATE_WARPING			; $54cf
	jr z,+			; $54d1

	cp LINK_STATE_GRABBED_BY_WALLMASTER			; $54d3
	jr z,+			; $54d5

	cp LINK_STATE_GRABBED			; $54d7
	ret nz			; $54d9
+
	jp specialObjectCode_link		; $54da

;;
; LINK_STATE_NORMAL
; LINK_STATE_10
; @addr{54dd}
_linkState01:
_linkState10:
	; This should prevent Link from ever doing his pushing animation.
	; Under normal circumstances, this should be overwritten with $00 later, allowing
	; him to do his pushing animation when necessary.
	ld a,$80		; $54dd
	ld (wForceLinkPushAnimation),a		; $54df

	; For some reason, Link can't do anything while the palette is changing
	ld a,(wPaletteThread_mode)		; $54e2
	or a			; $54e5
	ret nz			; $54e6

	ld a,(wScrollMode)		; $54e7
	and $0e			; $54ea
	ret nz			; $54ec

	call updateLinkDamageTaken		; $54ed
	ld a,(wLinkDeathTrigger)		; $54f0
	or a			; $54f3
	jp nz,setLinkStateToDead		; $54f4

	; This will return if [wLinkForceState] != 0
	call _checkLinkForceState		; $54f7

	call retIfTextIsActive		; $54fa

	ld a,(wDisabledObjects)		; $54fd
	and $81			; $5500
	ret nz			; $5502

	call decPegasusSeedCounter		; $5503

	ld a,(w1Companion.id)		; $5506
	cp SPECIALOBJECTID_MINECART			; $5509
	jr z,++			; $550b
	cp SPECIALOBJECTID_RAFT			; $550d
	jr z,++			; $550f

	; Return if Link is riding an animal?
	ld a,(wLinkObjectIndex)		; $5511
	rrca			; $5514
	ret c			; $5515

	ld a,(wLinkPlayingInstrument)		; $5516
	ld b,a			; $5519
	ld a,(wLinkInAir)		; $551a
	or b			; $551d
	jr nz,++		; $551e

	ld e,SpecialObject.knockbackCounter		; $5520
	ld a,(de)		; $5522
	or a			; $5523
	jr nz,++		; $5524

	; Return if Link interacts with an object
	call linkInteractWithAButtonSensitiveObjects		; $5526
	ret c			; $5529

	; Deal with push blocks, chests, signs, etc. and return if he opened a chest, read
	; a sign, or opened an overworld keyhole?
	call interactWithTileBeforeLink		; $552a
	ret c			; $552d
++
	xor a			; $552e
	ld (wForceLinkPushAnimation),a		; $552f
	ld (wLinkPlayingInstrument),a		; $5532

	ld a,(wAreaFlags)		; $5535
	and AREAFLAG_SIDESCROLL			; $5538
	jp nz,_linkState01_sidescroll		; $553a

	; The rest of this code is only run in non-sidescrolling areas.

	; Apply stuff like breakable floors, holes, conveyors, etc.
	call _linkApplyTileTypes		; $553d

	; Let Link move around if a chest spawned on top of him
	call checkAndUpdateLinkOnChest		; $5540

	; Check whether Link pressed A or B to use an item
	call checkUseItems		; $5543

	ld a,(wLinkPlayingInstrument)		; $5546
	or a			; $5549
	ret nz			; $554a

	call _specialObjectUpdateAdjacentWallsBitset		; $554b
	call _linkUpdateKnockback		; $554e

	; Jump if drowning
	ld a,(wLinkSwimmingState)		; $5551
	and $40			; $5554
	jr nz,++		; $5556

	ld a,(wMagnetGloveState)		; $5558
	bit 6,a			; $555b
	jr nz,++		; $555d

	ld a,(wLinkInAir)		; $555f
	or a			; $5562
	jr nz,++		; $5563

	ld a,(wLinkGrabState)		; $5565
	ld c,a			; $5568
	ld a,(wLinkImmobilized)		; $5569
	or c			; $556c
	jr nz,++		; $556d

	call checkLinkPushingAgainstBed		; $556f
	call _checkLinkJumpingOffCliff		; $5572
++
	call _linkUpdateInAir		; $5575
	ld a,(wLinkInAir)		; $5578
	or a			; $557b
	jr z,@notInAir			; $557c

	; Link is in the air, either jumping or going down a ledge.

	bit 7,a			; $557e
	jr nz,+			; $5580

	ld e,SpecialObject.speedZ+1		; $5582
	ld a,(de)		; $5584
	bit 7,a			; $5585
	call z,_linkUpdateVelocity		; $5587
+
	ld hl,wcc95		; $558a
	res 4,(hl)		; $558d
	call _specialObjectSetAngleRelativeToVar38		; $558f
	call specialObjectUpdatePosition		; $5592
	jp specialObjectAnimate		; $5595

@notInAir:
	ld a,(wMagnetGloveState)		; $5598
	bit 6,a			; $559b
	jp nz,_animateLinkStanding		; $559d

	ld e,SpecialObject.knockbackCounter		; $55a0
	ld a,(de)		; $55a2
	or a			; $55a3
	jp nz,_func_5631		; $55a4

	ld h,d			; $55a7
	ld l,SpecialObject.collisionType		; $55a8
	set 7,(hl)		; $55aa

	ld a,(wLinkSwimmingState)		; $55ac
	or a			; $55af
	jp nz,_linkUpdateSwimming		; $55b0

	call objectSetVisiblec1		; $55b3
	ld a,(wLinkObjectIndex)		; $55b6
	rrca			; $55b9
	jr nc,+			; $55ba


	; This is odd. The "jr z" line below will never jump since 'a' will never be 0.
	; A "cp" opcode instead of "or" would make a lot more sense. Is this a typo?
	; The only difference this makes is that, when on a raft, Link can change
	; directions while swinging his sword / using other items.

	ld a,(w1Companion.id)		; $55bc
	or SPECIALOBJECTID_RAFT			; $55bf
	jr z,@updateDirectionIfNotUsingItem	; $55c1
	jr @updateDirection		; $55c3
+
	; This will return if a transition occurs (pressed B in an underwater area).
	call _checkForUnderwaterTransition		; $55c5

	; Check whether Link is wearing a transformation ring or is a baby
	callab bank6.getTransformedLinkID		; $55c8
	ld a,b			; $55d0
	or a			; $55d1
	jp nz,setLinkIDOverride		; $55d2


	; Handle movement

	; Check if Link is underwater?
	ld h,d			; $55d5
	ld l,SpecialObject.var2f		; $55d6
	bit 7,(hl)		; $55d8
	jr z,+			; $55da

	; Do mermaid-suit-based movement
	call _linkUpdateVelocity@mermaidSuit		; $55dc
	jr ++			; $55df
+
	; Check if bits 0-3 of wLinkGrabState == 1 or 2.
	; (Link is grabbing or lifting something. This cancels ice physics.)
	ld a,(wLinkGrabState)		; $55e1
	and $0f			; $55e4
	dec a			; $55e6
	cp $02			; $55e7
	jr c,@normalMovement	; $55e9

	ld hl,wIsTileSlippery		; $55eb
	bit 6,(hl)		; $55ee
	jr z,@normalMovement	; $55f0

	; Slippery tile movement?
	ld c,$88		; $55f2
	call updateLinkSpeed_withParam		; $55f4
	call _linkUpdateVelocity		; $55f7
++
	ld a,(wLinkAngle)		; $55fa
	rlca			; $55fd
	ld c,$02		; $55fe
	jr c,@updateMovement	; $5600
	jr @walking		; $5602

@normalMovement:
	ld a,(wcc95)		; $5604
	ld b,a			; $5607

	ld e,SpecialObject.angle		; $5608
	ld a,(wLinkAngle)		; $560a
	ld (de),a		; $560d

	; Set cflag if in a spinner or wLinkAngle is set. (The latter case just means he
	; isn't moving.)
	or b			; $560e
	rlca			; $560f

	ld c,$00		; $5610
	jr c,@updateMovement	; $5612

	ld c,$01		; $5614
	ld a,(wLinkImmobilized)		; $5616
	or a			; $5619
	jr nz,@updateMovement	; $561a

	call updateLinkSpeed_standard		; $561c

@walking:
	ld c,$07		; $561f

@updateMovement:
	; The value of 'c' here determines whether Link should move, what his animation
	; should be, and whether the heart ring should apply. See the _linkUpdateMovement
	; function for details.
	call _linkUpdateMovement		; $5621

@updateDirectionIfNotUsingItem:
	ld a,(wLinkTurningDisabled)		; $5624
	or a			; $5627
	ret nz			; $5628

@updateDirection:
	jp updateLinkDirectionFromAngle		; $5629

;;
; @addr{562c}
linkResetSpeed:
	ld e,SpecialObject.speed		; $562c
	xor a			; $562e
	ld (de),a		; $562f
	ret			; $5630

;;
; Does something with Link's knockback when on a slippery tile?
; @addr{5631}
_func_5631:
	ld hl,wIsTileSlippery		; $5631
	bit 6,(hl)		; $5634
	ret z			; $5636
	ld e,SpecialObject.knockbackAngle		; $5637
	ld a,(de)		; $5639
	ld e,SpecialObject.angle		; $563a
	ld (de),a		; $563c
	ret			; $563d

;;
; Called once per frame that Link is moving.
;
; @param	a		Bits 0,1 set if Link's y,x offsets should be added to the
;				counter, respectively.
; @param	wTmpcec0	Offsets of Link's movement, to be added to wHeartRingCounter.
; @addr{563e}
_updateHeartRingCounter:
	ld e,a			; $563e
	ld a,(wActiveRing)		; $563f

	; b = number of steps (divided by $100, in pixels) until you get a heart refill.
	; c = number of quarter hearts to refill (times 4).

	ldbc $02,$08		; $5642
	cp HEART_RING_L1			; $5645
	jr z,@heartRingEquipped		; $5647

	cp HEART_RING_L2			; $5649
	jr nz,@clearCounter		; $564b
	ldbc $03,$10		; $564d

@heartRingEquipped:
	ld a,e			; $5650
	or c			; $5651
	ld c,a			; $5652
	push de			; $5653

	; Add Link's y position offset
	ld de,wTmpcec0+1		; $5654
	ld hl,wHeartRingCounter		; $5657
	srl c			; $565a
	call c,@addOffsetsToCounter		; $565c

	; Add Link's x position offset
	ld e,<wTmpcec0+3		; $565f
	ld l,<wHeartRingCounter		; $5661
	srl c			; $5663
	call c,@addOffsetsToCounter		; $5665

	; Check if the counter is high enough for a refill
	pop de			; $5668
	ld a,(wHeartRingCounter+2)		; $5669
	cp b			; $566c
	ret c			; $566d

	; Give hearts if health isn't full already
	ld hl,wLinkHealth		; $566e
	ldi a,(hl)		; $5671
	cp (hl)			; $5672
	ld a,TREASURE_HEART_REFILL		; $5673
	call c,giveTreasure		; $5675

@clearCounter:
	ld hl,wHeartRingCounter		; $5678
	xor a			; $567b
	ldi (hl),a		; $567c
	ldi (hl),a		; $567d
	ldi (hl),a		; $567e
	ret			; $567f

;;
; Adds the position offsets at 'de' to the counter at 'hl'.
; @addr{5680}
@addOffsetsToCounter:
	ld a,(de)		; $5680
	dec e			; $5681
	rlca			; $5682
	jr nc,+			; $5683

	; If moving in a negative direction, negate the offsets so they're positive again
	ld a,(de)		; $5685
	cpl			; $5686
	adc (hl)		; $5687
	ldi (hl),a		; $5688
	inc e			; $5689
	ld a,(de)		; $568a
	cpl			; $568b
	jr ++			; $568c
+
	ld a,(de)		; $568e
	add (hl)		; $568f
	ldi (hl),a		; $5690
	inc e			; $5691
	ld a,(de)		; $5692
++
	adc (hl)		; $5693
	ldi (hl),a		; $5694
	ret nc			; $5695
	inc (hl)		; $5696
	ret			; $5697

;;
; This is called from _linkState01 if [wLinkSwimmingState] != 0.
; Only for non-sidescrolling areas. (See also _linkUpdateSwimming_sidescroll.)
; @addr{5698}
_linkUpdateSwimming:
	ld a,(wLinkSwimmingState)		; $5698
	and $0f			; $569b

	ld hl,wcc95		; $569d
	res 4,(hl)		; $56a0

	rst_jumpTable			; $56a2
	.dw _initLinkState
	.dw _overworldSwimmingState1
	.dw _overworldSwimmingState2
	.dw _overworldSwimmingState3
	.dw _linkUpdateDrowning

;;
; Just entered the water
; @addr{56ad}
_overworldSwimmingState1:
	call linkCancelAllItemUsage		; $56ad
	call _linkSetSwimmingSpeed		; $56b0

	; Set counter1 to the number of frames to stay in swimmingState2.
	; This is just a period of time during which Link's speed is locked immediately
	; after entering the water.
	ld l,SpecialObject.var2f		; $56b3
	bit 6,(hl)		; $56b5
	ld l,SpecialObject.counter1		; $56b7
	ld (hl),$0a		; $56b9
	jr z,+			; $56bb
	ld (hl),$02		; $56bd
+
	ld a,(wLinkSwimmingState)		; $56bf
	bit 6,a			; $56c2
	jr nz,@drownWithLessInvincibility		; $56c4

	call _checkSwimmingOverSeawater		; $56c6
	jr z,@drown		; $56c9

	ld a,TREASURE_FLIPPERS		; $56cb
	call checkTreasureObtained		; $56cd
	ld b,LINK_ANIM_MODE_SWIM		; $56d0
	jr c,@splashAndSetAnimation	; $56d2

@drown:
	ld c,$88		; $56d4
	jr +			; $56d6

@drownWithLessInvincibility:
	ld c,$78		; $56d8
+
	ld a,LINK_STATE_RESPAWNING		; $56da
	ld (wLinkForceState),a		; $56dc
	ld a,$04		; $56df
	ld (wLinkStateParameter),a		; $56e1
	ld a,$80		; $56e4
	ld (wcc92),a		; $56e6

	ld h,d			; $56e9
	ld l,SpecialObject.invincibilityCounter		; $56ea
	ld (hl),c		; $56ec
	ld l,SpecialObject.collisionType		; $56ed
	res 7,(hl)		; $56ef

	ld a,SND_DAMAGE_LINK		; $56f1
	call playSound		; $56f3

	ld b,LINK_ANIM_MODE_DROWN		; $56f6

@splashAndSetAnimation:
	ld hl,wLinkSwimmingState		; $56f8
	ld a,(hl)		; $56fb
	and $f0			; $56fc
	or $02			; $56fe
	ld (hl),a		; $5700
	ld a,b			; $5701
	call specialObjectSetAnimation		; $5702
	jp linkCreateSplash		; $5705

;;
; This is called from _linkUpdateSwimming_sidescroll.
; @addr{5708}
_forceDrownLink:
	ld hl,wLinkSwimmingState		; $5708
	set 6,(hl)		; $570b
	jr _overworldSwimmingState1@drownWithLessInvincibility		; $570d

;;
; @param[out]	zflag	Set if swimming over seawater (and you have the mermaid suit)
; @addr{570f}
_checkSwimmingOverSeawater:
	ld a,(w1Link.var2f)		; $570f
	bit 6,a			; $5712
	ret nz			; $5714
	ld a,(wActiveTileType)		; $5715
	sub TILETYPE_SEAWATER			; $5718
	ret			; $571a

;;
; State 2: speed is locked for a few frames after entering the water
; @addr{571b}
_overworldSwimmingState2:
	call itemDecCounter1		; $571b
	jp nz,specialObjectUpdatePosition		; $571e

	ld hl,wLinkSwimmingState		; $5721
	inc (hl)		; $5724

;;
; State 3: the normal state when swimming
; @addr{5725}
_overworldSwimmingState3:
	call _checkSwimmingOverSeawater		; $5725
	jr z,_overworldSwimmingState1@drown		; $5728

	call _linkUpdateDiving		; $572a

	; Set Link's visibility layer to normal
	call objectSetVisiblec1		; $572d

	; Enable Link's collisions
	ld h,d			; $5730
	ld l,SpecialObject.collisionType		; $5731
	set 7,(hl)		; $5733

	; Check if Link is diving
	ld a,(wLinkSwimmingState)		; $5735
	rlca			; $5738
	jr nc,+			; $5739

	; If he's diving, disable Link's collisions
	res 7,(hl)		; $573b
	; Draw him behind other sprites
	call objectSetVisiblec3		; $573d
+
	call updateLinkDirectionFromAngle		; $5740

	; Check whether the flippers or the mermaid suit are in use
	ld h,d			; $5743
	ld l,SpecialObject.var2f		; $5744
	bit 6,(hl)		; $5746
	jr z,+			; $5748

	; Mermaid suit movement
	call _linkUpdateVelocity@mermaidSuit		; $574a
	jp specialObjectUpdatePosition		; $574d
+
	; Flippers movement
	call _linkUpdateFlippersSpeed		; $5750
	call _func_5933		; $5753
	jp specialObjectUpdatePosition		; $5756


;;
; Deals with Link drowning
; @addr{5759}
_linkUpdateDrowning:
	ld a,$80		; $5759
	ld (wcc92),a		; $575b

	call specialObjectAnimate		; $575e

	ld h,d			; $5761
	xor a			; $5762
	ld l,SpecialObject.collisionType		; $5763
	ld (hl),a		; $5765

	ld l,SpecialObject.animParameter		; $5766
	bit 7,(hl)		; $5768
	ret z			; $576a

	ld (wLinkSwimmingState),a		; $576b

	; Set link's state to LINK_STATE_RESPAWNING; but, set
	; wLinkStateParameter to $02 to trigger only the respawning code, and not
	; anything else.
	ld a,$02		; $576e
	ld (wLinkStateParameter),a		; $5770
	ld a,LINK_STATE_RESPAWNING		; $5773
	jp linkSetState		; $5775

;;
; Sets Link's speed, speedTmp, var12, and var35 variables.
; @addr{5778}
_linkSetSwimmingSpeed:
	ld a,SWIMMERS_RING		; $5778
	call cpActiveRing		; $577a
	ld a,SPEED_e0		; $577d
	jr z,+			; $577f
	ld a,SPEED_80		; $5781
+
	; Set speed, speedTmp to specified value
	ld h,d			; $5783
	ld l,SpecialObject.speed		; $5784
	ldi (hl),a		; $5786
	ldi (hl),a		; $5787

	; [SpecialObject.var12] = $03
	inc l			; $5788
	ld a,$03		; $5789
	ld (hl),a		; $578b

	ld l,SpecialObject.var35		; $578c
	ld (hl),$00		; $578e
	ret			; $5790

;;
; Sets the speedTmp variable in the same way as the above function, but doesn't touch any
; other variables.
; @addr{5791}
_linkSetSwimmingSpeedTmp:
	ld a,SWIMMERS_RING		; $5791
	call cpActiveRing		; $5793
	ld a,SPEED_e0		; $5796
	jr z,+			; $5798
	ld a,SPEED_80		; $579a
+
	ld e,SpecialObject.speedTmp		; $579c
	ld (de),a		; $579e
	ret			; $579f

;;
; @param[out]	a	The angle Link should move in?
; @addr{57a0}
_linkUpdateFlippersSpeed:
	ld e,SpecialObject.var35		; $57a0
	ld a,(de)		; $57a2
	rst_jumpTable			; $57a3
	.dw @flippersState0
	.dw @flippersState1
	.dw @flippersState2

; Swimming with flippers; waiting for Link to press A, if he will at all
@flippersState0:
	ld a,(wGameKeysJustPressed)		; $57aa
	and BTN_A			; $57ad
	jr nz,@pressedA			; $57af

	call _linkSetSwimmingSpeedTmp		; $57b1
	ld a,(wLinkAngle)		; $57b4
	ret			; $57b7

@pressedA:
	; Go to next state
	ld a,$01		; $57b8
	ld (de),a		; $57ba

	ld a,$08		; $57bb
--
	push af			; $57bd
	ld e,SpecialObject.direction		; $57be
	ld a,(de)		; $57c0
	add a			; $57c1
	add a			; $57c2
	add a			; $57c3
	call _func_5933		; $57c4
	pop af			; $57c7
	dec a			; $57c8
	jr nz,--		; $57c9

	ld e,SpecialObject.counter1		; $57cb
	ld a,$0d		; $57cd
	ld (de),a		; $57cf
	ld a,SND_LINK_SWIM		; $57d0
	call playSound		; $57d2


; Accerelating
@flippersState1:
	ldbc $01,$05		; $57d5
	jr ++			; $57d8


; Decelerating
@flippersState2:
	; b: Next state to go to (minus 1)
	; c: Value to add to speedTmp
	ldbc $ff,-5		; $57da
++
	call itemDecCounter1		; $57dd
	jr z,@nextState		; $57e0

	ld a,(hl)		; $57e2
	and $03			; $57e3
	jr z,@accelerate	; $57e5
	jr @returnDirection		; $57e7

@nextState:
	ld l,SpecialObject.var35		; $57e9
	inc b			; $57eb
	ld (hl),b		; $57ec
	jr nz,+			; $57ed

	call _linkSetSwimmingSpeed		; $57ef
	jr @returnDirection		; $57f2
+
	ld l,SpecialObject.counter1		; $57f4
	ld a,$0c		; $57f6
	ld (hl),a		; $57f8

	; Accelerate, or decelerate depending on 'c'.
@accelerate:
	ld l,SpecialObject.speedTmp		; $57f9
	ld a,(hl)		; $57fb
	add c			; $57fc
	bit 7,a			; $57fd
	jr z,+			; $57ff
	xor a			; $5801
+
	ld (hl),a		; $5802

	; Return an angle value based on Link's direction?
@returnDirection:
	ld a,(wLinkAngle)		; $5803
	bit 7,a			; $5806
	ret z			; $5808

	ld e,SpecialObject.direction		; $5809
	ld a,(de)		; $580b
	swap a			; $580c
	rrca			; $580e
	ret			; $580f

;;
; @addr{5810}
_linkUpdateDiving:
	call specialObjectAnimate		; $5810
	ld hl,wLinkSwimmingState		; $5813
	bit 7,(hl)		; $5816
	jr z,@checkInput			; $5818

	ld a,(wDisableScreenTransitions)		; $581a
	or a			; $581d
	jr nz,@checkInput		; $581e

	ld a,(wActiveTilePos)		; $5820
	ld c,a			; $5823
	ld b,>wRoomLayout		; $5824
	ld a,(bc)		; $5826
	cp TILEINDEX_DEEP_WATER			; $5827
	jp z,_checkForUnderwaterTransition@levelDown		; $5829

@checkInput:
	ld a,(wGameKeysJustPressed)		; $582c
	bit BTN_BIT_B,a			; $582f
	jr nz,@pressedB		; $5831

	ld a,ZORA_RING		; $5833
	call cpActiveRing		; $5835
	ret z			; $5838

	ld e,SpecialObject.counter2		; $5839
	ld a,(de)		; $583b
	dec a			; $583c
	ld (de),a		; $583d
	jr z,@surface		; $583e
	ret			; $5840

@pressedB:
	bit 7,(hl)		; $5841
	jr z,@dive		; $5843

@surface:
	res 7,(hl)		; $5845
	ld a,LINK_ANIM_MODE_SWIM		; $5847
	jp specialObjectSetAnimation		; $5849

@dive:
	set 7,(hl)		; $584c

	ld e,SpecialObject.counter2		; $584e
	ld a,$78		; $5850
	ld (de),a		; $5852

	call linkCreateSplash		; $5853
	ld a,LINK_ANIM_MODE_DIVE		; $5856
	jp specialObjectSetAnimation		; $5858

;;
; @addr{585b}
_linkUpdateSwimming_sidescroll:
	ld a,(wLinkSwimmingState)		; $585b
	and $0f			; $585e
	jr z,@swimmingState0	; $5860

	ld hl,wcc95		; $5862
	res 4,(hl)		; $5865

	rst_jumpTable			; $5867
	.dw @swimmingState0
	.dw @swimmingState1
	.dw @swimmingState2
	.dw _linkUpdateDrowning

; Not swimming
@swimmingState0:
	jp _initLinkState		; $5870


; Just entered the water
@swimmingState1:
	call linkCancelAllItemUsage		; $5873

	ld hl,wLinkSwimmingState		; $5876
	inc (hl)		; $5879

	call _linkSetSwimmingSpeed		; $587a
	call objectSetVisiblec1		; $587d

	ld a,TREASURE_FLIPPERS		; $5880
	call checkTreasureObtained		; $5882
	jr nc,@drown			; $5885

	ld hl,w1Link.var2f		; $5887
	bit 6,(hl)		; $588a
	ld a,LINK_ANIM_MODE_SWIM_2D		; $588c
	jr z,++			; $588e

	set 7,(hl)		; $5890
	ld a,LINK_ANIM_MODE_MERMAID		; $5892
	jr ++			; $5894

@drown:
	ld a,$03		; $5896
	ld (wLinkSwimmingState),a		; $5898
	ld a,LINK_ANIM_MODE_DROWN		; $589b
++
	jp specialObjectSetAnimation		; $589d


; Link remains in this state until he exits the water
@swimmingState2:
	xor a			; $58a0
	ld (wLinkInAir),a		; $58a1

	ld h,d			; $58a4
	ld l,SpecialObject.collisionType		; $58a5
	set 7,(hl)		; $58a7
	ld a,(wLinkImmobilized)		; $58a9
	or a			; $58ac
	jr nz,+++		; $58ad

	; Jump if Link isn't moving ([w1LinkAngle] == $ff)
	ld l,SpecialObject.direction		; $58af
	ld a,(wLinkAngle)		; $58b1
	add a			; $58b4
	jr c,+			; $58b5

	; Jump if Link's angle is going directly up or directly down (so, don't modify his
	; current facing direction)
	ld c,a			; $58b7
	and $18			; $58b8
	jr z,+			; $58ba

	; Set Link's facing direction based on his angle
	ld a,c			; $58bc
	swap a			; $58bd
	and $03			; $58bf
	ld (hl),a		; $58c1
+
	; Ensure that he's facing either left or right (not up or down)
	set 0,(hl)		; $58c2

	; Jump if Link does not have the mermaid suit (only flippers)
	ld l,SpecialObject.var2f		; $58c4
	bit 6,(hl)		; $58c6
	jr z,+			; $58c8

	; Mermaid suit movement
	call _linkUpdateVelocity@mermaidSuit		; $58ca
	jr ++			; $58cd
+
	; Flippers movement
	call _linkUpdateFlippersSpeed		; $58cf
	call _func_5933		; $58d2
++
	call specialObjectUpdatePosition		; $58d5
+++
	; When counter2 goes below 0, create a bubble
	ld h,d			; $58d8
	ld l,SpecialObject.counter2		; $58d9
	dec (hl)		; $58db
	bit 7,(hl)		; $58dc
	jr z,+			; $58de

	; Wait between 50-81 frames before creating the next bubble
	call getRandomNumber		; $58e0
	and $1f			; $58e3
	add 50			; $58e5
	ld (hl),a		; $58e7

	ld b,INTERACID_BUBBLE		; $58e8
	call objectCreateInteractionWithSubid00		; $58ea
+
	jp specialObjectAnimate		; $58ed

;;
; Updates speed and angle for things like ice, jumping, underwater? (Things where he
; accelerates and decelerates)
; @addr{58f0}
_linkUpdateVelocity:
	ld a,(wAreaFlags)		; $58f0
	and AREAFLAG_UNDERWATER			; $58f3
	jr z,@label_05_159	; $58f5

@mermaidSuit:
	ld c,$98		; $58f7
	call updateLinkSpeed_withParam		; $58f9
	ld a,(wActiveRing)		; $58fc
	cp SWIMMERS_RING			; $58ff
	jr nz,+			; $5901

	ld e,SpecialObject.speedTmp		; $5903
	ld a,SPEED_160		; $5905
	ld (de),a		; $5907
+
	ld h,d			; $5908
	ld a,(wLinkImmobilized)		; $5909
	or a			; $590c
	jr nz,+			; $590d

	ld a,(wGameKeysJustPressed)		; $590f
	and (BTN_UP | BTN_RIGHT | BTN_DOWN | BTN_LEFT)			; $5912
	jr nz,@directionButtonPressed	; $5914
+
	ld l,SpecialObject.var3e		; $5916
	dec (hl)		; $5918
	bit 7,(hl)		; $5919
	jr z,++			; $591b

	ld a,$ff		; $591d
	ld (hl),a		; $591f
	jr _func_5933			; $5920

@directionButtonPressed:
	ld a,SND_SPLASH		; $5922
	call playSound		; $5924
	ld h,d			; $5927
	ld l,SpecialObject.var3e		; $5928
	ld (hl),$04		; $592a
++
	ld l,SpecialObject.var12		; $592c
	ld (hl),$14		; $592e

@label_05_159:
	ld a,(wLinkAngle)		; $5930

;;
; @param a
; @addr{5933}
_func_5933:
	ld e,a			; $5933
	ld h,d			; $5934
	ld l,SpecialObject.angle		; $5935
	bit 7,(hl)		; $5937
	jr z,+			; $5939

	ld (hl),e		; $593b
	ret			; $593c
+
	bit 7,a			; $593d
	jr nz,@label_05_162	; $593f
	sub (hl)		; $5941
	add $04			; $5942
	and $1f			; $5944
	cp $09			; $5946
	jr c,@label_05_164	; $5948
	sub $10			; $594a
	cp $09			; $594c
	jr c,@label_05_163	; $594e
	ld bc,$0100		; $5950
	bit 7,a			; $5953
	jr nz,@label_05_165	; $5955
	ld b,$ff		; $5957
	jr @label_05_165		; $5959
@label_05_162:
	ld bc,$00fb		; $595b
	ld a,(wLinkInAir)		; $595e
	or a			; $5961
	jr z,@label_05_165	; $5962
	ld c,b			; $5964
	jr @label_05_165		; $5965
@label_05_163:
	ld bc,$01fb		; $5967
	cp $03			; $596a
	jr c,@label_05_165	; $596c
	ld b,$ff		; $596e
	cp $06			; $5970
	jr nc,@label_05_165	; $5972
	ld a,e			; $5974
	xor $10			; $5975
	ld (hl),a		; $5977
	ld b,$00		; $5978
	jr @label_05_165		; $597a
@label_05_164:
	ld bc,$ff05		; $597c
	cp $03			; $597f
	jr c,@label_05_165	; $5981
	ld b,$01		; $5983
	cp $06			; $5985
	jr nc,@label_05_165	; $5987
	ld a,e			; $5989
	ld (hl),a		; $598a
	ld b,$00		; $598b
@label_05_165:
	ld l,SpecialObject.var12		; $598d
	inc (hl)		; $598f
	ldi a,(hl)		; $5990
	cp (hl)			; $5991
	ret c			; $5992

	; Set SpecialObject.speedTmp to $00
	dec l			; $5993
	ld (hl),$00		; $5994

	ld l,SpecialObject.angle		; $5996
	ld a,(hl)		; $5998
	add b			; $5999
	and $1f			; $599a
	ld (hl),a		; $599c
	ld l,SpecialObject.speedTmp		; $599d
	ldd a,(hl)		; $599f
	ld b,a			; $59a0
	ld a,(hl)		; $59a1
	add c			; $59a2
	jr z,++			; $59a3
	bit 7,a			; $59a5
	jr nz,++		; $59a7

	cp b			; $59a9
	jr c,+			; $59aa
	ld a,b			; $59ac
+
	ld (hl),a		; $59ad
	ret			; $59ae
++
	ld l,SpecialObject.speed		; $59af
	xor a			; $59b1
	ldi (hl),a		; $59b2
	inc l			; $59b3
	ld (hl),l		; $59b4
	dec a			; $59b5
	ld l,SpecialObject.angle		; $59b6
	ld (hl),a		; $59b8
	ret			; $59b9

;;
; linkState01 code, only for sidescrolling areas.
; @addr{59ba}
_linkState01_sidescroll:
	call _sidescrollUpdateActiveTile		; $59ba
	ld a,(wActiveTileType)		; $59bd
	bit TILETYPE_SS_BIT_WATER,a			; $59c0
	jr z,@notInWater		; $59c2

	; In water

	ld h,d			; $59c4
	ld l,SpecialObject.var2f		; $59c5
	bit 6,(hl)		; $59c7
	jr z,+			; $59c9
	set 7,(hl)		; $59cb
+
	; If link was in water last frame, don't create a splash
	ld a,(wLinkSwimmingState)		; $59cd
	or a			; $59d0
	jr nz,++		; $59d1

	; Otherwise, he's just entering the water; create a splash
	inc a			; $59d3
	ld (wLinkSwimmingState),a		; $59d4
	call linkCreateSplash		; $59d7
	jr ++			; $59da

@notInWater:
	; Set WLinkSwimmingState to $00, and jump if he wasn't in water last frame
	ld hl,wLinkSwimmingState		; $59dc
	ld a,(hl)		; $59df
	ld (hl),$00		; $59e0
	or a			; $59e2
	jr z,++			; $59e3

	; He was in water last frame.

	; Skip the below code if he surfaced from an underwater ladder tile.
	ld a,(wLastActiveTileType)		; $59e5
	cp (TILETYPE_SS_LADDER | TILETYPE_SS_WATER)	; $59e8
	jr z,++			; $59ea

	; Make him "hop out" of the water.

	ld a,$02		; $59ec
	ld (wLinkInAir),a		; $59ee
	call linkCreateSplash		; $59f1

	ld bc,-$1a0		; $59f4
	call objectSetSpeedZ		; $59f7

	ld a,(wLinkAngle)		; $59fa
	ld l,SpecialObject.angle		; $59fd
	ld (hl),a		; $59ff

++
	call checkUseItems		; $5a00

	ld a,(wLinkPlayingInstrument)		; $5a03
	or a			; $5a06
	ret nz			; $5a07

	call _specialObjectUpdateAdjacentWallsBitset		; $5a08
	call _linkUpdateKnockback		; $5a0b

	ld a,(wLinkSwimmingState)		; $5a0e
	or a			; $5a11
	jp nz,_linkUpdateSwimming_sidescroll		; $5a12

	ld a,(wMagnetGloveState)		; $5a15
	bit 6,a			; $5a18
	jp z,+			; $5a1a

	xor a			; $5a1d
	ld (wLinkInAir),a		; $5a1e
	jp _animateLinkStanding		; $5a21
+
	call _linkUpdateInAir_sidescroll		; $5a24
	ret z			; $5a27

	ld e,SpecialObject.knockbackCounter		; $5a28
	ld a,(de)		; $5a2a
	or a			; $5a2b
	ret nz			; $5a2c

	ld a,(wActiveTileIndex)		; $5a2d
	cp TILEINDEX_SS_SPIKE			; $5a30
	call z,_dealSpikeDamageToLink		; $5a32

	ld a,(wForceIcePhysics)		; $5a35
	or a			; $5a38
	jr z,+			; $5a39

	ld e,SpecialObject.adjacentWallsBitset		; $5a3b
	ld a,(de)		; $5a3d
	and $30			; $5a3e
	jr nz,@onIce		; $5a40
+
	ld a,(wLastActiveTileType)		; $5a42
	cp TILETYPE_SS_ICE			; $5a45
	jr nz,@notOnIce		; $5a47

@onIce:
	ld a,SNOWSHOE_RING		; $5a49
	call cpActiveRing		; $5a4b
	jr z,@notOnIce		; $5a4e

	ld c,$88		; $5a50
	call updateLinkSpeed_withParam		; $5a52

	ld a,$06		; $5a55
	ld (wForceIcePhysics),a		; $5a57

	call _linkUpdateVelocity		; $5a5a

	ld c,$02		; $5a5d
	ld a,(wLinkAngle)		; $5a5f
	rlca			; $5a62
	jr c,++			; $5a63
	jr +			; $5a65

@notOnIce:
	xor a			; $5a67
	ld (wForceIcePhysics),a		; $5a68
	ld c,a			; $5a6b
	ld a,(wLinkAngle)		; $5a6c
	ld e,SpecialObject.angle		; $5a6f
	ld (de),a		; $5a71
	rlca			; $5a72
	jr c,++			; $5a73

	call updateLinkSpeed_standard		; $5a75

	; Parameter for _linkUpdateMovement (update his animation only; don't update his
	; position)
	ld c,$01		; $5a78

	ld a,(wLinkImmobilized)		; $5a7a
	or a			; $5a7d
	jr nz,++		; $5a7e
+
	; Parameter for _linkUpdateMovement (update everything, including his position)
	ld c,$07		; $5a80
++
	; When not in the water or in other tiles with particular effects, adjust Link's
	; angle so that he moves purely horizontally.
	ld hl,wActiveTileType		; $5a82
	ldi a,(hl)		; $5a85
	or (hl)			; $5a86
	and $ff~TILETYPE_SS_ICE			; $5a87
	call z,_linkAdjustAngleInSidescrollingArea		; $5a89

	call _linkUpdateMovement		; $5a8c

	; The following checks are for whether to cap Link's y position so he doesn't go
	; above a certain point.

	ld e,SpecialObject.angle		; $5a8f
	ld a,(de)		; $5a91
	add $04			; $5a92
	and $1f			; $5a94
	cp $09			; $5a96
	jr nc,++	; $5a98

	; Allow him to move up if the tile he's in has any special properties?
	ld hl,wActiveTileType		; $5a9a
	ldi a,(hl)		; $5a9d
	or a			; $5a9e
	jr nz,++	; $5a9f

	; Allow him to move up if the tile he's standing on is NOT the top of a ladder?
	ld a,(hl)		; $5aa1
	cp (TILETYPE_SS_LADDER | TILETYPE_SS_LADDER_TOP)	; $5aa2
	jr nz,++	; $5aa4

	; Check if Link's y position within the tile is lower than 9
	ld e,SpecialObject.yh		; $5aa6
	ld a,(de)		; $5aa8
	and $0f			; $5aa9
	cp $09			; $5aab
	jr nc,++	; $5aad

	; If it's lower than 9, set it back to 9
	ld a,(de)		; $5aaf
	and $f0			; $5ab0
	add $09			; $5ab2
	ld (de),a		; $5ab4

++
	; Don't climb a ladder if Link is touching the ground
	ld e,SpecialObject.adjacentWallsBitset		; $5ab5
	ld a,(de)		; $5ab7
	and $30			; $5ab8
	jr nz,+			; $5aba

	ld a,(wActiveTileType)		; $5abc
	bit TILETYPE_SS_BIT_LADDER,a			; $5abf
	jr z,+			; $5ac1

	; Climbing a ladder
	ld a,$01		; $5ac3
	ld (wLinkClimbingVine),a		; $5ac5
+
	ld a,(wLinkTurningDisabled)		; $5ac8
	or a			; $5acb
	ret nz			; $5acc
	jp updateLinkDirectionFromAngle		; $5acd

;;
; Updates Link's animation and position based on his current speed and angle variables,
; among other things.
; @param c Bit 0: Set if Link's animation should be "walking" instead of "standing".
;          Bit 1: Set if Link's position should be updated based on his speed and angle.
;          Bit 2: Set if the heart ring's regeneration should be applied (if he moves).
; @addr{5ad0}
_linkUpdateMovement:
	ld a,c			; $5ad0

	; Check whether to animate him "standing" or "walking"
	rrca			; $5ad1
	push af			; $5ad2
	jr c,+			; $5ad3
	call _animateLinkStanding		; $5ad5
	jr ++			; $5ad8
+
	call _animateLinkWalking		; $5ada
++
	pop af			; $5add

	; Check whether to update his position
	rrca			; $5ade
	jr nc,++		; $5adf

	push af			; $5ae1
	call specialObjectUpdatePosition		; $5ae2
	jr z,+			; $5ae5

	ld c,a			; $5ae7
	pop af			; $5ae8

	; Check whether to update the heart ring counter
	rrca			; $5ae9
	ret nc			; $5aea

	ld a,c			; $5aeb
	jp _updateHeartRingCounter		; $5aec
+
	pop af			; $5aef
++
	jp linkResetSpeed		; $5af0

;;
; Only for top-down sections. (See also _linkUpdateInAir_sidescroll.)
; @addr{5af3}
_linkUpdateInAir:
	ld a,(wLinkInAir)		; $5af3
	and $0f			; $5af6
	rst_jumpTable			; $5af8
	.dw @notInAir
	.dw @startedJump
	.dw @inAir

@notInAir:
	; Ensure that bit 1 of wLinkInAir is set if Link's z position is < 0.
	ld h,d			; $5aff
	ld l,SpecialObject.zh		; $5b00
	bit 7,(hl)		; $5b02
	ret z			; $5b04

	ld a,$02		; $5b05
	ld (wLinkInAir),a		; $5b07
	jr ++			; $5b0a

@startedJump:
	ld hl,wLinkInAir		; $5b0c
	inc (hl)		; $5b0f
	bit 7,(hl)		; $5b10
	jr nz,+			; $5b12

	ld hl,wIsTileSlippery		; $5b14
	bit 6,(hl)		; $5b17
	jr nz,+			; $5b19

	ld l,<wActiveTileType		; $5b1b
	ld (hl),TILETYPE_NORMAL		; $5b1d
	call updateLinkSpeed_standard		; $5b1f

	ld a,(wLinkAngle)		; $5b22
	ld e,SpecialObject.angle		; $5b25
	ld (de),a		; $5b27
+
	ld a,SND_JUMP		; $5b28
	call playSound		; $5b2a
++
	; Set jumping animation if he's not holding anything or using an item
	ld a,(wLinkGrabState)		; $5b2d
	ld c,a			; $5b30
	ld a,(wLinkTurningDisabled)		; $5b31
	or c			; $5b34
	ld a,LINK_ANIM_MODE_JUMP		; $5b35
	call z,specialObjectSetAnimation		; $5b37

@inAir:
	xor a			; $5b3a
	ld e,SpecialObject.var12		; $5b3b
	ld (de),a		; $5b3d
	inc e			; $5b3e
	ld (de),a		; $5b3f

	; If bit 7 of wLinkInAir is set, allow him to pass through walls (needed for
	; moving through cliff tiles?)
	ld hl,wLinkInAir		; $5b40
	bit 7,(hl)		; $5b43
	jr z,+			; $5b45
	ld e,SpecialObject.adjacentWallsBitset		; $5b47
	ld (de),a		; $5b49
+
	; Set 'c' to the gravity value. Reduce if bit 5 of wLinkInAir is set?
	bit 5,(hl)		; $5b4a
	ld c,$20		; $5b4c
	jr z,+			; $5b4e
	ld c,$0a		; $5b50
+
	call objectUpdateSpeedZ_paramC		; $5b52

	ld l,SpecialObject.speedZ+1		; $5b55
	jr z,@landed			; $5b57

	; Still in the air

	; Return if speedZ is negative
	ld a,(hl)		; $5b59
	bit 7,a			; $5b5a
	ret nz			; $5b5c

	; Return if speedZ < $0300
	cp $03			; $5b5d
	ret c			; $5b5f

	; Cap speedZ to $0300
	ld (hl),$03		; $5b60
	dec l			; $5b62
	ld (hl),$00		; $5b63
	ret			; $5b65

@landed:
	; Set speedZ and wLinkInAir to 0
	xor a			; $5b66
	ldd (hl),a		; $5b67
	ld (hl),a		; $5b68
	ld (wLinkInAir),a		; $5b69

	ld e,SpecialObject.var36		; $5b6c
	ld (de),a		; $5b6e

	call _animateLinkStanding		; $5b6f
	call _specialObjectSetPositionToVar38IfSet		; $5b72
	call _linkApplyTileTypes		; $5b75

	; Check if wActiveTileType is TILETYPE_HOLE or TILETYPE_WARPHOLE
	ld a,(wActiveTileType)		; $5b78
	dec a			; $5b7b
	cp TILETYPE_WARPHOLE			; $5b7c
	jr nc,+			; $5b7e

	; If it's a hole tile, initialize this
	ld a,$04		; $5b80
	ld (wStandingOnTileCounter),a		; $5b82
+
	ld a,SND_LAND		; $5b85
	call playSound		; $5b87
	call _specialObjectUpdateAdjacentWallsBitset		; $5b8a
	jp _initLinkState		; $5b8d

;;
; @param[out]	zflag	If set, _linkState01_sidescroll will return prematurely.
; @addr{5b90}
_linkUpdateInAir_sidescroll:
	ld a,(wLinkInAir)		; $5b90
	and $0f			; $5b93
	rst_jumpTable			; $5b95
	.dw @notInAir
	.dw @jumping
	.dw @inAir

@notInAir:
	ld a,(wLinkRidingObject)		; $5b9c
	or a			; $5b9f
	ret nz			; $5ba0

	; Return if Link is on solid ground
	ld e,SpecialObject.adjacentWallsBitset		; $5ba1
	ld a,(de)		; $5ba3
	and $30			; $5ba4
	ret nz			; $5ba6

	; Return if Link's current tile, or the one he's standing on, is a ladder.
	ld hl,wActiveTileType		; $5ba7
	ldi a,(hl)		; $5baa
	or (hl)			; $5bab
	bit TILETYPE_SS_BIT_LADDER,a			; $5bac
	ret nz			; $5bae

	; Link is in the air.
	ld h,d			; $5baf
	ld l,SpecialObject.speedZ		; $5bb0
	xor a			; $5bb2
	ldi (hl),a		; $5bb3
	ldi (hl),a		; $5bb4
	jr +			; $5bb5

@jumping:
	ld a,SND_JUMP		; $5bb7
	call playSound		; $5bb9
+
	ld a,(wLinkGrabState)		; $5bbc
	ld c,a			; $5bbf
	ld a,(wLinkTurningDisabled)		; $5bc0
	or c			; $5bc3
	ld a,LINK_ANIM_MODE_JUMP		; $5bc4
	call z,specialObjectSetAnimation		; $5bc6

	ld a,$02		; $5bc9
	ld (wLinkInAir),a		; $5bcb
	call updateLinkSpeed_standard		; $5bce

@inAir:
	ld h,d			; $5bd1
	ld l,SpecialObject.speedZ+1		; $5bd2
	bit 7,(hl)		; $5bd4
	jr z,@positiveSpeedZ			; $5bd6

	; If speedZ is negative, check if he hits the ceiling
	ld e,SpecialObject.adjacentWallsBitset		; $5bd8
	ld a,(de)		; $5bda
	and $c0			; $5bdb
	jr nz,@applyGravity	; $5bdd
	jr @applySpeedZ		; $5bdf

@positiveSpeedZ:
	ld a,(wLinkRidingObject)		; $5be1
	or a			; $5be4
	jp nz,@playingInstrument		; $5be5

	; Check if Link is on solid ground
	ld e,SpecialObject.adjacentWallsBitset		; $5be8
	ld a,(de)		; $5bea
	and $30			; $5beb
	jp nz,@landedOnGround		; $5bed

	; Check if Link presses up on a ladder; this will put him back into a ground state
	ld a,(wActiveTileType)		; $5bf0
	bit TILETYPE_SS_BIT_LADDER,a			; $5bf3
	jr z,+			; $5bf5

	ld a,(wGameKeysPressed)		; $5bf7
	and BTN_UP			; $5bfa
	jp nz,@landed		; $5bfc
+
	ld e,SpecialObject.yh		; $5bff
	ld a,(de)		; $5c01
	bit 3,a			; $5c02
	jr z,+			; $5c04

	ld a,(wLastActiveTileType)		; $5c06
	cp (TILETYPE_SS_LADDER | TILETYPE_SS_LADDER_TOP)	; $5c09
	jr z,@landedOnGround	; $5c0b
+
	ld hl,wActiveTileType		; $5c0d
	ldi a,(hl)		; $5c10
	cp TILETYPE_SS_LAVA			; $5c11
	jp z,_forceDrownLink		; $5c13

	; Check if he's ended up in a hole
	cp TILETYPE_SS_HOLE			; $5c16
	jr nz,++		; $5c18

	; Check the tile below link? (In this case, since wLastActiveTileType is the tile
	; 8 pixels below him, this will probably be the same as wActiveTile, UNTIL he
	; reaches the center of the tile. At which time, if the tile beneath has
	; a tileType of $00, Link will respawn.
	ld a,(hl)		; $5c1a
	or a			; $5c1b
	jr nz,++		; $5c1c

	; Damage Link and respawn him.
	ld a,SND_DAMAGE_LINK		; $5c1e
	call playSound		; $5c20
	jp respawnLink		; $5c23

++
	call _linkUpdateVelocity		; $5c26

@applySpeedZ:
	; Apply speedZ to Y position
	ld l,SpecialObject.y		; $5c29
	ld e,SpecialObject.speedZ		; $5c2b
	ld a,(de)		; $5c2d
	add (hl)		; $5c2e
	ldi (hl),a		; $5c2f
	inc e			; $5c30
	ld a,(de)		; $5c31
	adc (hl)		; $5c32
	ldi (hl),a		; $5c33

@applyGravity:
	; Set 'c' to the gravity value (value to add to speedZ).
	ld c,$24		; $5c34
	ld a,(wLinkInAir)		; $5c36
	bit 5,a			; $5c39
	jr z,+			; $5c3b
	ld c,$0e		; $5c3d
+
	ld l,SpecialObject.speedZ		; $5c3f
	ld a,(hl)		; $5c41
	add c			; $5c42
	ldi (hl),a		; $5c43
	ld a,(hl)		; $5c44
	adc $00			; $5c45
	ldd (hl),a		; $5c47

	; Cap Link's speedZ to $0300
	bit 7,a			; $5c48
	jr nz,+			; $5c4a
	cp $03			; $5c4c
	jr c,+			; $5c4e
	xor a			; $5c50
	ldi (hl),a		; $5c51
	ld (hl),$03		; $5c52
+
	call _specialObjectUpdateAdjacentWallsBitset		; $5c54

	; Check (again) whether Link has reached the ground.
	ld e,SpecialObject.adjacentWallsBitset		; $5c57
	ld a,(de)		; $5c59
	and $30			; $5c5a
	jr nz,@landedOnGround	; $5c5c

	; Adjusts Link's angle so he doesn't move (on his own) on the y axis.
	; This is confusing since he has a Z speed, which gets applied to the Y axis. All
	; this does is prevent Link's movement from affecting the Y axis; it still allows
	; his Z speed to be applied.
	; Disabling this would give him some control over the height of his jumps.
	call _linkAdjustAngleInSidescrollingArea		; $5c5e

	call specialObjectUpdatePosition		; $5c61
	call specialObjectAnimate		; $5c64

	; Check if Link's reached the bottom boundary of the room?
	ld e,SpecialObject.yh		; $5c67
	ld a,(de)		; $5c69
	cp $a9			; $5c6a
	jr c,@notLanded	; $5c6c
	jr @landedOnGround		; $5c6e

@notLanded:
	xor a			; $5c70
	ret			; $5c71

@landedOnGround:
	; Lock his y position to the 9th pixel on that tile.
	ld e,SpecialObject.yh		; $5c72
	ld a,(de)		; $5c74
	and $f8			; $5c75
	add $01			; $5c77
	ld (de),a		; $5c79

@landed:
	xor a			; $5c7a
	ld e,SpecialObject.speedZ		; $5c7b
	ld (de),a		; $5c7d
	inc e			; $5c7e
	ld (de),a		; $5c7f

	ld (wLinkInAir),a		; $5c80

	; Check if he landed on a spike
	ld a,(wActiveTileIndex)		; $5c83
	cp TILEINDEX_SS_SPIKE			; $5c86
	call z,_dealSpikeDamageToLink		; $5c88

	ld a,SND_LAND		; $5c8b
	call playSound		; $5c8d
	call _animateLinkStanding		; $5c90
	xor a			; $5c93
	ret			; $5c94

@playingInstrument:
	ld e,SpecialObject.var12		; $5c95
	xor a			; $5c97
	ld (de),a		; $5c98

	; Write $ff to the variable that you just wrote $00 to? OK, game.
	ld a,$ff		; $5c99
	ld (de),a		; $5c9b

	ld e,SpecialObject.angle		; $5c9c
	ld (de),a		; $5c9e
	jr @landed		; $5c9f

;;
; Sets link's state to LINK_STATE_NORMAL, sets var35 to $00
; @addr{5ca1}
_initLinkState:
	ld h,d			; $5ca1
	ld l,<w1Link.state		; $5ca2
	ld (hl),LINK_STATE_NORMAL		; $5ca4
	inc l			; $5ca6
	ld (hl),$00		; $5ca7
	ld l,<w1Link.var35		; $5ca9
	ld (hl),$00		; $5cab
	ret			; $5cad

;;
; @addr{5cae}
_initLinkStateAndAnimateStanding:
	call _initLinkState		; $5cae
	ld l,<w1Link.visible	; $5cb1
	set 7,(hl)		; $5cb3
;;
; @addr{5cb5}
_animateLinkStanding:
	ld e,<w1Link.animMode	; $5cb5
	ld a,(de)		; $5cb7
	cp LINK_ANIM_MODE_WALK	; $5cb8
	jr nz,+			; $5cba

	call checkPegasusSeedCounter		; $5cbc
	jr nz,_animateLinkWalking		; $5cbf
+
	; If not using pegasus seeds, set animMode to 0. At the end of the function, this
	; will be changed back to LINK_ANIM_MODE_WALK; this will simply cause the
	; animation to be reset, resulting in him staying on the animation's first frame.
	xor a			; $5cc1
	ld (de),a		; $5cc2

;;
; @addr{5cc3}
_animateLinkWalking:
	call checkPegasusSeedCounter		; $5cc3
	jr z,++			; $5cc6

	rlca			; $5cc8
	jr nc,++		; $5cc9

	; This has to do with the little puffs appearing at link's feet
	ld hl,w1ReservedItemF		; $5ccb
	ld a,$03		; $5cce
	ldi (hl),a		; $5cd0
	ld (hl),ITEMID_DUST		; $5cd1
	inc l			; $5cd3
	inc (hl)		; $5cd4

	ld a,SND_LAND		; $5cd5
	call playSound		; $5cd7
++
	ld h,d			; $5cda
	ld a,$10	; $5cdb
	ld l,<w1Link.animMode	; $5cdd
	cp (hl)			; $5cdf
	jp nz,specialObjectSetAnimation		; $5ce0
	jp specialObjectAnimate		; $5ce3

;;
; @addr{5ce6}
updateLinkSpeed_standard:
	ld c,$00		; $5ce6

;;
; @param	c	Bit 7 set if speed shouldn't be modified?
; @addr{5ce8}
updateLinkSpeed_withParam:
	ld e,<w1Link.var36		; $5ce8
	ld a,(de)		; $5cea
	cp c			; $5ceb
	jr z,++			; $5cec

	ld a,c			; $5cee
	ld (de),a		; $5cef
	and $7f			; $5cf0
	ld hl,@data		; $5cf2
	rst_addAToHl			; $5cf5

	ld e,<w1Link.speed		; $5cf6
	ldi a,(hl)		; $5cf8
	or a			; $5cf9
	jr z,+			; $5cfa

	ld (de),a		; $5cfc
+
	xor a			; $5cfd
	ld e,<w1Link.var12		; $5cfe
	ld (de),a		; $5d00
	inc e			; $5d01
	ldi a,(hl)		; $5d02
	ld (de),a		; $5d03
++
	; 'b' will be added to the index for the below table, depending on whether Link is
	; slowed down by grass, stairs, etc.
	ld b,$02		; $5d04
	; 'e' will be added to the index in the same way as 'b'. It will be $04 if Link is
	; using pegasus seeds.
	ld e,$00		; $5d06

	; Don't apply pegasus seed modifier when on a hole?
	ld a,(wActiveTileType)		; $5d08
	cp TILETYPE_HOLE	; $5d0b
	jr z,++			; $5d0d
	cp TILETYPE_WARPHOLE	; $5d0f
	jr z,++			; $5d11

	; Grass: b = $02
	cp TILETYPE_GRASS	; $5d13
	jr z,+			; $5d15
	inc b			; $5d17

	; Stairs / vines: b = $03
	cp TILETYPE_STAIRS	; $5d18
	jr z,+			; $5d1a
	cp TILETYPE_VINES	; $5d1c
	jr z,+			; $5d1e

	; Standard movement: b = $04
	inc b			; $5d20
+
	call checkPegasusSeedCounter		; $5d21
	jr z,++			; $5d24

	ld e,$03		; $5d26
++
	ld a,e			; $5d28
	add b			; $5d29
	add c			; $5d2a
	and $7f			; $5d2b
	ld hl,@data		; $5d2d
	rst_addAToHl			; $5d30
	ld a,(hl)		; $5d31
	ld h,d			; $5d32
	ld l,<w1Link.speedTmp		; $5d33
	ldd (hl),a		; $5d35
	bit 7,c			; $5d36
	ret nz			; $5d38
	ld (hl),a		; $5d39
	ret			; $5d3a

@data:
	.db $28 $00 $1e $14 $28 $2d $1e $3c
	.db $00 $06 $28 $28 $28 $3c $3c $3c
	.db $14 $03 $1e $14 $28 $2d $1e $3c
	.db $00 $05 $2d $2d $2d $2d $2d $2d

;;
; Updates Link's speed and updates his position if he's experiencing knockback.
; @addr{5d5b}
_linkUpdateKnockback:
	ld e,SpecialObject.state		; $5d5b
	ld a,(de)		; $5d5d
	cp LINK_STATE_RESPAWNING			; $5d5e
	jr z,@cancelKnockback	; $5d60

	ld a,(wLinkInAir)		; $5d62
	rlca			; $5d65
	jr c,@cancelKnockback	; $5d66

	; Set c to the amount to decrement knockback by.
	; $01 normally, $02 if in the air?
	ld c,$01		; $5d68
	or a			; $5d6a
	jr z,+			; $5d6b
	inc c			; $5d6d
+
	ld h,d			; $5d6e
	ld l,SpecialObject.knockbackCounter		; $5d6f
	ld a,(hl)		; $5d71
	or a			; $5d72
	ret z			; $5d73

	; Decrement knockback
	sub c			; $5d74
	jr c,@cancelKnockback	; $5d75
	ld (hl),a		; $5d77

	; Adjust link's knockback angle if necessary when sidescrolling
	ld l,SpecialObject.knockbackAngle		; $5d78
	call _linkAdjustGivenAngleInSidescrollingArea		; $5d7a

	; Get speed and knockback angle (de = w1Link.knockbackAngle)
	ld a,(de)		; $5d7d
	ld c,a			; $5d7e
	ld b,SPEED_140		; $5d7f

	ld hl,wcc95		; $5d81
	res 5,(hl)		; $5d84

	jp specialObjectUpdatePositionGivenVelocity		; $5d86

@cancelKnockback:
	ld e,SpecialObject.knockbackCounter		; $5d89
	xor a			; $5d8b
	ld (de),a		; $5d8c
	ret			; $5d8d

;;
; Updates a special object's position without allowing it to "slide off" tiles when they
; are approached from the side.
; @addr{5d8e}
specialObjectUpdatePositionWithoutTileEdgeAdjust:
	ld e,SpecialObject.speed		; $5d8e
	ld a,(de)		; $5d90
	ld b,a			; $5d91
	ld e,SpecialObject.angle		; $5d92
	ld a,(de)		; $5d94
	jr +			; $5d95

;;
; @addr{5d97}
specialObjectUpdatePosition:
	ld e,SpecialObject.speed		; $5d97
	ld a,(de)		; $5d99
	ld b,a			; $5d9a
	ld e,SpecialObject.angle	; $5d9b
	ld a,(de)		; $5d9d
	ld c,a			; $5d9e

;;
; Updates position, accounting for solid walls.
;
; @param	b	Speed
; @param	c	Angle
; @param[out]	a	Bits 0, 1 set if his y, x positions changed, respectively.
; @param[out]	c	Same as a.
; @param[out]	zflag	Set if the object did not move at all.
; @addr{5d9f}
specialObjectUpdatePositionGivenVelocity:
	bit 7,c			; $5d9f
	jr nz,++++		; $5da1

	ld e,SpecialObject.adjacentWallsBitset		; $5da3
	ld a,(de)		; $5da5
	ld e,a			; $5da6
	call @tileEdgeAdjust		; $5da7
	jr nz,++		; $5daa
+
	ld c,a			; $5dac
	ld e,$00		; $5dad
++
	; Depending on the angle, change 'e' to hold the bits that should be checked for
	; collision in adjacentWallsBitset. If the angle is facing up, then only the 'up'
	; bits will be set.
	ld a,c			; $5daf
	ld hl,@bitsToCheck		; $5db0
	rst_addAToHl			; $5db3
	ld a,e			; $5db4
	and (hl)		; $5db5
	ld e,a			; $5db6

	; Get 4 bytes at hl determining the offsets Link should move for speed 'b' and
	; angle 'c'.
	call getPositionOffsetForVelocity		; $5db7

	ld c,$00		; $5dba

	; Don't apply vertical speed if there is a wall.
	ld b,e			; $5dbc
	ld a,b			; $5dbd
	and $f0			; $5dbe
	jr nz,++		; $5dc0

	; Don't run the below code if the vertical offset is zero.
	ldi a,(hl)		; $5dc2
	or (hl)			; $5dc3
	jr z,++			; $5dc4

	; Add values at hl to y position
	dec l			; $5dc6
	ld e,SpecialObject.y		; $5dc7
	ld a,(de)		; $5dc9
	add (hl)		; $5dca
	ld (de),a		; $5dcb
	inc e			; $5dcc
	inc l			; $5dcd
	ld a,(de)		; $5dce
	adc (hl)		; $5dcf
	ld (de),a		; $5dd0

	; Set bit 0 of c
	inc c			; $5dd1
++
	; Don't apply horizontal speed if there is a wall.
	ld a,b			; $5dd2
	and $0f			; $5dd3
	jr nz,++		; $5dd5

	; Don't run the below code if the horizontal offset is zero.
	ld l,<(wTmpcec0+3)		; $5dd7
	ldd a,(hl)		; $5dd9
	or (hl)			; $5dda
	jr z,++			; $5ddb

	; Add values at hl to x position
	ld e,SpecialObject.x		; $5ddd
	ld a,(de)		; $5ddf
	add (hl)		; $5de0
	ld (de),a		; $5de1
	inc l			; $5de2
	inc e			; $5de3
	ld a,(de)		; $5de4
	adc (hl)		; $5de5
	ld (de),a		; $5de6

	set 1,c			; $5de7
++
	ld a,c			; $5de9
	or a			; $5dea
	ret			; $5deb
++++
	xor a			; $5dec
	ld c,a			; $5ded
	ret			; $5dee

; Takes an angle as an index.
; Each value tells which bits in adjacentWallsBitset to check for collision for that
; angle. Ie. when moving up, only check collisions above Link, not below.
@bitsToCheck:
	.db $cf $c3 $c3 $c3 $c3 $c3 $c3 $c3
	.db $f3 $33 $33 $33 $33 $33 $33 $33
	.db $3f $3c $3c $3c $3c $3c $3c $3c
	.db $fc $cc $cc $cc $cc $cc $cc $cc

;;
; Converts Link's angle such that he "slides off" a tile when walking towards the edge.
; @param c Angle
; @param e adjacentWallsBitset
; @param[out] a New angle value
; @param[out] zflag Set if a value has been returned in 'a'.
; @addr{5e0f}
@tileEdgeAdjust:
	ld a,c			; $5e0f
	ld hl,slideAngleTable		; $5e10
	rst_addAToHl			; $5e13
	ld a,(hl)		; $5e14
	and $03			; $5e15
	ret nz			; $5e17

	ld a,(hl)		; $5e18
	rlca			; $5e19
	jr c,@bit7		; $5e1a
	rlca			; $5e1c
	jr c,@bit6		; $5e1d
	rlca			; $5e1f
	jr c,@bit5		; $5e20

	ld a,e			; $5e22
	and $cc			; $5e23
	cp $04			; $5e25
	ld a,$00		; $5e27
	ret z			; $5e29

	ld a,e			; $5e2a
	and $3c			; $5e2b
	cp $08			; $5e2d
	ld a,$10		; $5e2f
	ret			; $5e31
@bit5:
	ld a,e			; $5e32
	and $c3			; $5e33
	cp $01			; $5e35
	ld a,$00		; $5e37
	ret z			; $5e39
	ld a,e			; $5e3a
	and $33			; $5e3b
	cp $02			; $5e3d
	ld a,$10		; $5e3f
	ret			; $5e41
@bit7:
	ld a,e			; $5e42
	and $c3			; $5e43
	cp $80			; $5e45
	ld a,$08		; $5e47
	ret z			; $5e49
	ld a,e			; $5e4a
	and $cc			; $5e4b
	cp $40			; $5e4d
	ld a,$18		; $5e4f
	ret			; $5e51
@bit6:
	ld a,e			; $5e52
	and $33			; $5e53
	cp $20			; $5e55
	ld a,$08		; $5e57
	ret z			; $5e59
	ld a,e			; $5e5a
	and $3c			; $5e5b
	cp $10			; $5e5d
	ld a,$18		; $5e5f
	ret			; $5e61

;;
; Updates SpecialObject.adjacentWallsBitset (always for link?) which determines which ways
; he can move.
; @addr{5e62}
_specialObjectUpdateAdjacentWallsBitset:
	ld e,SpecialObject.adjacentWallsBitset		; $5e62
	xor a			; $5e64
	ld (de),a		; $5e65

	; Return if Link is riding a companion, minecart
	ld a,(wLinkObjectIndex)		; $5e66
	rrca			; $5e69
	ret c			; $5e6a

	ld h,d			; $5e6b
	ld l,SpecialObject.yh		; $5e6c
	ld b,(hl)		; $5e6e
	ld l,SpecialObject.xh		; $5e6f
	ld c,(hl)		; $5e71
	call calculateAdjacentWallsBitset		; $5e72
	ld b,a			; $5e75
	ld hl,@data-1		; $5e76
--
	inc hl			; $5e79
	ldi a,(hl)		; $5e7a
	or a			; $5e7b
	jr z,++			; $5e7c
	cp b			; $5e7e
	jr nz,--		; $5e7f

	ld a,(hl)		; $5e81
	ldh (<hFF8B),a	; $5e82
	ld e,SpecialObject.adjacentWallsBitset		; $5e84
	ld (de),a		; $5e86
	ret			; $5e87
++
	ld a,b			; $5e88
	ld e,SpecialObject.adjacentWallsBitset		; $5e89
	ld (de),a		; $5e8b
	ret			; $5e8c

@data:
	.db $db $c3
	.db $ee $cc
	.db $00

;;
; This function only really works with Link.
;
; @param	bc	Position to check
; @param[out]	b	Bit 7 set if the position is surrounded by a wall on all sides?
; @addr{5e92}
checkPositionSurroundedByWalls:
	call calculateAdjacentWallsBitset		; $5e92
--
	ld b,$80		; $5e95
	cp $ff			; $5e97
	ret z			; $5e99

	rra			; $5e9a
	rl b			; $5e9b
	rra			; $5e9d
	rl b			; $5e9e
	jr nz,--		; $5ea0
	ret			; $5ea2

;;
; This function is likely meant for Link only, due to its use of "wLinkRaisedFloorOffset".
;
; @param	bc	YX position.
; @param[out]	a	Bitset of adjacent walls.
; @param[out]	hFF8B	Same as 'a'.
; @addr{5ea3}
calculateAdjacentWallsBitset:
	ld a,$01		; $5ea3
	ldh (<hFF8B),a	; $5ea5

	ld hl,@overworldOffsets		; $5ea7
	ld a,(wAreaFlags)		; $5eaa
	and AREAFLAG_SIDESCROLL			; $5ead
	jr z,@loop			; $5eaf
	ld hl,@sidescrollOffsets		; $5eb1

; Loop 8 times
@loop:
	ldi a,(hl)		; $5eb4
	add b			; $5eb5
	ld b,a			; $5eb6
	ldi a,(hl)		; $5eb7
	add c			; $5eb8
	ld c,a			; $5eb9
	push hl			; $5eba

	ld a,(wLinkRaisedFloorOffset)		; $5ebb
	or a			; $5ebe
	jr z,+			; $5ebf

	call @checkTileCollisionAt_allowRaisedFl		; $5ec1
	jr ++			; $5ec4
+
	call checkTileCollisionAt_allowHoles		; $5ec6
++
	pop hl			; $5ec9
	ldh a,(<hFF8B)	; $5eca
	rla			; $5ecc
	ldh (<hFF8B),a	; $5ecd
	jr nc,@loop		; $5ecf
	ret			; $5ed1

; List of YX offsets from Link's position to check for collision at.
; For each offset where there is a collision, the corresponding bit of 'a' will be set.
@overworldOffsets:
	.db -3, -3
	.db  0,  5
	.db 10, -5
	.db  0,  5
	.db -7, -7
	.db  5,  0
	.db -5,  9
	.db  5,  0

@sidescrollOffsets:
	.db -3, -3
	.db  0,  5
	.db 10, -5
	.db  0,  5
	.db -7, -7
	.db  5,  0
	.db -5,  9
	.db  5,  0

;;
; This may be identical to "checkTileCollisionAt_allowHoles", except that unlike that,
; this does not consider raised floors to have collision?
; @param bc YX position to check for collision
; @param[out] cflag Set on collision
; @addr{5ef2}
@checkTileCollisionAt_allowRaisedFl:
	ld a,b			; $5ef2
	and $f0			; $5ef3
	ld l,a			; $5ef5
	ld a,c			; $5ef6
	swap a			; $5ef7
	and $0f			; $5ef9
	or l			; $5efb
	ld l,a			; $5efc
	ld h,>wRoomCollisions		; $5efd
	ld a,(hl)		; $5eff
	cp $10			; $5f00
	jr c,@simpleCollision		; $5f02

; Complex collision

	and $0f			; $5f04
	ld hl,@specialCollisions		; $5f06
	rst_addAToHl			; $5f09
	ld e,(hl)		; $5f0a
	cp $08			; $5f0b
	ld a,b			; $5f0d
	jr nc,+			; $5f0e
	ld a,c			; $5f10
+
	rrca			; $5f11
	and $07			; $5f12
	ld hl,bitTable		; $5f14
	add l			; $5f17
	ld l,a			; $5f18
	ld a,(hl)		; $5f19
	and e			; $5f1a
	ret z			; $5f1b
	scf			; $5f1c
	ret			; $5f1d

@specialCollisions:
	.db %00000000 %11000011 %00000011 %11000000 %00000000 %11000011 %11000011 %00000000
	.db %00000000 %11000011 %00000011 %11000000 %11000000 %11000001 %00000000 %00000000


@simpleCollision:
	bit 3,b			; $5f2e
	jr nz,+			; $5f30
	rrca			; $5f32
	rrca			; $5f33
+
	bit 3,c			; $5f34
	jr nz,+			; $5f36
	rrca			; $5f38
+
	rrca			; $5f39
	ret			; $5f3a

;;
; Unused?
; @addr{5f3b}
_clearLinkImmobilizedBit4:
	push hl			; $5f3b
	ld hl,wLinkImmobilized		; $5f3c
	res 4,(hl)		; $5f3f
	pop hl			; $5f41
	ret			; $5f42

;;
; @addr{5f43}
_setLinkImmobilizedBit4:
	push hl			; $5f43
	ld hl,wLinkImmobilized		; $5f44
	set 4,(hl)		; $5f47
	pop hl			; $5f49
	ret			; $5f4a

;;
; Adjusts Link's position to suck him into the center of a tile, and sets his state to
; LINK_STATE_FALLING when he reaches the center.
; @addr{5f4b}
_linkPullIntoHole:
	xor a			; $5f4b
	ld e,SpecialObject.knockbackCounter		; $5f4c
	ld (de),a		; $5f4e

	ld h,d			; $5f4f
	ld l,SpecialObject.state		; $5f50
	ld a,(hl)		; $5f52
	cp LINK_STATE_RESPAWNING			; $5f53
	ret z			; $5f55

	; Allow partial control of Link's position for the first 16 frames he's over the
	; hole.
	ld a,(wStandingOnTileCounter)		; $5f56
	cp $10			; $5f59
	call nc,_setLinkImmobilizedBit4		; $5f5b

	; Depending on the frame counter, move horizontally, vertically, or not at all.
	and $03			; $5f5e
	jr z,@moveVertical			; $5f60
	dec a			; $5f62
	jr z,@moveHorizontal			; $5f63
	ret			; $5f65

@moveVertical:
	ld l,SpecialObject.yh		; $5f66
	ld a,(hl)		; $5f68
	add $05			; $5f69
	and $f0			; $5f6b
	add $08			; $5f6d
	sub (hl)		; $5f6f
	jr c,@decPosition			; $5f70
	jr @incPosition			; $5f72

@moveHorizontal:
	ld l,SpecialObject.xh		; $5f74
	ld a,(hl)		; $5f76
	and $f0			; $5f77
	add $08			; $5f79
	sub (hl)		; $5f7b
	jr c,@decPosition			; $5f7c

@incPosition:
	ld a,(hl)		; $5f7e
	inc a			; $5f7f
	jr +			; $5f80

@decPosition:
	ld a,(hl)		; $5f82
	dec a			; $5f83
+
	ld (hl),a		; $5f84

	; Check that Link is within 3 pixels of the vertical center
	ld l,SpecialObject.yh		; $5f85
	ldi a,(hl)		; $5f87
	and $0f			; $5f88
	sub $07			; $5f8a
	cp $03			; $5f8c
	ret nc			; $5f8e

	; Check that Link is within 3 pixels of the horizontal center
	inc l			; $5f8f
	ldi a,(hl)		; $5f90
	and $0f			; $5f91
	sub $07			; $5f93
	cp $03			; $5f95
	ret nc			; $5f97

	; Link has reached the center of the tile, now he'll start falling

	call clearAllParentItems		; $5f98

	ld e,SpecialObject.knockbackCounter		; $5f9b
	xor a			; $5f9d
	ld (de),a		; $5f9e
	ld (wLinkStateParameter),a		; $5f9f

	; Change Link's state to the falling state
	ld e,SpecialObject.id		; $5fa2
	ld a,(de)		; $5fa4
	or a			; $5fa5
	ld a,LINK_STATE_RESPAWNING		; $5fa6
	jp z,linkSetState		; $5fa8

	; If link's ID isn't zero, set his state indirectly...?
	ld (wLinkForceState),a		; $5fab
	ret			; $5fae

;;
; Checks if Link is pushing against the bed in Nayru's house. If so, set Link's state to
; LINK_STATE_SLEEPING.
; The only bed that this works for is the one in Nayru's house.
; @addr{5faf}
checkLinkPushingAgainstBed:
	ld hl,wInformativeTextsShown		; $5faf
	bit 1,(hl)		; $5fb2
	ret nz			; $5fb4

	ld a,(wActiveGroup)		; $5fb5
	cp $03			; $5fb8
	ret nz			; $5fba

	; Check link is in room $9e, position $17, facing right
	ldbc $9e, $17		; $5fbb
	ld l,DIR_RIGHT		; $5fbe
	ld a,(wActiveRoom)		; $5fc0
	cp b			; $5fc3
	ret nz			; $5fc4

	ld a,(wActiveTilePos)		; $5fc5
	cp c			; $5fc8
	ret nz			; $5fc9

	ld e,SpecialObject.direction		; $5fca
	ld a,(de)		; $5fcc
	cp l			; $5fcd
	ret nz			; $5fce

	call checkLinkPushingAgainstWall		; $5fcf
	ret z			; $5fd2

	; Increment counter, wait until it's been 90 frames
	ld hl,wLinkPushingAgainstBedCounter		; $5fd3
	inc (hl)		; $5fd6
	ld a,(hl)		; $5fd7
	cp 90			; $5fd8
	ret c			; $5fda

	pop hl			; $5fdb
	ld hl,wInformativeTextsShown		; $5fdc
	set 1,(hl)		; $5fdf
	ld a,LINK_STATE_SLEEPING		; $5fe1
	jp linkSetState		; $5fe3

_label_05_234:
	xor a			; $5fe6
	ld e,SpecialObject.var37		; $5fe7
	ld (de),a		; $5fe9
	inc e			; $5fea
	ld (de),a		; $5feb
	ret			; $5fec

;;
; @param	a	Value for var37
; @param	l	Value for var38 (a position value)
; @addr{5fed}
_specialObjectSetVar37AndVar38:
	ld e,SpecialObject.var37		; $5fed
	ld (de),a		; $5fef
	inc e			; $5ff0
	ld a,l			; $5ff1
	ld (de),a		; $5ff2

;;
; Sets an object's angle to face the position in var37/var38?
; @addr{5ff3}
_specialObjectSetAngleRelativeToVar38:
	ld e,SpecialObject.var37		; $5ff3
	ld a,(de)		; $5ff5
	or a			; $5ff6
	ret z			; $5ff7

	ld hl,_data_6012-2		; $5ff8
	rst_addDoubleIndex			; $5ffb

	inc e			; $5ffc
	ld a,(de)		; $5ffd
	ld c,a			; $5ffe
	and $f0			; $5fff
	add (hl)		; $6001
	ld b,a			; $6002
	inc hl			; $6003
	ld a,c			; $6004
	and $0f			; $6005
	swap a			; $6007
	add (hl)		; $6009
	ld c,a			; $600a

	call objectGetRelativeAngle		; $600b
	ld e,SpecialObject.angle		; $600e
	ld (de),a		; $6010
	ret			; $6011

; @addr{6012}
_data_6012:
	.db $02 $08
	.db $0c $08

;;
; Warps link somewhere based on var37 and var38?
; @addr{6016}
_specialObjectSetPositionToVar38IfSet:
	ld e,SpecialObject.var37		; $6016
	ld a,(de)		; $6018
	or a			; $6019
	ret z			; $601a

	ld hl,_data_6012-2		; $601b
	rst_addDoubleIndex			; $601e

	; de = SpecialObject.var38
	inc e			; $601f
	ld a,(de)		; $6020
	ld c,a			; $6021
	and $f0			; $6022
	add (hl)		; $6024
	ld e,SpecialObject.yh		; $6025
	ld (de),a		; $6027

	inc hl			; $6028
	ld a,c			; $6029
	and $0f			; $602a
	swap a			; $602c
	add (hl)		; $602e
	ld e,SpecialObject.xh		; $602f
	ld (de),a		; $6031
	jr _label_05_234		; $6032

;;
; Checks if Link touches a cliff tile, and starts the jumping-off-cliff code if so.
; @addr{6034}
_checkLinkJumpingOffCliff:
	; Return if Link is not moving in a cardinal direction?
	ld a,(wLinkAngle)		; $6034
	ld c,a			; $6037
	and $e7			; $6038
	ret nz			; $603a

	ld h,d			; $603b
	ld l,SpecialObject.angle		; $603c
	xor c			; $603e
	cp (hl)			; $603f
	ret nz			; $6040

	; Check that Link is facing towards a solid wall
	add a			; $6041
	swap a			; $6042
	ld c,a			; $6044
	add a			; $6045
	add a			; $6046
	add c			; $6047
	ld hl,@wallDirections		; $6048
	rst_addAToHl			; $604b
	ld e,SpecialObject.adjacentWallsBitset		; $604c
	ld a,(de)		; $604e
	and (hl)		; $604f
	cp (hl)			; $6050
	ret nz			; $6051

	; Check 2 offsets from Link's position to ensure that both of them are cliff
	; tiles.
	call @checkCliffTile		; $6052
	ret nc			; $6055
	call @checkCliffTile		; $6056
	ret nc			; $6059

	; If the above checks passed, start making Link jump off the cliff.

	ld a,$81		; $605a
	ld (wLinkInAir),a		; $605c
	ld bc,-$1c0		; $605f
	call objectSetSpeedZ		; $6062
	ld l,SpecialObject.knockbackCounter		; $6065
	ld (hl),$00		; $6067

	; Return from caller (don't execute any more "linkState01" code)
	pop hl			; $6069

	ld a,LINK_STATE_JUMPING_DOWN_LEDGE		; $606a
	call linkSetState		; $606c
	jr _linkState12		; $606f

;;
; Unused?
; @addr{6071}
@setSpeed140:
	ld l,SpecialObject.speed		; $6071
	ld (hl),SPEED_140		; $6073
	ret			; $6075

;;
; @param[out] cflag
; @addr{6076}
@checkCliffTile:
	inc hl			; $6076
	ldi a,(hl)		; $6077
	ld c,(hl)		; $6078
	ld b,a			; $6079
	push hl			; $607a
	call objectGetRelativeTile		; $607b
	ldh (<hFF8B),a	; $607e
	ld hl,cliffTilesTable		; $6080
	call lookupCollisionTable		; $6083
	pop hl			; $6086
	ret nc			; $6087

	ld c,a			; $6088
	ld e,SpecialObject.angle		; $6089
	ld a,(de)		; $608b
	cp c			; $608c
	scf			; $608d
	ret z			; $608e

	xor a			; $608f
	ret			; $6090

; Data format:
; b0: bits that must be set in w1Link.adjacentWallsBitset for that direction
; b1-b2, b3-b4: Each of these pairs of bytes is a relative offset from Link's position to
; check whether the tile there is a cliff tile. Both resulting positions must be valid.
@wallDirections:
	.db $c0 $fc $fd $fc $02 ; DIR_UP
	.db $03 $00 $04 $05 $04 ; DIR_RIGHT
	.db $30 $08 $fd $08 $02 ; DIR_DOWN
	.db $0c $00 $fb $05 $fb ; DIR_LEFT

;;
; LINK_STATE_JUMPING_DOWN_LEDGE
; @addr{60a5}
_linkState12:
	ld e,SpecialObject.state2		; $60a5
	ld a,(de)		; $60a7
	rst_jumpTable			; $60a8
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate0:
	call itemIncState2		; $60b1

	; Set jumping animation if not underwater
	ld l,SpecialObject.var2f		; $60b4
	bit 7,(hl)		; $60b6
	jr nz,++		; $60b8

	ld a,(wLinkGrabState)		; $60ba
	ld c,a			; $60bd
	ld a,(wLinkTurningDisabled)		; $60be
	or c			; $60c1
	ld a,LINK_ANIM_MODE_JUMP		; $60c2
	call z,specialObjectSetAnimation		; $60c4
++
	ld a,SND_JUMP		; $60c7
	call playSound		; $60c9

	call @getLengthOfCliff		; $60cc
	jr z,@willTransition			; $60cf

	ld hl,@cliffSpeedTable - 1		; $60d1
	rst_addAToHl			; $60d4
	ld a,(hl)		; $60d5
	ld e,SpecialObject.speed		; $60d6
	ld (de),a		; $60d8
	ret			; $60d9

; A screen transition will occur by jumping off this cliff. Only works properly for cliffs
; facing down.
@willTransition:
	ld a,(wScreenTransitionBoundaryY)		; $60da
	ld b,a			; $60dd
	ld h,d			; $60de
	ld l,SpecialObject.yh		; $60df
	ld a,(hl)		; $60e1
	sub b			; $60e2
	ld (hl),b		; $60e3

	ld l,SpecialObject.zh		; $60e4
	ld (hl),a		; $60e6

	; Disable terrain effects (shadow)
	ld l,SpecialObject.visible		; $60e7
	res 6,(hl)		; $60e9

	ld l,SpecialObject.state2		; $60eb
	ld (hl),$02		; $60ed

	xor a			; $60ef
	ld l,SpecialObject.speed		; $60f0
	ld (hl),a		; $60f2
	ld l,SpecialObject.speedZ		; $60f3
	ldi (hl),a		; $60f5
	ld (hl),$ff		; $60f6

	; [wDisableScreenTransitions] = $01
	inc a			; $60f8
	ld (wDisableScreenTransitions),a		; $60f9

	ld l,SpecialObject.var2f		; $60fc
	set 0,(hl)		; $60fe
	ret			; $6100


; The index to this table is the length of a cliff in tiles; the value is the speed
; required to pass through the cliff.
@cliffSpeedTable:
	.db           SPEED_080 SPEED_0a0 SPEED_0e0
	.db SPEED_120 SPEED_160 SPEED_1a0 SPEED_200
	.db SPEED_240 SPEED_280 SPEED_2c0 SPEED_300


; In the process of falling down the cliff (will land in-bounds).
@substate1:
	call objectApplySpeed		; $610c
	ld c,$20		; $610f
	call objectUpdateSpeedZ_paramC		; $6111
	jp nz,specialObjectAnimate		; $6114

; Link has landed on the ground

	; If a screen transition happened, update respawn position
	ld h,d			; $6117
	ld l,SpecialObject.var2f		; $6118
	bit 0,(hl)		; $611a
	res 0,(hl)		; $611c
	call nz,updateLinkLocalRespawnPosition		; $611e

	call specialObjectTryToBreakTile_source05		; $6121

	xor a			; $6124
	ld (wLinkInAir),a		; $6125
	ld (wLinkSwimmingState),a		; $6128

	ld a,SND_LAND		; $612b
	call playSound		; $612d

	call _specialObjectUpdateAdjacentWallsBitset		; $6130
	jp _initLinkStateAndAnimateStanding		; $6133


; In the process of falling down the cliff (a screen transition will occur).
@substate2:
	ld c,$20		; $6136
	call objectUpdateSpeedZ_paramC		; $6138
	jp nz,specialObjectAnimate		; $613b

	; Initiate screen transition
	ld a,$82		; $613e
	ld (wScreenTransitionDirection),a		; $6140
	ld e,SpecialObject.state2		; $6143
	ld a,$03		; $6145
	ld (de),a		; $6147
	ret			; $6148

; In the process of falling down the cliff, after a screen transition happened.
@substate3:
	; Wait for transition to finish
	ld a,(wScrollMode)		; $6149
	cp $01			; $614c
	ret nz			; $614e

	call @getLengthOfCliff		; $614f

	; Set his y position to the position he'll land at, and set his z position to the
	; equivalent height needed to appear to not have moved.
	ld h,d			; $6152
	ld l,SpecialObject.yh		; $6153
	ld a,(hl)		; $6155
	sub b			; $6156
	ld (hl),b		; $6157
	ld l,SpecialObject.zh		; $6158
	ld (hl),a		; $615a

	; Re-enable terrain effects (shadow)
	ld l,SpecialObject.visible		; $615b
	set 6,(hl)		; $615d

	; Go to substate 1 to complete the fall.
	ld l,SpecialObject.state2		; $615f
	ld (hl),$01		; $6161
	ret			; $6163

;;
; Calculates the number of cliff tiles Link will need to pass through.
;
; @param[out]	a	Number of cliff tiles that Link must pass through
; @param[out]	bc	Position of the tile that will be landed on
; @param[out]	zflag	Set if there will be a screen transition before hitting the ground
; @addr{6164}
@getLengthOfCliff:
	; Get Link's position in bc
	ld h,d			; $6164
	ld l,SpecialObject.yh		; $6165
	ldi a,(hl)		; $6167
	add $05			; $6168
	ld b,a			; $616a
	inc l			; $616b
	ld c,(hl)		; $616c

	; Determine direction he's moving in based on angle
	ld l,SpecialObject.angle		; $616d
	ld a,(hl)		; $616f
	add a			; $6170
	swap a			; $6171
	and $03			; $6173
	ld hl,@offsets		; $6175
	rst_addDoubleIndex			; $6178

	ldi a,(hl)
	ldh (<hFF8D),a ; [hFF8D] = y-offset to add to get the next tile's position
	ld a,(hl)
	ldh (<hFF8C),a ; [hFF8C] = x-offset to add to get the next tile's position
	ld a,$01
	ldh (<hFF8B),a ; [hFF8B] = how many tiles away the one we're checking is

@nextTile:
	; Get next tile's position
	ldh a,(<hFF8D)	; $6183
	add b			; $6185
	ld b,a			; $6186
	ldh a,(<hFF8C)	; $6187
	add c			; $6189
	ld c,a			; $618a

	call checkTileCollisionAt_allowHoles		; $618b
	jr nc,@noCollision	; $618e

	; If this tile is breakable, we can land here
	ld a, $80 | BREAKABLETILESOURCE_05		; $6190
	call tryToBreakTile		; $6192
	jr c,@landHere	; $6195

	; Even if it's solid and unbreakable, check if it's an exception (raisable floor)
	ldh a,(<hFF92)	; $6197
	ld hl,_landableTileFromCliffExceptions		; $6199
	call findByteInCollisionTable		; $619c
	jr c,@landHere	; $619f

	; Try the next tile
	ldh a,(<hFF8B)	; $61a1
	inc a			; $61a3
	ldh (<hFF8B),a	; $61a4
	jr @nextTile			; $61a6

@noCollision:
	; Check if we've gone out of bounds (tile index $00)
	call getTileAtPosition		; $61a8
	or a			; $61ab
	ret z			; $61ac

@landHere:
	ldh a,(<hFF8B)	; $61ad
	cp $0b			; $61af
	jr c,+			; $61b1
	ld a,$0b		; $61b3
+
	or a			; $61b5
	ret			; $61b6

@offsets:
	.db $f8 $00 ; DIR_UP
	.db $00 $08 ; DIR_RIGHT
	.db $08 $00 ; DIR_DOWN
	.db $00 $f8 ; DIR_LEFT


; This is a list of tiles that can be landed on when jumping down a cliff, despite being
; solid.
_landableTileFromCliffExceptions:
	.dw @collisions0
	.dw @collisions1
	.dw @collisions2
	.dw @collisions3
	.dw @collisions4
	.dw @collisions5

@collisions1:
@collisions2:
@collisions5:
	.db TILEINDEX_RAISABLE_FLOOR_1 TILEINDEX_RAISABLE_FLOOR_2
@collisions0:
@collisions3:
@collisions4:
	.db $00


;;
; @addr{61ce}
specialObjectCode_transformedLink:
	ld e,SpecialObject.state		; $61ce
	ld a,(de)		; $61d0
	rst_jumpTable			; $61d1
	.dw @state0
	.dw @state1

;;
; State 0: initialization (just transformed)
; @addr{61d6}
@state0:
	call dropLinkHeldItem		; $61d6
	call clearAllParentItems		; $61d9
	ld a,(wLinkForceState)		; $61dc
	or a			; $61df
	jr nz,@resetIDToNormal	; $61e0

	call specialObjectSetOamVariables		; $61e2
	xor a			; $61e5
	call specialObjectSetAnimation		; $61e6
	call objectSetVisiblec1		; $61e9
	call itemIncState		; $61ec

	ld l,SpecialObject.collisionType		; $61ef
	ld a, $80 | ITEMCOLLISION_LINK
	ldi (hl),a		; $61f3

	inc l			; $61f4
	ld a,$06		; $61f5
	ldi (hl),a ; [collisionRadiusY] = $06
	ldi (hl),a ; [collisionRadiusX] = $06

	ld l,SpecialObject.id		; $61f9
	ld a,(hl)		; $61fb
	cp SPECIALOBJECTID_LINK_AS_BABY			; $61fc
	ret nz			; $61fe

	ld l,SpecialObject.counter1		; $61ff
	ld (hl),$e0		; $6201
	inc l			; $6203
	ld (hl),$01 ; [counter2] = $01

	ld a,SND_BECOME_BABY		; $6206
	call playSound		; $6208
	jr @createGreenPoof		; $620b

@disableTransformationForBaby:
	ld a,SND_MAGIC_POWDER		; $620d
	call playSound		; $620f

@disableTransformation:
	lda SPECIALOBJECTID_LINK			; $6212
	call setLinkIDOverride		; $6213
	ld a,$01		; $6216
	ld (wDisableRingTransformations),a		; $6218

	ld e,SpecialObject.id		; $621b
	ld a,(de)		; $621d
	cp SPECIALOBJECTID_LINK_AS_BABY			; $621e
	ret nz			; $6220

@createGreenPoof:
	ld b,INTERACID_GREENPOOF		; $6221
	jp objectCreateInteractionWithSubid00		; $6223

@resetIDToNormal:
	; If a specific state is requested, go back to normal Link code and run it.
	lda SPECIALOBJECTID_LINK			; $6226
	call setLinkID		; $6227
	ld a,$01		; $622a
	ld (wDisableRingTransformations),a		; $622c
	jp specialObjectCode_link		; $622f

;;
; State 1: normal movement, etc in transformed state
; @addr{6232}
@state1:
	ld a,(wLinkForceState)		; $6232
	or a			; $6235
	jr nz,@resetIDToNormal	; $6236

	ld a,(wPaletteThread_mode)		; $6238
	or a			; $623b
	ret nz			; $623c

	ld a,(wScrollMode)		; $623d
	and $0e			; $6240
	ret nz			; $6242

	call updateLinkDamageTaken		; $6243
	ld a,(wLinkDeathTrigger)		; $6246
	or a			; $6249
	jr nz,@disableTransformation	; $624a

	call retIfTextIsActive		; $624c

	ld a,(wDisabledObjects)		; $624f
	and $81			; $6252
	ret nz			; $6254

	call decPegasusSeedCounter		; $6255

	ld h,d			; $6258
	ld l,SpecialObject.id		; $6259
	ld a,(hl)		; $625b
	cp SPECIALOBJECTID_LINK_AS_BABY			; $625c
	jr nz,+		; $625e
	ld l,SpecialObject.counter1		; $6260
	call decHlRef16WithCap		; $6262
	jr z,@disableTransformationForBaby	; $6265
	jr ++			; $6267
+
	call _linkApplyTileTypes		; $6269
	ld a,(wLinkSwimmingState)		; $626c
	or a			; $626f
	jr nz,@resetIDToNormal	; $6270

	callab bank6.getTransformedLinkID		; $6272
	ld e,SpecialObject.id		; $627a
	ld a,(de)		; $627c
	cp b			; $627d
	ld a,b			; $627e
	jr nz,@resetIDToNormal	; $627f
++
	call _specialObjectUpdateAdjacentWallsBitset		; $6281
	call _linkUpdateKnockback		; $6284
	call updateLinkSpeed_standard		; $6287

	; Halve speed if he's in baby form
	ld h,d			; $628a
	ld l,SpecialObject.id		; $628b
	ld a,(hl)		; $628d
	cp SPECIALOBJECTID_LINK_AS_BABY			; $628e
	jr nz,+			; $6290
	ld l,SpecialObject.speed		; $6292
	srl (hl)		; $6294
+
	ld l,SpecialObject.knockbackCounter		; $6296
	ld a,(hl)		; $6298
	or a			; $6299
	jr nz,@animateIfPegasusSeedsActive	; $629a

	ld l,SpecialObject.collisionType		; $629c
	set 7,(hl)		; $629e

	; Update gravity
	ld l,SpecialObject.zh		; $62a0
	bit 7,(hl)		; $62a2
	jr z,++			; $62a4
	ld c,$20		; $62a6
	call objectUpdateSpeedZ_paramC		; $62a8
	jr nz,++		; $62ab
	xor a			; $62ad
	ld (wLinkInAir),a		; $62ae
++
	ld a,(wcc95)		; $62b1
	ld b,a			; $62b4
	ld l,SpecialObject.angle		; $62b5
	ld a,(wLinkAngle)		; $62b7
	ld (hl),a		; $62ba

	; Set carry flag if [wLinkAngle] == $ff or Link is in a spinner
	or b			; $62bb
	rlca			; $62bc
	jr c,@animateIfPegasusSeedsActive	; $62bd

	ld l,SpecialObject.id		; $62bf
	ld a,(hl)		; $62c1
	cp SPECIALOBJECTID_LINK_AS_BABY			; $62c2
	jr nz,++		; $62c4
	ld l,SpecialObject.animParameter		; $62c6
	bit 7,(hl)		; $62c8
	res 7,(hl)		; $62ca
	ld a,SND_SPLASH		; $62cc
	call nz,playSound		; $62ce
++
	ld a,(wLinkTurningDisabled)		; $62d1
	or a			; $62d4
	call z,updateLinkDirectionFromAngle		; $62d5
	ld a,(wActiveTileType)		; $62d8
	cp TILETYPE_STUMP			; $62db
	jr z,@animate			; $62dd
	ld a,(wLinkImmobilized)		; $62df
	or a			; $62e2
	jr nz,@animate		; $62e3
	call specialObjectUpdatePosition		; $62e5

@animate:
	; Check whether to create the pegasus seed effect
	call checkPegasusSeedCounter		; $62e8
	jr z,++			; $62eb
	rlca			; $62ed
	jr nc,++		; $62ee
	call getFreeInteractionSlot		; $62f0
	jr nz,++		; $62f3
	ld (hl),INTERACID_FALLDOWNHOLE		; $62f5
	inc l			; $62f7
	inc (hl)		; $62f8
	ld bc,$0500		; $62f9
	call objectCopyPositionWithOffset		; $62fc
++
	ld e,SpecialObject.animMode		; $62ff
	ld a,(de)		; $6301
	or a			; $6302
	jp z,specialObjectAnimate		; $6303
	xor a			; $6306
	jp specialObjectSetAnimation		; $6307

@animateIfPegasusSeedsActive:
	call checkPegasusSeedCounter		; $630a
	jr nz,@animate		; $630d
	xor a			; $630f
	jp specialObjectSetAnimation		; $6310


;;
; @addr{6313}
specialObjectCode_linkRidingAnimal:
	ld e,SpecialObject.state		; $6313
	ld a,(de)		; $6315
	rst_jumpTable			; $6316
	.dw @state0
	.dw @state1

@state0:
	call dropLinkHeldItem		; $631b
	call clearAllParentItems		; $631e
	call specialObjectSetOamVariables		; $6321

	ld h,d			; $6324
	ld l,SpecialObject.state		; $6325
	inc (hl)		; $6327
	ld l,SpecialObject.collisionType		; $6328
	ld a, $80 | ITEMCOLLISION_LINK		; $632a
	ldi (hl),a		; $632c

	inc l			; $632d
	ld a,$06		; $632e
	ldi (hl),a ; [collisionRadiusY] = $06
	ldi (hl),a ; [collisionRadiusX] = $06
	call @readCompanionAnimParameter		; $6332
	jp objectSetVisiblec1		; $6335

	; Unused code? (Revert back to ordinary Link code)
	lda SPECIALOBJECTID_LINK			; $6338
	call setLinkIDOverride		; $6339
	ld b,INTERACID_GREENPOOF		; $633c
	jp objectCreateInteractionWithSubid00		; $633e

@state1:
	ld a,(wPaletteThread_mode)		; $6341
	or a			; $6344
	ret nz			; $6345

	call updateLinkDamageTaken		; $6346

	call retIfTextIsActive		; $6349
	ld a,(wScrollMode)		; $634c
	and $0e			; $634f
	ret nz			; $6351

	ld a,(wDisabledObjects)		; $6352
	rlca			; $6355
	ret c			; $6356
	call _linkUpdateKnockback		; $6357

;;
; Copies companion's animParameter & $3f to var31.
; @addr{635a}
@readCompanionAnimParameter:
	ld hl,w1Companion.animParameter		; $635a
	ld a,(hl)		; $635d
	and $3f			; $635e
	ld e,SpecialObject.var31		; $6360
	ld (de),a		; $6362
	ret			; $6363


;;
; Update a minecart object.
; @addr{6364}
_specialObjectCode_minecart:
	; Jump to code in bank 6 to handle it
	jpab bank6.specialObjectCode_minecart		; $6364




; Maple variables:
;
;  var03:  gets set to 0 (rarer item drops) or 1 (standard item drops) when spawning.
;
;  relatedObj1: pointer to a bomb object (maple can suck one up when on her vacuum).
;  relatedObj2: At first, this is a pointer to data in the rom determining Maple's path?
;               When collecting items, this is a pointer to the item she's collecting.
;
;  damage: maple's vehicle (0=broom, 1=vacuum, 2=ufo)
;  health: the value of the loot that Maple's gotten
;  var2a:  the value of the loot that Link's gotten
;
;  invincibilityCounter: nonzero if maple's dropped a heart piece
;  knockbackAngle: actually stores bitmask for item indices 1-4; a bit is set if the item
;                  has been spawned. These items can't spawn more than once.
;  stunCounter: the index of the item that Maple is picking up
;
;  var3a: When recoiling, this gets copied to speedZ?
;         During item collection, this is the delay for maple turning?
;  var3b: Counter until Maple can update her angle by a unit. (Length determined by var3a)
;  var3c: Counter until Maple's Z speed reverses (when floating up and down)
;  var3d: Angle that she's turning toward
;  var3f: Value from 0-2 which determines how much variation there is in maple's movement
;         path? (The variation in her movement increases as she's encountered more often.)
;
;
;;
; @addr{636c}
_specialObjectCode_maple:
	call _companionRetIfInactiveWithoutStateCheck		; $636c
	ld e,SpecialObject.state		; $636f
	ld a,(de)		; $6371
	rst_jumpTable			; $6372
	.dw _mapleState0
	.dw _mapleState1
	.dw _mapleState2
	.dw _mapleState3
	.dw _mapleState4
	.dw _mapleState5
	.dw _mapleState6
	.dw _mapleState7
	.dw _mapleState8
	.dw _mapleState9
	.dw _mapleStateA
	.dw _mapleStateB
	.dw _mapleStateC

;;
; State 0: Initialization
; @addr{638d}
_mapleState0:
	xor a			; $638d
	ld (wcc85),a		; $638e
	call specialObjectSetOamVariables		; $6391

	; Set 'c' to be the amount of variation in maple's path (higher the more she's
	; been encountered)
	ld c,$02		; $6394
	ld a,(wMapleState)		; $6396
	and $0f			; $6399
	cp $0f			; $639b
	jr z,+			; $639d
	dec c			; $639f
	cp $08			; $63a0
	jr nc,+			; $63a2
	dec c			; $63a4
+
	ld a,c			; $63a5
	ld e,SpecialObject.var3f		; $63a6
	ld (de),a		; $63a8

	; Determine maple's vehicle (written to "damage" variable); broom/vacuum in normal
	; game, or broom/ufo in linked game.
	or a			; $63a9
	jr z,+			; $63aa
	ld a,$01		; $63ac
+
	ld e,SpecialObject.damage		; $63ae
	ld (de),a		; $63b0
	or a			; $63b1
	jr z,++			; $63b2
	call checkIsLinkedGame		; $63b4
	jr z,++			; $63b7
	ld a,$02		; $63b9
	ld (de),a		; $63bb
++
	call itemIncState		; $63bc

	ld l,SpecialObject.yh		; $63bf
	ld a,$10		; $63c1
	ldi (hl),a  ; [yh] = $10
	inc l			; $63c4
	ld (hl),$b8 ; [xh] = $b8

	ld l,SpecialObject.zh		; $63c7
	ld a,$88		; $63c9
	ldi (hl),a		; $63cb

	ld (hl),SPEED_140 ; [speed] = SPEED_140

	ld l,SpecialObject.collisionRadiusY		; $63ce
	ld a,$08		; $63d0
	ldi (hl),a		; $63d2
	ld (hl),a		; $63d3

	ld l,SpecialObject.knockbackCounter		; $63d4
	ld (hl),$03		; $63d6

	; Decide on Maple's drop pattern.
	; If [var03] = 0, it's a rare item pattern (1/8 times).
	; If [var03] = 1, it's a standard pattern  (7/8 times).
	call getRandomNumber		; $63d8
	and $07			; $63db
	jr z,+			; $63dd
	ld a,$01		; $63df
+
	ld e,SpecialObject.var03		; $63e1
	ld (de),a		; $63e3

	ld hl,_mapleShadowPathsTable		; $63e4
	rst_addDoubleIndex			; $63e7
	ldi a,(hl)		; $63e8
	ld h,(hl)		; $63e9
	ld l,a			; $63ea

	ld e,SpecialObject.var3a		; $63eb
	ldi a,(hl)		; $63ed
	ld (de),a		; $63ee
	inc e			; $63ef
	ld (de),a		; $63f0
	ld e,SpecialObject.relatedObj2		; $63f1
	ld a,l			; $63f3
	ld (de),a		; $63f4
	inc e			; $63f5
	ld a,h			; $63f6
	ld (de),a		; $63f7

	ld a,(hl)		; $63f8
	ld e,SpecialObject.angle		; $63f9
	ld (de),a		; $63fb
	call _mapleDecideNextAngle		; $63fc
	call objectSetVisiblec0		; $63ff
	ld a,$19		; $6402
	jp specialObjectSetAnimation		; $6404

;;
; @addr{6407}
_mapleState1:
	call _mapleState4		; $6407
	ret nz			; $640a
	ld a,(wMenuDisabled)		; $640b
	or a			; $640e
	jp nz,_mapleDeleteSelf		; $640f

	ld a,MUS_MAPLE_THEME		; $6412
	ld (wActiveMusic),a		; $6414
	jp playSound		; $6417

;;
; State 4: lying on ground after being hit
; @addr{641a}
_mapleState4:
	ld hl,w1Companion.knockbackCounter		; $641a
	dec (hl)		; $641d
	ret nz			; $641e
	call itemIncState		; $641f
	xor a			; $6422
	ret			; $6423

;;
; State 2: flying around (above screen or otherwise) before being hit
; @addr{6424}
_mapleState2:
	ld a,(wTextIsActive)		; $6424
	or a			; $6427
	jr nz,@animate		; $6428
	ld hl,w1Companion.counter2		; $642a
	ld a,(hl)		; $642d
	or a			; $642e
	jr z,+			; $642f
	dec (hl)		; $6431
	ret			; $6432
+
	ld l,SpecialObject.var3d		; $6433
	ld a,(hl)		; $6435
	ld l,SpecialObject.angle		; $6436
	cp (hl)			; $6438
	jr z,+			; $6439
	call _mapleUpdateAngle		; $643b
	jr ++			; $643e
+
	ld l,SpecialObject.counter1		; $6440
	dec (hl)		; $6442
	call z,_mapleDecideNextAngle		; $6443
	jr z,@label_05_262	; $6446
++
	call objectApplySpeed		; $6448
	ld e,SpecialObject.var3e		; $644b
	ld a,(de)		; $644d
	or a			; $644e
	ret z			; $644f

	call checkLinkVulnerableAndIDZero		; $6450
	jr nc,@animate		; $6453
	call objectCheckCollidedWithLink_ignoreZ		; $6455
	jr c,_mapleCollideWithLink	; $6458
@animate:
	call _mapleUpdateOscillation		; $645a
	jp specialObjectAnimate		; $645d

@label_05_262:
	ld hl,w1Companion.var3e		; $6460
	ld a,(hl)		; $6463
	or a			; $6464
	jp nz,_mapleDeleteSelf		; $6465

	inc (hl)		; $6468
	call _mapleInitZPositionAndSpeed		; $6469

	ld l,SpecialObject.speed		; $646c
	ld (hl),SPEED_200		; $646e
	ld l,SpecialObject.counter2		; $6470
	ld (hl),$3c		; $6472

	ld e,SpecialObject.var3f		; $6474
	ld a,(de)		; $6476

	ld e,$03		; $6477
	or a			; $6479
	jr z,++			; $647a
	set 2,e			; $647c
	cp $01			; $647e
	jr z,++			; $6480
	set 3,e			; $6482
++
	call getRandomNumber		; $6484
	and e			; $6487
	ld hl,_mapleMovementPatternIndices		; $6488
	rst_addAToHl			; $648b
	ld a,(hl)		; $648c
	ld hl,_mapleMovementPatternTable		; $648d
	rst_addDoubleIndex			; $6490

	ld e,SpecialObject.yh		; $6491
	ldi a,(hl)		; $6493
	ld h,(hl)		; $6494
	ld l,a			; $6495

	ldi a,(hl)		; $6496
	ld (de),a		; $6497
	ld e,SpecialObject.xh		; $6498
	ldi a,(hl)		; $649a
	ld (de),a		; $649b

	ldi a,(hl)		; $649c
	ld e,SpecialObject.var3a		; $649d
	ld (de),a		; $649f
	inc e			; $64a0
	ld (de),a		; $64a1

	ld a,(hl)		; $64a2
	ld e,SpecialObject.angle		; $64a3
	ld (de),a		; $64a5

	ld e,SpecialObject.relatedObj2		; $64a6
	ld a,l			; $64a8
	ld (de),a		; $64a9
	inc e			; $64aa
	ld a,h			; $64ab
	ld (de),a		; $64ac

;;
; Updates var3d with the angle Maple should be turning toward next, and counter1 with the
; length of time she should stay in that angle.
;
; @param[out]	zflag	z if we've reached the end of the "angle data".
; @addr{64ad}
_mapleDecideNextAngle:
	ld hl,w1Companion.relatedObj2		; $64ad
	ldi a,(hl)		; $64b0
	ld h,(hl)		; $64b1
	ld l,a			; $64b2

	ld e,SpecialObject.var3d		; $64b3
	ldi a,(hl)		; $64b5
	ld (de),a		; $64b6
	ld c,a			; $64b7
	ld e,SpecialObject.counter1		; $64b8
	ldi a,(hl)		; $64ba
	ld (de),a		; $64bb

	ld e,SpecialObject.relatedObj2		; $64bc
	ld a,l			; $64be
	ld (de),a		; $64bf
	inc e			; $64c0
	ld a,h			; $64c1
	ld (de),a		; $64c2

	ld a,c			; $64c3
	cp $ff			; $64c4
	ret z			; $64c6
	jp _mapleDecideAnimation		; $64c7

;;
; Handles stuff when Maple collides with Link. (Sets knockback for both, sets Maple's
; animation, drops items, and goes to state 3.)
;
; @addr{64ca}
_mapleCollideWithLink:
	call dropLinkHeldItem		; $64ca
	call _mapleSpawnItemDrops		; $64cd

	ld a,$01		; $64d0
	ld (wDisableScreenTransitions),a		; $64d2
	ld (wMenuDisabled),a		; $64d5
	ld a,$3c		; $64d8
	ld (wInstrumentsDisabledCounter),a		; $64da
	ld e,SpecialObject.counter1		; $64dd
	xor a			; $64df
	ld (de),a		; $64e0

	; Set knockback direction and angle for Link and Maple
	call _mapleGetCardinalAngleTowardLink		; $64e1
	ld b,a			; $64e4
	ld hl,w1Link.knockbackCounter		; $64e5
	ld (hl),$18		; $64e8

	ld e,SpecialObject.angle		; $64ea
	ld l,<w1Link.knockbackAngle		; $64ec
	ld (hl),a		; $64ee
	xor $10			; $64ef
	ld (de),a		; $64f1

	; Determine maple's knockback speed
	ld e,SpecialObject.damage		; $64f2
	ld a,(de)		; $64f4
	ld hl,@speeds		; $64f5
	rst_addAToHl			; $64f8
	ld a,(hl)		; $64f9
	ld e,SpecialObject.speed		; $64fa
	ld (de),a		; $64fc

	ld e,SpecialObject.var3a		; $64fd
	ld a,$fc		; $64ff
	ld (de),a		; $6501
	ld a,$0f		; $6502
	ld (wScreenShakeCounterX),a		; $6504

	ld e,SpecialObject.state		; $6507
	ld a,$03		; $6509
	ld (de),a		; $650b

	; Determine animation? ('b' currently holds the angle toward link.)
	ld a,b			; $650c
	add $04			; $650d
	add a			; $650f
	add a			; $6510
	swap a			; $6511
	and $01			; $6513
	xor $01			; $6515
	add $10			; $6517
	ld b,a			; $6519
	ld e,SpecialObject.damage		; $651a
	ld a,(de)		; $651c
	add a			; $651d
	add b			; $651e
	call specialObjectSetAnimation		; $651f

	ld a,SND_SCENT_SEED		; $6522
	jp playSound		; $6524

@speeds:
	.db SPEED_100
	.db SPEED_140
	.db SPEED_180

;;
; State 3: recoiling after being hit
; @addr{652a}
_mapleState3:
	ld a,(w1Link.knockbackCounter)		; $652a
	or a			; $652d
	jr nz,+			; $652e
	ld a,$01		; $6530
	ld (wDisabledObjects),a		; $6532
+
	ld h,d			; $6535
	ld e,SpecialObject.var3a		; $6536
	ld a,(de)		; $6538
	or a			; $6539
	jr z,@animate		; $653a

	ld e,SpecialObject.zh		; $653c
	ld a,(de)		; $653e
	or a			; $653f
	jr nz,@applyKnockback	; $6540

	; Update speedZ
	ld e,SpecialObject.var3a		; $6542
	ld l,SpecialObject.speedZ+1		; $6544
	ld a,(de)		; $6546
	inc a			; $6547
	ld (de),a		; $6548
	ld (hl),a		; $6549

@applyKnockback:
	ld c,$40		; $654a
	call objectUpdateSpeedZ_paramC		; $654c
	call objectApplySpeed		; $654f
	call _mapleKeepInBounds		; $6552
	call objectGetTileCollisions		; $6555
	ret z			; $6558
	jr @counteractWallSpeed		; $6559

@animate:
	ld a,(wDisabledObjects)		; $655b
	or a			; $655e
	ret z			; $655f

	; Wait until the animation gives the signal to go to state 4
	ld e,SpecialObject.animParameter		; $6560
	ld a,(de)		; $6562
	cp $ff			; $6563
	jp nz,specialObjectAnimate		; $6565
	ld e,SpecialObject.knockbackCounter		; $6568
	ld a,$78		; $656a
	ld (de),a		; $656c
	ld e,SpecialObject.state		; $656d
	ld a,$04		; $656f
	ld (de),a		; $6571
	ret			; $6572

; If maple's hitting a wall, counteract the speed being applied.
@counteractWallSpeed:
	ld e,SpecialObject.angle		; $6573
	call convertAngleDeToDirection		; $6575
	ld hl,@offsets		; $6578
	rst_addDoubleIndex			; $657b
	ld e,SpecialObject.yh		; $657c
	ld a,(de)		; $657e
	add (hl)		; $657f
	ld b,a			; $6580
	inc hl			; $6581
	ld e,SpecialObject.xh		; $6582
	ld a,(de)		; $6584
	add (hl)		; $6585
	ld c,a			; $6586

	ld h,d			; $6587
	ld l,SpecialObject.yh		; $6588
	ld (hl),b		; $658a
	ld l,SpecialObject.xh		; $658b
	ld (hl),c		; $658d
	ret			; $658e

@offsets:
	.db $04 $00 ; DIR_UP
	.db $00 $fc ; DIR_RIGHT
	.db $fc $00 ; DIR_DOWN
	.db $00 $04 ; DIR_LEFT

;;
; State 5: floating back up after being hit
; @addr{6597}
_mapleState5:
	ld hl,w1Companion.counter1		; $6597
	ld a,(hl)		; $659a
	or a			; $659b
	jr nz,@floatUp		; $659c

; counter1 has reached 0

	inc (hl)		; $659e
	call _mapleInitZPositionAndSpeed		; $659f
	ld l,SpecialObject.zh		; $65a2
	ld (hl),$ff		; $65a4
	ld a,$01		; $65a6
	ld l,SpecialObject.var3a		; $65a8
	ldi (hl),a		; $65aa
	ld (hl),a  ; [var3b] = $01

	; Reverse direction (to face Link)
	ld e,SpecialObject.angle		; $65ac
	ld a,(de)		; $65ae
	xor $10			; $65af
	ld (de),a		; $65b1
	call _mapleDecideAnimation		; $65b2

@floatUp:
	ld e,SpecialObject.damage		; $65b5
	ld a,(de)		; $65b7
	ld c,a			; $65b8

	; Rise one pixel per frame
	ld e,SpecialObject.zh		; $65b9
	ld a,(de)		; $65bb
	dec a			; $65bc
	ld (de),a		; $65bd
	cp $f9			; $65be
	ret nc			; $65c0

	; If on the ufo or vacuum cleaner, rise 16 pixels higher
	ld a,c			; $65c1
	or a			; $65c2
	jr z,@finishedFloatingUp			; $65c3
	ld a,(de)		; $65c5
	cp $e9			; $65c6
	ret nc			; $65c8

@finishedFloatingUp:
	ld a,(wMapleState)		; $65c9
	bit 4,a			; $65cc
	jr nz,@exchangeTouchingBook	; $65ce

	ld l,SpecialObject.state		; $65d0
	ld (hl),$06		; $65d2

	; Set collision radius variables
	ld e,SpecialObject.damage		; $65d4
	ld a,(de)		; $65d6
	ld hl,@collisionRadii		; $65d7
	rst_addDoubleIndex			; $65da
	ld e,SpecialObject.collisionRadiusY		; $65db
	ldi a,(hl)		; $65dd
	ld (de),a		; $65de
	inc e			; $65df
	ld a,(hl)		; $65e0
	ld (de),a		; $65e1

	; Check if this is the past. She says something about coming through a "weird
	; tunnel", which is probably their justification for her being in the past? She
	; only says this the first time she's encountered in the past.
	ld a,(wActiveGroup)		; $65e2
	dec a			; $65e5
	jr nz,@normalEncounter	; $65e6

	ld a,(wMapleState)		; $65e8
	and $0f			; $65eb
	ld bc,TX_0712		; $65ed
	jr z,++			; $65f0

	ld a,GLOBALFLAG_44		; $65f2
	call checkGlobalFlag		; $65f4
	ld bc,TX_0713		; $65f7
	jr nz,@normalEncounter	; $65fa
++
	ld a,GLOBALFLAG_44		; $65fc
	call setGlobalFlag		; $65fe
	jr @showText		; $6601

@normalEncounter:
	; If this is the first encounter, show TX_0700
	ld a,(wMapleState)		; $6603
	and $0f			; $6606
	ld bc,TX_0700		; $6608
	jr z,@showText		; $660b

	; If we've encountered maple 5 times or more, show TX_0705
	ld c,<TX_0705		; $660d
	cp $05			; $660f
	jr nc,@showText		; $6611

	; Otherwise, pick a random text index from TX_0701-TX_0704
	call getRandomNumber		; $6613
	and $03			; $6616
	ld hl,@normalEncounterText		; $6618
	rst_addAToHl			; $661b
	ld c,(hl)		; $661c
@showText:
	call showText		; $661d
	xor a			; $6620
	ld (wDisabledObjects),a		; $6621
	ld (wMenuDisabled),a		; $6624
	jp _mapleDecideItemToCollectAndUpdateTargetAngle		; $6627

@exchangeTouchingBook:
	ld a,$0b		; $662a
	ld l,SpecialObject.state		; $662c
	ld (hl),a		; $662e

	ld l,SpecialObject.direction		; $662f
	ldi (hl),a  ; [direction] = $0b (?)
	ld (hl),$ff ; [angle] = $ff

	ld l,SpecialObject.speed		; $6634
	ld (hl),SPEED_100		; $6636

	ld bc,TX_070d		; $6638
	jp showText		; $663b


; One of these pieces of text is chosen at random when bumping into maple between the 2nd
; and 4th encounters (inclusive).
@normalEncounterText:
	.db <TX_0701 <TX_0702 <TX_0703 <TX_0704


; Values for collisionRadiusY/X for maple's various forms.
@collisionRadii:
	.db $02 $02 ; broom
	.db $02 $02 ; vacuum cleaner
	.db $04 $04 ; ufo


;;
; Updates maple's Z position and speedZ for oscillation (but not if she's in a ufo?)
; @addr{6648}
_mapleUpdateOscillation:
	ld h,d			; $6648
	ld e,SpecialObject.damage		; $6649
	ld a,(de)		; $664b
	cp $02			; $664c
	ret z			; $664e

	ld c,$00		; $664f
	call objectUpdateSpeedZ_paramC		; $6651

	; Wait a certain number of frames before inverting speedZ
	ld l,SpecialObject.var3c		; $6654
	ld a,(hl)		; $6656
	dec a			; $6657
	ld (hl),a		; $6658
	ret nz			; $6659

	ld a,$16		; $665a
	ld (hl),a		; $665c

	; Invert speedZ
	ld l,SpecialObject.speedZ		; $665d
	ld a,(hl)		; $665f
	cpl			; $6660
	inc a			; $6661
	ldi (hl),a		; $6662
	ld a,(hl)		; $6663
	cpl			; $6664
	ld (hl),a		; $6665
	ret			; $6666

;;
; @addr{6667}
_mapleUpdateAngle:
	ld hl,w1Companion.var3b		; $6667
	dec (hl)		; $666a
	ret nz			; $666b

	ld e,SpecialObject.var3a		; $666c
	ld a,(de)		; $666e
	ld (hl),a		; $666f
	ld l,SpecialObject.angle		; $6670
	ld e,SpecialObject.var3d		; $6672
	ld l,(hl)		; $6674
	ldh (<hFF8B),a	; $6675
	ld a,(de)		; $6677
	call objectNudgeAngleTowards		; $6678

;;
; @param[out]	zflag
; @addr{667b}
_mapleDecideAnimation:
	ld e,SpecialObject.var3e		; $667b
	ld a,(de)		; $667d
	or a			; $667e
	jr z,@ret		; $667f

	ld h,d			; $6681
	ld l,SpecialObject.angle		; $6682
	ld a,(hl)		; $6684
	call convertAngleToDirection		; $6685
	add $04			; $6688
	ld b,a			; $668a
	ld e,SpecialObject.damage		; $668b
	ld a,(de)		; $668d
	add a			; $668e
	add a			; $668f
	add b			; $6690
	ld l,SpecialObject.animMode		; $6691
	cp (hl)			; $6693
	call nz,specialObjectSetAnimation		; $6694
@ret:
	or d			; $6697
	ret			; $6698


;;
; State 6: talking to Link / moving toward an item
; @addr{6699}
_mapleState6:
	call _mapleUpdateOscillation		; $6699
	call specialObjectAnimate		; $669c
	call retIfTextIsActive		; $669f

	ld a,(wActiveMusic)		; $66a2
	cp MUS_MAPLE_GAME			; $66a5
	jr z,++			; $66a7
	ld a,MUS_MAPLE_GAME		; $66a9
	ld (wActiveMusic),a		; $66ab
	call playSound		; $66ae
++
	; Check whether to update Maple's angle toward an item
	ld l,SpecialObject.var3d		; $66b1
	ld a,(hl)		; $66b3
	ld l,SpecialObject.angle		; $66b4
	cp (hl)			; $66b6
	call nz,_mapleUpdateAngle		; $66b7

	call _mapleDecideItemToCollectAndUpdateTargetAngle		; $66ba
	call objectApplySpeed		; $66bd

	; Check if Maple's touching the target object
	ld e,SpecialObject.relatedObj2		; $66c0
	ld a,(de)		; $66c2
	ld h,a			; $66c3
	inc e			; $66c4
	ld a,(de)		; $66c5
	ld l,a			; $66c6
	call checkObjectsCollided		; $66c7
	jp nc,_mapleKeepInBounds		; $66ca

	; Set the item being collected to state 4
	ld e,SpecialObject.relatedObj2		; $66cd
	ld a,(de)		; $66cf
	ld h,a			; $66d0
	inc e			; $66d1
	ld a,(de)		; $66d2
	or Object.state			; $66d3
	ld l,a			; $66d5
	ld (hl),$04 ; [Part.state] = $04
	inc l			; $66d8
	ld (hl),$00 ; [Part.state2] = $00

	; Read the item's var03 to determine how long it takes to collect.
	ld a,(de)		; $66db
	or Object.var03			; $66dc
	ld l,a			; $66de
	ld a,(hl)		; $66df
	ld e,SpecialObject.stunCounter		; $66e0
	ld (de),a		; $66e2

	; Go to state 7
	ld e,SpecialObject.state		; $66e3
	ld a,$07		; $66e5
	ld (de),a		; $66e7

	; If maple's on her broom, she'll only do her sweeping animation if she's not in
	; a wall - otherwise, she'll just sort of sit there?
	ld e,SpecialObject.damage		; $66e8
	ld a,(de)		; $66ea
	or a			; $66eb
	call z,_mapleFunc_6c27		; $66ec
	ret z			; $66ef

	add $16			; $66f0
	jp specialObjectSetAnimation		; $66f2


;;
; State 7: picking up an item
; @addr{66f5}
_mapleState7:
	call specialObjectAnimate		; $66f5

	ld e,SpecialObject.damage		; $66f8
	ld a,(de)		; $66fa
	cp $01			; $66fb
	jp nz,@anyVehicle		; $66fd

; Maple is on the vacuum.
;
; The next bit of code deals with pulling a bomb object (an actual explosive one) toward
; maple. When it touches her, she will be momentarily stunned.

	; Adjust collisionRadiusY/X for the purpose of checking if a bomb object is close
	; enough to be sucked toward the vacuum.
	ld e,SpecialObject.collisionRadiusY		; $6700
	ld a,$08		; $6702
	ld (de),a		; $6704
	inc e			; $6705
	ld a,$0a		; $6706
	ld (de),a		; $6708

	; Check if there's an actual bomb (one that can explode) on-screen.
	call _mapleFindUnexplodedBomb		; $6709
	jr nz,+			; $670c
	call checkObjectsCollided		; $670e
	jr c,@explosiveBombNearMaple	; $6711
+
	call _mapleFindNextUnexplodedBomb		; $6713
	jr nz,@updateItemBeingCollected	; $6716
	call checkObjectsCollided		; $6718
	jr c,@explosiveBombNearMaple	; $671b

	ld e,SpecialObject.relatedObj1		; $671d
	xor a			; $671f
	ld (de),a		; $6720
	inc e			; $6721
	ld (de),a		; $6722
	jr @updateItemBeingCollected		; $6723

@explosiveBombNearMaple:
	; Constantly signal the bomb to reset its animation so it doesn't explode
	ld l,SpecialObject.var2f		; $6725
	set 7,(hl)		; $6727

	; Update the bomb's X and Y positions toward maple, and check if they've reached
	; her.
	ld b,$00		; $6729
	ld l,Item.yh		; $672b
	ld e,l			; $672d
	ld a,(de)		; $672e
	cp (hl)			; $672f
	jr z,@updateBombX	; $6730
	inc b			; $6732
	jr c,+			; $6733
	inc (hl)		; $6735
	jr @updateBombX		; $6736
+
	dec (hl)		; $6738

@updateBombX:
	ld l,Item.xh		; $6739
	ld e,l			; $673b
	ld a,(de)		; $673c
	cp (hl)			; $673d
	jr z,++			; $673e
	inc b			; $6740
	jr c,+			; $6741
	inc (hl)		; $6743
	jr ++			; $6744
+
	dec (hl)		; $6746
++
	ld a,b			; $6747
	or a			; $6748
	jr nz,@updateItemBeingCollected	; $6749

; The bomb has reached maple's Y/X position. Start pulling it up.

	; [Item.z] -= $0040
	ld l,Item.z		; $674b
	ld a,(hl)		; $674d
	sub $40			; $674e
	ldi (hl),a		; $6750
	ld a,(hl)		; $6751
	sbc $00			; $6752
	ld (hl),a		; $6754

	cp $f8			; $6755
	jr nz,@updateItemBeingCollected	; $6757

; The bomb has risen high enough. Maple will now be stunned.

	; Signal the bomb to delete itself
	ld l,SpecialObject.var2f		; $6759
	set 5,(hl)		; $675b

	ld a,$1a		; $675d
	call specialObjectSetAnimation		; $675f

	; Go to state 8
	ld h,d			; $6762
	ld l,SpecialObject.state		; $6763
	ld (hl),$08		; $6765
	inc l			; $6767
	ld (hl),$00 ; [state2] = 0

	ld l,SpecialObject.counter2		; $676a
	ld (hl),$20		; $676c

	ld e,SpecialObject.relatedObj2		; $676e
	ld a,(de)		; $6770
	ld h,a			; $6771
	inc e			; $6772
	ld a,(de)		; $6773
	ld l,a			; $6774
	ld a,(hl)		; $6775
	or a			; $6776
	jr z,@updateItemBeingCollected	; $6777

	; Release the other item Maple was pulling up
	ld a,(de)		; $6779
	add Object.state			; $677a
	ld l,a			; $677c
	ld (hl),$01		; $677d

	add Object.angle-Object.state			; $677f
	ld l,a			; $6781
	ld (hl),$80		; $6782

	xor a			; $6784
	ld e,SpecialObject.relatedObj2		; $6785
	ld (de),a		; $6787

; Done with bomb-pulling code. Below is standard vacuum cleaner code.

@updateItemBeingCollected:
	; Fix collision radius after the above code changed it for bomb detection
	ld e,SpecialObject.collisionRadiusY		; $6788
	ld a,$02		; $678a
	ld (de),a		; $678c
	inc e			; $678d
	ld a,$02		; $678e
	ld (de),a		; $6790

; Vacuum-exclusive code is done.

@anyVehicle:
	ld e,SpecialObject.relatedObj2		; $6791
	ld a,(de)		; $6793
	or a			; $6794
	ret z			; $6795
	ld h,a			; $6796
	inc e			; $6797
	ld a,(de)		; $6798
	ld l,a			; $6799

	ldi a,(hl)		; $679a
	or a			; $679b
	jr z,@itemCollected	; $679c

	; Check bit 7 of item's subid?
	inc l			; $679e
	bit 7,(hl)		; $679f
	jr nz,@itemCollected	; $67a1

	; Check if they've collided (the part object writes to maple's "damageToApply"?)
	ld e,SpecialObject.damageToApply		; $67a3
	ld a,(de)		; $67a5
	or a			; $67a6
	ret z			; $67a7

	ld e,SpecialObject.relatedObj2		; $67a8
	ld a,(de)		; $67aa
	ld h,a			; $67ab
	ld l,Part.var03		; $67ac
	ld a,$80		; $67ae
	ld (hl),a		; $67b0

	xor a			; $67b1
	ld l,Part.invincibilityCounter		; $67b2
	ld (hl),a		; $67b4
	ld l,Part.collisionType		; $67b5
	ld (hl),a		; $67b7

	ld e,SpecialObject.stunCounter		; $67b8
	ld a,(de)		; $67ba
	ld hl,_mapleItemValues		; $67bb
	rst_addAToHl			; $67be
	ld a,$0e		; $67bf
	ld (de),a		; $67c1

	ld e,SpecialObject.health		; $67c2
	ld a,(de)		; $67c4
	ld b,a			; $67c5
	ld a,(hl)		; $67c6
	add b			; $67c7
	ld (de),a		; $67c8

	; If maple's on a broom, go to state $0a (dusting animation); otherwise go back to
	; state $06 (start heading toward the next item)
	ld e,SpecialObject.damage		; $67c9
	ld a,(de)		; $67cb
	or a			; $67cc
	jr nz,@itemCollected	; $67cd

	ld a,$0a		; $67cf
	jr @setState		; $67d1

@itemCollected:
	; Return if Maple's still pulling up a real bomb
	ld h,d			; $67d3
	ld l,SpecialObject.relatedObj1		; $67d4
	ldi a,(hl)		; $67d6
	or (hl)			; $67d7
	ret nz			; $67d8

	ld a,$06		; $67d9
@setState:
	ld e,SpecialObject.state		; $67db
	ld (de),a		; $67dd

	; Update direction with target direction. (I don't think this has been updated? So
	; she'll still be moving in the direction she was headed to reach this item.)
	ld e,SpecialObject.var3d		; $67de
	ld a,(de)		; $67e0
	ld e,SpecialObject.angle		; $67e1
	ld (de),a		; $67e3
	ret			; $67e4

;;
; State A: Maple doing her dusting animation after getting an item (broom only)
; @addr{67e5}
_mapleStateA:
	call specialObjectAnimate		; $67e5
	call itemDecCounter2		; $67e8
	ret nz			; $67eb

	ld l,SpecialObject.state		; $67ec
	ld (hl),$06		; $67ee

	; [zh] = [direction]. ???
	ld l,SpecialObject.direction		; $67f0
	ld a,(hl)		; $67f2
	ld l,SpecialObject.zh		; $67f3
	ld (hl),a		; $67f5

	ld a,$04		; $67f6
	jp specialObjectSetAnimation		; $67f8

;;
; State 8: stunned from a bomb
; @addr{67fb}
_mapleState8:
	call specialObjectAnimate		; $67fb
	ld e,SpecialObject.state2		; $67fe
	ld a,(de)		; $6800
	rst_jumpTable			; $6801
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate0:
	call itemDecCounter2		; $680a
	ret nz			; $680d

	ld l,SpecialObject.state2		; $680e
	ld (hl),$01		; $6810

	ld l,SpecialObject.speedZ		; $6812
	xor a			; $6814
	ldi (hl),a		; $6815
	ld (hl),a		; $6816

	ld a,$13		; $6817
	jp specialObjectSetAnimation		; $6819

@substate1:
	ld c,$40		; $681c
	call objectUpdateSpeedZ_paramC		; $681e
	ret nz			; $6821

	ld l,SpecialObject.state2		; $6822
	ld (hl),$02		; $6824
	ld l,SpecialObject.counter2		; $6826
	ld (hl),$40		; $6828
	ret			; $682a

@substate2:
	call itemDecCounter2		; $682b
	ret nz			; $682e

	ld l,SpecialObject.state2		; $682f
	ld (hl),$03		; $6831
	ld a,$08		; $6833
	jp specialObjectSetAnimation		; $6835

@substate3:
	ld h,d			; $6838
	ld l,SpecialObject.zh		; $6839
	dec (hl)		; $683b
	ld a,(hl)		; $683c
	cp $e9			; $683d
	ret nc			; $683f

	; Go back to state 6 (moving toward next item)
	ld l,SpecialObject.state		; $6840
	ld (hl),$06		; $6842

	ld l,SpecialObject.health		; $6844
	inc (hl)		; $6846

	ld l,SpecialObject.speedZ		; $6847
	ld a,$40		; $6849
	ldi (hl),a		; $684b
	ld (hl),$00		; $684c

	jp _mapleDecideItemToCollectAndUpdateTargetAngle		; $684e

;;
; State 9: flying away after item collection is over
; @addr{6851}
_mapleState9:
	call specialObjectAnimate		; $6851
	ld e,SpecialObject.state2		; $6854
	ld a,(de)		; $6856
	rst_jumpTable			; $6857
	.dw @substate0
	.dw @substate1
	.dw @substate2

; Substate 0: display text
@substate0:
	call retIfTextIsActive		; $685e

	ld a,$3c		; $6861
	ld (wInstrumentsDisabledCounter),a		; $6863

	ld a,$01		; $6866
	ld (de),a ; [state2] = $01

	; "health" is maple's obtained value, and "var2a" is Link's obtained value.

	; Check if either of them got anything
	ld h,d			; $6869
	ld l,SpecialObject.health		; $686a
	ldi a,(hl)		; $686c
	ld b,a			; $686d
	or (hl) ; hl = SpecialObject.var2a
	jr z,@showText		; $686f

	; Check for draw, or maple got more, or link got more
	ld a,(hl)		; $6871
	cp b			; $6872
	ld a,$01		; $6873
	jr z,@showText		; $6875
	inc a			; $6877
	jr c,@showText		; $6878
	inc a			; $687a

@showText:
	ld hl,@textIndices		; $687b
	rst_addDoubleIndex			; $687e
	ld c,(hl)		; $687f
	inc hl			; $6880
	ld b,(hl)		; $6881
	call showText		; $6882

	call _mapleGetCardinalAngleTowardLink		; $6885
	call convertAngleToDirection		; $6888
	add $04			; $688b
	ld b,a			; $688d
	ld e,SpecialObject.damage		; $688e
	ld a,(de)		; $6890
	add a			; $6891
	add a			; $6892
	add b			; $6893
	jp specialObjectSetAnimation		; $6894

@textIndices:
	.dw TX_070c ; 0: nothing obtained by maple or link
	.dw TX_0708 ; 1: draw
	.dw TX_0706 ; 2: maple got more
	.dw TX_0707 ; 3: link got more


; Substate 1: wait until textbox is closed
@substate1:
	call _mapleUpdateOscillation		; $689f
	call retIfTextIsActive		; $68a2

	ld a,$80		; $68a5
	ld (wTextIsActive),a		; $68a7
	ld a,$1f		; $68aa
	ld (wDisabledObjects),a		; $68ac

	ld l,SpecialObject.angle		; $68af
	ld (hl),$18		; $68b1
	ld l,SpecialObject.speed		; $68b3
	ld (hl),SPEED_300		; $68b5

	ld l,SpecialObject.state2		; $68b7
	ld (hl),$02		; $68b9

	ld e,SpecialObject.damage		; $68bb
	ld a,(de)		; $68bd
	add a			; $68be
	add a			; $68bf
	add $07			; $68c0
	jp specialObjectSetAnimation		; $68c2


; Substate 2: moving until off screen
@substate2:
	call _mapleUpdateOscillation		; $68c5
	call objectApplySpeed		; $68c8
	call objectCheckWithinScreenBoundary		; $68cb
	ret c			; $68ce

;;
; Increments meeting counter, deletes maple, etc.
; @addr{68cf}
_mapleEndEncounter:
	xor a			; $68cf
	ld (wTextIsActive),a		; $68d0
	ld (wDisabledObjects),a		; $68d3
	ld (wMenuDisabled),a		; $68d6
	ld (wDisableScreenTransitions),a		; $68d9
	call _mapleIncrementMeetingCounter		; $68dc

	; Fall through

;;
; @addr{68df}
_mapleDeleteSelf:
	ld a,(wActiveMusic2)		; $68df
	ld (wActiveMusic),a		; $68e2
	call playSound		; $68e5
	pop af			; $68e8
	xor a			; $68e9
	ld (wIsMaplePresent),a		; $68ea
	jp itemDelete		; $68ed


;;
; State B: exchanging touching book
; @addr{68f0}
_mapleStateB:
	inc e			; $68f0
	ld a,(de) ; a = [state2]
	or a			; $68f2
	jr nz,@substate1	; $68f3

@substate0:
	call _mapleUpdateOscillation		; $68f5
	ld e,SpecialObject.direction		; $68f8
	ld a,(de)		; $68fa
	bit 7,a			; $68fb
	jr z,+			; $68fd
	and $03			; $68ff
	jr @determineAnimation		; $6901
+
	call objectGetAngleTowardLink		; $6903
	call convertAngleToDirection		; $6906
	ld h,d			; $6909
	ld l,SpecialObject.direction		; $690a
	cp (hl)			; $690c
	ld (hl),a		; $690d
	jr z,@waitForText	; $690e

@determineAnimation:
	add $04			; $6910
	ld b,a			; $6912
	ld e,SpecialObject.damage		; $6913
	ld a,(de)		; $6915
	add a			; $6916
	add a			; $6917
	add b			; $6918
	call specialObjectSetAnimation		; $6919

@waitForText:
	call retIfTextIsActive		; $691c

	ld hl,wMapleState		; $691f
	set 5,(hl)		; $6922
	ld e,SpecialObject.angle		; $6924
	ld a,(de)		; $6926
	rlca			; $6927
	jp nc,objectApplySpeed		; $6928
	ret			; $692b

@substate1:
	dec a			; $692c
	ld (de),a ; [state2] -= 1
	ret nz			; $692e

	ld bc,TX_0711		; $692f
	call showText		; $6932
	ld e,SpecialObject.angle		; $6935
	ld a,$18		; $6937
	ld (de),a		; $6939

	; Go to state $0c
	call itemIncState		; $693a

	ld l,SpecialObject.speed		; $693d
	ld (hl),SPEED_300		; $693f

	; Fall through

;;
; State C: leaving after reading touching book
; @addr{6941}
_mapleStateC:
	call _mapleUpdateOscillation		; $6941
	call retIfTextIsActive		; $6944

	call objectApplySpeed		; $6947

	ld e,SpecialObject.damage		; $694a
	ld a,(de)		; $694c
	add a			; $694d
	add a			; $694e
	add $07			; $694f
	ld hl,wMapleState		; $6951
	bit 4,(hl)		; $6954
	res 4,(hl)		; $6956
	call nz,specialObjectSetAnimation		; $6958

	call objectCheckWithinScreenBoundary		; $695b
	ret c			; $695e
	jp _mapleEndEncounter		; $695f


;;
; Adjusts Maple's X and Y position to keep them in-bounds.
; @addr{6962}
_mapleKeepInBounds:
	ld e,SpecialObject.yh		; $6962
	ld a,(de)		; $6964
	cp $f0			; $6965
	jr c,+			; $6967
	xor a			; $6969
+
	cp $20			; $696a
	jr nc,++		; $696c
	ld a,$20		; $696e
	ld (de),a		; $6970
	jr @checkX		; $6971
++
	cp SCREEN_HEIGHT*16 - 8			; $6973
	jr c,@checkX	; $6975
	ld a,SCREEN_HEIGHT*16 - 8		; $6977
	ld (de),a		; $6979

@checkX:
	ld e,SpecialObject.xh		; $697a
	ld a,(de)		; $697c
	cp $f0			; $697d
	jr c,+			; $697f
	xor a			; $6981
+
	cp $08			; $6982
	jr nc,++		; $6984
	ld a,$08		; $6986
	ld (de),a		; $6988
	jr @ret			; $6989
++
	cp SCREEN_WIDTH*16 - 8			; $698b
	jr c,@ret		; $698d
	ld a,SCREEN_WIDTH*16 - 8		; $698f
	ld (de),a		; $6991
@ret:
	ret			; $6992


;;
; @addr{6993}
_mapleSpawnItemDrops:
	; Check if Link has the touching book
	ld a,TREASURE_TRADEITEM		; $6993
	call checkTreasureObtained		; $6995
	jr nc,@noTradeItem	; $6998
	cp $08			; $699a
	jr nz,@noTradeItem	; $699c

	ld b,INTERACID_TOUCHING_BOOK		; $699e
	call objectCreateInteractionWithSubid00		; $69a0
	ret nz			; $69a3
	ld hl,wMapleState		; $69a4
	set 4,(hl)		; $69a7
	ret			; $69a9

@noTradeItem:
	; Clear health and var2a (the total value of the items Maple and Link have
	; collected, respectively)
	ld e,SpecialObject.var2a		; $69aa
	xor a			; $69ac
	ld (de),a		; $69ad
	ld e,SpecialObject.health		; $69ae
	ld (de),a		; $69b0

; Spawn 5 items from Maple

	ld e,SpecialObject.counter1		; $69b1
	ld a,$05		; $69b3
	ld (de),a		; $69b5

@nextMapleItem:
	ld e,SpecialObject.var03 ; If var03 is 0, rarer items will be dropped
	ld a,(de)		; $69b8
	ld hl,_maple_itemDropDistributionTable		; $69b9
	rst_addDoubleIndex			; $69bc
	ldi a,(hl)		; $69bd
	ld h,(hl)		; $69be
	ld l,a			; $69bf
	call getRandomIndexFromProbabilityDistribution		; $69c0

	ld a,b			; $69c3
	call @checkSpawnItem		; $69c4
	jr c,+			; $69c7
	jr nz,@nextMapleItem	; $69c9
+
	ld e,SpecialObject.counter1		; $69cb
	ld a,(de)		; $69cd
	dec a			; $69ce
	ld (de),a		; $69cf
	jr nz,@nextMapleItem	; $69d0

; Spawn 5 items from Link

	; hFF8C acts as a "drop attempt" counter. It's possible that Link will run out of
	; things to drop, so it'll stop trying eventually.
	ld a,$20		; $69d2
	ldh (<hFF8C),a	; $69d4

	ld e,SpecialObject.counter1		; $69d6
	ld a,$05		; $69d8
	ld (de),a		; $69da

@nextLinkItem:
	ldh a,(<hFF8C)	; $69db
	dec a			; $69dd
	ldh (<hFF8C),a	; $69de
	jr z,@ret	; $69e0

	ld hl,_maple_linkItemDropDistribution		; $69e2
	call getRandomIndexFromProbabilityDistribution		; $69e5

	call _mapleCheckLinkCanDropItem		; $69e8
	jr z,@nextLinkItem	; $69eb

	ld d,>w1Link		; $69ed
	call _mapleSpawnItemDrop		; $69ef

	ld d,>w1Companion		; $69f2
	ld e,SpecialObject.counter1		; $69f4
	ld a,(de)		; $69f6
	dec a			; $69f7
	ld (de),a		; $69f8
	jr nz,@nextLinkItem	; $69f9
@ret:
	ret			; $69fb

;;
; @param	a	Index of item to drop
; @param[out]	cflag	Set if it's ok to drop this item
; @param[out]	zflag
; @addr{69fc}
@checkSpawnItem:
	; Check that Link has obtained the item (if applicable)
	push af			; $69fc
	ld hl,_mapleItemDropTreasureIndices		; $69fd
	rst_addAToHl			; $6a00
	ld a,(hl)		; $6a01
	call checkTreasureObtained		; $6a02
	pop hl			; $6a05
	jr c,@obtained		; $6a06
	or d			; $6a08
	ret			; $6a09

@obtained:
	ld a,h			; $6a0a
	ldh (<hFF8B),a	; $6a0b

	; Skip the below conditions for all items of index 5 or above (items that can be
	; dropped multiple times)
	cp $05			; $6a0d
	jp nc,_mapleSpawnItemDrop		; $6a0f

	; If this is the heart piece, only drop it if it hasn't been obtained yet
	or a			; $6a12
	jr nz,@notHeartPiece	; $6a13
	ld a,(wMapleState)		; $6a15
	bit 7,a			; $6a18
	ret nz			; $6a1a
	ld e,SpecialObject.invincibilityCounter		; $6a1b
	ld a,(de)		; $6a1d
	or a			; $6a1e
	ret nz			; $6a1f

	inc a			; $6a20
	ld (de),a		; $6a21
	jr @spawnItem		; $6a22

@notHeartPiece:
	dec a			; $6a24
	ld hl,@itemBitmasks		; $6a25
	rst_addAToHl			; $6a28
	ld b,(hl)		; $6a29
	ld e,SpecialObject.knockbackAngle		; $6a2a
	ld a,(de)		; $6a2c
	and b			; $6a2d
	ret nz			; $6a2e
	ld a,(de)		; $6a2f
	or b			; $6a30
	ld (de),a		; $6a31

@spawnItem:
	jr _mapleSpawnItemDrop_variant		; $6a32


; Bitmasks for items 1-5 for remembering if one's spawned already
@itemBitmasks:
	.db $04 $02 $02 $01


; The following are probability distributions for maple's dropped items. The sum of the
; numbers in each distribution should be exactly $100. An item with a higher number has
; a higher chance of dropping.

_maple_itemDropDistributionTable: ; Probabilities that Maple will drop something
	.dw @rareItems
	.dw @standardItems

@rareItems:
	.db $14 $0e $0e $1e $20 $00 $00 $00
	.db $00 $00 $28 $2e $28 $14

@standardItems:
	.db $00 $02 $04 $08 $0a $00 $00 $00
	.db $00 $00 $32 $34 $3c $46


_maple_linkItemDropDistribution: ; Probabilities that Link will drop something
	.db $00 $00 $00 $00 $00 $20 $20 $20
	.db $20 $20 $20 $20 $00 $20


; Each byte is the "value" of an item. The values of the items Link and Maple pick up are
; added up and totalled to see who "won" the encounter.
_mapleItemValues:
	.db $3c $0f $0a $08 $06 $05 $05 $05
	.db $05 $05 $04 $03 $02 $01 $00


; Given an index of an item drop, the corresponding value in the table below is a treasure
; to check if Link's obtained in order to allow Maple to drop it. "TREASURE_PUNCH" is
; always considered obtained, so it's used as a value to mean "always drop this".
;
; Item indices:
;  $00: heart piece
;  $01: gasha seed
;  $02: ring
;  $03: ring (different class?)
;  $04: potion
;  $05: ember seeds
;  $06: scent seeds
;  $07: pegasus seeds
;  $08: gale seeds
;  $09: mystery seeds
;  $0a: bombs
;  $0b: heart
;  $0c: 5 rupees
;  $0d: 1 rupee

_mapleItemDropTreasureIndices:
	.db TREASURE_PUNCH      TREASURE_PUNCH         TREASURE_PUNCH       TREASURE_PUNCH
	.db TREASURE_PUNCH      TREASURE_EMBER_SEEDS   TREASURE_SCENT_SEEDS TREASURE_PEGASUS_SEEDS
	.db TREASURE_GALE_SEEDS TREASURE_MYSTERY_SEEDS TREASURE_BOMBS       TREASURE_PUNCH
	.db TREASURE_PUNCH      TREASURE_PUNCH

;;
; @param	d	Object it comes from (Link or Maple)
; @param	hFF8B	Value for part's subid and var03 (item type?)
; @addr{6a83}
_mapleSpawnItemDrop:
	call getFreePartSlot		; $6a83
	scf			; $6a86
	ret nz			; $6a87
	ld (hl),PARTID_ITEM_FROM_MAPLE		; $6a88
	ld e,SpecialObject.yh		; $6a8a
	call objectCopyPosition_rawAddress		; $6a8c
	ldh a,(<hFF8B)	; $6a8f
	ld l,Part.var03		; $6a91
	ldd (hl),a ; [var03] = [hFF8B]
	ld (hl),a  ; [subid] = [hFF8B]
	xor a			; $6a95
	ret			; $6a96

;;
; @param	d	Object it comes from (Link or Maple)
; @param	hFF8B	Value for part's subid and var03 (item type?)
; @addr{6a97}
_mapleSpawnItemDrop_variant:
	call getFreePartSlot		; $6a97
	scf			; $6a9a
	ret nz			; $6a9b
	ld (hl),PARTID_ITEM_FROM_MAPLE_2		; $6a9c
	ld l,Part.subid		; $6a9e
	ldh a,(<hFF8B)	; $6aa0
	ldi (hl),a		; $6aa2
	ld (hl),a		; $6aa3
	call objectCopyPosition		; $6aa4
	or a			; $6aa7
	ret			; $6aa8

;;
; Decides what Maple's next item target should be.
;
; @param[out]	hl	The part object to go for
; @param[out]	zflag	nz if there are no items left
; @addr{6aa9}
_mapleDecideItemToCollect:

; Search for item IDs 0-4 first

	ld b,$00		; $6aa9

@idLoop1
	ldhl FIRST_PART_INDEX, Part.enabled		; $6aab

@partLoop1:
	ld l,Part.enabled		; $6aae
	ldi a,(hl)		; $6ab0
	or a			; $6ab1
	jr z,@nextPart1			; $6ab2

	ldi a,(hl)		; $6ab4
	cp PARTID_ITEM_FROM_MAPLE_2			; $6ab5
	jr nz,@nextPart1		; $6ab7

	ldd a,(hl)		; $6ab9
	cp b			; $6aba
	jr nz,@nextPart1		; $6abb

	; Found an item to go for
	dec l			; $6abd
	xor a			; $6abe
	ret			; $6abf

@nextPart1:
	inc h			; $6ac0
	ld a,h			; $6ac1
	cp LAST_PART_INDEX+1			; $6ac2
	jr c,@partLoop1		; $6ac4

	inc b			; $6ac6
	ld a,b			; $6ac7
	cp $05			; $6ac8
	jr c,@idLoop1		; $6aca

; Now search for item IDs $05-$0d

	xor a			; $6acc
	ld c,$00		; $6acd
	ld hl,@itemIDs		; $6acf
	rst_addAToHl			; $6ad2
	ld a,(hl)		; $6ad3
	ld b,a			; $6ad4
	xor a			; $6ad5
	ldh (<hFF91),a	; $6ad6

@idLoop2:
	ldhl FIRST_PART_INDEX, Part.enabled		; $6ad8

@partLoop2:
	ld l,Part.enabled		; $6adb
	ldi a,(hl)		; $6add
	or a			; $6ade
	jr z,@nextPart2		; $6adf

	ldi a,(hl)		; $6ae1
	cp PARTID_ITEM_FROM_MAPLE			; $6ae2
	jr nz,@nextPart2		; $6ae4

	ldd a,(hl)		; $6ae6
	cp b			; $6ae7
	jr nz,@nextPart2		; $6ae8

; We've found an item to go for. However, we'll only pick this one if it's closest of its
; type. Start by calculating maple's distance from it.

	ld l,Part.yh		; $6aea
	ld l,(hl)		; $6aec
	ld e,SpecialObject.yh		; $6aed
	ld a,(de)		; $6aef
	sub l			; $6af0
	jr nc,+			; $6af1
	cpl			; $6af3
	inc a			; $6af4
+
	ldh (<hFF8C),a	; $6af5
	ld l,Part.xh		; $6af7
	ld l,(hl)		; $6af9
	ld e,SpecialObject.xh		; $6afa
	ld a,(de)		; $6afc
	sub l			; $6afd
	jr nc,+			; $6afe
	cpl			; $6b00
	inc a			; $6b01
+
	ld l,a			; $6b02
	ldh a,(<hFF8C)	; $6b03
	add l			; $6b05
	ld l,a			; $6b06

; l now contains the distance to the item. Check if it's less than the closest item's
; distance (stored in hFF8D), or if this is the first such item (index stored in hFF91).

	ldh a,(<hFF91)	; $6b07
	or a			; $6b09
	jr z,++			; $6b0a
	ldh a,(<hFF8D)	; $6b0c
	cp l			; $6b0e
	jr c,@nextPart2		; $6b0f
++
	ld a,l			; $6b11
	ldh (<hFF8D),a	; $6b12
	ld a,h			; $6b14
	ldh (<hFF91),a	; $6b15

@nextPart2:
	inc h			; $6b17
	ld a,h			; $6b18
	cp $e0			; $6b19
	jr c,@partLoop2		; $6b1b

	; If we found an item of this type, return.
	ldh a,(<hFF91)	; $6b1d
	or a			; $6b1f
	jr nz,@foundItem	; $6b20

	; Otherwise, try the next item type.
	inc c			; $6b22
	ld a,c			; $6b23
	cp $09			; $6b24
	jr nc,@noItemsLeft	; $6b26

	ld hl,@itemIDs		; $6b28
	rst_addAToHl			; $6b2b
	ld a,(hl)		; $6b2c
	ld b,a			; $6b2d
	jr @idLoop2		; $6b2e

@noItemsLeft:
	; This will unset the zflag, since a=$09 and d=$d1... but they probably meant to
	; write "or d" to produce that effect. (That's what they normally do.)
	and d			; $6b30
	ret			; $6b31

@foundItem:
	ld h,a			; $6b32
	ld l,Part.enabled		; $6b33
	xor a			; $6b35
	ret			; $6b36

@itemIDs:
	.db $05 $06 $07 $08 $09 $0a $0b $0c
	.db $0d


;;
; Searches for a bomb item (an actual bomb that will explode). If one exists, and isn't
; currently exploding, it gets set as Maple's relatedObj1.
;
; @param[out]	zflag	z if the first bomb object found was suitable
; @addr{6b40}
_mapleFindUnexplodedBomb:
	ld e,SpecialObject.relatedObj1		; $6b40
	xor a			; $6b42
	ld (de),a		; $6b43
	inc e			; $6b44
	ld (de),a		; $6b45
	ld c,ITEMID_BOMB		; $6b46
	call findItemWithID		; $6b48
	ret nz			; $6b4b
	jr ++			; $6b4c

;;
; This is similar to above, except it's a "continuation" in case the first bomb that was
; found was unsuitable (in the process of exploding).
;
; @addr{6b4e}
_mapleFindNextUnexplodedBomb:
	ld c,ITEMID_BOMB		; $6b4e
	call findItemWithID_startingAfterH		; $6b50
	ret nz			; $6b53
++
	ld l,Item.var2f		; $6b54
	ld a,(hl)		; $6b56
	bit 7,a			; $6b57
	jr nz,++		; $6b59
	and $60			; $6b5b
	ret nz			; $6b5d
	ld l,$0f		; $6b5e
	bit 7,(hl)		; $6b60
	ret nz			; $6b62
++
	ld e,SpecialObject.relatedObj1		; $6b63
	ld a,h			; $6b65
	ld (de),a		; $6b66
	inc e			; $6b67
	xor a			; $6b68
	ld (de),a		; $6b69
	ret			; $6b6a

;;
; @addr{6b6b}
_mapleInitZPositionAndSpeed:
	ld h,d			; $6b6b
	ld l,SpecialObject.zh		; $6b6c
	ld a,$f8		; $6b6e
	ldi (hl),a		; $6b70

	ld l,SpecialObject.speedZ		; $6b71
	ld (hl),$40		; $6b73
	inc l			; $6b75
	ld (hl),$00		; $6b76

	ld l,SpecialObject.var3c		; $6b78
	ld a,$16		; $6b7a
	ldi (hl),a		; $6b7c
	ret			; $6b7d

;;
; @param[out]	a	Angle toward link (rounded to cardinal direction)
; @addr{6b7e}
_mapleGetCardinalAngleTowardLink:
	call objectGetAngleTowardLink		; $6b7e
	and $18			; $6b81
	ret			; $6b83

;;
; Decides what item Maple should go for, and updates var3d appropriately (the angle she's
; turning toward).
;
; If there are no more items, this sets Maple's state to $09.
;
; @addr{6b84}
_mapleDecideItemToCollectAndUpdateTargetAngle:
	call _mapleDecideItemToCollect		; $6b84
	jr nz,@noMoreItems	; $6b87

	ld e,SpecialObject.relatedObj2		; $6b89
	ld a,h			; $6b8b
	ld (de),a		; $6b8c
	inc e			; $6b8d
	ld a,l			; $6b8e
	ld (de),a		; $6b8f
	ld e,SpecialObject.damageToApply		; $6b90
	xor a			; $6b92
	ld (de),a		; $6b93
	jr _mapleSetTargetDirectionToRelatedObj2		; $6b94

@noMoreItems:
	ld e,SpecialObject.state		; $6b96
	ld a,$09		; $6b98
	ld (de),a		; $6b9a
	inc e			; $6b9b
	xor a			; $6b9c
	ld (de),a ; [state2] = 0
	ret			; $6b9e

;;
; @addr{6b9f}
_mapleSetTargetDirectionToRelatedObj2:
	ld e,SpecialObject.relatedObj2		; $6b9f
	ld a,(de)		; $6ba1
	ld h,a			; $6ba2
	inc e			; $6ba3
	ld a,(de)		; $6ba4
	or Object.yh			; $6ba5
	ld l,a			; $6ba7

	ldi a,(hl)		; $6ba8
	ld b,a			; $6ba9
	inc l			; $6baa
	ld a,(hl)		; $6bab
	ld c,a			; $6bac
	call objectGetRelativeAngle		; $6bad
	ld e,SpecialObject.var3d		; $6bb0
	ld (de),a		; $6bb2
	ret			; $6bb3

;;
; Checks if Link can drop an item in Maple's minigame, and removes the item amount from
; his inventory if he can.
;
; This function is bugged. The programmers mixed up the "treasure indices" with maple's
; item indices. As a result, the incorrect treasures are checked to be obtained; for
; example, pegasus seeds check that Link has obtained the rod of seasons. This means
; pegasus seeds will never drop in Ages. Similarly, gale seeds check the magnet gloves.
;
; @param	b	The item to drop
; @param[out]	hFF8B	The "maple item index" of the item to be dropped
; @param[out]	zflag	nz if Link can drop it
; @addr{6bb4}
_mapleCheckLinkCanDropItem:
	ld a,b			; $6bb4
	sub $05			; $6bb5
	ld b,a			; $6bb7
	rst_jumpTable			; $6bb8
	.dw @seed
	.dw @seed
	.dw @seed
	.dw @seed
	.dw @seed
	.dw @bombs
	.dw @heart
	.dw @heart ; This should be 5 rupees, but Link never drops that.
	.dw @oneRupee

@oneRupee:
	ld hl,wNumRupees		; $6bcb
	ldi a,(hl)		; $6bce
	or (hl)			; $6bcf
	ret z			; $6bd0
	ld a,$01		; $6bd1
	call removeRupeeValue		; $6bd3
	ld a,$0c		; $6bd6
	jr @setMapleItemIndex		; $6bd8

@bombs:
	; $0a corresponds to bombs in maple's treasure indices, but for the purpose of the
	; "checkTreasureObtained" call, it actually corresponds to "TREASURE_SWITCH_HOOK"!
	ld a,$0a		; $6bda
	ldh (<hFF8B),a	; $6bdc
	call checkTreasureObtained		; $6bde
	jr nc,@cannotDrop	; $6be1

	ld hl,wNumBombs		; $6be3
	ld a,(hl)		; $6be6
	sub $04			; $6be7
	jr c,@cannotDrop	; $6be9
	daa			; $6beb
	ld (hl),a		; $6bec
	call setStatusBarNeedsRefreshBit1		; $6bed
	or d			; $6bf0
	ret			; $6bf1

@seed:
	; BUG: For the purpose of "checkTreasureObtained", the treasure index will be very
	; wrong.
	;   Ember seed:   TREASURE_SWORD
	;   Scent seed:   TREASURE_BOOMERANG
	;   Pegasus seed: TREASURE_ROD_OF_SEASONS
	;   Gale seed:    TREASURE_MAGNET_GLOVES
	;   Mystery seed: TREASURE_SWITCH_HOOK_HELPER
	ld a,b			; $6bf2
	add $05			; $6bf3
	ldh (<hFF8B),a	; $6bf5
	call checkTreasureObtained		; $6bf7
	jr nc,@cannotDrop	; $6bfa

	; See if we can remove 5 of the seed type from the inventory
	ld a,b			; $6bfc
	ld hl,wNumEmberSeeds		; $6bfd
	rst_addAToHl			; $6c00
	ld a,(hl)		; $6c01
	sub $05			; $6c02
	jr c,@cannotDrop	; $6c04
	daa			; $6c06
	ld (hl),a		; $6c07

	call setStatusBarNeedsRefreshBit1		; $6c08
	or d			; $6c0b
	ret			; $6c0c

@cannotDrop:
	xor a			; $6c0d
	ret			; $6c0e

@heart:
	ld hl,wLinkHealth		; $6c0f
	ld a,(hl)		; $6c12
	cp 12 ; Check for at least 3 hearts
	jr nc,+			; $6c15
	xor a			; $6c17
	ret			; $6c18
+
	sub $04			; $6c19
	ld (hl),a		; $6c1b

	ld hl,wStatusBarNeedsRefresh		; $6c1c
	set 2,(hl)		; $6c1f

	ld a,$0b		; $6c21

@setMapleItemIndex:
	ldh (<hFF8B),a	; $6c23
	or d			; $6c25
	ret			; $6c26

;;
; @param[out]	a	Maple.damage variable (actually vehicle type)
; @param[out]	zflag	z if Maple's in a wall? (she won't do her sweeping animation)
; @addr{6c27}
_mapleFunc_6c27:
	ld e,SpecialObject.counter2		; $6c27
	ld a,$30		; $6c29
	ld (de),a		; $6c2b

	; [direction] = [zh]. ???
	ld e,SpecialObject.zh		; $6c2c
	ld a,(de)		; $6c2e
	ld e,SpecialObject.direction		; $6c2f
	ld (de),a		; $6c31

	call objectGetTileCollisions		; $6c32
	jr nz,@collision	; $6c35
	ld e,SpecialObject.zh		; $6c37
	xor a			; $6c39
	ld (de),a		; $6c3a
	or d			; $6c3b
	ld e,SpecialObject.damage		; $6c3c
	ld a,(de)		; $6c3e
	ret			; $6c3f
@collision:
	xor a			; $6c40
	ret			; $6c41

;;
; Increments lower 4 bits of wMapleState (the number of times Maple has been met)
; @addr{6c42}
_mapleIncrementMeetingCounter:
	ld hl,wMapleState		; $6c42
	ld a,(hl)		; $6c45
	and $0f			; $6c46
	ld b,a			; $6c48
	cp $0f			; $6c49
	jr nc,+			; $6c4b
	inc b			; $6c4d
+
	xor (hl)		; $6c4e
	or b			; $6c4f
	ld (hl),a		; $6c50
	ret			; $6c51


; These are the possible paths Maple can take when you just see her shadow.
_mapleShadowPathsTable:
	.dw @rareItemDrops
	.dw @standardItemDrops

; Data format:
;   First byte is the delay it takes to change angles. (Higher values make larger arcs.)
;   Each subsequent row is:
;     b0: target angle
;     b1: number of frames to move in that direction (not counting time it takes to turn)
@rareItemDrops:
	.db $02
	.db $18 $64
	.db $10 $02
	.db $08 $1e
	.db $10 $02
	.db $18 $7a
	.db $ff $ff

@standardItemDrops:
	.db $04
	.db $18 $64
	.db $10 $04
	.db $08 $64
	.db $ff $ff


; Maps a number to an index for the table below. At first, only the first 4 bytes are read
; at random from this table, but as maple is encountered more, the subsequent bytes are
; read, giving maple more variety in the way she moves.
_mapleMovementPatternIndices:
	.db $00 $01 $02 $00 $03 $04 $05 $03
	.db $06 $07 $01 $02 $04 $05 $06 $07

_mapleMovementPatternTable:
	.dw @pattern0
	.dw @pattern1
	.dw @pattern2
	.dw @pattern3
	.dw @pattern4
	.dw @pattern5
	.dw @pattern6
	.dw @pattern7

; Data format:
;   First row is the Y/X position for Maple to start at.
;   Second row is one byte for the delay it takes to change angles.
;   Each subsequent row is:
;     b0: target angle
;     b1: number of frames to move in that direction (not counting time it takes to turn)
@pattern0:
	.db $18 $b8
	.db $02
	.db $18 $4b
	.db $10 $01
	.db $08 $32
	.db $10 $01
	.db $18 $46
	.db $ff $ff

@pattern1:
	.db $70 $b8
	.db $02
	.db $18 $4b
	.db $00 $01
	.db $08 $32
	.db $00 $01
	.db $18 $46
	.db $ff $ff

@pattern2:
	.db $18 $f0
	.db $02
	.db $08 $46
	.db $10 $19
	.db $18 $28
	.db $00 $14
	.db $08 $19
	.db $10 $0f
	.db $18 $14
	.db $00 $0a
	.db $08 $0f
	.db $10 $32
	.db $ff $ff

@pattern3:
	.db $a0 $90
	.db $02
	.db $00 $37
	.db $18 $01
	.db $10 $19
	.db $18 $01
	.db $00 $19
	.db $18 $01
	.db $10 $3c
	.db $ff $ff

@pattern4:
	.db $a0 $10
	.db $02
	.db $00 $37
	.db $08 $01
	.db $10 $19
	.db $08 $01
	.db $00 $19
	.db $08 $01
	.db $10 $3c
	.db $ff $ff

@pattern5:
	.db $18 $f0
	.db $01
	.db $08 $28
	.db $16 $0f
	.db $08 $2d
	.db $16 $0a
	.db $08 $37
	.db $ff $ff

@pattern6:
	.db $f0 $30
	.db $02
	.db $14 $19
	.db $05 $11
	.db $14 $0a
	.db $17 $05
	.db $10 $01
	.db $05 $1e
	.db $14 $1e
	.db $ff $ff

@pattern7:
	.db $f0 $70
	.db $02
	.db $0c $19
	.db $1b $11
	.db $0c $08
	.db $0a $02
	.db $10 $01
	.db $1b $0f
	.db $0c $1e
	.db $ff $ff



;;
; @addr{6d1e}
_specialObjectCode_ricky:
	call _companionRetIfInactive		; $6d1e
	call _companionFunc_47d8		; $6d21
	call @runState		; $6d24
	jp _companionCheckEnableTerrainEffects		; $6d27

@runState:
	ld e,SpecialObject.state		; $6d2a
	ld a,(de)		; $6d2c
	rst_jumpTable			; $6d2d
	.dw _rickyState0
	.dw _rickyState1
	.dw _rickyState2
	.dw _rickyState3
	.dw _rickyState4
	.dw _rickyState5
	.dw _rickyState6
	.dw _rickyState7
	.dw _rickyState8
	.dw _rickyState9
	.dw _rickyStateA
	.dw _rickyStateB
	.dw _rickyStateC

;;
; State 0: initialization
; @addr{6d48}
_rickyState0:
_rickyStateB:
	call _companionCheckCanSpawn ; This may return

	ld a,$06		; $6d4b
	call objectSetCollideRadius		; $6d4d

	ld a,DIR_DOWN		; $6d50
	ld l,SpecialObject.direction		; $6d52
	ldi (hl),a		; $6d54
	ld (hl),a ; [angle] = $02

	ld l,SpecialObject.var39		; $6d56
	ld (hl),$10		; $6d58
	ld a,(wRickyState)		; $6d5a
	bit 7,a			; $6d5d
	jr nz,@setAnimation17	; $6d5f

	ld c,$17		; $6d61
	bit 6,a			; $6d63
	jr nz,@canTalkToRicky	; $6d65

	and $20			; $6d67
	jr nz,@setAnimation17	; $6d69

	ld c,$00		; $6d6b
@canTalkToRicky:
	; Ricky not ridable yet, can press A to talk to him
	ld l,SpecialObject.state		; $6d6d
	ld (hl),$0a		; $6d6f
	ld e,SpecialObject.var3d		; $6d71
	call objectAddToAButtonSensitiveObjectList		; $6d73
	ld a,c			; $6d76
	jr @setAnimation		; $6d77

@setAnimation17:
	ld a,$17		; $6d79

@setAnimation:
	call specialObjectSetAnimation		; $6d7b
	jp objectSetVisiblec1		; $6d7e

;;
; State 1: waiting for Link to mount
; @addr{6d81}
_rickyState1:
	call specialObjectAnimate		; $6d81
	call _companionSetPriorityRelativeToLink		; $6d84

	ld c,$09		; $6d87
	call objectCheckLinkWithinDistance		; $6d89
	jr nc,@didntMount	; $6d8c

	call _companionTryToMount		; $6d8e
	ret z			; $6d91

@didntMount:
	; Make Ricky hop every once in a while
	ld e,SpecialObject.animParameter		; $6d92
	ld a,(de)		; $6d94
	and $c0			; $6d95
	jr z,_rickyCheckHazards		; $6d97
	rlca			; $6d99
	ld c,$40		; $6d9a
	jp nc,objectUpdateSpeedZ_paramC		; $6d9c
	ld bc,$ff00		; $6d9f
	call objectSetSpeedZ		; $6da2

;;
; @addr{6da5}
_rickyCheckHazards:
	call _companionCheckHazards		; $6da5
	jp c,_rickyFunc_70cc		; $6da8

;;
; @addr{6dab}
_rickyState9:
	ret			; $6dab

;;
; State 2: Jumping up a cliff
; @addr{6dac}
_rickyState2:
	call _companionDecCounter1		; $6dac
	jr z,++			; $6daf
	dec (hl)		; $6db1
	ret nz			; $6db2
	ld a,SND_RICKY		; $6db3
	call playSound		; $6db5
++
	ld c,$40		; $6db8
	call objectUpdateSpeedZ_paramC		; $6dba
	call specialObjectAnimate		; $6dbd
	call objectApplySpeed		; $6dc0

	call _companionCalculateAdjacentWallsBitset		; $6dc3

	; Check whether Ricky's passed through any walls?
	ld e,SpecialObject.adjacentWallsBitset		; $6dc6
	ld a,(de)		; $6dc8
	and $0f			; $6dc9
	ld e,SpecialObject.counter2		; $6dcb
	jr z,+			; $6dcd
	ld (de),a		; $6dcf
	ret			; $6dd0
+
	ld a,(de)		; $6dd1
	or a			; $6dd2
	ret z			; $6dd3
	jp _rickyStopUntilLandedOnGround		; $6dd4

;;
; State 3: Link is currently jumping up to mount Ricky
; @addr{6dd7}
_rickyState3:
	ld c,$40		; $6dd7
	call objectUpdateSpeedZ_paramC		; $6dd9
	call _companionCheckMountingComplete		; $6ddc
	ret nz			; $6ddf

	call _companionFinalizeMounting		; $6de0
	ld a,SND_RICKY		; $6de3
	call playSound		; $6de5
	ld c,$20		; $6de8
	jp _companionSetAnimation		; $6dea

;;
; State 4: Ricky falling into a hazard (hole/water)
; @addr{6ded}
_rickyState4:
	ld e,SpecialObject.var37		; $6ded
	ld a,(de)		; $6def
	cp $0e ; Is this water?
	jr z,++			; $6df2

	; For any other value of var37, assume it's a hole ($0d).
	ld a,$0d		; $6df4
	ld (de),a		; $6df6
	call _companionDragToCenterOfHole		; $6df7
	ret nz			; $6dfa
++
	call _companionDecCounter1		; $6dfb
	jr nz,@animate	; $6dfe

	inc (hl)		; $6e00
	ld e,SpecialObject.var37		; $6e01
	ld a,(de)		; $6e03
	call specialObjectSetAnimation		; $6e04

	ld e,SpecialObject.var37		; $6e07
	ld a,(de)		; $6e09
	cp $0e ; Is this water?
	jr z,@animate	; $6e0c
	ld a,SND_LINK_FALL		; $6e0e
	jp playSound		; $6e10

@animate:
	call _companionAnimateDrowningOrFallingThenRespawn		; $6e13
	ret nc			; $6e16

	; Decide animation depending whether Link is riding Ricky
	ld c,$01		; $6e17
	ld a,(wLinkObjectIndex)		; $6e19
	rrca			; $6e1c
	jr nc,+			; $6e1d
	ld c,$05		; $6e1f
+
	jp _companionUpdateDirectionAndSetAnimation		; $6e21

;;
; State 5: Link riding Ricky.
;
; (Note: this may be called from state C?)
;
; @addr{6e24}
_rickyState5:
	ld e,SpecialObject.state2		; $6e24
	ld a,(de)		; $6e26
	rst_jumpTable			; $6e27
	.dw _rickyState5Substate0
	.dw _rickyState5Substate1
	.dw _rickyState5Substate2
	.dw _rickyState5Substate3

;;
; Substate 0: moving (not hopping)
; @addr{6e30}
_rickyState5Substate0:
	ld a,(wForceCompanionDismount)		; $6e30
	or a			; $6e33
	jr nz,++		; $6e34

	ld a,(wGameKeysJustPressed)		; $6e36
	bit BTN_BIT_A,a			; $6e39
	jp nz,_rickyStartPunch		; $6e3b

	bit BTN_BIT_B,a			; $6e3e
++
	jp nz,_companionGotoDismountState		; $6e40

	; Copy Link's angle (calculated from input buttons) to companion's angle
	ld h,d			; $6e43
	ld a,(wLinkAngle)		; $6e44
	ld l,SpecialObject.angle		; $6e47
	ld (hl),a		; $6e49

	; If not moving, set var39 to $10 (counter until Ricky hops)
	rlca			; $6e4a
	ld l,SpecialObject.var39		; $6e4b
	jr nc,@moving		; $6e4d
	ld a,$10		; $6e4f
	ld (hl),a		; $6e51

	ld c,$20		; $6e52
	call _companionSetAnimation		; $6e54
	jp _rickyCheckHazards		; $6e57

@moving:
	; Check if the "jump countdown" has reached zero
	ld l,SpecialObject.var39		; $6e5a
	ld a,(hl)		; $6e5c
	or a			; $6e5d
	jr z,@tryToJump		; $6e5e

	dec (hl) ; [var39]-=1

	ld l,SpecialObject.speed		; $6e61
	ld (hl),SPEED_c0		; $6e63

	ld c,$20		; $6e65
	call _companionUpdateDirectionAndAnimate		; $6e67
	call _rickyCheckForHoleInFront		; $6e6a
	jp z,_rickyBeginJumpOverHole		; $6e6d

	call _companionCheckHopDownCliff		; $6e70
	jr nz,+			; $6e73
	jp _rickySetJumpSpeed		; $6e75
+
	call _rickyCheckHopUpCliff		; $6e78
	jr nz,+			; $6e7b
	jp _rickySetJumpSpeed_andcc91		; $6e7d
+
	call _companionUpdateMovement		; $6e80
	jp _rickyCheckHazards		; $6e83

; "Jump timer" has reached zero; make him jump (either from movement, over a hole, or up
; or down a cliff).
@tryToJump:
	ld h,d			; $6e86
	ld l,SpecialObject.angle		; $6e87
	ldd a,(hl)		; $6e89
	add a			; $6e8a
	swap a			; $6e8b
	and $03			; $6e8d
	ldi (hl),a		; $6e8f
	call _rickySetJumpSpeed_andcc91		; $6e90

	; If he's moving left or right, skip the up/down cliff checks
	ld l,SpecialObject.angle		; $6e93
	ld a,(hl)		; $6e95
	bit 2,a			; $6e96
	jr nz,@jump	; $6e98

	call _companionCheckHopDownCliff		; $6e9a
	jr nz,++		; $6e9d
	ld (wDisableScreenTransitions),a		; $6e9f
	ld c,$0f		; $6ea2
	jp _companionSetAnimation		; $6ea4
++
	call _rickyCheckHopUpCliff		; $6ea7
	ld c,$0f		; $6eaa
	jp z,_companionSetAnimation		; $6eac

@jump:
	; If there's a hole in front, try to jump over it
	ld e,SpecialObject.state2		; $6eaf
	ld a,$02		; $6eb1
	ld (de),a		; $6eb3
	call _rickyCheckForHoleInFront		; $6eb4
	jp z,_rickyBeginJumpOverHole		; $6eb7

	; Otherwise, just do a normal hop
	ld bc,-$180		; $6eba
	call objectSetSpeedZ		; $6ebd
	ld l,SpecialObject.state2		; $6ec0
	ld (hl),$01		; $6ec2
	ld l,SpecialObject.counter1		; $6ec4
	ld (hl),$08		; $6ec6
	ld l,SpecialObject.speed		; $6ec8
	ld (hl),SPEED_200		; $6eca
	ld c,$19		; $6ecc
	call _companionSetAnimation		; $6ece

	call getRandomNumber		; $6ed1
	and $0f			; $6ed4
	ld a,SND_JUMP		; $6ed6
	jr nz,+			; $6ed8
	ld a,SND_RICKY		; $6eda
+
	jp playSound		; $6edc

;;
; Checks for holes for Ricky to jump over. Stores the tile 2 spaces away in var36.
;
; @param[out]	a	The tile directly in front of Ricky
; @param[out]	var36	The tile 2 spaces in front of Ricky
; @param[out]	zflag	Set if the tile in front of Ricky is a hole
; @addr{6edf}
_rickyCheckForHoleInFront:
	; Make sure we're not moving diagonally
	ld a,(wLinkAngle)		; $6edf
	and $04			; $6ee2
	ret nz			; $6ee4

	ld e,SpecialObject.direction		; $6ee5
	ld a,(de)		; $6ee7
	ld hl,_rickyHoleCheckOffsets		; $6ee8
	rst_addDoubleIndex			; $6eeb

	; Set b = y-position 2 tiles away, [hFF90] = y-position one tile away
	ld e,SpecialObject.yh		; $6eec
	ld a,(de)		; $6eee
	add (hl)		; $6eef
	ldh (<hFF90),a	; $6ef0
	add (hl)		; $6ef2
	ld b,a			; $6ef3

	; Set c = x-position 2 tiles away, [hFF91] = x-position one tile away
	inc hl			; $6ef4
	ld e,SpecialObject.xh		; $6ef5
	ld a,(de)		; $6ef7
	add (hl)		; $6ef8
	ldh (<hFF91),a	; $6ef9
	add (hl)		; $6efb
	ld c,a			; $6efc

	; Store in var36 the index of the tile 2 spaces away
	call getTileAtPosition		; $6efd
	ld a,l			; $6f00
	ld e,SpecialObject.var36		; $6f01
	ld (de),a		; $6f03

	ldh a,(<hFF90)	; $6f04
	ld b,a			; $6f06
	ldh a,(<hFF91)	; $6f07
	ld c,a			; $6f09
	call getTileAtPosition		; $6f0a
	ld h,>wRoomLayout		; $6f0d
	ld a,(hl)		; $6f0f
	cp TILEINDEX_HOLE			; $6f10
	ret z			; $6f12
	cp TILEINDEX_FD			; $6f13
	ret			; $6f15

;;
; Substate 1: hopping during normal movement
; @addr{6f16}
_rickyState5Substate1:
	dec e			; $6f16
	ld a,(de) ; Check [state]
	cp $05			; $6f18
	jr nz,@doneInputParsing	; $6f1a

	ld a,(wGameKeysJustPressed)		; $6f1c
	bit BTN_BIT_A,a			; $6f1f
	jp nz,_rickyStartPunch		; $6f21

	; Check if we're attempting to move
	ld a,(wLinkAngle)		; $6f24
	bit 7,a			; $6f27
	jr nz,@doneInputParsing	; $6f29

	; Update direction based on wLinkAngle
	ld hl,w1Companion.direction		; $6f2b
	ld b,a			; $6f2e
	add a			; $6f2f
	swap a			; $6f30
	and $03			; $6f32
	ldi (hl),a		; $6f34

	; Check if angle changed (and if animation needs updating)
	ld a,b			; $6f35
	cp (hl)			; $6f36
	ld (hl),a		; $6f37
	ld c,$19		; $6f38
	call nz,_companionSetAnimation		; $6f3a

@doneInputParsing:
	ld c,$40		; $6f3d
	call objectUpdateSpeedZ_paramC		; $6f3f
	jr z,@landed		; $6f42

	ld a,(wLinkObjectIndex)		; $6f44
	rra			; $6f47
	jr nc,++		; Check if Link's riding?
	ld a,(wLinkAngle)		; $6f4a
	and $04			; $6f4d
	jr nz,@updateMovement	; $6f4f
++
	; If Ricky's facing a hole, don't move into it
	ld hl,_rickyHoleCheckOffsets		; $6f51
	call _specialObjectGetRelativeTileWithDirectionTable		; $6f54
	ld a,b			; $6f57
	cp TILEINDEX_HOLE			; $6f58
	ret z			; $6f5a
	cp TILEINDEX_FD			; $6f5b
	ret z			; $6f5d

@updateMovement:
	jp _companionUpdateMovement		; $6f5e

@landed:
	call specialObjectAnimate		; $6f61
	call _companionDecCounter1IfNonzero		; $6f64
	ret nz			; $6f67
	jp _rickyStopUntilLandedOnGround		; $6f68

;;
; Substate 2: jumping over a hole
; @addr{6f6b}
_rickyState5Substate2:
	call _companionDecCounter1		; $6f6b
	jr z,++			; $6f6e
	dec (hl)		; $6f70
	ret nz			; $6f71
	ld a,SND_RICKY		; $6f72
	call playSound		; $6f74
++
	ld c,$40		; $6f77
	call objectUpdateSpeedZ_paramC		; $6f79
	jp z,_rickyStopUntilLandedOnGround		; $6f7c

	call specialObjectAnimate		; $6f7f
	call _companionUpdateMovement		; $6f82
	call _specialObjectCheckMovingTowardWall		; $6f85
	jp nz,_rickyStopUntilLandedOnGround		; $6f88
	ret			; $6f8b

;;
; Substate 3: just landed on the ground (or waiting to land on the ground?)
; @addr{6f8c}
_rickyState5Substate3:
	; If he hasn't landed yet, do nothing until he does
	ld c,$40		; $6f8c
	call objectUpdateSpeedZ_paramC		; $6f8e
	ret nz			; $6f91

	call _rickyBreakTilesOnLanding		; $6f92

	; Return to state 5, substate 0 (normal movement)
	xor a			; $6f95
	ld e,SpecialObject.state2		; $6f96
	ld (de),a		; $6f98

	jp _rickyCheckHazards2		; $6f99

;;
; State 8: punching (substate 0) or charging tornado (substate 1)
; @addr{6f9c}
_rickyState8:
	ld e,$05		; $6f9c
	ld a,(de)		; $6f9e
	rst_jumpTable			; $6f9f
	.dw @substate0
	.dw @substate1

; Substate 0: punching
@substate0:
	ld c,$40		; $6fa4
	call objectUpdateSpeedZ_paramC		; $6fa6
	jr z,@onGround			; $6fa9

	call _companionUpdateMovement		; $6fab
	jr ++			; $6fae

@onGround:
	call _companionTryToBreakTileFromMoving		; $6fb0
	call _rickyCheckHazards		; $6fb3
++
	; Wait for the animation to signal something (play sound effect or start tornado
	; charging)
	call specialObjectAnimate		; $6fb6
	ld e,SpecialObject.animParameter		; $6fb9
	ld a,(de)		; $6fbb
	and $c0			; $6fbc
	ret z			; $6fbe

	rlca			; $6fbf
	jr c,@startTornadoCharge			; $6fc0

	ld a,SND_UNKNOWN5		; $6fc2
	jp playSound		; $6fc4

@startTornadoCharge:
	; Return if in midair
	ld e,SpecialObject.zh		; $6fc7
	ld a,(de)		; $6fc9
	or a			; $6fca
	ret nz			; $6fcb

	; Check if let go of the button
	ld a,(wGameKeysPressed)		; $6fcc
	and BTN_A			; $6fcf
	jp z,_rickyStopUntilLandedOnGround		; $6fd1

	; Start tornado charging
	call itemIncState2		; $6fd4
	ld c,$13		; $6fd7
	call _companionSetAnimation		; $6fd9
	call _companionCheckHazards		; $6fdc
	ret nc			; $6fdf
	jp _rickyFunc_70cc		; $6fe0

; Substate 1: charging tornado
@substate1:
	; Update facing direction
	ld a,(wLinkAngle)		; $6fe3
	bit 7,a			; $6fe6
	jr nz,++		; $6fe8
	ld hl,w1Companion.angle		; $6fea
	cp (hl)			; $6fed
	ld (hl),a		; $6fee
	ld c,$13		; $6fef
	call nz,_companionUpdateDirectionAndAnimate		; $6ff1
++
	call specialObjectAnimate		; $6ff4
	ld a,(wGameKeysPressed)		; $6ff7
	and BTN_A			; $6ffa
	jr z,@releasedAButton	; $6ffc

	; Check if fully charged
	ld e,SpecialObject.var35		; $6ffe
	ld a,(de)		; $7000
	cp $1e			; $7001
	jr nz,@continueCharging		; $7003

	call _companionTryToBreakTileFromMoving		; $7005
	call _rickyCheckHazards		; $7008
	ld c,$04		; $700b
	jp _companionFlashFromChargingAnimation		; $700d

@continueCharging:
	inc a			; $7010
	ld (de),a ; [var35]++
	cp $1e			; $7012
	ret nz			; $7014
	ld a,SND_CHARGE_SWORD		; $7015
	jp playSound		; $7017

@releasedAButton:
	; Reset palette to normal
	ld hl,w1Link.oamFlagsBackup		; $701a
	ldi a,(hl)		; $701d
	ld (hl),a		; $701e

	ld e,SpecialObject.var35		; $701f
	ld a,(de)		; $7021
	cp $1e			; $7022
	jr nz,@notCharged	; $7024

	ldbc ITEMID_RICKY_TORNADO, $00		; $7026
	call _companionCreateItem		; $7029

	ld a,SNDCTRL_STOPSFX		; $702c
	call playSound		; $702e
	ld a,SND_SWORDSPIN		; $7031
	call playSound		; $7033

	jr _rickyStartPunch		; $7036

@notCharged:
	ld c,$05		; $7038
	jp _companionSetAnimationAndGotoState5		; $703a

;;
; @addr{703d}
_rickyStartPunch:
	ldbc ITEMID_28, $00		; $703d
	call _companionCreateWeaponItem		; $7040
	ret nz			; $7043
	ld h,d			; $7044
	ld l,SpecialObject.state		; $7045
	ld a,$08		; $7047
	ldi (hl),a		; $7049
	xor a			; $704a
	ld (hl),a ; [state2] = 0

	inc a			; $704c
	ld l,SpecialObject.var35		; $704d
	ld (hl),a		; $704f
	ld c,$09		; $7050
	call _companionSetAnimation		; $7052
	ld a,SND_SWORDSLASH		; $7055
	jp playSound		; $7057

;;
; State 6: Link has dismounted; he can't remount until he moves a certain distance away,
; then comes back.
; @addr{705a}
_rickyState6:
	ld e,SpecialObject.state2		; $705a
	ld a,(de)		; $705c
	rst_jumpTable			; $705d
	.dw @substate0
	.dw @substate1
	.dw @substate2

@substate0:
	ld c,$40		; $7064
	call objectUpdateSpeedZ_paramC		; $7066
	ret nz			; $7069
	call itemIncState2		; $706a
	call companionDismountAndSavePosition		; $706d
	ld a,$17		; $7070
	jp specialObjectSetAnimation		; $7072

@substate1:
	ld a,(wLinkInAir)		; $7075
	or a			; $7078
	ret nz			; $7079
	jp itemIncState2		; $707a

; Waiting for Link to get a certain distance away before allowing him to mount again
@substate2:
	call _companionSetPriorityRelativeToLink		; $707d

	ld c,$09		; $7080
	call objectCheckLinkWithinDistance		; $7082
	jp c,_rickyCheckHazards		; $7085

	; Link is far enough away; allow him to remount when he approaches again.
	ld e,SpecialObject.state2		; $7088
	xor a			; $708a
	ld (de),a ; [state2] = 0
	dec e			; $708c
	inc a			; $708d
	ld (de),a ; [state] = 1
	ret			; $708f

;;
; State 7: Jumping down a cliff
; @addr{7090}
_rickyState7:
	call _companionDecCounter1ToJumpDownCliff		; $7090
	ret c			; $7093

	call _companionCalculateAdjacentWallsBitset		; $7094
	call _specialObjectCheckMovingAwayFromWall		; $7097
	ld e,$07		; $709a
	jr z,+			; $709c
	ld (de),a		; $709e
	ret			; $709f
+
	ld a,(de)		; $70a0
	or a			; $70a1
	ret z			; $70a2

;;
; Sets ricky to state 5, substate 3 (do nothing until he lands, then continue normal
; movement)
; @addr{70a3}
_rickyStopUntilLandedOnGround:
	ld a,(wLinkObjectIndex)		; $70a3
	rrca			; $70a6
	jr nc,+			; $70a7
	xor a			; $70a9
	ld (wLinkInAir),a		; $70aa
	ld (wDisableScreenTransitions),a		; $70ad
+
	ld a,$05		; $70b0
	ld e,SpecialObject.state		; $70b2
	ld (de),a		; $70b4
	ld a,$03		; $70b5
	ld e,SpecialObject.state2		; $70b7
	ld (de),a		; $70b9

	; If Ricky's close to the screen edge, set the "jump delay counter" back to $10 so
	; that he'll stay on the ground long enough for a screen transition to happen
	call _rickyCheckAtScreenEdge		; $70ba
	jr z,_rickyCheckHazards2			; $70bd
	ld e,SpecialObject.var39		; $70bf
	ld a,$10		; $70c1
	ld (de),a		; $70c3

;;
; @addr{70c4}
_rickyCheckHazards2:
	call _companionCheckHazards		; $70c4
	ld c,$20		; $70c7
	jp nc,_companionSetAnimation		; $70c9

;;
; @param	a	Hazard type landed on
; @addr{70cc}
_rickyFunc_70cc:
	ld c,$0e		; $70cc
	cp $01 ; Landed on water?
	jr z,+			; $70d0
	ld c,$0d		; $70d2
+
	ld h,d			; $70d4
	ld l,SpecialObject.var37		; $70d5
	ld (hl),c		; $70d7
	ld l,SpecialObject.counter1		; $70d8
	ld (hl),$00		; $70da
	ret			; $70dc

;;
; State A: various cutscene-related things? Behaviour is controlled by "var03" instead of
; "state2".
;
; @addr{70dd}
_rickyStateA:
	ld e,SpecialObject.var03		; $70dd
	ld a,(de)		; $70df
	rst_jumpTable			; $70e0
	.dw _rickyStateASubstate0
	.dw _rickyStateASubstate1
	.dw _rickyStateASubstate2
	.dw _rickyStateASubstate3
	.dw _rickyStateASubstate4
	.dw _rickyStateASubstate5
	.dw _rickyStateASubstate6
	.dw _rickyStateASubstate7

;;
; Standing around doing nothing?
; @addr{70f1}
_rickyStateASubstate0:
	call _companionPreventLinkFromPassing_noExtraChecks		; $70f1
	call _companionSetPriorityRelativeToLink		; $70f4
	call specialObjectAnimate		; $70f7
	ld e,$21		; $70fa
	ld a,(de)		; $70fc
	rlca			; $70fd
	ld c,$40		; $70fe
	jp nc,objectUpdateSpeedZ_paramC		; $7100
	ld bc,-$100		; $7103
	jp objectSetSpeedZ		; $7106

;;
; Force Link to mount
; @addr{7109}
_rickyStateASubstate1:
	ld e,SpecialObject.var3d		; $7109
	call objectRemoveFromAButtonSensitiveObjectList		; $710b
	jp _companionForceMount		; $710e

;;
; Ricky leaving upon meeting Tingle (part 1: print text)
; @addr{7111}
_rickyStateASubstate2:
	ld c,$40		; $7111
	call objectUpdateSpeedZ_paramC		; $7113
	ret nz			; $7116

	ld bc,TX_2006		; $7117
	call showText		; $711a

	ld hl,w1Link.yh		; $711d
	ld e,SpecialObject.yh		; $7120
	ld a,(de)		; $7122
	cp (hl)			; $7123
	ld a,$02		; $7124
	jr c,+			; $7126
	ld a,$00		; $7128
+
	ld e,SpecialObject.direction		; $712a
	ld (de),a		; $712c
	ld a,$03		; $712d
	ld e,SpecialObject.var3f		; $712f
	ld (de),a		; $7131
	call specialObjectSetAnimation		; $7132
	call _rickyIncVar03		; $7135
	jr _rickySetJumpSpeedForCutscene		; $7138

;;
; @addr{713a}
_rickySetJumpSpeedForCutsceneAndSetAngle:
	ld b,$30		; $713a
	ld c,$58		; $713c
	call objectGetRelativeAngle		; $713e
	and $1c			; $7141
	ld e,SpecialObject.angle		; $7143
	ld (de),a		; $7145

;;
; @addr{7146}
_rickySetJumpSpeedForCutscene:
	ld bc,-$180		; $7146
	call objectSetSpeedZ		; $7149
	ld l,SpecialObject.state2		; $714c
	ld (hl),$01		; $714e
	ld l,SpecialObject.speed		; $7150
	ld (hl),SPEED_200		; $7152
	ld l,SpecialObject.counter1		; $7154
	ld (hl),$08		; $7156
	ret			; $7158

;;
; Ricky leaving upon meeting Tingle (part 5: punching the air)
; @addr{7159}
_rickyStateASubstate6:
	; Wait for animation to give signals to play sound, start moving away.
	call specialObjectAnimate		; $7159
	ld e,SpecialObject.animParameter		; $715c
	ld a,(de)		; $715e
	or a			; $715f
	ld a,SND_RICKY		; $7160
	jp z,playSound		; $7162

	ld a,(de)		; $7165
	rlca			; $7166
	ret nc			; $7167

	; Start moving away
	call _rickySetJumpSpeedForCutsceneAndSetAngle		; $7168
	ld e,SpecialObject.angle		; $716b
	ld a,$10		; $716d
	ld (de),a		; $716f

	ld c,$05		; $7170
	call _companionSetAnimation		; $7172
	jp _rickyIncVar03		; $7175

;;
; Ricky leaving upon meeting Tingle (part 2: start moving toward cliff)
; @addr{7178}
_rickyStateASubstate3:
	call retIfTextIsActive		; $7178

	; Move down-left
	ld a,$14		; $717b
	ld e,SpecialObject.angle		; $717d
	ld (de),a		; $717f

	; Face down
	dec e			; $7180
	ld a,$02		; $7181
	ld (de),a		; $7183

	ld c,$05		; $7184
	call _companionSetAnimation		; $7186
	jp _rickyIncVar03		; $7189

;;
; Ricky leaving upon meeting Tingle (part 4: jumping down cliff)
; @addr{718c}
_rickyStateASubstate5:
	call specialObjectAnimate		; $718c
	call objectApplySpeed		; $718f
	ld c,$40		; $7192
	call objectUpdateSpeedZ_paramC		; $7194
	ret nz			; $7197

	; Reached bottom of cliff
	ld a,$18		; $7198
	call specialObjectSetAnimation		; $719a
	jp _rickyIncVar03		; $719d

;;
; Ricky leaving upon meeting Tingle (part 3: moving toward cliff, or...
;                                    part 6: moving toward screen edge)
; @addr{71a0}
_rickyStateASubstate4:
_rickyStateASubstate7:
	call _companionSetAnimationToVar3f		; $71a0
	call _rickyWaitUntilJumpDone		; $71a3
	ret nz			; $71a6

	; Ricky has just touched the ground, and is ready to do another hop.

	; Check if moving toward a wall on the left
	ld a,$18		; $71a7
	ld e,SpecialObject.angle		; $71a9
	ld (de),a		; $71ab
	call _specialObjectCheckMovingTowardWall		; $71ac
	jr z,@hop	; $71af

	; Check if moving toward a wall below
	ld a,$10		; $71b1
	ld e,SpecialObject.angle		; $71b3
	ld (de),a		; $71b5
	call _specialObjectCheckMovingTowardWall		; $71b6
	jr z,@hop	; $71b9

	; He's against the cliff; proceed to next state (jumping down cliff).
	call _rickySetJumpSpeed		; $71bb
	ld a,SND_JUMP		; $71be
	call playSound		; $71c0
	jp _rickyIncVar03		; $71c3

@hop:
	call objectCheckWithinScreenBoundary		; $71c6
	jr nc,@leftScreen	; $71c9

	; Moving toward cliff, or screen edge? Set angle accordingly.
	ld e,SpecialObject.var03		; $71cb
	ld a,(de)		; $71cd
	cp $07			; $71ce
	ld a,$10		; $71d0
	jr z,+			; $71d2
	ld a,$14		; $71d4
+
	ld e,SpecialObject.angle		; $71d6
	ld (de),a		; $71d8
	jp _rickySetJumpSpeedForCutscene		; $71d9

@leftScreen:
	xor a			; $71dc
	ld (wDisabledObjects),a		; $71dd
	ld (wMenuDisabled),a		; $71e0
	ld (wDeathRespawnBuffer.rememberedCompanionId),a		; $71e3
	call itemDelete		; $71e6
	ld hl,wRickyState		; $71e9
	set 6,(hl)		; $71ec
	jp saveLinkLocalRespawnAndCompanionPosition		; $71ee

;;
; @addr{71f1}
_rickyIncVar03:
	ld e,SpecialObject.var03		; $71f1
	ld a,(de)		; $71f3
	inc a			; $71f4
	ld (de),a		; $71f5
	ret			; $71f6

;;
; Unused? (Seasons departure code?)
; @addr{71f7}
_rickyFunc_71f7:
	call retIfTextIsActive		; $71f7
	call companionDismount		; $71fa

	ld a,$18		; $71fd
	ld (w1Link.angle),a		; $71ff
	ld (wLinkAngle),a		; $7202

	ld a,SPEED_140		; $7205
	ld (w1Link.speed),a		; $7207

	ld h,d			; $720a
	ld l,SpecialObject.angle		; $720b
	ld a,$18		; $720d
	ldd (hl),a		; $720f

	ld a,DIR_LEFT		; $7210
	ldd (hl),a ; [direction] = DIR_LEFT
	ld a,$1e		; $7213
	ld (hl),a ; [counter2] = $1e

	ld a,$24		; $7216
	call specialObjectSetAnimation		; $7218
	jr _rickyIncVar03		; $721b

;;
; Unused? (Seasons departure code?)
; @addr{721d}
_rickyFunc_721d:
	ld a,(wLinkInAir)		; $721d
	or a			; $7220
	ret nz			; $7221

	call setLinkForceStateToState08		; $7222
	ld hl,w1Link.xh		; $7225
	ld e,SpecialObject.xh		; $7228
	ld a,(de)		; $722a
	bit 7,a			; $722b
	jr nz,+		; $722d

	cp (hl)			; $722f
	ld a,DIR_RIGHT		; $7230
	jr nc,++			; $7232
+
	ld a,DIR_LEFT		; $7234
++
	ld l,SpecialObject.direction		; $7236
	ld (hl),a		; $7238
	ld e,SpecialObject.counter2		; $7239
	ld a,(de)		; $723b
	or a			; $723c
	jr z,@moveCompanion	; $723d
	dec a			; $723f
	ld (de),a		; $7240
	ret			; $7241

@moveCompanion:
	call specialObjectAnimate		; $7242
	call _companionUpdateMovement		; $7245
	call objectCheckWithinScreenBoundary		; $7248
	ret c			; $724b
	xor a			; $724c
	ld (wRememberedCompanionId),a		; $724d
	ld (wDisabledObjects),a		; $7250
	ld (wMenuDisabled),a		; $7253
	jp itemDelete		; $7256

;;
; @param[out]	zflag	Set if Ricky's on the ground and counter1 has reached 0.
; @addr{7259}
_rickyWaitUntilJumpDone:
	ld c,$40		; $7259
	call objectUpdateSpeedZ_paramC		; $725b
	jr z,@onGround		; $725e

	call _companionUpdateMovement		; $7260
	or d			; $7263
	ret			; $7264

@onGround:
	ld c,$05		; $7265
	call _companionSetAnimation		; $7267
	jp _companionDecCounter1IfNonzero		; $726a

;;
; State $0c: Ricky entering screen from flute call
; @addr{726d}
_rickyStateC:
	ld e,SpecialObject.var03		; $726d
	ld a,(de)		; $726f
	rst_jumpTable			; $7270
	.dw @parameter0
	.dw @parameter1

@parameter0:
	call _companionInitializeOnEnteringScreen		; $7275
	ld (hl),$02		; $7278
	call _rickySetJumpSpeedForCutscene		; $727a
	ld a,SND_RICKY		; $727d
	call playSound		; $727f
	ld c,$01		; $7282
	jp _companionSetAnimation		; $7284

@parameter1:
	call _rickyState5		; $7287

	; Return if falling into a hazard
	ld e,SpecialObject.state		; $728a
	ld a,(de)		; $728c
	cp $04			; $728d
	ret z			; $728f

	ld a,$0c		; $7290
	ld (de),a ; [state] = $0c
	inc e			; $7293
	ld a,(de) ; a = [state2]
	cp $03			; $7295
	ret nz			; $7297

	call _rickyBreakTilesOnLanding		; $7298
	ld hl,_rickyHoleCheckOffsets		; $729b
	call _specialObjectGetRelativeTileWithDirectionTable		; $729e
	or a			; $72a1
	jr nz,@initializeRicky	; $72a2
	call itemDecCounter2		; $72a4
	jr z,@initializeRicky	; $72a7
	call _rickySetJumpSpeedForCutscene		; $72a9
	ld c,$01		; $72ac
	jp _companionSetAnimation		; $72ae

; Make Ricky stop moving in, start waiting in place
@initializeRicky:
	ld e,SpecialObject.var03		; $72b1
	xor a			; $72b3
	ld (de),a		; $72b4
	jp _rickyState0		; $72b5


;;
; @param[out]	zflag	Set if Ricky should hop up a cliff
; @addr{72b8}
_rickyCheckHopUpCliff:
	; Check that Ricky's facing a wall above him
	ld e,SpecialObject.adjacentWallsBitset		; $72b8
	ld a,(de)		; $72ba
	and $c0			; $72bb
	cp $c0			; $72bd
	ret nz			; $72bf

	; Check that we're trying to move up
	ld a,(wLinkAngle)		; $72c0
	cp $00			; $72c3
	ret nz			; $72c5

	; Ricky can jump up to two tiles above him where the collision value equals $03
	; (only the bottom half of the tile is solid).

; Check that the tiles on ricky's left and right sides one tile up are clear
@tryOneTileUp:
	ld hl,@cliffOffset_oneUp_right		; $72c6
	call _specialObjectGetRelativeTileFromHl		; $72c9
	cp $03			; $72cc
	jr z,+			; $72ce
	ld a,b			; $72d0
	cp TILEINDEX_VINE_TOP			; $72d1
	jr nz,@tryTwoTilesUp	; $72d3
+
	ld hl,@cliffOffset_oneUp_left		; $72d5
	call _specialObjectGetRelativeTileFromHl		; $72d8
	cp $03			; $72db
	jr z,@canJumpUpCliff	; $72dd
	ld a,b			; $72df
	cp TILEINDEX_VINE_TOP			; $72e0
	jr z,@canJumpUpCliff	; $72e2

; Check that the tiles on ricky's left and right sides two tiles up are clear
@tryTwoTilesUp:
	ld hl,@cliffOffset_twoUp_right		; $72e4
	call _specialObjectGetRelativeTileFromHl		; $72e7
	cp $03			; $72ea
	jr z,+			; $72ec
	ld a,b			; $72ee
	cp TILEINDEX_VINE_TOP			; $72ef
	ret nz			; $72f1
+
	ld hl,@cliffOffset_twoUp_left		; $72f2
	call _specialObjectGetRelativeTileFromHl		; $72f5
	cp $03			; $72f8
	jr z,@canJumpUpCliff	; $72fa
	ld a,b			; $72fc
	cp TILEINDEX_VINE_TOP			; $72fd
	ret nz			; $72ff

@canJumpUpCliff:
	; State 2 handles jumping up a cliff
	ld e,SpecialObject.state		; $7300
	ld a,$02		; $7302
	ld (de),a		; $7304
	inc e			; $7305
	xor a			; $7306
	ld (de),a ; [state2] = 0

	ld e,SpecialObject.counter2		; $7308
	ld (de),a		; $730a
	ret			; $730b

; Offsets for the cliff tile that Ricky will be hopping up to

@cliffOffset_oneUp_right:
	.db $f8 $06
@cliffOffset_oneUp_left:
	.db $f8 $fa
@cliffOffset_twoUp_right:
	.db $e8 $06
@cliffOffset_twoUp_left:
	.db $e8 $fa


;;
; @addr{7314}
_rickyBreakTilesOnLanding:
	ld hl,@offsets		; $7314
@next:
	ldi a,(hl)		; $7317
	ld b,a			; $7318
	ldi a,(hl)		; $7319
	ld c,a			; $731a
	or b			; $731b
	ret z			; $731c
	push hl			; $731d
	ld a,(w1Companion.yh)		; $731e
	add b			; $7321
	ld b,a			; $7322
	ld a,(w1Companion.xh)		; $7323
	add c			; $7326
	ld c,a			; $7327
	ld a,BREAKABLETILESOURCE_10		; $7328
	call tryToBreakTile		; $732a
	pop hl			; $732d
	jr @next		; $732e

; Each row is a Y/X offset at which to attempt to break a tile when Ricky lands.
@offsets:
	.db $04 $00
	.db $04 $06
	.db $fe $00
	.db $04 $fa
	.db $00 $00


;;
; Seems to set variables for ricky's jump speed, etc, but the jump may still be cancelled
; after this?
; @addr{733a}
_rickyBeginJumpOverHole:
	ld a,$01		; $733a
	ld (wLinkInAir),a		; $733c

;;
; @addr{733f}
_rickySetJumpSpeed_andcc91:
	ld a,$01		; $733f
	ld (wDisableScreenTransitions),a		; $7341

;;
; Sets up Ricky's speed for long jumps across holes and cliffs.
; @addr{7344}
_rickySetJumpSpeed:
	ld bc,-$300		; $7344
	call objectSetSpeedZ		; $7347
	ld l,SpecialObject.counter1		; $734a
	ld (hl),$08		; $734c
	ld l,SpecialObject.speed		; $734e
	ld (hl),SPEED_140		; $7350
	ld c,$0f		; $7352
	call _companionSetAnimation		; $7354
	ld h,d			; $7357
	ret			; $7358

;;
; @param[out]	zflag	Set if Ricky's close to the screen edge
; @addr{7359}
_rickyCheckAtScreenEdge:
	ld h,d			; $7359
	ld l,SpecialObject.yh		; $735a
	ld a,$06		; $735c
	cp (hl)			; $735e
	jr nc,@outsideScreen	; $735f

	ld a,(wScreenTransitionBoundaryY)		; $7361
	dec a			; $7364
	cp (hl)			; $7365
	jr c,@outsideScreen	; $7366

	ld l,SpecialObject.xh		; $7368
	ld a,$06		; $736a
	cp (hl)			; $736c
	jr nc,@outsideScreen	; $736d

	ld a,(wScreenTransitionBoundaryX)		; $736f
	dec a			; $7372
	cp (hl)			; $7373
	jr c,@outsideScreen	; $7374

	xor a			; $7376
	ret			; $7377

@outsideScreen:
	or d			; $7378
	ret			; $7379

; Offsets relative to Ricky's position to check for holes to jump over
_rickyHoleCheckOffsets:
	.db $f8 $00
	.db $05 $08
	.db $08 $00
	.db $05 $f8


;;
; var38: nonzero if Dimitri is in water?
; @addr{7382}
_specialObjectCode_dimitri:
	call _companionRetIfInactive		; $7382
	call _companionFunc_47d8		; $7385
	call @runState		; $7388
	xor a			; $738b
	ld (wDimitriHitNpc),a		; $738c
	jp _companionCheckEnableTerrainEffects		; $738f

; Note: expects that h=d (call to _companionFunc_47d8 does this)
@runState:
	ld e,SpecialObject.state		; $7392
	ld a,(de)		; $7394
	rst_jumpTable			; $7395
	.dw _dimitriState0
	.dw _dimitriState1
	.dw _dimitriState2
	.dw _dimitriState3
	.dw _dimitriState4
	.dw _dimitriState5
	.dw _dimitriState6
	.dw _dimitriState7
	.dw _dimitriState8
	.dw _dimitriState9
	.dw _dimitriStateA
	.dw _dimitriStateB
	.dw _dimitriStateC
	.dw _dimitriStateD

;;
; State 0: initialization, deciding which state to go to
; @addr{73b2}
_dimitriState0:
	call _companionCheckCanSpawn		; $73b2

	ld a,DIR_DOWN		; $73b5
	ld l,SpecialObject.direction		; $73b7
	ldi (hl),a		; $73b9
	ld (hl),a ; [counter2] = $02

	ld a,(wDimitriState)		; $73bb
	bit 7,a			; $73be
	jr nz,@setAnimation	; $73c0
	bit 6,a			; $73c2
	jr nz,+			; $73c4
	and $20			; $73c6
	jr nz,@setAnimation	; $73c8
+
	ld a,GLOBALFLAG_SAVED_COMPANION_FROM_FOREST		; $73ca
	call checkGlobalFlag		; $73cc
	ld h,d			; $73cf
	ld c,$24		; $73d0
	jr z,+			; $73d2
	ld c,$1e		; $73d4
+
	ld l,SpecialObject.state		; $73d6
	ld (hl),$0a		; $73d8

	ld e,SpecialObject.var3d		; $73da
	call objectAddToAButtonSensitiveObjectList		; $73dc

	ld a,c			; $73df
	ld e,SpecialObject.var3f		; $73e0
	ld (de),a		; $73e2
	call specialObjectSetAnimation		; $73e3

	ld bc,$0408		; $73e6
	call objectSetCollideRadii		; $73e9
	jr @setVisible		; $73ec

@setAnimation:
	ld c,$1c		; $73ee
	call _companionSetAnimation		; $73f0
@setVisible:
	jp objectSetVisible81		; $73f3

;;
; State 1: waiting for Link to mount
; @addr{73f6}
_dimitriState1:
	call _companionSetPriorityRelativeToLink		; $73f6
	ld c,$40		; $73f9
	call objectUpdateSpeedZ_paramC		; $73fb
	ret nz			; $73fe

	; Is dimitri in a hole?
	call _companionCheckHazards		; $73ff
	jr nc,@onLand		; $7402
	cp $02			; $7404
	ret z			; $7406

	; No, he must be in water
	call _dimitriAddWaterfallResistance		; $7407
	ld a,$04		; $740a
	call _dimitriFunc_756d		; $740c
	jr ++			; $740f

@onLand:
	ld e,SpecialObject.var38		; $7411
	ld a,(de)		; $7413
	or a			; $7414
	jr z,++			; $7415
	xor a			; $7417
	ld (de),a		; $7418
	ld c,$1c		; $7419
	call _companionSetAnimation		; $741b
++
	ld a,$06		; $741e
	call objectSetCollideRadius		; $7420

	ld e,SpecialObject.var3b		; $7423
	ld a,(de)		; $7425
	or a			; $7426
	jp nz,_dimitriGotoState1IfLinkFarAway		; $7427

	ld c,$09		; $742a
	call objectCheckLinkWithinDistance		; $742c
	jp nc,_dimitriCheckAddToGrabbableObjectBuffer		; $742f
	jp _companionTryToMount		; $7432

;;
; State 2: curled into a ball (being held or thrown).
;
; The substates are generally controlled by power bracelet code (see "itemCode16").
;
; @addr{7435}
_dimitriState2:
	inc e			; $7435
	ld a,(de)		; $7436
	rst_jumpTable			; $7437
	.dw _dimitriState2Substate0
	.dw _dimitriState2Substate1
	.dw _dimitriState2Substate2
	.dw _dimitriState2Substate3

;;
; Substate 0: just grabbed
; @addr{7440}
_dimitriState2Substate0:
	ld a,$40		; $7440
	ld (wLinkGrabState2),a		; $7442
	call itemIncState2		; $7445
	xor a			; $7448
	ld (wcc90),a		; $7449

	ld l,SpecialObject.var38		; $744c
	ld (hl),a		; $744e
	ld l,$3f		; $744f
	ld (hl),$ff		; $7451

	call objectSetVisiblec0		; $7453

	ld a,$02		; $7456
	ld hl,wCompanionTutorialTextShown		; $7458
	call setFlag		; $745b

	ld c,$18		; $745e
	jp _companionSetAnimation		; $7460

;;
; Substate 1: being lifted, carried
; @addr{7463}
_dimitriState2Substate1:
	xor a			; $7463
	ld (w1Link.knockbackCounter),a		; $7464
	ld a,(wActiveTileType)		; $7467
	cp TILETYPE_NOTHING			; $746a
	jr nz,+			; $746c
	ld a,$20		; $746e
	ld (wStandingOnTileCounter),a		; $7470
+
	ld a,(wLinkClimbingVine)		; $7473
	or a			; $7476
	jr nz,@releaseDimitri	; $7477

	ld a,(w1Link.angle)		; $7479
	bit 7,a			; $747c
	jr nz,@update	; $747e

	ld e,SpecialObject.angle		; $7480
	ld (de),a		; $7482

	ld a,(w1Link.direction)		; $7483
	dec e			; $7486
	ld (de),a ; [direction] = [w1Link.direction]

	call _dimitriCheckCanBeHeldInDirection		; $7488
	jr nz,@update	; $748b

@releaseDimitri:
	ld h,d			; $748d
	ld l,$00		; $748e
	res 1,(hl)		; $7490
	ld l,$3b		; $7492
	ld (hl),$01		; $7494
	jp dropLinkHeldItem		; $7496

@update:
	; Check whether to prevent Link from throwing dimitri (write nonzero to wcc67)
	call _companionCalculateAdjacentWallsBitset		; $7499
	call _specialObjectCheckMovingTowardWall		; $749c
	ret z			; $749f
	ld (wcc67),a		; $74a0
	ret			; $74a3

;;
; Substate 2: dimitri released, falling to ground
; @addr{74a4}
_dimitriState2Substate2:
	ld h,d			; $74a4
	ld l,SpecialObject.enabled		; $74a5
	res 1,(hl)		; $74a7

	call _companionCheckHazards		; $74a9
	jr nc,@noHazard		; $74ac

	; Return if he's on a hole
	cp $02			; $74ae
	ret z			; $74b0
	jr @onHazard		; $74b1

@noHazard:
	ld h,d			; $74b3
	ld l,SpecialObject.var3f		; $74b4
	ld a,(hl)		; $74b6
	cp $ff			; $74b7
	jr nz,++		; $74b9

	; Set Link's current position as the spot to return to if Dimitri lands in water
	xor a			; $74bb
	ld (hl),a		; $74bc
	ld l,SpecialObject.var39		; $74bd
	ld a,(w1Link.yh)		; $74bf
	ldi (hl),a		; $74c2
	ld a,(w1Link.xh)		; $74c3
	ld (hl),a		; $74c6
++

; Check whether Dimitri should stop moving when thrown. Involves screen boundary checks.

	ld a,(wDimitriHitNpc)		; $74c7
	or a			; $74ca
	jr nz,@stopMovement	; $74cb

	call _companionCalculateAdjacentWallsBitset		; $74cd
	call _specialObjectCheckMovingTowardWall		; $74d0
	jr nz,@stopMovement	; $74d3

	ld c,$00		; $74d5
	ld h,d			; $74d7
	ld l,SpecialObject.yh		; $74d8
	ld a,(hl)		; $74da
	cp $08			; $74db
	jr nc,++		; $74dd
	ld (hl),$10		; $74df
	inc c			; $74e1
	jr @checkX		; $74e2
++
	ld a,(wActiveGroup)		; $74e4
	or a			; $74e7
	ld a,(hl)		; $74e8
	jr nz,@largeRoomYCheck	; $74e9
@smallRoomYCheck:
	cp SMALL_ROOM_HEIGHT*16-6
	jr c,@checkX			; $74ed
	ld (hl), SMALL_ROOM_HEIGHT*16-6
	inc c			; $74f1
	jr @checkX			; $74f2
@largeRoomYCheck:
	cp LARGE_ROOM_HEIGHT*16-8
	jr c,@checkX			; $74f6
	ld (hl), LARGE_ROOM_HEIGHT*16-8
	inc c			; $74fa
	jr @checkX			; $74fb

@checkX:
	ld l,SpecialObject.xh		; $74fd
	ld a,(hl)		; $74ff
	cp $04			; $7500
	jr nc,++		; $7502
	ld (hl),$04		; $7504
	inc c			; $7506
	jr @doneBoundsCheck		; $7507
++
	ld a,(wActiveGroup)		; $7509
	or a			; $750c
	ld a,(hl)		; $750d
	jr nz,@largeRoomXCheck	; $750e
@smallRoomXCheck:
	cp SMALL_ROOM_WIDTH*16-5			; $7510
	jr c,@doneBoundsCheck	; $7512
	ld (hl), SMALL_ROOM_WIDTH*16-5		; $7514
	inc c			; $7516
	jr @doneBoundsCheck		; $7517
@largeRoomXCheck:
	cp LARGE_ROOM_WIDTH*16-17			; $7519
	jr c,@doneBoundsCheck	; $751b
	ld (hl), LARGE_ROOM_WIDTH*16-17		; $751d
	inc c			; $751f

@doneBoundsCheck:
	ld a,c			; $7520
	or a			; $7521
	jr z,@checkOnHazard	; $7522

@stopMovement:
	ld a,SPEED_0		; $7524
	ld (w1ReservedItemC.speed),a		; $7526

@checkOnHazard:
	call objectCheckIsOnHazard		; $7529
	cp $01			; $752c
	ret nz			; $752e

@onHazard:
	ld h,d			; $752f
	ld l,SpecialObject.state		; $7530
	ld (hl),$0b		; $7532
	ld l,SpecialObject.var38		; $7534
	ld (hl),$04		; $7536

	; Calculate angle toward Link?
	ld l,SpecialObject.var39		; $7538
	ldi a,(hl)		; $753a
	ld c,(hl)		; $753b
	ld b,a			; $753c
	call objectGetRelativeAngle		; $753d
	and $18			; $7540
	ld e,SpecialObject.angle		; $7542
	ld (de),a		; $7544

	; Calculate direction based on angle
	add a			; $7545
	swap a			; $7546
	and $03			; $7548
	dec e			; $754a
	ld (de),a ; [direction] = a

	ld c,$00		; $754c
	jp _companionSetAnimation		; $754e

;;
; Substate 3: landed on ground for good
; @addr{7551}
_dimitriState2Substate3:
	ld h,d			; $7551
	ld l,SpecialObject.enabled		; $7552
	res 1,(hl)		; $7554

	ld c,$40		; $7556
	call objectUpdateSpeedZ_paramC		; $7558
	ret nz			; $755b
	call _companionTryToBreakTileFromMoving		; $755c
	call _companionCheckHazards		; $755f
	jr nc,@gotoState1	; $7562

	; If on a hole, return (stay in this state?)
	cp $02			; $7564
	ret z			; $7566

	; If in water, go to state 1, but with alternate value for var38?
	ld a,$04		; $7567
	jp _dimitriFunc_756d		; $7569

@gotoState1:
	xor a			; $756c

;;
; @param	a	Value for var38
; @addr{756d}
_dimitriFunc_756d:
	ld h,d			; $756d
	ld l,SpecialObject.var38		; $756e
	ld (hl),a		; $7570

	ld l,SpecialObject.state		; $7571
	ld a,$01		; $7573
	ldi (hl),a		; $7575
	ld (hl),$00 ; [state2] = 0

	ld c,$1c		; $7578
	jp _companionSetAnimation		; $757a

;;
; State 3: Link is jumping up to mount Dimitri
; @addr{757d}
_dimitriState3:
	call _companionCheckMountingComplete		; $757d
	ret nz			; $7580
	call _companionFinalizeMounting		; $7581
	ld c,$00		; $7584
	jp _companionSetAnimation		; $7586

;;
; State 4: Dimitri's falling into a hazard (hole/water)
; @addr{7589}
_dimitriState4:
	call _companionDragToCenterOfHole		; $7589
	ret nz			; $758c
	call _companionDecCounter1		; $758d
	jr nz,@animate		; $7590

	inc (hl)		; $7592
	ld a,SND_LINK_FALL		; $7593
	call playSound		; $7595
	ld a,$25		; $7598
	jp specialObjectSetAnimation		; $759a

@animate:
	call _companionAnimateDrowningOrFallingThenRespawn		; $759d
	ret nc			; $75a0
	ld c,$00		; $75a1
	jp _companionUpdateDirectionAndSetAnimation		; $75a3

;;
; State 5: Link riding dimitri.
; @addr{75a6}
_dimitriState5:
	ld c,$40		; $75a6
	call objectUpdateSpeedZ_paramC		; $75a8
	ret nz			; $75ab

	ld a,(wForceCompanionDismount)		; $75ac
	or a			; $75af
	jr nz,++		; $75b0
	ld a,(wGameKeysJustPressed)		; $75b2
	bit BTN_BIT_A,a			; $75b5
	jr nz,_dimitriGotoEatingState	; $75b7
	bit BTN_BIT_B,a			; $75b9
++
	jp nz,_companionGotoDismountState		; $75bb

	ld a,(wLinkAngle)		; $75be
	bit 7,a			; $75c1
	jr nz,_dimitriUpdateMovement@checkHazards	; $75c3

	; Check if angle changed, update direction if so
	ld hl,w1Companion.angle		; $75c5
	cp (hl)			; $75c8
	ld (hl),a		; $75c9
	ld c,$00		; $75ca
	jp nz,_companionUpdateDirectionAndAnimate		; $75cc

	; Return if he should hop down a cliff (state changed in function call)
	call _companionCheckHopDownCliff		; $75cf
	ret z			; $75d2

;;
; @addr{75d3}
_dimitriUpdateMovement:
	; Play sound effect when animation indicates to do so
	ld h,d			; $75d3
	ld l,SpecialObject.animParameter		; $75d4
	ld a,(hl)		; $75d6
	rlca			; $75d7
	ld a,SND_LINK_SWIM		; $75d8
	call c,playSound		; $75da

	; Determine speed
	ld l,SpecialObject.var38		; $75dd
	ld a,(hl)		; $75df
	or a			; $75e0
	ld a,SPEED_c0		; $75e1
	jr z,+			; $75e3
	ld a,SPEED_100		; $75e5
+
	ld l,SpecialObject.speed		; $75e7
	ld (hl),a		; $75e9
	call _companionUpdateMovement		; $75ea
	call specialObjectAnimate		; $75ed

@checkHazards:
	call _companionCheckHazards		; $75f0
	ld h,d			; $75f3
	jr nc,@setNotInWater	; $75f4

	; Return if the hazard is a hole
	cp $02			; $75f6
	ret z			; $75f8

	; If it's water, stay in state 5 (he can swim).
	ld l,SpecialObject.state		; $75f9
	ld (hl),$05		; $75fb

	ld a,(wLinkForceState)		; $75fd
	cp LINK_STATE_RESPAWNING			; $7600
	jr nz,++		; $7602
	xor a			; $7604
	ld (wLinkForceState),a		; $7605
	jp _companionGotoHazardHandlingState		; $7608
++
	call _dimitriAddWaterfallResistance		; $760b
	ld b,$04		; $760e
	jr @setWaterStatus		; $7610

@setNotInWater:
	ld b,$00		; $7612

@setWaterStatus:
	; Set var38 to value of "b", update animation if it changed
	ld l,SpecialObject.var38		; $7614
	ld a,(hl)		; $7616
	cp b			; $7617
	ld (hl),b		; $7618
	ld c,$00		; $7619
	jp nz,_companionUpdateDirectionAndSetAnimation		; $761b

;;
; @addr{761e}
_dimitriState9:
	ret			; $761e

;;
; @addr{761f}
_dimitriGotoEatingState:
	ld h,d			; $761f
	ld l,SpecialObject.state		; $7620
	ld a,$08		; $7622
	ldi (hl),a		; $7624
	xor a			; $7625
	ldi (hl),a ; [state2] = 0
	ld (hl),a  ; [counter1] = 0

	ld l,SpecialObject.var35		; $7628
	ld (hl),a		; $762a

	; Calculate angle based on direction
	ld l,SpecialObject.direction		; $762b
	ldi a,(hl)		; $762d
	swap a			; $762e
	rrca			; $7630
	ld (hl),a		; $7631

	ld a,$01		; $7632
	ld (wLinkInAir),a		; $7634
	ld l,SpecialObject.speed		; $7637
	ld (hl),SPEED_c0		; $7639
	ld c,$08		; $763b
	call _companionSetAnimation		; $763d
	ldbc ITEMID_DIMITRI_MOUTH, $00		; $7640
	call _companionCreateWeaponItem		; $7643

	ld a,SND_DIMITRI		; $7646
	jp playSound		; $7648

;;
; State 6: Link has dismounted; he can't remount until he moves a certain distance away,
; then comes back.
; @addr{764b}
_dimitriState6:
	ld e,SpecialObject.state2		; $764b
	ld a,(de)		; $764d
	rst_jumpTable			; $764e
	.dw @substate0
	.dw @substate1
	.dw @substate2

@substate0:
	ld a,$01		; $7655
	ld (de),a		; $7657
	call companionDismountAndSavePosition		; $7658
	ld c,$1c		; $765b
	jp _companionSetAnimation		; $765d

@substate1:
	ld a,(wLinkInAir)		; $7660
	or a			; $7663
	ret nz			; $7664
	jp itemIncState2		; $7665

@substate2:
	call _dimitriCheckAddToGrabbableObjectBuffer		; $7668

;;
; @addr{766b}
_dimitriGotoState1IfLinkFarAway:
	; Return if Link is too close
	ld c,$09		; $766b
	call objectCheckLinkWithinDistance		; $766d
	ret c			; $7670

;;
; @param[out]	a	0
; @param[out]	de	var3b
; @addr{7671}
_dimitriGotoState1:
	ld e,SpecialObject.state		; $7671
	ld a,$01		; $7673
	ld (de),a		; $7675
	inc e			; $7676
	xor a			; $7677
	ld (de),a ; [state2] = 0
	ld e,SpecialObject.var3b		; $7679
	ld (de),a		; $767b
	ret			; $767c

;;
; State 7: jumping down a cliff
; @addr{767d}
_dimitriState7:
	call _companionDecCounter1ToJumpDownCliff		; $767d
	ret c			; $7680
	call _companionCalculateAdjacentWallsBitset		; $7681
	call _specialObjectCheckMovingAwayFromWall		; $7684

	ld l,SpecialObject.counter2		; $7687
	jr z,+			; $7689
	ld (hl),a		; $768b
	ret			; $768c
+
	ld a,(hl)		; $768d
	or a			; $768e
	ret z			; $768f
	jp _dimitriLandOnGroundAndGotoState5		; $7690

;;
; State 8: Attempting to eat something
; @addr{7693}
_dimitriState8:
	ld e,SpecialObject.state2		; $7693
	ld a,(de)		; $7695
	rst_jumpTable			; $7696
	.dw @substate0
	.dw @substate1
	.dw @substate2

; Substate 0: Moving forward for the bite
@substate0:
	call specialObjectAnimate		; $769d
	call objectApplySpeed		; $76a0
	ld e,SpecialObject.animParameter		; $76a3
	ld a,(de)		; $76a5
	rlca			; $76a6
	ret nc			; $76a7

	; Initialize stuff for substate 1 (moving back)

	call itemIncState2		; $76a8

	; Calculate angle based on the reverse of the current direction
	ld l,SpecialObject.direction		; $76ab
	ldi a,(hl)		; $76ad
	xor $02			; $76ae
	swap a			; $76b0
	rrca			; $76b2
	ld (hl),a		; $76b3

	ld l,SpecialObject.counter1		; $76b4
	ld (hl),$0c		; $76b6
	ld c,$00		; $76b8
	jp _companionSetAnimation		; $76ba

; Substate 1: moving back
@substate1:
	call specialObjectAnimate		; $76bd
	call objectApplySpeed		; $76c0
	call _companionDecCounter1IfNonzero		; $76c3
	ret nz			; $76c6

	; Done moving back

	ld (hl),$14		; $76c7

	; Fix angle to be consistent with direction
	ld l,SpecialObject.direction		; $76c9
	ldi a,(hl)		; $76cb
	swap a			; $76cc
	rrca			; $76ce
	ld (hl),a		; $76cf

	; Check if he swallowed something; if so, go to substate 2, otherwise resume
	; normal movement.
	ld l,SpecialObject.var35		; $76d0
	ld a,(hl)		; $76d2
	or a			; $76d3
	jp z,_dimitriLandOnGroundAndGotoState5		; $76d4
	call itemIncState2		; $76d7
	ld c,$10		; $76da
	jp _companionSetAnimation		; $76dc

; Substate 2: swallowing something
@substate2:
	call specialObjectAnimate		; $76df
	call _companionDecCounter1IfNonzero		; $76e2
	ret nz			; $76e5
	jr _dimitriLandOnGroundAndGotoState5		; $76e6

;;
; State B: swimming back to land after being thrown into water
; @addr{76e8}
_dimitriStateB:
	ld c,$40		; $76e8
	call objectUpdateSpeedZ_paramC		; $76ea
	ret nz			; $76ed

	call _dimitriUpdateMovement		; $76ee

	; Set state to $01 if he's out of the water; stay in $0b otherwise
	ld h,d			; $76f1
	ld l,SpecialObject.var38		; $76f2
	ld a,(hl)		; $76f4
	or a			; $76f5
	ld l,SpecialObject.state		; $76f6
	ld (hl),$0b		; $76f8
	ret nz			; $76fa
	ld (hl),$01		; $76fb
	ret			; $76fd

;;
; State C: Dimitri entering screen from flute call
; @addr{76fe}
_dimitriStateC:
	ld e,SpecialObject.var03		; $76fe
	ld a,(de)		; $7700
	rst_jumpTable			; $7701
	.dw @parameter0
	.dw @parameter1

; substate 0: dimitri just spawned?
@parameter0:
	call _companionInitializeOnEnteringScreen		; $7706
	ld (hl),$3c ; [counter2] = $3c

	ld a,SND_DIMITRI		; $770b
	call playSound		; $770d
	ld c,$00		; $7710
	jp _companionSetAnimation		; $7712

; substate 1: walking in
@parameter1:
	call _dimitriUpdateMovement		; $7715
	ld e,SpecialObject.state		; $7718
	ld a,$0c		; $771a
	ld (de),a		; $771c

	ld hl,_dimitriTileOffsets		; $771d
	call _companionRetIfNotFinishedWalkingIn		; $7720

	; Done walking into screen; jump to state 0
	ld e,SpecialObject.var03		; $7723
	xor a			; $7725
	ld (de),a		; $7726
	jp _dimitriState0		; $7727

;;
; State D: ? (set to this by INTERACID_CARPENTER subid $ff?)
; @addr{772a}
_dimitriStateD:
	ld e,SpecialObject.var3c		; $772a
	ld a,(de)		; $772c
	or a			; $772d
	jr nz,++		; $772e

	call _dimitriGotoState1		; $7730
	inc a			; $7733
	ld (de),a ; [var3b] = 1

	ld hl,w1Companion.enabled		; $7735
	res 1,(hl)		; $7738
	ld c,$1c		; $773a
	jp _companionSetAnimation		; $773c
++
	ld e,SpecialObject.state		; $773f
	ld a,$05		; $7741
	ld (de),a		; $7743

;;
; @addr{7744}
_dimitriLandOnGroundAndGotoState5:
	xor a			; $7744
	ld (wLinkInAir),a		; $7745
	ld c,$00		; $7748
	jp _companionSetAnimationAndGotoState5		; $774a

;;
; State A: cutscene-related stuff
; @addr{774d}
_dimitriStateA:
	ld e,SpecialObject.var03		; $774d
	ld a,(de)		; $774f
	rst_jumpTable			; $7750
	.dw _dimitriStateASubstate0
	.dw _dimitriStateASubstate1
	.dw _dimitriStateASubstate2
	.dw _dimitriStateASubstate3
	.dw _dimitriStateASubstate4

;;
; Force mounting Dimitri?
; @addr{775b}
_dimitriStateASubstate0:
	ld e,SpecialObject.var3d		; $775b
	ld a,(de)		; $775d
	or a			; $775e
	jr z,+			; $775f
	ld a,$81		; $7761
	ld (wDisabledObjects),a		; $7763
+
	call _companionSetAnimationToVar3f		; $7766
	call _companionPreventLinkFromPassing_noExtraChecks		; $7769
	call specialObjectAnimate		; $776c

	ld e,SpecialObject.visible		; $776f
	ld a,$c7		; $7771
	ld (de),a		; $7773

	ld a,(wDimitriState)		; $7774
	and $80			; $7777
	ret z			; $7779

	ld e,SpecialObject.visible		; $777a
	ld a,$c1		; $777c
	ld (de),a		; $777e

	ld a,$ff		; $777f
	ld (wStatusBarNeedsRefresh),a		; $7781
	ld c,$1c		; $7784
	call _companionSetAnimation		; $7786
	jp _companionForceMount		; $7789

;;
; Force mounting dimitri?
; @addr{778c}
_dimitriStateASubstate1:
	ld e,SpecialObject.var3d		; $778c
	call objectRemoveFromAButtonSensitiveObjectList		; $778e
	ld c,$1c		; $7791
	call _companionSetAnimation		; $7793
	jp _companionForceMount		; $7796

;;
; Dimitri begins parting upon reaching mainland?
; @addr{7799}
_dimitriStateASubstate3:
	ld e,SpecialObject.direction		; $7799
	ld a,DIR_RIGHT		; $779b
	ld (de),a		; $779d
	inc e			; $779e
	ld a,$08		; $779f
	ld (de),a ; [angle] = $08

	ld c,$00		; $77a2
	call _companionSetAnimation		; $77a4
	ld e,SpecialObject.var03		; $77a7
	ld a,$04		; $77a9
	ld (de),a		; $77ab

	ld a,SND_DIMITRI		; $77ac
	jp playSound		; $77ae

;;
; Dimitri moving until he goes off-screen
; @addr{77b1}
_dimitriStateASubstate4:
	call _dimitriUpdateMovement		; $77b1

	ld e,SpecialObject.state		; $77b4
	ld a,$0a		; $77b6
	ld (de),a		; $77b8

	call objectCheckWithinScreenBoundary		; $77b9
	ret c			; $77bc

	xor a			; $77bd
	ld (wDisabledObjects),a		; $77be
	ld (wMenuDisabled),a		; $77c1
	ld (wUseSimulatedInput),a		; $77c4
	jp itemDelete		; $77c7

;;
; Force dismount Dimitri
; @addr{77ca}
_dimitriStateASubstate2:
	ld a,(wLinkObjectIndex)		; $77ca
	cp >w1Companion			; $77cd
	ret nz			; $77cf
	call companionDismountAndSavePosition		; $77d0
	xor a			; $77d3
	ld (wRememberedCompanionId),a		; $77d4
	ret			; $77d7


;;
; @addr{77d8}
_dimitriCheckAddToGrabbableObjectBuffer:
	ld a,(wLinkClimbingVine)		; $77d8
	or a			; $77db
	ret nz			; $77dc
	ld a,(w1Link.direction)		; $77dd
	call _dimitriCheckCanBeHeldInDirection		; $77e0
	ret z			; $77e3

	; Check the collisions at Link's position
	ld hl,w1Link.yh		; $77e4
	ld b,(hl)		; $77e7
	ld l,<w1Link.xh		; $77e8
	ld c,(hl)		; $77ea
	call getTileCollisionsAtPosition		; $77eb

	; Disallow cave entrances (top half solid)?
	cp $0c			; $77ee
	jr z,@ret	; $77f0

	; Disallow if Link's on a fully solid tile?
	cp $0f			; $77f2
	jr z,@ret	; $77f4

	cp SPECIALCOLLISION_VERTICAL_BRIDGE			; $77f6
	jr z,@ret	; $77f8
	cp SPECIALCOLLISION_HORIZONTAL_BRIDGE			; $77fa
	call nz,objectAddToGrabbableObjectBuffer		; $77fc
@ret:
	ret			; $77ff

;;
; Checks the tiles in front of Dimitri to see if he can be held?
; (if moving diagonally, it checks both directions, and fails if one is impassable).
;
; This seems to disallow holding him on small bridges and cave entrances.
;
; @param	a	Direction that Link/Dimitri's moving toward
; @param[out]	zflag	Set if one of the tiles in front are not passable.
; @addr{7800}
_dimitriCheckCanBeHeldInDirection:
	call @checkTile		; $7800
	ret z			; $7803

	ld hl,w1Link.angle		; $7804
	ldd a,(hl)		; $7807
	bit 7,a			; $7808
	ret nz			; $780a
	bit 2,a			; $780b
	jr nz,@diagonalMovement			; $780d

	or d			; $780f
	ret			; $7810

@diagonalMovement:
	; Calculate the other direction being moved in
	add a			; $7811
	ld b,a			; $7812
	ldi a,(hl) ; a = [direction]
	swap a			; $7814
	srl a			; $7816
	xor b			; $7818
	add a			; $7819
	swap a			; $781a
	and $03			; $781c

;;
; @param	a	Direction
; @param[out]	zflag	Set if the tile in that direction is not ok for holding dimitri?
; @addr{781e}
@checkTile:
	ld hl,_dimitriTileOffsets		; $781e
	rst_addDoubleIndex			; $7821
	ldi a,(hl)		; $7822
	ld c,(hl)		; $7823
	ld b,a			; $7824
	call objectGetRelativeTile		; $7825

	cp TILEINDEX_VINE_BOTTOM			; $7828
	ret z			; $782a
	cp TILEINDEX_VINE_MIDDLE			; $782b
	ret z			; $782d
	cp TILEINDEX_VINE_TOP			; $782e
	ret z			; $7830

	; Only disallow tiles where the top half is solid? (cave entrances?
	ld h,>wRoomCollisions		; $7831
	ld a,(hl)		; $7833
	cp $0c			; $7834
	ret z			; $7836

	cp SPECIALCOLLISION_VERTICAL_BRIDGE			; $7837
	ret z			; $7839
	cp SPECIALCOLLISION_HORIZONTAL_BRIDGE			; $783a
	ret			; $783c

;;
; Moves Dimitri down if he's on a waterfall
; @addr{783d}
_dimitriAddWaterfallResistance:
	call objectGetTileAtPosition		; $783d
	ld h,d			; $7840
	cp TILEINDEX_WATERFALL			; $7841
	jr z,+			; $7843
	cp TILEINDEX_WATERFALL_BOTTOM			; $7845
	ret nz			; $7847
+
	; Move y-position down the waterfall (acts as resistance)
	ld l,SpecialObject.y		; $7848
	ld a,(hl)		; $784a
	add $c0			; $784b
	ldi (hl),a		; $784d
	ld a,(hl)		; $784e
	adc $00			; $784f
	ld (hl),a		; $7851

	; Check if we should start a screen transition based on downward waterfall
	; movement
	ld a,(wScreenTransitionBoundaryY)		; $7852
	cp (hl)			; $7855
	ret nc			; $7856
	ld a,$82		; $7857
	ld (wScreenTransitionDirection),a		; $7859
	ret			; $785c

_dimitriTileOffsets:
	.db $f8 $00 ; DIR_UP
	.db $00 $08 ; DIR_RIGHT
	.db $08 $00 ; DIR_DOWN
	.db $00 $f8 ; DIR_LEFT

;;
; @addr{7865}
_specialObjectCode_moosh:
	call _companionRetIfInactive		; $7865
	call _companionFunc_47d8		; $7868
	call @runState		; $786b
	jp _companionCheckEnableTerrainEffects		; $786e

@runState:
	ld e,SpecialObject.state		; $7871
	ld a,(de)		; $7873
	rst_jumpTable			; $7874
	.dw _mooshState0
	.dw _mooshState1
	.dw _mooshState2
	.dw _mooshState3
	.dw _mooshState4
	.dw _mooshState5
	.dw _mooshState6
	.dw _mooshState7
	.dw _mooshState8
	.dw _mooshState9
	.dw _mooshStateA
	.dw _mooshStateB
	.dw _mooshStateC

;;
; State 0: initialization
; @addr{788f}
_mooshState0:
	call _companionCheckCanSpawn		; $788f
	ld a,$06		; $7892
	call objectSetCollideRadius		; $7894

	ld a,DIR_DOWN		; $7897
	ld l,SpecialObject.direction		; $7899
	ldi (hl),a		; $789b
	ldi (hl),a ; [angle] = $02

	ld hl,wMooshState		; $789d
	ld a,$80		; $78a0
	and (hl)		; $78a2
	jr nz,@setAnimation	; $78a3

	; Check for the screen with the bridge near the forest?
	ld a,(wActiveRoom)		; $78a5
	cp $54			; $78a8
	jr z,@gotoCutsceneStateA	; $78aa

	ld a,$20		; $78ac
	and (hl)		; $78ae
	jr z,@gotoCutsceneStateA	; $78af
	ld a,$40		; $78b1
	and (hl)		; $78b3
	jr nz,@gotoCutsceneStateA	; $78b4

	; Check for the room where Moosh leaves after obtaining cheval's rope
	ld a,TREASURE_CHEVAL_ROPE		; $78b6
	call checkTreasureObtained		; $78b8
	jr nc,@setAnimation	; $78bb
	ld a,(wActiveRoom)		; $78bd
	cp $6b			; $78c0
	jr nz,@setAnimation	; $78c2

@gotoCutsceneStateA:
	ld e,SpecialObject.state		; $78c4
	ld a,$0a		; $78c6
	ld (de),a		; $78c8
	jp _mooshStateA		; $78c9

@setAnimation:
	ld c,$01		; $78cc
	call _companionSetAnimation		; $78ce
	jp objectSetVisiblec1		; $78d1

;;
; State 1: waiting for Link to mount
; @addr{78d4}
_mooshState1:
	call _companionSetPriorityRelativeToLink		; $78d4
	call specialObjectAnimate		; $78d7

	ld c,$09		; $78da
	call objectCheckLinkWithinDistance		; $78dc
	jp c,_companionTryToMount		; $78df

;;
; @addr{78e2}
_mooshCheckHazards:
	call _companionCheckHazards		; $78e2
	ret nc			; $78e5
	jr _mooshSetVar37ForHazard		; $78e6

;;
; State 3: Link is currently jumping up to mount Moosh
; @addr{78e8}
_mooshState3:
	call _companionCheckMountingComplete		; $78e8
	ret nz			; $78eb
	call _companionFinalizeMounting		; $78ec
	ld c,$13		; $78ef
	jp _companionSetAnimation		; $78f1

;;
; State 4: Moosh falling into a hazard (hole/water)
; @addr{78f4}
_mooshState4:
	ld h,d			; $78f4
	ld l,SpecialObject.collisionType		; $78f5
	set 7,(hl)		; $78f7

	; Check if the hazard is water
	ld l,SpecialObject.var37		; $78f9
	ld a,(hl)		; $78fb
	cp $0d
	jr z,++			; $78fe

	; No, it's a hole
	ld a,$0e		; $7900
	ld (hl),a		; $7902
	call _companionDragToCenterOfHole		; $7903
	ret nz			; $7906
++
	call _companionDecCounter1		; $7907
	jr nz,@animate	; $790a

	; Set falling/drowning animation, play falling sound if appropriate
	dec (hl)		; $790c
	ld l,SpecialObject.var37		; $790d
	ld a,(hl)		; $790f
	call specialObjectSetAnimation		; $7910

	ld e,SpecialObject.var37		; $7913
	ld a,(de)		; $7915
	cp $0d ; Is this water?
	jr z,@animate	; $7918

	ld a,SND_LINK_FALL		; $791a
	jp playSound		; $791c

@animate:
	call _companionAnimateDrowningOrFallingThenRespawn		; $791f
	ret nc			; $7922
	ld c,$13		; $7923
	ld a,(wLinkObjectIndex)		; $7925
	rrca			; $7928
	jr c,+			; $7929
	ld c,$01		; $792b
+
	jp _companionUpdateDirectionAndSetAnimation		; $792d

;;
; @addr{7930}
_mooshTryToBreakTileFromMovingAndCheckHazards:
	call _companionTryToBreakTileFromMoving		; $7930
	call _companionCheckHazards		; $7933
	ld c,$13		; $7936
	jp nc,_companionUpdateDirectionAndAnimate		; $7938

;;
; @addr{793b}
_mooshSetVar37ForHazard:
	dec a			; $793b
	ld c,$0d		; $793c
	jr z,+			; $793e
	ld c,$0e		; $7940
+
	ld e,SpecialObject.var37		; $7942
	ld a,c			; $7944
	ld (de),a		; $7945
	ld e,SpecialObject.counter1		; $7946
	xor a			; $7948
	ld (de),a		; $7949
	ret			; $794a

;;
; State 5: Link riding Moosh.
; @addr{794b}
_mooshState5:
	ld c,$10		; $794b
	call objectUpdateSpeedZ_paramC		; $794d
	ret nz			; $7950

	call _companionCheckHazards		; $7951
	jr c,_mooshSetVar37ForHazard	; $7954

	ld a,(wForceCompanionDismount)		; $7956
	or a			; $7959
	jr nz,++		; $795a
	ld a,(wGameKeysJustPressed)		; $795c
	bit BTN_BIT_A,a			; $795f
	jr nz,_mooshPressedAButton	; $7961
	bit BTN_BIT_B,a			; $7963
++
	jp nz,_companionGotoDismountState		; $7965

	; Return if not attempting to move
	ld a,(wLinkAngle)		; $7968
	bit 7,a			; $796b
	ret nz			; $796d

	; Update angle, and animation if the angle changed
	ld hl,w1Companion.angle		; $796e
	cp (hl)			; $7971
	ld (hl),a		; $7972
	ld c,$13		; $7973
	jp nz,_companionUpdateDirectionAndAnimate		; $7975

	call _companionCheckHopDownCliff		; $7978
	ret z			; $797b

	ld e,SpecialObject.speed		; $797c
	ld a,SPEED_100		; $797e
	ld (de),a		; $7980
	call _companionUpdateMovement		; $7981

	jr _mooshTryToBreakTileFromMovingAndCheckHazards		; $7984

;;
; @addr{7986}
_mooshLandOnGroundAndGotoState5:
	xor a			; $7986
	ld (wLinkInAir),a		; $7987
	ld c,$13		; $798a
	jp _companionSetAnimationAndGotoState5		; $798c

;;
; @addr{798f}
_mooshPressedAButton:
	ld a,$08		; $798f
	ld e,SpecialObject.state		; $7991
	ld (de),a		; $7993
	inc e			; $7994
	xor a			; $7995
	ld (de),a		; $7996
	ld a,SND_JUMP		; $7997
	call playSound		; $7999

;;
; @addr{799c}
_mooshState2:
_mooshState9:
_mooshStateB:
	ret			; $799c

;;
; State 8: floating in air, possibly performing buttstomp
; @addr{799d}
_mooshState8:
	ld e,SpecialObject.state2		; $799d
	ld a,(de)		; $799f
	rst_jumpTable			; $79a0
	.dw _mooshState8Substate0
	.dw _mooshState8Substate1
	.dw _mooshState8Substate2
	.dw _mooshState8Substate3
	.dw _mooshState8Substate4
	.dw _mooshState8Substate5

;;
; Substate 0: just pressed A button
; @addr{79ad}
_mooshState8Substate0:
	ld a,$01		; $79ad
	ld (de),a ; [state2] = 1

	ld bc,-$140		; $79b0
	call objectSetSpeedZ		; $79b3
	ld l,SpecialObject.speed		; $79b6
	ld (hl),SPEED_100		; $79b8

	ld l,SpecialObject.var39		; $79ba
	ld a,$04		; $79bc
	ldi (hl),a		; $79be
	xor a			; $79bf
	ldi (hl),a ; [var3a] = 0
	ldi (hl),a ; [var3b] = 0

	ld c,$09		; $79c2
	jp _companionSetAnimation		; $79c4

;;
; Substate 1: floating in air
; @addr{79c7}
_mooshState8Substate1:
	; Check if over water
	call objectCheckIsOverHazard		; $79c7
	cp $01			; $79ca
	jr nz,@notOverWater	; $79cc

; He's over water; go to substate 5.

	ld bc,$0000		; $79ce
	call objectSetSpeedZ		; $79d1

	ld l,SpecialObject.state2		; $79d4
	ld (hl),$05		; $79d6

	ld b,INTERACID_EXCLAMATION_MARK		; $79d8
	call objectCreateInteractionWithSubid00		; $79da

	; Subtract new interaction's zh by $20 (should be above moosh)
	dec l			; $79dd
	ld a,(hl)		; $79de
	sub $20			; $79df
	ld (hl),a		; $79e1

	ld l,Interaction.counter1		; $79e2
	ld e,SpecialObject.counter1		; $79e4
	ld a,$3c		; $79e6
	ld (hl),a ; [Interaction.counter1] = $3c
	ld (de),a ; [Moosh.counter1] = $3c
	ret			; $79ea

@notOverWater:
	ld a,(wLinkAngle)		; $79eb
	bit 7,a			; $79ee
	jr nz,+			; $79f0
	ld hl,w1Companion.angle		; $79f2
	cp (hl)			; $79f5
	ld (hl),a		; $79f6
	call _companionUpdateMovement		; $79f7
+
	ld e,SpecialObject.speedZ+1		; $79fa
	ld a,(de)		; $79fc
	rlca			; $79fd
	jr c,@movingUp	; $79fe

; Moosh is moving down (speedZ is positive or 0).

	; Increment var3b once for every frame A is held (or set to 0 if A is released).
	ld e,SpecialObject.var3b		; $7a00
	ld a,(wGameKeysPressed)		; $7a02
	and BTN_A			; $7a05
	jr z,+			; $7a07
	ld a,(de)		; $7a09
	inc a			; $7a0a
+
	ld (de),a		; $7a0b

	; Start charging stomp after A is held for 10 frames
	cp $0a			; $7a0c
	jr nc,@gotoSubstate2	; $7a0e

	; If pressed A, flutter in the air.
	ld a,(wGameKeysJustPressed)		; $7a10
	bit BTN_BIT_A,a			; $7a13
	jr z,@label_05_444	; $7a15

	; Don't allow him to flutter more than 16 times.
	ld e,SpecialObject.var3a		; $7a17
	ld a,(de)		; $7a19
	cp $10			; $7a1a
	jr z,@label_05_444	; $7a1c

	; [var3a] += 1 (counter for number of times he's fluttered)
	inc a			; $7a1e
	ld (de),a		; $7a1f

	; [var39] += 8 (ignore gravity for 8 more frames)
	dec e			; $7a20
	ld a,(de)		; $7a21
	add $08			; $7a22
	ld (de),a		; $7a24

	ld e,SpecialObject.animCounter		; $7a25
	ld a,$01		; $7a27
	ld (de),a		; $7a29
	call specialObjectAnimate		; $7a2a
	ld a,SND_JUMP		; $7a2d
	call playSound		; $7a2f

@label_05_444:
	ld e,SpecialObject.var39		; $7a32
	ld a,(de)		; $7a34
	or a			; $7a35
	jr z,@updateMovement	; $7a36

	; [var39] -= 1
	dec a			; $7a38
	ld (de),a		; $7a39

	ld e,SpecialObject.animCounter		; $7a3a
	ld a,$0f		; $7a3c
	ld (de),a		; $7a3e
	ld c,$09		; $7a3f
	jp _companionUpdateDirectionAndAnimate		; $7a41

@movingUp:
	ld c,$09		; $7a44
	call _companionUpdateDirectionAndAnimate		; $7a46

@updateMovement:
	ld c,$10		; $7a49
	call objectUpdateSpeedZ_paramC		; $7a4b
	ret nz			; $7a4e
	call _companionTryToBreakTileFromMoving		; $7a4f
	call _mooshLandOnGroundAndGotoState5		; $7a52
	jp _mooshTryToBreakTileFromMovingAndCheckHazards		; $7a55

@gotoSubstate2:
	jp itemIncState2		; $7a58

;;
; Substate 2: charging buttstomp
; @addr{7a5b}
_mooshState8Substate2:
	call specialObjectAnimate		; $7a5b

	ld a,(wGameKeysPressed)		; $7a5e
	bit BTN_BIT_A,a			; $7a61
	jr z,@gotoNextSubstate	; $7a63

	ld e,SpecialObject.var3b		; $7a65
	ld a,(de)		; $7a67
	cp 40			; $7a68
	jr c,+			; $7a6a
	ld c,$02		; $7a6c
	call _companionFlashFromChargingAnimation		; $7a6e
+
	ld e,SpecialObject.var3b		; $7a71
	ld a,(de)		; $7a73
	inc a			; $7a74
	ld (de),a		; $7a75

	; Check if it's finished charging
	cp 40			; $7a76
	ret c			; $7a78
	ld a,SND_CHARGE_SWORD		; $7a79
	jp z,playSound		; $7a7b

	; Reset bit 7 on w1Link.collisionType and w1Companion.collisionType (disable
	; collisions?)
	ld hl,w1Link.collisionType		; $7a7e
	res 7,(hl)		; $7a81
	inc h			; $7a83
	res 7,(hl)		; $7a84

	; Force the buttstomp to release after 120 frames of charging
	ld e,SpecialObject.var3b		; $7a86
	ld a,(de)		; $7a88
	cp 120			; $7a89
	ret nz			; $7a8b

@gotoNextSubstate:
	ld hl,w1Link.oamFlagsBackup		; $7a8c
	ldi a,(hl)		; $7a8f
	ld (hl),a ; [w1Link.oamFlags] = [w1Link.oamFlagsBackup]

	call itemIncState2		; $7a91
	ld c,$17		; $7a94

	; Set buttstomp animation if he's charged up enough
	ld e,SpecialObject.var3b		; $7a96
	ld a,(de)		; $7a98
	cp 40			; $7a99
	ret c			; $7a9b
	jp _companionSetAnimation		; $7a9c

;;
; Substate 3: falling to ground with buttstomp attack (or cancelling buttstomp)
; @addr{7a9f}
_mooshState8Substate3:
	ld c,$80		; $7a9f
	call objectUpdateSpeedZ_paramC		; $7aa1
	ret nz			; $7aa4

; Reached the ground

	ld e,SpecialObject.var3b		; $7aa5
	ld a,(de)		; $7aa7
	cp 40			; $7aa8
	jr nc,+			; $7aaa

	; Buttstomp not charged; just land on the ground
	call _mooshLandOnGroundAndGotoState5		; $7aac
	jp _mooshTryToBreakTileFromMovingAndCheckHazards		; $7aaf
+
	; Buttstomp charged; unleash the attack
	call _companionCheckHazards		; $7ab2
	jp c,_mooshSetVar37ForHazard		; $7ab5

	call itemIncState2		; $7ab8

	ld a,$0f		; $7abb
	ld (wScreenShakeCounterY),a		; $7abd

	ld a,SNDCTRL_STOPSFX		; $7ac0
	call playSound		; $7ac2
	ld a,SND_SCENT_SEED		; $7ac5
	call playSound		; $7ac7

	ld a,$05		; $7aca
	ld hl,wCompanionTutorialTextShown		; $7acc
	call setFlag		; $7acf

	ldbc ITEMID_28, $00		; $7ad2
	jp _companionCreateWeaponItem		; $7ad5

;;
; Substate 4: sitting on the ground briefly after buttstomp attack
; @addr{7ad8}
_mooshState8Substate4:
	call specialObjectAnimate		; $7ad8
	ld e,SpecialObject.animParameter		; $7adb
	ld a,(de)		; $7add
	rlca			; $7ade
	ret nc			; $7adf

	; Set bit 7 on w1Link.collisionType and w1Companion.collisionType (enable
	; collisions?)
	ld hl,w1Link.collisionType		; $7ae0
	set 7,(hl)		; $7ae3
	inc h			; $7ae5
	set 7,(hl)		; $7ae6

	jp _mooshLandOnGroundAndGotoState5		; $7ae8

;;
; Substate 5: Moosh is over water, in the process of falling down.
; @addr{7aeb}
_mooshState8Substate5:
	call _companionDecCounter1IfNonzero		; $7aeb
	jr z,+			; $7aee
	jp specialObjectAnimate		; $7af0
+
	ld c,$10		; $7af3
	call objectUpdateSpeedZ_paramC		; $7af5
	ret nz			; $7af8
	call _mooshLandOnGroundAndGotoState5		; $7af9
	jp _mooshTryToBreakTileFromMovingAndCheckHazards		; $7afc

;;
; State 6: Link has dismounted; he can't remount until he moves a certain distance away,
; then comes back.
; @addr{7aff}
_mooshState6:
	ld e,SpecialObject.state2		; $7aff
	ld a,(de)		; $7b01
	rst_jumpTable			; $7b02
	.dw @substate0
	.dw @substate1
	.dw @substate2

@substate0:
	ld a,$01		; $7b09
	ld (de),a		; $7b0b
	call companionDismountAndSavePosition		; $7b0c
	ld c,$01		; $7b0f
	jp _companionSetAnimation		; $7b11

@substate1:
	ld a,(wLinkInAir)		; $7b14
	or a			; $7b17
	ret nz			; $7b18
	jp itemIncState2		; $7b19

@substate2:
	ld c,$09		; $7b1c
	call objectCheckLinkWithinDistance		; $7b1e
	jp c,_mooshCheckHazards		; $7b21

	ld e,SpecialObject.state2		; $7b24
	xor a			; $7b26
	ld (de),a		; $7b27
	dec e			; $7b28
	ld a,$01		; $7b29
	ld (de),a ; [state] = $01 (waiting for Link to mount)
	ret			; $7b2c

;;
; State 7: jumping down a cliff
; @addr{7b2d}
_mooshState7:
	call _companionDecCounter1ToJumpDownCliff		; $7b2d
	jr nc,+		; $7b30
	ret nz			; $7b32
	ld c,$09		; $7b33
	jp _companionSetAnimation		; $7b35
+
	call _companionCalculateAdjacentWallsBitset		; $7b38
	call _specialObjectCheckMovingAwayFromWall		; $7b3b
	ld e,$07		; $7b3e
	jr z,+			; $7b40
	ld (de),a		; $7b42
	ret			; $7b43
+
	ld a,(de)		; $7b44
	or a			; $7b45
	ret z			; $7b46
	jp _mooshLandOnGroundAndGotoState5		; $7b47

;;
; State C: Moosh entering from a flute call
; @addr{7b4a}
_mooshStateC:
	ld e,SpecialObject.var03		; $7b4a
	ld a,(de)		; $7b4c
	rst_jumpTable			; $7b4d
	.dw @substate0
	.dw @substate1

@substate0:
	call _companionInitializeOnEnteringScreen		; $7b52
	ld (hl),$3c ; [counter2] = $3c
	ld a,SND_MOOSH		; $7b57
	call playSound		; $7b59
	ld c,$0f		; $7b5c
	jp _companionSetAnimation		; $7b5e

@substate1:
	call specialObjectAnimate		; $7b61

	ld e,SpecialObject.speed		; $7b64
	ld a,SPEED_c0		; $7b66
	ld (de),a		; $7b68

	call _companionUpdateMovement		; $7b69
	ld hl,@mooshDirectionOffsets		; $7b6c
	call _companionRetIfNotFinishedWalkingIn		; $7b6f
	ld e,SpecialObject.var03		; $7b72
	xor a			; $7b74
	ld (de),a		; $7b75
	jp _mooshState0		; $7b76

@mooshDirectionOffsets:
	.db $f8 $00 ; DIR_UP
	.db $00 $08 ; DIR_RIGHT
	.db $08 $00 ; DIR_DOWN
	.db $00 $f8 ; DIR_LEFT


;;
; State A: cutscene stuff
; @addr{7b81}
_mooshStateA:
	ld e,SpecialObject.var03		; $7b81
	ld a,(de)		; $7b83
	rst_jumpTable			; $7b84
	.dw @mooshStateASubstate0
	.dw _mooshStateASubstate1
	.dw @mooshStateASubstate2
	.dw _mooshStateASubstate3
	.dw _mooshStateASubstate4
	.dw _mooshStateASubstate5
	.dw _mooshStateASubstate6

;;
; @addr{7b93}
@mooshStateASubstate0:
	ld a,$01 ; [var03] = $01
	ld (de),a		; $7b95

	ld hl,wMooshState		; $7b96
	ld a,$20		; $7b99
	and (hl)		; $7b9b
	jr z,@label_05_454	; $7b9c

	ld a,$40		; $7b9e
	and (hl)		; $7ba0
	jr z,@label_05_456	; $7ba1

;;
; @addr{7ba3}
@mooshStateASubstate2:
	ld a,$01		; $7ba3
	ld (de),a ; [var03] = $01

	ld e,SpecialObject.var3d		; $7ba6
	call objectAddToAButtonSensitiveObjectList		; $7ba8

@label_05_454:
	ld a,GLOBALFLAG_SAVED_COMPANION_FROM_FOREST		; $7bab
	call checkGlobalFlag		; $7bad
	ld a,$00		; $7bb0
	jr z,+			; $7bb2
	ld a,$03		; $7bb4
+
	ld e,SpecialObject.var3f		; $7bb6
	ld (de),a		; $7bb8
	call specialObjectSetAnimation		; $7bb9
	jp objectSetVisiblec3		; $7bbc

@label_05_456:
	ld a,$01		; $7bbf
	ld (wMenuDisabled),a		; $7bc1
	ld (wDisabledObjects),a		; $7bc4

	ld a,$04		; $7bc7
	ld (de),a ; [var03] = $04

	ld a,$01		; $7bca
	call specialObjectSetAnimation		; $7bcc
	jp objectSetVisiblec3		; $7bcf

;;
; @addr{7bd2}
_mooshStateASubstate1:
	ld e,SpecialObject.var3d		; $7bd2
	ld a,(de)		; $7bd4
	or a			; $7bd5
	jr z,+			; $7bd6
	ld a,$01		; $7bd8
	ld (wDisabledObjects),a		; $7bda
	ld (wMenuDisabled),a		; $7bdd
+
	call _companionSetAnimationToVar3f		; $7be0
	call _mooshUpdateAsNpc		; $7be3
	ld a,(wMooshState)		; $7be6
	and $80			; $7be9
	ret z			; $7beb
	jr _label_05_458		; $7bec

;;
; @addr{7bee}
_mooshStateASubstate3:
	call _companionSetAnimationToVar3f		; $7bee
	call _mooshUpdateAsNpc		; $7bf1
	ld a,(wMooshState)		; $7bf4
	and $20			; $7bf7
	ret z			; $7bf9
	ld a,$ff		; $7bfa
	ld (wStatusBarNeedsRefresh),a		; $7bfc

_label_05_458:
	ld e,SpecialObject.var3d	; $7bff
	xor a			; $7c01
	ld (de),a		; $7c02
	call objectRemoveFromAButtonSensitiveObjectList		; $7c03

	ld c,$01		; $7c06
	call _companionSetAnimation		; $7c08
	jp _companionForceMount		; $7c0b

;;
; @addr{7c0e}
_mooshStateASubstate4:
	call _mooshIncVar03		; $7c0e
	ld bc,TX_2208		; $7c11
	jp showText		; $7c14

;;
; @addr{7c17}
_mooshStateASubstate5:
	call retIfTextIsActive		; $7c17

	ld bc,-$140		; $7c1a
	call objectSetSpeedZ		; $7c1d
	ld l,SpecialObject.angle		; $7c20
	ld (hl),$10		; $7c22
	ld l,SpecialObject.speed		; $7c24
	ld (hl),SPEED_100		; $7c26

	ld a,$0b		; $7c28
	call specialObjectSetAnimation		; $7c2a

	jp _mooshIncVar03		; $7c2d

;;
; @addr{7c30}
_mooshStateASubstate6:
	call specialObjectAnimate		; $7c30

	ld e,SpecialObject.speedZ+1		; $7c33
	ld a,(de)		; $7c35
	or a			; $7c36
	ld c,$10		; $7c37
	jp nz,objectUpdateSpeedZ_paramC		; $7c39

	call objectApplySpeed		; $7c3c
	ld e,SpecialObject.yh		; $7c3f
	ld a,(de)		; $7c41
	cp $f0			; $7c42
	ret c			; $7c44

	xor a			; $7c45
	ld (wDisabledObjects),a		; $7c46
	ld (wMenuDisabled),a		; $7c49
	ld (wRememberedCompanionId),a		; $7c4c

	ld hl,wMooshState		; $7c4f
	set 6,(hl)		; $7c52
	jp itemDelete		; $7c54

;;
; Prevents Link from passing Moosh, calls animate.
; @addr{7c57}
_mooshUpdateAsNpc:
	call _companionPreventLinkFromPassing_noExtraChecks		; $7c57
	call specialObjectAnimate		; $7c5a
	jp _companionSetPriorityRelativeToLink		; $7c5d

;;
; @addr{7c60}
_mooshIncVar03:
	ld e,SpecialObject.var03		; $7c60
	ld a,(de)		; $7c62
	inc a			; $7c63
	ld (de),a		; $7c64
	ret			; $7c65


;;
; @addr{7c66}
_specialObjectCode_raft:
	jpab bank6.specialObjectCode_raft		; $7c66


.include "data/tileTypeMappings.s"


; @addr{7d09}
cliffTilesTable:
	.dw @collisions0Data
	.dw @collisions1Data
	.dw @collisions2Data
	.dw @collisions3Data
	.dw @collisions4Data
	.dw @collisions5Data

; Data format:
; b0: Tile index
; b1: Angle value from which the tile can be jumped off of.

@collisions0Data:
@collisions4Data:
	.db $05 $10
	.db $06 $10
	.db $07 $10
	.db $0a $18
	.db $0b $08
	.db $64 $10
	.db $ff $10
	.db $00

@collisions1Data:
@collisions2Data:
@collisions5Data:
	.db $b0 $10
	.db $b1 $18
	.db $b2 $00
	.db $b3 $08
	.db $c1 $10
	.db $c2 $18
	.db $c3 $00
	.db $c4 $08
@collisions3Data:
	.db $00


.ifdef BUILD_VANILLA

; Garbage data

	.db $52 $06
	.db $53 $06
	.db $48 $02
	.db $49 $02
	.db $4a $02
	.db $4b $02
	.db $4d $03
	.db $54 $09
	.db $55 $0a
	.db $56 $0b
	.db $57 $0c
	.db $60 $0d
	.db $8a $0f
	.db $00

	.db $16 $10
	.db $18 $10
	.db $17 $90
	.db $19 $90
	.db $f4 $01
	.db $0f $01
	.db $0c $01
	.db $1a $30
	.db $1b $20
	.db $1c $20
	.db $1d $20
	.db $1e $20
	.db $1f $20
	.db $20 $40
	.db $22 $40
	.db $02 $00
	.db $00

	.db $7d $7d
	.db $8c $7d
	.db $8c $7d
	.db $9c $7d
	.db $7d $7d
	.db $8c $7d
	.db $05 $10
	.db $06 $10
	.db $07 $10
	.db $0a $18
	.db $0b $08
	.db $64 $10
	.db $ff $10
	.db $00

	.db $b0 $10
	.db $b1 $18
	.db $b2 $00
	.db $b3 $08
	.db $c1 $10
	.db $c2 $18
	.db $c3 $00
	.db $c4 $08
	.db $00

.endif
.ends


.BANK $06 SLOT 1
.ORG 0


 m_section_superfree "Bank_6" NAMESPACE bank6

	.include "code/interactableTiles.s"
	.include "code/specialObjectAnimationsAndDamage.s"
	.include "code/breakableTiles.s"

	.include "code/items/parentItemUsage.s"

	.include "code/items/shieldParent.s"
	.include "code/items/otherSwordsParent.s"
	.include "code/items/switchHookParent.s"
	.include "code/items/caneOfSomariaParent.s"
	.include "code/items/swordParent.s"
	.include "code/items/harpFluteParent.s"
	.include "code/items/seedsParent.s"
	.include "code/items/shovelParent.s"
	.include "code/items/boomerangParent.s"
	.include "code/items/bombsBraceletParent.s"
	.include "code/items/featherParent.s"
	.include "code/items/magnetGloveParent.s"

	.include "code/items/parentItemCommon.s"


; Following table affects how an item can be used (ie. how it interacts with other items
; being used).
;
; Data format:
;  b0: bits 4-7: Priority (higher value = higher precedence)
;                Gets written to high nibble of Item.enabled
;      bits 0-3: Determines what "parent item" slot to use when the button is pressed.
;                0: Item is unusable.
;                1: Uses w1ParentItem3 or 4.
;                2: Uses w1ParentItem3 or 4, but only one instance of the item may exist
;                   at once. (boomerang, seed satchel)
;                3: Uses w1ParentItem2. If an object is already there, it gets
;                   overwritten if this object's priority is high enough.
;                   (sword, cane, bombs, etc)
;                4: Same as 2, but the item can't be used if w1ParentItem2 is in use (Link
;                   is holding a sword or something)
;                5: Uses w1ParentItem5 (only if not already in use). (shield, flute, harp)
;                6-7: invalid
;  b1: Byte to check input against when the item is first used
;
; @addr{55be}
_itemUsageParameterTable:
	.db $00 <wGameKeysPressed	; ITEMID_NONE
	.db $05 <wGameKeysPressed	; ITEMID_SHIELD
	.db $03 <wGameKeysJustPressed	; ITEMID_PUNCH
	.db $23 <wGameKeysJustPressed	; ITEMID_BOMB
	.db $03 <wGameKeysJustPressed	; ITEMID_CANE_OF_SOMARIA
	.db $63 <wGameKeysJustPressed	; ITEMID_SWORD
	.db $02 <wGameKeysJustPressed	; ITEMID_BOOMERANG
	.db $00 <wGameKeysJustPressed	; ITEMID_ROD_OF_SEASONS
	.db $00 <wGameKeysJustPressed	; ITEMID_MAGNET_GLOVES
	.db $00 <wGameKeysJustPressed	; ITEMID_SWITCH_HOOK_HELPER
	.db $73 <wGameKeysJustPressed	; ITEMID_SWITCH_HOOK
	.db $00 <wGameKeysJustPressed	; ITEMID_SWITCH_HOOK_CHAIN
	.db $73 <wGameKeysJustPressed	; ITEMID_BIGGORON_SWORD
	.db $02 <wGameKeysJustPressed	; ITEMID_BOMBCHUS
	.db $05 <wGameKeysJustPressed	; ITEMID_FLUTE
	.db $43 <wGameKeysJustPressed	; ITEMID_SHOOTER
	.db $00 <wGameKeysJustPressed	; ITEMID_10
	.db $05 <wGameKeysJustPressed	; ITEMID_HARP
	.db $00 <wGameKeysJustPressed	; ITEMID_12
	.db $00 <wGameKeysJustPressed	; ITEMID_SLINGSHOT
	.db $00 <wGameKeysJustPressed	; ITEMID_14
	.db $13 <wGameKeysJustPressed	; ITEMID_SHOVEL
	.db $13 <wGameKeysPressed	; ITEMID_BRACELET
	.db $01 <wGameKeysJustPressed	; ITEMID_FEATHER
	.db $00 <wGameKeysJustPressed	; ITEMID_18
	.db $02 <wGameKeysJustPressed	; ITEMID_SEED_SATCHEL
	.db $00 <wGameKeysJustPressed	; ITEMID_DUST
	.db $00 <wGameKeysJustPressed	; ITEMID_1b
	.db $00 <wGameKeysJustPressed	; ITEMID_1c
	.db $00 <wGameKeysJustPressed	; ITEMID_MINECART_COLLISION
	.db $00 <wGameKeysJustPressed	; ITEMID_FOOLS_ORE
	.db $00 <wGameKeysJustPressed	; ITEMID_1f



; Data format:
;  b0: bit 7:    If set, the corresponding bit in wLinkUsingItem1 will be set.
;      bits 4-6: Value for bits 0-2 of Item.var3f
;      bits 0-3: Determines parent item's relatedObj2?
;                A value of $6 refers to w1WeaponItem.
;  b1: Animation to set Link to? (see constants/linkAnimations.s)
;
; @addr{55fe}
_linkItemAnimationTable:
	.db $00  LINK_ANIM_MODE_NONE	; ITEMID_NONE
	.db $00  LINK_ANIM_MODE_NONE	; ITEMID_SHIELD
	.db $d6  LINK_ANIM_MODE_21	; ITEMID_PUNCH
	.db $30  LINK_ANIM_MODE_LIFT	; ITEMID_BOMB
	.db $d6  LINK_ANIM_MODE_22	; ITEMID_CANE_OF_SOMARIA
	.db $e6  LINK_ANIM_MODE_22	; ITEMID_SWORD
	.db $b0  LINK_ANIM_MODE_21	; ITEMID_BOOMERANG
	.db $d6  LINK_ANIM_MODE_22	; ITEMID_ROD_OF_SEASONS
	.db $60  LINK_ANIM_MODE_NONE	; ITEMID_MAGNET_GLOVES
	.db $80  LINK_ANIM_MODE_NONE	; ITEMID_SWITCH_HOOK_HELPER
	.db $f6  LINK_ANIM_MODE_21	; ITEMID_SWITCH_HOOK
	.db $80  LINK_ANIM_MODE_NONE	; ITEMID_SWITCH_HOOK_CHAIN
	.db $f6  LINK_ANIM_MODE_23	; ITEMID_BIGGORON_SWORD
	.db $30  LINK_ANIM_MODE_21	; ITEMID_BOMBCHUS
	.db $70  LINK_ANIM_MODE_FLUTE	; ITEMID_FLUTE
	.db $c6  LINK_ANIM_MODE_21	; ITEMID_SHOOTER
	.db $80  LINK_ANIM_MODE_NONE	; ITEMID_10
	.db $70  LINK_ANIM_MODE_HARP_2	; ITEMID_HARP
	.db $80  LINK_ANIM_MODE_NONE	; ITEMID_12
	.db $c6  LINK_ANIM_MODE_21	; ITEMID_SLINGSHOT
	.db $80  LINK_ANIM_MODE_NONE	; ITEMID_14
	.db $b0  LINK_ANIM_MODE_DIG_2	; ITEMID_SHOVEL
	.db $40  LINK_ANIM_MODE_LIFT_3	; ITEMID_BRACELET
	.db $80  LINK_ANIM_MODE_NONE	; ITEMID_FEATHER
	.db $80  LINK_ANIM_MODE_NONE	; ITEMID_18
	.db $a0  LINK_ANIM_MODE_21	; ITEMID_SEED_SATCHEL
	.db $80  LINK_ANIM_MODE_NONE	; ITEMID_DUST
	.db $80  LINK_ANIM_MODE_NONE	; ITEMID_1b
	.db $80  LINK_ANIM_MODE_NONE	; ITEMID_1c
	.db $80  LINK_ANIM_MODE_NONE	; ITEMID_MINECART_COLLISION
	.db $e6  LINK_ANIM_MODE_22	; ITEMID_FOOLS_ORE
	.db $80  LINK_ANIM_MODE_NONE	; ITEMID_1f


;;
; Update a minecart object.
; (Called from bank5._specialObjectCode_minecart)
; @addr{563e}
specialObjectCode_minecart:
	call _minecartCreateCollisionItem		; $563e
	ld e,SpecialObject.state		; $5641
	ld a,(de)		; $5643
	rst_jumpTable			; $5644

	.dw @state0
	.dw @state1

@state0:
	; Set state to $01
	ld a,$01		; $5649
	ld (de),a		; $564b

	; Setup palette, etc
	callab bank5.specialObjectSetOamVariables		; $564c

	ld h,d			; $5654
	ld l,SpecialObject.speed		; $5655
	ld (hl),SPEED_100		; $5657

	ld l,SpecialObject.direction		; $5659
	ld a,(hl)		; $565b
	call specialObjectSetAnimation		; $565c

	ld a,d			; $565f
	ld (wLinkObjectIndex),a		; $5660
	call setCameraFocusedObjectToLink		; $5663

	; Resets link's animation if he's using an item, maybe?
	call clearVar3fForParentItems		; $5666

	call clearPegasusSeedCounter		; $5669

	ld hl,w1Link.z		; $566c
	xor a			; $566f
	ldi (hl),a		; $5670
	ldi (hl),a		; $5671

	jp objectSetVisiblec2		; $5672

@state1:
	ld a,(wPaletteThread_mode)		; $5675
	or a			; $5678
	ret nz			; $5679

	call retIfTextIsActive		; $567a

	ld a,(wScrollMode)		; $567d
	and $0e			; $5680
	ret nz			; $5682

	ld a,(wDisabledObjects)		; $5683
	and $81			; $5686
	ret nz			; $5688

	; Disable link's collisions?
	ld hl,w1Link.collisionType		; $5689
	res 7,(hl)		; $568c

	xor a			; $568e
	ld l,<w1Link.knockbackCounter		; $568f
	ldi (hl),a		; $5691

	; Check if on the center of the tile (y)
	ld h,d			; $5692
	ld l,SpecialObject.yh		; $5693
	ldi a,(hl)		; $5695
	ld b,a			; $5696
	and $0f			; $5697
	cp $08			; $5699
	jr nz,++		; $569b

	; Check if on the center of the tile (x)
	inc l			; $569d
	ldi a,(hl)		; $569e
	ld c,a			; $569f
	and $0f			; $56a0
	cp $08			; $56a2
	jr nz,++		; $56a4

	; Minecart is centered on the tile

	call _minecartCheckCollisions		; $56a6
	jr c,@minecartStopped	; $56a9

	; Compare direction to angle, ensure they're synchronized
	ld h,d			; $56ab
	ld l,SpecialObject.direction		; $56ac
	ldi a,(hl)		; $56ae
	swap a			; $56af
	rrca			; $56b1
	cp (hl)			; $56b2
	jr z,++			; $56b3

	ldd (hl),a		; $56b5
	ld a,(hl)		; $56b6
	call specialObjectSetAnimation		; $56b7

++
	ld h,d			; $56ba
	ld l,SpecialObject.var35		; $56bb
	dec (hl)		; $56bd
	bit 7,(hl)		; $56be
	jr z,+			; $56c0

	ld (hl),$1a		; $56c2
	ld a,SND_MINECART		; $56c4
	call playSound		; $56c6
+
	call objectApplySpeed		; $56c9
	jp specialObjectAnimate		; $56cc

@minecartStopped:
	; Go to state $02.
	; State $02 doesn't exist, so, good thing this is getting deleted anyway.
	ld e,SpecialObject.state		; $56cf
	ld a,$02		; $56d1
	ld (de),a		; $56d3

	call clearVar3fForParentItems		; $56d4

	; Force link to jump, lock his direction?
	ld a,$81		; $56d7
	ld (wLinkInAir),a		; $56d9

	; Copy / initialize various link variables

	ld hl,w1Link.angle		; $56dc
	ld e,SpecialObject.angle		; $56df
	ld a,(de)		; $56e1
	ld (hl),a		; $56e2

	ld l,<w1Link.yh		; $56e3
	ld a,(hl)		; $56e5
	add $06			; $56e6
	ld (hl),a		; $56e8

	ld l,<w1Link.zh		; $56e9
	ld (hl),$fa		; $56eb

	ld l,<w1Link.speed		; $56ed
	ld (hl),SPEED_80		; $56ef

	ld l,<w1Link.speedZ		; $56f1
	ld (hl),$40		; $56f3
	inc l			; $56f5
	ld (hl),$fe		; $56f6

	; Re-enable terrain effects (shadow)
	ld l,<w1Link.visible		; $56f8
	set 6,(hl)		; $56fa

	; Change main object back to w1Link ($d000) instead of this object ($d100)
	ld a,>w1Link		; $56fc
	ld (wLinkObjectIndex),a		; $56fe
	call setCameraFocusedObjectToLink		; $5701

	; Create the "interaction" minecart to replace the "special object" minecart
	ld b,INTERACID_MINECART		; $5704
	call objectCreateInteractionWithSubid00		; $5706
	jp objectDelete_useActiveObjectType		; $5709

;;
; Check for collisions, check the track for changing direction.
; @param[out] cflag Set if the minecart should stop (reached a platform)
; @addr{570c}
_minecartCheckCollisions:
	; Get minecart position in c, tile it's on in e
	call getTileAtPosition		; $570c
	ld e,a			; $570f
	ld c,l			; $5710

	; Try to find the relevant data in @trackData based on the tile the minecart is
	; currently on.
	ld h,d			; $5711
	ld l,SpecialObject.direction		; $5712
	ld a,(hl)		; $5714
	swap a			; $5715
	ld hl,@trackData		; $5717
	rst_addAToHl			; $571a
--
	ldi a,(hl)		; $571b
	or a			; $571c
	jr z,@noTrackFound		; $571d

	cp e			; $571f
	jr z,++			; $5720

	ld a,$04		; $5722
	rst_addAToHl			; $5724
	jr --		; $5725

	; Found a matching tile in @trackData
++
	; Add value to c to get the position of the next tile the minecart will move to.
	ldi a,(hl)		; $5727
	add c			; $5728
	ld c,a			; $5729
	ldh (<hFF8B),a	; $572a

	; Check for the edge of the room
	ld b,>wRoomCollisions		; $572c
	ld a,(bc)		; $572e
	cp $ff			; $572f
	ret z			; $5731

	; Check for a platform to disembark at
	ld b,>wRoomLayout		; $5732
	ld a,(bc)		; $5734
	cp TILEINDEX_MINECART_PLATFORM			; $5735
	jr z,@stopMinecart	; $5737

	; c will now store the value of the next tile.
	ld c,a			; $5739

	; Check the next 3 bytes of @trackData to see if the next track tile is acceptable
	ld b,$03		; $573a
--
	ldi a,(hl)		; $573c
	cp c			; $573d
	jr z,@updateDirection	; $573e
	dec b			; $5740
	jr nz,--		; $5741
	jr @noTrackFound		; $5743

@stopMinecart:
	; Set carry flag to give the signal that the ride is over.
	scf			; $5745
	ret			; $5746

@updateDirection:
	ld a,e			; $5747
	sub TILEINDEX_TRACK_TL		; $5748
	cp TILEINDEX_MINECART_PLATFORM - TILEINDEX_TRACK_TL	; $574a
	jr c,++			; $574c

@noTrackFound:
	; Index $06 will jump to @notTrack.
	ld a,$06		; $574e
++
	ld e,SpecialObject.direction		; $5750
	rst_jumpTable			; $5752
.dw @trackTL
.dw @trackBR
.dw @trackBL
.dw @trackTR
.dw @trackHorizontal
.dw @trackVertical
.dw @notTrack

@trackTL:
@trackBR:
	ld a,(de)		; $5761
	xor $01			; $5762
	ld (de),a		; $5764
	ret			; $5765

@trackBL:
@trackTR:
	ld a,(de)		; $5766
	xor $03			; $5767
	ld (de),a		; $5769
	ret			; $576a

@trackHorizontal:
	ld a,(de)		; $576b
	and $02			; $576c
	or $01			; $576e
	ld (de),a		; $5770
	ret			; $5771

@trackVertical:
	ld a,(de)		; $5772
	and $02			; $5773
	ld (de),a		; $5775
	ret			; $5776

@notTrack:
	call @checkMinecartDoor		; $5777
	jr nc,+			; $577a

	; Next tile is a minecart door, keep going
	xor a			; $577c
	ret			; $577d
+
	; Reverse direction
	ld a,(de)		; $577e
	xor $02			; $577f
	ld (de),a		; $5781
	ret			; $5782

; b0: Tile to check for ($00 to end list)
; b1: Value to add to position (where the next tile is)
; b2-b4: Other tiles that are allowed to link to the current tile
; @addr{5783}
@trackData:
	; DIR_UP
	.db TILEINDEX_TRACK_VERTICAL $f0 TILEINDEX_TRACK_VERTICAL   TILEINDEX_TRACK_TL TILEINDEX_TRACK_TR
	.db TILEINDEX_TRACK_TL       $01 TILEINDEX_TRACK_HORIZONTAL TILEINDEX_TRACK_BR TILEINDEX_TRACK_TR
	.db TILEINDEX_TRACK_TR       $ff TILEINDEX_TRACK_HORIZONTAL TILEINDEX_TRACK_BL TILEINDEX_TRACK_TL
	.db $00

	; DIR_RIGHT
	.db TILEINDEX_TRACK_HORIZONTAL $01 TILEINDEX_TRACK_HORIZONTAL TILEINDEX_TRACK_BR TILEINDEX_TRACK_TR
	.db TILEINDEX_TRACK_BR         $f0 TILEINDEX_TRACK_VERTICAL   TILEINDEX_TRACK_TL TILEINDEX_TRACK_TR
	.db TILEINDEX_TRACK_TR         $10 TILEINDEX_TRACK_VERTICAL   TILEINDEX_TRACK_BL TILEINDEX_TRACK_BR
	.db $00

	; DIR_DOWN
	.db TILEINDEX_TRACK_VERTICAL $10 TILEINDEX_TRACK_VERTICAL   TILEINDEX_TRACK_BR TILEINDEX_TRACK_BL
	.db TILEINDEX_TRACK_BR       $ff TILEINDEX_TRACK_HORIZONTAL TILEINDEX_TRACK_BL TILEINDEX_TRACK_TL
	.db TILEINDEX_TRACK_BL       $01 TILEINDEX_TRACK_HORIZONTAL TILEINDEX_TRACK_BR TILEINDEX_TRACK_TR
	.db $00

	; DIR_LEFT
	.db TILEINDEX_TRACK_HORIZONTAL $ff TILEINDEX_TRACK_HORIZONTAL TILEINDEX_TRACK_BL TILEINDEX_TRACK_TL
	.db TILEINDEX_TRACK_BL         $f0 TILEINDEX_TRACK_VERTICAL   TILEINDEX_TRACK_TR TILEINDEX_TRACK_TL
	.db TILEINDEX_TRACK_TL         $10 TILEINDEX_TRACK_VERTICAL   TILEINDEX_TRACK_BR TILEINDEX_TRACK_BL
	.db $00

;;
; @param	c	Next tile
; @param[out]	cflag	Set if the next tile is a minecart door that will open
; @addr{57c3}
@checkMinecartDoor:
	; Check if the next tile is a minecart door
	ld a,c			; $57c3
	sub TILEINDEX_MINECART_DOOR_UP			; $57c4
	cp $04			; $57c6
	ret nc			; $57c8

	; Calculate the angle for the interaction to be created (?)
	add $0c			; $57c9
	add a			; $57cb
	ld b,a			; $57cc

	call getFreeInteractionSlot		; $57cd
	ret nz			; $57d0

	ld (hl),INTERACID_DOOR_CONTROLLER		; $57d1

	ld l,Interaction.angle		; $57d3
	ld (hl),b		; $57d5

	; Set position (this interaction stuffs both X and Y in the yh variable)
	ld l,Interaction.yh		; $57d6
	ldh a,(<hFF8B)	; $57d8
	ld (hl),a		; $57da

	scf			; $57db
	ret			; $57dc

;;
; Creates an invisible item object which stays with the minecart to give it collision with enemies
; @addr{57dd}
_minecartCreateCollisionItem:
	; Check if the "item" has been created already
	ld e,SpecialObject.var36		; $57dd
	ld a,(de)		; $57df
	or a			; $57e0
	ret nz			; $57e1

	call getFreeItemSlot		; $57e2
	ret nz			; $57e5

	; Mark it as created
	ld e,SpecialObject.var36		; $57e6
	ld a,$01		; $57e8
	ld (de),a		; $57ea

	; Set Item.enabled
	ldi (hl),a		; $57eb

	; Set Item.id
	ld (hl),ITEMID_MINECART_COLLISION		; $57ec
	ret			; $57ee

;;
; @addr{57ef}
specialObjectCode_raft:
	ld a,d			; $57ef
	ld (wLinkRidingObject),a		; $57f0
	ld e,Item.state		; $57f3
	ld a,(de)		; $57f5
	rst_jumpTable			; $57f6
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3

@state0:
	callab bank5.specialObjectSetOamVariables		; $57ff
	xor a			; $5807
	call specialObjectSetAnimation		; $5808
	call itemIncState		; $580b

	ld l,SpecialObject.collisionType		; $580e
	ld a,$80|ITEMCOLLISION_LINK		; $5810
	ldi (hl),a		; $5812

	; collisionRadiusY/X
	inc l			; $5813
	ld a,$06		; $5814
	ldi (hl),a		; $5816
	ldi (hl),a		; $5817

	ld l,SpecialObject.counter1		; $5818
	ld (hl),$0c		; $581a

	ld a,d			; $581c
	ld (wLinkObjectIndex),a		; $581d
	call setCameraFocusedObjectToLink		; $5820
	jp @saveRaftPosition		; $5823


; State 1: riding the raft
@state1:
	ld a,(wPaletteThread_mode)		; $5826
	or a			; $5829
	ret nz			; $582a
	call retIfTextIsActive		; $582b
	ld a,(wScrollMode)		; $582e
	and $0e			; $5831
	ret nz			; $5833
	ld a,(wDisabledObjects)		; $5834
	and $81			; $5837
	ret nz			; $5839

	ld a,(wLinkForceState)		; $583a
	cp LINK_STATE_RESPAWNING			; $583d
	jr z,@respawning			; $583f
	ld a,(w1Link.state)		; $5841
	cp LINK_STATE_RESPAWNING			; $5844
	jr nz,++		; $5846

@respawning:
	ld hl,wLinkLocalRespawnY		; $5848
	ld e,SpecialObject.yh		; $584b
	ldi a,(hl)		; $584d
	ld (de),a		; $584e
	ld e,SpecialObject.xh		; $584f
	ldi a,(hl)		; $5851
	ld (de),a		; $5852
	jp objectSetInvisible		; $5853

++
	; Update direction; if changed, re-initialize animation
	call updateCompanionDirectionFromAngle		; $5856
	jr c,+			; $5859
	call specialObjectAnimate		; $585b
	jr ++			; $585e
+
	call specialObjectSetAnimation		; $5860
++
	call @raftCalculateAdjacentWallsBitset		; $5863
	call @transferKnockbackToLink		; $5866
	ld hl,w1Link.knockbackCounter		; $5869
	ld a,(hl)		; $586c
	or a			; $586d
	jr z,@updateMovement	; $586e

	; Experiencing knockback; decrement counter, apply knockback speed
	dec (hl)		; $5870
	dec l			; $5871
	ld c,(hl)		; $5872
	ld b,SPEED_100		; $5873
	callab bank5.specialObjectUpdatePositionGivenVelocity		; $5875

	ld a,$88		; $587d
	ld (wcc92),a		; $587f
	jr @notDismounting		; $5882

@updateMovement:
	ld e,SpecialObject.speed		; $5884
	ld a,SPEED_e0		; $5886
	ld (de),a		; $5888

	ld e,SpecialObject.angle		; $5889
	ld a,(wLinkAngle)		; $588b
	ld (de),a		; $588e
	bit 7,a			; $588f
	jr nz,@notDismounting	; $5891
	ld a,(wLinkImmobilized)		; $5893
	or a			; $5896
	jr nz,@notDismounting	; $5897

	callab bank5.specialObjectUpdatePosition	; $5899
	ld a,c			; $58a1
	or a			; $58a2
	jr z,@positionUnchanged	; $58a3

	ld a,$08		; $58a5
	ld (wcc92),a		; $58a7


	; If not dismounting this frame, reset 'dismounting angle' (var3e) and
	; 'dismounting counter' (var3f).
@notDismounting:
	ld h,d			; $58aa
	ld l,SpecialObject.var3e		; $58ab
	ld a,$ff		; $58ad
	ldi (hl),a		; $58af

	; [var3f] = $04
	ld (hl),$04		; $58b0
	ret			; $58b2


	; If position is unchanged, check whether to dismount
@positionUnchanged:
	; Return if "dismount angle" changed from before
	ld h,d			; $58b3
	ld e,SpecialObject.angle		; $58b4
	ld a,(de)		; $58b6
	ld l,SpecialObject.var3e		; $58b7
	cp (hl)			; $58b9
	ldi (hl),a		; $58ba
	ret nz			; $58bb

	; [var3f]--
	dec (hl)		; $58bc
	ret nz			; $58bd

	; Get angle from var3e
	dec e			; $58be
	ld a,(de)		; $58bf
	ld hl,@dismountTileOffsets		; $58c0
	rst_addDoubleIndex			; $58c3

	; Get Y/X offset from this object in 'bc'
	ldi a,(hl)		; $58c4
	ld c,(hl)		; $58c5
	ld h,d			; $58c6
	ld l,SpecialObject.yh		; $58c7
	add (hl)		; $58c9
	ld b,a			; $58ca
	ld l,SpecialObject.xh		; $58cb
	ld a,(hl)		; $58cd
	add c			; $58ce
	ld c,a			; $58cf

	; If Link can walk on the adjacent tile, check whether to dismount
	call getTileAtPosition		; $58d0
	ld h,>wRoomCollisions		; $58d3
	ld a,(hl)		; $58d5
	or a			; $58d6
	jr z,@checkDismount	; $58d7
	cp SPECIALCOLLISION_STAIRS			; $58d9
	jr nz,@notDismounting	; $58db

@checkDismount:
	callab bank5.calculateAdjacentWallsBitset		; $58dd
	ldh a,(<hFF8B)	; $58e5
	or a			; $58e7
	jr nz,@notDismounting	; $58e8

	; Disable menu, force Link to walk for 14 frames
	inc a			; $58ea
	ld (wMenuDisabled),a		; $58eb
	ld a,LINK_STATE_FORCE_MOVEMENT		; $58ee
	ld (wLinkForceState),a		; $58f0
	ld a,14		; $58f3
	ld (wLinkStateParameter),a		; $58f5

	; Update angle; copy direction + angle to Link
	call itemUpdateAngle		; $58f8
	ld e,l			; $58fb
	ld h,>w1Link		; $58fc
	ld a,(de)		; $58fe
	ldi (hl),a		; $58ff
	inc e			; $5900
	ld a,(de)		; $5901
	ldi (hl),a		; $5902

	; Link is no longer riding the raft, set object index to $d0
	ld a,h			; $5903
	ld (wLinkObjectIndex),a		; $5904

	call setCameraFocusedObjectToLink		; $5907
	call itemIncState		; $590a
	jr @saveRaftPosition		; $590d


; These are offsets from the raft's position at which to check whether the tile there can
; be dismounted onto. (the only requirement is that it's non-solid.)
@dismountTileOffsets:
	.db $f7 $00 ; DIR_UP
	.db $fd $08 ; DIR_RIGHT
	.db $08 $00 ; DIR_DOWN
	.db $fd $f7 ; DIR_LEFT


; State 2: started dismounting
@state2:
	ld a,$80		; $5917
	ld (wcc92),a		; $5919
	call itemDecCounter1		; $591c
	ret nz			; $591f

	xor a			; $5920
	ld (wMenuDisabled),a		; $5921
	ld e,SpecialObject.enabled		; $5924
	inc a			; $5926
	ld (de),a		; $5927
	call updateLinkLocalRespawnPosition		; $5928
	call itemIncState		; $592b


; State 3: replace self with raft interaction
@state3:
	ldbc INTERACID_RAFT, $02		; $592e
	call objectCreateInteraction		; $5931
	ret nz			; $5934
	ld e,SpecialObject.direction		; $5935
	ld a,(de)		; $5937
	ld l,Interaction.direction		; $5938
	ld (hl),a		; $593a
	jp itemDelete		; $593b

;;
; @addr{593e}
@saveRaftPosition:
	ld bc,wLastAnimalMountPointY		; $593e
	ld h,d			; $5941
	ld l,SpecialObject.yh		; $5942
	ldi a,(hl)		; $5944
	ld (bc),a		; $5945
	inc c			; $5946
	inc l			; $5947
	ld a,(hl)		; $5948
	ld (bc),a		; $5949
	jpab bank5.saveLinkLocalRespawnAndCompanionPosition		; $594a

;;
; Calculates the "adjacent walls bitset" for the raft specifically, treating everything as
; solid except for water tiles.
;
; @addr{5952}
@raftCalculateAdjacentWallsBitset:
	ld a,$01		; $5952
	ldh (<hFF8B),a	; $5954
	ld hl,@@wallPositionOffsets		; $5956
--
	ldi a,(hl)		; $5959
	ld b,a			; $595a
	ldi a,(hl)		; $595b
	ld c,a			; $595c
	push hl			; $595d
	call objectGetRelativeTile		; $595e
	or a			; $5961
	jr z,+			; $5962
	ld e,a			; $5964
	ld hl,@@validTiles		; $5965
	call findByteAtHl		; $5968
	ccf			; $596b
+
	pop hl			; $596c
	ldh a,(<hFF8B)	; $596d
	rla			; $596f
	ldh (<hFF8B),a	; $5970
	jr nc,--		; $5972

	ld e,SpecialObject.adjacentWallsBitset		; $5974
	ld (de),a		; $5976
	ret			; $5977

; Offsets at which to check for solid walls (8 positions to check)
@@wallPositionOffsets:
	.db $fa $fb
	.db $fa $04
	.db $05 $fb
	.db $05 $04
	.db $fb $fa
	.db $04 $fa
	.db $fb $05
	.db $04 $05


; A list of tiles that the raft may cross.
@@validTiles:
	.db TILEINDEX_DEEP_WATER
	.db TILEINDEX_CURRENT_UP
	.db TILEINDEX_CURRENT_DOWN
	.db TILEINDEX_CURRENT_LEFT
	.db TILEINDEX_CURRENT_RIGHT
	.db TILEINDEX_WATER
	.db TILEINDEX_WHIRLPOOL
	.db $00


;;
; @addr{5990}
@transferKnockbackToLink:
	; Check Link's invincibilityCounter and var2a
	ld hl,w1Link.invincibilityCounter		; $5990
	ldd a,(hl)		; $5993
	or (hl)			; $5994
	jr nz,@@end		; $5995

	; Ret if raft's var2a is zero
	ld e,l			; $5997
	ld a,(de)		; $5998
	or a			; $5999
	ret z			; $599a

	; Transfer raft's var2a, invincibilityCounter, knockbackCounter, knockbackAngle,
	; and damageToApply to Link.
	ldi (hl),a		; $599b
	inc e			; $599c
	ld a,(de)		; $599d
	ldi (hl),a		; $599e
	inc e			; $599f
	ld a,(de)		; $59a0
	ldi (hl),a		; $59a1
	inc e			; $59a2
	ld a,(de)		; $59a3
	ldi (hl),a		; $59a4
	ld e,SpecialObject.damageToApply		; $59a5
	ld a,(de)		; $59a7
	ld l,e			; $59a8
	ld (hl),a		; $59a9

@@end:
	; Clear raft's invincibilityCounter and var2a
	ld e,SpecialObject.var2a		; $59aa
	xor a			; $59ac
	ld (de),a		; $59ad
	inc e			; $59ae
	ld (de),a		; $59af
	ret			; $59b0


	.include "build/data/specialObjectAnimationData.s"


;;
; @addr{6cec}
specialObjectCode_companionCutscene:
	ld hl,w1Companion.id		; $6cec
	ld a,(hl)		; $6cef
	sub SPECIALOBJECTID_RICKY_CUTSCENE			; $6cf0
	rst_jumpTable			; $6cf2
	.dw _specialObjectCode_rickyCutscene
	.dw _specialObjectCode_dimitriCutscene
	.dw _specialObjectCode_mooshCutscene
	.dw _specialObjectCode_mapleCutscene

;;
; @addr{6cfb}
_specialObjectCode_rickyCutscene:
	ld e,SpecialObject.state		; $6cfb
	ld a,(de)		; $6cfd
	ld a,(de)		; $6cfe
	rst_jumpTable			; $6cff
	.dw @state0
	.dw _rickyCutscene_state1

@state0:
	call _companionCutsceneInitOam		; $6d04
	ld h,d			; $6d07
	ld l,SpecialObject.speed		; $6d08
	ld (hl),SPEED_200		; $6d0a
	ld l,SpecialObject.angle		; $6d0c
	ld (hl),$08		; $6d0e

_rickyCutsceneJump:
	ld bc,$fe00		; $6d10
	call objectSetSpeedZ		; $6d13
	ld a,$02		; $6d16
	jp specialObjectSetAnimation		; $6d18


;;
; @param	de	Pointer to Object.state variable
; @addr{6d1b}
_companionCutsceneInitOam:
	ld a,$01		; $6d1b
	ld (de),a		; $6d1d
	callab bank5.specialObjectSetOamVariables		; $6d1e
	jp objectSetVisiblec0		; $6d26


_rickyCutscene_state1:
	ld e,SpecialObject.subid		; $6d29
	ld a,(de)		; $6d2b
	rst_jumpTable			; $6d2c
	.dw @subid0
	.dw @subid1

@subid0:
	ret			; $6d31

@subid1:
	ld e,SpecialObject.state2		; $6d32
	ld a,(de)		; $6d34
	rst_jumpTable			; $6d35
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4
	.dw @substate5
	.dw @substate6
	.dw @substate7
	.dw @substate8
	.dw @substate9
	.dw @substateA

@substate0:
	ld l,SpecialObject.state2		; $6d4c
	inc (hl)		; $6d4e

@substate1:
	call objectApplySpeed		; $6d4f

	ld e,SpecialObject.xh		; $6d52
	ld a,(de)		; $6d54
	bit 7,a			; $6d55
	jr nz,++		; $6d57

	ld hl,w1Link.xh		; $6d59
	ld b,(hl)		; $6d5c
	add $18			; $6d5d
	cp b			; $6d5f
	jr c,++			; $6d60

	call itemIncState2		; $6d62
	inc (hl)		; $6d65
	ld l,SpecialObject.z		; $6d66
	xor a			; $6d68
	ldi (hl),a		; $6d69
	ld (hl),a		; $6d6a
	ld l,SpecialObject.counter1		; $6d6b
	ld (hl),$3c		; $6d6d
	jp specialObjectAnimate		; $6d6f
++
	ld c,$40		; $6d72
	call objectUpdateSpeedZ_paramC		; $6d74
	ret nz			; $6d77
	call itemIncState2		; $6d78
	ld l,SpecialObject.counter1		; $6d7b
	ld (hl),$08		; $6d7d
	jp specialObjectAnimate		; $6d7f

@substate2:
	call itemDecCounter1		; $6d82
	ret nz			; $6d85
	ld l,SpecialObject.state2		; $6d86
	dec (hl)		; $6d88
	jp _rickyCutsceneJump		; $6d89

@substate3:
	call itemDecCounter1		; $6d8c
	ret nz			; $6d8f
	ld l,SpecialObject.state2		; $6d90
	inc (hl)		; $6d92
	ld l,SpecialObject.counter1		; $6d93
	ld (hl),$5a		; $6d95
	ld a,$14		; $6d97
	jp specialObjectSetAnimation		; $6d99

@substate4:
	call specialObjectAnimate		; $6d9c
	call itemDecCounter1		; $6d9f
	ret nz			; $6da2
	ld l,SpecialObject.state2		; $6da3
	inc (hl)		; $6da5
	ld l,SpecialObject.counter1		; $6da6
	ld (hl),$0c		; $6da8
	ld a,$1f		; $6daa
	call specialObjectSetAnimation		; $6dac
	call getFreeInteractionSlot		; $6daf
	ret nz			; $6db2

	ld (hl),$07		; $6db3
	ld bc,$f812		; $6db5
	jp objectCopyPositionWithOffset		; $6db8

	ld l,SpecialObject.state2		; $6dbb
	ld (hl),$00		; $6dbd
	ld a,$1e		; $6dbf
	jp specialObjectSetAnimation		; $6dc1

@substate5:
	call itemDecCounter1		; $6dc4
	ret nz			; $6dc7
	ld l,SpecialObject.state2		; $6dc8
	inc (hl)		; $6dca
	ld l,SpecialObject.counter1		; $6dcb
	ld (hl),$3c		; $6dcd
	ld a,$1e		; $6dcf
	jp specialObjectSetAnimation		; $6dd1

@substate6:
	call itemDecCounter1		; $6dd4
	ret nz			; $6dd7
	ld l,SpecialObject.state2		; $6dd8
	inc (hl)		; $6dda

	; counter1
	inc l			; $6ddb
	ld (hl),$1e		; $6ddc

	ld hl,wActiveRing		; $6dde
	ld (hl),$ff		; $6de1
	ld a,$81		; $6de3
	ld (wLinkInAir),a		; $6de5
	ld hl,w1Link.speed		; $6de8
	ld (hl),SPEED_80		; $6deb
	ld l,SpecialObject.speedZ		; $6ded
	ld (hl),$00		; $6def
	inc l			; $6df1
	ld (hl),$fe		; $6df2

	ld a,$18		; $6df4
	ld (w1Link.angle),a		; $6df6
	ld a,SND_JUMP		; $6df9
	jp playSound		; $6dfb

@substate7:
	call itemDecCounter1		; $6dfe
	ret nz			; $6e01
	ld l,SpecialObject.state2		; $6e02
	inc (hl)		; $6e04
	ld l,SpecialObject.counter1		; $6e05
	ld (hl),$14		; $6e07
	xor a			; $6e09
	ld hl,w1Link.visible		; $6e0a
	ld (hl),a		; $6e0d
	inc a			; $6e0e
	ld (wDisabledObjects),a		; $6e0f
	ret			; $6e12

@substate8:
	call itemDecCounter1		; $6e13
	ret nz			; $6e16
	ld l,SpecialObject.state2		; $6e17
	inc (hl)		; $6e19
	ld l,SpecialObject.angle		; $6e1a
	ld (hl),$18		; $6e1c

@jump:
	ld a,$1c		; $6e1e
	call specialObjectSetAnimation		; $6e20
	ld bc,$fe00		; $6e23
	jp objectSetSpeedZ		; $6e26

@substate9:
	call objectApplySpeed		; $6e29
	ld e,SpecialObject.xh		; $6e2c
	ld a,(de)		; $6e2e
	sub $10			; $6e2f
	rlca			; $6e31
	jr nc,+			; $6e32
	ld hl,$cfdf		; $6e34
	ld (hl),$01		; $6e37
	ret			; $6e39
+
	ld c,$40		; $6e3a
	call objectUpdateSpeedZ_paramC		; $6e3c
	ret nz			; $6e3f
	call itemIncState2		; $6e40
	ld l,SpecialObject.counter1		; $6e43
	ld (hl),$08		; $6e45
	jp specialObjectAnimate		; $6e47

@substateA:
	call itemDecCounter1		; $6e4a
	ret nz			; $6e4d
	ld l,SpecialObject.state2		; $6e4e
	dec (hl)		; $6e50
	jp @jump		; $6e51

;;
; @addr{6e54}
_specialObjectCode_mooshCutscene:
	ld e,SpecialObject.state		; $6e54
	ld a,(de)		; $6e56
	rst_jumpTable			; $6e57
	.dw @state0
	.dw @state1

@state0:
	call _companionCutsceneInitOam		; $6e5c
	ld h,d			; $6e5f
	ld l,SpecialObject.counter1		; $6e60
	ld (hl),$5a		; $6e62
	ld l,SpecialObject.speed		; $6e64
	ld (hl),SPEED_160		; $6e66
	ld l,SpecialObject.var36		; $6e68
	ld (hl),$05		; $6e6a
	ld l,SpecialObject.angle		; $6e6c
	ld (hl),$10		; $6e6e
	ld l,SpecialObject.z		; $6e70
	ld (hl),$ff		; $6e72
	inc l			; $6e74
	ld (hl),$e0		; $6e75

	call getFreeInteractionSlot		; $6e77
	jr nz,+			; $6e7a
	ld (hl),INTERACID_BANANA		; $6e7c
	ld l,Interaction.relatedObj1+1		; $6e7e
	ld (hl),d		; $6e80
+
	ld a,$07		; $6e81
	jp specialObjectSetAnimation		; $6e83

@state1:
	ld e,SpecialObject.state2		; $6e86
	ld a,(de)		; $6e88
	or a			; $6e89
	jr z,+			; $6e8a
	call specialObjectAnimate		; $6e8c
	call objectApplySpeed		; $6e8f
+
	ld e,SpecialObject.state2		; $6e92
	ld a,(de)		; $6e94
	rst_jumpTable			; $6e95
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4

@substate0:
	call itemDecCounter1		; $6ea0
	ret nz			; $6ea3
	ld (hl),$48		; $6ea4
	ld l,SpecialObject.state2		; $6ea6
	inc (hl)		; $6ea8
	ret			; $6ea9

@substate1:
	call itemDecCounter1		; $6eaa
	ret nz			; $6ead
	ld (hl),$06		; $6eae
	ld l,SpecialObject.state2		; $6eb0
	inc (hl)		; $6eb2
	jp _companionCutsceneFunc_7081		; $6eb3

@substate2:
	ld h,d			; $6eb6
	ld l,SpecialObject.angle		; $6eb7
	ld a,(hl)		; $6eb9
	cp $10			; $6eba
	jr z,@label_6ec2			; $6ebc
	ld l,SpecialObject.state2		; $6ebe
	inc (hl)		; $6ec0
	ret			; $6ec1

@label_6ec2:
	ld l,SpecialObject.counter1		; $6ec2
	dec (hl)		; $6ec4
	ret nz			; $6ec5
	call _companionCutsceneDecAngle		; $6ec6
	ld (hl),$06		; $6ec9
	jp _companionCutsceneFunc_7081		; $6ecb

@substate3:
	ld h,d			; $6ece
	ld l,SpecialObject.angle		; $6ecf
	ld a,(hl)		; $6ed1
	cp $10			; $6ed2
	jr nz,@label_6ec2		; $6ed4
	ld l,SpecialObject.state2		; $6ed6
	inc (hl)		; $6ed8
	ld a,$07		; $6ed9
	jp specialObjectSetAnimation		; $6edb

@substate4:
	ld e,SpecialObject.yh		; $6ede
	ld a,(de)		; $6ee0
	cp $b0			; $6ee1
	ret c			; $6ee3

	ld hl,w1Companion.id		; $6ee4
	ld b,$3f		; $6ee7
	call clearMemory		; $6ee9
	ld hl,w1Companion.id		; $6eec
	ld (hl),SPECIALOBJECTID_DIMITRI_CUTSCENE		; $6eef
	ld l,SpecialObject.yh		; $6ef1
	ld (hl),$e8		; $6ef3
	inc l			; $6ef5
	inc l			; $6ef6
	ld (hl),$28		; $6ef7
	ret			; $6ef9

;;
; @addr{6efa}
_specialObjectCode_dimitriCutscene:
	ld e,SpecialObject.state		; $6efa
	ld a,(de)		; $6efc
	rst_jumpTable			; $6efd
	.dw @state0
	.dw @state1

@state0:
	call _companionCutsceneInitOam		; $6f02
	ld h,d			; $6f05
	ld l,SpecialObject.speed		; $6f06
	ld (hl),SPEED_100		; $6f08
	ld l,SpecialObject.z		; $6f0a
	ld (hl),$e0		; $6f0c
	inc l			; $6f0e
	ld (hl),$ff		; $6f0f
	ld a,$19		; $6f11
	jp specialObjectSetAnimation		; $6f13

@state1:
	ld e,SpecialObject.state2		; $6f16
	ld a,(de)		; $6f18
	rst_jumpTable			; $6f19
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4
	.dw @substate5
	.dw @substate6

@substate0:
	ld h,d			; $6f28
	ld l,SpecialObject.state2		; $6f29
	inc (hl)		; $6f2b
	ld l,SpecialObject.counter2		; $6f2c
	ld a,(hl)		; $6f2e
	cp $02			; $6f2f
	jr nz,+			; $6f31

	push af			; $6f33
	ld a,$1a		; $6f34
	call specialObjectSetAnimation		; $6f36
	pop af			; $6f39
+
	ld b,a			; $6f3a
	add a			; $6f3b
	add b			; $6f3c
	ld hl,@@data		; $6f3d
	rst_addAToHl			; $6f40
	ldi a,(hl)		; $6f41
	ld e,SpecialObject.angle		; $6f42
	ld (de),a		; $6f44
	ld c,(hl)		; $6f45
	inc hl			; $6f46
	ld b,(hl)		; $6f47
	jp objectSetSpeedZ		; $6f48


; b0: angle
; b1/b2: speedZ
@@data:
	dbw $0c $fd40
	dbw $0c $fda0
	dbw $13 $fe80


@substate1:
	call specialObjectAnimate		; $6f54
	call objectApplySpeed		; $6f57
	ld c,$18		; $6f5a
	call objectUpdateSpeedZ_paramC		; $6f5c
	ret nz			; $6f5f

	ld h,d			; $6f60
	ld l,SpecialObject.counter2		; $6f61
	inc (hl)		; $6f63
	ld a,(hl)		; $6f64
	ld l,SpecialObject.state2		; $6f65
	cp $03			; $6f67
	jr z,+			; $6f69
	dec (hl)		; $6f6b
	ld l,SpecialObject.counter1		; $6f6c
	ld (hl),$08		; $6f6e
	ret			; $6f70
+
	inc (hl)		; $6f71
	ld l,SpecialObject.counter1		; $6f72
	ld (hl),$06		; $6f74
	ret			; $6f76

@substate2:
	call itemDecCounter1		; $6f77
	ret nz			; $6f7a
	ld l,SpecialObject.state2		; $6f7b
	inc (hl)		; $6f7d
	ld l,SpecialObject.counter1		; $6f7e
	ld (hl),$14		; $6f80
	ld a,$27		; $6f82
	jp specialObjectSetAnimation		; $6f84

@substate3:
	call itemDecCounter1		; $6f87
	ret nz			; $6f8a
	ld l,SpecialObject.state2		; $6f8b
	inc (hl)		; $6f8d
	ld l,SpecialObject.counter1		; $6f8e
	ld (hl),$78		; $6f90
	ret			; $6f92

@substate4:
	call specialObjectAnimate		; $6f93
	call itemDecCounter1		; $6f96
	ret nz			; $6f99
	ld l,SpecialObject.state2		; $6f9a
	inc (hl)		; $6f9c
	ld l,SpecialObject.counter1		; $6f9d
	ld (hl),$3c		; $6f9f
	ld l,SpecialObject.angle		; $6fa1
	ld (hl),$0b		; $6fa3
	ld l,SpecialObject.speed		; $6fa5
	ld (hl),SPEED_80		; $6fa7
	ret			; $6fa9

@substate5:
	call itemDecCounter1		; $6faa
	ret nz			; $6fad
	ld l,SpecialObject.state2		; $6fae
	inc (hl)		; $6fb0
	ld a,$26		; $6fb1
	jp specialObjectSetAnimation		; $6fb3

@substate6:
	call specialObjectAnimate		; $6fb6
	call objectApplySpeed		; $6fb9
	ld e,SpecialObject.xh		; $6fbc
	ld a,(de)		; $6fbe
	cp $78			; $6fbf
	jr nz,+			; $6fc1
	ld a,$05		; $6fc3
	jp specialObjectSetAnimation		; $6fc5
+
	cp $b0			; $6fc8
	ret c			; $6fca

	ld hl,w1Companion.id		; $6fcb
	ld b,$3f		; $6fce
	call clearMemory		; $6fd0
	ld hl,w1Companion.id		; $6fd3
	ld (hl),SPECIALOBJECTID_RICKY_CUTSCENE		; $6fd6
	inc l			; $6fd8
	ld (hl),$01		; $6fd9
	ld l,SpecialObject.yh		; $6fdb
	ld (hl),$48		; $6fdd
	inc l			; $6fdf
	inc l			; $6fe0
	ld (hl),$d8		; $6fe1
	ret			; $6fe3

;;
; @addr{6fe4}
_specialObjectCode_mapleCutscene:
	ld e,SpecialObject.state		; $6fe4
	ld a,(de)		; $6fe6
	rst_jumpTable			; $6fe7
	.dw @state0
	.dw @state1

@state0:
	call _companionCutsceneInitOam		; $6fec
	ld h,d			; $6fef
	ld l,SpecialObject.zh		; $6ff0
	ld (hl),$f0		; $6ff2
	ld l,SpecialObject.angle		; $6ff4
	ld (hl),$08		; $6ff6
	ld l,SpecialObject.counter1		; $6ff8
	ld (hl),$5a		; $6ffa
	ret			; $6ffc

@initPositionSpeedAnimation:
	ld l,SpecialObject.counter2		; $6ffd
	ld a,(hl)		; $6fff
	add a			; $7000
	ld hl,@@data		; $7001
	rst_addDoubleIndex			; $7004
	ldi a,(hl)		; $7005
	ld e,SpecialObject.speed		; $7006
	ld (de),a		; $7008
	ldi a,(hl)		; $7009
	ld e,SpecialObject.counter1		; $700a
	ld (de),a		; $700c
	ldi a,(hl)		; $700d
	ld e,SpecialObject.yh		; $700e
	ld (de),a		; $7010
	ld a,(hl)		; $7011
	jp specialObjectSetAnimation		; $7012


; b0: speed
; b1: counter1
; b2: yh
; b3: animation
@@data:
	.db SPEED_200 $60 $78 $05
	.db SPEED_1c0 $6e $70 $07
	.db SPEED_180 $7d $68 $05
	.db SPEED_040 $e6 $2c $05


@state1:
	call specialObjectAnimate		; $7025
	call objectOscillateZ		; $7028
	ld e,SpecialObject.state2		; $702b
	ld a,(de)		; $702d
	rst_jumpTable			; $702e
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate0:
	ld a,(wPaletteThread_mode)		; $7037
	or a			; $703a
	call z,itemDecCounter1		; $703b
	ret nz			; $703e
	call itemIncState2		; $703f
	jr @initPositionSpeedAnimation		; $7042

@substate1:
	call itemDecCounter1		; $7044
	jp nz,objectApplySpeed		; $7047
	ld (hl),$5a		; $704a
	inc l			; $704c
	inc (hl)		; $704d
	jp itemIncState2		; $704e

@substate2:
	call itemDecCounter1		; $7051
	ret nz			; $7054

	; Check counter2
	inc l			; $7055
	ld a,(hl)		; $7056
	cp $04			; $7057
	jr nz,++		; $7059

	; Set counter1
	dec l			; $705b
	ld (hl),$1e		; $705c

	call itemIncState2		; $705e
	ld a,$07		; $7061
	jp specialObjectSetAnimation		; $7063
++
	ld l,SpecialObject.state2		; $7066
	dec (hl)		; $7068
	ld l,SpecialObject.angle		; $7069
	ld a,(hl)		; $706b
	xor $10			; $706c
	ld (hl),a		; $706e
	jr @initPositionSpeedAnimation		; $706f

@substate3:
	call itemDecCounter1		; $7071
	jr z,+			; $7074
	ld c,$02		; $7076
	jp objectUpdateSpeedZ_paramC		; $7078
+
	ld a,$ff		; $707b
	ld ($cfdf),a		; $707d
	ret			; $7080

;;
; @param	a	Angle
; @addr{7081}
_companionCutsceneFunc_7081:
	sub $04			; $7081
	and $07			; $7083
	ret nz			; $7085
	ld e,SpecialObject.angle		; $7086
	call convertAngleDeToDirection		; $7088
	dec a			; $708b
	and $03			; $708c
	ld h,d			; $708e
	ld l,SpecialObject.direction		; $708f
	ld (hl),a		; $7091
	ld l,SpecialObject.var36		; $7092
	add (hl)		; $7094
	jp specialObjectSetAnimation		; $7095

;;
; @addr{7098}
_companionCutsceneDecAngle:
	ld e,SpecialObject.angle		; $7098
	ld a,(de)		; $709a
	dec a			; $709b
	and $1f			; $709c
	ld (de),a		; $709e
	ret			; $709f


;;
; @addr{70a0}
specialObjectCode_linkInCutscene:
	ld e,SpecialObject.subid		; $70a0
	ld a,(de)		; $70a2
	rst_jumpTable			; $70a3
	.dw _linkCutscene0
	.dw _linkCutscene1
	.dw _linkCutscene2
	.dw _linkCutscene3
	.dw _linkCutscene4
	.dw _linkCutscene5
	.dw _linkCutscene6
	.dw _linkCutscene7
	.dw _linkCutscene8
	.dw _linkCutscene9
	.dw _linkCutsceneA
	.dw _linkCutsceneB
	.dw _linkCutsceneC


;;
; Opening cutscene with the triforce
; @addr{70be}
_linkCutscene0:
	ld e,Item.state		; $70be
	ld a,(de)		; $70c0
	rst_jumpTable			; $70c1
	.dw @state0
	.dw @state1

@state0:
	call _linkCutscene_initOam_setVisible_incState		; $70c6
	call objectSetVisible81		; $70c9
	xor a			; $70cc
	call specialObjectSetAnimation		; $70cd

@state1:
	ld e,SpecialObject.state2		; $70d0
	ld a,(de)		; $70d2
	rst_jumpTable			; $70d3
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4
	.dw @substate5
	.dw _linkCutscene0_substate6

@substate0:
	ld a,(wLinkAngle)		; $70e2
	rlca			; $70e5
	ld a,$00		; $70e6
	jp c,specialObjectSetAnimation		; $70e8

	ld h,d			; $70eb
	ld l,SpecialObject.yh		; $70ec
	ld a,(wGameKeysPressed)		; $70ee
	bit BTN_BIT_DOWN,a			; $70f1
	jr z,+			; $70f3
	inc (hl)		; $70f5
+
	bit BTN_BIT_UP,a			; $70f6
	jr z,+			; $70f8
	dec (hl)		; $70fa
+
	ld a,(hl)		; $70fb
	cp $40			; $70fc
	jp nc,specialObjectAnimate		; $70fe
	ld a,$01		; $7101
	ld (wTmpcbb9),a		; $7103
	ld a,SND_DROPESSENCE		; $7106
	call playSound		; $7108
	jp itemIncState2		; $710b

@substate1:
	ld a,(wTmpcbb9)		; $710e
	cp $02			; $7111
	ret nz			; $7113

	call itemIncState2		; $7114
	ld b,$04		; $7117
	call func_2d48		; $7119
	ld a,b			; $711c
	ld e,SpecialObject.counter1		; $711d
	ld (de),a		; $711f
	ld a,$04		; $7120
	jp specialObjectSetAnimation		; $7122

@substate2:
	call itemDecCounter1		; $7125
	jp nz,specialObjectAnimate		; $7128

	ld l,SpecialObject.speed		; $712b
	ld (hl),SPEED_20		; $712d
	ld b,$05		; $712f
	call func_2d48		; $7131
	ld a,b			; $7134
	ld e,SpecialObject.counter1		; $7135
	ld (de),a		; $7137
	jp itemIncState2		; $7138

@substate3:
	call itemDecCounter1		; $713b
	jp nz,++		; $713e

	call itemIncState2		; $7141
	ld b,$07		; $7144
	call func_2d48		; $7146
	ld a,b			; $7149
	ld e,SpecialObject.counter1		; $714a
	ld (de),a		; $714c
++
	ld hl,_linkCutscene_zOscillation0		; $714d
	jr _linkCutscene_oscillateZ		; $7150

@substate4:
	call itemDecCounter1		; $7152
	jp nz,_linkCutscene_oscillateZ_1		; $7155
	ld a,$03		; $7158
	ld (wTmpcbb9),a		; $715a
	call itemIncState2		; $715d

@substate5:
	ld a,(wTmpcbb9)		; $7160
	cp $06			; $7163
	jr nz,_linkCutscene_oscillateZ_1	; $7165

;;
; Creates the colored orb that appears under Link in the opening cutscene
; @addr{7167}
_linkCutscene_createGlowingOrb:
	ldbc INTERACID_SPARKLE, $06		; $7167
	call objectCreateInteraction		; $716a
	jr nz,+			; $716d
	ld l,Interaction.relatedObj1		; $716f
	ld a,SpecialObject.start		; $7171
	ldi (hl),a		; $7173
	ld (hl),d		; $7174
+
	call itemIncState2		; $7175
	ld a,$05		; $7178
	jp specialObjectSetAnimation		; $717a

;;
; @addr{717d}
_linkCutscene_oscillateZ_1:
	ld hl,_linkCutscene_zOscillation1		; $717d

;;
; @addr{7180}
_linkCutscene_oscillateZ:
	ld a,($cbb7)		; $7180
	and $07			; $7183
	jr nz,++		; $7185

	ld a,($cbb7)		; $7187
	and $38			; $718a
	swap a			; $718c
	rlca			; $718e
	rst_addAToHl			; $718f
	ld e,SpecialObject.zh		; $7190
	ld a,(hl)		; $7192
	ld b,a			; $7193
	ld a,(de)		; $7194
	add b			; $7195
	ld (de),a		; $7196
++
	jp specialObjectAnimate		; $7197

_linkCutscene_zOscillation0
	.db $ff $fe $fe $ff $00 $01 $01 $00

_linkCutscene_zOscillation1:
	.db $ff $ff $ff $00 $01 $01 $01 $00

_linkCutscene_zOscillation2:
	.db $02 $03 $04 $03 $02 $00 $ff $00


_linkCutscene0_substate6:
	ld e,SpecialObject.animParameter		; $71b2
	ld a,(de)		; $71b4
	inc a			; $71b5
	jr nz,+			; $71b6
	ld a,$07		; $71b8
	ld (wTmpcbb9),a		; $71ba
	ret			; $71bd
+
	call specialObjectAnimate		; $71be
	ld a,($cbb7)		; $71c1
	rrca			; $71c4
	jp nc,objectSetInvisible		; $71c5
	jp objectSetVisible		; $71c8


;;
; @addr{71cb}
_linkCutscene1:
	ld e,SpecialObject.state		; $71cb
	ld a,(de)		; $71cd
	rst_jumpTable			; $71ce
	.dw @state0
	.dw @state1

@state0:
	call _linkCutscene_initOam_setVisible_incState		; $71d3
	ld e,SpecialObject.counter1		; $71d6
	ld a,$78		; $71d8
	ld (de),a		; $71da
	xor a			; $71db
	ld e,SpecialObject.direction		; $71dc
	ld (de),a		; $71de
	call specialObjectSetAnimation		; $71df

@state1:
	ld e,SpecialObject.state2		; $71e2
	ld a,(de)		; $71e4
	rst_jumpTable			; $71e5
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw _linkCutsceneRet

@substate0:
	call itemDecCounter1		; $71f0
	ret nz			; $71f3
	call itemIncState2		; $71f4
	ld l,SpecialObject.speed		; $71f7
	ld (hl),SPEED_100		; $71f9
	ld l,SpecialObject.xh		; $71fb
	ld a,(hl)		; $71fd
	cp $48			; $71fe
	ld a,$00		; $7200
	jr z,++			; $7202
	ld a,$18		; $7204
	jr nc,++		; $7206
	ld a,$08		; $7208
++
	ld l,SpecialObject.angle		; $720a
	ld (hl),a		; $720c
	swap a			; $720d
	rlca			; $720f
	jp specialObjectSetAnimation		; $7210

@substate1:
	ld e,SpecialObject.xh		; $7213
	ld a,(de)		; $7215
	cp $48			; $7216
	jr nz,++		; $7218
	call itemIncState2		; $721a
	ld l,SpecialObject.counter1		; $721d
	ld (hl),$04		; $721f
	ret			; $7221
++
	call objectApplySpeed		; $7222
	jp specialObjectAnimate		; $7225

@substate2:
	call itemDecCounter1		; $7228
	ret nz			; $722b
	ld (hl),$2e		; $722c
	call itemIncState2		; $722e
	ld l,SpecialObject.angle		; $7231
	ld (hl),$00		; $7233
	xor a			; $7235
	jp specialObjectSetAnimation		; $7236

@substate3:
	call specialObjectAnimate		; $7239
	call objectApplySpeed		; $723c
	call itemDecCounter1		; $723f
	ret nz			; $7242
	ld hl,$cfd0		; $7243
	ld (hl),$01		; $7246
	ld a,SND_CLINK		; $7248
	call playSound		; $724a
	jp itemIncState2		; $724d

_linkCutsceneRet:
	ret			; $7250

;;
; @addr{7251}
_linkCutscene2:
	ld e,SpecialObject.state		; $7251
	ld a,(de)		; $7253
	rst_jumpTable			; $7254
	.dw @state0
	.dw @state1

@state0:
	call _linkCutscene_initOam_setVisible_incState		; $7259
	ld bc,$3838		; $725c
	call objectGetRelativeAngle		; $725f
	ld e,SpecialObject.angle		; $7262
	ld (de),a		; $7264
	call convertAngleDeToDirection		; $7265
	jp specialObjectSetAnimation		; $7268

@state1:
	ld e,SpecialObject.state2		; $726b
	ld a,(de)		; $726d
	rst_jumpTable			; $726e
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4
	.dw @substate5
	.dw @substate6
	.dw @substate7
	.dw @substate8

@substate0:
	ld a,($cfd0)		; $7281
	cp $02			; $7284
	ret nz			; $7286

	call itemIncState2		; $7287
	ld l,SpecialObject.yh		; $728a
	ldi a,(hl)		; $728c
	cp $48			; $728d
	ld a,$18		; $728f
	ld b,$04		; $7291
	jr z,++			; $7293
	ld a,$10		; $7295
	jr c,++			; $7297

	inc l			; $7299
	ld b,$01		; $729a
	ld a,(hl)		; $729c
	cp $38			; $729d
	ld a,$00		; $729f
	jr z,++			; $72a1
	ld a,$18		; $72a3
	jr nc,++		; $72a5
	ld a,$08		; $72a7
++
	ld l,SpecialObject.state2		; $72a9
	ld (hl),b		; $72ab
	ld l,SpecialObject.angle		; $72ac
	ld (hl),a		; $72ae
	swap a			; $72af
	rlca			; $72b1
	jp specialObjectSetAnimation		; $72b2

@substate1:
	call specialObjectAnimate		; $72b5
	call _linkCutscene_cpxTo38		; $72b8
	jp nz,objectApplySpeed		; $72bb

	call itemIncState2		; $72be
	ld l,SpecialObject.counter1		; $72c1
	ld (hl),$08		; $72c3
	ret			; $72c5

@substate2:
	ld b,$00		; $72c6

@label_72c8:
	call itemDecCounter1		; $72c8
	ret nz			; $72cb

@label_72cc:
	call itemIncState2		; $72cc
	ld l,SpecialObject.angle		; $72cf
	ld (hl),b		; $72d1
	ld a,b			; $72d2
	swap a			; $72d3
	rlca			; $72d5
	jp specialObjectSetAnimation		; $72d6

@substate3:
	call specialObjectAnimate		; $72d9
	call _linkCutscene_cpyTo48		; $72dc
	jp nz,objectApplySpeed		; $72df

@gotoState7:
	ld h,d			; $72e2
	ld l,SpecialObject.state2		; $72e3
	ld (hl),$07		; $72e5
	ld l,SpecialObject.counter1		; $72e7
	ld (hl),$3c		; $72e9
	xor a			; $72eb
	jp specialObjectSetAnimation		; $72ec

@substate4:
	call specialObjectAnimate		; $72ef
	call _linkCutscene_cpyTo48		; $72f2
	jp nz,objectApplySpeed		; $72f5
	call itemIncState2		; $72f8
	ld l,SpecialObject.counter1		; $72fb
	ld (hl),$08		; $72fd
	ret			; $72ff

@substate5:
	ld b,$18		; $7300
	jp @label_72c8		; $7302

@substate6:
	call specialObjectAnimate		; $7305
	call _linkCutscene_cpxTo38		; $7308
	jp nz,objectApplySpeed		; $730b
	jr @gotoState7			; $730e

@substate7:
	call itemDecCounter1		; $7310
	ret nz			; $7313
	ld (hl),$10		; $7314
	ld b,$00		; $7316
	call @label_72cc		; $7318
	ld hl,$cfd0		; $731b
	ld (hl),$03		; $731e
	ret			; $7320

@substate8:
	ret			; $7321

;;
; @addr{7322}
_linkCutscene3:
	ld e,SpecialObject.state		; $7322
	ld a,(de)		; $7324
	rst_jumpTable			; $7325
.dw @state0
.dw @state1

@state0:
	call _linkCutscene_initOam_setVisible_incState		; $732a
	ld a,$01		; $732d
	jp specialObjectSetAnimation		; $732f

@state1:
	ld e,SpecialObject.state2		; $7332
	ld a,(de)		; $7334
	rst_jumpTable			; $7335
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4
	.dw @substate5
	.dw @substate6
	.dw @substate7
	.dw @substate8
	.dw @substate9

@substate0:
	ld a,($cfd0)		; $734a
	cp $09			; $734d
	ret nz			; $734f

	call itemIncState2		; $7350
	ld l,SpecialObject.yh		; $7353
	ld a,$30		; $7355
	ldi (hl),a		; $7357
	inc l			; $7358
	ld a,$78		; $7359
	ld (hl),a		; $735b
	ld a,$01		; $735c
	jp specialObjectSetAnimation		; $735e

@substate1:
	ld a,($cfd0)		; $7361
	cp $0a			; $7364
	ret nz			; $7366
	call itemIncState2		; $7367
	ld l,SpecialObject.counter1		; $736a
	ld (hl),$1e		; $736c
	ret			; $736e

@substate2:
	call itemDecCounter1		; $736f
	ret nz			; $7372
	call itemIncState2		; $7373
	xor a			; $7376
	jp specialObjectSetAnimation		; $7377

@substate3:
	ld b,$0e		; $737a
	ld c,$02		; $737c
	ld a,($cfd0)		; $737e
	cp b			; $7381
	ret nz			; $7382
	call itemIncState2		; $7383
	ld a,c			; $7386
	jp specialObjectSetAnimation		; $7387

@substate4:
	ld a,($cfd0)		; $738a
	cp $11			; $738d
	ret nz			; $738f

	call itemIncState2		; $7390
	ld l,SpecialObject.angle		; $7393
	ld (hl),$18		; $7395
	ld l,SpecialObject.speed		; $7397
	ld (hl),SPEED_180		; $7399
	ld l,SpecialObject.counter1		; $739b
	ld (hl),$16		; $739d
	ld a,SND_UNKNOWN5		; $739f
	call playSound		; $73a1
	ld a,$03		; $73a4
	jp specialObjectSetAnimation		; $73a6

@substate5:
	call _linkCutscene_animateAndDecCounter1		; $73a9
	jp nz,objectApplySpeed		; $73ac
	call itemIncState2		; $73af
	ld l,SpecialObject.counter1		; $73b2
	ld (hl),$06		; $73b4

@substate9:
	ret			; $73b6

@substate6:
	call itemDecCounter1		; $73b7
	ret nz			; $73ba
	ld (hl),$08		; $73bb
	ld l,SpecialObject.angle		; $73bd
	ld (hl),$10		; $73bf
	ld a,$02		; $73c1
	ld l,SpecialObject.direction		; $73c3
	ld (hl),a		; $73c5
	call specialObjectSetAnimation		; $73c6
	jp itemIncState2		; $73c9

@substate7:
	call _linkCutscene_animateAndDecCounter1		; $73cc
	jp nz,objectApplySpeed		; $73cf
	ld a,SND_UNKNOWN5		; $73d2
	call playSound		; $73d4
	jp itemIncState2		; $73d7

@substate8:
	ld a,($cfd2)		; $73da
	or a			; $73dd
	jr z,_linkCutsceneFunc_73e8			; $73de

	ld a,$03		; $73e0
	call specialObjectSetAnimation		; $73e2
	jp itemIncState2		; $73e5

;;
; @addr{73e8}
_linkCutsceneFunc_73e8:
	ld a,(wFrameCounter)		; $73e8
	and $07			; $73eb
	ret nz			; $73ed

	callab func_0a_7877		; $73ee
	call objectGetRelativeAngle		; $73f6
	call convertAngleToDirection		; $73f9
	ld h,d			; $73fc
	ld l,SpecialObject.direction		; $73fd
	cp (hl)			; $73ff
	ret z			; $7400
	ld (hl),a		; $7401
	jp specialObjectSetAnimation		; $7402

;;
; @addr{7405}
_linkCutscene4:
	ld e,SpecialObject.state		; $7405
	ld a,(de)		; $7407
	rst_jumpTable			; $7408
	.dw @state0
	.dw @state1

@state0:
	call _linkCutscene_initOam_setVisible_incState		; $740d
	ld l,SpecialObject.yh		; $7410
	ld a,$38		; $7412
	ldi (hl),a		; $7414
	inc l			; $7415
	ld a,$58		; $7416
	ld (hl),a		; $7418
	xor a			; $7419
	jp specialObjectSetAnimation		; $741a

@state1:
	ld e,SpecialObject.state2		; $741d
	ld a,(de)		; $741f
	rst_jumpTable			; $7420
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4
	.dw @substate5

@substate0:
	ld a,($cfd0)		; $742d
	cp $1f			; $7430
	ret nz			; $7432
	jp itemIncState2		; $7433

@substate1:
	ld a,($cfd0)		; $7436
	cp $20			; $7439
	jp nz,_linkCutsceneFunc_73e8		; $743b
	call itemIncState2		; $743e
	ld l,SpecialObject.counter1		; $7441
	ld (hl),$50		; $7443
	ret			; $7445

@substate2:
	call itemDecCounter1		; $7446
	ret nz			; $7449
	ld (hl),$30		; $744a
	ld l,SpecialObject.speed		; $744c
	ld (hl),SPEED_100		; $744e
	ld b,$10		; $7450
	jp _linkCutscene2@label_72cc		; $7452

@substate3:
	call _linkCutscene_animateAndDecCounter1		; $7455
	jp nz,objectApplySpeed		; $7458
	ld (hl),$08		; $745b
	jp itemIncState2		; $745d

@substate4:
	call itemDecCounter1		; $7460
	ret nz			; $7463
	ld (hl),$10		; $7464
	ld b,$18		; $7466
	jp _linkCutscene2@label_72cc		; $7468

@substate5:
	call _linkCutscene_animateAndDecCounter1		; $746b
	jp nz,objectApplySpeed		; $746e
	ld a,$21		; $7471
	ld ($cfd0),a		; $7473
	ld a,$81		; $7476
	ld (wMenuDisabled),a		; $7478
	ld (wDisabledObjects),a		; $747b
	ld e,SpecialObject.direction		; $747e
	ld a,$03		; $7480
	ld (de),a		; $7482
	lda SPECIALOBJECTID_LINK			; $7483
	jp setLinkIDOverride		; $7484

;;
; @addr{7487}
_linkCutscene_cpyTo48:
	ld e,SpecialObject.yh		; $7487
	ld a,(de)		; $7489
	cp $48			; $748a
	ret			; $748c

;;
; @addr{748d}
_linkCutscene_cpxTo38:
	ld e,SpecialObject.xh		; $748d
	ld a,(de)		; $748f
	cp $38			; $7490
	ret			; $7492

;;
; @addr{7493}
_linkCutscene_initOam_setVisible_incState:
	callab bank5.specialObjectSetOamVariables		; $7493
	call objectSetVisiblec1		; $749b
	jp itemIncState		; $749e

;;
; @addr{74a1}
_linkCutscene_animateAndDecCounter1:
	call specialObjectAnimate		; $74a1
	jp itemDecCounter1		; $74a4

;;
; @addr{74a7}
_linkCutscene5:
	ld e,SpecialObject.state		; $74a7
	ld a,(de)		; $74a9
	rst_jumpTable			; $74aa
	.dw @state0
	.dw @state1

@state0:
	call _linkCutscene_initOam_setVisible_incState		; $74af
	ld l,SpecialObject.speed		; $74b2
	ld (hl),SPEED_100		; $74b4
	ld l,SpecialObject.var3d		; $74b6
	ld (hl),$00		; $74b8
	ld l,SpecialObject.direction		; $74ba
	ld (hl),$ff		; $74bc

@state1:
	call _linkCutscene_updateAngleOnPath		; $74be
	jr z,+			; $74c1
	call specialObjectAnimate		; $74c3
	jp objectApplySpeed		; $74c6
+
	ld a,SPECIALOBJECTID_LINK		; $74c9
	jp setLinkIDOverride		; $74cb

;;
; @addr{74ce}
_linkCutscene6:
	ld e,SpecialObject.state		; $74ce
	ld a,(de)		; $74d0
	rst_jumpTable			; $74d1
	.dw @state0
	.dw @state1

@state0:
	call _linkCutscene_initOam_setVisible_incState		; $74d6
	ld l,SpecialObject.speed		; $74d9
	ld (hl),SPEED_80		; $74db
	ld b,$16		; $74dd
	ld l,SpecialObject.angle		; $74df
	ld a,(hl)		; $74e1
	cp $08			; $74e2
	jr z,+			; $74e4
	ld b,$15		; $74e6
+
	ld a,b			; $74e8
	call specialObjectSetAnimation		; $74e9

@state1:
	ld e,SpecialObject.state2		; $74ec
	ld a,(de)		; $74ee
	rst_jumpTable			; $74ef
	.dw @substate0
	.dw @substate1
	.dw @substate2

@substate0:
	call specialObjectAnimate		; $74f6
	call getThisRoomFlags		; $74f9
	and $c0			; $74fc
	jp z,objectApplySpeed		; $74fe
	jp itemIncState2		; $7501

@substate1:
	ld a,($cfd0)		; $7504
	cp $07			; $7507
	ret nz			; $7509
	call itemIncState2		; $750a
	ld a,$02		; $750d
	jp specialObjectSetAnimation		; $750f

@substate2:
	ret			; $7512

;;
; @addr{7513}
_linkCutscene7:
	ld e,SpecialObject.state		; $7513
	ld a,(de)		; $7515
	rst_jumpTable			; $7516
	.dw @state0
	.dw @state1

@state0:
	call _linkCutscene_initOam_setVisible_incState		; $751b
	ld l,SpecialObject.counter1		; $751e
	ld (hl),$f0		; $7520
	ld a,$14		; $7522
	jp specialObjectSetAnimation		; $7524

@state1:
	call specialObjectAnimate		; $7527
	call itemDecCounter1		; $752a
	ret nz			; $752d
	lda SPECIALOBJECTID_LINK			; $752e
	call setLinkIDOverride		; $752f
	ld l,SpecialObject.direction		; $7532
	ld (hl),$02		; $7534
	ld a,$01		; $7536
	ld (wUseSimulatedInput),a		; $7538
	ld (wMenuDisabled),a		; $753b
	ret			; $753e

;;
; @addr{753f}
_linkCutscene8:
	ld e,SpecialObject.state		; $753f
	ld a,(de)		; $7541
	rst_jumpTable			; $7542
	.dw @state0
	.dw @state1

@state0:
	call _linkCutscene_initOam_setVisible_incState		; $7547
	ld l,SpecialObject.yh		; $754a
	ld (hl),$68		; $754c
	ld l,SpecialObject.xh		; $754e
	ld (hl),$50		; $7550
	ld a,$00		; $7552
	call specialObjectSetAnimation		; $7554
	jp objectSetInvisible		; $7557

@state1:
	ld e,SpecialObject.state2		; $755a
	ld a,(de)		; $755c
	rst_jumpTable			; $755d
	.dw @substate0
	.dw @substate1

@substate0:
	ld a,($cfd0)		; $7562
	cp $03			; $7565
	jr z,+			; $7567
	ld a,($cfd0)		; $7569
	cp $01			; $756c
	ret nz			; $756e
+
	call itemIncState2		; $756f
	jp objectSetVisiblec2		; $7572

@substate1:
	ret			; $7575

;;
; @addr{7576}
_linkCutscene9:
	ld e,SpecialObject.state		; $7576
	ld a,(de)		; $7578
	rst_jumpTable			; $7579
	.dw @state0
	.dw @state1

@state0:
	call _linkCutscene_initOam_setVisible_incState		; $757e
	ld a,$02		; $7581
	call specialObjectSetAnimation		; $7583
	jp objectSetInvisible		; $7586

@state1:
	ld e,SpecialObject.state2		; $7589
	ld a,(de)		; $758b
	rst_jumpTable			; $758c
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4

@substate0:
	ld a,($cfc0)		; $7597
	cp $01			; $759a
	ret nz			; $759c
	call itemIncState2		; $759d
	jp objectSetVisible82		; $75a0

@substate1:
	ld a,($cfc0)		; $75a3
	cp $03			; $75a6
	ret nz			; $75a8
	call itemIncState2		; $75a9

@substate2:
	ld a,($cfc0)		; $75ac
	cp $06			; $75af
	jp nz,_linkCutsceneFunc_73e8		; $75b1

	call itemIncState2		; $75b4
	ld bc,$fe40		; $75b7
	call objectSetSpeedZ		; $75ba
	ld a,$0d		; $75bd
	jp specialObjectSetAnimation		; $75bf

@substate3:
	ld c,$20		; $75c2
	call objectUpdateSpeedZ_paramC		; $75c4
	ret nz			; $75c7

	call itemIncState2		; $75c8
	ld l,SpecialObject.counter1		; $75cb
	ld (hl),$78		; $75cd
	ld l,SpecialObject.animCounter		; $75cf
	ld (hl),$01		; $75d1
	ret			; $75d3

@substate4:
	call itemDecCounter1		; $75d4
	jp nz,specialObjectAnimate		; $75d7
	ld hl,$cfdf		; $75da
	ld (hl),$ff		; $75dd
	ret			; $75df

;;
; Link being kissed by Zelda in ending cutscene
;
; @addr{75e0}
_linkCutsceneA:
	ld e,SpecialObject.state		; $75e0
	ld a,(de)		; $75e2
	rst_jumpTable			; $75e3
	.dw @state0
	.dw @state1

@state0:
	call _linkCutscene_initOam_setVisible_incState		; $75e8
	call objectSetInvisible		; $75eb

	call @checkShieldEquipped		; $75ee
	ld a,$0b		; $75f1
	jr nz,+			; $75f3
	ld a,$0f		; $75f5
+
	jp specialObjectSetAnimation		; $75f7

;;
; @param[out]	zflag	Set if shield equipped
; @addr{75fa}
@checkShieldEquipped:
	ld hl,wInventoryB		; $75fa
	ld a,ITEMID_SHIELD		; $75fd
	cp (hl)			; $75ff
	ret z			; $7600
	inc l			; $7601
	cp (hl)			; $7602
	ret			; $7603

@state1:
	ld e,SpecialObject.state2		; $7604
	ld a,(de)		; $7606
	rst_jumpTable			; $7607
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate0:
	ld a,($cfc0)		; $7610
	cp $01			; $7613
	ret nz			; $7615

	call itemIncState2		; $7616
	jp objectSetVisible82		; $7619

@substate1:
	ld a,($cfc0)		; $761c
	cp $07			; $761f
	ret nz			; $7621

	call itemIncState2		; $7622
	call @checkShieldEquipped		; $7625
	ld a,$10		; $7628
	jr nz,+			; $762a
	inc a			; $762c
+
	jp specialObjectSetAnimation		; $762d

@substate2:
	ld a,($cfc0)		; $7630
	cp $08			; $7633
	ret nz			; $7635

	call itemIncState2		; $7636
	ld l,SpecialObject.counter1		; $7639
	ld (hl),$68		; $763b
	inc l			; $763d
	ld (hl),$01		; $763e
	ld b,$02		; $7640
--
	call getFreeInteractionSlot		; $7642
	jr nz,@@setAnimation	; $7645
	ld (hl),INTERACID_KISS_HEART		; $7647
	inc l			; $7649
	ld a,b			; $764a
	dec a			; $764b
	ld (hl),a		; $764c
	call objectCopyPosition		; $764d
	dec b			; $7650
	jr nz,--		; $7651

@@setAnimation:
	ld a,$12		; $7653
	jp specialObjectSetAnimation		; $7655

@substate3:
	call specialObjectAnimate		; $7658
	ld h,d			; $765b
	ld l,SpecialObject.counter1		; $765c
	call decHlRef16WithCap		; $765e
	ret nz			; $7661

	ld hl,$cfc0		; $7662
	ld (hl),$09		; $7665
	ret			; $7667

;;
; Cutscene played on starting a new game ("accept our quest, hero")
;
; @addr{7668}
_linkCutsceneB:
	ld e,SpecialObject.state		; $7668
	ld a,(de)		; $766a
	rst_jumpTable			; $766b
	.dw @state0
	.dw @state1

@state0:
	call _linkCutscene_initOam_setVisible_incState		; $7670
	call objectSetVisible81		; $7673

	ld l,SpecialObject.counter1		; $7676
	ld (hl),$2c		; $7678
	inc hl			; $767a
	ld (hl),$01		; $767b
	ld l,SpecialObject.yh		; $767d
	ld (hl),$d0		; $767f
	ld l,SpecialObject.xh		; $7681
	ld (hl),$50		; $7683

	ld a,$08		; $7685
	call specialObjectSetAnimation		; $7687
	xor a			; $768a
	ld (wTmpcbb9),a		; $768b

	ldbc INTERACID_SPARKLE, $0d		; $768e
	call objectCreateInteraction		; $7691
	jr nz,@state1	; $7694
	ld l,Interaction.relatedObj1		; $7696
	ld a,SpecialObject.start		; $7698
	ldi (hl),a		; $769a
	ld (hl),d		; $769b

@state1:
	ld a,(wFrameCounter)		; $769c
	ld ($cbb7),a		; $769f
	ld e,SpecialObject.state2		; $76a2
	ld a,(de)		; $76a4
	rst_jumpTable			; $76a5
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate0:
	call _linkCutscene_oscillateZ_2		; $76ae
	ld hl,w1Link.counter1		; $76b1
	call decHlRef16WithCap		; $76b4
	ret nz			; $76b7

	ld (hl),$3c		; $76b8
	jp itemIncState2		; $76ba

@substate1:
	call _linkCutscene_oscillateZ_2		; $76bd
	call itemDecCounter1		; $76c0
	ret nz			; $76c3

	call itemIncState2		; $76c4
	ld bc,TX_1213		; $76c7
	jp showText		; $76ca

@substate2:
	ld hl,_linkCutscene_zOscillation1		; $76cd
	call _linkCutscene_oscillateZ		; $76d0
	ld a,(wTextIsActive)		; $76d3
	or a			; $76d6
	ret nz			; $76d7

	ld a,$06		; $76d8
	ld (wTmpcbb9),a		; $76da
	ld a,SND_FAIRYCUTSCENE		; $76dd
	call playSound		; $76df
	jp _linkCutscene_createGlowingOrb		; $76e2

@substate3:
	ld e,SpecialObject.animParameter		; $76e5
	ld a,(de)		; $76e7
	inc a			; $76e8
	jr nz,+			; $76e9
	ld a,$07		; $76eb
	ld (wTmpcbb9),a		; $76ed
	ret			; $76f0
+
	call specialObjectAnimate		; $76f1
	ld a,(wFrameCounter)		; $76f4
	rrca			; $76f7
	jp nc,objectSetInvisible		; $76f8
	jp objectSetVisible		; $76fb

;;
; @addr{76fe}
_linkCutsceneC:
	ld e,SpecialObject.state		; $76fe
	ld a,(de)		; $7700
	rst_jumpTable			; $7701
	.dw @state0
	.dw _linkCutsceneRet

@state0:
	call _linkCutscene_initOam_setVisible_incState		; $7706
	ld bc,$f804		; $7709
	ld a,$ff		; $770c
	call objectCreateExclamationMark		; $770e
	ld l,Interaction.subid		; $7711
	ld (hl),$01		; $7713
	ld a,$06		; $7715
	jp specialObjectSetAnimation		; $7717

;;
; @addr{771a}
_linkCutscene_oscillateZ_2:
	ld hl,_linkCutscene_zOscillation2		; $771a
	jp _linkCutscene_oscillateZ		; $771d

;;
; Update Link's angle to follow a certain path. Which path it is depends on var03 (value
; from 0-2).
;
; @param[out]	zflag	Set if reached the destination
; @addr{7720}
_linkCutscene_updateAngleOnPath:
	ld e,SpecialObject.var03		; $7720
	ld a,(de)		; $7722
	ld hl,@paths		; $7723
	rst_addDoubleIndex			; $7726
	ldi a,(hl)		; $7727
	ld h,(hl)		; $7728
	ld l,a			; $7729

	ld e,SpecialObject.var3d		; $772a
	ld a,(de)		; $772c
	add a			; $772d
	rst_addAToHl			; $772e
	ldi a,(hl)		; $772f
	cp $ff			; $7730
	ret z			; $7732

	or a			; $7733
	jr nz,@checkX		; $7734

	ld e,SpecialObject.yh		; $7736
	ld a,(de)		; $7738
	sub (hl)		; $7739
	ld b,$00		; $773a
	jr nc,+			; $773c
	ld b,$02		; $773e
+
	jr nz,@updateDirection	; $7740
	jr @next		; $7742

@checkX:
	ld e,SpecialObject.xh		; $7744
	ld a,(de)		; $7746
	sub (hl)		; $7747
	ld b,$03		; $7748
	jr nc,+			; $774a
	ld b,$01		; $774c
+
	jr nz,@updateDirection	; $774e

@next:
	ld h,d			; $7750
	ld l,SpecialObject.var3d		; $7751
	inc (hl)		; $7753
	call @updateDirection		; $7754
	jr _linkCutscene_updateAngleOnPath		; $7757

;;
; @param	b	Direction value
; @param[out]	zflag	Unset
; @addr{7759}
@updateDirection:
	ld e,SpecialObject.direction		; $7759
	ld a,(de)		; $775b
	cp b			; $775c
	jr z,@ret		; $775d

	ld a,b			; $775f
	ld (de),a		; $7760
	call specialObjectSetAnimation		; $7761
	ld e,SpecialObject.direction		; $7764
	ld a,(de)		; $7766
	swap a			; $7767
	rrca			; $7769
	ld e,SpecialObject.angle		; $776a
	ld (de),a		; $776c

@ret:
	or d			; $776d
	ret			; $776e


@paths:
	.dw @@path0
	.dw @@path1
	.dw @@path2

; Data format:
;  b0: 0 for y, 1 for x
;  b1: Target position to walk to

@@path0: ; Just saved the maku sapling, moving toward her
	.db $00 $38
	.db $01 $50
	.db $00 $38
	.db $ff

@@path1: ; Just freed the goron elder, moving toward him
	.db $01 $38
	.db $00 $60
	.db $ff

@@path2: ; Funny joke cutscene in trading sequence
	.db $00 $48
	.db $ff


.include "build/data/signText.s"


; @addr{7818}
_breakableTileCollisionTable:
	.dw _breakableTileCollision0Data
	.dw _breakableTileCollision1Data
	.dw _breakableTileCollision2Data
	.dw _breakableTileCollision3Data
	.dw _breakableTileCollision4Data
	.dw _breakableTileCollision5Data

; 1st byte is the tile index, 2nd is an index for "_breakableTileModes".

; @addr{7824}
_breakableTileCollision0Data:
_breakableTileCollision4Data:
	.db $da $32
	.db $f8 $00
	.db $f2 $0d
	.db $c0 $07
	.db $c1 $08
	.db $c2 $09
	.db $c3 $0b
	.db $c4 $0a
	.db $c5 $01
	.db $c6 $04
	.db $c7 $03
	.db $c8 $06
	.db $c9 $02
	.db $ca $05
	.db $cb $12
	.db $cc $13
	.db $cd $0e
	.db $ce $0f
	.db $cf $10
	.db $d1 $0c
	.db $db $14
	.db $04 $15
	.db $01 $11
	.db $10 $11
	.db $11 $11
	.db $12 $11
	.db $13 $11
	.db $14 $11
	.db $15 $11
	.db $16 $11
	.db $17 $11
	.db $18 $11
	.db $19 $11
	.db $1a $11
	.db $1b $11
	.db $20 $11
	.db $21 $11
	.db $22 $11
	.db $23 $11
	.db $24 $11
	.db $25 $11
	.db $26 $11
	.db $27 $11
	.db $28 $11
	.db $29 $11
	.db $2a $11
	.db $2b $11
	.db $30 $11
	.db $31 $11
	.db $32 $11
	.db $33 $11
	.db $34 $11
	.db $35 $11
	.db $36 $11
	.db $37 $11
	.db $38 $11
	.db $39 $11
	.db $3a $11
	.db $3b $11
	.db $af $11
	.db $bf $11
	.db $00
; @addr{789f}
_breakableTileCollision1Data:
_breakableTileCollision2Data:
_breakableTileCollision5Data:
	.db $da $32
	.db $f2 $16
	.db $f8 $2a
	.db $20 $17
	.db $21 $18
	.db $22 $19
	.db $23 $1a
	.db $ef $2b
	.db $11 $1b
	.db $12 $1c
	.db $10 $1d
	.db $13 $1e
	.db $1f $1f
	.db $30 $20
	.db $31 $21
	.db $32 $22
	.db $33 $23
	.db $38 $24
	.db $39 $25
	.db $3a $26
	.db $3b $27
	.db $16 $28
	.db $15 $29
	.db $db $2d
	.db $24 $2c
	.db $68 $2e
	.db $69 $2f
	.db $00
; @addr{78d6}
_breakableTileCollision3Data:
	.db $da $32
	.db $12 $30
	.db $71 $31
	.db $00

; Data format:
;  First 3 parameters are ways the tile can be broken.
;  4th parameter:
;   Dunno
;  5th parameter:
;   Bits 0-3: the id of the interaction that should be created when the
;             object is destroyed (ie. bush destroying animation).
;   Bit 4:    sets the subid (0 or 1) which tells it whether to flicker.
;   Bit 6:    whether to play the discovery sound.
;   Bit 7:    set if the game should call updateRoomFlagsForBrokenTile on breakage
;  6th parameter:
;   The tile it should turn into when broken, or $00 for no change.
.macro m_BreakableTileData
	.if \3 > $f
	.fail
	.endif
	.if \4 > $f
	.fail
	.endif

	.db \1 \2
	.db \3 | (\4<<4)
	.db \5 \6
.endm

; @addr{78dd}
_breakableTileModes:
	m_BreakableTileData %10010110 %00110000 %0010 $1 $10 $3a ; $00
	m_BreakableTileData %10110111 %10110001 %0110 $1 $00 $3a ; $01
	m_BreakableTileData %10110111 %10110001 %0110 $0 $c0 $d7 ; $02
	m_BreakableTileData %10110111 %10110001 %0110 $0 $c0 $d2 ; $03
	m_BreakableTileData %10110111 %10110001 %0110 $0 $c0 $dc ; $04
	m_BreakableTileData %10110111 %10110001 %0110 $0 $00 $f3 ; $05
	m_BreakableTileData %10110111 %10110001 %0110 $0 $00 $3a ; $06
	m_BreakableTileData %00100001 %00000000 %0000 $4 $06 $3a ; $07
	m_BreakableTileData %00100001 %00000000 %0000 $0 $c6 $dc ; $08
	m_BreakableTileData %00100001 %00000000 %0000 $0 $c6 $d2 ; $09
	m_BreakableTileData %00100001 %00000000 %0000 $0 $c6 $d7 ; $0a
	m_BreakableTileData %00100001 %00000000 %0000 $0 $06 $3a ; $0b
	m_BreakableTileData %00110000 %10000000 %0000 $0 $c6 $dd ; $0c
	m_BreakableTileData %10101101 %00010001 %0000 $7 $0c $3a ; $0d
	m_BreakableTileData %01000000 %10000000 %0111 $4 $0a $3a ; $0e
	m_BreakableTileData %00000000 %00010000 %0000 $7 $1f $3a ; $0f
	m_BreakableTileData %00000000 %00010000 %0000 $0 $df $dc ; $10
	m_BreakableTileData %01000000 %00000000 %0000 $9 $0a $1c ; $11
	m_BreakableTileData %01000000 %00000000 %0000 $0 $ca $d2 ; $12
	m_BreakableTileData %01000000 %00000000 %0000 $0 $0a $d7 ; $13
	m_BreakableTileData %00100000 %00000001 %0000 $0 $06 $3a ; $14
	m_BreakableTileData %00010110 %10010000 %1111 $0 $00 $3b ; $15
	m_BreakableTileData %10101101 %00010001 %0000 $7 $0c $a0 ; $16
	m_BreakableTileData %10110111 %00110001 %0100 $1 $00 $a0 ; $17
	m_BreakableTileData %10110111 %00110001 %0100 $0 $00 $a0 ; $18
	m_BreakableTileData %10110111 %00110001 %0100 $0 $40 $45 ; $19
	m_BreakableTileData %10110111 %00110001 %0100 $0 $00 $f3 ; $1a
	m_BreakableTileData %00100101 %00000001 %0000 $0 $06 $a0 ; $1b
	m_BreakableTileData %00100101 %00000001 %0000 $0 $46 $45 ; $1c
	m_BreakableTileData %00100101 %00000001 %0000 $2 $06 $a0 ; $1d
	m_BreakableTileData %00100101 %00000001 %0000 $0 $46 $0d ; $1e
	m_BreakableTileData %00110000 %00000000 %0000 $0 $06 $a0 ; $1f
	m_BreakableTileData %00110000 %00000000 %0000 $0 $c6 $34 ; $20
	m_BreakableTileData %00110000 %00000000 %0000 $0 $c6 $35 ; $21
	m_BreakableTileData %00110000 %00000000 %0000 $0 $c6 $36 ; $22
	m_BreakableTileData %00110000 %00000000 %0000 $0 $c6 $37 ; $23
	m_BreakableTileData %00110000 %00000000 %0000 $0 $c6 $34 ; $24
	m_BreakableTileData %00110000 %00000000 %0000 $0 $c6 $35 ; $25
	m_BreakableTileData %00110000 %00000000 %0000 $0 $c6 $36 ; $26
	m_BreakableTileData %00110000 %00000000 %0000 $0 $c6 $37 ; $27
	m_BreakableTileData %00111111 %00010000 %0000 $0 $06 $a0 ; $28
	m_BreakableTileData %00100001 %00000000 %0000 $4 $06 $4c ; $29
	m_BreakableTileData %10010110 %00110000 %0010 $0 $10 $ef ; $2a
	m_BreakableTileData %01000000 %00000000 %0000 $c $0a $4c ; $2b
	m_BreakableTileData %01000000 %00000000 %0000 $0 $0a $a1 ; $2c
	m_BreakableTileData %00100000 %00000001 %0000 $0 $06 $a0 ; $2d
	m_BreakableTileData %00000000 %00010000 %0000 $0 $df $35 ; $2e
	m_BreakableTileData %00000000 %00010000 %0000 $0 $df $37 ; $2f
	m_BreakableTileData %00110000 %00000000 %0000 $0 $06 $01 ; $30
	m_BreakableTileData %00100101 %00000001 %0000 $0 $06 $01 ; $31
	m_BreakableTileData %00111110 %10000000 %1011 $0 $1f $00 ; $32


;;
; @addr{79dc}
specialObjectLoadAnimationFrameToBuffer:
	ld hl,w1Companion.visible		; $79dc
	bit 7,(hl)		; $79df
	ret z			; $79e1

	ld l,<w1Companion.var32		; $79e2
	ld a,(hl)		; $79e4
	call _getSpecialObjectGraphicsFrame		; $79e5
	ret z			; $79e8

	ld a,l			; $79e9
	and $f0			; $79ea
	ld l,a			; $79ec
	ld de,w6SpecialObjectGfxBuffer|(:w6SpecialObjectGfxBuffer)		; $79ed
	jp copy256BytesFromBank		; $79f0


	; Garbage data/code

.ifdef BUILD_VANILLA

	m_BreakableTileData %00000000 %00010000 %0000 $0 $df $37 ; $2f
	m_BreakableTileData %00110000 %00000000 %0000 $0 $06 $01 ; $30
	m_BreakableTileData %00100101 %00000001 %0000 $0 $06 $01 ; $31
	m_BreakableTileData %00111110 %10000000 %1011 $0 $1f $00 ; $32


_fake_specialObjectLoadAnimationFrameToBuffer:
	ld hl,w1Companion.visible		; $7a07
	bit 7,(hl)		; $7a0a
	ret z			; $7a0c

	ld l,<w1Companion.var32		; $7a0d
	ld a,(hl)		; $7a0f
	call $4524		; $7a10
	ret z			; $7a13

	ld a,l			; $7a14
	and $f0			; $7a15
	ld l,a			; $7a17
	ld de,w6SpecialObjectGfxBuffer|(:w6SpecialObjectGfxBuffer)		; $7a18
	jp $3f17		; $7a1b


	ld a,(hl)		; $7a1e
	ret z			; $7a1f

	ld l,<w1Companion.var32		; $7a20
	ld a,(hl)		; $7a22
	call $4524		; $7a23
	ret z			; $7a26

	ld a,l			; $7a27
	and $f0			; $7a28
	ld l,a			; $7a2a
	ld de,w6SpecialObjectGfxBuffer|(:w6SpecialObjectGfxBuffer)		; $7a2b
	jp $3f31		; $7a2e
.endif

.ends

.BANK $07 SLOT 1
.ORG 0

 m_section_superfree "File_Management" namespace "fileManagement"

;;
; @param c What operation to do on the file
; @param hActiveFileSlot File index
; @addr{4000}
fileManagementFunction:
	ld a,c			; $4000
	rst_jumpTable			; $4001
	.dw _initializeFile
	.dw _saveFile
	.dw _loadFile
	.dw _eraseFile

;;
; @addr{400a}
_initializeFile:
	ld hl,_initialFileVariables		; $400a
	call _initializeFileVariables		; $400d

	; Load in a: wFileIsHeroGame (bit 1), wFileIsLinkedGame (bit 0)
	ld hl,wFileIsHeroGame		; $4010
	ldd a,(hl)		; $4013
	add a			; $4014
	add (hl)		; $4015
	push af			; $4016

	; Initialize data differently based on whether it's a linked or hero game
	ld hl,_initialFileVariablesTable		; $4017
	rst_addDoubleIndex			; $401a
	ldi a,(hl)		; $401b
	ld h,(hl)		; $401c
	ld l,a			; $401d
	call _initializeFileVariables		; $401e

	; Clear unappraised rings
	pop af			; $4021
	ld c,a			; $4022
	ld hl,wUnappraisedRings		; $4023
	ld b,$40		; $4026
	ld a,$ff		; $4028
	call fillMemory		; $402a

	; Clear ring box contents
	ld hl,wRingBoxContents		; $402d
	ld b,$06		; $4030
	ld a,$ff		; $4032
	call fillMemory		; $4034

	; If hero game, give victory ring
	ld a,c			; $4037
	cp $02			; $4038
	jr nz,++		; $403a

	ld hl,wObtainedTreasureFlags		; $403c
	ld a,TREASURE_RING		; $403f
	call setFlag		; $4041
	ld a,VICTORY_RING | $40		; $4044
	ld (wUnappraisedRings),a		; $4046
++
	callab initializeChildOnGameStart		; $4049
	callab initializeVinePositions		; $4051

;;
; In addition to saving, this is called after creating a file, as well as when it's about
; to be loaded (for some reason)
; @addr{4059}
_saveFile:
	; Write $01 here for "ages"
	ld hl,wWhichGame		; $4059
	ld (hl),$01		; $405c

	; String to verify save integrity (unique between ages/seasons)
	ld hl,wSavefileString		; $405e
	ld de,_saveVerificationString		; $4061
	ld b,$08		; $4064
	call copyMemoryReverse		; $4066

	; Calculate checksum
	ld l,<wFileStart		; $4069
	call _calculateFileChecksum		; $406b
	ld (hl),e		; $406e
	inc l			; $406f
	ld (hl),d		; $4070

	; Save file
	ld l,<wFileStart		; $4071
	call _getFileAddress1		; $4073
	ld e,c			; $4076
	ld d,b			; $4077
	call _copyFileFromHlToDe		; $4078

	; Save file to backup slot?
	call _getFileAddress2		; $407b
	ld e,c			; $407e
	ld d,b			; $407f
	call _copyFileFromHlToDe		; $4080

	; Redundant?
	jr _verifyFileCopies		; $4083

;;
; @addr{4085}
_loadFile:
	call _verifyFileCopies		; $4085
	push af			; $4088
	or a			; $4089
	jr nz,+			; $408a

	call _getFileAddress1		; $408c
	jr ++			; $408f
+
	call _getFileAddress2		; $4091
++
	ld l,c			; $4094
	ld h,b			; $4095
	ld de,wFileStart		; $4096
	call _copyFileFromHlToDe		; $4099
	pop af			; $409c
	ret			; $409d

;;
; @addr{409e}
_eraseFile:
	call _getFileAddress1		; $409e
	call @clearFile		; $40a1

	call _getFileAddress2		; $40a4
;;
; @param bc
; @addr{40a7}
@clearFile:
	ld a,$0a		; $40a7
	ld ($1111),a		; $40a9
	ld l,c			; $40ac
	ld h,b			; $40ad
	call _clearFileAtHl		; $40ae
	xor a			; $40b1
	ld ($1111),a		; $40b2
	ret			; $40b5

;;
; Clear $0550 bytes at hl
; @addr{40b6}
_clearFileAtHl:
	ld bc,$0550		; $40b6
	jp clearMemoryBc		; $40b9

;;
; Checks both copies of the file data to see if one is valid.
; If one is valid but not the other, this also updates the invalid copy with the valid
; copy's data.
; @param[out] a $01 if copy 2 was valid while copy 1 wasn't
; @addr{40bc}
_verifyFileCopies:
	call _getFileAddress2		; $40bc
	ld l,c			; $40bf
	ld h,b			; $40c0
	call _verifyFileAtHl		; $40c1
	and $01			; $40c4
	push af			; $40c6

	call _getFileAddress1		; $40c7
	ld l,c			; $40ca
	ld h,b			; $40cb
	call _verifyFileAtHl		; $40cc
	pop bc			; $40cf
	rl b			; $40d0

	; bit 0 set if copy 1 failed, bit 1 set if copy 2 failed
	ld a,b			; $40d2
	rst_jumpTable			; $40d3
	.dw @bothCopiesValid
	.dw @copy1Invalid
	.dw @copy2Invalid
	.dw @bothCopiesInvalid

;;
; @addr{40dc}
@copy2Invalid:
	call _getFileAddress2		; $40dc
	ld e,c			; $40df
	ld d,b			; $40e0
	call _getFileAddress1		; $40e1
	ld l,c			; $40e4
	ld h,b			; $40e5
	call _copyFileFromHlToDe		; $40e6

;;
; @addr{40e9}
@bothCopiesValid:
	xor a			; $40e9
	ret			; $40ea

;;
; @addr{40eb}
@copy1Invalid:
	call _getFileAddress1		; $40eb
	ld e,c			; $40ee
	ld d,b			; $40ef
	call _getFileAddress2		; $40f0
	ld l,c			; $40f3
	ld h,b			; $40f4
	call _copyFileFromHlToDe		; $40f5
	ld a,$01		; $40f8
	ret			; $40fa

;;
; @addr{40fb}
@bothCopiesInvalid:
	ld a,$ff		; $40fb
	ret			; $40fd

;;
; Copy a file ($0550 bytes) from hl to de.
; @param de Destination address
; @param hl Source address
; @addr{40fe}
_copyFileFromHlToDe:
	push hl			; $40fe
	ld a,$0a		; $40ff
	ld ($1111),a		; $4101
	ld bc,$0550		; $4104
	call copyMemoryBc		; $4107
	xor a			; $410a
	ld ($1111),a		; $410b
	pop hl			; $410e
	ret			; $410f

;;
; @param hl Address of file
; @param[out] a Equals $ff if verification failed
; @param[out] cflag Set if verification failed
; @addr{4110}
_verifyFileAtHl:
	push hl			; $4110
	ld a,$0a		; $4111
	ld ($1111),a		; $4113

	; Verify checksum
	call _calculateFileChecksum		; $4116
	ldi a,(hl)		; $4119
	cp e			; $411a
	jr nz,@verifyFailed	; $411b
	ldi a,(hl)		; $411d
	cp d			; $411e
	jr nz,@verifyFailed	; $411f

	; Verify the savefile string
	ld de,_saveVerificationString		; $4121
	ld b,$08		; $4124
@nextChar:
	ld a,(de)		; $4126
	cp (hl)			; $4127
	jr nz,@verifyFailed	; $4128

	inc de			; $412a
	inc hl			; $412b
	dec b			; $412c
	jr nz,@nextChar		; $412d

@verifyDone:
	xor a			; $412f
	ld ($1111),a		; $4130
	pop hl			; $4133
	ld a,b			; $4134
	rrca			; $4135
	ret			; $4136

	; Clear the save data
@verifyFailed:
	pop hl			; $4137
	push hl			; $4138
	call _clearFileAtHl		; $4139
	ld b,$ff		; $413c
	jr @verifyDone		; $413e

;;
; Calculate a checksum over $550 bytes (excluding the first 2) for a save file
; @param hl Address to start at
; @param[out] de Checksum
; @addr{4140}
_calculateFileChecksum:
	push hl			; $4140
	ld a,$02		; $4141
	rst_addAToHl			; $4143
	ld bc,$02a7		; $4144
	ld de,$0000		; $4147
--
	ldi a,(hl)		; $414a
	add e			; $414b
	ld e,a			; $414c
	ldi a,(hl)		; $414d
	adc d			; $414e
	ld d,a			; $414f
	dec bc			; $4150
	ld a,b			; $4151
	or c			; $4152
	jr nz,--		; $4153

	pop hl			; $4155
	ret			; $4156

;;
; Get the first address of the save data
; @param hActiveFileSlot Save slot
; @param[out] bc Address
; @addr{4157}
_getFileAddress1:
	ld c,$00		; $4157
	jr +			; $4159

;;
; Get the second (backup?) address of the save data
; @param hActiveFileSlot Save slot
; @param[out] bc Address
; @addr{415b}
_getFileAddress2:
	ld c,$03		; $415b
+
	push hl			; $415d
	ldh a,(<hActiveFileSlot)	; $415e
	add c			; $4160
	ld hl,@saveFileAddresses		; $4161
	rst_addDoubleIndex			; $4164
	ldi a,(hl)		; $4165
	ld b,(hl)		; $4166
	ld c,a			; $4167
	pop hl			; $4168
	ret			; $4169

; @addr{416a}
@saveFileAddresses:
	.dw $a010
	.dw $a560
	.dw $aab0

	.dw $b000
	.dw $b550
	.dw $baa0

;;
; @param hl Address of initial values (should point to _initialFileVariables or some
; variant)
; @addr{4176}
_initializeFileVariables:
	ld d,>wc600Block		; $4176
--
	ldi a,(hl)		; $4178
	or a			; $4179
	jr z,+			; $417a

	ld e,a			; $417c
	ldi a,(hl)		; $417d
	ld (de),a		; $417e
	jr --			; $417f
+
	ret			; $4181

; Table to distinguish initial file data based on whether it's a standard, linked, or hero
; game.
; @addr{4182}
_initialFileVariablesTable:
	.dw _initialFileVariables_standardGame
	.dw _initialFileVariables_linkedGame
	.dw _initialFileVariables_heroGame
	.dw _initialFileVariables_linkedGame

; Initial values for variables in the c6xx block.
; @addr{418a}
_initialFileVariables:
	.db <wTextSpeed				$02
	.db <wc608				$01
	.db <wLinkName+5			$00 ; Ensure names have null terminator
	.db <wKidName+5				$00
	.db <wObtainedTreasureFlags		1<<TREASURE_PUNCH
	.db <wMaxBombs				$10
	.db <wLinkHealth			$10 ; 4 hearts (gets overwritten in standard game)
	.db <wLinkMaxHealth			$10
	.db <wDeathRespawnBuffer.group		$00
	.db <wDeathRespawnBuffer.room		$8a
	.db <wDeathRespawnBuffer.y		$38
	.db <wDeathRespawnBuffer.x		$48
	.db <wDeathRespawnBuffer.facingDir	$00
	.db <wJabuWaterLevel			$21
	.db <wPortalGroup			$ff
	.db <wPirateShipRoom			$b6
	.db <wPirateShipY			$48
	.db <wPirateShipX			$48
	.db <wPirateShipAngle			$02
	.db $00

; Standard game (not linked or hero)
; @addr{41b1}
_initialFileVariables_standardGame:
	.db <wLinkHealth			$0c
	.db <wLinkMaxHealth			$0c
	; Continue reading the following data

; Hero game (not linked+hero game)
; @addr{41b5}
_initialFileVariables_heroGame:
	.db <wChildStatus			$00
	.db <wShieldLevel			$01
	.db <wAnimalCompanion			$00
	.db $00

; Linked game, or linked+hero game
; @addr{41bc}
_initialFileVariables_linkedGame:
	.db <wSwordLevel			$01
	.db <wShieldLevel			$01
	.db <wInventoryStorage			ITEMID_SWORD
	.db <wObtainedTreasureFlags,		(1<<TREASURE_PUNCH) | (1<<TREASURE_SWORD)
	.db <wPirateShipY			$58
	.db <wPirateShipX			$78
	.db $00

; This string is different in ages and seasons.
; @addr{41c9}
_saveVerificationString:
	.ASC "Z21216-0"

.ends


 ; This section can't be superfree, since it must be in the same bank as section
 ; "Bank_7_Data".
 m_section_free "Enemy_Part_Collisions" namespace "bank7"

;;
; For each Enemy and each Part, check for collisions with Link and Items.
; @addr{41d1}
checkEnemyAndPartCollisions:
	; Calculate shield position
	ld a,(w1Link.direction)		; $41d1
	add a			; $41d4
	add a			; $41d5
	ld hl,@shieldPositionOffsets		; $41d6
	rst_addAToHl			; $41d9
	ld de,wShieldY		; $41da
	ld a,(w1Link.yh)		; $41dd
	add (hl)		; $41e0
	ld (de),a		; $41e1
	inc hl			; $41e2
	inc e			; $41e3
	ld a,(w1Link.xh)		; $41e4
	add (hl)		; $41e7
	ld (de),a		; $41e8

	inc hl			; $41e9
	inc e			; $41ea
	ldi a,(hl)		; $41eb
	ld (de),a		; $41ec
	inc e			; $41ed
	ldi a,(hl)		; $41ee
	ld (de),a		; $41ef

	; Check collisions for all Enemies
	ld a,Enemy.start		; $41f0
	ldh (<hActiveObjectType),a	; $41f2
	ld d,FIRST_ENEMY_INDEX		; $41f4
	ld a,d			; $41f6
@nextEnemy:
	ldh (<hActiveObject),a	; $41f7
	ld h,d			; $41f9
	ld l,Enemy.collisionType		; $41fa
	bit 7,(hl)		; $41fc
	jr z,+			; $41fe

	ld a,(hl)		; $4200
	ld l,Enemy.var2a		; $4201
	bit 7,(hl)		; $4203
	call z,_enemyCheckCollisions		; $4205
+
	inc d			; $4208
	ld a,d			; $4209
	cp LAST_ENEMY_INDEX+1			; $420a
	jr c,@nextEnemy		; $420c

	; Check collisions for all Parts
	ld a,Part.start		; $420e
	ldh (<hActiveObjectType),a	; $4210
	ld d,FIRST_PART_INDEX		; $4212
	ld a,d			; $4214
@nextPart:
	ldh (<hActiveObject),a	; $4215
	ld h,d			; $4217
	ld l,Part.collisionType		; $4218
	bit 7,(hl)		; $421a
	jr z,+			; $421c

	ld l,Part.var2a		; $421e
	bit 7,(hl)		; $4220
	jr nz,+			; $4222

	; Check Part.invincibilityCounter
	inc l			; $4224
	ld a,(hl)		; $4225
	or a			; $4226
	call z,_partCheckCollisions		; $4227
+
	inc d			; $422a
	ld a,d			; $422b
	cp LAST_PART_INDEX+1			; $422c
	jr c,@nextPart		; $422e

	ret			; $4230

; @addr{4231}
@shieldPositionOffsets:
	.db $f9 $01 $01 $06 ; DIR_UP
	.db $00 $06 $07 $01 ; DIR_RIGHT
	.db $06 $ff $01 $06 ; DIR_DOWN
	.db $00 $f9 $07 $01 ; DIR_LEFT


;;
; Check if the given part is colliding with an item or link, and do the appropriate
; action.
; @param d Part index
; @addr{4241}
_partCheckCollisions:
	ld e,Part.collisionType		; $4241
	ld a,(de)		; $4243
	ld hl,partActiveCollisions		; $4244
	ld e,Part.yh		; $4247
	jr ++			; $4249

;;
; Check if the given enemy is colliding with an item or link, and do the appropriate
; action.
; @param a Enemy.collisionType
; @param d Enemy index
; @addr{424b}
_enemyCheckCollisions:
	ld hl,enemyActiveCollisions		; $424b
	ld e,Enemy.yh		; $424e

++
	add a			; $4250
	ld c,a			; $4251
	ld b,$00		; $4252
	add hl,bc		; $4254
	add hl,bc		; $4255

	; Store pointer for later
	ld a,l			; $4256
	ldh (<hFF92),a	; $4257
	ld a,h			; $4259
	ldh (<hFF93),a	; $425a

	; Store X in hFF8E, Y in hFF8F, Z in hFF91
	ld h,d			; $425c
	ld l,e			; $425d
	ldi a,(hl)		; $425e
	ldh (<hFF8F),a	; $425f
	inc l			; $4261
	ldi a,(hl)		; $4262
	ldh (<hFF8E),a	; $4263
	inc l			; $4265
	ld a,(hl)		; $4266
	ldh (<hFF91),a	; $4267

	; Check invincibility
	ld a,l			; $4269
	add Object.invincibilityCounter-Object.zh		; $426a
	ld l,a			; $426c
	ld a,(hl)		; $426d
	or a			; $426e
	jr nz,@doneCheckingItems	; $426f

	; Check collisions with items
	ld h,FIRST_ITEM_INDEX		; $4271
@checkItem:
	ld l,Item.collisionType		; $4273
	ld a,(hl)		; $4275
	bit 7,a			; $4276
	jr z,@nextItem		; $4278

	and $7f			; $427a
	ldh (<hFF90),a	; $427c
	ld b,a			; $427e
	ld e,h			; $427f
	ldh a,(<hFF92)	; $4280
	ld l,a			; $4282
	ldh a,(<hFF93)	; $4283
	ld h,a			; $4285
	ld a,b			; $4286
	call @checkFlag		; $4287
	ld h,e			; $428a
	jr z,@nextItem		; $428b

	ld bc,$0e07		; $428d
	ldh a,(<hFF90)	; $4290
	cp ITEMCOLLISION_BOMB			; $4292
	jr nz,++		; $4294

	ld l,Item.collisionRadiusY		; $4296
	ld a,(hl)		; $4298
	ld c,a			; $4299
	add a			; $429a
	ld b,a			; $429b
++
	ld l,Item.zh		; $429c
	ldh a,(<hFF91)	; $429e
	sub (hl)		; $42a0
	add c			; $42a1
	cp b			; $42a2
	jr nc,@nextItem		; $42a3

	ld l,Item.yh		; $42a5
	ld b,(hl)		; $42a7
	ld l,Item.xh		; $42a8
	ld c,(hl)		; $42aa
	ld l,Item.collisionRadiusY		; $42ab
	ldh a,(<hActiveObjectType)	; $42ad
	add Object.collisionRadiusY			; $42af
	ld e,a			; $42b1
	call checkObjectsCollidedFromVariables		; $42b2
	jp c,@handleCollision		; $42b5

@nextItem:
	inc h			; $42b8
	ld a,h			; $42b9
	cp LAST_STANDARD_ITEM_INDEX+1			; $42ba
	jr c,@checkItem		; $42bc

@doneCheckingItems:
	call checkLinkVulnerable		; $42be
	ret nc			; $42c1

	; Check for collision with link
	; (hl points to link object from the call to checkLinkVulnerable)

	; Check if Z positions are within 7 pixels
	ld l,<w1Link.zh		; $42c2
	ldh a,(<hFF91)	; $42c4
	sub (hl)		; $42c6
	add $07			; $42c7
	cp $0e			; $42c9
	ret nc			; $42cb

	; If the shield is out...
	ld a,(wUsingShield)		; $42cc
	or a			; $42cf
	jr z,@checkHitLink		; $42d0

	; Store shield level as collision type
	ldh (<hFF90),a	; $42d2

	; Check if the shield can defend from this object
	ldh a,(<hFF92)	; $42d4
	ld l,a			; $42d6
	ldh a,(<hFF93)	; $42d7
	ld h,a			; $42d9
	ldh a,(<hFF90)	; $42da
	call @checkFlag		; $42dc
	jr z,@checkHitLink		; $42df

	; Check if current object is within the shield's hitbox
	ld hl,wShieldY		; $42e1
	ldi a,(hl)		; $42e4
	ld b,a			; $42e5
	ldi a,(hl)		; $42e6
	ld c,a			; $42e7
	ldh a,(<hActiveObjectType)	; $42e8
	add <Object.collisionRadiusY			; $42ea
	ld e,a			; $42ec
	call checkObjectsCollidedFromVariables		; $42ed
	ld hl,w1Link		; $42f0
	jp c,@handleCollision		; $42f3

	; Not using shield (or shield is ineffective)
@checkHitLink:
	ldh a,(<hActiveObjectType)	; $42f6
	add Object.stunCounter			; $42f8
	ld e,a			; $42fa
	ld a,(de)		; $42fb
	or a			; $42fc
	ret nz			; $42fd

	; Check if the current object responds to link's collisionType
	ld a,(wLinkObjectIndex)		; $42fe
	ld h,a			; $4301
	ld e,a			; $4302
	ld l,<w1Link.collisionType		; $4303
	ld a,(hl)		; $4305
	and $7f			; $4306
	ldh (<hFF90),a	; $4308
	ldh a,(<hFF92)	; $430a
	ld l,a			; $430c
	ldh a,(<hFF93)	; $430d
	ld h,a			; $430f
	ldh a,(<hFF90)	; $4310
	call @checkFlag		; $4312
	ret z			; $4315

	; If link and the current object collide, damage link

	ld h,e			; $4316
	ld l,<w1Link.yh		; $4317
	ld b,(hl)		; $4319
	ld l,<w1Link.xh		; $431a
	ld c,(hl)		; $431c
	ld l,<w1Link.collisionRadiusY		; $431d
	ldh a,(<hActiveObjectType)	; $431f
	add Object.collisionRadiusY			; $4321
	ld e,a			; $4323
	call checkObjectsCollidedFromVariables		; $4324
	jp c,@handleCollision		; $4327
	ret			; $432a

;;
; This appears to behave identically to the checkFlag function in bank 0.
; I guess it's a bit more efficient?
; @param a Bit to check
; @param hl Start of flags
; @addr{432b}
@checkFlag:
	ld b,a			; $432b
	and $f8			; $432c
	rlca			; $432e
	swap a			; $432f
	ld c,a			; $4331
	ld a,b			; $4332
	and $07			; $4333
	ld b,$00		; $4335
	add hl,bc		; $4337
	ld c,(hl)		; $4338
	ld hl,bitTable		; $4339
	add l			; $433c
	ld l,a			; $433d
	ld a,(hl)		; $433e
	and c			; $433f
	ret			; $4340

;;
; @param de Object 1 (Enemy/Part?)
; @param hl Object 2 (Link/Item?)
; @param hFF8D Y-position?
; @param hFF8E X-position?
; @param hFF90 Collision type
; @addr{4341}
@handleCollision:
	ld a,l			; $4341
	and $c0			; $4342
	ld l,a			; $4344
	push hl			; $4345
	ld a,WEAPON_ITEM_INDEX		; $4346
	cp h			; $4348
	jr nz,@notWeaponItem		; $4349

@weaponItem:
	ld a,(w1Link.yh)		; $434b
	ld b,a			; $434e
	ld a,(w1Link.xh)		; $434f
	jr ++			; $4352

@notWeaponItem:
	ldh a,(<hFF8D)	; $4354
	ld b,a			; $4356
	ldh a,(<hFF8C)	; $4357

++
	ld c,a			; $4359
	call objectGetRelativeAngleWithTempVars		; $435a
	ldh (<hFF8A),a	; $435d
	ldh a,(<hActiveObjectType)	; $435f
	add Object.enemyCollisionMode			; $4361
	ld e,a			; $4363
	ld a,(de)		; $4364
	add a			; $4365
	call multiplyABy16		; $4366
	ld hl,objectCollisionTable		; $4369
	add hl,bc		; $436c
	pop bc			; $436d
	ldh a,(<hFF90)	; $436e
	rst_addAToHl			; $4370
	ld a,(hl)		; $4371
	rst_jumpTable			; $4372
	.dw _collisionEffect00
	.dw _collisionEffect01
	.dw _collisionEffect02
	.dw _collisionEffect03
	.dw _collisionEffect04
	.dw _collisionEffect05
	.dw _collisionEffect06
	.dw _collisionEffect07
	.dw _collisionEffect08
	.dw _collisionEffect09
	.dw _collisionEffect0a
	.dw _collisionEffect0b
	.dw _collisionEffect0c
	.dw _collisionEffect0d
	.dw _collisionEffect0e
	.dw _collisionEffect0f
	.dw _collisionEffect10
	.dw _collisionEffect11
	.dw _collisionEffect12
	.dw _collisionEffect13
	.dw _collisionEffect14
	.dw _collisionEffect15
	.dw _collisionEffect16
	.dw _collisionEffect17
	.dw _collisionEffect18
	.dw _collisionEffect19
	.dw _collisionEffect1a
	.dw _collisionEffect1b
	.dw _collisionEffect1c
	.dw _collisionEffect1d
	.dw _collisionEffect1e
	.dw _collisionEffect1f
	.dw _collisionEffect20
	.dw _collisionEffect21
	.dw _collisionEffect22
	.dw _collisionEffect23
	.dw _collisionEffect24
	.dw _collisionEffect25
	.dw _collisionEffect26
	.dw _collisionEffect27
	.dw _collisionEffect28
	.dw _collisionEffect29
	.dw _collisionEffect2a
	.dw _collisionEffect2b
	.dw _collisionEffect2c
	.dw _collisionEffect2d
	.dw _collisionEffect2e
	.dw _collisionEffect2f
	.dw _collisionEffect30
	.dw _collisionEffect31
	.dw _collisionEffect32
	.dw _collisionEffect33
	.dw _collisionEffect34
	.dw _collisionEffect35
	.dw _collisionEffect36
	.dw _collisionEffect37
	.dw _collisionEffect38
	.dw _collisionEffect39
	.dw _collisionEffect3a
	.dw _collisionEffect3b
	.dw _collisionEffect3c
	.dw _collisionEffect3d
	.dw _collisionEffect3e
	.dw _collisionEffect3f

; Parameters which get passed to collision code functions:
; bc = link / item object (points to the start of the object)
; de = enemy / part object (points to Object.enemyCollisionMode)

;;
; COLLISIONEFFECT_NONE
; @addr{43f3}
_collisionEffect00:
	ret			; $43f3

;;
; COLLISIONEFFECT_DAMAGE_LINK_WITH_RING_MODIFIER
; This is the same as COLLISIONEFFECT_DAMAGE_LINK, but it checks for rings that reduce or
; prevent damage.
; @addr{43f4}
_collisionEffect3c:
	; Get Object.id
	ldh a,(<hActiveObjectType)	; $43f4
	inc a			; $43f6
	ld e,a			; $43f7
	ld a,(de)		; $43f8
	ld c,a			; $43f9

	; Try to find the id in @ringProtections
	ld hl,@ringProtections		; $43fa
--
	ldi a,(hl)		; $43fd
	or a			; $43fe
	jr z,_collisionEffect02	; $43ff

	cp c			; $4401
	ldi a,(hl)		; $4402
	jr nz,--		; $4403

	; If the id was found, check if the corresponding ring is equipped
	ld c,a			; $4405
	and $7f			; $4406
	call cpActiveRing		; $4408
	jr nz,_collisionEffect02	; $440b

	; If bit 7 is unset, destroy the projectile
	bit 7,c			; $440d
	ld a,ENEMYDMG_40		; $440f
	jp z,_applyDamageToEnemyOrPart		; $4411

	; Else, hit link but halve the damage
	call _collisionEffect02		; $4414
	ld h,b			; $4417
	ld l,<w1Link.damageToApply		; $4418
	sra (hl)		; $441a
	ret			; $441c

; @addr{441d}
@ringProtections:
	.db ENEMYID_BLADE_TRAP		$80|GREEN_LUCK_RING
	.db PARTID_OCTOROK_PROJECTILE	$00|RED_HOLY_RING
	.db PARTID_ZORA_FIRE		$00|BLUE_HOLY_RING
	.db PARTID_BEAM			$80|BLUE_LUCK_RING
	.db $00

;;
; COLLISIONEFFECT_DAMAGE_LINK_LOW_KNOCKBACK
; @addr{4426}
_collisionEffect01:
	ld e,LINKDMG_00		; $4426
	jr ++			; $4428

;;
; COLLISIONEFFECT_DAMAGE_LINK
; @addr{442a}
_collisionEffect02:
	ld e,LINKDMG_04		; $442a
	jr ++			; $442c

;;
; COLLISIONEFFECT_DAMAGE_LINK_HIGH_KNOCKBACK
; @addr{442e}
_collisionEffect03:
	ld e,LINKDMG_08		; $442e
	jr ++			; $4430

;;
; COLLISIONEFFECT_DAMAGE_LINK_NO_KNOCKBACK
; @addr{4432}
_collisionEffect04:
	ld e,LINKDMG_0c		; $4432
++
	call _applyDamageToLink_paramE		; $4434
	ld a,ENEMYDMG_1c		; $4437
	jp _applyDamageToEnemyOrPart		; $4439

;;
; COLLISIONEFFECT_SWORD_LOW_KNOCKBACK
; @addr{443c}
_collisionEffect08:
	ld e,ENEMYDMG_00		; $443c
	jr _label_07_027		; $443e

;;
; COLLISIONEFFECT_SWORD
; @addr{4440}
_collisionEffect09:
	ld e,ENEMYDMG_04		; $4440
	jr _label_07_027		; $4442

;;
; COLLISIONEFFECT_SWORD_HIGH_KNOCKBACK
; @addr{4440}
_collisionEffect0a:
	ld e,ENEMYDMG_08		; $4444
	jr _label_07_027		; $4446

;;
; COLLISIONEFFECT_SWORD_NO_KNOCKBACK
; @addr{4440}
_collisionEffect0b:
	call _func_07_47b7		; $4448
	ret z			; $444b
	ld e,ENEMYDMG_0c		; $444c
	jr _label_07_027		; $444e

;;
; COLLISIONEFFECT_21
; @addr{4450}
_collisionEffect21:
	ld e,ENEMYDMG_30		; $4450
_label_07_027:
	ldh a,(<hActiveObjectType)	; $4452
	add Object.var3e			; $4454
	ld l,a			; $4456
	ld h,d			; $4457
	ld c,Item.var2a		; $4458
	ld a,(bc)		; $445a
	or (hl)			; $445b
	ld (bc),a		; $445c
	ld a,e			; $445d
	jp _applyDamageToEnemyOrPart		; $445e

;;
; COLLISIONEFFECT_BUMP_WITH_CLINK_LOW_KNOCKBACK
; @addr{4461}
_collisionEffect12:
	call _createClinkInteraction		; $4461

;;
; COLLISIONEFFECT_BUMP_LOW_KNOCKBACK
; @addr{4464}
_collisionEffect0c:
	ld e,ENEMYDMG_10		; $4464
	jr _label_07_028		; $4466

;;
; COLLISIONEFFECT_BUMP_WITH_CLINK
; @addr{4468}
_collisionEffect13:
	call _createClinkInteraction		; $4468

;;
; COLLISIONEFFECT_BUMP
; @addr{446b}
_collisionEffect0d:
	ld e,ENEMYDMG_14		; $446b
	jr _label_07_028		; $446d

;;
; COLLISIONEFFECT_BUMP_WITH_CLINK_HIGH_KNOCKBACK
; @addr{446f}
_collisionEffect14:
	call _createClinkInteraction		; $446f

;;
; COLLISIONEFFECT_BUMP_HIGH_KNOCKBACK
; @addr{4472}
_collisionEffect0e:
	ld e,ENEMYDMG_18		; $4472
_label_07_028:
	ldh a,(<hActiveObjectType)	; $4474
	add Object.var3e			; $4476
	ld l,a			; $4478
	ld h,d			; $4479
	ld c,Item.var2a		; $447a
	ld a,(bc)		; $447c
	or (hl)			; $447d
	ld (bc),a		; $447e
	ld a,e			; $447f
	jp _applyDamageToEnemyOrPart		; $4480

;;
; COLLISIONEFFECT_05
; @addr{4483}
_collisionEffect05:
	ldhl LINKDMG_10, ENEMYDMG_1c		; $4483
	jr _applyDamageToBothObjects		; $4486

;;
; COLLISIONEFFECT_06
; @addr{4488}
_collisionEffect06:
	ldhl LINKDMG_14, ENEMYDMG_1c		; $4488
	jr _applyDamageToBothObjects		; $448b

;;
; COLLISIONEFFECT_07
; @addr{448d}
_collisionEffect07:
	ldhl LINKDMG_18, ENEMYDMG_1c		; $448d
	jr _applyDamageToBothObjects		; $4490

;;
; COLLISIONEFFECT_SHIELD_BUMP_WITH_CLINK
; @addr{4492}
_collisionEffect18:
	call _createClinkInteraction		; $4492

;;
; COLLISIONEFFECT_SHIELD_BUMP
; @addr{4495}
_collisionEffect0f:
	ldhl LINKDMG_10, ENEMYDMG_10		; $4495
	jr _applyDamageToBothObjects		; $4498

;;
; COLLISIONEFFECT_SHIELD_BUMP_WITH_CLINK_HIGH_KNOCKBACK
; @addr{449a}
_collisionEffect19:
	call _createClinkInteraction		; $449a

;;
; COLLISIONEFFECT_SHIELD_BUMP_HIGH_KNOCKBACK
; @addr{449d}
_collisionEffect10:
	ldhl LINKDMG_14, ENEMYDMG_14		; $449d
	jr _applyDamageToBothObjects		; $44a0

;;
; COLLISIONEFFECT_15
; @addr{44a2}
_collisionEffect15:
	call _createClinkInteraction		; $44a2
	ldhl LINKDMG_10, ENEMYDMG_34		; $44a5
	jr _applyDamageToBothObjects		; $44a8

;;
; COLLISIONEFFECT_16
; @addr{44aa}
_collisionEffect16:
	call _createClinkInteraction		; $44aa
	ldhl LINKDMG_14, ENEMYDMG_34		; $44ad
	jr _applyDamageToBothObjects		; $44b0

;;
; COLLISIONEFFECT_17
; @addr{44b2}
_collisionEffect17:
	call _createClinkInteraction		; $44b2
	ldhl LINKDMG_18, ENEMYDMG_34		; $44b5
	jr _applyDamageToBothObjects		; $44b8

;;
; COLLISIONEFFECT_1a
; @addr{44ba}
_collisionEffect1a:
	call _createClinkInteraction		; $44ba

;;
; COLLISIONEFFECT_11
; @addr{44bd}
_collisionEffect11:
	ldhl LINKDMG_18, ENEMYDMG_18		; $44bd
	jr _applyDamageToBothObjects		; $44c0

;;
; COLLISIONEFFECT_1b
; @addr{44c2}
_collisionEffect1b:
	call _createClinkInteraction		; $44c2
	ldhl LINKDMG_1c, ENEMYDMG_28		; $44c5
	jr _applyDamageToBothObjects		; $44c8

;;
; COLLISIONEFFECT_1d
; @addr{44ca}
_collisionEffect1d:
	ldhl LINKDMG_0c, ENEMYDMG_04		; $44ca
	jr _applyDamageToBothObjects		; $44cd

;;
; COLLISIONEFFECT_1e
; @addr{44cf}
_collisionEffect1e:
	ldhl LINKDMG_28, ENEMYDMG_34		; $44cf
	jr _applyDamageToBothObjects		; $44d2

;;
; COLLISIONEFFECT_1f
; @addr{44d4}
_collisionEffect1f:
	ldhl LINKDMG_20, ENEMYDMG_34		; $44d4
	jr _applyDamageToBothObjects		; $44d7

;;
; COLLISIONEFFECT_20
; @addr{44d9}
_collisionEffect20:
	ld h,b			; $44d9
	ld l,Item.id		; $44da
	ld a,(hl)		; $44dc
	cp $28			; $44dd
	jr nc,+			; $44df

	ld l,Item.collisionType		; $44e1
	res 7,(hl)		; $44e3
+
	call _func_07_47b7		; $44e5
	ret z			; $44e8

	ldhl LINKDMG_24, ENEMYDMG_44		; $44e9
	jr _applyDamageToBothObjects		; $44ec

;;
; COLLISIONEFFECT_STUN
; @addr{44ee}
_collisionEffect22:
	ldhl LINKDMG_1c, ENEMYDMG_24		; $44ee

;;
; @param h Damage type for link ( / item?)
; @param l Damage type for enemy / part
; @addr{44f1}
_applyDamageToBothObjects:
	ld a,h			; $44f1
	push hl			; $44f2
	call _applyDamageToLink		; $44f3
	pop hl			; $44f6
	ld a,l			; $44f7
	jp _applyDamageToEnemyOrPart		; $44f8

;;
; COLLISIONEFFECT_26
; @addr{44fb}
_collisionEffect26:
	ldhl LINKDMG_1c, ENEMYDMG_34		; $44fb
	jr _applyDamageToBothObjects		; $44fe

;;
; COLLISIONEFFECT_BURN
; @addr{4500}
_collisionEffect27:
	ld h,b			; $4500
	ld l,Item.collisionType		; $4501
	res 7,(hl)		; $4503
	call _func_07_47b7		; $4505
	ret z			; $4508

	call _createFlamePart		; $4509
	ldhl LINKDMG_1c, ENEMYDMG_2c		; $450c
	jr _applyDamageToBothObjects		; $450f

;;
; COLLISIONEFFECT_PEGASUS_SEED
; @addr{4511}
_collisionEffect28:
	ld h,b			; $4511
	ld l,Item.collisionType		; $4512
	res 7,(hl)		; $4514
	call _func_07_47b7		; $4516
	ret z			; $4519

	ldhl LINKDMG_1c, ENEMYDMG_38		; $451a
	jr _applyDamageToBothObjects		; $451d

;;
; COLLISIONEFFECT_3a
; Assumes that the first object is an Enemy, not a Part.
; @addr{451f}
_collisionEffect3a:
	ld e,Enemy.knockbackCounter		; $451f
	ld a,(de)		; $4521
	or a			; $4522
	ret nz			; $4523

;;
; COLLISIONEFFECT_LIKELIKE
; @addr{4524}
_collisionEffect3d:
	ld a,(w1Link.id)		; $4524
	or a			; $4527
	ret nz			; $4528

	ld a,(wWarpsDisabled)		; $4529
	or a			; $452c
	ret nz			; $452d

	ld a,LINK_STATE_GRABBED		; $452e
	ld (wLinkForceState),a		; $4530
	ldhl LINKDMG_2c, ENEMYDMG_1c		; $4533
	jr _applyDamageToBothObjects		; $4536

;;
; COLLISIONEFFECT_2b
; @addr{4538}
_collisionEffect2b:
	ldhl LINKDMG_1c, ENEMYDMG_3c		; $4538
	jr _applyDamageToBothObjects		; $453b

;;
; COLLISIONEFFECT_2c
; @addr{453d}
_collisionEffect2c:
	ldhl LINKDMG_14, ENEMYDMG_30		; $453d
	jr _applyDamageToBothObjects		; $4540

;;
; COLLISIONEFFECT_2f
; @addr{4542}
_collisionEffect2f:
	ldhl LINKDMG_30, ENEMYDMG_04		; $4542
	jr _applyDamageToBothObjects		; $4545

;;
; COLLISIONEFFECT_30
; @addr{4547}
_collisionEffect30:
	ldhl LINKDMG_1c, ENEMYDMG_44		; $4547
	jr _applyDamageToBothObjects		; $454a

;;
; COLLISIONEFFECT_1c
; @addr{454c}
_collisionEffect1c:
	ldhl LINKDMG_1c, ENEMYDMG_1c		; $454c
	jr _applyDamageToBothObjects		; $454f

;;
; COLLISIONEFFECT_SWITCH_HOOK
; @addr{4551}
_collisionEffect2e:
	ld h,d			; $4551
	ldh a,(<hActiveObjectType)	; $4552
	add Object.health			; $4554
	ld l,a			; $4556
	ld a,(hl)		; $4557
	or a			; $4558
	jr z,_collisionEffect1c	; $4559

	; Clear Object.stunCounter, Object.knockbackCounter
	ld a,l			; $455b
	add Object.stunCounter-Object.health			; $455c
	ld l,a			; $455e
	xor a			; $455f
	ldd (hl),a		; $4560
	ldd (hl),a		; $4561

	; l = Object.knockbackAngle
	ldh a,(<hFF8A)	; $4562
	xor $10			; $4564
	ld (hl),a		; $4566

	; l = Object.collisionType
	res 3,l			; $4567
	res 7,(hl)		; $4569

	ld a,l			; $456b
	add Object.state-Object.collisionType			; $456c
	ld l,a			; $456e
	ld (hl),$03		; $456f

	; l = Object.state2
	inc l			; $4571
	ld (hl),$00		; $4572

	; Now do something with link
	ld h,b			; $4574
	ld l,<w1Link.var2a		; $4575
	set 5,(hl)		; $4577
	ld l,<w1Link.collisionType		; $4579
	res 7,(hl)		; $457b
	ld l,<w1Link.relatedObj2		; $457d
	ldh a,(<hActiveObjectType)	; $457f
	ldi (hl),a		; $4581
	ld (hl),d		; $4582
	ret			; $4583

;;
; COLLISIONEFFECT_23
; @addr{4584}
_collisionEffect23:
	ldh a,(<hActiveObjectType)	; $4584
	add Object.health			; $4586
	ld l,a			; $4588
	ld h,d			; $4589
	ld (hl),$00		; $458a
	ret			; $458c

;;
; COLLISIONEFFECT_24
; @addr{458d}
_collisionEffect24:
	ldh a,(<hActiveObjectType)	; $458d
	add Object.var2a			; $458f
	ld e,a			; $4591
	ldh a,(<hFF90)	; $4592
	or $80			; $4594
	ld (de),a		; $4596

	ld a,e			; $4597
	add Object.relatedObj1-Object.var2a			; $4598
	ld l,a			; $459a
	ld h,d			; $459b
	ld (hl),c		; $459c
	inc l			; $459d
	ld (hl),b		; $459e

	ld c,Item.var2a		; $459f
	ld a,$01		; $45a1
	ld (bc),a		; $45a3
	ret			; $45a4

;;
; COLLISIONEFFECT_25
; @addr{45a5}
_collisionEffect25:
	call _killEnemyOrPart		; $45a5
	ld a,l			; $45a8
	add Object.var3f-Object.collisionType			; $45a9
	ld l,a			; $45ab
	set 7,(hl)		; $45ac

	ld c,Item.var2a		; $45ae
	ld a,$02		; $45b0
	ld (bc),a		; $45b2
	ret			; $45b3

;;
; COLLISIONEFFECT_GALE_SEED
; This assumes that second object is an Enemy, NOT a Part. At least, it does when
; func_07_47b7 returns nonzero...
; @addr{45b4}
_collisionEffect29:
	ld h,b			; $45b4
	ld l,Item.collisionType		; $45b5
	res 7,(hl)		; $45b7
	call _func_07_47b7		; $45b9
	ret z			; $45bc

	ld h,d			; $45bd
	ld l,Enemy.var2a		; $45be
	ld (hl),$9e		; $45c0
	ld l,Enemy.stunCounter		; $45c2
	ld (hl),$00		; $45c4
	ld l,Enemy.collisionType		; $45c6
	res 7,(hl)		; $45c8
	ld l,Enemy.state		; $45ca
	ld (hl),$05		; $45cc

	ld l,Enemy.visible		; $45ce
	ld a,(hl)		; $45d0
	and $c0			; $45d1
	or $02			; $45d3
	ld (hl),a		; $45d5

	ld l,Enemy.counter2		; $45d6
	ld (hl),$1e		; $45d8
	ld l,Enemy.speed		; $45da
	ld (hl),$05		; $45dc

	ld l,Enemy.speedZ		; $45de
	ld (hl),$00		; $45e0
	inc l			; $45e2
	ld (hl),$fa		; $45e3

	; Copy item's x/y position to enemy
	ld l,Enemy.yh		; $45e5
	ld c,Item.yh		; $45e7
	ld a,(bc)		; $45e9
	ldi (hl),a		; $45ea
	inc l			; $45eb
	ld c,Item.xh		; $45ec
	ld a,(bc)		; $45ee
	ldi (hl),a		; $45ef

	; l = Enemy.zh
	inc l			; $45f0
	ld a,(hl)		; $45f1
	rlca			; $45f2
	jr c,+			; $45f3
	ld (hl),$ff		; $45f5
+
	call getRandomNumber		; $45f7
	and $18			; $45fa
	ld e,Enemy.angle		; $45fc
	ld (de),a		; $45fe
	ld a,LINKDMG_1c		; $45ff
	jp _applyDamageToLink		; $4601

;;
; COLLISIONEFFECT_2a
; This assumes that the second object is a Part, not an Enemy.
; @addr{4604}
_collisionEffect2a:
	ld h,b			; $4604
	ld l,Item.knockbackCounter		; $4605
	ld a,d			; $4607
	cp (hl)			; $4608
	ret z			; $4609

	ldd (hl),a		; $460a

	; Write to Item.knockbackAngle
	ld e,Part.animParameter		; $460b
	ld a,(de)		; $460d
	ldd (hl),a		; $460e

	; l = Item.var2a
	dec l			; $460f
	set 4,(hl)		; $4610

	ld e,Part.var2a		; $4612
	ldh a,(<hFF90)	; $4614
	or $80			; $4616
	ld (de),a		; $4618
	ret			; $4619

;;
; COLLISIONEFFECT_2d
; @addr{461a}
_collisionEffect2d:
	ld h,b			; $461a
	ld l,Item.var2f		; $461b
	set 5,(hl)		; $461d
	ret			; $461f

;;
; COLLISIONEFFECT_31
; @addr{4620}
_collisionEffect31:
	ld a,ENEMYDMG_34		; $4620
	jp _applyDamageToEnemyOrPart		; $4622

;;
; COLLISIONEFFECT_32
; @addr{4625}
_collisionEffect32:
	ldhl LINKDMG_34, ENEMYDMG_48		; $4625
	jr _label_07_033		; $4628

;;
; COLLISIONEFFECT_33
; @addr{462a}
_collisionEffect33:
	ldhl LINKDMG_38, ENEMYDMG_4c		; $462a
_label_07_033:
	call _applyDamageToBothObjects		; $462d
	jp _createClinkInteraction		; $4630

;;
; COLLISIONEFFECT_34
; @addr{4633}
_collisionEffect34:
	call _createFlamePart		; $4633
	ld h,b			; $4636
	ld l,Item.collisionType		; $4637
	res 7,(hl)		; $4639
	ldhl LINKDMG_1c, ENEMYDMG_2c		; $463b
	call _applyDamageToBothObjects		; $463e
	jr _killEnemyOrPart		; $4641

;;
; COLLISIONEFFECT_35
; @addr{4643}
_collisionEffect35:
	ldhl LINKDMG_1c, ENEMYDMG_1c		; $4643
	call _applyDamageToBothObjects		; $4646

;;
; Set the Enemy/Part's health to zero, disable its collisions?
; @addr{4649}
_killEnemyOrPart:
	ld h,d			; $4649
	ldh a,(<hActiveObjectType)	; $464a
	add Object.health			; $464c
	ld l,a			; $464e
	ld (hl),$00		; $464f

	add Object.collisionType-Object.health			; $4651
	ld l,a			; $4653
	res 7,(hl)		; $4654
	ret			; $4656

;;
; COLLISIONEFFECT_ELECTRIC_SHOCK
; @addr{4657}
_collisionEffect36:
	ld h,d			; $4657
	ldh a,(<hActiveObjectType)	; $4658
	add Object.var2a			; $465a
	ld l,a			; $465c
	ld (hl),$80|ITEMCOLLISION_ELECTRIC_SHOCK		; $465d

	add Object.collisionType-Object.var2a			; $465f
	ld l,a			; $4661
	res 7,(hl)		; $4662

	; Apply damage if green holy ring is not equipped
	ld a,GREEN_HOLY_RING		; $4664
	call cpActiveRing		; $4666
	ld a,$f8		; $4669
	jr nz,+			; $466b
	xor a			; $466d
+
	ld hl,w1Link.damageToApply		; $466e
	ld (hl),a		; $4671

	ld l,<w1Link.knockbackAngle		; $4672
	ldh a,(<hFF8A)	; $4674
	ld (hl),a		; $4676

	ld l,<w1Link.knockbackCounter		; $4677
	ld (hl),$08		; $4679

	ld l,<w1Link.invincibilityCounter		; $467b
	ld (hl),$0c		; $467d

	ld a,(wIsLinkBeingShocked)		; $467f
	or a			; $4682
	jr nz,+			; $4683

	inc a			; $4685
	ld (wIsLinkBeingShocked),a		; $4686
+
	ld h,b			; $4689
	ld l,<Item.collisionType		; $468a
	res 7,(hl)		; $468c

	ld a,LINKDMG_1c		; $468e
	jp _applyDamageToLink		; $4690

;;
; COLLISIONEFFECT_37
; @addr{4693}
_collisionEffect37:
	ldh a,(<hActiveObjectType)	; $4693
	add Object.invincibilityCounter			; $4695
	ld e,a			; $4697
	ld a,(de)		; $4698
	or a			; $4699
	ret nz			; $469a

	ld a,(wWarpsDisabled)		; $469b
	or a			; $469e
	ret nz			; $469f

	ld a,(w1Link.state)		; $46a0
	cp LINK_STATE_NORMAL			; $46a3
	ret nz			; $46a5

	ld a,e			; $46a6
	add Object.collisionType-Object.invincibilityCounter		; $46a7
	ld e,a			; $46a9
	xor a			; $46aa
	ld (de),a		; $46ab

	ld a,LINK_STATE_GRABBED_BY_WALLMASTER		; $46ac
	ld (wLinkForceState),a		; $46ae
	ld a,ENEMYDMG_1c		; $46b1
	jp _applyDamageToEnemyOrPart		; $46b3

;;
; COLLISIONEFFECT_38
; @addr{46b6}
_collisionEffect38:
	ld h,d			; $46b6
	ldh a,(<hActiveObjectType)	; $46b7
	add Object.collisionType			; $46b9
	ld l,a			; $46bb
	res 7,(hl)		; $46bc

	add Object.counter1-Object.collisionType		; $46be
	ld l,a			; $46c0
	ld (hl),$60		; $46c1

	add Object.zh-Object.counter1			; $46c3
	ld l,a			; $46c5
	ld (hl),$00		; $46c6
	ld a,ENEMYDMG_1c		; $46c8
	jp _applyDamageToEnemyOrPart		; $46ca

;;
; COLLISIONEFFECT_39
; @addr{46cd}
_collisionEffect39:
	ret			; $46cd

;;
; COLLISIONEFFECT_3b
; @addr{46ce}
_collisionEffect3b:
	ld a,$02		; $46ce
	call setLinkIDOverride		; $46d0
	ld a,ENEMYDMG_1c		; $46d3
	jp _applyDamageToEnemyOrPart		; $46d5

;;
; COLLISIONEFFECT_3e
; @addr{46d8}
_collisionEffect3e:
	ret			; $46d8

;;
; COLLISIONEFFECT_3f
; @addr{46d9}
_collisionEffect3f:
	ret			; $46d9

;;
; @addr{46da}
_createFlamePart:
	call getFreePartSlot		; $46da
	ret nz			; $46dd

	ld (hl),PARTID_FLAME		; $46de
	ld l,Part.relatedObj1		; $46e0
	ldh a,(<hActiveObjectType)	; $46e2
	ldi (hl),a		; $46e4
	ld (hl),d		; $46e5
	ret			; $46e6

;;
; @addr{46e7}
_createClinkInteraction:
	call getFreeInteractionSlot		; $46e7
	jr nz,@ret		; $46ea

	ld (hl),INTERACID_CLINK		; $46ec
	ldh a,(<hFF8F)	; $46ee
	ld l,a			; $46f0
	ldh a,(<hFF8D)	; $46f1
	sub l			; $46f3
	sra a			; $46f4
	add l			; $46f6
	ld l,Interaction.yh		; $46f7
	ldi (hl),a		; $46f9
	ldh a,(<hFF8E)	; $46fa
	ld l,a			; $46fc
	ldh a,(<hFF8C)	; $46fd
	sub l			; $46ff
	sra a			; $4700
	add l			; $4702
	ld l,Interaction.xh		; $4703
	ld (hl),a		; $4705
@ret:
	ret			; $4706

;;
; Apply damage to the enemy/part
; @param	b	Item/Link object
; @param	d	Enemy/Part object
; @param	e	Enemy damage type (see enum below)
; @param	hFF90	CollisionType
; @addr{4707}
_applyDamageToEnemyOrPart:
	ld hl,@damageTypeTable		; $4707
	rst_addAToHl			; $470a
	ldh a,(<hActiveObjectType)	; $470b
	add Object.health			; $470d
	ld e,a			; $470f
	bit 7,(hl)		; $4710
	jr z,++			; $4712

	; Apply damage
	ld c,Item.damage		; $4714
	ld a,(bc)		; $4716
	ld c,a			; $4717
	ld a,(de)		; $4718
	add c			; $4719
	jr c,+			; $471a
	xor a			; $471c
+
	ld (de),a		; $471d
	jr nz,++		; $471e

	; If health reaches zero, disable collisions
	ld c,e			; $4720
	ld a,e			; $4721
	add Object.collisionType-Object.health		; $4722
	ld e,a			; $4724
	ld a,(de)		; $4725
	res 7,a			; $4726
	ld (de),a		; $4728
	ld e,c			; $4729
++
	; e = Object.var2a
	inc e			; $472a
	ldi a,(hl)		; $472b
	ld c,a			; $472c
	bit 6,c			; $472d
	jr z,+			; $472f

	; Set var2a to the collisionType of the object it collided with
	ldh a,(<hFF90)	; $4731
	or $80			; $4733
	ld (de),a		; $4735
+
	; e = Object.invincibilityCounter
	inc e			; $4736
	ldi a,(hl)		; $4737
	bit 5,c			; $4738
	jr z,+			; $473a
	ld (de),a		; $473c
+
	; e = Object.knockbackCounter
	inc e			; $473d
	inc e			; $473e
	bit 4,c			; $473f
	ldi a,(hl)		; $4741
	jr z,++			; $4742

	; Apply knockback
	ld (de),a		; $4744

	; Calculate value for Object.knockbackAngle
	ldh a,(<hFF8A)	; $4745
	xor $10			; $4747
	dec e			; $4749
	ld (de),a		; $474a
	inc e			; $474b
++
	; e = Object.stunCounter
	inc e			; $474c
	ldi a,(hl)		; $474d
	bit 3,c			; $474e
	jr z,+			; $4750
	ld (de),a		; $4752
+
	ld a,c			; $4753
	and $07			; $4754
	ret z			; $4756

	ld hl,@soundEffects		; $4757
	rst_addAToHl			; $475a
	ld a,(hl)		; $475b
	jp playSound		; $475c

; Data format:
; b0: bit 7: whether to apply damage to the enemy/part
;     bit 6: whether to write something to Object.var2a?
;     bit 5: whether to give invincibility frames
;     bit 4: whether to give knockback
;     bit 3: whether to stun it
;     bits 0-2: sound effect to play
; b1: Value to write to Object.invincibilityFrames (if applicable)
; b2: Value to write to Object.knockbackCounter (if applicable)
; b3: Value to write to Object.stunCounter (if applicable)

; @addr{475f}
@damageTypeTable:
	.db $f1 $10 $08 $00 ; ENEMYDMG_00
	.db $f1 $15 $0b $00 ; ENEMYDMG_04
	.db $f1 $1a $0f $00 ; ENEMYDMG_08
	.db $f1 $20 $00 $00 ; ENEMYDMG_0c
	.db $70 $f0 $08 $00 ; ENEMYDMG_10
	.db $70 $eb $0b $00 ; ENEMYDMG_14
	.db $70 $e6 $0f $00 ; ENEMYDMG_18
	.db $40 $00 $00 $00 ; ENEMYDMG_1c
	.db $e1 $20 $00 $00 ; ENEMYDMG_20
	.db $29 $f0 $00 $78 ; ENEMYDMG_24
	.db $60 $ec $00 $00 ; ENEMYDMG_28
	.db $e8 $a6 $00 $5a ; ENEMYDMG_2c
	.db $f2 $20 $00 $00 ; ENEMYDMG_30
	.db $60 $e4 $00 $00 ; ENEMYDMG_34
	.db $29 $f0 $00 $f0 ; ENEMYDMG_38
	.db $a9 $18 $00 $78 ; ENEMYDMG_3c
	.db $e3 $20 $00 $00 ; ENEMYDMG_40
	.db $50 $00 $00 $00 ; ENEMYDMG_44
	.db $70 $f7 $07 $00 ; ENEMYDMG_48
	.db $70 $f5 $09 $00 ; ENEMYDMG_4c


; @addr{47af}
@soundEffects:
	.db SND_NONE
	.db SND_DAMAGE_ENEMY
	.db SND_BOSS_DAMAGE
	.db SND_CLINK2
	.db SND_NONE
	.db SND_NONE
	.db SND_NONE
	.db SND_NONE

.ENUM 0 EXPORT
	ENEMYDMG_00	dsb 4
	ENEMYDMG_04	dsb 4
	ENEMYDMG_08	dsb 4
	ENEMYDMG_0c	dsb 4
	ENEMYDMG_10	dsb 4
	ENEMYDMG_14	dsb 4
	ENEMYDMG_18	dsb 4
	ENEMYDMG_1c	dsb 4
	ENEMYDMG_20	dsb 4
	ENEMYDMG_24	dsb 4
	ENEMYDMG_28	dsb 4
	ENEMYDMG_2c	dsb 4
	ENEMYDMG_30	dsb 4
	ENEMYDMG_34	dsb 4
	ENEMYDMG_38	dsb 4
	ENEMYDMG_3c	dsb 4
	ENEMYDMG_40	dsb 4
	ENEMYDMG_44	dsb 4
	ENEMYDMG_48	dsb 4
	ENEMYDMG_4c	dsb 4
.ENDE


;;
; @addr{47b7}
_func_07_47b7:
	ld c,Item.id		; $47b7
	ld a,(bc)		; $47b9
	cp ITEMID_MYSTERY_SEED			; $47ba
	ret nz			; $47bc

	ldh a,(<hActiveObjectType)	; $47bd
	add Object.var3f			; $47bf
	ld e,a			; $47c1
	ld a,(de)		; $47c2
	cpl			; $47c3
	bit 5,a			; $47c4
	ret nz			; $47c6

	ld h,b			; $47c7
	ld l,Item.var2a		; $47c8
	ld (hl),$40		; $47ca
	ld l,Item.collisionType		; $47cc
	res 7,(hl)		; $47ce

	ldh a,(<hActiveObjectType)	; $47d0
	add Object.var2a			; $47d2
	ld e,a			; $47d4
	ld a,$9a		; $47d5
	ld (de),a		; $47d7

	ld a,e			; $47d8
	add Object.stunCounter-Object.var2a			; $47d9
	ld e,a			; $47db
	xor a			; $47dc
	ld (de),a		; $47dd
	ret			; $47de

;;
; This can be called for either Link or an item object. (Perhaps other special objects?)
;
; @param	b	Link/Item object
; @param	d	Enemy / part object
; @param	e	Link damage type (see enum below)
; @addr{47df}
_applyDamageToLink_paramE:
	ld a,e			; $47df

;;
; @addr{47e0}
_applyDamageToLink:
	push af			; $47e0
	ldh a,(<hActiveObjectType)	; $47e1
	add Object.var3e			; $47e3
	ld e,a			; $47e5
	ld a,(de)		; $47e6
	ld (wTmpcec0),a		; $47e7
	pop af			; $47ea
	ld hl,@damageTypeTable		; $47eb
	rst_addAToHl			; $47ee

	bit 7,(hl)		; $47ef
	jr z,++			; $47f1

	ldh a,(<hActiveObjectType)	; $47f3
	add Object.damage			; $47f5
	ld e,a			; $47f7
	ld a,(de)		; $47f8
	ld c,Item.damageToApply		; $47f9
	ld (bc),a		; $47fb
++
	ldi a,(hl)		; $47fc
	ld e,a			; $47fd
	ld c,Item.var2a		; $47fe
	ld a,(bc)		; $4800
	ld c,a			; $4801
	ld a,(wTmpcec0)		; $4802
	or c			; $4805
	ld c,Item.var2a		; $4806
	ld (bc),a		; $4808

	; bc = invincibilityCounter
	inc c			; $4809
	ldi a,(hl)		; $480a
	bit 5,e			; $480b
	jr z,+			; $480d
	ld (bc),a		; $480f
+
	; bc = knockbackAngle
	inc c			; $4810
	ldh a,(<hFF8A)	; $4811
	ld (bc),a		; $4813

	; bc = knockbackCounter
	inc c			; $4814
	ldi a,(hl)		; $4815
	bit 4,e			; $4816
	jr z,+			; $4818
	ld (bc),a		; $481a
+
	; bc = stunCounter
	inc c			; $481b
	ldi a,(hl)		; $481c
	bit 4,e			; $481d
	jr z,+			; $481f
	ld (bc),a		; $4821
+
	ld a,e			; $4822
	and $07			; $4823
	ret z			; $4825

	ld hl,@soundEffects		; $4826
	rst_addAToHl			; $4829
	ld a,(hl)		; $482a
	jp playSound		; $482b

; Data format:
; b0: bit 7: whether to apply damage to Link
;     bit 6: does nothing?
;     bit 5: whether to give invincibility frames
;     bit 4: whether to give knockback
;     bit 3: whether to stun it
;     bits 0-2: sound effect to play
; b1: Value to write to Object.invincibilityFrames (if applicable)
; b2: Value to write to Object.knockbackCounter (if applicable)
; b3: Value to write to Object.stunCounter (if applicable)

; @addr{482e}
@damageTypeTable:
	.db $b2 $19 $07 $00 ; LINKDMG_00
	.db $b2 $22 $0f $00 ; LINKDMG_04
	.db $b2 $2a $15 $00 ; LINKDMG_08
	.db $b2 $20 $00 $00 ; LINKDMG_0c
	.db $31 $f8 $0b $00 ; LINKDMG_10
	.db $31 $f1 $13 $00 ; LINKDMG_14
	.db $31 $ea $19 $00 ; LINKDMG_18
	.db $40 $00 $00 $00 ; LINKDMG_1c
	.db $03 $00 $00 $00 ; LINKDMG_20
	.db $c0 $00 $00 $00 ; LINKDMG_24
	.db $13 $00 $10 $00 ; LINKDMG_28
	.db $62 $f4 $00 $00 ; LINKDMG_2c
	.db $c0 $00 $00 $00 ; LINKDMG_30
	.db $31 $fa $06 $00 ; LINKDMG_34
	.db $31 $f8 $08 $00 ; LINKDMG_38

; @addr{486a}
@soundEffects:
	.db SND_NONE
	.db SND_BOMB_LAND
	.db SND_DAMAGE_LINK
	.db SND_CLINK2
	.db SND_BOMB_LAND
	.db SND_BOMB_LAND
	.db SND_BOMB_LAND
	.db SND_BOMB_LAND

.ENUM 0 EXPORT
	LINKDMG_00	dsb 4
	LINKDMG_04	dsb 4
	LINKDMG_08	dsb 4
	LINKDMG_0c	dsb 4
	LINKDMG_10	dsb 4
	LINKDMG_14	dsb 4
	LINKDMG_18	dsb 4
	LINKDMG_1c	dsb 4
	LINKDMG_20	dsb 4
	LINKDMG_24	dsb 4
	LINKDMG_28	dsb 4
	LINKDMG_2c	dsb 4
	LINKDMG_30	dsb 4
	LINKDMG_34	dsb 4
	LINKDMG_38	dsb 4
.ENDE

.ends


 m_section_superfree "Item_Code" namespace "itemCode"

;;
; @addr{4872}
updateItems:
	ld b,$00		; $4872

	ld a,(wScrollMode)		; $4874
	cp $08			; $4877
	jr z,@dontUpdateItems	; $4879

	ld a,(wDisabledObjects)		; $487b
	and $90			; $487e
	jr nz,@dontUpdateItems	; $4880

	ld a,(wPaletteThread_mode)		; $4882
	or a			; $4885
	jr nz,@dontUpdateItems	; $4886

	ld a,(wTextIsActive)		; $4888
	or a			; $488b
	jr z,++			; $488c

	; Set b to $01, indicating items shouldn't be updated after initialization
@dontUpdateItems:
	inc b			; $488e
++
	ld hl,$cc8b		; $488f
	ld a,(hl)		; $4892
	and $fe			; $4893
	or b			; $4895
	ld (hl),a		; $4896

	xor a			; $4897
	ld (wScentSeedActive),a		; $4898

	ld a,Item.start		; $489b
	ldh (<hActiveObjectType),a	; $489d
	ld d,FIRST_ITEM_INDEX		; $489f
	ld a,d			; $48a1

@itemLoop:
	ldh (<hActiveObject),a	; $48a2
	ld e,Item.start		; $48a4
	ld a,(de)		; $48a6
	or a			; $48a7
	jr z,@nextItem		; $48a8

	; Always update items when uninitialized
	ld e,Item.state		; $48aa
	ld a,(de)		; $48ac
	or a			; $48ad
	jr z,+			; $48ae

	; If already initialized, don't update items if this variable is set
	ld a,($cc8b)		; $48b0
	or a			; $48b3
+
	call z,@updateItem		; $48b4
@nextItem:
	inc d			; $48b7
	ld a,d			; $48b8
	cp LAST_ITEM_INDEX+1			; $48b9
	jr c,@itemLoop		; $48bb
	ret			; $48bd

;;
; @param d Item index
; @addr{48be}
@updateItem:
	ld e,Item.id		; $48be
	ld a,(de)		; $48c0
	rst_jumpTable			; $48c1
	.dw itemCode00 ; 0x00
	.dw itemDelete ; 0x01
	.dw itemCode02 ; 0x02
	.dw itemCode03 ; 0x03
	.dw itemCode04 ; 0x04
	.dw itemCode05 ; 0x05
	.dw itemCode06 ; 0x06
	.dw itemDelete ; 0x07
	.dw itemDelete ; 0x08
	.dw itemCode09 ; 0x09
	.dw itemCode0a ; 0x0a
	.dw itemCode0b ; 0x0b
	.dw itemCode0c ; 0x0c
	.dw itemCode0d ; 0x0d
	.dw itemDelete ; 0x0e
	.dw itemCode0f ; 0x0f
	.dw itemDelete ; 0x10
	.dw itemDelete ; 0x11
	.dw itemDelete ; 0x12
	.dw itemCode13 ; 0x13
	.dw itemDelete ; 0x14
	.dw itemCode15 ; 0x15
	.dw itemCode16 ; 0x16
	.dw itemDelete ; 0x17
	.dw itemCode18 ; 0x18
	.dw itemDelete ; 0x19
	.dw itemCode1a ; 0x1a
	.dw itemDelete ; 0x1b
	.dw itemDelete ; 0x1c
	.dw itemCode1d ; 0x1d
	.dw itemCode1e ; 0x1e
	.dw itemDelete ; 0x1f
	.dw itemCode20 ; 0x20
	.dw itemCode21 ; 0x21
	.dw itemCode22 ; 0x22
	.dw itemCode23 ; 0x23
	.dw itemCode24 ; 0x24
	.dw itemDelete ; 0x25
	.dw itemDelete ; 0x26
	.dw itemCode27 ; 0x27
	.dw itemCode28 ; 0x28
	.dw itemCode29 ; 0x29
	.dw itemCode2a ; 0x2a
	.dw itemCode2b ; 0x2b

;;
; The main difference between this and the above "updateItems" is that this is called
; after all of the other objects have been updated. This also doesn't have any conditions
; before it starts calling the update code.
;
; @addr{491a}
updateItemsPost:
	lda Item.start			; $491a
	ldh (<hActiveObjectType),a	; $491b
	ld d,FIRST_ITEM_INDEX		; $491d
	ld a,d			; $491f
@itemLoop:
	ldh (<hActiveObject),a	; $4920
	ld e,Item.enabled		; $4922
	ld a,(de)		; $4924
	or a			; $4925
	call nz,_updateItemPost		; $4926
	inc d			; $4929
	ld a,d			; $492a
	cp $e0			; $492b
	jr c,@itemLoop		; $492d

itemCodeNilPost:
	ret			; $492f

;;
; @addr{4930}
_updateItemPost:
	ld e,$01		; $4930
	ld a,(de)		; $4932
	rst_jumpTable			; $4933

	.dw itemCode00Post	; 0x00
	.dw itemCodeNilPost	; 0x01
	.dw itemCode02Post	; 0x02
	.dw itemCodeNilPost	; 0x03
	.dw itemCode04Post	; 0x04
	.dw itemCode05Post	; 0x05
	.dw itemCodeNilPost	; 0x06
	.dw itemCode07Post	; 0x07
	.dw itemCode08Post	; 0x08
	.dw itemCodeNilPost	; 0x09
	.dw itemCode0aPost	; 0x0a
	.dw itemCode0bPost	; 0x0b
	.dw itemCode0cPost	; 0x0c
	.dw itemCodeNilPost	; 0x0d
	.dw itemCodeNilPost	; 0x0e
	.dw itemCode0fPost	; 0x0f
	.dw itemCodeNilPost	; 0x10
	.dw itemCodeNilPost	; 0x11
	.dw itemCodeNilPost	; 0x12
	.dw itemCode13Post	; 0x13
	.dw itemCodeNilPost	; 0x14
	.dw itemCodeNilPost	; 0x15
	.dw itemCodeNilPost	; 0x16
	.dw itemCodeNilPost	; 0x17
	.dw itemCodeNilPost	; 0x18
	.dw itemCodeNilPost	; 0x19
	.dw itemCodeNilPost	; 0x1a
	.dw itemCodeNilPost	; 0x1b
	.dw itemCodeNilPost	; 0x1c
	.dw itemCode1dPost	; 0x1d
	.dw itemCode1ePost	; 0x1e
	.dw itemCodeNilPost	; 0x1f
	.dw itemCodeNilPost	; 0x20
	.dw itemCodeNilPost	; 0x21
	.dw itemCodeNilPost	; 0x22
	.dw itemCodeNilPost	; 0x23
	.dw itemCodeNilPost	; 0x24
	.dw itemCodeNilPost	; 0x25
	.dw itemCodeNilPost	; 0x26
	.dw itemCodeNilPost	; 0x27
	.dw itemCodeNilPost	; 0x28
	.dw itemCodeNilPost	; 0x29
	.dw itemCodeNilPost	; 0x2a
	.dw itemCodeNilPost	; 0x2b

;;
; @addr{498c}
_loadAttributesAndGraphicsAndIncState:
	call itemIncState		; $498c
	ld l,Item.enabled		; $498f
	ld (hl),$03		; $4991

;;
; Loads values for Item.collisionRadiusY/X, Item.damage, Item.health, and loads graphics.
; @addr{4993}
_itemLoadAttributesAndGraphics:
	ld e,Item.id		; $4993
	ld a,(de)		; $4995
	add a			; $4996
	ld hl,itemAttributes		; $4997
	rst_addDoubleIndex			; $499a

	; b0: Item.collisionType
	ld e,Item.collisionType		; $499b
	ldi a,(hl)		; $499d
	ld (de),a		; $499e

	; b1: Item.collisionRadiusY/X
	ld e,Item.collisionRadiusY		; $499f
	ld a,(hl)		; $49a1
	swap a			; $49a2
	and $0f			; $49a4
	ld (de),a		; $49a6
	inc e			; $49a7
	ldi a,(hl)		; $49a8
	and $0f			; $49a9
	ld (de),a		; $49ab

	; b2: Item.damage
	inc e			; $49ac
	ldi a,(hl)		; $49ad
	ld (de),a		; $49ae
	ld c,a			; $49af

	; b3: Item.health
	inc e			; $49b0
	ldi a,(hl)		; $49b1
	ld (de),a		; $49b2

	; Write Item.damage to Item.var3a as well?
	ld e,Item.var3a		; $49b3
	ld a,c			; $49b5
	ld (de),a		; $49b6

	call _itemSetVar3cToFF		; $49b7
	jpab bank3f.itemLoadGraphics		; $49ba

;;
; @addr{49c2}
_itemSetVar3cToFF:
	ld e,Item.var3c		; $49c2
	ld a,$ff		; $49c4
	ld (de),a		; $49c6
	ret			; $49c7

;;
; Reduces the item's health according to the Item.damageToApply variable.
; Also does something with Item.var2a.
;
; @param[out]	a	[Item.var2a]
; @param[out]	hl	Item.var2a
; @param[out]	zflag	Set if Item.var2a is zero.
; @param[out]	cflag	Set if health went below 0
; @addr{49c8}
_itemUpdateDamageToApply:
	ld h,d			; $49c8
	ld l,Item.damageToApply		; $49c9
	ld a,(hl)		; $49cb
	ld (hl),$00		; $49cc

	ld l,Item.health		; $49ce
	add (hl)		; $49d0
	ld (hl),a		; $49d1
	rlca			; $49d2
	ld l,Item.var2a		; $49d3
	ld a,(hl)		; $49d5
	dec a			; $49d6
	inc a			; $49d7
	ret			; $49d8

;;
; @addr{49d9}
itemAnimate:
	ld h,d			; $49d9
	ld l,Item.animCounter		; $49da
	dec (hl)		; $49dc
	ret nz			; $49dd

	ld l,Item.animPointer		; $49de
	jr _itemNextAnimationFrame		; $49e0

;;
; @param a Animation index
; @addr{49e2}
itemSetAnimation:
	add a			; $49e2
	ld c,a			; $49e3
	ld b,$00		; $49e4
	ld e,Item.id		; $49e6
	ld a,(de)		; $49e8
	ld hl,itemAnimationTable		; $49e9
	rst_addDoubleIndex			; $49ec
	ldi a,(hl)		; $49ed
	ld h,(hl)		; $49ee
	ld l,a			; $49ef
	add hl,bc		; $49f0

;;
; @addr{49f1}
_itemNextAnimationFrame:
	ldi a,(hl)		; $49f1
	ld h,(hl)		; $49f2
	ld l,a			; $49f3

	; Byte 0: how many frames to hold it (or $ff to loop)
	ldi a,(hl)		; $49f4
	cp $ff			; $49f5
	jr nz,++		; $49f7

	; If $ff, animation loops
	ld b,a			; $49f9
	ld c,(hl)		; $49fa
	add hl,bc		; $49fb
	ldi a,(hl)		; $49fc
++
	ld e,Item.animCounter		; $49fd
	ld (de),a		; $49ff

	; Byte 1: frame index (store in bc for now)
	ldi a,(hl)		; $4a00
	ld c,a			; $4a01
	ld b,$00		; $4a02

	; Item.animParameter
	inc e			; $4a04
	ldi a,(hl)		; $4a05
	ld (de),a		; $4a06

	; Item.animPointer
	inc e			; $4a07
	; Save the current position in the animation
	ld a,l			; $4a08
	ld (de),a		; $4a09
	inc e			; $4a0a
	ld a,h			; $4a0b
	ld (de),a		; $4a0c

	ld e,Item.id		; $4a0d
	ld a,(de)		; $4a0f
	ld hl,itemOamDataTable		; $4a10
	rst_addDoubleIndex			; $4a13
	ldi a,(hl)		; $4a14
	ld h,(hl)		; $4a15
	ld l,a			; $4a16
	add hl,bc		; $4a17

	; Set the address of the oam data
	ld e,Item.oamDataAddress		; $4a18
	ldi a,(hl)		; $4a1a
	ld (de),a		; $4a1b
	inc e			; $4a1c
	ldi a,(hl)		; $4a1d
	and $3f			; $4a1e
	ld (de),a		; $4a20
	ret			; $4a21

;;
; Transfer an item's knockbackCounter and knockbackAngle to Link.
; @addr{4a22}
_itemTransferKnockbackToLink:
	ld h,d			; $4a22
	ld l,Item.knockbackCounter		; $4a23
	ld a,(hl)		; $4a25
	or a			; $4a26
	ret z			; $4a27

	ld (hl),$00		; $4a28

	; b = [Item.knockbackAngle]
	dec l			; $4a2a
	ld b,(hl)		; $4a2b

	ld hl,w1Link.knockbackCounter		; $4a2c
	cp (hl)			; $4a2f
	jr c,+			; $4a30
	ld (hl),a		; $4a32
+
	; Set Item.knockbackAngle
	dec l			; $4a33
	ld (hl),b		; $4a34
	ret			; $4a35

;;
; Applies speed based on Item.direction?
;
; @param	hl	Table of offsets for Y/X/Z positions based on Item.direction
; @addr{4a36}
_applyOffsetTableHL:
	ld e,Item.direction		; $4a36
	ld a,(de)		; $4a38

	; a *= 3
	ld e,a			; $4a39
	add a			; $4a3a
	add e			; $4a3b

	rst_addAToHl			; $4a3c

	; b0: Y offset
	ld e,Item.yh		; $4a3d
	ld a,(de)		; $4a3f
	add (hl)		; $4a40
	ld (de),a		; $4a41

	; b1: X offset
	inc hl			; $4a42
	ld e,Item.xh		; $4a43
	ld a,(de)		; $4a45
	add (hl)		; $4a46
	ld (de),a		; $4a47

	; b2: Z offset
	inc hl			; $4a48
	ld e,Item.zh		; $4a49
	ld a,(de)		; $4a4b
	add (hl)		; $4a4c
	ld (de),a		; $4a4d
	ret			; $4a4e

;;
; In sidescrolling areas, the Z position and Y position can't both exist.
; This function adds the Z position to the Y position, and zeroes the Z position.
;
; @param[out]	zflag	Set if not in a sidescrolling area
; @addr{4a4f}
_itemMergeZPositionIfSidescrollingArea:
	ld h,d			; $4a4f
	ld a,(wAreaFlags)		; $4a50
	and AREAFLAG_SIDESCROLL			; $4a53
	ret z			; $4a55

	ld e,Item.yh		; $4a56
	ld l,Item.zh		; $4a58
	ld a,(de)		; $4a5a
	add (hl)		; $4a5b
	ld (de),a		; $4a5c
	xor a			; $4a5d
	ldd (hl),a		; $4a5e
	ld (hl),a		; $4a5f
	or d			; $4a60
	ret			; $4a61

;;
; Updates Z position if in midair (not if on the ground). If the item falls into a hazard
; (water/lava/hole), this creates an animation, deletes the item, and returns from the
; caller.
;
; @param	c	Gravity
; @addr{4a62}
_itemUpdateSpeedZAndCheckHazards:
	ld e,Item.zh		; $4a62
	ld a,e			; $4a64
	ldh (<hFF8B),a	; $4a65
	ld a,(de)		; $4a67
	rlca			; $4a68
	jr nc,++		; $4a69

	; If in midair, update z speed
	rrca			; $4a6b
	ldh (<hFF8B),a	; $4a6c
	call objectUpdateSpeedZ_paramC		; $4a6e
	jr nz,+++		; $4a71

	; Item has hit the ground

	ldh (<hFF8B),a	; $4a73
++
	call objectReplaceWithAnimationIfOnHazard		; $4a75
	jr nc,+++		; $4a78

	; Return from caller if this was replaced with an animation
	pop hl			; $4a7a
	ld a,$ff		; $4a7b
	ret			; $4a7d

	; Above ground?
+++
	ldh a,(<hFF8B)	; $4a7e
	rlca			; $4a80
	or a			; $4a81
	ret			; $4a82

;;
; This function moves a bomb toward a point stored in the item's var31/var32 variables.
; Does nothing when var31/var32 are set to zero.
;
; Not used by bombchus, but IS used by scent seeds...
;
; @param[out]	cflag	Set when the bomb has reached the point (if such a point exists)
; @addr{4a83}
_bombPullTowardPoint:
	ld h,d			; $4a83

	; Return if object is above ground.
	ld l,Item.zh		; $4a84
	and $80			; $4a86
	jr nz,@end		; $4a88

	; The following code pulls a bomb towards a specific point.
	; The point is stored in its var31/var32 variables.

	; Load bc with Item.var31/32, and zero out those values
	ld l,Item.var31		; $4a8a
	ld b,(hl)		; $4a8c
	ldi (hl),a		; $4a8d
	ld c,(hl)		; $4a8e
	ldi (hl),a		; $4a8f
	; Return if they were already zero
	or b			; $4a90
	ret z			; $4a91

	; Return if the object contains the point
	push bc			; $4a92
	call objectCheckContainsPoint		; $4a93
	pop bc			; $4a96
	ret c			; $4a97

	; If it doesn't contain the point (not there yet), move toward it
	call objectGetRelativeAngle		; $4a98
	ld c,a			; $4a9b
	ld b,$0a		; $4a9c
	ld e,Item.angle		; $4a9e
	call objectApplyGivenSpeed		; $4aa0
@end:
	xor a			; $4aa3
	ret			; $4aa4

;;
; Deals with checking whether a thrown item has landed on a hole/water/lava, updating its
; vertical speed, etc.
;
; Sets Item.var3b depending on what it landed on (see structs.s for more info).
;
; This does not check for collision with walls; it only updates "vertical" motion and
; checks for collision on that front.
;
; @param	c	Gravity
; @param[out]	cflag	Set if the item has landed.
; @addr{4aa5}
_itemUpdateThrowingVertically:
	; Jump if in a sidescrolling area
	call _itemMergeZPositionIfSidescrollingArea		; $4aa5
	jr nz,@sidescrolling	; $4aa8

	; Update vertical speed, return if the object hasn't landed yet
	call objectUpdateSpeedZ_paramC		; $4aaa
	jr nz,@unsetCollision			; $4aad

	; Object has landed / is bouncing; need to check for collision with water, holes,
	; etc.

	call @checkHoleOrWater		; $4aaf
	bit 4,(hl)		; $4ab2
	set 4,(hl)		; $4ab4
	scf			; $4ab6
	ret			; $4ab7

;;
; @param[out]	zflag	Unset.
; @param[out]	cflag	Unset.
; @addr{4ab8}
@unsetCollision:
	ld l,Item.var3b		; $4ab8
	res 4,(hl)		; $4aba
	or d			; $4abc
	ret			; $4abd

;;
; @param[out]	zflag	Former value of bit 4 of Item.var3b.
; @param[out]	cflag	Set.
; @addr{4abe}
@setCollision:
	ld h,d			; $4abe
	ld l,Item.var3b		; $4abf
	bit 4,(hl)		; $4ac1
	set 4,(hl)		; $4ac3
	scf			; $4ac5
	ret			; $4ac6

;;
; Throwing item update code for sidescrolling areas
;
; @addr{4ac7}
@sidescrolling:
	push bc			; $4ac7
	call @checkHoleOrWater		; $4ac8

	; Jump if object is not moving up.
	ld l,Item.speedZ+1		; $4acb
	bit 7,(hl)		; $4acd
	jr z,@notMovingUp		; $4acf

	; Check for collision with the ceiling
	call objectCheckTileCollision_allowHoles		; $4ad1
	ld h,d			; $4ad4
	pop bc			; $4ad5
	jr nc,@noCeilingCollision	; $4ad6

	; Object collided with ceiling, so Y position isn't updated (though gravity is)
	ld b,$03		; $4ad8
	jr @updateGravity		; $4ada

@notMovingUp:
	; Check for a collision 5 pixels below center
	ld l,Item.yh		; $4adc
	ldi a,(hl)		; $4ade
	add $05			; $4adf
	ld b,a			; $4ae1
	inc l			; $4ae2
	ld c,(hl)		; $4ae3
	call checkTileCollisionAt_allowHoles		; $4ae4
	ld h,d			; $4ae7
	pop bc			; $4ae8
	jr c,@setCollision		; $4ae9

@noCeilingCollision:
	; Set maximum gravity = $0300 normally, $0100 when in water
	ld l,Item.var3b		; $4aeb
	bit 0,(hl)		; $4aed
	ld b,$03		; $4aef
	jr z,+			; $4af1

	ld b,$01		; $4af3
	bit 7,(hl)		; $4af5
	jr nz,@unsetCollision	; $4af7
+
	; Update Y position based on speedZ (since this is a sidescrolling area)
	ld e,Item.speedZ		; $4af9
	ld l,Item.y		; $4afb
	ld a,(de)		; $4afd
	add (hl)		; $4afe
	ldi (hl),a		; $4aff
	inc e			; $4b00
	ld a,(de)		; $4b01
	adc (hl)		; $4b02
	ldi (hl),a		; $4b03

@updateGravity:
	; Update speedZ based on gravity
	ld l,Item.speedZ		; $4b04
	ld a,(hl)		; $4b06
	add c			; $4b07
	ldi (hl),a		; $4b08
	ld a,(hl)		; $4b09
	adc $00			; $4b0a
	ld (hl),a		; $4b0c

	; Return if speedZ is beneath the maximum speed ('b').
	bit 7,a			; $4b0d
	jr nz,@unsetCollision	; $4b0f
	cp b			; $4b11
	jr c,@unsetCollision	; $4b12

	; Set speedZ to the maximum speed 'b'.
	ld (hl),b		; $4b14
	dec l			; $4b15
	ld (hl),$00		; $4b16
	jr @unsetCollision		; $4b18

;;
; Updates Item.var3b depending whether it's on a hole, lava, water tile.
; @addr{4b1a}
@checkHoleOrWater:
	call _itemMergeZPositionIfSidescrollingArea		; $4b1a
	jr nz,@@sidescrolling			; $4b1d

	; Note: a=0 here

	; If top-down view and object is in midair, skip the "objectCheckIsOverHazard" check
	ld l,Item.zh		; $4b1f
	bit 7,(hl)		; $4b21
	jr nz,++		; $4b23

@@sidescrolling:
	call objectCheckIsOverHazard		; $4b25
	ld h,d			; $4b28
++
	; Here, 'a' holds the value for what kind of landing collision has occurred.

	; Update Item.var3b: flip bit 7, clear bit 6, update bits 0-2
	ld b,a			; $4b29
	ld l,Item.var3b		; $4b2a
	ld a,(hl)		; $4b2c
	ld c,a			; $4b2d
	and $b8			; $4b2e
	xor $80			; $4b30
	or b			; $4b32
	ld (hl),a		; $4b33

	; Set bit 6 if the item's bit 0 has changed?
	; (in other words, "landed on water" state has changed)
	ld a,b			; $4b34
	xor c			; $4b35
	rrca			; $4b36
	jr nc,+			; $4b37
	set 6,(hl)		; $4b39
+
	ret			; $4b3b

;;
; Calls _itemUpdateThrowingVertically and creates an appropriate animation if this item
; has fallen into something (water, lava, or a hole). Caller still needs to delete the
; object.
;
; @param	c	Gravity
; @param[out]	cflag	Set if the object has landed in water, lava, or a hole.
; @param[out]	zflag	Set if the object is in midair.
; @addr{4b3c}
_itemUpdateThrowingVerticallyAndCheckHazards:
	call _itemUpdateThrowingVertically		; $4b3c
	jr c,@landed			; $4b3f

	; Object isn't on the ground, so only check for collisions in sidescrolling areas.

	ld a,(wAreaFlags)		; $4b41
	and AREAFLAG_SIDESCROLL			; $4b44
	jr z,+			; $4b46

	ld b,INTERACID_LAVASPLASH		; $4b48
	bit 2,(hl)		; $4b4a
	jr nz,@createSplash		; $4b4c

	ld b,INTERACID_SPLASH		; $4b4e
	bit 6,(hl)		; $4b50
	call nz,@createSplash		; $4b52
+
	xor a			; $4b55
	ret			; $4b56

@landed:
	; If the item has landed in a sidescrolling area, there's no need to check what it
	; landed on (since if it had touched water, it would have still been considered
	; to be in midair).
	ld a,(wAreaFlags)		; $4b57
	and AREAFLAG_SIDESCROLL			; $4b5a
	jr nz,@noCollisions		; $4b5c

	ld h,d			; $4b5e
	ld l,Item.var3b		; $4b5f
	ld b,INTERACID_SPLASH		; $4b61
	bit 0,(hl)		; $4b63
	jr nz,@createSplash		; $4b65

	ld b,$0f		; $4b67
	bit 1,(hl)		; $4b69
	jr nz,@createHoleAnim	; $4b6b

	ld b,INTERACID_LAVASPLASH		; $4b6d
	bit 2,(hl)		; $4b6f
	jr nz,@createSplash		; $4b71

@noCollisions:
	xor a			; $4b73
	bit 4,(hl)		; $4b74
	ret			; $4b76

@createSplash:
	call objectCreateInteractionWithSubid00		; $4b77
	scf			; $4b7a
	ret			; $4b7b

@createHoleAnim:
	call objectCreateFallingDownHoleInteraction		; $4b7c
	scf			; $4b7f
	ret			; $4b80

;;
; Creates an interaction to do the clinking animation.
; @addr{4b81}
_objectCreateClinkInteraction:
	ld b,INTERACID_CLINK		; $4b81
	jp objectCreateInteractionWithSubid00		; $4b83

;;
; @addr{4b86}
_cpRelatedObject1ID:
	ld a,Object.id		; $4b86
	call objectGetRelatedObject1Var		; $4b88
	ld e,Item.id		; $4b8b
	ld a,(de)		; $4b8d
	cp (hl)			; $4b8e
	ret			; $4b8f

;;
; Same as below, but checks the tile at position bc instead of the tile at the object's
; position.
;
; @param	bc	Position of tile to check
; @addr{4b90}
_itemCheckCanPassSolidTileAt:
	call getTileAtPosition		; $4b90
	jr ++			; $4b93

;;
; This function checks for exceptions to solid tiles which items (switch hook, seeds) can
; pass through. It also keeps track of an "elevation level" in var3e which keeps track of
; how many cliff tiles the item has passed through.
;
; Also updates var3c, var3d (tile position and index).
;
; @param[out]	zflag	Set if there is no collision.
; @addr{4b95}
_itemCheckCanPassSolidTile:
	call objectGetTileAtPosition		; $4b95
++
	; Check if position / tile has changed? (var3c = position, var3d = tile index)
	ld e,a			; $4b98
	ld a,l			; $4b99
	ld h,d			; $4b9a
	ld l,Item.var3c		; $4b9b
	cp (hl)			; $4b9d
	ldi (hl),a		; $4b9e
	jr nz,@tileChanged		; $4b9f

	; Return if the tile index has not changed
	ld a,e			; $4ba1
	cp (hl)			; $4ba2
	ret z			; $4ba3

@tileChanged:
	ld (hl),e		; $4ba4
	ld l,Item.angle		; $4ba5
	ld b,(hl)		; $4ba7
	call _checkTileIsPassableFromDirection		; $4ba8
	jr nc,@collision		; $4bab
	ret z			; $4bad

	; If there was no collision, but the zero flag was not set, the item must move up
	; or down an elevation level (depending on the value of a from the function call).
	ld h,d			; $4bae
	ld l,Item.var3e		; $4baf
	add (hl)		; $4bb1
	ld (hl),a		; $4bb2

	; Check if the item has passed to a "negative" elevation, if so, trigger
	; a collision
	and $80			; $4bb3
	ret z			; $4bb5

@collision:
	ld h,d			; $4bb6
	ld l,Item.var3c		; $4bb7
	ld a,$ff		; $4bb9
	ldi (hl),a		; $4bbb
	ld (hl),a		; $4bbc
	or d			; $4bbd
	ret			; $4bbe

;;
; Checks if an item can pass through the given tile with a given angle.
;
; @param	b	angle
; @param	e	Tile index
; @param[out]	a	The elevation level change that will occur if the item can pass
;			this tile
; @param[out]	cflag	Set if the tile is passable
; @param[out]	zflag	Set if there will be no elevation change (ignore the value of a)
; @addr{4bbf}
_checkTileIsPassableFromDirection:
	; Check if the tile can be passed by items
	ld hl,_itemPassableTilesTable		; $4bbf
	call findByteInCollisionTable_paramE		; $4bc2
	jr c,@canPassWithoutElevationChange		; $4bc5

	; Retrieve a value based on the given angle to see which directions
	; should be checked for passability
	ld a,b			; $4bc7
	ld hl,angleTable		; $4bc8
	rst_addAToHl			; $4bcb
	ld a,(hl)		; $4bcc
	push af			; $4bcd

	ld a,(wActiveCollisions)		; $4bce
	ld hl,_itemPassableCliffTilesTable		; $4bd1
	rst_addDoubleIndex			; $4bd4
	ldi a,(hl)		; $4bd5
	ld h,(hl)		; $4bd6
	ld l,a			; $4bd7

	; If the value retrieved from angleTable was odd, allow the item to pass
	; through 2 directions
	pop af			; $4bd8
	srl a			; $4bd9
	jr nc,@checkOneDirectionOnly	; $4bdb

	rst_addAToHl			; $4bdd
	ld a,(hl)		; $4bde
	push hl			; $4bdf
	rst_addAToHl			; $4be0
	call lookupKey		; $4be1
	pop hl			; $4be4
	jr c,@canPassWithElevationChange		; $4be5

	inc hl			; $4be7
	jr ++			; $4be8

@checkOneDirectionOnly:
	rst_addAToHl			; $4bea
++
	ld a,(hl)		; $4beb
	rst_addAToHl			; $4bec
	call lookupKey		; $4bed
	ret nc			; $4bf0

@canPassWithElevationChange:
	or a			; $4bf1
	scf			; $4bf2
	ret			; $4bf3

@canPassWithoutElevationChange:
	xor a			; $4bf4
	scf			; $4bf5
	ret			; $4bf6

;;
; Checks if the item is on a conveyor belt, updates its position if so.
;
; Used by bombs, bombchus. Might not work well with other items due to assumptions about
; their size.
;
; @addr{4bf7}
_itemUpdateConveyorBelt:
	; Return if in midair
	ld e,Item.zh		; $4bf7
	ld a,(de)		; $4bf9
	rlca			; $4bfa
	ret c			; $4bfb

	; Check if on a conveyor belt; get in 'a' the angle to move in if so
	ld bc,$0500		; $4bfc
	call objectGetRelativeTile		; $4bff
	ld hl,_itemConveyorTilesTable		; $4c02
	call lookupCollisionTable		; $4c05
	ret nc			; $4c08

	push af			; $4c09
	rrca			; $4c0a
	rrca			; $4c0b
	ld hl,_bombEdgeOffsets		; $4c0c
	rst_addAToHl			; $4c0f

	; Set 'bc' to the item's position + offset (where to check for a wall)
	ldi a,(hl)		; $4c10
	ld c,(hl)		; $4c11
	ld h,d			; $4c12
	ld l,Item.yh		; $4c13
	add (hl)		; $4c15
	ld b,a			; $4c16
	ld l,Item.xh		; $4c17
	ld a,(hl)		; $4c19
	add c			; $4c1a
	ld c,a			; $4c1b

	call getTileCollisionsAtPosition		; $4c1c
	cp SPECIALCOLLISION_SCREEN_BOUNDARY			; $4c1f
	jr z,@ret		; $4c21

	call checkGivenCollision_allowHoles		; $4c23
	jr c,@ret		; $4c26

	pop af			; $4c28
	ld c,a			; $4c29
	ld b,SPEED_80		; $4c2a
	ld e,Item.angle		; $4c2c
	jp objectApplyGivenSpeed		; $4c2e

@ret:
	pop af			; $4c31
	ret			; $4c32


; These are offsets from a bomb or bombchu's center to check for wall collisions at.
; This might apply to all throwable items?
_bombEdgeOffsets:
	.db $fd $00 ; DIR_UP
	.db $00 $03 ; DIR_RIGHT
	.db $07 $00 ; DIR_DOWN
	.db $00 $fd ; DIR_LEFT


_itemConveyorTilesTable:
	.dw @collisions0
	.dw @collisions1
	.dw @collisions2
	.dw @collisions3
	.dw @collisions4
	.dw @collisions5

; b0: tile index
; b1: angle to move in

@collisions2:
@collisions5:
	.db TILEINDEX_CONVEYOR_UP	$00
	.db TILEINDEX_CONVEYOR_RIGHT	$08
	.db TILEINDEX_CONVEYOR_DOWN	$10
	.db TILEINDEX_CONVEYOR_LEFT	$18
@collisions0:
@collisions1:
@collisions3:
@collisions4:
	.db $00


; This lists the tiles that are passible from a single direction - usually cliffs.
; The second byte in the .db's specifies whether the item has to go up or down a level of
; elevation in order to pass it.
; @addr{4c50}
_itemPassableCliffTilesTable:
	.dw @collisions0
	.dw @collisions1
	.dw @collisions2
	.dw @collisions3
	.dw @collisions4
	.dw @collisions5

@collisions0:
@collisions4:
	.db @@up-CADDR
	.db @@right-CADDR
	.db @@down-CADDR
	.db @@left-CADDR
	.db @@up-CADDR
@@up:
	.db $64 $ff
	.db $05 $ff
	.db $06 $ff
	.db $07 $ff
	.db $8e $ff
	.db $00
@@down:
	.db $64 $01
	.db $05 $01
	.db $06 $01
	.db $07 $01
	.db $8e $01
	.db $00
@@right:
	.db $0b $01
	.db $0a $ff
	.db $00
@@left:
	.db $0b $ff
	.db $0a $01
	.db $00

@collisions1:
	.db @@up-CADDR
	.db @@right-CADDR
	.db @@down-CADDR
	.db @@left-CADDR
	.db @@up-CADDR
@@up:
	.db $b2 $01
	.db $b0 $ff
	.db $00
@@down:
	.db $b0 $01
	.db $b2 $ff
	.db $00
@@right:
	.db $b3 $01
	.db $b1 $ff
	.db $00
@@left:
	.db $b1 $01
	.db $b3 $ff
	.db $00

@collisions2:
@collisions5:
	.db @@up-CADDR
	.db @@right-CADDR
	.db @@down-CADDR
	.db @@left-CADDR
	.db @@up-CADDR

@@up:
	.db $b0 $ff
	.db $b2 $01
	.db $c1 $ff
	.db $c3 $01
	.db $00
@@down:
	.db $b0 $01
	.db $b2 $ff
	.db $c1 $01
	.db $c3 $ff
	.db $00
@@right:
	.db $c4 $01
	.db $c2 $ff
	.db $b3 $01
	.db $b1 $ff
	.db $00
@@left:
	.db $c4 $ff
	.db $c2 $01
	.db $b3 $ff
	.db $b1 $01
	.db $00

@collisions3:
	.db @@up-CADDR
	.db @@right-CADDR
	.db @@down-CADDR
	.db @@left-CADDR
	.db @@up-CADDR
@@up:
@@right:
@@down:
@@left:
	.db $00

; This lists the tiles that can be passed through by items (such as the switch hook or
; seeds) even if their collisions prevent link from passing them.
; @addr{4cc9}
_itemPassableTilesTable:
	.dw @collisions0
	.dw @collisions1
	.dw @collisions2
	.dw @collisions3
	.dw @collisions4
	.dw @collisions5

@collisions0:
@collisions4:
	.db $fd $eb
	.db $00
@collisions1:
	.db $94 $95 $0a
	.db $00
@collisions2:
@collisions5:
	.db $90 $91 $92 $93 $94 $95 $96 $97
	.db $98 $99 $9a $9b $0a $0b $0e $0f
@collisions3:
	.db $00


;;
; ITEMID_EMBER_SEED
; ITEMID_SCENT_SEED
; ITEMID_PEGASUS_SEED
; ITEMID_GALE_SEED
; ITEMID_MYSTERY_SEED
;
; @addr{4ced}
itemCode20:
itemCode21:
itemCode22:
itemCode23:
itemCode24:
	ld e,Item.state		; $4ced
	ld a,(de)		; $4cef
	rst_jumpTable			; $4cf0
	.dw @state0
	.dw _seedItemState1
	.dw _seedItemState2
	.dw _seedItemState3

@state0:
	call _itemLoadAttributesAndGraphics		; $4cf9
	xor a			; $4cfc
	call itemSetAnimation		; $4cfd
	call objectSetVisiblec1		; $4d00
	call itemIncState		; $4d03
	ld bc,$ffe0		; $4d06
	call objectSetSpeedZ		; $4d09

	; Subid is nonzero if being used from seed shooter
	ld l,Item.subid		; $4d0c
	ld a,(hl)		; $4d0e
	or a			; $4d0f
	call z,itemUpdateAngle		; $4d10

	ld l,Item.var34		; $4d13
	ld (hl),$03		; $4d15

	ld l,Item.subid		; $4d17
	ldd a,(hl)		; $4d19
	or a			; $4d1a
	jr nz,@shooter		; $4d1b

	; Satchel
	ldi a,(hl)		; $4d1d
	cp ITEMID_GALE_SEED			; $4d1e
	jr nz,++		; $4d20

	; Gale seed
	ld l,Item.zh		; $4d22
	ld a,(hl)		; $4d24
	add $f8			; $4d25
	ld (hl),a		; $4d27
	ld l,Item.angle		; $4d28
	ld (hl),$ff		; $4d2a
	ret			; $4d2c
++
	ld hl,@satchelPositionOffsets		; $4d2d
	call _applyOffsetTableHL		; $4d30
	ld a,SPEED_c0		; $4d33
	jr @setSpeed		; $4d35

@shooter:
	ld e,Item.angle		; $4d37
	ld a,(de)		; $4d39
	rrca			; $4d3a
	ld hl,@shooterPositionOffsets		; $4d3b
	rst_addAToHl			; $4d3e
	ldi a,(hl)		; $4d3f
	ld c,(hl)		; $4d40
	ld b,a			; $4d41

	ld h,d			; $4d42
	ld l,Item.zh		; $4d43
	ld a,(hl)		; $4d45
	add $fe			; $4d46
	ld (hl),a		; $4d48

	; Since 'd'='h', this will copy its own position and apply the offset
	call objectCopyPositionWithOffset		; $4d49

	ld hl,wIsSeedShooterInUse		; $4d4c
	inc (hl)		; $4d4f
	ld a,SPEED_300		; $4d50

@setSpeed:
	ld e,Item.speed		; $4d52
	ld (de),a		; $4d54

	; If it's a mystery seed, get a random effect
	ld e,Item.id		; $4d55
	ld a,(de)		; $4d57
	cp ITEMID_MYSTERY_SEED			; $4d58
	ret nz			; $4d5a

	call getRandomNumber_noPreserveVars		; $4d5b
	and $03			; $4d5e
	ld e,Item.var03		; $4d60
	ld (de),a		; $4d62
	add $80|ITEMCOLLISION_EMBER_SEED			; $4d63
	ld e,Item.collisionType		; $4d65
	ld (de),a		; $4d67
	ret			; $4d68


; Y/X/Z position offsets relative to Link to make seeds appear at (for satchel)
@satchelPositionOffsets:
	.db $fc $00 $fe ; DIR_UP
	.db $01 $04 $fe ; DIR_RIGHT
	.db $05 $00 $fe ; DIR_DOWN
	.db $01 $fb $fe ; DIR_LEFT

; Y/X offsets for shooter
@shooterPositionOffsets:
	.db $f2 $fc ; Up
	.db $fc $0b ; Up-right
	.db $05 $0c ; Right
	.db $09 $0b ; Down-right
	.db $0d $03 ; Down
	.db $0a $f8 ; Down-left
	.db $05 $f3 ; Left
	.db $f8 $f8 ; Up-left


;;
; State 1: seed moving
; @addr{4d85}
_seedItemState1:
	call _itemUpdateDamageToApply		; $4d85
	jr z,@noCollision		; $4d88

	; Check bit 4 of Item.var2a
	bit 4,a			; $4d8a
	jr z,@seedCollidedWithEnemy	; $4d8c

	; [Item.var2a] = 0
	ld (hl),$00		; $4d8e

	call _func_50f4		; $4d90
	jr z,@updatePosition	; $4d93
	jr @seedCollidedWithWall		; $4d95

@noCollision:
	ld e,Item.subid		; $4d97
	ld a,(de)		; $4d99
	or a			; $4d9a
	jr z,@satchelUpdate	; $4d9b

	call _seedItemUpdateBouncing		; $4d9d
	jr nz,@seedCollidedWithWall	; $4da0

@updatePosition:
	call objectCheckWithinRoomBoundary		; $4da2
	jp c,objectApplySpeed		; $4da5
	jp _seedItemDelete		; $4da8

@satchelUpdate:
	; Set speed to 0 if landed in water?
	ld h,d			; $4dab
	ld l,Item.var3b		; $4dac
	bit 0,(hl)		; $4dae
	jr z,+			; $4db0
	ld l,Item.speed		; $4db2
	ld (hl),SPEED_0		; $4db4
+
	call objectCheckWithinRoomBoundary		; $4db6
	jp nc,_seedItemDelete		; $4db9

	call objectApplySpeed		; $4dbc
	ld c,$1c		; $4dbf
	call _itemUpdateThrowingVerticallyAndCheckHazards		; $4dc1
	jp c,_seedItemDelete		; $4dc4
	ret z			; $4dc7

; Landed on ground

	ld a,SND_BOMB_LAND	; $4dc8
	call playSound		; $4dca
	call itemAnimate		; $4dcd
	ld e,Item.id		; $4dd0
	ld a,(de)		; $4dd2
	sub ITEMID_EMBER_SEED			; $4dd3
	rst_jumpTable			; $4dd5
	.dw @emberStandard
	.dw @scentLanded
	.dw _seedItemDelete
	.dw @galeLanded
	.dw @mysteryStandard


; This activates the seed on collision with something. The behaviour is slightly different
; than when it lands on the ground (which is covered above).
@seedCollidedWithWall:
	call itemAnimate		; $4de0
	ld e,Item.id		; $4de3
	ld a,(de)		; $4de5
	sub ITEMID_EMBER_SEED			; $4de6
	rst_jumpTable			; $4de8
	.dw @emberStandard
	.dw @scentOrPegasusCollided
	.dw @scentOrPegasusCollided
	.dw @galeCollidedWithWall
	.dw @mysteryStandard


; Behaviour on collision with enemy; again slightly different
@seedCollidedWithEnemy:
	call itemAnimate		; $4df3
	ld e,Item.collisionType		; $4df6
	xor a			; $4df8
	ld (de),a		; $4df9
	ld e,Item.id		; $4dfa
	ld a,(de)		; $4dfc
	sub ITEMID_EMBER_SEED			; $4dfd
	rst_jumpTable			; $4dff
	.dw @emberStandard
	.dw @scentOrPegasusCollided
	.dw @scentOrPegasusCollided
	.dw @galeCollidedWithEnemy
	.dw @mysteryCollidedWithEnemy


@emberStandard:
@galeCollidedWithEnemy:
	call @initState3		; $4e0a
	jp objectSetVisible82		; $4e0d


@scentLanded:
	ld a,$27		; $4e10
	call @loadGfxVarsWithIndex		; $4e12
	ld a,$02		; $4e15
	call itemSetState		; $4e17
	ld l,Item.collisionType		; $4e1a
	res 7,(hl)		; $4e1c
	ld a,$01		; $4e1e
	call itemSetAnimation		; $4e20
	jp objectSetVisible83		; $4e23


@scentOrPegasusCollided:
	ld e,Item.collisionType		; $4e26
	xor a			; $4e28
	ld (de),a		; $4e29
	jr @initState3		; $4e2a


@galeLanded:
	call @breakTileWithGaleSeed		; $4e2c

	ld a,$25		; $4e2f
	call @loadGfxVarsWithIndex		; $4e31
	ld a,$02		; $4e34
	call itemSetState		; $4e36

	ld l,Item.collisionType		; $4e39
	xor a			; $4e3b
	ldi (hl),a		; $4e3c

	; Set collisionRadiusY/X
	inc l			; $4e3d
	ld a,$02		; $4e3e
	ldi (hl),a		; $4e40
	ld (hl),a		; $4e41

	jp objectSetVisible82		; $4e42


@breakTileWithGaleSeed:
	ld a,BREAKABLETILESOURCE_0d		; $4e45
	jp itemTryToBreakTile		; $4e47


@galeCollidedWithWall:
	call @breakTileWithGaleSeed		; $4e4a
	ld a,$26		; $4e4d
	call @loadGfxVarsWithIndex		; $4e4f
	ld a,$03		; $4e52
	call itemSetState		; $4e54
	ld l,Item.collisionType		; $4e57
	res 7,(hl)		; $4e59
	jp objectSetVisible82		; $4e5b


@mysteryCollidedWithEnemy:
	ld h,d			; $4e5e
	ld l,Item.var2a		; $4e5f
	bit 6,(hl)		; $4e61
	jr nz,@mysteryStandard	; $4e63

	; Change id to be the random type selected
	ld l,Item.var03		; $4e65
	ldd a,(hl)		; $4e67
	add ITEMID_EMBER_SEED			; $4e68
	dec l			; $4e6a
	ld (hl),a		; $4e6b

	call _itemLoadAttributesAndGraphics		; $4e6c
	xor a			; $4e6f
	call itemSetAnimation		; $4e70
	ld e,Item.health		; $4e73
	ld a,$ff		; $4e75
	ld (de),a		; $4e77
	jp @seedCollidedWithEnemy		; $4e78


@mysteryStandard:
	ld e,Item.collisionType		; $4e7b
	xor a			; $4e7d
	ld (de),a		; $4e7e
	call objectSetVisible82		; $4e7f

;;
; Sets state to 3, loads gfx for the new effect, plays sound, sets counter1.
;
; @addr{4e82}
@initState3:
	ld e,Item.state		; $4e82
	ld a,$03		; $4e84
	ld (de),a		; $4e86

	ld e,Item.id		; $4e87
	ld a,(de)		; $4e89

;;
; @param	a	Index to use for below table (plus $20, since
;			ITEMID_EMBER_SEED=$20)
; @addr{4e8a}
@loadGfxVarsWithIndex:
	add a			; $4e8a
	ld hl,@data-(ITEMID_EMBER_SEED*4)		; $4e8b
	rst_addDoubleIndex			; $4e8e

	ld e,Item.oamFlagsBackup		; $4e8f
	ldi a,(hl)		; $4e91
	ld (de),a		; $4e92
	inc e			; $4e93
	ld (de),a		; $4e94
	inc e			; $4e95
	ldi a,(hl)		; $4e96
	ld (de),a		; $4e97
	ldi a,(hl)		; $4e98
	ld e,Item.counter1		; $4e99
	ld (de),a		; $4e9b
	ld a,(hl)		; $4e9c
	jp playSound		; $4e9d

; b0: value for Item.oamFlags and oamFlagsBackup
; b1: value for Item.oamTileIndexBase
; b2: value for Item.counter1
; b3: sound effect
@data:
	.db $0a $06 $3a SND_LIGHTTORCH
	.db $0b $10 $3c SND_PIRATE_BELL
	.db $09 $18 $00 SND_LIGHTTORCH
	.db $09 $28 $32 SND_GALE_SEED
	.db $08 $18 $00 SND_MYSTERY_SEED

	.db $09 $28 $b4 SND_GALE_SEED
	.db $09 $28 $1e SND_GALE_SEED
	.db $0b $3c $96 SND_SCENT_SEED

;;
; @addr{4ec0}
_seedItemDelete:
	ld e,Item.subid		; $4ec0
	ld a,(de)		; $4ec2
	or a			; $4ec3
	jr z,@delete			; $4ec4

	ld hl,wIsSeedShooterInUse		; $4ec6
	ld a,(hl)		; $4ec9
	or a			; $4eca
	jr z,@delete			; $4ecb
	dec (hl)		; $4ecd
@delete:
	jp itemDelete		; $4ece


;;
; State 3: typically occurs when the seed collides with a wall or enemy (instead of the
; ground)
; @addr{4ed1}
_seedItemState3:
	ld e,Item.id		; $4ed1
	ld a,(de)		; $4ed3
	sub ITEMID_EMBER_SEED			; $4ed4
	rst_jumpTable			; $4ed6
	.dw _emberSeedBurn
	.dw _seedUpdateAnimation
	.dw _seedUpdateAnimation
	.dw _galeSeedUpdateAnimationAndCounter
	.dw _seedUpdateAnimation

_emberSeedBurn:
	ld h,d			; $4ee1
	ld l,Item.counter1		; $4ee2
	dec (hl)		; $4ee4
	jr z,@breakTile		; $4ee5

	call itemAnimate		; $4ee7
	call _itemUpdateDamageToApply		; $4eea
	ld l,Item.animParameter		; $4eed
	ld b,(hl)		; $4eef
	jr z,+			; $4ef0

	ld l,Item.collisionType		; $4ef2
	ld (hl),$00		; $4ef4
	bit 7,b			; $4ef6
	jr nz,@deleteSelf	; $4ef8
+
	ld l,Item.z		; $4efa
	ldi a,(hl)		; $4efc
	or (hl)			; $4efd
	ld c,$1c		; $4efe
	jp nz,objectUpdateSpeedZ_paramC		; $4f00
	bit 6,b			; $4f03
	ret z			; $4f05

	call objectCheckTileAtPositionIsWater		; $4f06
	jr c,@deleteSelf	; $4f09
	ret			; $4f0b

@breakTile:
	ld a,BREAKABLETILESOURCE_0c		; $4f0c
	call itemTryToBreakTile		; $4f0e
@deleteSelf:
	jp _seedItemDelete		; $4f11


;;
; Generic update function for seed states 2/3
;
; @addr{4f14}
_seedUpdateAnimation:
	ld e,Item.collisionType		; $4f14
	xor a			; $4f16
	ld (de),a		; $4f17
	call itemAnimate		; $4f18
	ld e,Item.animParameter		; $4f1b
	ld a,(de)		; $4f1d
	rlca			; $4f1e
	ret nc			; $4f1f
	jp _seedItemDelete		; $4f20

;;
; State 2: typically occurs when the seed lands on the ground
; @addr{4f23}
_seedItemState2:
	ld e,Item.id		; $4f23
	ld a,(de)		; $4f25
	sub ITEMID_EMBER_SEED			; $4f26
	rst_jumpTable			; $4f28
	.dw _emberSeedBurn
	.dw _scentSeedSmell
	.dw _seedUpdateAnimation
	.dw _galeSeedTryToWarpLink
	.dw _seedUpdateAnimation

;;
; Scent seed in the "smelling" state that attracts enemies
;
; @addr{4f33}
_scentSeedSmell:
	ld h,d			; $4f33
	ld l,Item.counter1		; $4f34
	ld a,(wFrameCounter)		; $4f36
	rrca			; $4f39
	jr c,+			; $4f3a
	dec (hl)		; $4f3c
	jp z,_seedItemDelete		; $4f3d
+
	; Toggle visibility when counter is low enough
	ld a,(hl)		; $4f40
	cp $1e			; $4f41
	jr nc,+			; $4f43
	ld l,Item.visible		; $4f45
	ld a,(hl)		; $4f47
	xor $80			; $4f48
	ld (hl),a		; $4f4a
+
	ld l,Item.yh		; $4f4b
	ldi a,(hl)		; $4f4d
	ldh (<hFFB2),a	; $4f4e
	inc l			; $4f50
	ldi a,(hl)		; $4f51
	ldh (<hFFB3),a	; $4f52

	ld a,$ff		; $4f54
	ld (wScentSeedActive),a		; $4f56
	call itemAnimate		; $4f59
	call _bombPullTowardPoint		; $4f5c
	jp c,_seedItemDelete		; $4f5f
	jp _itemUpdateSpeedZAndCheckHazards		; $4f62

;;
; @addr{4f65}
_galeSeedUpdateAnimationAndCounter:
	call _galeSeedUpdateAnimation		; $4f65
	call itemDecCounter1		; $4f68
	jp z,_seedItemDelete		; $4f6b

	; Toggle visibility when almost disappeared
	ld a,(hl)		; $4f6e
	cp $14			; $4f6f
	ret nc			; $4f71
	ld l,Item.visible		; $4f72
	ld a,(hl)		; $4f74
	xor $80			; $4f75
	ld (hl),a		; $4f77
	ret			; $4f78

;;
; Note: for some reason, this tends to be called twice per frame in the
; "_galeSeedTryToWarpLink" function, which causes the animation to go over, and it skips
; over some of the palettes?
;
; @addr{4f79}
_galeSeedUpdateAnimation:
	call itemAnimate		; $4f79
	ld e,Item.counter1		; $4f7c
	ld a,(de)		; $4f7e
	and $03			; $4f7f
	ret nz			; $4f81

	; Cycle through palettes
	ld e,Item.oamFlagsBackup		; $4f82
	ld a,(de)		; $4f84
	inc a			; $4f85
	and $0b			; $4f86
	ld (de),a		; $4f88
	inc e			; $4f89
	ld (de),a		; $4f8a
	ret			; $4f8b

;;
; Gale seed in its tornado state, will pull in Link if possible
; @addr{4f8c}
_galeSeedTryToWarpLink:
	call _galeSeedUpdateAnimation		; $4f8c
	ld e,Item.state2		; $4f8f
	ld a,(de)		; $4f91
	rst_jumpTable			; $4f92
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate0:
	; Test AREAFLAG_OUTDOORS
	ld a,(wAreaFlags)		; $4f9b
	rrca			; $4f9e
	jr nc,@setSubstate3	; $4f9f

	; Check warps enabled, Link not riding companion
	ld a,(wWarpsDisabled)		; $4fa1
	or a			; $4fa4
	jr nz,_galeSeedUpdateAnimationAndCounter	; $4fa5
	ld a,(wLinkObjectIndex)		; $4fa7
	rrca			; $4faa
	jr c,_galeSeedUpdateAnimationAndCounter	; $4fab

	; Don't allow warp to occur if holding a very heavy object?
	ld a,(wLinkGrabState2)		; $4fad
	and $f0			; $4fb0
	cp $40			; $4fb2
	jr z,_galeSeedUpdateAnimationAndCounter	; $4fb4

	call checkLinkVulnerableAndIDZero		; $4fb6
	jr nc,_galeSeedUpdateAnimationAndCounter	; $4fb9
	call objectCheckCollidedWithLink		; $4fbb
	jr nc,_galeSeedUpdateAnimationAndCounter	; $4fbe

	ld hl,w1Link		; $4fc0
	call objectTakePosition		; $4fc3
	ld e,Item.counter2		; $4fc6
	ld a,$3c		; $4fc8
	ld (de),a		; $4fca
	ld e,Item.state2		; $4fcb
	ld a,$01		; $4fcd
	ld (de),a		; $4fcf
	ld (wMenuDisabled),a		; $4fd0
	ld (wLinkCanPassNpcs),a		; $4fd3
	ld (wDisableScreenTransitions),a		; $4fd6
	ld a,LINK_STATE_SPINNING_FROM_GALE		; $4fd9
	ld (wLinkForceState),a		; $4fdb
	jp objectSetVisible80		; $4fde

@setSubstate3:
	ld e,Item.state2		; $4fe1
	ld a,$03		; $4fe3
	ld (de),a		; $4fe5
	ret			; $4fe6


; Substate 1: Link caught in the gale, but still on the ground
@substate1:
	ld a,(wLinkDeathTrigger)		; $4fe7
	or a			; $4fea
	jr nz,@setSubstate3	; $4feb
	ld h,d			; $4fed
	ld l,Item.counter2		; $4fee
	dec (hl)		; $4ff0
	jr z,+			; $4ff1

	; Only flicker if in group 0??? This causes it to look slightly different when
	; used in the past, as opposed to the present...
	ld a,(wActiveGroup)		; $4ff3
	or a			; $4ff6
	jr z,@flickerAndCopyPositionToLink	; $4ff7
	ret			; $4ff9
+
	ld a,$02		; $4ffa
	ld (de),a		; $4ffc


; Substate 2: Link and gale moving up
@substate2:
	; Move Z position up until it reaches $7f
	ld h,d			; $4ffd
	ld l,Item.zh		; $4ffe
	dec (hl)		; $5000
	dec (hl)		; $5001
	bit 7,(hl)		; $5002
	jr nz,@flickerAndCopyPositionToLink	; $5004

	ld a,$02		; $5006
	ld (w1Link.state2),a		; $5008
	ld a,CUTSCENE_16		; $500b
	ld (wCutsceneTrigger),a		; $500d

	; Open warp menu, delete self
	ld a,$05		; $5010
	call openMenu		; $5012
	jp _seedItemDelete		; $5015

@flickerAndCopyPositionToLink:
	ld e,Item.visible		; $5018
	ld a,(de)		; $501a
	xor $80			; $501b
	ld (de),a		; $501d

	xor a			; $501e
	ld (wLinkSwimmingState),a		; $501f
	ld hl,w1Link		; $5022
	jp objectCopyPosition		; $5025


; Substate 3: doesn't warp Link anywhere, just waiting for it to get deleted
@substate3:
	call itemDecCounter2		; $5028
	jp z,_seedItemDelete		; $502b
	ld l,Item.visible		; $502e
	ld a,(hl)		; $5030
	xor $80			; $5031
	ld (hl),a		; $5033
	ret			; $5034

;;
; Called for seeds used with seed shooter. Checks for tile collisions and triggers
; "bounces" when that happens.
;
; @param[out]	zflag	Unset when the seed's "effect" should be activated
; @addr{5035}
_seedItemUpdateBouncing:
	call objectGetTileAtPosition		; $5035
	ld hl,_seedDontBounceTilesTable		; $5038
	call findByteInCollisionTable		; $503b
	jr c,@unsetZFlag	; $503e

	ld e,Item.angle		; $5040
	ld a,(de)		; $5042
	bit 2,a			; $5043
	jr z,@movingStraight		; $5045

; Moving diagonal

	call _seedItemCheckDiagonalCollision		; $5047

	; Call this just to update var3c/var3d (tile position / index)?
	push af			; $504a
	call _itemCheckCanPassSolidTile		; $504b
	pop af			; $504e

	jr z,@setZFlag		; $504f
	jr @bounce		; $5051

@movingStraight:
	ld e,Item.var33		; $5053
	xor a			; $5055
	ld (de),a		; $5056
	call objectCheckTileCollision_allowHoles		; $5057
	jr nc,@setZFlag		; $505a

	ld e,Item.var33		; $505c
	ld a,$03		; $505e
	ld (de),a		; $5060
	call _itemCheckCanPassSolidTile		; $5061
	jr z,@setZFlag		; $5064

@bounce:
	call _seedItemClearKnockback		; $5066

	; Decrement bounce counter
	ld h,d			; $5069
	ld l,Item.var34		; $506a
	dec (hl)		; $506c
	jr z,@unsetZFlag	; $506d

	ld l,Item.var33		; $506f
	ld a,(hl)		; $5071
	cp $03			; $5072
	jr z,@reverseBothComponents	; $5074

	; Calculate new angle based on whether it was a vertical or horizontal collision
	ld c,a			; $5076
	ld e,Item.angle		; $5077
	ld a,(de)		; $5079
	rrca			; $507a
	rrca			; $507b
	and $06			; $507c
	add c			; $507e
	ld hl,@angleCalcTable-1		; $507f
	rst_addAToHl			; $5082
	ld a,(hl)		; $5083
	ld (de),a		; $5084

@setZFlag:
	xor a			; $5085
	ret			; $5086

; Flips both X and Y componets
@reverseBothComponents:
	ld l,Item.angle		; $5087
	ld a,(hl)		; $5089
	xor $10			; $508a
	ld (hl),a		; $508c
	xor a			; $508d
	ret			; $508e

@unsetZFlag:
	or d			; $508f
	ret			; $5090


; Used for calculating new angle after bounces
@angleCalcTable:
	.db $1c $0c $14 $04 $0c $1c $04 $14

;;
; Called when a seed is moving in a diagonal direction.
;
; Sets var33 such that bits 0 and 1 are set on horizontal and vertical collisions,
; respectively.
;
; @param	a	Angle
; @param[out]	zflag	Unset if the seed should bounce
; @addr{5099}
_seedItemCheckDiagonalCollision:
	rrca			; $5099
	and $0c			; $509a
	ld hl,@collisionOffsets		; $509c
	rst_addAToHl			; $509f
	xor a			; $50a0
	ldh (<hFF8A),a	; $50a1

	; Loop will iterate twice (first for vertical collision, then horizontal).
	ld e,Item.var33		; $50a3
	ld a,$40		; $50a5
	ld (de),a		; $50a7

@nextComponent:
	ld e,Item.yh		; $50a8
	ld a,(de)		; $50aa
	add (hl)		; $50ab
	ld b,a			; $50ac
	inc hl			; $50ad
	ld e,Item.xh		; $50ae
	ld a,(de)		; $50b0
	add (hl)		; $50b1
	ld c,a			; $50b2

	inc hl			; $50b3
	push hl			; $50b4
	call checkTileCollisionAt_allowHoles		; $50b5
	jr nc,@next		; $50b8

; Collision occurred; check whether it should bounce (set carry flag if so)

	call getTileAtPosition		; $50ba
	ld hl,_seedDontBounceTilesTable		; $50bd
	call findByteInCollisionTable		; $50c0
	ccf			; $50c3
	jr nc,@next	; $50c4

	ld h,d			; $50c6
	ld l,Item.angle		; $50c7
	ld b,(hl)		; $50c9
	call _checkTileIsPassableFromDirection		; $50ca
	ccf			; $50cd
	jr c,@next	; $50ce
	jr z,@next	; $50d0

	; Bounce if the new elevation would be negative
	ld h,d			; $50d2
	ld l,Item.var3e		; $50d3
	add (hl)		; $50d5
	rlca			; $50d6

@next:
	; Rotate carry bit into var33
	ld h,d			; $50d7
	ld l,Item.var33		; $50d8
	rl (hl)			; $50da
	pop hl			; $50dc
	jr nc,@nextComponent	; $50dd

	ld e,Item.var33		; $50df
	ld a,(de)		; $50e1
	or a			; $50e2
	ret			; $50e3


; Offsets from item position to check for collisions at.
; First 2 bytes are offsets for vertical collisions, next 2 are for horizontal.
@collisionOffsets:
	.db $fc $00 $00 $03 ; Up-right
	.db $03 $00 $00 $03 ; Down-right
	.db $03 $00 $00 $fc ; Down-left
	.db $fc $00 $00 $fc ; Up-left


;;
; @param	h,d	Object
; @param[out]	zflag	Set if there are still bounces left?
; @addr{50f4}
_func_50f4:
	ld e,Item.angle		; $50f4
	ld l,Item.knockbackAngle		; $50f6
	ld a,(de)		; $50f8
	add (hl)		; $50f9
	ld hl,_data_5114		; $50fa
	rst_addAToHl			; $50fd
	ld c,(hl)		; $50fe
	ld a,(de)		; $50ff
	cp c			; $5100
	jr z,_seedItemClearKnockback	; $5101

	ld h,d			; $5103
	ld l,Item.var34		; $5104
	dec (hl)		; $5106
	jr z,@unsetZFlag	; $5107

	; Set Item.angle
	ld a,c			; $5109
	ld (de),a		; $510a
	xor a			; $510b
	ret			; $510c

@unsetZFlag:
	or d			; $510d
	ret			; $510e

;;
; @addr{510f}
_seedItemClearKnockback:
	ld e,Item.knockbackCounter		; $510f
	xor a			; $5111
	ld (de),a		; $5112
	ret			; $5113


_data_5114:
	.db $00 $08 $10 $18 $1c $04 $0c $14
	.db $18 $00 $08 $10 $14 $1c $04 $0c
	.db $10 $18 $00 $08 $0c $14 $1c $04
	.db $08 $10 $18 $00 $04 $0c $14 $1c


; List of tiles which seeds don't bounce off of. (Burnable stuff.)
_seedDontBounceTilesTable:
	.dw @collisions0
	.dw @collisions1
	.dw @collisions2
	.dw @collisions3
	.dw @collisions4
	.dw @collisions5

@collisions0:
	.db $ce $cf $c5 $c5 $c6 $c7 $c8 $c9 $ca
@collisions1:
@collisions3:
@collisions4:
	.db $00

@collisions2:
@collisions5:
	.db TILEINDEX_UNLIT_TORCH
	.db TILEINDEX_LIT_TORCH
	.db $00


;;
; This is an object which serves as a collision for enemies when Dimitri does his eating
; attack. Also checks for eatable tiles.
;
; ITEMID_DIMITRI_MOUTH
; @addr{514d}
itemCode2b:
	ld e,Item.state		; $514d
	ld a,(de)		; $514f
	or a			; $5150
	jr nz,+			; $5151

	; Initialization
	call _itemLoadAttributesAndGraphics		; $5153
	call itemIncState		; $5156
	ld l,Item.counter1		; $5159
	ld (hl),$0c		; $515b
+
	call @calcPosition		; $515d

	; Check for enemy collision?
	ld h,d			; $5160
	ld l,Item.var2a		; $5161
	bit 1,(hl)		; $5163
	jr nz,@swallow		; $5165

	ld a,BREAKABLETILESOURCE_DIMITRI_EAT		; $5167
	call itemTryToBreakTile		; $5169
	jr c,@swallow			; $516c

	; Delete self after 12 frames
	call itemDecCounter1		; $516e
	jr z,@delete		; $5171
	ret			; $5173

@swallow:
	; Set var35 to $01 to tell Dimitri to do his swallow animation?
	ld a,$01		; $5174
	ld (w1Companion.var35),a		; $5176

@delete:
	jp itemDelete		; $5179

;;
; Sets the position for this object around Dimitri's mouth.
;
; @addr{517c}
@calcPosition:
	ld a,(w1Companion.direction)		; $517c
	ld hl,@offsets		; $517f
	rst_addDoubleIndex			; $5182
	ldi a,(hl)		; $5183
	ld c,(hl)		; $5184
	ld b,a			; $5185
	ld hl,w1Companion.yh		; $5186
	jp objectTakePositionWithOffset		; $5189

@offsets:
	.db $f6 $00 ; DIR_UP
	.db $fe $0a ; DIR_RIGHT
	.db $04 $00 ; DIR_DOWN
	.db $fe $f6 ; DIR_LEFT


;;
; ITEMID_BOMBCHUS
; @addr{5194}
itemCode0d:
	call _bombchuCountdownToExplosion		; $5194

	; If state is $ff, it's exploding
	ld e,Item.state		; $5197
	ld a,(de)		; $5199
	cp $ff			; $519a
	jp nc,_itemUpdateExplosion		; $519c

	call objectCheckWithinRoomBoundary		; $519f
	jp nc,itemDelete		; $51a2

	call objectSetPriorityRelativeToLink_withTerrainEffects		; $51a5

	ld a,(wAreaFlags)		; $51a8
	and AREAFLAG_SIDESCROLL			; $51ab
	jr nz,@sidescroll	; $51ad

	; This call will return if the bombchu falls into a hole/water/lava.
	ld c,$20		; $51af
	call _itemUpdateSpeedZAndCheckHazards		; $51b1

	ld e,Item.state		; $51b4
	ld a,(de)		; $51b6
	rst_jumpTable			; $51b7

	.dw @tdState0
	.dw @tdState1
	.dw @tdState2
	.dw @tdState3
	.dw @tdState4

@sidescroll:
	ld e,Item.var32		; $51c2
	ld a,(de)		; $51c4
	or a			; $51c5
	jr nz,+			; $51c6

	ld c,$18		; $51c8
	call _itemUpdateThrowingVerticallyAndCheckHazards		; $51ca
	jp c,itemDelete		; $51cd
+
	ld e,Item.state		; $51d0
	ld a,(de)		; $51d2
	rst_jumpTable			; $51d3

	.dw @ssState0
	.dw @ssState1
	.dw @ssState2
	.dw @ssState3


@tdState0:
	call _itemLoadAttributesAndGraphics		; $51dc
	call decNumBombchus		; $51df

	ld h,d			; $51e2
	ld l,Item.state		; $51e3
	inc (hl)		; $51e5

	; var30 used to cycle through possible targets
	ld l,Item.var30		; $51e6
	ld (hl),FIRST_ENEMY_INDEX		; $51e8

	ld l,Item.speedTmp		; $51ea
	ld (hl),SPEED_80		; $51ec

	ld l,Item.counter1		; $51ee
	ld (hl),$10		; $51f0

	; Explosion countdown
	inc l			; $51f2
	ld (hl),$b4		; $51f3

	; Collision radius is used as vision radius before a target is found
	ld l,Item.collisionRadiusY		; $51f5
	ld a,$18		; $51f7
	ldi (hl),a		; $51f9
	ld (hl),a		; $51fa

	; Default "direction to turn" on encountering a hole
	ld l,Item.var31		; $51fb
	ld (hl),$08		; $51fd

	; Initialize angle based on link's facing direction
	ld l,Item.angle		; $51ff
	ld a,(w1Link.direction)		; $5201
	swap a			; $5204
	rrca			; $5206
	ld (hl),a		; $5207
	ld l,Item.direction		; $5208
	ld (hl),$ff		; $520a

	call _bombchuSetAnimationFromAngle		; $520c
	jp _bombchuSetPositionInFrontOfLink		; $520f


; State 1: waiting to reach the ground (if dropped from midair)
@tdState1:
	ld h,d			; $5212
	ld l,Item.zh		; $5213
	bit 7,(hl)		; $5215
	jr nz,++		; $5217

	; Increment state if on the ground
	ld l,e			; $5219
	inc (hl)		; $521a

; State 2: searching for target
@tdState2:
	call _bombchuCheckForEnemyTarget		; $521b
	ret z			; $521e
++
	call _bombchuUpdateSpeed		; $521f
	call _itemUpdateConveyorBelt		; $5222

@animate:
	jp itemAnimate		; $5225


; State 3: target found
@tdState3:
	ld h,d			; $5228
	ld l,Item.counter1		; $5229
	dec (hl)		; $522b
	jp nz,_itemUpdateConveyorBelt		; $522c

	; Set counter
	ld (hl),$0a		; $522f

	; Increment state
	ld l,e			; $5231
	inc (hl)		; $5232


; State 4: Dashing toward target
@tdState4:
	call _bombchuCheckCollidedWithTarget		; $5233
	jp c,_bombchuClearCounter2AndInitializeExplosion		; $5236

	call _bombchuUpdateVelocity		; $5239
	call _itemUpdateConveyorBelt		; $523c
	jr @animate		; $523f


; Sidescrolling states

@ssState0:
	; Do the same initialization as top-down areas
	call @tdState0		; $5241

	; Force the bombchu to face left or right
	ld e,Item.angle		; $5244
	ld a,(de)		; $5246
	bit 3,a			; $5247
	ret nz			; $5249

	add $08			; $524a
	ld (de),a		; $524c
	jp _bombchuSetAnimationFromAngle		; $524d

; State 1: searching for target
@ssState1:
	ld e,Item.speed		; $5250
	ld a,SPEED_80		; $5252
	ld (de),a		; $5254
	call _bombchuCheckForEnemyTarget		; $5255
	ret z			; $5258

	; Target not found yet

	call _bombchuCheckWallsAndApplySpeed		; $5259

@ssAnimate:
	jp itemAnimate		; $525c


; State 2: Target found, wait for a few frames
@ssState2:
	call itemDecCounter1		; $525f
	ret nz			; $5262

	ld (hl),$0a		; $5263

	; Increment state
	ld l,e			; $5265
	inc (hl)		; $5266

; State 3: Chase after target
@ssState3:
	call _bombchuCheckCollidedWithTarget		; $5267
	jp c,_bombchuClearCounter2AndInitializeExplosion		; $526a
	call _bombchuUpdateVelocityAndClimbing_sidescroll		; $526d
	jr @ssAnimate		; $5270


;;
; Updates bombchu's position & speed every frame, and the angle every 8 frames.
;
; @addr{5272}
_bombchuUpdateVelocity:
	ld a,(wFrameCounter)		; $5272
	and $07			; $5275
	call z,_bombchuUpdateAngle_topDown		; $5277

;;
; @addr{527a}
_bombchuUpdateSpeed:
	call @updateSpeed		; $527a

	; Note: this will actually update the Z position for a second time in the frame?
	; (due to earlier call to _itemUpdateSpeedZAndCheckHazards)
	ld c,$18		; $527d
	call objectUpdateSpeedZ_paramC		; $527f

	jp objectApplySpeed		; $5282


; Update the speed based on what kind of tile it's on
@updateSpeed:
	ld e,Item.angle		; $5285
	call _bombchuGetTileCollisions		; $5287

	cp SPECIALCOLLISION_HOLE			; $528a
	jr z,@impassableTile	; $528c

	cp SPECIALCOLLISION_15			; $528e
	jr z,@impassableTile	; $5290

	; Check for SPECIALCOLLISION_SCREEN_BOUNDARY
	inc a			; $5292
	jr z,@impassableTile	; $5293

	; Set the bombchu's speed (halve it if it's on a solid tile)
	dec a			; $5295
	ld e,Item.speedTmp		; $5296
	ld a,(de)		; $5298
	jr z,+			; $5299

	ld e,a			; $529b
	ld hl,_bounceSpeedReductionMapping		; $529c
	call lookupKey		; $529f
+
	; If new speed < old speed, trigger a jump. (Happens when a bombchu starts
	; climbing a wall)
	ld h,d			; $52a2
	ld l,Item.speed		; $52a3
	cp (hl)			; $52a5
	ld (hl),a		; $52a6
	ret nc			; $52a7

	ld l,Item.speedZ		; $52a8
	ld a,$80		; $52aa
	ldi (hl),a		; $52ac
	ld (hl),$ff		; $52ad
	ret			; $52af

; Bombchus can pass most tiles, even walls, but not holes (perhaps a few other things).
@impassableTile:
	; Item.var31 holds the direction the bombchu should turn to continue moving closer
	; to the target.
	ld h,d			; $52b0
	ld l,Item.var31		; $52b1
	ld a,(hl)		; $52b3
	ld l,Item.angle		; $52b4
	add (hl)		; $52b6
	and $18			; $52b7
	ld (hl),a		; $52b9
	jp _bombchuSetAnimationFromAngle		; $52ba

;;
; Get tile collisions at the front end of the bombchu.
;
; @param	e	Angle address (object variable)
; @param[out]	a	Collision value
; @param[out]	hl	Address of collision data
; @param[out]	zflag	Set if there is no collision.
; @addr{52bd}
_bombchuGetTileCollisions:
	ld h,d			; $52bd
	ld l,Item.yh		; $52be
	ld b,(hl)		; $52c0
	ld l,Item.xh		; $52c1
	ld c,(hl)		; $52c3

	ld a,(de)		; $52c4
	rrca			; $52c5
	rrca			; $52c6
	ld hl,@offsets		; $52c7
	rst_addAToHl			; $52ca
	ldi a,(hl)		; $52cb
	add b			; $52cc
	ld b,a			; $52cd
	ld a,(hl)		; $52ce
	add c			; $52cf
	ld c,a			; $52d0
	jp getTileCollisionsAtPosition		; $52d1

@offsets:
	.db $fc $00 ; DIR_UP
	.db $02 $03 ; DIR_RIGHT
	.db $06 $00 ; DIR_DOWN
	.db $02 $fc ; DIR_LEFT

;;
; @addr{52dc}
_bombchuUpdateVelocityAndClimbing_sidescroll:
	ld a,(wFrameCounter)		; $52dc
	and $07			; $52df
	call z,_bombchuUpdateAngle_sidescrolling		; $52e1

;;
; In sidescrolling areas, this updates the bombchu's "climbing wall" state.
;
; @addr{52e4}
_bombchuCheckWallsAndApplySpeed:
	call @updateWallClimbing		; $52e4
	jp objectApplySpeed		; $52e7

;;
; @addr{52ea}
@updateWallClimbing:
	ld e,Item.var32		; $52ea
	ld a,(de)		; $52ec
	or a			; $52ed
	jr nz,@climbingWall	; $52ee

	; Return if it hasn't collided with a wall
	ld e,Item.angle		; $52f0
	call _bombchuGetTileCollisions		; $52f2
	ret z			; $52f5

	; Check for SPECIALCOLLISION_SCREEN_BOUNDARY
	inc a			; $52f6
	jr nz,+			; $52f7

	; Reverse direction if it runs into such a tile
	ld e,Item.angle		; $52f9
	ld a,(de)		; $52fb
	xor $10			; $52fc
	ld (de),a		; $52fe
	jp _bombchuSetAnimationFromAngle		; $52ff
+
	; Tell it to start climbing the wall
	ld h,d			; $5302
	ld l,Item.angle		; $5303
	ld a,(hl)		; $5305
	ld (hl),$00		; $5306
	ld l,Item.var33		; $5308
	ld (hl),a		; $530a
	ld l,Item.var32		; $530b
	ld (hl),$01		; $530d
	jp _bombchuSetAnimationFromAngle		; $530f

@climbingWall:
	; Check if the bombchu is still touching the wall it's supposed to be climbing
	ld e,Item.var33		; $5312
	call _bombchuGetTileCollisions		; $5314
	jr nz,@@touchingWall	; $5317

	; Bombchu is no longer touching the wall it's climbing. It will now "uncling"; the
	; following code figures out which direction to make it face.
	; The direction will be the "former angle" (var33) unless it's on the ceiling, in
	; which case, it will just continue in its current direction.

	ld h,d			; $5319
	ld l,Item.angle		; $531a
	ld e,Item.var33		; $531c
	ld a,(de)		; $531e
	or a			; $531f
	jr nz,+			; $5320

	ld a,(hl)		; $5322
	ld e,Item.var33		; $5323
	ld (de),a		; $5325
+
	; Revert to former angle and uncling
	ld a,(de)		; $5326
	ld (hl),a		; $5327
	ld l,Item.var32		; $5328
	xor a			; $532a
	ldi (hl),a		; $532b
	inc l			; $532c
	ld (hl),a		; $532d

	; Clear vertical speed
	ld l,Item.speedZ		; $532e
	ldi (hl),a		; $5330
	ldi (hl),a		; $5331

	ld l,Item.direction		; $5332
	ld (hl),$ff		; $5334
	jp _bombchuSetAnimationFromAngle		; $5336

@@touchingWall:
	; Check if it hits a wall
	ld e,Item.angle		; $5339
	call _bombchuGetTileCollisions		; $533b
	ret z			; $533e

	; If so, try to cling to it
	ld h,d			; $533f
	ld l,Item.angle		; $5340
	ld b,(hl)		; $5342
	ld e,Item.var33		; $5343
	ld a,(de)		; $5345
	xor $10			; $5346
	ld (hl),a		; $5348

	; If both the new and old angles are horizontal, stop clinging to the wall?
	bit 3,a			; $5349
	jr z,+			; $534b
	bit 3,b			; $534d
	jr z,+			; $534f

	ld l,Item.var32		; $5351
	ld (hl),$00		; $5353
+
	; Set var33
	ld a,b			; $5355
	ld (de),a		; $5356

	; If a==0 (old angle was "up"), the bombchu will cling to the ceiling (var34 will
	; be nonzero).
	or a			; $5357
	ld l,Item.var34		; $5358
	ld (hl),$00		; $535a
	jr nz,_bombchuSetAnimationFromAngle	; $535c
	inc (hl)		; $535e
	jr _bombchuSetAnimationFromAngle		; $535f

;;
; Sets the bombchu's angle relative to its target.
;
; @addr{5361}
_bombchuUpdateAngle_topDown:
	ld a,Object.yh		; $5361
	call objectGetRelatedObject2Var		; $5363
	ld b,(hl)		; $5366
	ld l,Enemy.xh		; $5367
	ld c,(hl)		; $5369
	call objectGetRelativeAngle		; $536a

	; Turn the angle into a cardinal direction, set that to the bombchu's angle
	ld b,a			; $536d
	add $04			; $536e
	and $18			; $5370
	ld e,Item.angle		; $5372
	ld (de),a		; $5374

	; Write $08 or $f8 to Item.var31, depending on which "side" the bombchu will need
	; to turn towards later?
	sub b			; $5375
	and $1f			; $5376
	cp $10			; $5378
	ld a,$08		; $537a
	jr nc,+			; $537c
	ld a,$f8		; $537e
+
	ld e,Item.var31		; $5380
	ld (de),a		; $5382

;;
; If [Item.angle] != [Item.direction], this updates the item's animation. The animation
; index is 0-3 depending on the item's angle (or sometimes it's 4-5 if var34 is set).
;
; Note: this sets the direction to equal the angle value, which is non-standard (usually
; the direction is a value from 0-3, not from $00-$1f).
;
; Also, this assumes that the item's angle is a cardinal direction?
;
; @addr{5383}
_bombchuSetAnimationFromAngle:
	ld h,d			; $5383
	ld l,Item.direction		; $5384
	ld e,Item.angle		; $5386
	ld a,(de)		; $5388
	cp (hl)			; $5389
	ret z			; $538a

	; Update Item.direction
	ld (hl),a		; $538b

	; Convert angle to a value from 0-3. (Assumes that the angle is a cardinal
	; direction?)
	swap a			; $538c
	rlca			; $538e

	ld l,Item.var34		; $538f
	bit 0,(hl)		; $5391
	jr z,+			; $5393
	dec a			; $5395
	ld a,$04		; $5396
	jr z,+			; $5398
	inc a			; $539a
+
	jp itemSetAnimation		; $539b

;;
; Sets up a bombchu's angle toward its target such that it will only move along its
; current axis; so if it's moving along the X axis, it will chase on the X axis, and
; vice-versa.
;
; @addr{539e}
_bombchuUpdateAngle_sidescrolling:
	ld a,Object.yh		; $539e
	call objectGetRelatedObject2Var		; $53a0
	ld b,(hl)		; $53a3
	ld l,Enemy.xh		; $53a4
	ld c,(hl)		; $53a6
	call objectGetRelativeAngle		; $53a7

	ld b,a			; $53aa
	ld e,Item.angle		; $53ab
	ld a,(de)		; $53ad
	bit 3,a			; $53ae
	ld a,b			; $53b0
	jr nz,@leftOrRight	; $53b1

; Bombchu facing up or down

	sub $08			; $53b3
	and $1f			; $53b5
	cp $10			; $53b7
	ld a,$00		; $53b9
	jr c,@setAngle		; $53bb
	ld a,$10		; $53bd
	jr @setAngle		; $53bf

; Bombchu facing left or right
@leftOrRight:
	cp $10			; $53c1
	ld a,$08		; $53c3
	jr c,@setAngle		; $53c5
	ld a,$18		; $53c7

@setAngle:
	ld e,Item.angle		; $53c9
	ld (de),a		; $53cb
	jr _bombchuSetAnimationFromAngle		; $53cc

;;
; Set a bombchu's position to be slightly in front of Link, based on his direction. If it
; would put the item in a wall, it will default to Link's exact position instead.
;
; @param[out]	zflag	Set if the item defaulted to Link's exact position due to a wall
; @addr{53ce}
_bombchuSetPositionInFrontOfLink:
	ld hl,w1Link.yh		; $53ce
	ld b,(hl)		; $53d1
	ld l,<w1Link.xh		; $53d2
	ld c,(hl)		; $53d4

	ld a,(wActiveGroup)		; $53d5
	cp FIRST_SIDESCROLL_GROUP			; $53d8
	ld l,<w1Link.direction		; $53da
	ld a,(hl)		; $53dc

	ld hl,@normalOffsets		; $53dd
	jr c,+			; $53e0
	ld hl,@sidescrollOffsets		; $53e2
+
	; Set the item's position to [Link's position] + [Offset from table]
	rst_addDoubleIndex			; $53e5
	ld e,Item.yh		; $53e6
	ldi a,(hl)		; $53e8
	add b			; $53e9
	ld (de),a		; $53ea
	ld e,Item.xh		; $53eb
	ld a,(hl)		; $53ed
	add c			; $53ee
	ld (de),a		; $53ef

	; Check if it's in a wall
	push bc			; $53f0
	call objectGetTileCollisions		; $53f1
	pop bc			; $53f4
	cp $0f			; $53f5
	ret nz			; $53f7

	; If the item would end up on a solid tile, put it directly on Link instead
	; (ignore the offset from the table)
	ld a,c			; $53f8
	ld (de),a		; $53f9
	ld e,Item.yh		; $53fa
	ld a,b			; $53fc
	ld (de),a		; $53fd
	ret			; $53fe

; Offsets relative to Link where items will appear

@normalOffsets:
	.db $f4 $00 ; DIR_UP
	.db $02 $0c ; DIR_RIGHT
	.db $0c $00 ; DIR_DOWN
	.db $02 $f4 ; DIR_LEFT

@sidescrollOffsets:
	.db $00 $00 ; DIR_UP
	.db $02 $0c ; DIR_RIGHT
	.db $00 $00 ; DIR_DOWN
	.db $02 $f4 ; DIR_LEFT


;;
; Bombchus call this every frame.
;
; @addr{540f}
_bombchuCountdownToExplosion:
	call itemDecCounter2		; $540f
	ret nz			; $5412

;;
; @addr{5413}
_bombchuClearCounter2AndInitializeExplosion:
	ld e,Item.counter2		; $5413
	xor a			; $5415
	ld (de),a		; $5416
	jp _itemInitializeBombExplosion		; $5417

;;
; @param[out]	cflag	Set on collision or if the enemy has died
; @addr{541a}
_bombchuCheckCollidedWithTarget:
	ld a,Object.health		; $541a
	call objectGetRelatedObject2Var		; $541c
	ld a,(hl)		; $541f
	or a			; $5420
	scf			; $5421
	ret z			; $5422
	jp checkObjectsCollided		; $5423

;;
; Each time this is called, it checks one enemy and sets it as the target if it meets all
; the conditions (close enough, valid target, etc).
;
; Each time it loops through all enemies, the bombchu's vision radius increases.
;
; @param[out]	zflag	Set if a valid target is found
; @addr{5426}
_bombchuCheckForEnemyTarget:
	; Check if the target enemy is enabled
	ld e,Item.var30		; $5426
	ld a,(de)		; $5428
	ld h,a			; $5429
	ld l,Enemy.enabled		; $542a
	ld a,(hl)		; $542c
	or a			; $542d
	jr z,@nextTarget	; $542e

	; Check it's visible
	ld l,Enemy.visible		; $5430
	bit 7,(hl)		; $5432
	jr z,@nextTarget	; $5434

	; Check it's a valid target (see data/bombchuTargets.s)
	ld l,Enemy.id		; $5436
	ld a,(hl)		; $5438
	push hl			; $5439
	ld hl,bombchuTargets		; $543a
	call checkFlag		; $543d
	pop hl			; $5440
	jr z,@nextTarget	; $5441

	; Check if it's within the bombchu's "collision radius" (actually used as vision
	; radius)
	call checkObjectsCollided		; $5443
	jr nc,@nextTarget	; $5446

	; Valid target established; set relatedObj2 to the target
	ld a,h			; $5448
	ld h,d			; $5449
	ld l,Item.relatedObj2+1		; $544a
	ldd (hl),a		; $544c
	ld (hl),Enemy.enabled		; $544d

	; Stop using collision radius as vision radius
	ld l,Item.collisionRadiusY		; $544f
	ld a,$06		; $5451
	ldi (hl),a		; $5453
	ld (hl),a		; $5454

	; Set counter1, speedTmp
	ld l,Item.counter1		; $5455
	ld (hl),$0c		; $5457
	ld l,Item.speedTmp		; $5459
	ld (hl),SPEED_1c0		; $545b

	; Increment state
	ld l,Item.state		; $545d
	inc (hl)		; $545f

	ld a,(wAreaFlags)		; $5460
	and AREAFLAG_SIDESCROLL			; $5463
	jr nz,+			; $5465

	call _bombchuUpdateAngle_topDown		; $5467
	xor a			; $546a
	ret			; $546b
+
	call _bombchuUpdateAngle_sidescrolling		; $546c
	xor a			; $546f
	ret			; $5470

@nextTarget:
	; Increment target enemy index by one
	inc h			; $5471
	ld a,h			; $5472
	cp LAST_ENEMY_INDEX+1			; $5473
	jr c,+			; $5475

	; Looped through all enemies
	call @incVisionRadius		; $5477
	ld a,FIRST_ENEMY_INDEX		; $547a
+
	ld e,Item.var30		; $547c
	ld (de),a		; $547e
	or d			; $547f
	ret			; $5480

@incVisionRadius:
	; Increase collisionRadiusY/X by increments of $10, but keep it below $70. (these
	; act as the bombchu's vision radius)
	ld e,Item.collisionRadiusY		; $5481
	ld a,(de)		; $5483
	add $10			; $5484
	cp $60			; $5486
	jr c,+			; $5488
	ld a,$18		; $548a
+
	ld (de),a		; $548c
	inc e			; $548d
	ld (de),a		; $548e
	ret			; $548f

.include "data/bombchuTargets.s"

;;
; ITEMID_BOMB
; @addr{54a0}
itemCode03:
	ld e,Item.var2f		; $54a0
	ld a,(de)		; $54a2
	bit 5,a			; $54a3
	jr nz,@label_07_153	; $54a5

	bit 7,a			; $54a7
	jp nz,_bombResetAnimationAndSetVisiblec1		; $54a9

	; Check if exploding
	bit 4,a			; $54ac
	jp nz,_bombUpdateExplosion		; $54ae

	ld e,Item.state		; $54b1
	ld a,(de)		; $54b3
	rst_jumpTable			; $54b4

	.dw @state0
	.dw @state1
	.dw @state2


; Not sure when this is executed. Causes the bomb to be deleted.
@label_07_153:
	ld h,d			; $54bb
	ld l,Item.state		; $54bc
	ldi a,(hl)		; $54be
	cp $02			; $54bf
	jr nz,+			; $54c1

	; Check bit 1 of Item.state2 (check if it's being held?)
	bit 1,(hl)		; $54c3
	call z,dropLinkHeldItem		; $54c5
+
	jp itemDelete		; $54c8

; State 1: bomb is motionless on the ground
@state1:
	ld c,$20		; $54cb
	call _bombUpdateThrowingVerticallyAndCheckDelete		; $54cd
	ret c			; $54d0

	; No idea what function is for
	call _bombPullTowardPoint		; $54d1
	jp c,itemDelete		; $54d4

	call _itemUpdateConveyorBelt		; $54d7
	jp _bombUpdateAnimation		; $54da

; State 0/2: bomb is being picked up / thrown around
@state0:
@state2:
	ld e,Item.state2		; $54dd
	ld a,(de)		; $54df
	rst_jumpTable			; $54e0

	.dw @heldState0
	.dw @heldState1
	.dw @heldState2
	.dw @heldState3


; Bomb just picked up
@heldState0:
	call itemIncState2		; $54e9

	ld l,Item.var2f		; $54ec
	set 6,(hl)		; $54ee

	ld l,Item.var37		; $54f0
	res 0,(hl)		; $54f2
	call _bombInitializeIfNeeded		; $54f4

; Bomb being held
@heldState1:
	; Bombs don't explode while being held if the peace ring is equipped
	ld a,PEACE_RING		; $54f7
	call cpActiveRing		; $54f9
	jp z,_bombResetAnimationAndSetVisiblec1		; $54fc

	call _bombUpdateAnimation		; $54ff
	ret z			; $5502

	; If z-flag was unset (bomb started exploding), release the item?
	jp dropLinkHeldItem		; $5503

; Bomb being thrown
@heldState2:
@heldState3:
	; Set state2 to $03
	ld a,$03		; $5506
	ld (de),a		; $5508

	; Update movement?
	call _bombUpdateThrowingLaterally		; $5509

	ld e,Item.var39		; $550c
	ld a,(de)		; $550e
	ld c,a			; $550f

	; Update throwing, return if the bomb was deleted from falling into a hazard
	call _bombUpdateThrowingVerticallyAndCheckDelete		; $5510
	ret c			; $5513

	; Jump if the item is not on the ground
	jr z,+			; $5514

	; If on the ground...
	call _itemBounce		; $5516
	jr c,@stoppedBouncing			; $5519

	; No idea what this function is for
	call _bombPullTowardPoint		; $551b
	jp c,itemDelete		; $551e
+
	jp _bombUpdateAnimation		; $5521

@stoppedBouncing:
	; Bomb goes to state 1 (motionless on the ground)
	ld h,d			; $5524
	ld l,Item.state		; $5525
	ld (hl),$01		; $5527

	ld l,Item.var2f		; $5529
	res 6,(hl)		; $552b

	jp _bombUpdateAnimation		; $552d

;;
; @param[out]	cflag	Set if the item was deleted
; @param[out]	zflag	Set if the bomb is not on the ground
; @addr{5530}
_bombUpdateThrowingVerticallyAndCheckDelete:
	push bc			; $5530
	ld a,(wAreaFlags)		; $5531
	and AREAFLAG_SIDESCROLL			; $5534
	jr z,+			; $5536

	; If in a sidescrolling area, allow Y values between $08-$f7?
	ld e,Item.yh		; $5538
	ld a,(de)		; $553a
	sub $08			; $553b
	cp $f0			; $553d
	ccf			; $553f
	jr c,++			; $5540
+
	call objectCheckWithinRoomBoundary		; $5542
++
	pop bc			; $5545
	jr nc,@delete		; $5546

	; Within the room boundary

	; Return if it hasn't landed in a hazard (hole/water/lava)
	call _itemUpdateThrowingVerticallyAndCheckHazards		; $5548
	ret nc			; $554b

	; Check if room $0050 (Present overworld, bomb upgrade screen)
	ld bc,$0050		; $554c
	ld a,(wActiveGroup)		; $554f
	cp b			; $5552
	jr nz,@delete		; $5553
	ld a,(wActiveRoom)		; $5555
	cp c			; $5558
	jr nz,@delete		; $5559

	; If so, trigger a cutscene?
	ld a,$01		; $555b
	ld (wTmpcfc0.bombUpgradeCutscene.state),a		; $555d

@delete:
	call itemDelete		; $5560
	scf			; $5563
	ret			; $5564

;;
; Update function for bombs and bombchus while they're exploding
;
; @addr{5565}
_itemUpdateExplosion:
	; animParameter specifies:
	;  Bits 0-4: collision radius
	;  Bit 6:    Zero out "collisionType" if set?
	;  Bit 7:    End of animation (delete self)
	ld h,d			; $5565
	ld l,Item.animParameter		; $5566
	ld a,(hl)		; $5568
	bit 7,a			; $5569
	jp nz,itemDelete		; $556b

	ld l,Item.collisionType		; $556e
	bit 6,a			; $5570
	jr z,+			; $5572
	ld (hl),$00		; $5574
+
	ld c,(hl)		; $5576
	ld l,Item.collisionRadiusY		; $5577
	and $1f			; $5579
	ldi (hl),a		; $557b
	ldi (hl),a		; $557c

	; If bit 7 of Item.collisionType is set, check for collision with Link
	bit 7,c			; $557d
	call nz,_explosionCheckAndApplyLinkCollision		; $557f

	ld h,d			; $5582
	ld l,Item.counter1		; $5583
	bit 7,(hl)		; $5585
	call z,_explosionTryToBreakNextTile		; $5587
	jp itemAnimate		; $558a

;;
; Bombs call each frame if bit 4 of Item.var2f is set.
;
; @addr{558d}
_bombUpdateExplosion:
	ld h,d			; $558d
	ld l,Item.state		; $558e
	ld a,(hl)		; $5590
	cp $ff			; $5591
	jr nz,_itemInitializeBombExplosion	; $5593
	jr _itemUpdateExplosion		; $5595

;;
; @param[out]	zflag	Set if the bomb isn't exploding (not sure if it gets unset on just
;			one frame, or all frames after the explosion starts)
; @addr{5597}
_bombUpdateAnimation:
	call itemAnimate		; $5597
	ld e,Item.animParameter		; $559a
	ld a,(de)		; $559c
	or a			; $559d
	ret z			; $559e

;;
; Initializes a bomb explosion?
;
; @param[out]	zflag
; @addr{559f}
_itemInitializeBombExplosion:
	ld h,d			; $559f
	ld l,Item.oamFlagsBackup		; $55a0
	ld a,$0a		; $55a2
	ldi (hl),a		; $55a4
	ldi (hl),a		; $55a5

	; Set Item.oamTileIndexBase
	ld (hl),$0c		; $55a6

	; Enable collisions
	ld l,Item.collisionType		; $55a8
	set 7,(hl)		; $55aa

	; Decrease damage if not using blast ring
	ld a,BLAST_RING		; $55ac
	call cpActiveRing		; $55ae
	jr nz,+			; $55b1
	ld l,Item.damage		; $55b3
	dec (hl)		; $55b5
	dec (hl)		; $55b6
+
	; State $ff means exploding
	ld l,Item.state		; $55b7
	ld (hl),$ff		; $55b9
	ld l,Item.counter1		; $55bb
	ld (hl),$08		; $55bd

	ld l,Item.var2f		; $55bf
	ld a,(hl)		; $55c1
	or $50			; $55c2
	ld (hl),a		; $55c4

	ld l,Item.id		; $55c5
	ldd a,(hl)		; $55c7

	; Reset bit 1 of Item.enabled
	res 1,(hl)		; $55c8

	; Check if this is a bomb, as opposed to a bombchu?
	cp ITEMID_BOMB			; $55ca
	ld a,$01		; $55cc
	jr z,+			; $55ce
	ld a,$06		; $55d0
+
	call itemSetAnimation		; $55d2
	call objectSetVisible80		; $55d5
	ld a,SND_EXPLOSION		; $55d8
	call playSound		; $55da
	or d			; $55dd
	ret			; $55de

;;
; @addr{55df}
_bombInitializeIfNeeded:
	ld h,d			; $55df
	ld l,Item.var37		; $55e0
	bit 7,(hl)		; $55e2
	ret nz			; $55e4

	set 7,(hl)		; $55e5
	call decNumBombs		; $55e7
	call _itemLoadAttributesAndGraphics		; $55ea
	call _itemMergeZPositionIfSidescrollingArea		; $55ed

;;
; @addr{55f0}
_bombResetAnimationAndSetVisiblec1:
	xor a			; $55f0
	call itemSetAnimation		; $55f1
	jp objectSetVisiblec1		; $55f4

;;
; Bombs call this to check for collision with Link and apply the damage.
;
; @addr{55f7}
_explosionCheckAndApplyLinkCollision:
	; Return if the bomb has already hit Link
	ld h,d			; $55f7
	ld l,Item.var37		; $55f8
	bit 6,(hl)		; $55fa
	ret nz			; $55fc

	ld a,(w1Companion.id)		; $55fd
	cp SPECIALOBJECTID_MINECART			; $5600
	ret z			; $5602

	ld a,BOMBPROOF_RING		; $5603
	call cpActiveRing		; $5605
	ret z			; $5608

	call checkLinkVulnerable		; $5609
	ret nc			; $560c

	; Check if close enough on the Z axis
	ld h,d			; $560d
	ld l,Item.collisionRadiusY		; $560e
	ld a,(hl)		; $5610
	ld c,a			; $5611
	add a			; $5612
	ld b,a			; $5613
	ld l,Item.zh		; $5614
	ld a,(w1Link.zh)		; $5616
	sub (hl)		; $5619
	add c			; $561a
	cp b			; $561b
	ret nc			; $561c

	call objectCheckCollidedWithLink_ignoreZ		; $561d
	ret nc			; $5620

	; Collision occurred; now give Link knockback, etc.

	call objectGetAngleTowardLink		; $5621

	; Set bit 6 to prevent double-hits?
	ld h,d			; $5624
	ld l,Item.var37		; $5625
	set 6,(hl)		; $5627

	ld l,Item.damage		; $5629
	ld c,(hl)		; $562b
	ld hl,w1Link.damageToApply		; $562c
	ld (hl),c		; $562f

	ld l,<w1Link.knockbackCounter		; $5630
	ld (hl),$0c		; $5632

	; knockbackAngle
	dec l			; $5634
	ldd (hl),a		; $5635

	; invincibilityCounter
	ld (hl),$10		; $5636

	; var2a
	dec l			; $5638
	ld (hl),$01		; $5639

	jp linkApplyDamage		; $563b

;;
; Checks whether nearby tiles should be blown up from the explosion.
;
; Each call checks one tile for deletion. After 9 calls, all spots will have been checked.
;
; @param	hl	Pointer to a counter (should count down from 8 to 0)
; @addr{563e}
_explosionTryToBreakNextTile:
	ld a,(hl)		; $563e
	dec (hl)		; $563f
	ld l,a			; $5640
	add a			; $5641
	add l			; $5642
	ld hl,@data		; $5643
	rst_addAToHl			; $5646

	; Verify Z position is close enough (for non-sidescrolling areas)
	ld a,(wAreaFlags)		; $5647
	and AREAFLAG_SIDESCROLL			; $564a
	ld e,Item.zh		; $564c
	ld a,(de)		; $564e
	jr nz,+			; $564f

	sub $02			; $5651
	cp (hl)			; $5653
	ret c			; $5654

	xor a			; $5655
+
	ld c,a			; $5656
	inc hl			; $5657
	ldi a,(hl)		; $5658
	add c			; $5659
	ld b,a			; $565a

	ld a,(hl)		; $565b
	ld c,a			; $565c

	; bc = offset to add to explosion's position

	; Get Y position of tile, return if out of bounds
	ld h,d			; $565d
	ld e,$00		; $565e
	bit 7,b			; $5660
	jr z,+			; $5662
	dec e			; $5664
+
	ld l,Item.yh		; $5665
	ldi a,(hl)		; $5667
	add b			; $5668
	ld b,a			; $5669
	ld a,$00		; $566a
	adc e			; $566c
	ret nz			; $566d

	; Get X position of tile, return if out of bounds
	inc l			; $566e
	ld e,$00		; $566f
	bit 7,c			; $5671
	jr z,+			; $5673
	dec e			; $5675
+
	ld a,(hl)		; $5676
	add c			; $5677
	ld c,a			; $5678
	ld a,$00		; $5679
	adc e			; $567b
	ret nz			; $567c

	ld a,BREAKABLETILESOURCE_04		; $567d
	jp tryToBreakTile		; $567f

; The following is a list of offsets from the center of the bomb at which to try
; destroying tiles.
;
; b0: necessary Z-axis proximity (lower is closer?)
; b1: offset from y-position
; b2: offset from x-position

@data:
	.db $f8 $f3 $f3
	.db $f8 $0c $f3
	.db $f8 $0c $0c
	.db $f8 $f3 $0c
	.db $f4 $00 $f3
	.db $f4 $0c $00
	.db $f4 $00 $0c
	.db $f4 $f3 $00
	.db $f2 $00 $00

;;
; ITEMID_BOOMERANG
; @addr{569d}
itemCode06:
	ld e,Item.state		; $569d
	ld a,(de)		; $569f
	rst_jumpTable			; $56a0

	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3
	.dw @state4

@state0:
	call _itemLoadAttributesAndGraphics		; $56ab
	ld a,UNCMP_GFXH_18		; $56ae
	call loadWeaponGfx		; $56b0

	call itemIncState		; $56b3
	ld l,Item.speed		; $56b6
	ld (hl),SPEED_1a0		; $56b8

	ld l,Item.counter1		; $56ba
	ld (hl),$28		; $56bc

	ld c,-1		; $56be
	ld a,RANG_RING_L1		; $56c0
	call cpActiveRing		; $56c2
	jr z,+			; $56c5

	ld a,RANG_RING_L2		; $56c7
	call cpActiveRing		; $56c9
	jr nz,++		; $56cc
	ld c,-2		; $56ce
+
	; One of the rang rings are equipped; damage output increased (value of 'c')
	ld l,Item.damage		; $56d0
	ld a,(hl)		; $56d2
	add c			; $56d3
	ld (hl),a		; $56d4
++
	call objectSetVisible82		; $56d5
	xor a			; $56d8
	jp itemSetAnimation		; $56d9


; State 1: boomerang moving outward
@state1:
	ld e,Item.var2a		; $56dc
	ld a,(de)		; $56de
	or a			; $56df
	jr nz,@returnToLink	; $56e0

	call objectCheckTileCollision_allowHoles		; $56e2
	jr nc,@noCollision	; $56e5
	call _itemCheckCanPassSolidTile		; $56e7
	jr nz,@hitWall		; $56ea

@noCollision:
	call objectCheckWithinRoomBoundary		; $56ec
	jr nc,@returnToLink	; $56ef

	; Nudge angle toward a certain value. (Is this for the magical boomerang?)
	ld e,Item.var34		; $56f1
	ld a,(de)		; $56f3
	call objectNudgeAngleTowards		; $56f4

	; Decrement counter until boomerang must return
	call itemDecCounter1		; $56f7
	jr nz,@updateSpeedAndAnimation	; $56fa

; Decide on the angle to change to, then go to the next state
@returnToLink:
	call objectGetAngleTowardLink		; $56fc
	ld c,a			; $56ff

	; If the boomerang's Y or X has gone below 0 (above $f0), go directly to link?
	ld h,d			; $5700
	ld l,Item.yh		; $5701
	ld a,$f0		; $5703
	cp (hl)			; $5705
	jr c,@@setAngle		; $5706
	ld l,Item.xh		; $5708
	cp (hl)			; $570a
	jr c,@@setAngle		; $570b

	; If the boomerang is already moving in Link's general direction, don't bother
	; changing the angle?
	ld l,Item.angle		; $570d
	ld a,c			; $570f
	sub (hl)		; $5710
	add $08			; $5711
	cp $11			; $5713
	jr c,@nextState		; $5715

@@setAngle:
	ld l,Item.angle		; $5717
	ld (hl),c		; $5719
	jr @nextState		; $571a

@hitWall:
	call _objectCreateClinkInteraction		; $571c

	; Reverse direction
	ld h,d			; $571f
	ld l,Item.angle		; $5720
	ld a,(hl)		; $5722
	xor $10			; $5723
	ld (hl),a		; $5725

@nextState:
	ld l,Item.state		; $5726
	inc (hl)		; $5728

	; Clear link to parent item
	ld l,Item.relatedObj1		; $5729
	xor a			; $572b
	ldi (hl),a		; $572c
	ld (hl),a		; $572d

	jr @updateSpeedAndAnimation		; $572e


; State 2: boomerang returning to Link
@state2:
	call objectGetAngleTowardLink		; $5730
	call objectNudgeAngleTowards		; $5733

	; Increment state if within 10 pixels of Link
	ld bc,$140a		; $5736
	call _itemCheckWithinRangeOfLink		; $5739
	call c,itemIncState		; $573c

	jr @updateSpeedAndAnimation		; $573f


; State 3: boomerang within 10 pixels of link; move directly toward him instead of nudging
; the angle.
@state3:
	call objectGetAngleTowardLink		; $5741
	ld e,Item.angle		; $5744
	ld (de),a		; $5746

	; Check if within 2 pixels of Link
	ld bc,$0402		; $5747
	call _itemCheckWithinRangeOfLink		; $574a
	jr nc,@updateSpeedAndAnimation	; $574d

	; Go to state 4, make invisible, disable collisions
	call itemIncState		; $574f
	ld l,Item.counter1		; $5752
	ld (hl),$04		; $5754
	ld l,Item.collisionType		; $5756
	ld (hl),$00		; $5758
	jp objectSetInvisible		; $575a


; Stays in this state for 4 frames before deleting itself. I guess this creates a delay
; before the boomerang can be used again?
@state4:
	call itemDecCounter1		; $575d
	jp z,itemDelete		; $5760

	ld a,(wLinkObjectIndex)		; $5763
	ld h,a			; $5766
	ld l,SpecialObject.yh		; $5767
	jp objectTakePosition		; $5769


@updateSpeedAndAnimation:
	call objectApplySpeed		; $576c
	ld h,d			; $576f
	ld l,Item.animParameter		; $5770
	ld a,(hl)		; $5772
	or a			; $5773
	ld (hl),$00		; $5774

	; Play sound when animParameter is nonzero
	ld a,SND_BOOMERANG		; $5776
	call nz,playSound		; $5778

	jp itemAnimate		; $577b

;;
; Assumes that both objects are of the same size (checks top-left positions)
;
; @param	b	Should be double the value of c
; @param	c	Range to be within
; @param[out]	cflag	Set if within specified range of link
; @addr{577e}
_itemCheckWithinRangeOfLink:
	ld hl,w1Link.yh		; $577e
	ld e,Item.yh		; $5781
	ld a,(de)		; $5783
	sub (hl)		; $5784
	add c			; $5785
	cp b			; $5786
	ret nc			; $5787

	ld l,<w1Link.xh		; $5788
	ld e,Item.xh		; $578a
	ld a,(de)		; $578c
	sub (hl)		; $578d
	add c			; $578e
	cp b			; $578f
	ret			; $5790

;;
; The chain on the switch hook; cycles between 3 intermediate positions
;
; ITEMID_SWITCH_HOOK_CHAIN
; @addr{5791}
itemCode0bPost:
	ld a,(w1WeaponItem.id)		; $5791
	cp ITEMID_SWITCH_HOOK			; $5794
	jp nz,itemDelete		; $5796

	ld a,(w1WeaponItem.var2f)		; $5799
	bit 4,a			; $579c
	jp nz,itemDelete		; $579e

	; Copy Z position
	ld h,d			; $57a1
	ld a,(w1WeaponItem.zh)		; $57a2
	ld l,Item.zh		; $57a5
	ld (hl),a		; $57a7

	; Cycle through the 3 positions
	ld l,Item.counter1		; $57a8
	dec (hl)		; $57aa
	jr nz,+			; $57ab
	ld (hl),$03		; $57ad
+
	ld e,(hl)		; $57af

	; Set Y position
	push de			; $57b0
	ld b,$03		; $57b1
	ld hl,w1WeaponItem.yh		; $57b3
	call @setPositionComponent		; $57b6

	; Set X position
	pop de			; $57b9
	ld b,$00		; $57ba
	ld hl,w1WeaponItem.xh		; $57bc

; @param	b	Offset to add to position
; @param	e	Index, or which position to place this at (1-3)
; @param	hl	X or Y position variable
@setPositionComponent:
	ld a,(hl)		; $57bf
	cp $f8			; $57c0
	jr c,+			; $57c2
	xor a			; $57c4
+
	; Calculate: c = ([Switch hook pos] - [Link pos]) / 4
	ld h,>w1Link		; $57c5
	sub (hl)		; $57c7
	ld c,a			; $57c8
	ld a,$00		; $57c9
	sbc a			; $57cb
	rra			; $57cc
	rr c			; $57cd
	rra			; $57cf
	rr c			; $57d0

	; Calculate: a = c * e
	xor a			; $57d2
-
	add c			; $57d3
	dec e			; $57d4
	jr nz,-			; $57d5

	; Add this to the current position (plus offset 'b')
	add (hl)		; $57d7
	add b			; $57d8
	ld h,d			; $57d9
	ldi (hl),a		; $57da
	ret			; $57db

;;
; ITEMID_SWITCH_HOOK_CHAIN
; @addr{57dc}
itemCode0b:
	ld e,Item.state		; $57dc
	ld a,(de)		; $57de
	or a			; $57df
	ret nz			; $57e0

	call _itemLoadAttributesAndGraphics		; $57e1
	call itemIncState		; $57e4
	ld l,Item.counter1		; $57e7
	ld (hl),$03		; $57e9
	xor a			; $57eb
	call itemSetAnimation		; $57ec
	jp objectSetVisible83		; $57ef

;;
; ITEMID_SWITCH_HOOK
; @addr{57f2}
itemCode0aPost:
	call _cpRelatedObject1ID		; $57f2
	ret z			; $57f5

	ld a,(wSwitchHookState)		; $57f6
	or a			; $57f9
	jp z,itemDelete		; $57fa

	jp _func_5902		; $57fd

;;
; ITEMID_SWITCH_HOOK
; @addr{5800}
itemCode0a:
	ld a,$08		; $5800
	ld (wDisableRingTransformations),a		; $5802
	ld a,$80		; $5805
	ld (wcc92),a		; $5807
	ld e,Item.state		; $580a
	ld a,(de)		; $580c
	rst_jumpTable			; $580d
	.dw @state0
	.dw @state1
	.dw @state2
	.dw _switchHookState3

@state0:
	ld a,UNCMP_GFXH_1f		; $5816
	call loadWeaponGfx		; $5818

	ld hl,@offsetsTable		; $581b
	call _applyOffsetTableHL		; $581e

	call objectSetVisible82		; $5821
	call _loadAttributesAndGraphicsAndIncState		; $5824

	; Depending on the switch hook's level, set speed (b) and # frames to extend (c)
	ldbc SPEED_200,$29		; $5827
	ld a,(wSwitchHookLevel)		; $582a
	dec a			; $582d
	jr z,+			; $582e
	ldbc SPEED_300,$26		; $5830
+
	ld h,d			; $5833
	ld l,Item.speed		; $5834
	ld (hl),b		; $5836
	ld l,Item.counter1		; $5837
	ld (hl),c		; $5839

	ld l,Item.var2f		; $583a
	ld (hl),$01		; $583c
	call itemUpdateAngle		; $583e

	; Set animation based on Item.direction
	ld a,(hl)		; $5841
	add $02			; $5842
	jp itemSetAnimation		; $5844

; Offsets to make the switch hook centered with link
@offsetsTable:
	.db $01 $00 $00 ; DIR_UP
	.db $03 $01 $00 ; DIR_RIGHT
	.db $01 $00 $00 ; DIR_DOWN
	.db $03 $ff $00 ; DIR_LEFT

; State 1: extending the hook
@state1:
	; When var2a is nonzero, a collision has occured?
	ld e,Item.var2a		; $5853
	ld a,(de)		; $5855
	or a			; $5856
	jr z,+			; $5857

	; If bit 5 is set, the switch hook can exchange with the object
	bit 5,a			; $5859
	jr nz,@goToState3	; $585b

	; Otherwise, it will be pulled back
	jr @startRetracting		; $585d
+
	; Cancel the switch hook when you take damage
	ld h,d			; $585f
	ld l,Item.var2f		; $5860
	bit 5,(hl)		; $5862
	jp nz,itemDelete		; $5864

	call itemDecCounter1		; $5867
	jr z,@startRetracting	; $586a

	call objectCheckWithinRoomBoundary		; $586c
	jr nc,@startRetracting	; $586f

	; Check if collided with a tile
	call objectCheckTileCollision_allowHoles		; $5871
	jr nc,@noCollisionWithTile	; $5874

	; There is a collision, but check for exceptions (tiles that items can pass by)
	call _itemCheckCanPassSolidTile		; $5876
	jr nz,@collisionWithTile	; $5879

@noCollisionWithTile:
	; Bit 3 of var2f remembers whether a "chain" item has been created
	ld e,Item.var2f		; $587b
	ld a,(de)		; $587d
	bit 3,a			; $587e
	jr nz,++		; $5880

	call getFreeItemSlot		; $5882
	jr nz,++		; $5885

	inc a			; $5887
	ldi (hl),a		; $5888
	ld (hl),ITEMID_SWITCH_HOOK_CHAIN		; $5889

	; Remember to not create the item again
	ld h,d			; $588b
	ld l,Item.var2f		; $588c
	set 3,(hl)		; $588e
++
	call _updateSwitchHookSound		; $5890
	jp objectApplySpeed		; $5893

@collisionWithTile:
	call _objectCreateClinkInteraction		; $5896

	; Check if the tile is breakable (oring with $80 makes it perform only a check,
	; not the breakage itself).
	ld a,$80 | BREAKABLETILESOURCE_SWITCH_HOOK		; $5899
	call itemTryToBreakTile		; $589b
	; Retract if not breakable by the switch hook
	jr nc,@startRetracting	; $589e

	; Hooked onto a tile that can be swapped with
	ld e,Item.subid		; $58a0
	ld a,$01		; $58a2
	ld (de),a		; $58a4

@goToState3:
	ld a,$03		; $58a5
	call itemSetState		; $58a7

	; Disable collisions with objects?
	ld l,Item.collisionType		; $58aa
	res 7,(hl)		; $58ac

	ld a,$ff		; $58ae
	ld (wDisableLinkCollisionsAndMenu),a		; $58b0

	ld a,$01		; $58b3
	ld (wSwitchHookState),a		; $58b5

	jp resetLinkInvincibility		; $58b8

@label_07_185:
	xor a			; $58bb
	ld (wDisableLinkCollisionsAndMenu),a		; $58bc
	ld (wSwitchHookState),a		; $58bf

@startRetracting:
	ld h,d			; $58c2

	; Disable collisions with objects?
	ld l,Item.collisionType		; $58c3
	res 7,(hl)		; $58c5

	ld a,$02		; $58c7
	jp itemSetState		; $58c9

; State 2: retracting the hook
@state2:
	ld e,Item.state2		; $58cc
	ld a,(de)		; $58ce
	or a			; $58cf
	jr nz,@fullyRetracted		; $58d0

	; The counter is just for keeping track of the sound?
	call itemDecCounter1		; $58d2
	call _updateSwitchHookSound		; $58d5

	; Update angle based on position of link
	call objectGetAngleTowardLink		; $58d8
	ld e,Item.angle		; $58db
	ld (de),a		; $58dd

	call objectApplySpeed		; $58de

	; Check if within 8 pixels of link
	ld bc,$1008		; $58e1
	call _itemCheckWithinRangeOfLink		; $58e4
	ret nc			; $58e7

	; Item has reached Link

	call itemIncState2		; $58e8

	; Set Item.counter1 to $03
	inc l			; $58eb
	ld (hl),$03		; $58ec

	ld l,Item.var2f		; $58ee
	set 4,(hl)		; $58f0
	jp objectSetInvisible		; $58f2

@fullyRetracted:
	ld hl,w1Link.yh		; $58f5
	call objectTakePosition		; $58f8
	call itemDecCounter1		; $58fb
	ret nz			; $58fe
	jp itemDelete		; $58ff

;;
; Swap with an object?
; @addr{5902}
_func_5902:
	call _checkRelatedObject2States		; $5902
	jr nc,++		; $5905
	jr z,++			; $5907

	ld a,Object.state2		; $5909
	call objectGetRelatedObject2Var		; $590b
	ld (hl),$03		; $590e
++
	xor a			; $5910
	ld (wDisableLinkCollisionsAndMenu),a		; $5911
	ld (wSwitchHookState),a		; $5914
	jp itemDelete		; $5917

; State 3: grabbed something switchable
; Uses w1ReservedItemE as ITEMID_SWITCH_HOOK_HELPER to hold the positions for link and the
; object temporarily.
_switchHookState3:
	ld e,Item.state2		; $591a
	ld a,(de)		; $591c
	rst_jumpTable			; $591d
	.dw @s3subState0
	.dw @s3subState1
	.dw @s3subState2
	.dw @s3subState3

; Substate 0: grabbed an object/tile, doing the cling animation for several frames
@s3subState0:
	ld h,d			; $5926

	; Check if deletion was requested?
	ld l,Item.var2f		; $5927
	bit 5,(hl)		; $5929
	jp nz,_func_5902		; $592b

	; Wait until the animation writes bit 7 to animParameter
	ld l,Item.animParameter		; $592e
	bit 7,(hl)		; $5930
	jp z,itemAnimate		; $5932

	; At this point the animation is finished, now link and the hooked object/tile
	; will rise and swap

	call _checkRelatedObject2States		; $5935
	jr nc,itemCode0a@label_07_185	; $5938
	; Jump if an object collision, not a tile collision
	jr nz,@@objectCollision		; $593a

	; Tile collision

	; Break the tile underneath whatever was latched on to
	ld a,BREAKABLETILESOURCE_SWITCH_HOOK		; $593c
	call itemTryToBreakTile		; $593e
	jp nc,itemCode0a@label_07_185		; $5941

	ld h,d			; $5944
	ld l,Item.var03		; $5945
	ldh a,(<hFF8E)	; $5947
	ld (hl),a		; $5949

	ld l,Item.var3c		; $594a
	ldh a,(<hFF93)	; $594c
	ldi (hl),a		; $594e
	ldh a,(<hFF92)	; $594f
	ld (hl),a		; $5951

	; Imitate the tile that was grabbed
	call _itemMimicBgTile		; $5952

	ld h,d			; $5955
	ld l,Item.var3c		; $5956
	ld c,(hl)		; $5958
	call objectSetShortPosition		; $5959
	call objectSetVisiblec2		; $595c
	jr +++			; $595f

@@objectCollision:
	ld a,(w1ReservedInteraction1.id)		; $5961
	cp INTERACID_PUSHBLOCK			; $5964
	jr z,++			; $5966

	; Get the object being switched with's yx in bc
	ld a,Object.yh		; $5968
	call objectGetRelatedObject2Var		; $596a
	ldi a,(hl)		; $596d
	inc l			; $596e
	ld c,(hl)		; $596f
	ld b,a			; $5970

	callab bank5.checkPositionSurroundedByWalls		; $5971
	rl b			; $5979
	jr c,++			; $597b

	ld a,Object.yh		; $597d
	call objectGetRelatedObject2Var		; $597f
	call objectTakePosition		; $5982
	call objectSetInvisible		; $5985
+++
	ld a,$02		; $5988
	ld (wSwitchHookState),a		; $598a
.ifdef ROM_AGES
	ld a,SND_SWITCH2		; $598d
.else
	ld a,$8e
.endif
	call playSound		; $598f

	call itemIncState2		; $5992

	ld l,Item.zh		; $5995
	ld (hl),$00		; $5997
	ld l,Item.var2f		; $5999
	set 1,(hl)		; $599b

	; Use w1ReservedItemE to keep copies of xyz positions
	ld hl,w1ReservedItemE		; $599d
	ld a,$01		; $59a0
	ldi (hl),a		; $59a2
	ld (hl),ITEMID_SWITCH_HOOK_HELPER		; $59a3

	; Zero Item.state and Item.state2
	ld l,Item.state		; $59a5
	xor a			; $59a7
	ldi (hl),a		; $59a8
	ldi (hl),a		; $59a9

	call objectCopyPosition		; $59aa
	jp resetLinkInvincibility		; $59ad
++
	ld a,Object.state2		; $59b0
	call objectGetRelatedObject2Var		; $59b2
	ld (hl),$03		; $59b5
	jp itemCode0a@label_07_185		; $59b7


; Substate 1: Link and the object are rising for several frames
@s3subState1:
	ld h,d			; $59ba
	ld l,Item.zh		; $59bb
	dec (hl)		; $59bd
	ld a,(hl)		; $59be
	cp $f1			; $59bf
	call c,itemIncState2		; $59c1
	jr @updateOtherPositions		; $59c4

; Substate 2: Link and the object swap positions
@s3subState2:
	push de			; $59c6

	; Swap Link and Hook's xyz (at least, the copies in w1ReservedItemE)
	ld hl,w1ReservedItemE.var36		; $59c7
	ld de,w1ReservedItemE.var30		; $59ca
	ld b,$06		; $59cd
--
	ld a,(de)		; $59cf
	ld c,(hl)		; $59d0
	ldi (hl),a		; $59d1
	ld a,c			; $59d2
	ld (de),a		; $59d3
	inc e			; $59d4
	dec b			; $59d5
	jr nz,--		; $59d6

	pop de			; $59d8
	ld e,Item.subid		; $59d9
	ld a,(de)		; $59db
	or a			; $59dc
	; Jump if hooked an object, and not a tile
	jr z,@doneCentering	; $59dd

	; Everything from here to @doneCentering involves centering the hooked tile at
	; link's position.

	ld a,(w1Link.direction)		; $59df
	; a *= 3
	ld l,a			; $59e2
	add a			; $59e3
	add l			; $59e4

	ld hl,itemCode0a@offsetsTable		; $59e5
	rst_addAToHl			; $59e8

	push de			; $59e9
	ld de,w1ReservedItemE.var31		; $59ea
	ld a,(de)		; $59ed
	add (hl)		; $59ee
	ld (de),a		; $59ef

	inc hl			; $59f0
	ld e,<w1ReservedItemE.var33		; $59f1
	ld a,(de)		; $59f3
	add (hl)		; $59f4
	ld (de),a		; $59f5

	ld e,<w1ReservedItemE.var31		; $59f6
	call getShortPositionFromDE		; $59f8
	pop de			; $59fb
	ld l,a			; $59fc
	call _checkCanPlaceDiamondOnTile		; $59fd
	jr z,++			; $5a00

	ld e,l			; $5a02
	ld a,(w1Link.direction)		; $5a03
	ld bc,@data		; $5a06
	call addAToBc		; $5a09
	ld a,(bc)		; $5a0c
	rst_addAToHl			; $5a0d
	call _checkCanPlaceDiamondOnTile		; $5a0e
	jr z,++			; $5a11
	ld l,e			; $5a13
++
	ld c,l			; $5a14
	ld hl,w1ReservedItemE.var31		; $5a15
	call setShortPosition_paramC		; $5a18

@doneCentering:
	ld e,Item.y		; $5a1b
	ld hl,w1ReservedItemE.var30		; $5a1d
	ld b,$04		; $5a20
	call copyMemory		; $5a22

	; Reverse link's direction
	ld hl,w1Link.direction		; $5a25
	ld a,(hl)		; $5a28
	xor $02			; $5a29
	ld (hl),a		; $5a2b

	call itemIncState2		; $5a2c
	call _checkRelatedObject2States		; $5a2f
	jr nc,+			; $5a32
	jr z,+			; $5a34
	ld (hl),$02		; $5a36
+
	jr @updateOtherPositions			; $5a38

@data:
	.db $10 $ff $f0 $01

; Update the positions (mainly z positions) for Link and the object being hooked.
@updateOtherPositions:
	; Update other object position if hooked to an enemy
	call _checkRelatedObject2States		; $5a3e
	call nz,objectCopyPosition		; $5a41

	; Update the Z position that w1ReservedItemE is keeping track of
	push de			; $5a44
	ld e,Item.zh		; $5a45
	ld a,(de)		; $5a47
	ld de,w1ReservedItemE.var3b		; $5a48
	ld (de),a		; $5a4b

	; Update link's position
	ld hl,w1Link.y		; $5a4c
	ld e,<w1ReservedItemE.var36		; $5a4f
	ld b,$06		; $5a51
	call copyMemoryReverse		; $5a53
	pop de			; $5a56
	ret			; $5a57

; Substate 3: Link and the other object are moving back to the ground
@s3subState3:
	ld h,d			; $5a58

	; Lower 1 pixel
	ld l,Item.zh		; $5a59
	inc (hl)		; $5a5b
	call @updateOtherPositions		; $5a5c

	; Return if link and the item haven't reached the ground yet
	ld e,Item.zh		; $5a5f
	ld a,(de)		; $5a61
	or a			; $5a62
	ret nz			; $5a63

	call _checkRelatedObject2States		; $5a64
	jr nz,@reenableEnemy		; $5a67

	; For tile collisions, check whether to make the interaction which shows it
	; breaking, or whether to keep the switch hook diamond there

	call objectGetTileCollisions		; $5a69
	call _checkCanPlaceDiamondOnTile		; $5a6c
	jr nz,+			; $5a6f

	; If the current block is the switch diamond, do NOT break it
	ld c,l			; $5a71
	ld e,Item.var3d		; $5a72
	ld a,(de)		; $5a74
	cp TILEINDEX_SWITCH_DIAMOND			; $5a75
	jr nz,+			; $5a77

	call setTile		; $5a79
	jr @delete			; $5a7c
+
	; Create the bush/pot/etc breakage animation (based on var03)
	callab bank6.itemMakeInteractionForBreakableTile		; $5a7e
	jr @delete		; $5a86

@reenableEnemy:
	ld (hl),$03		; $5a88
@delete:
	xor a			; $5a8a
	ld (wSwitchHookState),a		; $5a8b
	ld (wDisableLinkCollisionsAndMenu),a		; $5a8e
	jp itemDelete		; $5a91

;;
; This function is used for the switch hook.
;
; @param[out]	hl	Related object 2's state2 variable
; @param[out]	zflag	Set if latched onto a tile, not an object
; @param[out]	cflag	Unset if the related object is on state 3, substate 3?
; @addr{5a94}
_checkRelatedObject2States:
	; Jump if latched onto a tile, not an object
	ld e,Item.subid		; $5a94
	ld a,(de)		; $5a96
	dec a			; $5a97
	jr z,++			; $5a98

	; It might be assuming that there aren't any states above $03, so the carry flag
	; will always be set when returning here?
	ld a,Object.state		; $5a9a
	call objectGetRelatedObject2Var		; $5a9c
	ldi a,(hl)		; $5a9f
	cp $03			; $5aa0
	ret nz			; $5aa2

	ld a,(hl)		; $5aa3
	cp $03			; $5aa4
	ret nc			; $5aa6

	or d			; $5aa7
++
	scf			; $5aa8
	ret			; $5aa9

;;
; Plays the switch hook sound every 4 frames.
; @addr{5aaa}
_updateSwitchHookSound:
	ld e,Item.counter1		; $5aaa
	ld a,(de)		; $5aac
	and $03			; $5aad
	ret z			; $5aaf

	ld a,SND_SWITCH_HOOK		; $5ab0
	jp playSound		; $5ab2

;;
; @param l Position to check
; @param[out] zflag Set if the tile at l has a collision value of 0 (or is the somaria
; block?)
; @addr{5ab5}
_checkCanPlaceDiamondOnTile:
	ld h,>wRoomCollisions		; $5ab5
	ld a,(hl)		; $5ab7
	or a			; $5ab8
	ret z			; $5ab9
	ld h,>wRoomLayout		; $5aba
	ld a,(hl)		; $5abc
	cp TILEINDEX_SOMARIA_BLOCK			; $5abd
	ret			; $5abf


;;
; ITEMID_SWITCH_HOOK_HELPER
; Used with the switch hook in w1ReservedItemE to store position values.
; @addr{5ac0}
itemCode09:
	ld h,d			; $5ac0
	ld l,Item.var2f		; $5ac1
	bit 5,(hl)		; $5ac3
	jr nz,@state2		; $5ac5

	ld e,Item.state		; $5ac7
	ld a,(de)		; $5ac9
	rst_jumpTable			; $5aca
	.dw @state0
	.dw @state1
	.dw @state2

; Initialization (initial copying of positions)
@state0:
	call itemIncState		; $5ad1
	ld h,d			; $5ad4

	; Copy from Item.y to Item.var30
	ld l,Item.y		; $5ad5
	ld e,Item.var30		; $5ad7
	ld b,$06		; $5ad9
	call copyMemory		; $5adb

	; Copy from w1Link.y to Item.var36
	ld hl,w1Link.y		; $5ade
	ld b,$06		; $5ae1
	call copyMemory		; $5ae3

	; Set the focused object to this
	jp setCameraFocusedObject		; $5ae6

; State 1: do nothing until the switch hook is no longer in use, then delete self
@state1:
	ld a,(w1WeaponItem.id)		; $5ae9
	cp ITEMID_SWITCH_HOOK			; $5aec
	ret z			; $5aee

; State 2: Restore camera to focusing on Link and delete self
@state2:
	call setCameraFocusedObjectToLink		; $5aef
	jp itemDelete		; $5af2

;;
; Unused?
; @addr{5af5}
_func_5af5:
	ld hl,w1ReservedItemE		; $5af5
	bit 0,(hl)		; $5af8
	ret z			; $5afa
	ld l,Item.var2f		; $5afb
	set 5,(hl)		; $5afd
	ret			; $5aff

;;
; ITEMID_RICKY_TORNADO
; @addr{5b00}
itemCode2a:
	ld e,Item.state		; $5b00
	ld a,(de)		; $5b02
	rst_jumpTable			; $5b03

	.dw @state0
	.dw @state1


; State 0: initialization
@state0:
	call itemIncState		; $5b08
	ld l,Item.speed		; $5b0b
	ld (hl),SPEED_300		; $5b0d

	ld a,(w1Companion.direction)		; $5b0f
	ld c,a			; $5b12
	swap a			; $5b13
	rrca			; $5b15
	ld l,Item.angle		; $5b16
	ld (hl),a		; $5b18

	; Get offset from companion position to spawn at in 'bc'
	ld a,c			; $5b19
	ld hl,@offsets		; $5b1a
	rst_addDoubleIndex			; $5b1d
	ldi a,(hl)		; $5b1e
	ld c,(hl)		; $5b1f
	ld b,a			; $5b20

	; Copy companion's position
	ld hl,w1Companion.yh		; $5b21
	call objectTakePositionWithOffset		; $5b24

	; Make Z position 2 higher than companion
	sub $02			; $5b27
	ld (de),a		; $5b29

	call _itemLoadAttributesAndGraphics		; $5b2a
	xor a			; $5b2d
	call itemSetAnimation		; $5b2e
	jp objectSetVisiblec1		; $5b31

@offsets:
	.db $f0 $00 ; DIR_UP
	.db $00 $0c ; DIR_RIGHT
	.db $08 $00 ; DIR_DOWN
	.db $00 $f4 ; DIR_LEFT


; State 1: flying away until it hits something
@state1:
	call objectApplySpeed		; $5b3c

	ld a,BREAKABLETILESOURCE_SWORD_L1		; $5b3f
	call itemTryToBreakTile		; $5b41

	call objectGetTileCollisions		; $5b44
	and $0f			; $5b47
	cp $0f			; $5b49
	jp z,itemDelete		; $5b4b

	jp itemAnimate		; $5b4e


;;
; ITEMID_SHOOTER
; ITEMID_29
;
; @addr{5b51}
itemCode0f:
itemCode29:
	ld e,Item.state		; $5b51
	ld a,(de)		; $5b53
	rst_jumpTable			; $5b54
	.dw @state0
	.dw @state1

@state0:
	ld a,UNCMP_GFXH_1d		; $5b59
	call loadWeaponGfx		; $5b5b
	call _loadAttributesAndGraphicsAndIncState		; $5b5e
	ld e,Item.var30		; $5b61
	ld a,$ff		; $5b63
	ld (de),a		; $5b65
	jp objectSetVisible81		; $5b66

@state1:
	ret			; $5b69


;;
; ITEMID_SHOOTER
; @addr{5b6a}
itemCode0fPost:
	call _cpRelatedObject1ID		; $5b6a
	jp nz,itemDelete		; $5b6d

	ld hl,@data		; $5b70
	call _itemInitializeFromLinkPosition		; $5b73

	; Copy link Z position
	ld h,d			; $5b76
	ld a,(w1Link.zh)		; $5b77
	ld l,Item.zh		; $5b7a
	ld (hl),a		; $5b7c

	; Check if angle has changed
	ld l,Item.var30		; $5b7d
	ld a,(w1ParentItem2.angle)		; $5b7f
	cp (hl)			; $5b82
	ld (hl),a		; $5b83
	ret z			; $5b84
	jp itemSetAnimation		; $5b85


; b0/b1: collisionRadiusY/X
; b2/b3: Y/X offsets relative to Link
@data:
	.db $00 $00 $00 $00


;;
; ITEMID_28 (ricky/moosh attack?)
;
; @addr{5b8c}
itemCode28:
	ld e,Item.state		; $5b8c
	ld a,(de)		; $5b8e
	or a			; $5b8f
	jr nz,+			; $5b90

	; Initialization
	call itemIncState		; $5b92
	ld l,Item.counter1		; $5b95
	ld (hl),$14		; $5b97
	call _itemLoadAttributesAndGraphics		; $5b99
	jr @calculatePosition			; $5b9c
+
	call @calculatePosition		; $5b9e
	call @tryToBreakTiles		; $5ba1
	call itemDecCounter1		; $5ba4
	ret nz			; $5ba7
	jp itemDelete		; $5ba8

@calculatePosition:
	ld a,(w1Companion.id)		; $5bab
	cp SPECIALOBJECTID_RICKY			; $5bae
	ld hl,@mooshData		; $5bb0
	jr nz,+			; $5bb3

	ld a,(w1Companion.direction)		; $5bb5
	add a			; $5bb8
	ld hl,@rickyData		; $5bb9
	rst_addDoubleIndex			; $5bbc
+
	jp _itemInitializeFromLinkPosition		; $5bbd


; b0/b1: collisionRadiusY/X
; b2/b3: Y/X offsets from Link's position

@rickyData:
	.db $10 $0c $f4 $00 ; DIR_UP
	.db $0c $12 $fe $08 ; DIR_RIGHT
	.db $10 $0c $08 $00 ; DIR_DOWN
	.db $0c $12 $fe $f8 ; DIR_LEFT

@mooshData:
	.db $18 $18 $10 $00


@tryToBreakTiles:
	ld hl,@rickyBreakableTileOffsets		; $5bd4
	ld a,(w1Companion.id)		; $5bd7
	cp SPECIALOBJECTID_RICKY			; $5bda
	jr z,@nextTile			; $5bdc
	ld hl,@mooshBreakableTileOffsets		; $5bde

@nextTile:
	; Get item Y/X + offset in bc
	ld e,Item.yh		; $5be1
	ld a,(de)		; $5be3
	add (hl)		; $5be4
	ld b,a			; $5be5
	inc hl			; $5be6
	ld e,Item.xh		; $5be7
	ld a,(de)		; $5be9
	add (hl)		; $5bea
	ld c,a			; $5beb

	inc hl			; $5bec
	push hl			; $5bed
	ld a,(w1Companion.id)		; $5bee
	cp SPECIALOBJECTID_RICKY			; $5bf1
	ld a,BREAKABLETILESOURCE_0f		; $5bf3
	jr z,+			; $5bf5
	ld a,BREAKABLETILESOURCE_11		; $5bf7
+
	call tryToBreakTile		; $5bf9
	pop hl			; $5bfc
	ld a,(hl)		; $5bfd
	cp $ff			; $5bfe
	jr nz,@nextTile		; $5c00
	ret			; $5c02


; List of offsets from this object's position to try breaking tiles at

@rickyBreakableTileOffsets:
	.db $f8 $08
	.db $f8 $f8
	.db $08 $08
	.db $08 $f8
	.db $ff

@mooshBreakableTileOffsets:
	.db $00 $00
	.db $f0 $f0
	.db $f0 $00
	.db $f0 $10
	.db $00 $f0
	.db $00 $10
	.db $10 $f0
	.db $10 $00
	.db $10 $10
	.db $ff


;;
; ITEMID_SHOVEL
; @addr{5c1f}
itemCode15:
	ld e,Item.state		; $5c1f
	ld a,(de)		; $5c21
	or a			; $5c22
	jr nz,@state1		; $5c23

	; Initialization (state 0)

	call _itemLoadAttributesAndGraphics		; $5c25
	call itemIncState		; $5c28
	ld l,Item.counter1		; $5c2b
	ld (hl),$04		; $5c2d

	ld a,BREAKABLETILESOURCE_06		; $5c2f
	call itemTryToBreakTile		; $5c31
	ld a,SND_CLINK		; $5c34
	jr nc,+			; $5c36

	; Dig succeeded
	ld a,$01		; $5c38
	call addToGashaMaturity		; $5c3a
	ld a,SND_DIG		; $5c3d
+
	jp playSound		; $5c3f

; State 1: does nothing for 4 frames?
@state1:
	call itemDecCounter1		; $5c42
	ret nz			; $5c45
	jp itemDelete		; $5c46


;;
; ITEMID_CANE_OF_SOMARIA
; @addr{5c49}
itemCode04:
	call _itemTransferKnockbackToLink		; $5c49
	ld e,Item.state		; $5c4c
	ld a,(de)		; $5c4e
	rst_jumpTable			; $5c4f

	.dw @state0
	.dw @state1
	.dw @state2

@state0:
	ld a,UNCMP_GFXH_1c		; $5c56
	call loadWeaponGfx		; $5c58
	call _loadAttributesAndGraphicsAndIncState		; $5c5b

	ld a,SND_SWORDSLASH		; $5c5e
	call playSound		; $5c60

	xor a			; $5c63
	call itemSetAnimation		; $5c64
	jp objectSetVisible82		; $5c67

@state1:
	; Wait for a particular part of the swing animation
	ld a,(w1ParentItem2.animParameter)		; $5c6a
	cp $06			; $5c6d
	ret nz			; $5c6f

	call itemIncState		; $5c70

	ld c,ITEMID_18		; $5c73
	call findItemWithID		; $5c75
	jr nz,+			; $5c78

	; Set var2f of any previous instance of ITEMID_18 (triggers deletion?)
	ld l,Item.var2f		; $5c7a
	set 5,(hl)		; $5c7c
+
	; Get in bc the place to try to make a block
	ld a,(w1Link.direction)		; $5c7e
	ld hl,@somariaCreationOffsets		; $5c81
	rst_addDoubleIndex			; $5c84
	ld a,(w1Link.yh)		; $5c85
	add (hl)		; $5c88
	ld b,a			; $5c89
	inc hl			; $5c8a
	ld a,(w1Link.xh)		; $5c8b
	add (hl)		; $5c8e
	ld c,a			; $5c8f

	call getFreeItemSlot		; $5c90
	ret nz			; $5c93
	inc (hl)		; $5c94
	inc l			; $5c95
	ld (hl),ITEMID_18		; $5c96

	; Set Y/X of the new item as calculated earlier, and copy Link's Z position
	ld l,Item.yh		; $5c98
	ld (hl),b		; $5c9a
	ld a,(w1Link.zh)		; $5c9b
	ld l,Item.zh		; $5c9e
	ldd (hl),a		; $5ca0
	dec l			; $5ca1
	ld (hl),c		; $5ca2

@state2:
	ret			; $5ca3

; Offsets relative to link's position to try to create a somaria block?
@somariaCreationOffsets:
	.dw $00ec ; DIR_UP
	.dw $1300 ; DIR_RIGHT
	.dw $0013 ; DIR_DOWN
	.dw $ec00 ; DIR_LEFT


;;
; ITEMID_18 (somaria block object)
; @addr{5cac}
itemCode18:
	ld e,Item.state		; $5cac
	ld a,(de)		; $5cae
	rst_jumpTable			; $5caf

	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3
	.dw @state4


; State 0: initialization
@state0:
	call _itemMergeZPositionIfSidescrollingArea		; $5cba
	call @alignOnTile		; $5cbd
	call _itemLoadAttributesAndGraphics		; $5cc0
	xor a			; $5cc3
	call itemSetAnimation		; $5cc4
	call itemIncState		; $5cc7
	ld a,SND_MYSTERY_SEED		; $5cca
	call playSound		; $5ccc
	jp objectSetVisible83		; $5ccf


; State 1: phasing in
@state1:
	call @checkBlockCanAppear		; $5cd2
	call z,@pushLinkAway		; $5cd5

	; Wait for phase-in animation to complete
	call itemAnimate		; $5cd8
	ld e,Item.animParameter		; $5cdb
	ld a,(de)		; $5cdd
	or a			; $5cde
	ret z			; $5cdf

	; Animation done

	ld h,d			; $5ce0
	ld l,Item.oamFlagsBackup		; $5ce1
	ld a,$0d		; $5ce3
	ldi (hl),a		; $5ce5
	ldi (hl),a		; $5ce6

	; Item.oamTileIndexBase
	ld (hl),$36		; $5ce7

	; Enable collisions with enemies?
	ld l,Item.collisionType		; $5ce9
	set 7,(hl)		; $5ceb

@checkCreateBlock:
	call @checkBlockCanAppear		; $5ced
	jr nz,@deleteSelfWithPuff	; $5cf0
	call @createBlockIfNotOnHazard		; $5cf2
	jr nz,@deleteSelfWithPuff	; $5cf5

	; Note: a = 0 here

	ld h,d			; $5cf7
	ld l,Item.zh		; $5cf8
	ld (hl),a		; $5cfa

	; Set [state]=3, [state2]=0
	ld l,Item.state2		; $5cfb
	ldd (hl),a		; $5cfd
	ld (hl),$03		; $5cfe

	ld l,Item.collisionRadiusY		; $5d00
	ld a,$04		; $5d02
	ldi (hl),a		; $5d04
	ldi (hl),a		; $5d05

	ld l,Item.var2f		; $5d06
	ld a,(hl)		; $5d08
	and $f0			; $5d09
	ld (hl),a		; $5d0b

	ld a,$01		; $5d0c
	jp itemSetAnimation		; $5d0e


; State 4: block being pushed
@state4:
	ld e,Item.state2		; $5d11
	ld a,(de)		; $5d13
	rst_jumpTable			; $5d14

	.dw @state4Substate0
	.dw @state4Substate1

@state4Substate0:
	call itemIncState2		; $5d19
	call itemUpdateAngle		; $5d1c

	; Set speed & counter1 based on bracelet level
	ldbc SPEED_80, $20		; $5d1f
	ld a,(wBraceletLevel)		; $5d22
	cp $02			; $5d25
	jr nz,+			; $5d27
	ldbc SPEED_c0, $15		; $5d29
+
	ld l,Item.speed		; $5d2c
	ld (hl),b		; $5d2e
	ld l,Item.counter1		; $5d2f
	ld (hl),c		; $5d31

	ld a,SND_MOVEBLOCK		; $5d32
	call playSound		; $5d34
	call @removeBlock		; $5d37

@state4Substate1:
	call _itemUpdateDamageToApply		; $5d3a
	jr c,@deleteSelfWithPuff	; $5d3d
	call @checkDeletionTrigger		; $5d3f
	jr nz,@deleteSelfWithPuff	; $5d42

	call objectApplySpeed		; $5d44
	call @pushLinkAway		; $5d47
	call itemDecCounter1		; $5d4a

	ld l,Item.collisionRadiusY		; $5d4d
	ld a,$04		; $5d4f
	ldi (hl),a		; $5d51
	ld (hl),a		; $5d52

	; Return if counter1 is not 0
	ret nz			; $5d53

	jr @checkCreateBlock		; $5d54


@removeBlockAndDeleteSelfWithPuff:
	call @removeBlock		; $5d56
@deleteSelfWithPuff:
	ld h,d			; $5d59
	ld l,Item.var2f		; $5d5a
	bit 4,(hl)		; $5d5c
	call z,objectCreatePuff		; $5d5e
@deleteSelf:
	jp itemDelete		; $5d61


; State 2: being picked up / thrown
@state2:
	ld e,Item.state2		; $5d64
	ld a,(de)		; $5d66
	rst_jumpTable			; $5d67

	.dw @state2Substate0
	.dw @state2Substate1
	.dw @state2Substate2
	.dw @state2Substate3

; Substate 0: just picked up
@state2Substate0:
	call itemIncState2		; $5d70
	call @removeBlock		; $5d73
	call objectSetVisiblec1		; $5d76
	ld a,$02		; $5d79
	jp itemSetAnimation		; $5d7b

; Substate 1: being lifted
@state2Substate1:
	call _itemUpdateDamageToApply		; $5d7e
	ret nc			; $5d81
	call dropLinkHeldItem		; $5d82
	jr @deleteSelfWithPuff		; $5d85

; Substate 2/3: being thrown
@state2Substate2:
@state2Substate3:
	call objectCheckWithinRoomBoundary		; $5d87
	jr nc,@deleteSelf	; $5d8a

	call _bombUpdateThrowingLaterally		; $5d8c
	call @checkDeletionTrigger		; $5d8f
	jr nz,@deleteSelfWithPuff	; $5d92

	; var39 = gravity
	ld l,Item.var39		; $5d94
	ld c,(hl)		; $5d96
	call _itemUpdateThrowingVerticallyAndCheckHazards		; $5d97
	jr c,@deleteSelf	; $5d9a

	ret z			; $5d9c
	jr @deleteSelfWithPuff		; $5d9d


; State 3: block is just sitting around
@state3:
	call @checkBlockInPlace		; $5d9f
	jr nz,@deleteSelfWithPuff	; $5da2

	; Check if health went below 0
	call _itemUpdateDamageToApply		; $5da4
	jr c,@removeBlockAndDeleteSelfWithPuff	; $5da7

	; Check bit 5 of var2f (set when another somaria block is being created)
	call @checkDeletionTrigger		; $5da9
	jr nz,@removeBlockAndDeleteSelfWithPuff	; $5dac

	; If Link somehow ends up on this tile, delete the block
	ld a,(wActiveTilePos)		; $5dae
	ld l,Item.var32		; $5db1
	cp (hl)			; $5db3
	jr z,@removeBlockAndDeleteSelfWithPuff	; $5db4

	; If in a sidescrolling area, check that the tile below is solid
	ld a,(wAreaFlags)		; $5db6
	and AREAFLAG_SIDESCROLL			; $5db9
	jr z,++			; $5dbb

	ld a,(hl)		; $5dbd
	add $10			; $5dbe
	ld c,a			; $5dc0
	ld b,>wRoomCollisions		; $5dc1
	ld a,(bc)		; $5dc3
	cp $0f			; $5dc4
	jr nz,@removeBlockAndDeleteSelfWithPuff	; $5dc6
++
	ld l,Item.var2f		; $5dc8
	bit 0,(hl)		; $5dca
	jp z,objectAddToGrabbableObjectBuffer		; $5dcc

	; Link pushed on the block
	ld a,$04		; $5dcf
	jp itemSetState		; $5dd1

;;
; @param[out]	zflag	Unset if slated for deletion
; @addr{5dd4}
@checkDeletionTrigger:
	ld h,d			; $5dd4
	ld l,Item.var2f		; $5dd5
	bit 5,(hl)		; $5dd7
	ret			; $5dd9

;;
; @addr{5dda}
@pushLinkAway:
	ld e,Item.collisionRadiusY		; $5dda
	ld a,$07		; $5ddc
	ld (de),a		; $5dde
	ld hl,w1Link		; $5ddf
	jp preventObjectHFromPassingObjectD		; $5de2

;;
; @param[out]	zflag	Set if the cane of somaria block is present, and is solid?
; @addr{5de5}
@checkBlockInPlace:
	ld e,Item.var32		; $5de5
	ld a,(de)		; $5de7
	ld l,a			; $5de8
	ld h,>wRoomLayout		; $5de9
	ld a,(hl)		; $5deb
	cp TILEINDEX_SOMARIA_BLOCK			; $5dec
	ret nz			; $5dee

	ld h,>wRoomCollisions		; $5def
	ld a,(hl)		; $5df1
	cp $0f			; $5df2
	ret			; $5df4

;;
; @addr{5df5}
@removeBlock:
	call @checkBlockInPlace		; $5df5
	ret nz			; $5df8

	; Restore tile
	ld e,Item.var32		; $5df9
	ld a,(de)		; $5dfb
	call getTileIndexFromRoomLayoutBuffer		; $5dfc
	jp setTile		; $5dff

;;
; @param[out]	zflag	Set if the block can appear at this position
; @addr{5e02}
@checkBlockCanAppear:
	; Disallow cane of somaria usage if in patch's minigame room
	ld a,(wActiveGroup)		; $5e02
	cp $05			; $5e05
	jr nz,+			; $5e07
	ld a,(wActiveRoom)		; $5e09
	cp $e8			; $5e0c
	jr z,@@disallow		; $5e0e
+
	; Must be close to the ground
	ld e,Item.zh		; $5e10
	ld a,(de)		; $5e12
	dec a			; $5e13
	cp $fc			; $5e14
	jr c,@@disallow		; $5e16

	; Can't be in a wall
	call objectGetTileCollisions		; $5e18
	ret nz			; $5e1b

	; If underwater, never allow it
	ld a,(wAreaFlags)		; $5e1c
	bit AREAFLAG_BIT_UNDERWATER,a			; $5e1f
	ret nz			; $5e21

	; If in a sidescrolling area, check for floor underneath
	and AREAFLAG_SIDESCROLL			; $5e22
	ret z			; $5e24

	ld a,l			; $5e25
	add $10			; $5e26
	ld l,a			; $5e28
	ld a,(hl)		; $5e29
	cp $0f			; $5e2a
	ret			; $5e2c

@@disallow:
	or d			; $5e2d
	ret			; $5e2e

;;
; @param[out]	zflag	Set on success
; @addr{5e2f}
@createBlockIfNotOnHazard:
	call @alignOnTile		; $5e2f
	call objectGetTileAtPosition		; $5e32
	push hl			; $5e35
	ld hl,hazardCollisionTable		; $5e36
	call lookupCollisionTable		; $5e39
	pop hl			; $5e3c
	jr c,++			; $5e3d

	; Overwrite the tile with the somaria block
	ld b,(hl)		; $5e3f
	ld (hl),TILEINDEX_SOMARIA_BLOCK		; $5e40
	ld h,>wRoomCollisions		; $5e42
	ld (hl),$0f		; $5e44

	; Save the old value of the tile to w3RoomLayoutBuffer
	ld e,Item.var32		; $5e46
	ld a,l			; $5e48
	ld (de),a		; $5e49
	ld c,a			; $5e4a
	call setTileInRoomLayoutBuffer		; $5e4b
	xor a			; $5e4e
	ret			; $5e4f
++
	or d			; $5e50
	ret			; $5e51

@alignOnTile:
	call objectCenterOnTile		; $5e52
	ld l,Item.yh		; $5e55
	dec (hl)		; $5e57
	dec (hl)		; $5e58
	ret			; $5e59


;;
; ITEMID_MINECART_COLLISION
; @addr{5e5a}
itemCode1d:
	ld e,Item.state		; $5e5a
	ld a,(de)		; $5e5c
	or a			; $5e5d
	ret nz			; $5e5e

	call _itemLoadAttributesAndGraphics		; $5e5f
	call itemIncState		; $5e62
	ld l,Item.enabled		; $5e65
	set 1,(hl)		; $5e67

@ret:
	ret			; $5e69

;;
; ITEMID_MINECART_COLLISION
; @addr{5e6a}
itemCode1dPost:
	ld hl,w1Companion.id		; $5e6a
	ld a,(hl)		; $5e6d
	cp SPECIALOBJECTID_MINECART			; $5e6e
	jp z,objectTakePosition		; $5e70
	jp itemDelete		; $5e73


;;
; ITEMID_SLINGSHOT
; @addr{5e76}
itemCode13:
	ret			; $5e76


;;
; ITEMID_BIGGORON_SWORD
; ITEMID_FOOLS_ORE
;
; @addr{5e77}
itemCode0c:
itemCode1e:
	ld e,Item.state		; $5e77
	ld a,(de)		; $5e79
	rst_jumpTable			; $5e7a

	.dw @state0
	.dw itemCode1d@ret

@state0:
	ld a,UNCMP_GFXH_1b		; $5e7f
	call loadWeaponGfx		; $5e81
	call _loadAttributesAndGraphicsAndIncState		; $5e84
	ld a,SND_BIGSWORD		; $5e87
	call playSound		; $5e89
	jp objectSetVisible82		; $5e8c


;;
; ITEMID_SWORD
; @addr{5e8f}
itemCode05:
	call _itemTransferKnockbackToLink		; $5e8f
	ld e,Item.state		; $5e92
	ld a,(de)		; $5e94
	rst_jumpTable			; $5e95

	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3
	.dw @state4
	.dw @state5
	.dw @state6

@swordSounds:
	.db SND_SWORDSLASH
	.db SND_UNKNOWN5
	.db SND_BOOMERANG
	.db SND_SWORDSLASH
	.db SND_SWORDSLASH
	.db SND_UNKNOWN5
	.db SND_SWORDSLASH
	.db SND_SWORDSLASH


@state0:
	ld a,UNCMP_GFXH_1a		; $5eac
	call loadWeaponGfx		; $5eae

	; Play a random sound
	call getRandomNumber_noPreserveVars		; $5eb1
	and $07			; $5eb4
	ld hl,@swordSounds		; $5eb6
	rst_addAToHl			; $5eb9
	ld a,(hl)		; $5eba
	call playSound		; $5ebb

	ld e,Item.var31		; $5ebe
	xor a			; $5ec0
	ld (de),a		; $5ec1


; State 6: partial re-initialization?
@state6:
	call _loadAttributesAndGraphicsAndIncState		; $5ec2

	; Load collisiontype and damage
	ld a,(wSwordLevel)		; $5ec5
	ld hl,@swordLevelData-2		; $5ec8
	rst_addDoubleIndex			; $5ecb

	ld e,Item.collisionType		; $5ecc
	ldi a,(hl)		; $5ece
	ld (de),a		; $5ecf
	ld c,(hl)		; $5ed0

	; If var31 was nonzero, skip whimsical ring check?
	ld e,Item.var31		; $5ed1
	ld a,(de)		; $5ed3
	or a			; $5ed4
	ld a,c			; $5ed5
	ld (de),a		; $5ed6
	jr nz,@@setDamage		; $5ed7

	; Whimsical ring: usually 1 damage, with a 1/256 chance of doing 12 damage
	ld a,WHIMSICAL_RING		; $5ed9
	call cpActiveRing		; $5edb
	jr nz,@@setDamage		; $5ede
	call getRandomNumber		; $5ee0
	or a			; $5ee3
	ld c,-1		; $5ee4
	jr nz,@@setDamage		; $5ee6
	ld a,SND_LIGHTNING		; $5ee8
	call playSound		; $5eea
	ld c,-12		; $5eed

@@setDamage:
	ld e,Item.var3a		; $5eef
	ld a,c			; $5ef1
	ld (de),a		; $5ef2

	ld e,Item.state		; $5ef3
	ld a,$01		; $5ef5
	ld (de),a		; $5ef7

	jp objectSetVisible82		; $5ef8

; b0: collisionType
; b1: base damage
@swordLevelData:
	; L-1
	.db ($80|ITEMCOLLISION_L1_SWORD)
	.db (-2)

	; L-2
	.db ($80|ITEMCOLLISION_L2_SWORD)
	.db (-3)

	; L-3
	.db ($80|ITEMCOLLISION_L3_SWORD)
	.db (-5)


; State 4: swordspinning
@state4:
	ld e,Item.collisionType		; $5f01
	ld a, $80 | ITEMCOLLISION_SWORDSPIN		; $5f03
	ld (de),a		; $5f05


; State 1: being swung
@state1:
	ld h,d			; $5f06
	ld l,Item.oamFlagsBackup		; $5f07
	ldi a,(hl)		; $5f09
	ld (hl),a		; $5f0a
	ret			; $5f0b


; State 2: charging
@state2:
	ld e,Item.var31		; $5f0c
	ld a,(de)		; $5f0e
	ld e,Item.var3a		; $5f0f
	ld (de),a		; $5f11
	ret			; $5f12


; State 3: sword fully charged, flashing
@state3:
	ld h,d			; $5f13
	ld l,Item.counter1		; $5f14
	inc (hl)		; $5f16
	bit 2,(hl)		; $5f17
	ld l,Item.oamFlagsBackup		; $5f19
	ldi a,(hl)		; $5f1b
	jr nz,+			; $5f1c
	ld a,$0d		; $5f1e
+
	ld (hl),a		; $5f20
	ret			; $5f21


; State 5: end of swordspin
@state5:
	; Try to break tile at Link's feet, then delete self
	ld a,$08		; $5f22
	call _tryBreakTileWithSword_calculateLevel		; $5f24
	jp itemDelete		; $5f27


;;
; ITEMID_PUNCH
; ITEMID_NONE also points here, but this doesn't get called from there normally
; @addr{5f2a}
itemCode00:
itemCode02:
	ld e,Item.state		; $5f2a
	ld a,(de)		; $5f2c
	rst_jumpTable			; $5f2d

	.dw @state0
	.dw @state1

@state0:
	call _itemLoadAttributesAndGraphics		; $5f32
	ld c,SND_STRIKE		; $5f35
	call itemIncState		; $5f37
	ld l,Item.counter1		; $5f3a
	ld (hl),$04		; $5f3c
	ld l,Item.subid		; $5f3e
	bit 0,(hl)		; $5f40
	jr z,++			; $5f42

	; Expert's ring (bit 0 of Item.subid set)

	ld l,Item.collisionRadiusY		; $5f44
	ld a,$06		; $5f46
	ldi (hl),a		; $5f48
	ldi (hl),a		; $5f49

	; Increase Item.damage
	ld a,(hl)		; $5f4a
	add $fd			; $5f4b
	ld (hl),a		; $5f4d

	; Different collisionType for expert's ring?
	ld l,Item.collisionType		; $5f4e
	inc (hl)		; $5f50

	; Check for clinks against bombable walls?
	call _tryBreakTileWithExpertsRing		; $5f51

	ld c,SND_EXPLOSION		; $5f54
++
	ld a,c			; $5f56
	jp playSound		; $5f57

@state1:
	call itemDecCounter1		; $5f5a
	jp z,itemDelete		; $5f5d
	ret			; $5f60


;;
; ITEMID_SWORD_BEAM
; @addr{5f61}
itemCode27:
	ld e,Item.state		; $5f61
	ld a,(de)		; $5f63
	rst_jumpTable			; $5f64

	.dw @state0
	.dw @state1

@state0:
	ld hl,@initialOffsetsTable		; $5f69
	call _applyOffsetTableHL		; $5f6c
	call _itemLoadAttributesAndGraphics		; $5f6f
	call itemIncState		; $5f72

	ld l,Item.speed		; $5f75
	ld (hl),SPEED_300		; $5f77

	; Calculate angle
	ld l,Item.direction		; $5f79
	ldi a,(hl)		; $5f7b
	ld c,a			; $5f7c
	swap a			; $5f7d
	rrca			; $5f7f
	ld (hl),a		; $5f80

	ld a,c			; $5f81
	call itemSetAnimation		; $5f82
	call objectSetVisible81		; $5f85

	ld a,SND_SWORDBEAM		; $5f88
	jp playSound		; $5f8a

@initialOffsetsTable:
	.db $f5 $fc $00 ; DIR_UP
	.db $00 $0c $00 ; DIR_RIGHT
	.db $0a $03 $00 ; DIR_DOWN
	.db $00 $f3 $00 ; DIR_LEFT

@state1:
	call _itemUpdateDamageToApply		; $5f99
	jr nz,@collision		; $5f9c

	; No collision with an object?

	call objectApplySpeed		; $5f9e
	call objectCheckTileCollision_allowHoles		; $5fa1
	jr nc,@noCollision			; $5fa4

	call _itemCheckCanPassSolidTile		; $5fa6
	jr nz,@collision		; $5fa9

@noCollision:
	; Flip palette every 4 frames
	ld a,(wFrameCounter)		; $5fab
	and $03			; $5fae
	jr nz,+			; $5fb0
	ld h,d			; $5fb2
	ld l,Item.oamFlagsBackup		; $5fb3
	ld a,(hl)		; $5fb5
	xor $01			; $5fb6
	ldi (hl),a		; $5fb8
	ldi (hl),a		; $5fb9
+
	call objectCheckWithinScreenBoundary		; $5fba
	ret c			; $5fbd
	jp itemDelete		; $5fbe

@collision:
	ldbc INTERACID_CLINK, $81		; $5fc1
	call objectCreateInteraction		; $5fc4
	jp itemDelete		; $5fc7

;;
; Used for sword, cane of somaria, rod of seasons. Updates animation, deals with
; destroying tiles?
;
; @addr{5fca}
_updateSwingableItemAnimation:
	ld l,Item.animParameter		; $5fca
	cp $04			; $5fcc
	jr z,_label_07_227	; $5fce
	bit 6,(hl)		; $5fd0
	jr z,_label_07_227	; $5fd2

	res 6,(hl)		; $5fd4
	ld a,(hl)		; $5fd6
	and $1f			; $5fd7
	cp $10			; $5fd9
	jr nc,+			; $5fdb
	ld a,(w1Link.direction)		; $5fdd
	add a			; $5fe0
+
	and $07			; $5fe1
	push hl			; $5fe3
	call _tryBreakTileWithSword_calculateLevel		; $5fe4
	pop hl			; $5fe7

_label_07_227:
	ld c,$10		; $5fe8
	ld a,(hl)		; $5fea
	and $1f			; $5feb
	cp c			; $5fed
	jr nc,+			; $5fee

	srl a			; $5ff0
	ld c,a			; $5ff2
	ld a,(w1Link.direction)		; $5ff3
	add a			; $5ff6
	add a			; $5ff7
	add c			; $5ff8
	ld c,$00		; $5ff9
+
	ld hl,@data		; $5ffb
	rst_addAToHl			; $5ffe
	ld a,(hl)		; $5fff
	and $f0			; $6000
	swap a			; $6002
	add c			; $6004
	ld e,Item.var30		; $6005
	ld (de),a		; $6007

	ld a,(hl)		; $6008
	and $07			; $6009
	jp itemSetAnimation		; $600b


; For each byte:
;  Bits 4-7: value for Item.var30?
;  Bits 0-2: Animation index?
@data:
	.db $02 $41 $80 $c0 $10 $51 $92 $d2
	.db $26 $65 $a4 $e4 $30 $77 $b6 $f6

	.db $00 $11 $22 $33 $44 $55 $66 $77

;;
; Analagous to _updateSwingableItemAnimation, but specifically for biggoron's sword
;
; @addr{6026}
_updateBiggoronSwordAnimation:
	ld b,$00		; $6026
	ld l,Item.animParameter		; $6028
	bit 6,(hl)		; $602a
	jr z,+			; $602c
	res 6,(hl)		; $602e
	inc b			; $6030
+
	ld a,(hl)		; $6031
	and $0e			; $6032
	rrca			; $6034
	ld c,a			; $6035
	ld a,(w1Link.direction)		; $6036
	cp $01			; $6039
	jr nz,+			; $603b
	ld a,c			; $603d
	jr ++			; $603e
+
	inc a			; $6040
	add a			; $6041
	sub c			; $6042
++
	and $07			; $6043
	bit 0,b			; $6045
	jr z,++			; $6047

	push af			; $6049
	ld c,a			; $604a
	ld a,BREAKABLETILESOURCE_SWORD_L2		; $604b
	call _tryBreakTileWithSword		; $604d
	pop af			; $6050
++
	ld e,Item.var30		; $6051
	ld (de),a		; $6053
	jp itemSetAnimation		; $6054

;;
; ITEMID_MAGNET_GLOVES
;
; @addr{6057}
itemCode08Post:
	call _cpRelatedObject1ID		; $6057
	jp nz,itemDelete		; $605a

	ld hl,w1Link.yh		; $605d
	call objectTakePosition		; $6060
	ld a,(wFrameCounter)		; $6063
	rrca			; $6066
	rrca			; $6067
	ld a,(w1Link.direction)		; $6068
	adc a			; $606b
	ld e,Item.var30		; $606c
	ld (de),a		; $606e
	jp itemSetAnimation		; $606f

;;
; ITEMID_SLINGSHOT
;
; @addr{6072}
itemCode13Post:
	call _cpRelatedObject1ID		; $6072
	jp nz,itemDelete		; $6075

	ld hl,w1Link.yh		; $6078
	call objectTakePosition		; $607b
	ld a,(w1Link.direction)		; $607e
	ld e,Item.var30		; $6081
	ld (de),a		; $6083
	jp itemSetAnimation		; $6084

;;
; ITEMID_FOOLS_ORE
;
; @addr{6087}
itemCode1ePost:
	call _cpRelatedObject1ID		; $6087
	jp nz,itemDelete		; $608a

	ld l,Item.animParameter		; $608d
	ld a,(hl)		; $608f
	and $06			; $6090
	add a			; $6092
	ld b,a			; $6093
	ld a,(w1Link.direction)		; $6094
	add b			; $6097
	ld e,Item.var30		; $6098
	ld (de),a		; $609a
	ld hl,_swordArcData		; $609b
	jr _itemSetPositionInSwordArc		; $609e

;;
; ITEMID_PUNCH
;
; @addr{60a0}
itemCode00Post:
itemCode02Post:
	ld a,(w1Link.direction)		; $60a0
	add $18			; $60a3
	ld hl,_swordArcData		; $60a5
	jr _itemSetPositionInSwordArc		; $60a8

;;
; ITEMID_BIGGORON_SWORD
;
; @addr{60aa}
itemCode0cPost:
	call _cpRelatedObject1ID		; $60aa
	jp nz,itemDelete		; $60ad

	call _updateBiggoronSwordAnimation		; $60b0
	ld e,Item.var30		; $60b3
	ld a,(de)		; $60b5
	ld hl,_biggoronSwordArcData		; $60b6
	call _itemSetPositionInSwordArc		; $60b9
	jp _itemCalculateSwordDamage		; $60bc

;;
; ITEMID_CANE_OF_SOMARIA
; ITEMID_SWORD
; ITEMID_ROD_OF_SEASONS
;
; @addr{60bf}
itemCode04Post:
itemCode05Post:
itemCode07Post:
	call _cpRelatedObject1ID		; $60bf
	jp nz,itemDelete		; $60c2

	call _updateSwingableItemAnimation		; $60c5

	ld e,Item.var30		; $60c8
	ld a,(de)		; $60ca
	ld hl,_swordArcData		; $60cb
	call _itemSetPositionInSwordArc		; $60ce

	jp _itemCalculateSwordDamage		; $60d1

;;
; @param	a	Index for table 'hl'
; @param	hl	Usually points to _swordArcData
; @addr{60d4}
_itemSetPositionInSwordArc:
	add a			; $60d4
	rst_addDoubleIndex			; $60d5

;;
; Copy Link's position (accounting for raised floors, with Z position 2 higher than Link)
;
; @param	hl	Pointer to data for collision radii and position offsets
; @addr{60d6}
_itemInitializeFromLinkPosition:
	ld e,Item.collisionRadiusY		; $60d6
	ldi a,(hl)		; $60d8
	ld (de),a		; $60d9
	inc e			; $60da
	ldi a,(hl)		; $60db
	ld (de),a		; $60dc

	; Y
	ld a,(wLinkRaisedFloorOffset)		; $60dd
	ld b,a			; $60e0
	ld a,(w1Link.yh)		; $60e1
	add b			; $60e4
	add (hl)		; $60e5
	ld e,Item.yh		; $60e6
	ld (de),a		; $60e8

	; X
	inc hl			; $60e9
	ld e,Item.xh		; $60ea
	ld a,(w1Link.xh)		; $60ec
	add (hl)		; $60ef
	ld (de),a		; $60f0

	; Z
	ld a,(w1Link.zh)		; $60f1
	ld e,Item.zh		; $60f4
	sub $02			; $60f6
	ld (de),a		; $60f8
	ret			; $60f9


; Each row probably corresponds to part of a sword's arc? (Also used by punches.)
; b0/b1: collisionRadiusY/X
; b2/b3: Y/X offsets relative to Link
; @addr{60fa}
_swordArcData:
	.db $09 $06 $fe $10
	.db $06 $09 $f2 $00
	.db $09 $06 $00 $f1
	.db $06 $09 $f2 $00
	.db $07 $07 $f5 $0d
	.db $07 $07 $f5 $0d
	.db $07 $07 $11 $f3
	.db $07 $07 $f5 $f3
	.db $09 $06 $ef $fc
	.db $06 $09 $02 $13
	.db $09 $06 $15 $03
	.db $06 $09 $02 $ed
	.db $09 $06 $f6 $fc
	.db $04 $09 $02 $0c
	.db $09 $06 $10 $03
	.db $06 $09 $02 $f4
	.db $09 $09 $ef $fc
	.db $09 $09 $f2 $10
	.db $09 $09 $02 $13
	.db $09 $09 $12 $10
	.db $09 $09 $15 $03
	.db $09 $09 $11 $f3
	.db $09 $09 $02 $ed
	.db $09 $09 $f5 $f3
	.db $05 $05 $f4 $fd
	.db $05 $05 $00 $0c
	.db $05 $05 $0c $03
	.db $05 $05 $00 $f4

; @addr{616a}
_biggoronSwordArcData:
	.db $0b $0b $ef $fe
	.db $09 $0c $f2 $10
	.db $0b $0b $02 $13
	.db $0c $09 $12 $10
	.db $0b $0b $15 $01
	.db $09 $0c $11 $f3
	.db $0b $0b $02 $ed
	.db $0c $09 $f5 $f3


;;
; @addr{618a}
_tryBreakTileWithExpertsRing:
	ld a,(w1Link.direction)		; $618a
	add a			; $618d
	ld c,a			; $618e
	ld a,BREAKABLETILESOURCE_03		; $618f
	jr _tryBreakTileWithSword			; $6191

;;
; Same as below function, except this checks the sword's level to decide on the
; "breakableTileSource".
;
; @param	a	Direction (see below function)
; @addr{6193}
_tryBreakTileWithSword_calculateLevel:
	; Use BREAKABLETILESOURCE_SWORD_L1 or L2 depending on sword's level
	ld c,a			; $6193
	ld a,(wSwordLevel)		; $6194
	cp $01			; $6197
	jr z,_tryBreakTileWithSword		; $6199
	ld a,BREAKABLETILESOURCE_SWORD_L2		; $619b

;;
; Deals with sword slashing / spinning / poking against tiles, breaking them
;
; @param	a	See constants/breakableTileSources.s
; @param	c	Direction (0-7 are 45-degree increments, 8 is link's center)
; @addr{619d}
_tryBreakTileWithSword:
	; Check link is close enough to the ground
	ld e,a			; $619d
	ld a,(w1Link.zh)		; $619e
	dec a			; $61a1
	cp $f6			; $61a2
	ret c			; $61a4

	; Get Y/X relative to Link in bc
	ld a,c			; $61a5
	ld hl,@linkOffsets		; $61a6
	rst_addDoubleIndex			; $61a9
	ld a,(w1Link.yh)		; $61aa
	add (hl)		; $61ad
	ld b,a			; $61ae
	inc hl			; $61af
	ld a,(w1Link.xh)		; $61b0
	add (hl)		; $61b3
	ld c,a			; $61b4

	; Try to break the tile
	push bc			; $61b5
	ld a,e			; $61b6
	call tryToBreakTile		; $61b7

	; Copy tile position, then tile index
	ldh a,(<hFF93)	; $61ba
	ld ($ccb0),a		; $61bc
	ldh a,(<hFF92)	; $61bf
	ld ($ccaf),a		; $61c1
	pop bc			; $61c4

	; Return if the tile was broken
	ret c			; $61c5

	; Check for bombable wall clink sound
	ld hl,@clinkSoundTable		; $61c6
	call findByteInCollisionTable		; $61c9
	jr c,@bombableWallClink			; $61cc

	; Only continue if the sword is in a "poking" state
	ld a,(w1ParentItem2.subid)		; $61ce
	or a			; $61d1
	ret z			; $61d2

	; Check the second list of tiles to see if it produces no clink at all
	call findByteAtHl		; $61d3
	ret c			; $61d6

	; Produce a clink only if the tile is solid
	ldh a,(<hFF93)	; $61d7
	ld l,a			; $61d9
	ld h,>wRoomCollisions		; $61da
	ld a,(hl)		; $61dc
	cp $0f			; $61dd
	ret nz			; $61df
	ld e,$01		; $61e0
	jr @createClink			; $61e2

	; Play a different sound effect on bombable walls
@bombableWallClink:
	ld a,SND_CLINK2		; $61e4
	call playSound		; $61e6

	; Set bit 7 of subid to prevent 'clink' interaction from also playing a sound
	ld e,$80		; $61e9

@createClink:
	call getFreeInteractionSlot		; $61eb
	ret nz			; $61ee

	ld (hl),INTERACID_CLINK		; $61ef
	inc l			; $61f1
	ld (hl),e		; $61f2
	ld l,Interaction.yh		; $61f3
	ld (hl),b		; $61f5
	ld l,Interaction.xh		; $61f6
	ld (hl),c		; $61f8
	ret			; $61f9


@linkOffsets:
	.db $f2 $00 ; Up
	.db $f2 $0d ; Up-right
	.db $00 $0d ; Right
	.db $0d $0d ; Down-right
	.db $0d $00 ; Down
	.db $0d $f2 ; Down-left
	.db $00 $f2 ; Left
	.db $f2 $f2 ; Up-left
	.db $00 $00 ; Center


; 2 lists per entry:
; * The first is a list of tiles which produce an alternate "clinking" sound indicating
; they're bombable.
; * The second is a list of tiles which don't produce clinks at all.
;
; @addr{620c}
@clinkSoundTable:
	.dw @collisions0
	.dw @collisions1
	.dw @collisions2
	.dw @collisions3
	.dw @collisions4
	.dw @collisions5

@collisions0:
@collisions4:
	.db $c1 $c2 $c4 $d1 $cf
	.db $00

	.db $fd $fe $ff
	.db $00
	.db $00

@collisions1:
@collisions2:
@collisions5:
	.db $1f $30 $31 $32 $33 $38 $39 $3a $3b $68 $69
	.db $00

	.db $0a $0b
	.db $00

@collisions3:
	.db $12
	.db $00

	.db $00


;;
; Calculates the value for Item.damage, accounting for ring modifiers.
;
; @addr{6235}
_itemCalculateSwordDamage:
	ld e,Item.var3a		; $6235
	ld a,(de)		; $6237
	ld b,a			; $6238
	ld a,(w1ParentItem2.var3a)		; $6239
	or a			; $623c
	jr nz,@applyDamageModifier	; $623d

	ld hl,@swordDamageModifiers		; $623f
	ld a,(wActiveRing)		; $6242
	ld e,a			; $6245
@nextRing:
	ldi a,(hl)		; $6246
	or a			; $6247
	jr z,@noRingModifier	; $6248
	cp e			; $624a
	jr z,@foundRingModifier	; $624b
	inc hl			; $624d
	jr @nextRing		; $624e

@noRingModifier:
	ld a,e			; $6250
	cp RED_RING			; $6251
	jr z,@redRing		; $6253
	cp GREEN_RING			; $6255
	jr z,@greenRing		; $6257
	cp CURSED_RING			; $6259
	jr z,@cursedRing	; $625b

	ld a,b			; $625d
	jr @setDamage		; $625e

@redRing:
	ld a,b			; $6260
	jr @applyDamageModifier		; $6261

@greenRing:
	ld a,b			; $6263
	cpl			; $6264
	inc a			; $6265
	sra a			; $6266
	cpl			; $6268
	inc a			; $6269
	jr @applyDamageModifier		; $626a

@cursedRing:
	ld a,b			; $626c
	cpl			; $626d
	inc a			; $626e
	sra a			; $626f
	cpl			; $6271
	inc a			; $6272
	jr @setDamage		; $6273

@foundRingModifier:
	ld a,(hl)		; $6275

@applyDamageModifier:
	add b			; $6276

@setDamage:
	; Make sure it's not positive (don't want to heal enemies)
	bit 7,a			; $6277
	jr nz,+			; $6279
	ld a,$ff		; $627b
+
	ld e,Item.damage		; $627d
	ld (de),a		; $627f
	ret			; $6280


; Negative values give the sword more damage for that ring.
@swordDamageModifiers:
	.db POWER_RING_L1	$ff
	.db POWER_RING_L2	$fe
	.db POWER_RING_L3	$fd
	.db ARMOR_RING_L1	$01
	.db ARMOR_RING_L2	$01
	.db ARMOR_RING_L3	$01
	.db $00


;;
; Makes the given item mimic a tile. Used for switch hooking bushes and pots and stuff,
; possibly for other things too?
; @addr{628e}
_itemMimicBgTile:
	call getTileMappingData		; $628e
	push bc			; $6291
	ld h,d			; $6292

	; Set Item.oamFlagsBackup, Item.oamFlags
	ld l,Item.oamFlagsBackup		; $6293
	ld a,$0f		; $6295
	ldi (hl),a		; $6297
	ldi (hl),a		; $6298

	; Set Item.oamTileIndexBase
	ld (hl),c		; $6299

	; Compare the top-right tile to the top-left tile, and select the appropriate
	; animation depending on whether they reuse the same tile or not.
	; If they don't, it assumes that the graphics are adjacent to each other, due to
	; sprite limitations?
	ld a,($cec1)		; $629a
	sub c			; $629d
	jr z,+			; $629e
	ld a,$01		; $62a0
+
	call itemSetAnimation		; $62a2

	; Copy the BG palette which the tile uses to OBJ palette 7
	pop af			; $62a5
	and $07			; $62a6
	swap a			; $62a8
	rrca			; $62aa
	ld hl,w2AreaBgPalettes		; $62ab
	rst_addAToHl			; $62ae
	push de			; $62af
	ld a,:w2AreaSprPalettes		; $62b0
	ld ($ff00+R_SVBK),a	; $62b2
	ld de,w2AreaSprPalettes+7*8		; $62b4
	ld b,$08		; $62b7
	call copyMemory		; $62b9

	; Mark OBJ 7 as modified
	ld hl,hDirtySprPalettes	; $62bc
	set 7,(hl)		; $62bf

	xor a			; $62c1
	ld ($ff00+R_SVBK),a	; $62c2
	pop de			; $62c4
	ret			; $62c5

;;
; This is the object representation of a tile while being held / thrown?
;
; If it's not a tile (ie. it's dimitri), this is just an invisible item with collisions?
;
; ITEMID_BRACELET
; @addr{62c6}
itemCode16:
	ld e,Item.state		; $62c6
	ld a,(de)		; $62c8
	rst_jumpTable			; $62c9

	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3

@state0:
	call _itemLoadAttributesAndGraphics		; $62d2
	ld h,d			; $62d5
	ld l,Item.enabled		; $62d6
	set 1,(hl)		; $62d8

	; Check subid, which is the index of tile being lifted, or 0 if not lifting a tile
	ld l,Item.subid		; $62da
	ld a,(hl)		; $62dc
	or a			; $62dd
	jr z,@notTile		; $62de

	ld l,Item.state		; $62e0
	ld (hl),$02		; $62e2
	call _itemMimicBgTile		; $62e4
	jp objectSetVisiblec0		; $62e7


; State 1/2: being held
@state1:
@state2:
	ld h,d			; $62ea
	ld l,Item.state2		; $62eb
	ld a,(hl)		; $62ed
	or a			; $62ee
	ret z			; $62ef

	; Item thrown; enable collisions
	ld l,Item.collisionRadiusX		; $62f0
	ld a,$06		; $62f2
	ldd (hl),a		; $62f4
	ldd (hl),a		; $62f5

	; bit 7 of Item.collisionType
	dec l			; $62f6
	set 7,(hl)		; $62f7

	jr @throwItem		; $62f9


; When a bracelet object is created that doesn't come from a tile on the ground, it is
; created at the time it is thrown, instead of the time it is picked up. Also, it's
; invisible, since its only purpose is to provide collisions?
@notTile:
	call _braceletCheckDeleteSelfWhileThrowing		; $62fb

	; Check if relatedObj2 is an item or not?
	ld a,h			; $62fe
	cp >w1Companion			; $62ff
	jr z,@@copyCollisions			; $6301
	ld a,l			; $6303
	cp Item.start+$40			; $6304
	jr c,@throwItem	; $6306

; This will copy collision attributes of non-item objects. This should allow "non-allied"
; objects to damage enemies?
@@copyCollisions:
	; Copy angle (this -> relatedObj2)
	ld a,Object.angle		; $6308
	call objectGetRelatedObject2Var		; $630a
	ld e,Item.angle		; $630d
	ld a,(de)		; $630f
	ld (hl),a		; $6310

	; Copy collisionRadius (relatedObj2 -> this)
	ld a,l			; $6311
	add Object.collisionRadiusY-Object.angle			; $6312
	ld l,a			; $6314
	ld e,Item.collisionRadiusY		; $6315
	ldi a,(hl)		; $6317
	ld (de),a		; $6318
	inc e			; $6319
	ldi a,(hl)		; $631a
	ld (de),a		; $631b

	; Enable collisions (on this)
	ld h,d			; $631c
	ld l,Item.collisionType		; $631d
	set 7,(hl)		; $631f

@throwItem:
	call _itemBeginThrow		; $6321
	ld h,d			; $6324
	ld l,Item.state		; $6325
	ld (hl),$03		; $6327
	inc l			; $6329
	ld (hl),$00		; $632a


; State 3: being thrown
@state3:
	call _braceletCheckDeleteSelfWhileThrowing		; $632c
	call _itemUpdateThrowingLaterally		; $632f
	jr z,@@destroyWithAnimation	; $6332

	ld e,Item.var39		; $6334
	ld a,(de)		; $6336
	ld c,a			; $6337
	call _itemUpdateThrowingVertically		; $6338
	jr nc,@@noCollision	; $633b

	; If it's breakable, destroy it; if not, let it bounce
	call _braceletCheckBreakable		; $633d
	jr nz,@@destroyWithAnimation	; $6340
	call _itemBounce		; $6342
	jr c,@@release		; $6345

@@noCollision:
	; If this is not a breakable tile, copy this object's position to relatedObj2.
	ld e,Item.subid		; $6347
	ld a,(de)		; $6349
	or a			; $634a
	ret nz			; $634b
	ld a,Object.yh		; $634c
	call objectGetRelatedObject2Var		; $634e
	jp objectCopyPosition		; $6351

@@release:
	ld a,Object.state2		; $6354
	call objectGetRelatedObject2Var		; $6356
	ld (hl),$03		; $6359
	jp itemDelete		; $635b

@@destroyWithAnimation:
	call objectReplaceWithAnimationIfOnHazard		; $635e
	ret c			; $6361
	callab bank6.itemMakeInteractionForBreakableTile		; $6362
	jp itemDelete		; $636a

;;
; @param[out] zflag Set if Item.subid is zero
; @param[out] cflag Inverse of zflag?
; @addr{636d}
_braceletCheckBreakable:
	ld e,Item.subid		; $636d
	ld a,(de)		; $636f
	or a			; $6370
	ret z			; $6371
	scf			; $6372
	ret			; $6373

;;
; Called each frame an item's being thrown. Returns from caller if it decides to delete
; itself.
;
; @param[out]	hl	relatedObj2.state2 or this.state2
; @addr{6374}
_braceletCheckDeleteSelfWhileThrowing:
	ld e,Item.subid		; $6374
	ld a,(de)		; $6376
	or a			; $6377
	jr nz,@throwingTile		; $6378

	lda Item.enabled			; $637a
	call objectGetRelatedObject2Var		; $637b
	bit 0,(hl)		; $637e
	jr z,@deleteSelfAndRetFromCaller	; $6380

	; Delete self unless related object is on state 2, substate 0/1/2 (being held by
	; Link or just released)
	ld a,l			; $6382
	add Object.state-Object.enabled			; $6383
	ld l,a			; $6385
	ldi a,(hl)		; $6386
	cp $02			; $6387
	jr nz,@deleteSelfAndRetFromCaller	; $6389
	ld a,(hl)		; $638b
	cp $03			; $638c
	ret c			; $638e

@deleteSelfAndRetFromCaller:
	pop af			; $638f
	jp itemDelete		; $6390

@throwingTile:
	call objectCheckWithinRoomBoundary		; $6393
	jr nc,@deleteSelfAndRetFromCaller	; $6396
	ld h,d			; $6398
	ld l,Item.state2		; $6399
	ret			; $639b

;;
; Called every frame a bomb is being thrown. Also used by somaria block?
;
; @addr{639c}
_bombUpdateThrowingLaterally:
	; If it's landed in water, set speed to 0 (for sidescrolling areas)
	ld h,d			; $639c
	ld l,Item.var3b		; $639d
	bit 0,(hl)		; $639f
	jr z,+			; $63a1
	ld l,Item.speed		; $63a3
	ld (hl),$00		; $63a5
+
	; If this is the start of the throw, initialize speed variables
	ld l,Item.var37		; $63a7
	bit 0,(hl)		; $63a9
	call z,_itemBeginThrow		; $63ab

	; Check for collisions with walls, update position.
	jp _itemUpdateThrowingLaterally		; $63ae

;;
; Items call this once on the frame they're thrown
;
; @addr{63b1}
_itemBeginThrow:
	call _itemSetVar3cToFF		; $63b1

	; Move the item one pixel in Link's facing direction
	ld a,(w1Link.direction)		; $63b4
	ld hl,@throwOffsets		; $63b7
	rst_addAToHl			; $63ba
	ldi a,(hl)		; $63bb
	ld c,(hl)		; $63bc

	ld h,d			; $63bd
	ld l,Item.yh		; $63be
	add (hl)		; $63c0
	ldi (hl),a		; $63c1
	inc l			; $63c2
	ld a,(hl)		; $63c3
	add c			; $63c4
	ld (hl),a		; $63c5

	ld l,Item.enabled		; $63c6
	res 1,(hl)		; $63c8

	; Mark as thrown?
	ld l,Item.var37		; $63ca
	set 0,(hl)		; $63cc

	; Item.var38 contains "weight" information (how the object will be thrown)
	inc l			; $63ce
	ld a,(hl)		; $63cf
	and $f0			; $63d0
	swap a			; $63d2
	add a			; $63d4
	ld hl,_itemWeights		; $63d5
	rst_addDoubleIndex			; $63d8

	; Byte 0 from hl: value for Item.var39 (gravity)
	ldi a,(hl)		; $63d9
	ld e,Item.var39		; $63da
	ld (de),a		; $63dc

	; If angle is $ff (motionless), skip the rest.
	ld e,Item.angle		; $63dd
	ld a,(de)		; $63df
	rlca			; $63e0
	jr c,@clearItemSpeed	; $63e1

	; Byte 1: Value for Item.speedZ (8-bit, high byte is $ff)
	ld e,Item.speedZ		; $63e3
	ldi a,(hl)		; $63e5
	ld (de),a		; $63e6
	inc e			; $63e7
	ld a,$ff		; $63e8
	ld (de),a		; $63ea

	; Bytes 2,3: Throw speed with and without toss ring, respectively
	ld a,TOSS_RING		; $63eb
	call cpActiveRing		; $63ed
	jr nz,+			; $63f0
	inc hl			; $63f2
+
	ld e,Item.speed		; $63f3
	ldi a,(hl)		; $63f5
	ld (de),a		; $63f6
	ret			; $63f7

@clearItemSpeed:
	ld h,d			; $63f8
	ld l,Item.speed		; $63f9
	xor a			; $63fb
	ld (hl),a		; $63fc
	ld l,Item.speedZ		; $63fd
	ldi (hl),a		; $63ff
	ldi (hl),a		; $6400
	ret			; $6401

; Offsets to move the item when it's thrown.
; Each direction value reads 2 of these, one for Y and one for X.
@throwOffsets:
	.db $ff
	.db $00
	.db $01
	.db $00
	.db $ff

;;
; Checks whether a throwable item has collided with a wall; if not, this updates its
; position.
;
; Called by throwable items each frame. See also "_itemUpdateThrowingVertically".
;
; @param[out]	zflag	Set if the item should break.
; @addr{6407}
_itemUpdateThrowingLaterally:
	ld e,Item.var38		; $6407
	ld a,(de)		; $6409

	; Check whether the "weight" value for the item equals 3?
	cp $40			; $640a
	jr nc,+			; $640c
	cp $30			; $640e
	jr nc,@weight3		; $6410
+
	; Return if not moving
	ld e,Item.angle		; $6412
	ld a,(de)		; $6414
	cp $ff			; $6415
	jr z,@unsetZFlag	; $6417

	and $18			; $6419
	rrca			; $641b
	rrca			; $641c
	ld hl,_bombEdgeOffsets		; $641d
	rst_addAToHl			; $6420
	ldi a,(hl)		; $6421
	ld c,(hl)		; $6422

	; Load y position into b, jump if beyond room boundary.
	ld h,d			; $6423
	ld l,Item.yh		; $6424
	add (hl)		; $6426
	cp (LARGE_ROOM_HEIGHT*$10)			; $6427
	jr nc,@noCollision	; $6429

	ld b,a			; $642b
	ld l,Item.xh		; $642c
	ld a,c			; $642e
	add (hl)		; $642f
	ld c,a			; $6430

	call checkTileCollisionAt_allowHoles		; $6431
	jr nc,@noCollision	; $6434
	call _itemCheckCanPassSolidTileAt		; $6436
	jr z,@noCollision	; $6439
	jr @collision		; $643b

; This is probably a specific item with different dimensions than other throwable stuff
@weight3:
	ld h,d			; $643d
	ld l,Item.yh		; $643e
	ld b,(hl)		; $6440
	ld l,Item.xh		; $6441
	ld c,(hl)		; $6443

	ld e,Item.angle		; $6444
	ld a,(de)		; $6446
	and $18			; $6447
	ld hl,_data_649a		; $6449
	rst_addAToHl			; $644c

	; Loop 4 times, once for each corner of the object?
	ld e,$04		; $644d
--
	push bc			; $644f
	ldi a,(hl)		; $6450
	add b			; $6451
	ld b,a			; $6452
	ldi a,(hl)		; $6453
	add c			; $6454
	ld c,a			; $6455
	push hl			; $6456
	call checkTileCollisionAt_allowHoles		; $6457
	pop hl			; $645a
	pop bc			; $645b
	jr c,@collision	; $645c
	dec e			; $645e
	jr nz,--		; $645f
	jr @noCollision		; $6461

@collision:
	; Check if this is a breakable object (based on a tile that was picked up)?
	call _braceletCheckBreakable		; $6463
	jr nz,@setZFlag	; $6466

	; Clear angle, which will also set speed to 0
	ld e,Item.angle		; $6468
	ld a,$ff		; $646a
	ld (de),a		; $646c

@noCollision:
	ld a,(wAreaFlags)		; $646d
	and AREAFLAG_SIDESCROLL			; $6470
	jr z,+			; $6472

	; If in a sidescrolling area, don't apply speed if moving directly vertically?
	ld e,Item.angle		; $6474
	ld a,(de)		; $6476
	and $0f			; $6477
	jr z,@unsetZFlag	; $6479
+
	call objectApplySpeed		; $647b

@unsetZFlag:
	or d			; $647e
	ret			; $647f

@setZFlag:
	xor a			; $6480
	ret			; $6481

;;
; Called each time a particular item (ie a bomb) lands on a ground. This will cause it to
; bounce a few times before settling, reducing in speed with each bounce.
; @param[out] zflag Set if the item has reached a ground speed of zero.
; @param[out] cflag Set if the item has stopped bouncing.
; @addr{6482}
_itemBounce:
	ld a,SND_BOMB_LAND		; $6482
	call playSound		; $6484

	; Invert and reduce vertical speed
	call objectNegateAndHalveSpeedZ		; $6487
	ret c			; $648a

	; Reduce regular speed
	ld e,Item.speed		; $648b
	ld a,(de)		; $648d
	ld e,a			; $648e
	ld hl,_bounceSpeedReductionMapping		; $648f
	call lookupKey		; $6492
	ld e,Item.speed		; $6495
	ld (de),a		; $6497
	or a			; $6498
	ret			; $6499

; This seems to list the offsets of the 4 corners of a particular object, to be used for
; collision calculations.
; Somewhat similar to "_bombEdgeOffsets", except that is only used to check for collisions
; in the direction it's moving in, whereas this seems to cover the entire object.
_data_649a:
	.db $00 $00 $fa $fa $fa $00 $fa $05 ; DIR_UP
	.db $00 $00 $fa $05 $00 $05 $05 $05 ; DIR_RIGHT
	.db $00 $00 $05 $fb $05 $00 $05 $05 ; DIR_DOWN
	.db $00 $00 $fa $fa $00 $fa $06 $fa ; DIR_LEFT

; b0: Value to write to Item.var39 (gravity).
; b1: Low byte of Z speed to give the object (high byte will be $ff)
; b2: Throw speed without toss ring
; b3: Throw speed with toss ring
_itemWeights:
	.db $1c $10 SPEED_180 SPEED_280
	.db $20 $00 SPEED_080 SPEED_100
	.db $28 $20 SPEED_1a0 SPEED_280
	.db $20 $00 SPEED_080 SPEED_100
	.db $20 $e0 SPEED_140 SPEED_180
	.db $20 $00 SPEED_080 SPEED_100

; A series of key-value pairs where the key is a bouncing object's current speed, and the
; value is the object's new speed after one bounce.
; This returns roughly half the value of the key.
; @addr{64d2}
_bounceSpeedReductionMapping:
	.db SPEED_020 SPEED_000
	.db SPEED_040 SPEED_020
	.db SPEED_060 SPEED_020
	.db SPEED_080 SPEED_040
	.db SPEED_0a0 SPEED_040
	.db SPEED_0c0 SPEED_060
	.db SPEED_0e0 SPEED_060
	.db SPEED_100 SPEED_080
	.db SPEED_120 SPEED_080
	.db SPEED_140 SPEED_0a0
	.db SPEED_160 SPEED_0a0
	.db SPEED_180 SPEED_0c0
	.db SPEED_1a0 SPEED_0c0
	.db SPEED_1c0 SPEED_0e0
	.db SPEED_1e0 SPEED_0e0
	.db SPEED_200 SPEED_100
	.db SPEED_220 SPEED_100
	.db SPEED_240 SPEED_120
	.db SPEED_260 SPEED_120
	.db SPEED_280 SPEED_140
	.db SPEED_2a0 SPEED_140
	.db SPEED_2c0 SPEED_160
	.db SPEED_2e0 SPEED_160
	.db SPEED_300 SPEED_180
	.db $00 $00

;;
; ITEMID_DUST
; @addr{6504}
itemCode1a:
	ld e,Item.state2		; $6504
	ld a,(de)		; $6506
	rst_jumpTable			; $6507
	.dw @substate0
	.dw @substate1
	.dw @substate2

@substate0:
	call _itemLoadAttributesAndGraphics		; $650e
	call itemIncState2		; $6511
	ld hl,w1Link.yh		; $6514
	call objectTakePosition		; $6517
	xor a			; $651a
	call itemSetAnimation		; $651b
	jp objectSetVisible80		; $651e


; Substate 1: initial dust cloud above Link (lasts less than a second)
@substate1:
	call itemAnimate		; $6521
	call @setOamTileIndexBaseFromAnimParameter		; $6524

	; Mess with Item.oamFlags and Item.oamFlagsBackup
	ld a,(hl)		; $6527
	inc a			; $6528
	and $fb			; $6529
	xor $60			; $652b
	ldd (hl),a		; $652d
	ld (hl),a		; $652e

	; If bit 7 of animParameter was set, go to state 2
	bit 7,b			; $652f
	ret z			; $6531

	; [Item.oamFlags] = [Item.oamFlagsBackup] = $0b
	ld a,$0b		; $6532
	ldi (hl),a		; $6534
	ld (hl),a		; $6535

	ld l,Item.z		; $6536
	xor a			; $6538
	ldi (hl),a		; $6539
	ld (hl),a		; $653a

	call objectSetInvisible		; $653b
	jp itemIncState2		; $653e


; Substate 2: dust by Link's feet (spends the majority of time in this state)
@substate2:
	call checkPegasusSeedCounter		; $6541
	jp z,itemDelete		; $6544

	call @initializeNextDustCloud		; $6547

	; Each frame, alternate between two dust cloud positions, with corresponding
	; variables stored at var30-var33 and var34-var37.
	call itemDecCounter1		; $654a
	bit 0,(hl)		; $654d
	ld l,Item.var30		; $654f
	jr z,+			; $6551
	ld l,Item.var34		; $6553
+
	bit 7,(hl)		; $6555
	jp z,objectSetInvisible		; $6557

	; Inc var30/var34 (acts as a counter)
	inc (hl)		; $655a
	ld a,(hl)		; $655b
	cp $82			; $655c
	jr c,++			; $655e

	; Reset the counter, increment var31/var35 (which controls the animation)
	ld (hl),$80		; $6560
	inc l			; $6562
	inc (hl)		; $6563
	ld a,(hl)		; $6564
	dec l			; $6565
	cp $03			; $6566
	jr nc,@clearDustCloudVariables	; $6568
++
	; c = [var31/var35]+1
	inc l			; $656a
	ldi a,(hl)		; $656b
	inc a			; $656c
	ld c,a			; $656d

	; [Item.yh] = [var32/var36], [Item.xh] = [var33/var37]
	ldi a,(hl)		; $656e
	ld e,Item.yh		; $656f
	ld (de),a		; $6571
	ldi a,(hl)		; $6572
	ld e,Item.xh		; $6573
	ld (de),a		; $6575

	; Load the animation (corresponding to [var31/var35])
	ld a,c			; $6576
	call itemSetAnimation		; $6577
	call objectSetVisible80		; $657a

;;
; @param[out]	b	[Item.animParameter]
; @param[out]	hl	Item.oamFlags
; @addr{657d}
@setOamTileIndexBaseFromAnimParameter:
	ld h,d			; $657d
	ld l,Item.animParameter		; $657e
	ld a,(hl)		; $6580
	ld b,a			; $6581
	and $7f			; $6582
	ld l,Item.oamTileIndexBase		; $6584
	ldd (hl),a		; $6586
	ret			; $6587

;;
; Clears one of the "slots" for the dust cloud objects.
; @addr{6588}
@clearDustCloudVariables:
	xor a			; $6588
	ldi (hl),a		; $6589
	ldi (hl),a		; $658a
	ldi (hl),a		; $658b
	ldi (hl),a		; $658c
	jp objectSetInvisible		; $658d

;;
; Initializes a dust cloud if one of the two slots are blank
;
; @addr{6590}
@initializeNextDustCloud:
	ld h,d			; $6590
	ld l,Item.subid		; $6591
	bit 0,(hl)		; $6593
	ret z			; $6595

	ld (hl),$00		; $6596

	ld l,Item.var30		; $6598
	bit 7,(hl)		; $659a
	jr z,+			; $659c
	ld l,Item.var34		; $659e
	bit 7,(hl)		; $65a0
	ret nz			; $65a2
+
	ld a,$80		; $65a3
	ldi (hl),a		; $65a5
	xor a			; $65a6
	ldi (hl),a		; $65a7
	ld a,(w1Link.yh)		; $65a8
	add $05			; $65ab
	ldi (hl),a		; $65ad
	ld a,(w1Link.xh)		; $65ae
	ld (hl),a		; $65b1
	ret			; $65b2


	.include "build/data/itemAttributes.s"
	.include "data/itemAnimations.s"

.ends


 ; This section can't be superfree, since it must be in the same bank as section
 ; "Enemy_Part_Collisions".
 m_section_free "Bank_7_Data" namespace "bank7"

	.include "build/data/enemyActiveCollisions.s"
	.include "build/data/partActiveCollisions.s"
	.include "build/data/objectCollisionTable.s"

	; Garbage data follows (repeats of object collision table)

.ifdef BUILD_VANILLA
	; 0x72
	.db                     $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00

	; 0x73
	.db $03 $00 $00 $07 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
	.db $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00

	; 0x74
	.db $02 $17 $16 $16 $15 $15 $15 $16 $1b $15 $00 $00 $00 $00 $00 $00
	.db $00 $00 $00 $00 $00 $2d $1c $1b $00 $20 $20 $20 $20 $20 $20 $00

	; 0x75
	.db $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
	.db $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $2a $2a $2a $2a $2a $00

	; 0x76
	.db $02 $1f $1f $1f $1c $1c $1c $1c $1c $1c $00 $1c $00 $00 $00 $00
	.db $00 $00 $00 $00 $00 $00 $1c $1c $1c $20 $20 $20 $20 $20 $20 $00

	; 0x77
	.db $3b $00 $00 $1e $1c $1c $1c $1c $1c $00 $00 $00 $1c $00 $00 $00
	.db $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00

	; 0x78
	.db $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
	.db $00 $00 $00 $00 $00 $00 $00 $1c $00 $00 $00 $00 $00 $00 $00 $00

	; 0x79
	.db $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
	.db $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $31 $31 $31 $31 $31 $00

	; 0x7a
	.db $02 $00 $00 $1e $00 $1c $1c $00 $1c $00 $00 $00 $00 $00 $00 $00
	.db $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00

	; 0x7b
	.db $03 $00 $06 $06 $16 $16 $16 $16 $16 $16 $00 $00 $00 $00 $00 $00
	.db $00 $00 $00 $00 $00 $2d $00 $00 $00 $00 $00 $00 $00 $00 $00 $00

	; 0x7c
	.db $3d $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
	.db $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00

.endif

.ends


.BANK $08 SLOT 1
.ORG 0


 m_section_force Interactions_Bank8 NAMESPACE interactionBank1


; ==============================================================================
; INTERACID_GRASSDEBRIS (and other animations)
; ==============================================================================

interactionCode00:
interactionCode01:
interactionCode02:
interactionCode03:
interactionCode04:
interactionCode05:
interactionCode06:
interactionCode07:
interactionCode08:
interactionCode09:
interactionCode0a:
interactionCode0b:
interactionCode0c:
	ld e,Interaction.state		; $4000
	ld a,(de)		; $4002
	rst_jumpTable			; $4003
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $4008
	ld (de),a		; $400a
	call interactionInitGraphics		; $400b
	ld h,d			; $400e
	ld l,Interaction.speed	; $400f
	ld (hl),SPEED_80		; $4011

	ld l,Interaction.subid	; $4013
	bit 1,(hl)		; $4015
	call z,interactionSetAlwaysUpdateBit		; $4017

	call @doSpecializedInitialization		; $401a

	ld e,Interaction.id		; $401d
	ld a,(de)		; $401f
	ld hl,@soundAndPriorityTable	; $4020
	rst_addDoubleIndex			; $4023
	ld e,Interaction.subid	; $4024
	ld a,(de)		; $4026
	rlca			; $4027
	ldi a,(hl)		; $4028
	ld e,(hl)		; $4029
	call nc,playSound		; $402a
	ld a,e			; $402d
	rst_jumpTable			; $402e
	.dw objectSetVisible80
	.dw objectSetVisible81
	.dw objectSetVisible82
	.dw objectSetVisible83

@soundAndPriorityTable: ; $4037
	.db SND_CUTGRASS	$03	; 0x00
	.db SND_CUTGRASS	$03	; 0x01
	.db SND_NONE		$00	; 0x02
	.db SND_SPLASH		$03	; 0x03
	.db SND_SPLASH		$03	; 0x04
	.db SND_POOF		$00	; 0x05
	.db SND_BREAK_ROCK	$00	; 0x06
	.db SND_CLINK		$00	; 0x07
	.db SND_KILLENEMY	$00	; 0x08
	.db SND_NONE		$03	; 0x09
	.db SND_NONE		$03	; 0x0a
	.db SND_UNKNOWN5	$02	; 0x0b
	.db SND_BREAK_ROCK	$00	; 0x0c

@state1:
	ld h,d			; $4051
	ld l,Interaction.animParameter		; $4052
	bit 7,(hl)		; $4054
	jp nz,interactionDelete		; $4056

	ld l,Interaction.subid		; $4059
	bit 0,(hl)		; $405b
	jr z,++			; $405d

	ld a,(wFrameCounter)		; $405f
	xor d			; $4062
	rrca			; $4063
	ld l,Interaction.visible	; $4064
	set 7,(hl)		; $4066
	jr nc,++		; $4068

	res 7,(hl)		; $406a
++
	ld e,Interaction.id		; $406c
	ld a,(de)		; $406e
	cp INTERACID_SHOVELDEBRIS	; $406f
	jr nz,+			; $4071

	ld c,$60		; $4073
	call objectUpdateSpeedZ_paramC		; $4075
	call objectApplySpeed		; $4078
+
	jp interactionAnimate		; $407b

;;
; Does specific things for interactions 0 (underwater bush breaking) and $0a (shovel
; debris)
; @addr{407e}
@doSpecializedInitialization:
	ld e,Interaction.id		; $407e
	ld a,(de)		; $4080
	or a			; $4081
	jr z,@interac00		; $4082

	cp INTERACID_SHOVELDEBRIS	; $4084
	ret nz			; $4086

@interac0A:
	ld bc,-$240		; $4087
	call objectSetSpeedZ		; $408a
	ld e,Interaction.direction	; $408d
	ld a,(de)		; $408f
	jp interactionSetAnimation		; $4090

@interac00:
	ld a,(wAreaFlags)		; $4093
	and AREAFLAG_UNDERWATER	; $4096
	jr z,+			; $4098

	ld a,$0e		; $409a
	jr ++			; $409c
+
	ld a,(wGrassAnimationModifier)		; $409e
	and $03			; $40a1
	or $08			; $40a3
++
	ld e,Interaction.oamFlagsBackup		; $40a5
	ld (de),a		; $40a7
	inc e			; $40a8
	ld (de),a		; $40a9
	ret			; $40aa


; ==============================================================================
; INTERACID_FALLDOWNHOLE
; ==============================================================================
interactionCode0f:
	ld e,Interaction.state	; $40ab
	ld a,(de)		; $40ad
	rst_jumpTable			; $40ae
	.dw @interac0f_state0
	.dw @interac0f_state1
	.dw @interac0f_state2

@interac0f_state0:
	call interactionInitGraphics		; $40b5
	call interactionSetAlwaysUpdateBit		; $40b8
	call interactionIncState		; $40bb

	; [state] += [subid]
	ld e,Interaction.subid	; $40be
	ld a,(de)		; $40c0
	add (hl)		; $40c1
	ld (hl),a		; $40c2

	ld l,Interaction.speed	; $40c3
	ld (hl),SPEED_60		; $40c5
	dec a			; $40c7
	jr z,@fallDownHole			; $40c8

@dust:
	call interactionSetAnimation		; $40ca
	jp objectSetVisible80		; $40cd

@fallDownHole:
	inc e			; $40d0
	ld a,(de)		; $40d1
	rlca			; $40d2
	ld a,SND_FALLINHOLE	; $40d3
	call nc,playSound		; $40d5
	call @checkUpdateHoleEvent		; $40d8
	jp objectSetVisible83		; $40db


; State 1: "falling into hole" animation
@interac0f_state1:
	ld h,d			; $40de
	ld l,Interaction.animParameter		; $40df
	bit 7,(hl)		; $40e1
	jr nz,@delete		; $40e3

	; Calculate the direction this should move in to move towards the
	; center of the hole
	ld l,Interaction.yh		; $40e5
	ldi a,(hl)		; $40e7
	ldh (<hFF8F),a	; $40e8
	add $05			; $40ea
	and $f0			; $40ec
	add $08			; $40ee
	ld b,a			; $40f0
	inc l			; $40f1
	ld a,(hl)		; $40f2
	ldh (<hFF8E),a	; $40f3
	and $f0			; $40f5
	add $08			; $40f7
	ld c,a			; $40f9
	cp (hl)			; $40fa
	jr nz,+			; $40fb

	ldh a,(<hFF8F)	; $40fd
	cp b			; $40ff
	jr z,@animate			; $4100
+
	call objectGetRelativeAngleWithTempVars		; $4102
	ld e,Interaction.angle	; $4105
	ld (de),a		; $4107
	call objectApplySpeed		; $4108

@animate:
	jp interactionAnimate		; $410b


; State 2: pegasus seed dust?
@interac0f_state2:
	ld h,d			; $410e
	ld l,Interaction.visible	; $410f
	ld a,(hl)		; $4111
	xor $80			; $4112
	ld (hl),a		; $4114
	ld l,Interaction.animParameter		; $4115
	bit 7,(hl)		; $4117
	jr z,@animate			; $4119
@delete:
	jp interactionDelete		; $411b


;;
; Certain rooms have things happen when something falls into a hole; this writes something
; around $cfd8 to provide a signal?
; @addr{411e}
@checkUpdateHoleEvent:
	ld a,(wActiveRoom)		; $411e
	ld e,a			; $4121
	ld hl,@specialHoleRooms		; $4122
	call lookupKey		; $4125
	ret nc			; $4128

	ld b,a			; $4129
	ld a,(wActiveGroup)		; $412a
	cp b			; $412d
	ret nz			; $412e

	ld hl,wTmpcfc0.fallDownHoleEvent.cfd8		; $412f
	ld b,$04		; $4132
--
	ldi a,(hl)		; $4134
	cp $ff			; $4135
	jr nz,++		; $4137

	; This contains the ID of the object that fell in the hole?
	ld e,Interaction.counter2		; $4139
	ld a,(de)		; $413b
	ldd (hl),a		; $413c
	dec e			; $413d
	ld a,(de)		; $413e
	ld (hl),a		; $413f
	ret			; $4140
++
	inc l			; $4141
	dec b			; $4142
	jr nz,--		; $4143
	ret			; $4145

; @addr{4146}
@specialHoleRooms:
	.dw ROOM_5e8 ; Patch's room
	.dw ROOM_23e ; Toilet room
	.db $00

;;
; @addr{414b}
clearFallDownHoleEventBuffer:
	ld hl,wTmpcfc0.fallDownHoleEvent.cfd8		; $414b
	ld b,_sizeof_wTmpcfc0.fallDownHoleEvent.cfd8		; $414e
	ld a,$ff		; $4150
	jp fillMemory		; $4152


; ==============================================================================
; INTERACID_FARORE
; ==============================================================================
interactionCode10:
	ld e,Interaction.state		; $4155
	ld a,(de)		; $4157
	rst_jumpTable			; $4158
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $415d
	ld (de),a		; $415f

	call interactionInitGraphics		; $4160

	ld a,>TX_5500		; $4163
	call interactionSetHighTextIndex		; $4165

	ld hl,faroreScript		; $4168
	call interactionSetScript		; $416b

	ld a,GLOBALFLAG_SECRET_CHEST_WAITING		; $416e
	call unsetGlobalFlag		; $4170

	ld a,TEXTBOXFLAG_DONTCHECKPOSITION		; $4173
	ld (wTextboxFlags),a		; $4175
	ld a,$02		; $4178
	ld (wTextboxPosition),a		; $417a

	jp objectSetVisible82		; $417d

@state1:
	ld bc,$1406		; $4180
	call objectSetCollideRadii		; $4183
	call interactionRunScript		; $4186
	jp interactionAnimate		; $4189


; ==============================================================================
; INTERACID_FARORE_MAKECHEST
; ==============================================================================
interactionCode11:
	ld e,Interaction.subid	; $418c
	ld a,(de)		; $418e
	and $0f			; $418f
	rst_jumpTable			; $4191
	.dw _interac11_subid00
	.dw _interac11_subid01


; Subid 0 is the "parent" which controls the cutscene and the "children" (subid 1).
; The parent uses 2 variables to control the children:
;   * [$cfd8] is the distance away from the center of the circle the sparkles should be.
;   * [$cfd9] is set to 1 when the sparkles should start moving off-screen.
_interac11_subid00:
	ld e,Interaction.state	; $4196
	ld a,(de)		; $4198
	rst_jumpTable			; $4199
	.dw @interac11_00_state0
	.dw @interac11_00_state1
	.dw @interac11_00_state2
	.dw @interac11_00_state3
	.dw @interac11_00_state4
	.dw @interac11_00_state5
	.dw @interac11_00_state678
	.dw @interac11_00_state678
	.dw @interac11_00_state678
	.dw @interac11_00_state9
	.dw @interac11_00_stateA

@interac11_00_state0:
	ld a,$30		; $41b0
	ld ($cfd8),a		; $41b2
	xor a			; $41b5
	ld ($cfd9),a		; $41b6
	call setCameraFocusedObject		; $41b9
	ld e,Interaction.counter1		; $41bc
	ld a,$5a		; $41be
	ld (de),a		; $41c0
	call darkenRoomLightly		; $41c1
	jp interactionIncState		; $41c4

@interac11_00_state1:
	call interactionDecCounter1		; $41c7
	ret nz			; $41ca
	ld (hl),$30		; $41cb

	; Create 8 "sparkles".
	ld hl,objectData.faroreSparkleObjectData		; $41cd
	call parseGivenObjectData		; $41d0

	jp interactionIncState		; $41d3

@interac11_00_state2:
	call interactionDecCounter1		; $41d6
	ret nz			; $41d9
	ld (hl),$1e		; $41da
	jp interactionIncState		; $41dc

@interac11_00_state3:
	call interactionDecCounter1		; $41df
	ret nz			; $41e2
	ld (hl),$50		; $41e3
	jp interactionIncState		; $41e5

@interac11_00_state4:
	ld a,(wFrameCounter)		; $41e8
	rrca			; $41eb
	jr c,+			; $41ec
	ld hl,$cfd8		; $41ee
	dec (hl)		; $41f1
+
	call interactionDecCounter1		; $41f2
	ret nz			; $41f5
	ld (hl),$28		; $41f6
	jp interactionIncState		; $41f8

@interac11_00_state5:
	call interactionDecCounter1		; $41fb
	ret nz			; $41fe
	ld (hl),$08		; $41ff
	ld a,$01		; $4201
	ld ($cfd9),a		; $4203

	; Create a large, blue-and-red sparkle, and set its "related object" to this.
	ldbc INTERACID_SPARKLE, $0c		; $4206
	call objectCreateInteraction		; $4209
	ld l,Interaction.relatedObj1	; $420c
	ld (hl),Interaction.start		; $420e
	inc l			; $4210
	ld (hl),d		; $4211

	call objectCreatePuff		; $4212
	ld a,TILEINDEX_CHEST	; $4215
	ld c,$75		; $4217
	call setTile		; $4219
	jp interactionIncState		; $421c

@interac11_00_state678:
	call interactionDecCounter1		; $421f
	ret nz			; $4222
	ld (hl),$10		; $4223
	call fadeinFromWhite		; $4225

@playFadeoutSound:
	ld a,SND_FADEOUT	; $4228
	call playSound		; $422a
	jp interactionIncState		; $422d

@interac11_00_state9:
	call interactionDecCounter1		; $4230
	ret nz			; $4233
	ld a,$04		; $4234
	call fadeinFromWhiteWithDelay		; $4236
	jr @playFadeoutSound	; $4239

@interac11_00_stateA:
	ld a,(wPaletteThread_mode)		; $423b
	or a			; $423e
	ret nz			; $423f
	ld a,$01		; $4240
	ld ($cfc0),a		; $4242
	xor a			; $4245
	ld (wPaletteThread_parameter),a		; $4246
	call setCameraFocusedObjectToLink		; $4249
	jp interactionDelete		; $424c


; Subid 1 is a "sparkle" which is controlled by the parent, subid 0.
_interac11_subid01:
	ld e,Interaction.state	; $424f
	ld a,(de)		; $4251
	rst_jumpTable			; $4252
	.dw @interac11_01_state0
	.dw @interac11_01_state1
	.dw @interac11_01_state2
	.dw @interac11_01_state3

@interac11_01_state0:
	; Determine angle based on upper nibble of subid
	ld e,Interaction.subid		; $425b
	ld a,(de)		; $425d
	swap a			; $425e
	and $0f			; $4260
	ld hl,@initialAngles	; $4262
	rst_addAToHl			; $4265
	ld a,(hl)		; $4266
	ld e,Interaction.angle		; $4267
	ld (de),a		; $4269

	ld e,Interaction.speed		; $426a
	ld a,SPEED_100		; $426c
	ld (de),a		; $426e
	ld e,Interaction.counter1		; $426f
	ld a,$30		; $4271
	ld (de),a		; $4273

	call interactionInitGraphics		; $4274
	call objectSetVisible80		; $4277
	jp interactionIncState		; $427a

@initialAngles:
	.db $02 $06 $0a $0e $12 $16 $1a $1e


; Sparkles moving away from center, not rotating
@interac11_01_state1:
	call objectApplySpeed		; $4285
	call interactionAnimate		; $4288
	call interactionDecCounter1		; $428b
	ret nz			; $428e
	jp interactionIncState		; $428f

; Sparkles rotating around center
@interac11_01_state2:
	call @interac11_updateSparkle		; $4292

	; Wait for signal from parent to start flying away
	ld a,($cfd9)		; $4295
	or a			; $4298
	ret z			; $4299

	ld e,Interaction.speed		; $429a
	ld a,SPEED_200		; $429c
	ld (de),a		; $429e
	jp interactionIncState		; $429f

; Sparkles moving away until off-screen
@interac11_01_state3:
	call objectApplySpeed		; $42a2
	call interactionAnimate		; $42a5
	call objectCheckWithinScreenBoundary		; $42a8
	ret c			; $42ab
	jp interactionDelete		; $42ac

@interac11_updateSparkle:
	ld a,(wFrameCounter)		; $42af
	rrca			; $42b2
	jr c,++			; $42b3

	ld h,d			; $42b5
	ld l,Interaction.angle	; $42b6
	inc (hl)		; $42b8
	ld a,(hl)		; $42b9
	and $1f			; $42ba
	ld (hl),a		; $42bc
	ld a,SND_CIRCLING		; $42bd
	call z,playSound		; $42bf
++
	ld e,Interaction.angle		; $42c2
	ld bc,$7858		; $42c4
	ld a,($cfd8)		; $42c7
	call objectSetPositionInCircleArc		; $42ca
	jp interactionAnimate		; $42cd


; ==============================================================================
; INTERACID_DUNGEON_STUFF
; ==============================================================================
interactionCode12:
	ld e,Interaction.subid		; $42d0
	ld a,(de)		; $42d2
	rst_jumpTable			; $42d3
	.dw @subid00
	.dw @subid01
	.dw @subid02
	.dw @subid03
	.dw @subid04


; Show text upon entering a dungeon
@subid00:
	call checkInteractionState		; $42de
	jr nz,@initialized	; $42e1

	; Delete self Link is not currently walking in from a whiteout transition
	ld a,(wScrollMode)		; $42e3
	and SCROLLMODE_02		; $42e6
	jp z,interactionDelete		; $42e8

	; Delete self if Link entered from the wrong side of the room
	ld a,(w1Link.yh)		; $42eb
	cp $78			; $42ee
	jp c,interactionDelete		; $42f0

	call interactionIncState		; $42f3
	ld a,$08		; $42f6
	call objectSetCollideRadius		; $42f8
	call initializeDungeonStuff		; $42fb
	ld a,(wDungeonIndex)		; $42fe
	ld hl,@initialSpinnerValues		; $4301
	rst_addAToHl			; $4304
	ld a,(hl)		; $4305
	ld (wSpinnerState),a		; $4306

@initialized:
	call objectCheckCollidedWithLink_notDead		; $4309
	ret nc			; $430c

	ld a,(wDungeonIndex)		; $430d
	ld hl,@dungeonTextIndices	; $4310
	rst_addAToHl			; $4313
	ld c,(hl)		; $4314
	ld b,>TX_0200		; $4315
	call showText		; $4317
	call setDeathRespawnPoint		; $431a
	jp interactionDelete		; $431d


; Text shown on entering a dungeon. One byte per dungeon.
@dungeonTextIndices:
	.ifdef ROM_AGES
		.db <TX_0200 <TX_0201 <TX_0202 <TX_0203 <TX_0204 <TX_0205 <TX_0206 <TX_0207
		.db <TX_0208 <TX_0209 <TX_020a <TX_020b <TX_020c <TX_020d <TX_020e <TX_020f

	.else; ROM_SEASONS

		.db <TX_0200 <TX_0201 <TX_0202 <TX_0203 <TX_0204 <TX_0205 <TX_0206 <TX_0207
		.db <TX_0208 <TX_0209 <TX_020a <TX_020b
	.endif


; Initial values for wSpinnerState. A set bit means the corresponding spinner starts red.
; One byte per dungeon.
@initialSpinnerValues:
	.db $00 $00 $00 $00 $00 $00 $02 $00
	.db $01 $00 $00 $00 $01 $00 $00 $00


; A small key falls when [wNumEnemies]==0.
@subid01:
	call returnIfScrollMode01Unset		; $4340
	ld e,Interaction.state	; $4343
	ld a,(de)		; $4345
	rst_jumpTable			; $4346
	.dw @@substate0
	.dw @runScript

@@substate0:
	ld a,$01		; $434b
	ld (de),a		; $434d
	ld hl,dropSmallKeyWhenNoEnemiesScript		; $434e
	call interactionSetScript		; $4351

@runScript:
	call interactionRunScript		; $4354
	jp c,interactionDelete		; $4357
	ret			; $435a


; Create a chest when all enemies are killed
@subid02:
	ld e,Interaction.state		; $435b
	ld a,(de)		; $435d
	rst_jumpTable			; $435e
	.dw @@substate0
	.dw @runScript
	.dw @@substate2

@@substate0:
	ld a,$01		; $4365
	ld (de),a		; $4367
	ld hl,createChestWhenNoEnemiesScript		; $4368
	call interactionSetScript		; $436b
	jr @runScript		; $436e

@@substate2:
	; In substate 2, the chest has appeared; so it calls
	; "objectPreventLinkFromPassing" to push Link away?
	call objectPreventLinkFromPassing		; $4370
	jr @runScript		; $4373


; Set bit 7 of room flags when all enemies are killed
@subid03:
	call checkInteractionState		; $4375
	jr nz,@runScript	; $4378

	ld a,$01		; $437a
	ld (de),a		; $437c
	ld hl,setRoomFlagBit7WhenNoEnemiesScript		; $437d
	call interactionSetScript		; $4380
	jr @runScript		; $4383


; Create a staircase when all enemies are killed
@subid04:
	call returnIfScrollMode01Unset		; $4385

	call getThisRoomFlags		; $4388
	bit ROOMFLAG_BIT_KEYBLOCK,a			; $438b
	jp nz,interactionDelete		; $438d

	ld a,(wNumEnemies)		; $4390
	or a			; $4393
	ret nz			; $4394

	ld a,SND_SOLVEPUZZLE		; $4395
	call playSound		; $4397

	call getThisRoomFlags		; $439a
	set ROOMFLAG_BIT_KEYBLOCK,(hl)		; $439d

	; Search for all tiles with indices between $40 and $43, inclusive, and replace
	; them with staircases.
	ld bc, wRoomLayout + LARGE_ROOM_HEIGHT*16 - 1
--
	ld a,(bc)		; $43a2
	sub $40			; $43a3
	cp $04			; $43a5
	call c,@createStaircaseTile		; $43a7
	dec c			; $43aa
	jr nz,--		; $43ab
	ret			; $43ad

@createStaircaseTile:
	push bc			; $43ae
	push hl			; $43af
	ld hl,@replacementTiles		; $43b0
	rst_addAToHl			; $43b3
	ld a,(hl)		; $43b4
	call setTile		; $43b5
	call @createPuff		; $43b8
	pop hl			; $43bb
	pop bc			; $43bc
	ret			; $43bd

@replacementTiles:
	.db $46 $47 $44 $45

@createPuff:
	call getFreeInteractionSlot		; $43c2
	ret nz			; $43c5
	ld (hl),INTERACID_PUFF		; $43c6
	ld l,Interaction.yh		; $43c8
	jp setShortPosition_paramC		; $43ca


; ==============================================================================
; INTERACID_PUSHBLOCK_TRIGGER
; ==============================================================================
interactionCode13:
	call interactionDeleteAndRetIfEnabled02		; $43cd
	call returnIfScrollMode01Unset		; $43d0
	ld e,Interaction.state		; $43d3
	ld a,(de)		; $43d5
	rst_jumpTable			; $43d6
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3

@state0:
	ld h,d			; $43df
	ld l,Interaction.state		; $43e0
	ld (hl),$01		; $43e2

	call objectGetShortPosition		; $43e4
	ld l,Interaction.var18		; $43e7
	ld (hl),a		; $43e9

	; Replace the block at this position with TILEINDEX_PUSHABLE_BLOCK; save the old
	; value for the tile there into var19.
	ld c,a			; $43ea
	ld b,>wRoomLayout		; $43eb
	ld a,(bc)		; $43ed
	inc l			; $43ee
	ld (hl),a ; [var19] = tile at position
	ld a,TILEINDEX_PUSHABLE_BLOCK		; $43f0
	ld (bc),a		; $43f2

	ld hl,wNumEnemies		; $43f3
	inc (hl)		; $43f6
	ret			; $43f7

; Waiting for wNumEnemies to equal subid
@state1:
	ld a,(wNumEnemies)		; $43f8
	ld b,a			; $43fb
	ld e,Interaction.subid		; $43fc
	ld a,(de)		; $43fe
	cp b			; $43ff
	ret c			; $4400

	ld e,Interaction.state		; $4401
	ld a,$02		; $4403
	ld (de),a		; $4405

	ld e,Interaction.var18		; $4406
	ld a,(de)		; $4408
	ld c,a			; $4409
	inc e			; $440a
	ld a,(de)		; $440b
	ld b,>wRoomLayout		; $440c
	ld (bc),a		; $440e
	ret			; $440f

; Waiting for block to be pushed
@state2:
	ld e,Interaction.var18		; $4410
	ld a,(de)		; $4412
	ld l,a			; $4413
	inc e			; $4414
	ld a,(de)		; $4415
	ld h,>wRoomLayout		; $4416
	cp (hl)			; $4418
	ret z			; $4419

; Tile index changed; that must mean the block was pushed.

	ld e,Interaction.state		; $441a
	ld a,$03		; $441c
	ld (de),a		; $441e
	ld e,Interaction.counter1		; $441f
	ld a,$1e		; $4421
	ld (de),a		; $4423
	ret			; $4424

@state3:
	call interactionDecCounter1		; $4425
	ret nz			; $4428
	xor a			; $4429
	ld (wNumEnemies),a		; $442a
	jp interactionDelete		; $442d


; ==============================================================================
; INTERACID_PUSHBLOCK: a block in the process of being pushed.
; ==============================================================================
interactionCode14:
	ld e,Interaction.state		; $4430
	ld a,(de)		; $4432
	rst_jumpTable			; $4433
	.dw @state0
	.dw @state1

; State 0: block just pushed.
@state0:
	ld a,$01		; $4438
	ld (de),a		; $443a
	call interactionInitGraphics		; $443b

	; var30 is the position of the block being pushed.
	ld e,Interaction.var30		; $443e
	ld a,(de)		; $4440
	ld c,a			; $4441
	ld b,>wRoomLayout		; $4442
	ld a,(bc)		; $4444

	; Set var31 to be the tile index to imitate.
	ld e,Interaction.var31		; $4445
	ld (de),a		; $4447
	call objectMimicBgTile		; $4448

	call @checkRotatingCubePermitsPushing		; $444b
	jp c,interactionDelete		; $444e

	ld a,$06		; $4451
	call objectSetCollideRadius		; $4453
	call @loadPushableTileProperties		; $4456

	; If bit 2 of var34 is set, there's only a half-tile; animation 1 will flip it.
	; (Pots are like this). Otherwise, for tiles that aren't symmetrical, it will use
	; two consecutive tiles
	ld h,d			; $4459
	ld l,Interaction.var34		; $445a
	bit 2,(hl)		; $445c
	ld a,$01		; $445e
	call nz,interactionSetAnimation		; $4460

	; Determine speed to push with (L-2 bracelet pushes faster)
	ld h,d			; $4463
	ldbc SPEED_80, $20		; $4464
	ld a,(wBraceletLevel)		; $4467
	cp $02			; $446a
	jr nz,+			; $446c
	ld l,Interaction.var34		; $446e
	bit 5,(hl)		; $4470
	jr nz,+			; $4472
	ldbc SPEED_c0, $15		; $4474
+
	ld l,Interaction.speed		; $4477
	ld (hl),b		; $4479
	ld l,Interaction.counter1		; $447a
	ld (hl),c		; $447c

	ld l,Interaction.angle		; $447d
	ld a,(hl)		; $447f
	or $80			; $4480
	ld ($cca6),a		; $4482

	call @replaceTileUnderneathBlock		; $4485
	call objectSetVisible82		; $4488

	ld a,SND_MOVEBLOCK		; $448b
	call playSound		; $448d

@state1:
	call @updateZPositionForButton		; $4490
	call objectApplySpeed		; $4493
	call objectPreventLinkFromPassing		; $4496

	call interactionDecCounter1		; $4499
	ret nz			; $449c

; Finished moving; decide what to do next

	call objectReplaceWithAnimationIfOnHazard		; $449d
	jp c,interactionDelete		; $44a0

	; Update var30 with the new position.
	call objectGetShortPosition		; $44a3
	ld e,Interaction.var30		; $44a6
	ld (de),a		; $44a8

	; If the tile to place at the destination position is defined, place it.
	ld e,Interaction.var33		; $44a9
	ld a,(de)		; $44ab
	or a			; $44ac
	jr z,++			; $44ad
	ld b,a			; $44af
	ld e,Interaction.var30		; $44b0
	ld a,(de)		; $44b2
	ld c,a			; $44b3
	ld a,b			; $44b4
	call setTile		; $44b5
++
	; Check whether to play the sound
	ld e,Interaction.var34		; $44b8
	ld a,(de)		; $44ba
	rlca			; $44bb
	jr nc,++		; $44bc
	xor a			; $44be
	ld (wDisabledObjects),a		; $44bf
	ld a,SND_SOLVEPUZZLE		; $44c2
	call playSound		; $44c4
++
	jp interactionDelete		; $44c7

;;
; If this object is on top of an unpressed button, this raises the z position by 2 pixels.
; @addr{44ca}
@updateZPositionForButton:
	ld a,(wAreaFlags)		; $44ca
	and (AREAFLAG_10 | AREAFLAG_DUNGEON)			; $44cd
	ret z			; $44cf
	call objectGetShortPosition		; $44d0
	ld c,a			; $44d3
	ld b,>wRoomLayout		; $44d4
	ld a,(bc)		; $44d6
	cp TILEINDEX_BUTTON			; $44d7
	ld a,-2			; $44d9
	jr z,+			; $44db
	xor a			; $44dd
+
	ld e,Interaction.zh		; $44de
	ld (de),a		; $44e0
	ret			; $44e1

;;
; Replaces the tile underneath the block with whatever ground tile it should be. This
; first checks w3RoomLayoutBuffer for what the tile there should be. If that tile is
; non-solid, it uses that; otherwise, it uses [var32] as the new tile index.
;
; @param	c	Position
; @addr{44ec}
@replaceTileUnderneathBlock:
	ld e,Interaction.var30		; $44e2
	ld a,(de)		; $44e4
	ld c,a			; $44e5
	call getTileIndexFromRoomLayoutBuffer_paramC		; $44e6
	jp nc,setTile		; $44e9

	ld e,Interaction.var32		; $44ec
	ld a,(de)		; $44ee
	jp setTile		; $44ef

;;
; This appears to check whether pushing blocks $2c-$2e (colored blocks) is permitted,
; based on whether a rotating cube is present, and whether the correct color flames for
; the cube are lit.
;
; @param[out]	cflag	If set, this interaction will delete itself?
; @addr{44f2}
@checkRotatingCubePermitsPushing:
	ld a,(wRotatingCubePos)		; $44f2
	or a			; $44f5
	ret z			; $44f6
	ld a,(wRotatingCubeColor)		; $44f7
	bit 7,a			; $44fa
	jr z,++			; $44fc
	and $7f			; $44fe
	ld b,a			; $4500
	ld e,Interaction.var31		; $4501
	ld a,(de)		; $4503
	sub TILEINDEX_RED_PUSHABLE_BLOCK			; $4504
	cp b			; $4506
	ret z			; $4507
++
	scf			; $4508
	ret			; $4509

;;
; Loads var31-var34 with some variables relating to pushable blocks (see below).
; @addr{450a}
@loadPushableTileProperties:
	ld a,(wActiveCollisions)		; $450a
	ld hl,_pushableTilePropertiesTable		; $450d
	rst_addAToHl			; $4510
	ld a,(hl)		; $4511
	rst_addAToHl			; $4512
	ld e,Interaction.var31		; $4513
	ld a,(de)		; $4515
	ld b,a			; $4516
--
	ldi a,(hl)		; $4517
	or a			; $4518
	ret z			; $4519
	cp b			; $451a
	jr z,@match		; $451b
	inc hl			; $451d
	inc hl			; $451e
	inc hl			; $451f
	jr --			; $4520

@match:
	; Write data to var31-var34.
	ld (de),a		; $4522
	ldi a,(hl)		; $4523
	inc e			; $4524
	ld (de),a		; $4525
	ldi a,(hl)		; $4526
	inc e			; $4527
	ld (de),a		; $4528
	ldi a,(hl)		; $4529
	inc e			; $452a
	ld (de),a		; $452b
	ret			; $452c


; @addr{452d}
_pushableTilePropertiesTable:
	.db @collisions0-CADDR
	.db @collisions1-CADDR
	.db @collisions2-CADDR
	.db @collisions3-CADDR
	.db @collisions4-CADDR
	.db @collisions5-CADDR

; Data format:
;   b0 (var31): tile index
;   b1 (var32): the tile underneath it after being pushed
;   b2 (var33): the tile it becomes after being pushed (ie. a pushable block may become
;               unpushable)
;   b3 (var34): bit 2: if set, the tile is symmetrical, and flips the left half of the
;                      tile to get the right half.
;               bit 5: if set, it's "heavy" and doesn't get pushed more quickly with L2
;                      bracelet?
;               bit 7: play secret discovery sound after moving, and set
;               	"wDisabledObjects" to 0 (it would have been set to 1 previously
;               	from the "interactableTilesTable".

@collisions0:
	.db $d3 $3a $02 $01
	.db $d8 $3a $02 $05
	.db $d9 $dc $02 $85
	.db $02 $3a $02 $05

@collisions4:
@collisions5:
	.db $00

@collisions1:
@collisions2:
	.db $18 $a0 $1d $01
	.db $19 $a0 $1d $01
	.db $1a $a0 $1d $01
	.db $1b $a0 $1d $01
	.db $1c $a0 $1d $01
	.db $2a $a0 $2a $01
	.db $2c $a0 $2c $01
	.db $2d $a0 $2d $01
	.db $2e $a0 $2e $01
	.db $10 $a0 $10 $01
	.db $11 $a0 $10 $01
	.db $12 $a0 $10 $01
	.db $13 $0d $10 $01
	.db $25 $a0 $25 $01
	.db $07 $a0 $06 $01

@collisions3:
	.db $00


; ==============================================================================
; INTERACID_MINECART
; ==============================================================================
interactionCode16:
	ld e,Interaction.state		; $4581
	ld a,(de)		; $4583
	rst_jumpTable			; $4584
	.dw @state0
	.dw @state1
	.dw @state2
	.dw interactionDelete

@state0:
	ld a,$01		; $458d
	ld (de),a		; $458f
	call interactionInitGraphics		; $4590
	ld a,$06		; $4593
	call objectSetCollideRadius		; $4595
	ld l,Interaction.counter1		; $4598
	ld (hl),$04		; $459a

	; Check for position relative to platform, set direction based on that
	ld a,TILEINDEX_MINECART_PLATFORM		; $459c
	call objectGetRelativePositionOfTile		; $459e
	ld h,d			; $45a1
	ld l,Interaction.direction		; $45a2
	xor $02			; $45a4
	ldi (hl),a		; $45a6

	; Set Interaction.angle
	swap a			; $45a7
	rrca			; $45a9
	ldd (hl),a		; $45aa

	; Set animation based on facing direction
	ld a,(hl)		; $45ab
	and $01			; $45ac
	call interactionSetAnimation		; $45ae

	; Save the minecart in a "static object" slot so the game remembers where it is
	call objectDeleteRelatedObj1AsStaticObject		; $45b1
	call findFreeStaticObjectSlot		; $45b4
	ld a,STATICOBJTYPE_INTERACTION		; $45b7
	call z,objectSaveAsStaticObject		; $45b9

@state1:
	call objectSetPriorityRelativeToLink		; $45bc
	ld a,(wLinkInAir)		; $45bf
	add a			; $45c2
	jr c,+			; $45c3

	; Check for collision, also prevent link from walking through
	call objectPreventLinkFromPassing		; $45c5
	ret nc			; $45c8
+
	ld a,(w1Link.zh)		; $45c9
	or a			; $45cc
	jr nz,@resetCounter	; $45cd

	call checkLinkID0AndControlNormal		; $45cf
	jr nc,@resetCounter	; $45d2

	call objectCheckLinkPushingAgainstCenter		; $45d4
	jr nc,@resetCounter	; $45d7

	ld a,$01		; $45d9
	ld (wForceLinkPushAnimation),a		; $45db
	call interactionDecCounter1		; $45de
	ret nz			; $45e1

	call interactionIncState		; $45e2

	; Force link to jump, lock his speed
	ld a,$81		; $45e5
	ld (wLinkInAir),a		; $45e7
	ld hl,w1Link.speed		; $45ea
	ld (hl),SPEED_80		; $45ed

	ld l,<w1Link.speedZ		; $45ef
	ld (hl),$40		; $45f1
	inc l			; $45f3
	ld (hl),$fe		; $45f4

	call objectGetAngleTowardLink		; $45f6
	xor $10			; $45f9
	ld (w1Link.angle),a		; $45fb
	ret			; $45fe

@resetCounter:
	ld e,Interaction.counter1		; $45ff
	ld a,$04		; $4601
	ld (de),a		; $4603
	ret			; $4604

@state2:
	; Wait for link to reach a certain z position
	ld hl,w1Link.zh		; $4605
	ld a,(hl)		; $4608
	cp $fa			; $4609
	ret c			; $460b

	; Wait for link to start falling
	ld l,<w1Link.speedZ+1		; $460c
	bit 7,(hl)		; $460e
	ret nz			; $4610

	; Set minecart state to $03 (state $03 jumps to interactionDelete).
	ld a,$03		; $4611
	ld (de),a		; $4613

	; Use the "companion" slot to create a minecart.
	; Presumably this is necessary for it to persist between rooms?
	ld hl,w1Companion.enabled		; $4614
	ldi (hl),a		; $4617
	ld (hl),SPECIALOBJECTID_MINECART		; $4618

	; Copy direction, angle
	ld e,Interaction.direction		; $461a
	ld l,SpecialObject.direction		; $461c
	ld a,(de)		; $461e
	ldi (hl),a		; $461f
	inc e			; $4620
	ld a,(de)		; $4621
	ld (hl),a		; $4622

	call objectCopyPosition		; $4623

	; Minecart will be moved, so the static object slot will be updated later.
	jp objectDeleteRelatedObj1AsStaticObject		; $4626


; ==============================================================================
; INTERACID_DUNGEON_KEY_SPRITE
; ==============================================================================
interactionCode17:
	ld e,Interaction.state		; $4629
	ld a,(de)		; $462b
	rst_jumpTable			; $462c
	.dw @state0
	.dw @state1
	.dw @state2

@state0:
	call interactionIncState		; $4633
	ld l,Interaction.zh		; $4636
	ld (hl),$fc		; $4638
	ld l,Interaction.counter1		; $463a
	ld (hl),$08		; $463c

	; Subid is the tile index of the door being opened; use that to calculate a new
	; subid which will determine the graphic to use.
	ld l,Interaction.subid		; $463e
	ld a,(hl)		; $4640
	ld hl,@keyDoorGraphicTable		; $4641
	call lookupCollisionTable		; $4644
	ld e,Interaction.subid		; $4647
	ld (de),a		; $4649
	call interactionInitGraphics		; $464a

	call objectSetVisible80		; $464d
	ld a,SND_GETSEED		; $4650
	jp playSound		; $4652

@state1:
	call interactionDecCounter1		; $4655
	ret nz			; $4658
	ld (hl),$14		; $4659

	ld l,Interaction.zh		; $465b
	ld (hl),$f8		; $465d

	jp interactionIncState		; $465f

@state2:
	call interactionDecCounter1		; $4662
	ret nz			; $4665
	ld (hl),$0f		; $4666
	jp interactionDelete		; $4668


@keyDoorGraphicTable:
        .dw @collisions0
        .dw @collisions1
        .dw @collisions2
        .dw @collisions3
        .dw @collisions4
        .dw @collisions5

; Data format:
;   b0: tile index
;   b1: key type (0=small key, 1=boss key)

@collisions0:
@collisions1:
@collisions3:
@collisions4:
        .db $00 $00

@collisions2:
@collisions5:
        .db $1e $00 ; Keyblock
        .db $70 $00 ; Small key doors
        .db $71 $00
        .db $72 $00
        .db $73 $00
        .db $74 $01 ; Boss key doors
        .db $75 $01
        .db $76 $01
        .db $77 $01
        .db $00


; ==============================================================================
; INTERACID_OVERWORLD_KEY_SPRITE
; ==============================================================================
interactionCode18:
	ld e,Interaction.state		; $468c
	ld a,(de)		; $468e
	rst_jumpTable			; $468f
	.dw @state0
	.dw @state1
	.dw @state2

@state0:
	call interactionIncState		; $4696
	ld bc,-$200		; $4699
	call objectSetSpeedZ		; $469c
	call interactionSetAlwaysUpdateBit		; $469f
	call interactionInitGraphics		; $46a2
	jp objectSetVisible80		; $46a5

@state1:
	; Decrease speedZ, wait for it to stop moving up
	ld c,$28		; $46a8
	call objectUpdateSpeedZ_paramC		; $46aa
	ld e,Interaction.speedZ+1		; $46ad
	ld a,(de)		; $46af
	bit 7,a			; $46b0
	ret nz			; $46b2

	ld e,Interaction.counter1		; $46b3
	ld a,$3c		; $46b5
	ld (de),a		; $46b7
	jp interactionIncState		; $46b8

@state2:
	call interactionDecCounter1		; $46bb
	ret nz			; $46be
	jp interactionDelete		; $46bf


; ==============================================================================
; INTERACID_FARORES_MEMORY
; ==============================================================================
interactionCode1c:
	call checkInteractionState		; $46c2
	jp nz,interactionRunScript		; $46c5

; Initialization

	ld a,GLOBALFLAG_FINISHEDGAME		; $46c8
	call checkGlobalFlag		; $46ca
	jr nz,+			; $46cd
	call checkIsLinkedGame		; $46cf
	jp z,interactionDelete		; $46d2
+
	call interactionInitGraphics		; $46d5
	call objectSetVisible83		; $46d8

	ld hl,faroresMemoryScript		; $46db
	call interactionSetScript		; $46de

	jp interactionIncState		; $46e1


; ==============================================================================
; INTERACID_DOOR_CONTROLLER
; ==============================================================================
interactionCode1e:
	call interactionDeleteAndRetIfEnabled02		; $46e4
	call returnIfScrollMode01Unset		; $46e7
	ld a,(wSwitchHookState)		; $46ea
	cp $02			; $46ed
	ret z			; $46ef

	ld e,Interaction.state		; $46f0
	ld a,(de)		; $46f2
	rst_jumpTable			; $46f3
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3

@state0:
	ld a,$01		; $46fc
	ld (de),a		; $46fe

	; "xh" is actually a parameter. It's a value from 0-7; a bit for wActiveTriggers.
	ld h,d			; $46ff
	ld l,Interaction.xh		; $4700
	ld e,Interaction.var3f		; $4702
	ld a,(hl)		; $4704
	ld (de),a		; $4705
	and $07			; $4706
	ld bc,bitTable		; $4708
	add c			; $470b
	ld c,a			; $470c
	ld a,(bc)		; $470d
	ld l,Interaction.var3d		; $470e
	ld (hl),a		; $4710

	; Convert short-form position in yh to full y/x position
	ld l,Interaction.yh		; $4711
	ld e,Interaction.var3e		; $4713
	ld a,(hl)		; $4715
	ld (de),a		; $4716
	ld l,Interaction.yh		; $4717
	call setShortPosition		; $4719

	; Decide what script to run based on subid. The script will decide when to proceed
	; to state 2 (open door) or 3 (close door).
	ld e,Interaction.subid		; $471c
	ld a,(de)		; $471e
	ld hl,@scriptSubidTable		; $471f
	rst_addDoubleIndex			; $4722
	ldi a,(hl)		; $4723
	ld h,(hl)		; $4724
	ld l,a			; $4725
	call interactionSetScript		; $4726
	call @func_47e5		; $4729

@state1:
	call interactionRunScript		; $472c
	jp c,interactionDelete		; $472f

	ld e,Interaction.state2		; $4732
	xor a			; $4734
	ld (de),a		; $4735
	ret			; $4736


; State 2: a door is opening
@state2:
	ld a,(wPaletteThread_mode)		; $4737
	or a			; $473a
	ret nz			; $473b

	ld e,Interaction.state2		; $473c
	ld a,(de)		; $473e
	rst_jumpTable			; $473f
	.dw @state2Substate0
	.dw @state2Substate1

@state2Substate0:
	; The tile at this position must be solid
	call objectCheckTileCollision_allowHoles		; $4744
	jr nc,@gotoState1	; $4747

@interleaveDoorTile:
	ld a,SND_DOORCLOSE		; $4749
	call @playSoundIfInScreenBoundary		; $474b

	ld e,Interaction.angle		; $474e
	ld a,(de)		; $4750
	ld hl,@shutterTiles		; $4751
	rst_addAToHl			; $4754
	ld e,Interaction.var3e		; $4755
	ld a,(de)		; $4757
	ldh (<hFF8C),a	; $4758
	ldi a,(hl)		; $475a
	ldh (<hFF8F),a	; $475b
	ldi a,(hl)		; $475d
	ldh (<hFF8E),a	; $475e
	and $03			; $4760
	call setInterleavedTile		; $4762

	ldh a,(<hActiveObject)	; $4765
	ld d,a			; $4767
	ld h,d			; $4768
	ld l,Interaction.state2		; $4769
	inc (hl)		; $476b

	ld l,Interaction.counter1		; $476c
	ld (hl),$06		; $476e

	; Set the new tile in the room layout (but since we're not calling "setTile", the
	; visuals won't be updated just yet?)
	ld l,Interaction.var3e		; $4770
	ld c,(hl)		; $4772
	ld b,>wRoomLayout		; $4773
	ldh a,(<hFF8F)	; $4775
	ld (bc),a		; $4777
	ret			; $4778

@state2Substate1:
	call interactionDecCounter1		; $4779
	ret nz			; $477c

; Door will now open fully

	call @func_47ee		; $477d
	ld e,Interaction.angle		; $4780
	ld a,(de)		; $4782
	ld hl,@shutterTiles		; $4783
	rst_addAToHl			; $4786
	jr @setTileAndPlaySound		; $4787


; State 3: a door is closing
@state3:
	ld e,Interaction.state2		; $4789
	ld a,(de)		; $478b
	rst_jumpTable			; $478c
	.dw @state3Substate0
	.dw @state3Substate1

@state3Substate0:
	; The tile at this position must not be solid
	call objectGetTileAtPosition		; $4791
	cp TILEINDEX_SOMARIA_BLOCK			; $4794
	jr z,@interleaveDoorTile	; $4796
	call objectCheckTileCollision_allowHoles		; $4798
	jr c,@gotoState1	; $479b
	jr @interleaveDoorTile		; $479d

@state3Substate1:
	call interactionDecCounter1		; $479f
	ret nz			; $47a2

; Door will now close fully

	call @checkRespawnLink		; $47a3
	call @func_47f9		; $47a6

	ld e,Interaction.angle		; $47a9
	ld a,(de)		; $47ab
	ld hl,@shutterTiles		; $47ac
	rst_addAToHl			; $47af
	inc hl			; $47b0

@setTileAndPlaySound:
	ld e,Interaction.var3e		; $47b1
	ld a,(de)		; $47b3
	ld c,a			; $47b4
	ld a,(hl)		; $47b5
	call setTile		; $47b6
	ld a,SND_DOORCLOSE		; $47b9
	call @playSoundIfInScreenBoundary		; $47bb

@gotoState1:
	ld e,Interaction.state		; $47be
	ld a,$01		; $47c0
	ld (de),a		; $47c2
	inc e			; $47c3
	xor a			; $47c4
	ld (de),a		; $47c5
	jp @state1		; $47c6

;;
; Force Link to respawn if he's on the same tile as this object.
; @addr{47c9}
@checkRespawnLink:
	ld a,(w1Link.yh)		; $47c9
	and $f0			; $47cc
	ld b,a			; $47ce
	ld a,(w1Link.xh)		; $47cf
	swap a			; $47d2
	and $0f			; $47d4
	or b			; $47d6
	ld b,a			; $47d7
	ld e,Interaction.var3e		; $47d8
	ld a,(de)		; $47da
	cp b			; $47db
	ret nz			; $47dc
	ld a,$02		; $47dd
	ld (wScreenTransitionDelay),a		; $47df
	jp respawnLink		; $47e2

@func_47e5:
	ld e,Interaction.var3e		; $47e5
	ld a,(de)		; $47e7
	ld c,a			; $47e8
	ld b,>wRoomCollisions		; $47e9
	ld a,(bc)		; $47eb
	or a			; $47ec
	ret nz			; $47ed

@func_47ee:
	ld e,Interaction.subid		; $47ee
	ld a,(de)		; $47f0
	cp $04			; $47f1
	ret c			; $47f3
	ld hl,$cc93		; $47f4
	inc (hl)		; $47f7
	ret			; $47f8

@func_47f9:
	ld e,Interaction.subid		; $47f9
	ld a,(de)		; $47fb
	cp $04			; $47fc
	ret c			; $47fe
	ld hl,$cc93		; $47ff
	ld a,(hl)		; $4802
	or a			; $4803
	ret z			; $4804
	dec (hl)		; $4805
	ld a,(hl)		; $4806
	and $7f			; $4807
	ret nz			; $4809
	res 7,(hl)		; $480a
	ret			; $480c

;;
; @param	a	Sound to play
; @addr{480d}
@playSoundIfInScreenBoundary:
	ldh (<hFF8B),a	; $480d
	call objectCheckWithinScreenBoundary		; $480f
	ret nc			; $4812
	ldh a,(<hFF8B)	; $4813
	jp playSound		; $4815


; Data format:
;   b0: tile to transition into
;   b1: tile to transition from

@shutterTiles:
	.db $a0 $70 ; Key doors
	.db $a0 $71
	.db $a0 $72
	.db $a0 $73
	.db $a0 $74 ; Boss doors
	.db $a0 $75
	.db $a0 $76
	.db $a0 $77
	.db $a0 $78 ; Shutters
	.db $a0 $79
	.db $a0 $7a
	.db $a0 $7b
	.db $5e $7c ; Minecart shutters
	.db $5d $7d
	.db $5e $7e
	.db $5d $7f


; @addr{4838}
@scriptSubidTable:
	/* $00 */ .dw doorOpenerScript
	/* $01 */ .dw stubScript
	/* $02 */ .dw stubScript
	/* $03 */ .dw stubScript
	/* $04 */ .dw doorController_controlledByTriggers_up
	/* $05 */ .dw doorController_controlledByTriggers_right
	/* $06 */ .dw doorController_controlledByTriggers_down
	/* $07 */ .dw doorController_controlledByTriggers_left
	/* $08 */ .dw doorController_shutUntilEnemiesDead_up
	/* $09 */ .dw doorController_shutUntilEnemiesDead_right
	/* $0a */ .dw doorController_shutUntilEnemiesDead_down
	/* $0b */ .dw doorController_shutUntilEnemiesDead_left
	/* $0c */ .dw doorController_minecartDoor_up
	/* $0d */ .dw doorController_minecartDoor_right
	/* $0e */ .dw doorController_minecartDoor_down
	/* $0f */ .dw doorController_minecartDoor_left
	/* $10 */ .dw doorController_closeAfterLinkEnters_up
	/* $11 */ .dw doorController_closeAfterLinkEnters_right
	/* $12 */ .dw doorController_closeAfterLinkEnters_down
	/* $13 */ .dw doorController_closeAfterLinkEnters_left
	/* $14 */ .dw doorController_openWhenTorchesLit_up_2Torches
	/* $15 */ .dw doorController_openWhenTorchesLit_left_2Torches
	/* $16 */ .dw doorController_openWhenTorchesLit_down_1Torch
	/* $17 */ .dw doorController_openWhenTorchesLit_left_1Torch


; ==============================================================================
; INTERACID_TOGGLE_FLOOR: red/yellow/blue floor tiles that change color when jumped over.
; ==============================================================================
interactionCode15:
	ld e,Interaction.subid		; $4868
	ld a,(de)		; $486a
	or a			; $486b
	jp nz,@subid01		; $486c


; Subid 0: this checks Link's position and spawns new instances of subid 1 when needed.
@subid00:
	call interactionDeleteAndRetIfEnabled02		; $486f
	call checkInteractionState		; $4872
	jr nz,@initialized	; $4875

	call interactionIncState		; $4877

@updateTilePos:
	ld e,Interaction.var30		; $487a
	ld a,(wActiveTilePos)		; $487c
	ld (de),a		; $487f
	ret			; $4880

@initialized:
	ld a,(wLinkInAir)		; $4881
	or a			; $4884
	jr z,@updateTilePos	; $4885

	; Check that link's position is within 4 pixels of the tile's center on both axes
	ld a,(w1Link.yh)		; $4887
	add $05			; $488a
	and $0f			; $488c
	sub $04			; $488e
	cp $09			; $4890
	ret nc			; $4892
	ld a,(w1Link.xh)		; $4893
	and $0f			; $4896
	sub $04			; $4898
	cp $09			; $489a
	ret nc			; $489c

	; Check that Link's tile position has changed
	ld e,Interaction.var30		; $489d
	ld a,(de)		; $489f
	ld c,a			; $48a0
	call getLinkTilePosition		; $48a1
	cp c			; $48a4
	ret z			; $48a5

	; Position has changed. Check that the new tile is one of the colored floor tiles.
	ld (de),a		; $48a6
	ld c,a			; $48a7
	ld b,>wRoomLayout		; $48a8
	ld a,(bc)		; $48aa
	sub TILEINDEX_RED_TOGGLE_FLOOR			; $48ab
	cp $03			; $48ad
	ret nc			; $48af

	; Spawn an instance of this object with subid 1.
	call getFreeInteractionSlot		; $48b0
	ret nz			; $48b3
	ld (hl),INTERACID_TOGGLE_FLOOR		; $48b4
	inc l			; $48b6
	ld (hl),$01 ; [subid] = $01
	inc l			; $48b9
	ld (hl),c   ; [var03] = position

	ld l,Interaction.var30		; $48bb
	ld a,(wActiveTilePos)		; $48bd
	ld (hl),a		; $48c0
	ret			; $48c1


; Subid 1: toggles tile at position [var03] when Link lands.
@subid01:
	ld a,(wLinkInAir)		; $48c2
	or a			; $48c5
	ret nz			; $48c6

	; Get position of tile in 'c'.
	ld e,Interaction.var03		; $48c7
	ld a,(de)		; $48c9
	ld c,a			; $48ca

	; var30 contains Link's position from before he jumped; if he's landed on the same
	; spot, don't toggle the block.
	ld e,Interaction.var30		; $48cb
	ld a,(de)		; $48cd
	ld b,a			; $48ce
	call getLinkTilePosition		; $48cf
	cp b			; $48d2
	jp z,interactionDelete		; $48d3

	ld b,>wRoomLayout		; $48d6
	ld a,(bc)		; $48d8
	inc a			; $48d9
	cp TILEINDEX_RED_TOGGLE_FLOOR+3			; $48da
	jr c,+			; $48dc
	ld a,TILEINDEX_RED_TOGGLE_FLOOR		; $48de
+
	ldh (<hFF92),a	; $48e0
	call setTile		; $48e2
	ldh a,(<hFF92)	; $48e5
	ld b,a			; $48e7
	call setTileInRoomLayoutBuffer		; $48e8

	ld a,SND_GETSEED		; $48eb
	call playSound		; $48ed

	jp interactionDelete		; $48f0

;;
; @param[out]	a,l	The position of the tile Link's standing on
; @addr{48f3}
getLinkTilePosition:
	push bc			; $48f3
	ld a,(w1Link.yh)		; $48f4
	add $05			; $48f7
	and $f0			; $48f9
	ld b,a			; $48fb
	ld a,(w1Link.xh)		; $48fc
	swap a			; $48ff
	and $0f			; $4901
	or b			; $4903
	ld l,a			; $4904
	pop bc			; $4905
	ret			; $4906


; ==============================================================================
; INTERACID_COLORED_CUBE
; ==============================================================================
interactionCode19:
	call objectReplaceWithAnimationIfOnHazard		; $4907
	ret c			; $490a
	ld e,Interaction.state		; $490b
	ld a,(de)		; $490d
	rst_jumpTable			; $490e
	.dw @state0
	.dw @state1
	.dw @state2


; State 0: initialization
@state0:
	ld h,d			; $4915
	ld l,e			; $4916
	inc (hl)		; $4917

	ld l,Interaction.counter1		; $4918
	ld (hl),$14 ; counter1: frames it takes to push it
	inc l			; $491c
	ld (hl),$0a ; counter2: frames it takes to fall into a hole

	ld a,$06		; $491f
	call objectSetCollideRadius		; $4921
	call interactionInitGraphics		; $4924

	ld e,Interaction.subid		; $4927
	ld a,(de)		; $4929
	ld e,Interaction.direction		; $492a
	ld (de),a		; $492c

	call @setColor		; $492d

	; Load palettes 6 and 7. Since it uses palette 6, you shouldn't be able to move
	; any blocks or hold anything while one of these blocks is on screen, since this
	; would interfere with the "objectMimicBgTile" function.
	ld a,PALH_89		; $4930
	call loadPaletteHeader		; $4932

	call @updatePosition		; $4935
	jp objectSetVisible82		; $4938


; State 1: waiting to be pushed
@state1:
	call interactionDecCounter2		; $493b
	jr nz,+			; $493e
	call objectGetTileAtPosition		; $4940
	cp TILEINDEX_CRACKED_FLOOR			; $4943
	jp z,@fallDownHole		; $4945
+
	call @checkLinkPushingTowardBlock		; $4948
	jr nz,@resetCounter1	; $494b
	call interactionDecCounter1		; $494d
	ret nz			; $4950

; Block has been pushed for 20 frames.

	ld a,b			; $4951
	swap a			; $4952
	rrca			; $4954
	ld e,Interaction.angle		; $4955
	ld (de),a		; $4957
	call interactionCheckAdjacentTileIsSolid		; $4958
	jr nz,@resetCounter1	; $495b

	; Set collisions to 0
	call objectGetShortPosition		; $495d
	ld h,>wRoomCollisions		; $4960
	ld l,a			; $4962
	ld (hl),$00		; $4963

	call interactionIncState		; $4965
	ld l,Interaction.direction		; $4968
	ldi a,(hl)		; $496a
	add a			; $496b
	add a			; $496c
	ld b,a			; $496d
	ld a,(hl)		; $496e
	swap a			; $496f
	rlca			; $4971
	add b			; $4972
	ld hl,@animations		; $4973
	rst_addAToHl			; $4976
	ld a,(hl)		; $4977
	call interactionSetAnimation		; $4978
	jr @checkAnimParameter		; $497b

@resetCounter1:
	ld e,Interaction.counter1		; $497d
	ld a,$14		; $497f
	ld (de),a		; $4981
	ret			; $4982


; State 2: being pushed
@state2:
	call interactionAnimate		; $4983

@checkAnimParameter:
	ld e,Interaction.animParameter		; $4986
	ld a,(de)		; $4988
	or a			; $4989
	ret z			; $498a
	ld b,a			; $498b
	rlca			; $498c
	jr c,@finishMovement	; $498d

	xor a			; $498f
	ld (de),a		; $4990
	ld a,b			; $4991
	sub $02			; $4992
	ld hl,@directionOffsets		; $4994
	rst_addAToHl			; $4997
	ld e,Interaction.yh		; $4998
	ld a,(de)		; $499a
	add (hl)		; $499b
	ld (de),a		; $499c
	inc hl			; $499d
	ld e,Interaction.xh		; $499e
	ld a,(de)		; $49a0
	add (hl)		; $49a1
	ld (de),a		; $49a2
	ret			; $49a3

@finishMovement:
	ld h,d			; $49a4
	ld l,Interaction.state		; $49a5
	dec (hl)		; $49a7
	ld l,Interaction.counter1		; $49a8
	ld (hl),$14		; $49aa
	inc l			; $49ac
	ld (hl),$0a		; $49ad
	ld a,b			; $49af
	and $7f			; $49b0
	ld e,Interaction.direction		; $49b2
	ld (de),a		; $49b4
	call @setColor		; $49b5
	call objectCenterOnTile		; $49b8

.ifdef ROM_AGES
	ld a,SND_MOVE_BLOCK_2		; $49bb
.else
	ld a,$7f
.endif
	call playSound		; $49bd

;;
; Updates wRotatingCubePos and wRoomCollisions based on the object's current position.
; @addr{49c0}
@updatePosition:
	call objectGetShortPosition		; $49c0
	ld h,>wRoomCollisions		; $49c3
	ld l,a			; $49c5
	ld (hl),$0f		; $49c6
	ld (wRotatingCubePos),a		; $49c8

	; Push Link away? (only called once since solidity is handled by modifying
	; wRoomCollisions)
	jp objectPreventLinkFromPassing		; $49cb


@directionOffsets:
	.db $fc $00
	.db $00 $04
	.db $04 $00
	.db $00 $fc

;;
; @param[out]	b	Direction it's being pushed in
; @param[out]	zflag	Set if Link is pushing toward the block
; @addr{49e5}
@checkLinkPushingTowardBlock:
	ld a,(wLinkGrabState)		; $49d6
	or a			; $49d9
	ret nz			; $49da
	ld a,(wLinkAngle)		; $49db
	rlca			; $49de
	ret c			; $49df
	ld a,(w1Link.zh)		; $49e0
	rlca			; $49e3
	ret c			; $49e4

	ld a,(wGameKeysPressed)		; $49e5
	and (BTN_A | BTN_B)			; $49e8
	ret nz			; $49ea
	ld c,$14		; $49eb
	call objectCheckLinkWithinDistance		; $49ed
	jr nc,++		; $49f0
	srl a			; $49f2
	xor $02			; $49f4
	ld b,a			; $49f6
	ld a,(w1Link.direction)		; $49f7
	cp b			; $49fa
	ret			; $49fb
++
	or d			; $49fc
	ret			; $49fd

; These are the animations values to use when the tile is being pushed.
; Each row corresponds to an orientation of the cube (value of Interaction.direction).
; Each column corresponds to the direction it's being pushed in (Interaction.angle).
@animations:
	.db $12 $07 $13 $06 ; 0: yellow/red
	.db $14 $11 $15 $10 ; 1: red/yellow
	.db $16 $0b $17 $0a ; 2: red/blue
	.db $18 $09 $19 $08 ; 3: blue/red
	.db $1a $0f $1b $0e ; 4: blue/yellow
	.db $1c $0d $1d $0c ; 5: yellow/blue


;;
; Sets wRotatingCubeColor as well as the animation to use.
;
; @param	a	Orientation of cube (value of Interaction.direction)
; @addr{4a16}
@setColor:
	ld b,a			; $4a16
	ld hl,@colors		; $4a17
	rst_addAToHl			; $4a1a
	ld a,(hl)		; $4a1b
	ld (wRotatingCubeColor),a		; $4a1c
	ld a,b			; $4a1f
	jp interactionSetAnimation		; $4a20

@colors:
	.db $01 $00 $00 $02 $02 $01


@fallDownHole:
	ld c,l			; $4a29
	ld a,TILEINDEX_HOLE		; $4a2a
	call setTile		; $4a2c
	call objectCreateFallingDownHoleInteraction		; $4a2f
	jp interactionDelete		; $4a32


; ==============================================================================
; INTERACID_COLORED_CUBE_FLAME
; ==============================================================================
interactionCode1a:
	call checkInteractionState		; $4a35
	jr nz,@initialized	; $4a38
	ld a,(wRotatingCubePos)		; $4a3a
	or a			; $4a3d
	ret z			; $4a3e

	call @updateColor		; $4a3f
	call interactionInitGraphics		; $4a42
	call objectSetVisible82		; $4a45
	call interactionIncState		; $4a48

@initialized:
	ld a,(wRotatingCubeColor)		; $4a4b
	rlca			; $4a4e
	jp nc,objectSetInvisible		; $4a4f
	call objectSetVisible		; $4a52
	call @updateColor		; $4a55
	jp interactionAnimate		; $4a58

@updateColor:
	ld a,(wRotatingCubeColor)		; $4a5b
	and $7f			; $4a5e
	ld hl,@palettes		; $4a60
	rst_addAToHl			; $4a63
	ld e,Interaction.oamFlags		; $4a64
	ld a,(de)		; $4a66
	and $f8			; $4a67
	or (hl)			; $4a69
	ld (de),a		; $4a6a
	ret			; $4a6b

@palettes:
	.db $02 $03 $01


; ==============================================================================
; INTERACID_MINECART_GATE
; ==============================================================================
interactionCode1b:
	ld e,Interaction.state		; $4a6f
	ld a,(de)		; $4a71
	rst_jumpTable			; $4a72
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3

@state0:
	ld a,$01		; $4a7b
	ld (de),a		; $4a7d

	; Move bits 4-7 of subid to bits 0-3 (direction of gate)
	ld e,Interaction.subid		; $4a7e
	ld a,(de)		; $4a80
	ld b,a			; $4a81
	swap a			; $4a82
	and $0f			; $4a84
	ld (de),a		; $4a86

	; Set var03 to a bitmask based on bits 0-2 of subid
	ld a,b			; $4a87
	and $07			; $4a88
	ld hl,bitTable		; $4a8a
	add l			; $4a8d
	ld l,a			; $4a8e
	inc e			; $4a8f
	ld a,(hl)		; $4a90
	ld (de),a		; $4a91

	call interactionInitGraphics		; $4a92
	call objectSetVisible82		; $4a95

	call @setAnimationAndUpdateCollisions		; $4a98
	ld e,Interaction.var30		; $4a9b
	ld a,(de)		; $4a9d
	ld b,a			; $4a9e
	and $01			; $4a9f
	inc a			; $4aa1
	ld e,Interaction.state		; $4aa2
	ld (de),a		; $4aa4
	ld a,b			; $4aa5
	xor $01			; $4aa6
	jp interactionSetAnimation		; $4aa8

;;
; Sets var30 to the animation to be done. Bit 0 set if the gate is open.
; Also modifies tile collisions appropriately.
; @addr{4aab}
@setAnimationAndUpdateCollisions:
	ld a,(wSwitchState)		; $4aab
	ld b,a			; $4aae
	ld e,Interaction.var03		; $4aaf
	ld a,(de)		; $4ab1
	and b			; $4ab2
	ld c,$00		; $4ab3
	jr nz,+			; $4ab5
	ld c,$01		; $4ab7
+
	dec e			; $4ab9
	ld a,(de) ; a = [subid] (subid is 0 if facing left, 2 if facing right)
	or c			; $4abb
	ld e,Interaction.var30		; $4abc
	ld (de),a		; $4abe

	call interactionSetAnimation		; $4abf

	call objectGetTileAtPosition		; $4ac2
	dec h ; h points to wRoomCollisions
	dec l			; $4ac6

	; a = [var30]*3
	ld e,Interaction.var30		; $4ac7
	ld a,(de)		; $4ac9
	ld b,a			; $4aca
	add a			; $4acb
	add b			; $4acc

	ld bc,@collisions		; $4acd
	call addAToBc		; $4ad0
	ld a,(bc)		; $4ad3
	ldi (hl),a		; $4ad4
	inc bc			; $4ad5
	ld a,(bc)		; $4ad6
	ld (hl),a		; $4ad7

	inc bc			; $4ad8
	ld a,(bc)		; $4ad9
	add l			; $4ada
	ld l,a			; $4adb
	inc h			; $4adc
	ld a,(de)		; $4add
	rrca			; $4ade
	jr c,+			; $4adf
	ld (hl),$5e		; $4ae1
	ret			; $4ae3
+
	ld (hl),$00		; $4ae4
	ret			; $4ae6

@collisions:
	.db $00 $0a  $ff ; Gate facing right
	.db $0c $0a  $ff
	.db $05 $00  $00 ; Gate facing left
	.db $05 $0c  $00


; State 1: waiting for switch to be pressed
@state1:
	call objectSetPriorityRelativeToLink		; $4af3
	ld a,(wSwitchState)		; $4af6
	cpl			; $4af9
	jr ++			; $4afa

; State 2: waiting for switch to be released
@state2:
	call objectSetPriorityRelativeToLink		; $4afc
	ld a,(wSwitchState)		; $4aff
++
	ld b,a			; $4b02
	ld e,Interaction.var03		; $4b03
	ld a,(de)		; $4b05
	and b			; $4b06
	ret z			; $4b07

	ld e,Interaction.state		; $4b08
	ld a,$03		; $4b0a
	ld (de),a		; $4b0c
.ifdef ROM_AGES
	ld a,SND_OPEN_GATE		; $4b0d
.else
	ld a,$7d
.endif
	call playSound		; $4b0f
	jp @setAnimationAndUpdateCollisions		; $4b12


; State 3: in the process of opening or closing
@state3:
	call interactionAnimate		; $4b15
	call objectSetPriorityRelativeToLink		; $4b18

	ld e,Interaction.animParameter		; $4b1b
	ld a,(de)		; $4b1d
	inc a			; $4b1e
	ret nz			; $4b1f

	ld e,Interaction.var30		; $4b20
	ld a,(de)		; $4b22
	and $01			; $4b23
	inc a			; $4b25
	ld e,Interaction.state		; $4b26
	ld (de),a		; $4b28
	ret			; $4b29


; ==============================================================================
; INTERACID_SPECIAL_WARP
; ==============================================================================
interactionCode1f:
	ld e,Interaction.subid		; $4b2a
	ld a,(de)		; $4b2c
	rst_jumpTable			; $4b2d
	.dw @subid0
	.dw @subid1
	.dw @subid2

; Subid 0: Trigger a warp when Link dives touching this object
@subid0:
	call checkInteractionState		; $4b34
	jr z,@@initialize	; $4b37

	; Check that Link has collided with this object, he's not holding anything, and
	; he's diving.
	ld a,(wLinkSwimmingState)		; $4b39
	rlca			; $4b3c
	ret nc			; $4b3d
	call objectCheckCollidedWithLink_notDeadAndNotGrabbing		; $4b3e
	ret nc			; $4b41

	ld e,Interaction.var03		; $4b42
	ld a,(de)		; $4b44
	ld hl,@@warpData		; $4b45
	rst_addDoubleIndex			; $4b48
	ldi a,(hl)		; $4b49
	ld (wWarpDestIndex),a		; $4b4a
	ld a,(hl)		; $4b4d
	ld (wWarpDestPos),a		; $4b4e
	ld a,$87		; $4b51
	ld (wWarpDestGroup),a		; $4b53
	ld a,$01		; $4b56
	ld (wWarpTransition),a		; $4b58
	ld a,$03		; $4b5b
	ld (wWarpTransition2),a		; $4b5d
	jp interactionDelete		; $4b60

@@warpData:
	.db $09 $01
	.db $05 $03

@@initialize:
	ld a,$01		; $4b67
	ld (de),a		; $4b69
	ld a,$02		; $4b6a
	call objectSetCollideRadius		; $4b6c

	ld l,Interaction.xh		; $4b6f
	ld a,(hl)		; $4b71
	ld l,Interaction.var03		; $4b72
	ld (hl),a		; $4b74

	ld l,Interaction.yh		; $4b75
	ld c,(hl)		; $4b77
	jp setShortPosition_paramC		; $4b78


; Subid 1: a warp at the top of a waterfall
@subid1:
	ld e,Interaction.state		; $4b7b
	ld a,(de)		; $4b7d
	rst_jumpTable			; $4b7e
	.dw @subid1State0
	.dw @subid1State1
	.dw @subid1State2

@subid1State0:
	ld a,(wAnimalCompanion)		; $4b85
	cp SPECIALOBJECTID_DIMITRI			; $4b88
	jp nz,interactionDelete		; $4b8a

	ld bc,$0810		; $4b8d
	call objectSetCollideRadii		; $4b90
	call objectCheckCollidedWithLink_notDeadAndNotGrabbing		; $4b93
	call nc,interactionIncState		; $4b96
	jp interactionIncState		; $4b99

@subid1State1:
	call objectCheckCollidedWithLink_notDeadAndNotGrabbing		; $4b9c
	ret c			; $4b9f
	jp interactionIncState		; $4ba0

@subid1State2:
	ld a,d			; $4ba3
	ld (wcc90),a		; $4ba4
	ld a,(wLinkObjectIndex)		; $4ba7
	cp >w1Companion			; $4baa
	ret nz			; $4bac
	call objectCheckCollidedWithLink_notDeadAndNotGrabbing		; $4bad
	ret nc			; $4bb0
	ld hl,@@warpDestVariables		; $4bb1
	jp setWarpDestVariables		; $4bb4

@@warpDestVariables:
	.db $85 $b8 $00 $93 $03


; Subid 2: a warp in a cave in a waterfall
@subid2:
	ld a,d			; $4bbc
	ld (wDisableScreenTransitions),a		; $4bbd
	call checkInteractionState		; $4bc0
	jr z,@@initialize	; $4bc3

	call checkLinkCollisionsEnabled		; $4bc5
	ret nc			; $4bc8
	ld a,(wLinkObjectIndex)		; $4bc9
	bit 0,a			; $4bcc
	ret z			; $4bce

	ld h,a			; $4bcf
	ld l,<w1Companion.yh		; $4bd0
	ld a,(hl)		; $4bd2
	cp $a8			; $4bd3
	ret c			; $4bd5

	ld a,$ff		; $4bd6
	ld (wDisabledObjects),a		; $4bd8

	ld hl,@@warpDestVariables		; $4bdb
	call setWarpDestVariables		; $4bde
	jp interactionDelete		; $4be1

@@warpDestVariables:
	.db $00 $37 $0e $22 $03

@@initialize:
	call interactionIncState		; $4be9
	jp interactionSetAlwaysUpdateBit		; $4bec


; ==============================================================================
; INTERACID_DUNGEON_SCRIPT
; ==============================================================================
interactionCode20:
	call interactionDeleteAndRetIfEnabled02		; $4bef
	ld e,Interaction.state		; $4bf2
	ld a,(de)		; $4bf4
	rst_jumpTable			; $4bf5
	.dw @state0
	.dw @state1
	.dw @state2

@state0:
	ld a,$01		; $4bfc
	ld (de),a		; $4bfe

	xor a			; $4bff
	ld ($cfc1),a		; $4c00
	ld ($cfc2),a		; $4c03

	ld a,(wDungeonIndex)		; $4c06
	cp $ff			; $4c09
	jp z,interactionDelete		; $4c0b

	ld hl,@scriptTable		; $4c0e
	rst_addDoubleIndex			; $4c11
	ldi a,(hl)		; $4c12
	ld h,(hl)		; $4c13
	ld l,a			; $4c14
	ld e,Interaction.subid		; $4c15
	ld a,(de)		; $4c17
	rst_addDoubleIndex			; $4c18
	ldi a,(hl)		; $4c19
	ld h,(hl)		; $4c1a
	ld l,a			; $4c1b
	call interactionSetScript		; $4c1c
	jp interactionRunScript		; $4c1f

@state2:
	call objectPreventLinkFromPassing		; $4c22

@state1:
	call interactionRunScript		; $4c25
	ret nc			; $4c28
	jp interactionDelete		; $4c29

; @addr{4c2c}
@scriptTable:
	.dw @dungeon0
	.dw @dungeon1
	.dw @dungeon2
	.dw @dungeon3
	.dw @dungeon4
	.dw @dungeon5
	.dw @dungeon6
	.dw @dungeon7
	.dw @dungeon8
	.dw @dungeon9
	.dw @dungeona
	.dw @dungeonb
	.dw @dungeonc
	.dw @dungeond

@dungeon0:
@dungeond:
	.dw makuPathScript_spawnChestWhenActiveTriggersEq01
	.dw makuPathScript_spawnDownStairsWhenEnemiesKilled
	.dw makuPathScript_spawn30Rupees
	.dw makuPathScript_keyFallsFromCeilingWhen1TorchLit
	.dw makuPathScript_spawnUpStairsWhen2TorchesLit
@dungeon1:
	.dw dungeonScript_spawnChestOnTriggerBit0
	.dw spiritsGraveScript_spawnBracelet
	.dw dungeonScript_minibossDeath
	.dw dungeonScript_bossDeath
	.dw spiritsGraveScript_stairsToBraceletRoom
	.dw spiritsGraveScript_spawnMovingPlatform
@dungeon2:
	.dw wingDungeonScript_spawnFeather
	.dw wingDungeonScript_spawn30Rupees
	.dw dungeonScript_minibossDeath
	.dw wingDungeonScript_bossDeath
@dungeon3:
	.dw dungeonScript_minibossDeath
	.dw dungeonScript_bossDeath
	.dw moonlitGrottoScript_spawnChestWhen2TorchesLit
@dungeon4:
	.dw dungeonScript_minibossDeath
	.dw dungeonScript_bossDeath
	.dw skullDungeonScript_spawnChestWhenOrb0Hit
	.dw skullDungeonScript_spawnChestWhenOrb1Hit
@dungeon5:
	.dw dungeonScript_minibossDeath
	.dw dungeonScript_bossDeath
	.dw crownDungeonScript_spawnChestWhen3TriggersActive
@dungeon6:
	.dw dungeonScript_minibossDeath
@dungeon7:
	.dw dungeonScript_bossDeath
@dungeon8:
	.dw dungeonScript_minibossDeath
	.dw dungeonScript_bossDeath
	.dw ancientTombScript_spawnSouthStairsWhenTrigger0Active
	.dw ancientTombScript_spawnNorthStairsWhenTrigger0Active
	.dw ancientTombScript_retractWallWhenTrigger0Active
	.dw ancientTombScript_spawnDownStairsWhenEnemiesKilled
	.dw ancientTombScript_spawnVerticalBridgeWhenTorchLit
@dungeon9:
@dungeona:
@dungeonb:
	.dw dungeonScript_spawnChestOnTriggerBit0
	.dw herosCaveScript_spawnChestWhen4TriggersActive
	.dw herosCaveScript_spawnBridgeWhenTriggerPressed
	.dw herosCaveScript_spawnNorthStairsWhenEnemiesKilled
@dungeonc:
	.dw dungeonScript_bossDeath
	.dw mermaidsCaveScript_spawnBridgeWhenOrbHit
	.dw mermaidsCaveScript_updateTrigger2BasedOnTriggers0And1


; ==============================================================================
; INTERACID_DUNGEON_EVENTS
; ==============================================================================
interactionCode21:
	ld e,Interaction.subid		; $4c9a
	ld a,(de)		; $4c9c
	rst_jumpTable			; $4c9d
	.dw interactionDelete
	.dw _interaction21_subid01
	.dw _interaction21_subid02
	.dw _interaction21_subid03
	.dw _interaction21_subid04
	.dw _interaction21_subid05
	.dw _interaction21_subid06
	.dw _interaction21_subid07
	.dw _interaction21_subid08
	.dw _interaction21_subid09
	.dw _interaction21_subid0a
	.dw _interaction21_subid0b
	.dw _interaction21_subid0c
	.dw _interaction21_subid0d
	.dw _interaction21_subid0e
	.dw _interaction21_subid0f
	.dw _interaction21_subid10
	.dw _interaction21_subid11
	.dw _interaction21_subid12
	.dw _interaction21_subid13
	.dw _interaction21_subid14
	.dw _interaction21_subid15
	.dw _interaction21_subid16
	.dw _interaction21_subid17
	.dw _interaction21_subid18
	.dw _interaction21_subid19


; D2: Verify a 2x2 floor pattern
_interaction21_subid01:
	call _interactionDeleteAndRetIfItemFlagSet		; $4cd2
	ld hl,_subid01_tileData		; $4cd5

_verifyTilesAndDropSmallKey:
	call _verifyTiles		; $4cd8
	ret nz			; $4cdb
	jp _spawnSmallKeyFromCeiling		; $4cdc

_subid01_tileData:
	.db TILEINDEX_YELLOW_TOGGLE_FLOOR  $67 $77 $ff ; Tiles at $67 and $77 must be red
	.db TILEINDEX_BLUE_TOGGLE_FLOOR    $68 $78 $00 ; Tiles at $68 and $78 must be blue


; D2: Verify a floor tile is red to open a door
_interaction21_subid02:
	ld a,(wRoomLayout+$5a)		; $4ce7
	cp TILEINDEX_RED_TOGGLE_FLOOR			; $4cea
	ld a,$01		; $4cec
	jr z,+			; $4cee
	dec a			; $4cf0
+
	ld (wActiveTriggers),a		; $4cf1
	ret			; $4cf4


; Light torches when a colored cube rolls into this position.
_interaction21_subid03:
	call checkInteractionState		; $4cf5
	jr nz,@initialized	; $4cf8

	call interactionIncState		; $4cfa
	call objectGetTileAtPosition		; $4cfd
	ld a,(wRotatingCubePos)		; $4d00
	ld e,Interaction.var03		; $4d03
	ld (de),a		; $4d05
	cp l			; $4d06
	call z,@lightCubeTorches		; $4d07

@initialized:
	ld e,Interaction.var03		; $4d0a
	ld a,(de)		; $4d0c
	ld b,a			; $4d0d
	ld a,(wRotatingCubePos)		; $4d0e
	cp b			; $4d11
	ret z			; $4d12

	call objectGetTileAtPosition		; $4d13
	ld a,(wRotatingCubePos)		; $4d16
	cp l			; $4d19
	call z,@lightCubeTorches		; $4d1a
	ld a,(wRotatingCubePos)		; $4d1d
	ld e,Interaction.var03		; $4d20
	ld (de),a		; $4d22
	ret			; $4d23

@lightCubeTorches:
	ld hl,wRotatingCubeColor		; $4d24
	set 7,(hl)		; $4d27
	ld a,SND_LIGHTTORCH		; $4d29
	jp playSound		; $4d2b


; d2: Set torch color based on the color of the tile at this position.
_interaction21_subid04:
	call checkInteractionState		; $4d2e
	jr nz,@initialized	; $4d31

	call interactionIncState		; $4d33
	call objectGetTileAtPosition		; $4d36
	ld e,Interaction.var03		; $4d39
	ld (de),a		; $4d3b
	sub TILEINDEX_RED_TOGGLE_FLOOR			; $4d3c
	set 7,a			; $4d3e
	ld (wRotatingCubeColor),a		; $4d40
	ld a,$57		; $4d43
	ld (wRotatingCubePos),a		; $4d45

@initialized:
	call objectGetTileAtPosition		; $4d48
	ld b,a			; $4d4b
	sub TILEINDEX_RED_TOGGLE_FLOOR			; $4d4c
	cp $03			; $4d4e
	ret nc			; $4d50

	ld e,Interaction.var03		; $4d51
	ld a,(de)		; $4d53
	cp b			; $4d54
	ret z			; $4d55

	ld a,b			; $4d56
	ld (de),a		; $4d57
	sub TILEINDEX_RED_TOGGLE_FLOOR			; $4d58
	set 7,a			; $4d5a
	ld (wRotatingCubeColor),a		; $4d5c
	ret			; $4d5f


; d2: Drop a small key here when a colored block puzzle has been solved.
_interaction21_subid05:
	call _interactionDeleteAndRetIfItemFlagSet		; $4d60
	ld hl,@tileData		; $4d63
	jp _verifyTilesAndDropSmallKey		; $4d66

@tileData:
	.db TILEINDEX_RED_PUSHABLE_BLOCK     $49 $4b $69 $6b $ff
	.db TILEINDEX_YELLOW_PUSHABLE_BLOCK  $5a $ff
	.db TILEINDEX_BLUE_PUSHABLE_BLOCK    $4a $59 $5b $6a $00


; d2: Set trigger 0 when the colored flames are lit red.
_interaction21_subid06:
	ld b,$80		; $4d78
	jr ++			; $4d7a

; d1: Set trigger 0 when the colored flames are lit blue.
_interaction21_subid19:
	ld b,$82		; $4d7c
++
	ld a,(wRotatingCubeColor)		; $4d7e
	cp b			; $4d81
	ld a,$01		; $4d82
	jr z,+			; $4d84
	dec a			; $4d86
+
	ld (wActiveTriggers),a		; $4d87
	ret			; $4d8a


; Toggle a bit in wSwitchState based on whether a toggleable floor tile at position Y is
; blue. The bitmask to use is X.
_interaction21_subid07:
	ld e,Interaction.yh		; $4d8b
	ld a,(de)		; $4d8d
	ld c,a			; $4d8e
	ld b,>wRoomLayout		; $4d8f
	ld a,(bc)		; $4d91
	sub TILEINDEX_RED_TOGGLE_FLOOR			; $4d92
	cp $03			; $4d94
	ret nc			; $4d96

	ld a,(bc)		; $4d97
	cp TILEINDEX_RED_TOGGLE_FLOOR			; $4d98
	jr z,_unsetSwitch	; $4d9a
	cp TILEINDEX_YELLOW_TOGGLE_FLOOR			; $4d9c
	jr z,_unsetSwitch	; $4d9e

_setSwitch:
	ld e,Interaction.xh		; $4da0
	ld a,(de)		; $4da2
	ld hl,wSwitchState		; $4da3
	or (hl)			; $4da6
	ld (hl),a		; $4da7
	ret			; $4da8

_unsetSwitch:
	ld e,Interaction.xh		; $4da9
	ld a,(de)		; $4dab
	cpl			; $4dac
	ld hl,wSwitchState		; $4dad
	and (hl)		; $4db0
	ld (hl),a		; $4db1
	ret			; $4db2


; Toggle a bit in wSwitchState based on whether blue flames are lit. The bitmask to use is
; X.
_interaction21_subid08:
	ld hl,wRotatingCubeColor		; $4db3
	bit 7,(hl)		; $4db6
	ret z			; $4db8
	res 7,(hl)		; $4db9
	ld a,(hl)		; $4dbb
	cp $02			; $4dbc
	jr z,_setSwitch	; $4dbe
	jr _unsetSwitch		; $4dc0


; d3: Drop a small key when 3 blocks have been pushed.
_interaction21_subid09:
	call _interactionDeleteAndRetIfItemFlagSet		; $4dc2
	ld hl,@tileData		; $4dc5
	jp _verifyTilesAndDropSmallKey		; $4dc8

@tileData:
	.db TILEINDEX_PUSHABLE_BLOCK $3b $59 $5d $00


; d3: When an orb is hit, spawn an armos, as well as interaction which will spawn a chest
; when it's killed.
_interaction21_subid0a:
	call checkInteractionState		; $4dd0
	jr nz,@initialized	; $4dd3

	ld hl,wToggleBlocksState		; $4dd5
	res 4,(hl)		; $4dd8

	ld hl,objectData.moonlitGrotto_orb		; $4dda
	call parseGivenObjectData		; $4ddd

	call _interactionDeleteAndRetIfItemFlagSet		; $4de0
	call interactionIncState		; $4de3

@initialized:
	ld hl,wToggleBlocksState		; $4de6
	bit 4,(hl)		; $4de9
	ret z			; $4deb

	; Do something with the chest?
	ld a,$01		; $4dec
	ld ($cca2),a		; $4dee

	ld hl,objectData.moonlitGrotto_onOrbActivation		; $4df1
	call parseGivenObjectData		; $4df4

	jp interactionDelete		; $4df7


; Unused? A chest appears when 4 torches in a diamond formation are lit?
_interaction21_subid0b:
	call checkInteractionState		; $4dfa
	jr nz,@initialized	; $4dfd

	call getThisRoomFlags		; $4dff
	and $80			; $4e02
	jp nz,interactionDelete		; $4e04

	ld hl,objectData.objectData77d4		; $4e07
	call parseGivenObjectData		; $4e0a

	ldbc $4b,$35		; $4e0d
	call _makeTorchAtPositionTemporarilyLightable		; $4e10
	jp nz,interactionDelete		; $4e13

	ldbc $4b,$53		; $4e16
	call _makeTorchAtPositionTemporarilyLightable		; $4e19
	jp nz,interactionDelete		; $4e1c

	ldbc $4b,$57		; $4e1f
	call _makeTorchAtPositionTemporarilyLightable		; $4e22
	jp nz,interactionDelete		; $4e25

	ldbc $4b,$75		; $4e28
	call _makeTorchAtPositionTemporarilyLightable		; $4e2b
	jp nz,interactionDelete		; $4e2e

	call interactionIncState		; $4e31

@initialized:
	ld a,(wNumTorchesLit)		; $4e34
	cp $04			; $4e37
	ret nz			; $4e39
	ld hl,wDisabledObjects		; $4e3a
	set 3,(hl)		; $4e3d
	call getThisRoomFlags		; $4e3f
	set 7,(hl)		; $4e42
	ld a,$01		; $4e44
	ld (wActiveTriggers),a		; $4e46
	jp interactionDelete		; $4e49


; d3: 4 armos spawn when trigger 0 is activated.
_interaction21_subid0c:
	ld a,(wActiveTriggers)		; $4e4c
	or a			; $4e4f
	ret z			; $4e50
	ld ($cca2),a		; $4e51
	ld hl,objectData.moonlitGrotto_onArmosSwitchPressed		; $4e54
	call parseGivenObjectData		; $4e57
	jp interactionDelete		; $4e5a


; d3: Crystal breakage handler
_interaction21_subid0d:
	ld e,Interaction.state		; $4e5d
	ld a,(de)		; $4e5f
	rst_jumpTable			; $4e60
	.dw @state0
	.dw @state1
	.dw interactionRunScript
	.dw @state3

@state0:
	ld a,GLOBALFLAG_D3_CRYSTALS		; $4e69
	call checkGlobalFlag		; $4e6b
	jp nz,interactionDelete		; $4e6e
	call getThisRoomFlags		; $4e71
	and $40			; $4e74
	jp nz,interactionDelete		; $4e76

	ld a,(wSwitchState)		; $4e79
	ld e,Interaction.counter2		; $4e7c
	ld (de),a		; $4e7e
	jp interactionIncState		; $4e7f

@state1:
	ld a,(wSwitchState)		; $4e82
	ld b,a			; $4e85
	ld e,Interaction.counter2		; $4e86
	ld a,(de)		; $4e88
	cp b			; $4e89
	ret z			; $4e8a

	ld a,(wLinkDeathTrigger)		; $4e8b
	or a			; $4e8e
	ret nz			; $4e8f

	inc a			; $4e90
	ld (wDisabledObjects),a		; $4e91
	ld (wMenuDisabled),a		; $4e94
	ld (wDisableScreenTransitions),a		; $4e97
	ld (wcc90),a		; $4e9a

	ld hl,moonlitGrottoScript_brokeCrystal		; $4e9d
	call interactionSetScript		; $4ea0
	call interactionRunScript		; $4ea3
	jp interactionIncState		; $4ea6

@state3:
	ld a,(wSwitchState)		; $4ea9
	and $f0			; $4eac
	cp $f0			; $4eae
	jr nz,@enableControl	; $4eb0

	ld a,$02		; $4eb2
	ld (wScreenShakeMagnitude),a		; $4eb4

	ld hl,moonlitGrottoScript_brokeAllCrystals		; $4eb7
	call interactionSetScript		; $4eba

	ld e,Interaction.state		; $4ebd
	ld a,$02		; $4ebf
	ld (de),a		; $4ec1

	xor a			; $4ec2
	ld (wSpinnerState),a		; $4ec3
	ret			; $4ec6

@enableControl:
	jpab scriptHlp.moonlitGrotto_enableControlAfterBreakingCrystal		; $4ec7


; d3: Small key falls when a block is pushed into place
_interaction21_subid0e:
	call _interactionDeleteAndRetIfItemFlagSet		; $4ecf
	ld hl,wRoomLayout+$4a		; $4ed2
	ld a,(hl)		; $4ed5
	cp $2a			; $4ed6
	ret nz			; $4ed8
	jp _spawnSmallKeyFromCeiling		; $4ed9


; d4: A door opens when a certain floor pattern is achieved
_interaction21_subid0f:
	call interactionDeleteAndRetIfEnabled02		; $4edc
	ld hl,@tileData		; $4edf
	call _verifyTiles		; $4ee2
	ld a,$01		; $4ee5
	jr z,+			; $4ee7
	dec a			; $4ee9
+
	ld (wActiveTriggers),a		; $4eea
	ret			; $4eed

@tileData:
	.db TILEINDEX_RED_TOGGLE_FLOOR    $43 $45 $64 $ff
	.db TILEINDEX_YELLOW_TOGGLE_FLOOR $54 $63 $65 $ff
	.db TILEINDEX_BLUE_TOGGLE_FLOOR   $44 $53 $55 $00


; d4: A small key falls when a certain froor pattern is achieved
_interaction21_subid10:
	call interactionDeleteAndRetIfEnabled02		; $4efd
	call _interactionDeleteAndRetIfItemFlagSet		; $4f00
	ld hl,@tileData		; $4f03
	jp _verifyTilesAndDropSmallKey		; $4f06

@tileData:
	.db TILEINDEX_RED_TOGGLE_FLOOR  $54 $58 $ff
	.db TILEINDEX_BLUE_TOGGLE_FLOOR $55 $57 $00


; Tile-filling puzzle: when all the blue turns red, a chest will spawn here.
_interaction21_subid11:
	call interactionDeleteAndRetIfEnabled02		; $4f11
	call _interactionDeleteAndRetIfItemFlagSet		; $4f14

	ld a,TILEINDEX_BLUE_FLOOR		; $4f17
	call findTileInRoom		; $4f19
	ret z			; $4f1c

spawnChestAndDeleteSelf:
	ld a,SND_SOLVEPUZZLE		; $4f1d
	call playSound		; $4f1f
	call objectGetTileAtPosition		; $4f22
	ld c,l			; $4f25
	ld a,TILEINDEX_CHEST		; $4f26
	call setTile		; $4f28
	call objectCreatePuff		; $4f2b
	jp interactionDelete		; $4f2e


; d4: A chest spawns here when the torches light up with the color blue.
_interaction21_subid12:
	call _interactionDeleteAndRetIfItemFlagSet		; $4f31
	ld a,(wRotatingCubeColor)		; $4f34
	bit 7,a			; $4f37
	ret z			; $4f39
	and $03			; $4f3a
	cp $02			; $4f3c
	ret nz			; $4f3e
	jr spawnChestAndDeleteSelf		; $4f3f


; d5: A chest spawns here when all the spaces around the owl statue are filled.
_interaction21_subid13:
	call interactionDeleteAndRetIfEnabled02		; $4f41
	call _interactionDeleteAndRetIfItemFlagSet		; $4f44
	ld b,>wRoomLayout		; $4f47
	ld hl,@positionsToCheck		; $4f49
@next:
	ldi a,(hl)		; $4f4c
	or a			; $4f4d
	jr z,spawnChestAndDeleteSelf	; $4f4e
	ld c,a			; $4f50
	ld a,(bc)		; $4f51
	sub TILEINDEX_RED_PUSHABLE_BLOCK			; $4f52
	cp $03			; $4f54
	jr c,@next		; $4f56
	ret			; $4f58

@positionsToCheck: ; The positions in a circle around the owl statue
	.db $47 $48 $49 $57 $59 $67 $68 $69 $00


; d5: A chest spawns here when two blocks are pushed to the right places
_interaction21_subid14:
	call interactionDeleteAndRetIfEnabled02		; $4f62
	call _interactionDeleteAndRetIfItemFlagSet		; $4f65
	ld hl,@tileData		; $4f68
	call _verifyTiles		; $4f6b
	ret nz			; $4f6e
	jp spawnChestAndDeleteSelf		; $4f6f

@tileData:
	.db TILEINDEX_PUSHABLE_STATUE  $45 $49 $00


; d5: Cane of Somaria chest spawns here when blocks are pushed into a pattern
_interaction21_subid15:
	call interactionDeleteAndRetIfEnabled02		; $4f76
	call _interactionDeleteAndRetIfItemFlagSet		; $4f79
	ld hl,@tileData		; $4f7c
	call _verifyTiles		; $4f7f
	ret nz			; $4f82
	jp spawnChestAndDeleteSelf		; $4f83

@tileData:
	.db TILEINDEX_RED_PUSHABLE_BLOCK    $54 $62 $ff
	.db TILEINDEX_YELLOW_PUSHABLE_BLOCK $33 $52 $ff
	.db TILEINDEX_BLUE_PUSHABLE_BLOCK   $44 $73 $00


; d5: Sets floor tiles to show a pattern when a switch is held down.
_interaction21_subid16:
	call interactionDeleteAndRetIfEnabled02		; $4f92
	ld e,Interaction.state		; $4f95
	ld a,(de)		; $4f97
	rst_jumpTable			; $4f98
	.dw @state0
	.dw _interaction21_subid16_state1

@state0:
	ld a,(wActiveTriggers)		; $4f9d
	or a			; $4fa0
	ret z			; $4fa1

	call interactionIncState		; $4fa2

	ld c,$5c		; $4fa5
	ld a,TILEINDEX_RED_TOGGLE_FLOOR		; $4fa7
	call _setTileWithPuff		; $4fa9

	ld c,$6a		; $4fac
	ld a,TILEINDEX_RED_TOGGLE_FLOOR		; $4fae
	call _setTileWithPuff		; $4fb0

	ld c,$3b		; $4fb3
	ld a,TILEINDEX_YELLOW_TOGGLE_FLOOR		; $4fb5
	call _setTileWithPuff		; $4fb7

	ld c,$5a		; $4fba
	ld a,TILEINDEX_YELLOW_TOGGLE_FLOOR		; $4fbc
	call _setTileWithPuff		; $4fbe

	ld c,$4c		; $4fc1
	ld a,TILEINDEX_BLUE_TOGGLE_FLOOR		; $4fc3
	call _setTileWithPuff		; $4fc5

	ld c,$7b		; $4fc8
	ld a,TILEINDEX_BLUE_TOGGLE_FLOOR		; $4fca
	jr _setTileWithPuff		; $4fcc

_setTileToStandardFloor:
	ld a,TILEINDEX_STANDARD_FLOOR		; $4fce

_setTileWithPuff:
	call setTile		; $4fd0

;;
; @param	c	Position to create puff at
; @addr{4fd3}
_createPuffAt:
	call getFreeInteractionSlot		; $4fd3
	ret nz			; $4fd6
	ld (hl),INTERACID_PUFF		; $4fd7
	ld l,Interaction.yh		; $4fd9
	jp setShortPosition_paramC		; $4fdb

_interaction21_subid16_state1:
	ld a,(wActiveTriggers)		; $4fde
	or a			; $4fe1
	ret nz			; $4fe2

	ld c,$5c		; $4fe3
	call _setTileToStandardFloor		; $4fe5
	ld c,$6a		; $4fe8
	call _setTileToStandardFloor		; $4fea
	ld c,$3b		; $4fed
	call _setTileToStandardFloor		; $4fef
	ld c,$5a		; $4ff2
	call _setTileToStandardFloor		; $4ff4
	ld c,$4c		; $4ff7
	call _setTileToStandardFloor		; $4ff9
	ld c,$7b		; $4ffc
	call _setTileToStandardFloor		; $4ffe

	ld e,Interaction.state		; $5001
	xor a			; $5003
	ld (de),a		; $5004
	ret			; $5005


; Create a chest at position Y which appears when [wActiveTriggers] == X, but which also
; disappears when the trigger is released.
_interaction21_subid17:
	call interactionDeleteAndRetIfEnabled02		; $5006
	call getThisRoomFlags		; $5009
	and ROOMFLAG_ITEM			; $500c
	jp nz,interactionDelete		; $500e

	ld e,Interaction.xh		; $5011
	ld a,(de)		; $5013
	ld b,a			; $5014
	ld a,(wActiveTriggers)		; $5015
	cp b			; $5018
	jr nz,@triggerInactive	; $5019

@triggerActive:
	ld e,Interaction.yh		; $501b
	ld a,(de)		; $501d
	ld c,a			; $501e
	ld b,>wRoomLayout		; $501f
	ld a,(bc)		; $5021
	cp TILEINDEX_CHEST			; $5022
	ret z			; $5024

	ld a,TILEINDEX_CHEST		; $5025
	call setTile		; $5027
	call _createPuffAt		; $502a
	ld a,SND_SOLVEPUZZLE		; $502d
	jp playSound		; $502f

@triggerInactive:
	ld e,Interaction.yh		; $5032
	ld a,(de)		; $5034
	ld c,a			; $5035
	ld b,>wRoomLayout		; $5036
	ld a,(bc)		; $5038
	cp TILEINDEX_CHEST			; $5039
	ret nz			; $503b

	; Retrieve whatever tile was there before the chest
	ld a,:w3RoomLayoutBuffer		; $503c
	ld ($ff00+R_SVBK),a	; $503e
	ld b,>w3RoomLayoutBuffer		; $5040
	ld a,(bc)		; $5042
	ld l,a			; $5043
	xor a			; $5044
	ld ($ff00+R_SVBK),a	; $5045

	ld a,l			; $5047
	call setTile		; $5048
	jp _createPuffAt		; $504b


; d3: Calculate the value for [wSwitchState] based on which crystals are broken.
_interaction21_subid18:
	call getThisRoomFlags		; $504e
	ld b,$00		; $5051

	ld l,$5d		; $5053
	bit 6,(hl)		; $5055
	jr z,+			; $5057
	set 4,b			; $5059
+
	ld l,$5f		; $505b
	bit 6,(hl)		; $505d
	jr z,+			; $505f
	set 5,b			; $5061
+
	ld l,$61		; $5063
	bit 6,(hl)		; $5065
	jr z,+			; $5067
	set 6,b			; $5069
+
	ld l,$63		; $506b
	bit 6,(hl)		; $506d
	jr z,+			; $506f
	set 7,b			; $5071
+
	ld a,(wSwitchState)		; $5073
	or b			; $5076
	ld (wSwitchState),a		; $5077
	jp interactionDelete		; $507a


;;
; @addr{507d}
_interactionDeleteAndRetIfItemFlagSet:
	call getThisRoomFlags		; $507d
	and ROOMFLAG_ITEM			; $5080
	ret z			; $5082
	pop hl			; $5083
	jp interactionDelete		; $5084

;;
; @addr{5087}
_spawnSmallKeyFromCeiling:
	ldbc TREASURE_SMALL_KEY, $01		; $5087
	call createTreasure		; $508a
	ret nz			; $508d
	call objectCopyPosition		; $508e
	jp interactionDelete		; $5091

;;
; Verifies that certain tiles in the room layout equal specified values.
;
; @param	hl	Data structure where the first byte is a tile index, and
;			subsequent bytes are positions where the tile is expected to equal
;			that index. Value $ff starts a new "group", and $00 ends the
;			structure.
; @param[out]	zflag	Set if the tiles all match the expected values.
; @addr{5094}
_verifyTiles:
	ld b,>wRoomLayout		; $5094
@nextTileIndex:
	ldi a,(hl)		; $5096
	or a			; $5097
	ret z			; $5098
	ld e,a			; $5099
@nextPosition:
	ldi a,(hl)		; $509a
	ld c,a			; $509b
	or a			; $509c
	ret z			; $509d
	inc a			; $509e
	jr z,@nextTileIndex	; $509f
	ld a,(bc)		; $50a1
	cp e			; $50a2
	ret nz			; $50a3
	jr @nextPosition		; $50a4

;;
; @param	b	Number of frames it can stay lit before burning out
; @param	c	Position
; @param[out]	zflag	Set if the part object was created successfully
; @addr{50a6}
_makeTorchAtPositionTemporarilyLightable:
	call getFreePartSlot		; $50a6
	ret nz			; $50a9

	ld (hl),PARTID_06		; $50aa
	inc l			; $50ac
	ld (hl),$01		; $50ad
	ld l,Part.counter2		; $50af
	ld (hl),b		; $50b1
	ld l,Part.yh		; $50b2
	call setShortPosition_paramC		; $50b4
	xor a			; $50b7
	ret			; $50b8


; ==============================================================================
; INTERACID_FLOOR_COLOR_CHANGER
; ==============================================================================
interactionCode22:
	ld e,Interaction.subid		; $50b9
	ld a,(de)		; $50bb
	rst_jumpTable			; $50bc
	.dw @subid0
	.dw @subid1

; Subid 0: the "controller"; detects when the tile has been changed.
@subid0:
	call checkInteractionState		; $50c1
	jr nz,++		; $50c4

	call objectGetTileAtPosition		; $50c6
	ld e,Interaction.var03		; $50c9
	ld (de),a		; $50cb
	call interactionIncState		; $50cc
++
	; Check if the tile changed color
	call objectGetTileAtPosition		; $50cf
	ld e,Interaction.var03		; $50d2
	ld a,(de)		; $50d4
	cp (hl)			; $50d5
	ret z			; $50d6

	ld a,(hl)		; $50d7
	sub TILEINDEX_RED_TOGGLE_FLOOR			; $50d8
	cp $03			; $50da
	ret nc			; $50dc

	ld a,(hl)		; $50dd
	ld (de),a		; $50de
	sub TILEINDEX_RED_TOGGLE_FLOOR			; $50df
	add TILEINDEX_RED_FLOOR			; $50e1
	ld b,a			; $50e3
	call getFreeInteractionSlot		; $50e4
	ret nz			; $50e7

	ld (hl),INTERACID_FLOOR_COLOR_CHANGER		; $50e8
	inc l			; $50ea
	ld (hl),$01 ; [subid] = $01

	; Set var03 to the tile index to convert tiles to
	ld l,Interaction.var03		; $50ed
	ld (hl),b		; $50ef

	jp objectCopyPosition		; $50f0


; Subid 1: performs the updates to all tiles in the room in a random order.
@subid1:
	call checkInteractionState		; $50f3
	jr nz,@@initialized	; $50f6

	call objectGetTileAtPosition		; $50f8
	ld e,Interaction.var30		; $50fb
	ld (de),a		; $50fd
	call interactionIncState		; $50fe

	ld l,Interaction.counter1		; $5101
	ld (hl),$ff		; $5103

	; Generate all values from $00-$ff in a random order, and copy those values to
	; wBigBuffer.
	callab bank2.generateRandomBuffer		; $5105
	ld a,:w4RandomBuffer		; $510d
	ld ($ff00+R_SVBK),a	; $510f
	ld hl,w4RandomBuffer		; $5111
	ld de,wBigBuffer		; $5114
	ld b,$00		; $5117
	call copyMemory		; $5119
	ld a,$01		; $511c
	ld ($ff00+R_SVBK),a	; $511e

	ldh a,(<hActiveObject)	; $5120
	ld d,a			; $5122

@@initialized:
	call objectGetTileAtPosition		; $5123
	ld e,Interaction.var30		; $5126
	ld a,(de)		; $5128
	cp (hl)			; $5129
	jp z,++			; $512a
	ld a,(hl)		; $512d
	cp TILEINDEX_SOMARIA_BLOCK			; $512e
	jp nz,interactionDelete		; $5130
++
	ld a,l			; $5133
	ldh (<hFF8C),a	; $5134
	call @convertNextTile		; $5136
	jr z,@done	; $5139
	call @convertNextTile		; $513b
	jr z,@done	; $513e
	call @convertNextTile		; $5140
	jr z,@done	; $5143
	call @convertNextTile		; $5145
	ret nz			; $5148
@done:
	call @convertNextTile		; $5149
	jp interactionDelete		; $514c

;;
; @param	hFF8C	Position of this object
; @param[out]	zflag	Set if we've converted the last tile
; @addr{514f}
@convertNextTile:
	ld e,Interaction.counter1		; $514f
	ld a,(de)		; $5151
	ld hl,wBigBuffer		; $5152
	rst_addAToHl			; $5155
	ldh a,(<hFF8C)	; $5156
	ld c,a			; $5158
	ld a,(hl) ; Get next position to update in 'a'

	; Check that the position is in-bounds, and is not this object's position
	cp LARGE_ROOM_HEIGHT*16 - 17			; $515a
	jr nc,@decCounter1	; $515c
	cp c			; $515e
	jr z,@decCounter1	; $515f

	; Position can't be on the screen edge (but it doesn't appear to check the right
	; edge?)
	and $0f			; $5161
	jr z,@decCounter1	; $5163
	ld a,(hl)		; $5165
	and $f0			; $5166
	jr z,@decCounter1	; $5168
	cp LARGE_ROOM_HEIGHT*16 - 16			; $516a
	jr z,@decCounter1	; $516c

	; Check if this is a tile that should be replaced
	ld a,(hl)		; $516e
	ld l,a			; $516f
	ld h,>wRoomLayout		; $5170
	ld a,(hl)		; $5172
	sub TILEINDEX_RED_FLOOR			; $5173
	cp $03			; $5175
	jr nc,@notColoredFloor	; $5177

	; Replace the tile
	ld e,Interaction.var03		; $5179
	ld a,(de)		; $517b
	ld c,l			; $517c
	call setTile		; $517d
@decCounter1:
	jp interactionDecCounter1		; $5180

@notColoredFloor:
	; If it's not a colored floor, we should at least change the tile "underneath" it
	; in w3RoomLayoutBuffer, in case it's pushable or something.
	ld e,Interaction.var03		; $5183
	ld a,(de)		; $5185
	ld b,a			; $5186
	ld c,l			; $5187
	call setTileInRoomLayoutBuffer		; $5188
	jp interactionDecCounter1		; $518b

; ==============================================================================
; INTERACID_EXTENDABLE_BRIDGE
; ==============================================================================
interactionCode23:
	ld e,Interaction.state		; $518e
	ld a,(de)		; $5190
	rst_jumpTable			; $5191
	.dw @state0
	.dw @state1
	.dw @state2

@state0:
	ld e,Interaction.subid		; $5198
	ld a,(de)		; $519a
	ld b,a			; $519b
	and $07			; $519c
	ld hl,bitTable		; $519e
	add l			; $51a1
	ld l,a			; $51a2
	ld a,(hl)		; $51a3
	inc e			; $51a4
	ld (de),a ; [var03] = bitmask corresponding to [subid]

	; Check whether the tile here is a bridge; go to state 2 if so, state 1 otherwise
	ld e,Interaction.yh		; $51a6
	ld a,(de)		; $51a8
	ld c,a			; $51a9
	ld b,>wRoomLayout		; $51aa
	ld a,(bc)		; $51ac
	sub TILEINDEX_VERTICAL_BRIDGE			; $51ad
	sub $06			; $51af
	ld a,$02		; $51b1
	jr c,+			; $51b3
	dec a			; $51b5
+
	ld e,Interaction.state		; $51b6
	ld (de),a		; $51b8
	ld e,Interaction.var30		; $51b9
	ld a,(wSwitchState)		; $51bb
	ld (de),a		; $51be
	ret			; $51bf

; State 1: waiting for switch to toggle to create bridge
@state1:
	ld e,Interaction.state2		; $51c0
	ld a,(de)		; $51c2
	rst_jumpTable			; $51c3
	.dw @state1Substate0
	.dw @state1Substate1

@state1Substate0:
	call @checkSwitchStateChanged		; $51c8
	ret z			; $51cb
	ld hl,@bridgeCreationData		; $51cc

@startLoadingBridgeData:
	ld e,Interaction.var30		; $51cf
	ld a,(wSwitchState)		; $51d1
	ld (de),a		; $51d4

	ld e,Interaction.xh		; $51d5
	ld a,(de)		; $51d7
	rst_addDoubleIndex			; $51d8
	ldi a,(hl)		; $51d9
	ld h,(hl)		; $51da
	ld l,a			; $51db

	ldi a,(hl)		; $51dc
	ld e,Interaction.var31		; $51dd
	ld (de),a		; $51df
	ld e,Interaction.relatedObj2		; $51e0
	ld a,l			; $51e2
	ld (de),a		; $51e3
	inc e			; $51e4
	ld a,h			; $51e5
	ld (de),a		; $51e6
	ld a,$0a		; $51e7
	ld e,Interaction.counter1		; $51e9
	ld (de),a		; $51eb
	jp interactionIncState2		; $51ec

@state1Substate1:
	call interactionDecCounter1		; $51ef
	ret nz			; $51f2
	ld (hl),$0a		; $51f3
	call @updateNextTile		; $51f5
	ld a,c			; $51f8
	inc a			; $51f9
	jr z,@gotoNextState	; $51fa
	ld e,Interaction.var31		; $51fc
	ld a,(de)		; $51fe
	call setTile		; $51ff
	ld a,SND_DOORCLOSE		; $5202
	jp playSound		; $5204

@gotoNextState:
	call interactionIncState		; $5207
	inc l			; $520a
	ld (hl),$00		; $520b
	ret			; $520d

; State 2: waiting for switch to toggle to remove bridge
@state2:
	ld e,Interaction.state2		; $520e
	ld a,(de)		; $5210
	rst_jumpTable			; $5211
	.dw @state2Substate0
	.dw @state2Substate1

@state2Substate0:
	call @checkSwitchStateChanged		; $5216
	ret z			; $5219
	ld hl,@bridgeRemovalData		; $521a
	jr @startLoadingBridgeData		; $521d

@state2Substate1:
	call interactionDecCounter1		; $521f
	ret nz			; $5222
	ld (hl),$0a		; $5223

	call @updateNextTile		; $5225
	ld a,c			; $5228
	inc a			; $5229
	jr z,@gotoState1	; $522a
	ld e,Interaction.var31		; $522c
	ld a,(de)		; $522e
	call setTile		; $522f
	ld a,SND_DOORCLOSE		; $5232
	jp playSound		; $5234

@gotoState1:
	ld h,d			; $5237
	ld l,Interaction.state		; $5238
	ld (hl),$01		; $523a
	inc l			; $523c
	ld (hl),$00		; $523d
	ret			; $523f

;;
; @param[out]	zflag	nz if the switch has been toggled
; @addr{5240}
@checkSwitchStateChanged:
	ld a,(wSwitchState)		; $5240
	ld b,a			; $5243
	ld e,Interaction.var30		; $5244
	ld a,(de)		; $5246
	xor b			; $5247
	ld b,a			; $5248
	ld e,Interaction.var03		; $5249
	ld a,(de)		; $524b
	and b			; $524c
	ret			; $524d

;;
; @param[out]	c	Next byte
; @addr{524e}
@updateNextTile:
	ld h,d			; $524e
	ld l,Interaction.relatedObj2		; $524f
	ld e,l			; $5251
	ldi a,(hl)		; $5252
	ld h,(hl)		; $5253
	ld l,a			; $5254

	ldi a,(hl)		; $5255
	ld c,a			; $5256

	ld a,l			; $5257
	ld (de),a		; $5258
	inc e			; $5259
	ld a,h			; $525a
	ld (de),a		; $525b
	ret			; $525c


; Which data is read from here depends on the value of "Interaction.xh".
@bridgeCreationData:
	.dw @creation0
	.dw @creation1
	.dw @creation2
	.dw @creation3
	.dw @creation4
	.dw @creation5
	.dw @creation6

; Data format:
;   First byte is the tile index to create for the bridge.
;   Subsequent bytes are positions at which to create that tile until it reaches $ff.

@creation0:
	.db TILEINDEX_VERTICAL_BRIDGE   $43 $53 $63 $ff
@creation1:
	.db TILEINDEX_HORIZONTAL_BRIDGE $76 $77 $78 $79 $ff
@creation2:
	.db TILEINDEX_HORIZONTAL_BRIDGE $39 $38 $37 $36 $ff
@creation3:
	.db TILEINDEX_VERTICAL_BRIDGE   $42 $52 $62 $ff
@creation4:
	.db TILEINDEX_VERTICAL_BRIDGE   $4c $5c $6c $ff
@creation5:
	.db TILEINDEX_HORIZONTAL_BRIDGE $2a $29 $28 $27 $ff
@creation6:
	.db TILEINDEX_VERTICAL_BRIDGE   $3d $4d $5d $6d $ff


@bridgeRemovalData:
	.dw @removal0
	.dw @removal1
	.dw @removal2
	.dw @removal3
	.dw @removal4
	.dw @removal5
	.dw @removal6

; Data format is the same as above.
; TILEINDEX_HOLE+1 is a hole that's completely black (doesn't have "ground" surrounding
; it.)

@removal0:
	.db TILEINDEX_HOLE+1  $63 $53 $43 $ff
@removal1:
	.db TILEINDEX_HOLE+1  $79 $78 $77 $76 $ff
@removal2:
	.db TILEINDEX_HOLE+1  $36 $37 $38 $39 $ff
@removal3:
	.db TILEINDEX_HOLE+1  $62 $52 $42 $ff
@removal4:
	.db TILEINDEX_HOLE+1  $6c $5c $4c $ff
@removal5:
	.db TILEINDEX_HOLE+1  $27 $28 $29 $2a $ff
@removal6:
	.db TILEINDEX_HOLE+1  $6d $5d $4d $3d $ff


; ==============================================================================
; INTERACID_TRIGGER_TRANSLATOR
; ==============================================================================
interactionCode24:
	call interactionDeleteAndRetIfEnabled02		; $52c7
	ld e,Interaction.subid		; $52ca
	ld a,(de)		; $52cc
	and $0f			; $52cd
	rst_jumpTable			; $52cf
	.dw @subid0
	.dw @subid1
	.dw @subid2

; Subid 0: control a bit in wActiveTriggers based on wToggleBlocksState.
@subid0:
	ld a,(wToggleBlocksState)		; $52d6
	ld c,a			; $52d9

@label_08_081:
	ld e,Interaction.subid		; $52da
	ld a,(de)		; $52dc
	swap a			; $52dd
	and $07			; $52df
	ld hl,bitTable		; $52e1
	add l			; $52e4
	ld l,a			; $52e5

	ld a,c			; $52e6
	and (hl)		; $52e7
	ld b,a			; $52e8
	ld a,(hl)		; $52e9
	cpl			; $52ea
	ld c,a			; $52eb
	ld a,(wActiveTriggers)		; $52ec
	and c			; $52ef
	or b			; $52f0
	ld (wActiveTriggers),a		; $52f1
	ret			; $52f4

; Subid 0: control a bit in wActiveTriggers based on wSwitchState.
@subid1:
	ld a,(wSwitchState)		; $52f5
	ld c,a			; $52f8
	jr @label_08_081		; $52f9

; Subid 2: check that [wNumLitTorches] == Y.
@subid2:
	ld e,Interaction.yh		; $52fb
	ld a,(de)		; $52fd
	ld b,a			; $52fe
	ld e,Interaction.xh		; $52ff
	ld a,(de)		; $5301
	ld c,a			; $5302
	ld a,(wNumTorchesLit)		; $5303
	cp b			; $5306
	jr nz,++		; $5307
	ld a,(wActiveTriggers)		; $5309
	or c			; $530c
	ld (wActiveTriggers),a		; $530d
	ret			; $5310
++
	ld a,c			; $5311
	cpl			; $5312
	ld c,a			; $5313
	ld a,(wActiveTriggers)		; $5314
	and c			; $5317
	ld (wActiveTriggers),a		; $5318
	ret			; $531b


; ==============================================================================
; INTERACID_TILE_FILLER
; ==============================================================================
interactionCode25:
	call returnIfScrollMode01Unset		; $531c
	ld e,Interaction.state		; $531f
	ld a,(de)		; $5321
	rst_jumpTable			; $5322
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $5327
	ld (de),a		; $5329

	call objectGetTileAtPosition		; $532a
	ld c,l			; $532d
	ld a,TILEINDEX_YELLOW_FLOOR		; $532e
	call setTile		; $5330

	ld a,c			; $5333
	ld e,Interaction.var30		; $5334
	ld (de),a		; $5336

	call getFreeInteractionSlot		; $5337
	jr nz,@state1	; $533a
	ld (hl),INTERACID_PUFF		; $533c
	ld l,Interaction.yh		; $533e
	call setShortPosition_paramC		; $5340

@state1:
	; Check if Link's position has changed
	callab getLinkTilePosition		; $5343
	ld e,Interaction.var30		; $534b
	ld a,(de)		; $534d
	cp l			; $534e
	ret z			; $534f

	; Check that the position changed by exactly one tile horizontally or vertically
	ld b,a			; $5350
	ld a,l			; $5351
	add $f0			; $5352
	cp b			; $5354
	jr z,@updateFloor	; $5355
	ld a,l			; $5357
	inc a			; $5358
	cp b			; $5359
	jr z,@updateFloor	; $535a
	ld a,l			; $535c
	add $10			; $535d
	cp b			; $535f
	jr z,@updateFloor	; $5360
	ld a,l			; $5362
	dec a			; $5363
	cp b			; $5364
	ret nz			; $5365

@updateFloor:
	ld h,>wRoomLayout		; $5366
	ld a,(hl)		; $5368
	cp TILEINDEX_BLUE_FLOOR			; $5369
	ret nz			; $536b

	ld a,l			; $536c
	ldh (<hFF8B),a	; $536d
	ld e,Interaction.var30		; $536f
	ld (de),a		; $5371

	; Update the tile at the old position
	ld c,b			; $5372
	ld a,TILEINDEX_RED_FLOOR		; $5373
	call setTile		; $5375

	; Update the tile at the new position
	ldh a,(<hFF8B)	; $5378
	ld c,a			; $537a
	ld a,TILEINDEX_YELLOW_FLOOR		; $537b
	call setTile		; $537d

	ld a,SND_GETSEED		; $5380
	jp playSound		; $5382


; ==============================================================================
; INTERACID_BIPIN
; ==============================================================================
interactionCode28:
	ld e,Interaction.state		; $5385
	ld a,(de)		; $5387
	rst_jumpTable			; $5388
	.dw @state0
	.dw @state1

@state0:
	call interactionInitGraphics		; $538d
	call interactionIncState		; $5390

	; Decide what script to load based on subid
	ld e,Interaction.subid		; $5393
	ld a,(de)		; $5395
	ld hl,@scriptTable		; $5396
	rst_addDoubleIndex			; $5399
	ldi a,(hl)		; $539a
	ld h,(hl)		; $539b
	ld l,a			; $539c
	call interactionSetScript		; $539d

	ld e,Interaction.subid		; $53a0
	ld a,(de)		; $53a2
	rst_jumpTable			; $53a3
	.dw @bipin0
	.dw @bipin1
	.dw @bipin1
	.dw @bipin1
	.dw @bipin1
	.dw @bipin2
	.dw @bipin1
	.dw @bipin1
	.dw @bipin1
	.dw @bipin1
	.dw @bipin3


; Bipin running around, baby just born
@bipin0:
	ld h,d			; $53ba
	ld l,Interaction.speed		; $53bb
	ld (hl),SPEED_100		; $53bd
	ld l,Interaction.angle		; $53bf
	ld (hl),$18		; $53c1

	ld l,Interaction.var3a		; $53c3
	ld a,$04		; $53c5
	ld (hl),a		; $53c7
	call interactionSetAnimation		; $53c8

	jp @updateCollisionAndVisibility		; $53cb


; Bipin gives you a random tip
@bipin1:
	ld a,$03		; $53ce
	call interactionSetAnimation		; $53d0
	jp @updateCollisionAndVisibility		; $53d3


; Bipin just moved to Labrynna/Holodrum?
@bipin2:
	ld a,$02		; $53d6
	call interactionSetAnimation		; $53d8
	jp @updateCollisionAndVisibility		; $53db


; "Past" version of Bipin who gives you a gasha seed
@bipin3:
	ld a,$09		; $53de
	call interactionSetAnimation		; $53e0
	jp @updateCollisionAndVisibility		; $53e3


@state1:
	ld e,Interaction.subid		; $53e6
	ld a,(de)		; $53e8
	rst_jumpTable			; $53e9
	.dw @bipinSubid0
	.dw @runScriptAndAnimate
	.dw @runScriptAndAnimate
	.dw @runScriptAndAnimate
	.dw @runScriptAndAnimate
	.dw @runScriptAndAnimate
	.dw @runScriptAndAnimate
	.dw @runScriptAndAnimate
	.dw @runScriptAndAnimate
	.dw @runScriptAndAnimate
	.dw @runScriptAndAnimate

@bipinSubid0:
	call @updateSpeed		; $5400

@runScriptAndAnimate:
	call interactionRunScript		; $5403
	jp @updateAnimation		; $5406

@updateAnimation:
	call interactionAnimate		; $5409

@updateCollisionAndVisibility:
	call objectPreventLinkFromPassing		; $540c
	jp objectSetPriorityRelativeToLink_withTerrainEffects		; $540f


; Bipin runs around like a madman when his baby is first born
@updateSpeed:
	call objectApplySpeed		; $5412
	ld e,Interaction.xh		; $5415
	ld a,(de)		; $5417
	sub $28			; $5418
	cp $30			; $541a
	ret c			; $541c

	; Reverse direction
	ld h,d			; $541d
	ld l,Interaction.angle		; $541e
	ld a,(hl)		; $5420
	xor $10			; $5421
	ld (hl),a		; $5423

	ld l,Interaction.var3a		; $5424
	ld a,(hl)		; $5426
	xor $01			; $5427
	ld (hl),a		; $5429
	jp interactionSetAnimation		; $542a


@scriptTable:
	.dw bipinScript0
	.dw bipinScript1
	.dw bipinScript1
	.dw bipinScript1
	.dw bipinScript1
	.dw bipinScript2
	.dw bipinScript1
	.dw bipinScript1
	.dw bipinScript1
	.dw bipinScript1
	.dw bipinScript3


; ==============================================================================
; INTERACID_ADLAR
; ==============================================================================
interactionCode29:
	call checkInteractionState		; $5443
	jr z,@state0		; $5446

@state1:
	call interactionRunScript		; $5448
	jp interactionAnimateAsNpc		; $544b

@state0:
	call interactionInitGraphics		; $544e
	call interactionIncState		; $5451

	; Decide on a value to write to var38; this will affect the script.

	ld a,GLOBALFLAG_FINISHEDGAME		; $5454
	call checkGlobalFlag		; $5456
	ld a,$04		; $5459
	jr nz,@setVar38		; $545b

	ld hl,wGroup4Flags+$fc		; $545d
	bit 7,(hl)		; $5460
	ld a,$03		; $5462
	jr nz,@setVar38		; $5464

	ld a,GLOBALFLAG_SAVED_NAYRU		; $5466
	call checkGlobalFlag		; $5468
	ld a,$02		; $546b
	jr nz,@setVar38		; $546d

	call getThisRoomFlags		; $546f
	bit 6,(hl)		; $5472
	ld a,$01		; $5474
	jr nz,@setVar38		; $5476
	xor a			; $5478
@setVar38:
	ld e,Interaction.var38		; $5479
	ld (de),a		; $547b
	call objectSetVisiblec2		; $547c

	ld hl,adlarScript		; $547f
	jp interactionSetScript		; $5482


; ==============================================================================
; INTERACID_LIBRARIAN
; ==============================================================================
interactionCode2a:
	call checkInteractionState		; $5485
	jr z,@state0		; $5488

@state1:
	call interactionRunScript		; $548a
	jp interactionAnimateAsNpc		; $548d

@state0:
	call interactionInitGraphics		; $5490
	call interactionIncState		; $5493

	ld l,Interaction.textID+1		; $5496
	ld (hl),>TX_2700		; $5498

	ld l,Interaction.collisionRadiusY		; $549a
	ld (hl),$0c		; $549c
	inc l			; $549e
	ld (hl),$06		; $549f

	ld a,GLOBALFLAG_WATER_POLLUTION_FIXED		; $54a1
	call checkGlobalFlag		; $54a3
	ld a,<TX_2715		; $54a6
	jr z,+			; $54a8
	ld a,<TX_2716		; $54aa
+
	ld e,Interaction.textID		; $54ac
	ld (de),a		; $54ae

	call objectSetVisiblec2		; $54af

	ld hl,librarianScript		; $54b2
	jp interactionSetScript		; $54b5


; ==============================================================================
; INTERACID_BLOSSOM
; ==============================================================================
interactionCode2b:
	ld e,Interaction.state		; $54b8
	ld a,(de)		; $54ba
	rst_jumpTable			; $54bb
	.dw @state0
	.dw @state1

@state0:
	call interactionInitGraphics		; $54c0
	ld a,>TX_4400		; $54c3
	call interactionSetHighTextIndex		; $54c5
	call interactionIncState		; $54c8

	ld e,Interaction.subid		; $54cb
	ld a,(de)		; $54cd
	ld hl,@scriptTable		; $54ce
	rst_addDoubleIndex			; $54d1
	ldi a,(hl)		; $54d2
	ld h,(hl)		; $54d3
	ld l,a			; $54d4
	call interactionSetScript		; $54d5

	ld e,Interaction.subid		; $54d8
	ld a,(de)		; $54da
	rst_jumpTable			; $54db
	.dw @initAnimation0
	.dw @initAnimation0
	.dw @initAnimation4
	.dw @initAnimation0
	.dw @initAnimation4
	.dw @initAnimation4
	.dw @initAnimation4
	.dw @initAnimation4
	.dw @initAnimation4
	.dw @initAnimation4

@initAnimation0:
	ld a,$00		; $54f0
	call interactionSetAnimation		; $54f2
	jp @updateCollisionAndVisibility		; $54f5

@initAnimation4:
	ld a,$04		; $54f8
	call interactionSetAnimation		; $54fa
	jp @updateCollisionAndVisibility		; $54fd

@state1:
	call interactionRunScript		; $5500
	jp @updateAnimation		; $5503

@updateAnimation:
	call interactionAnimate		; $5506

@updateCollisionAndVisibility:
	call objectPreventLinkFromPassing		; $5509
	jp objectSetPriorityRelativeToLink_withTerrainEffects		; $550c

@scriptTable:
	.dw blossomScript0
	.dw blossomScript1
	.dw blossomScript2
	.dw blossomScript3
	.dw blossomScript4
	.dw blossomScript5
	.dw blossomScript6
	.dw blossomScript7
	.dw blossomScript8
	.dw blossomScript9


; ==============================================================================
; INTERACID_VERAN_CUTSCENE_WALLMASTER
; ==============================================================================
interactionCode2c:
	ld e,Interaction.state		; $5523
	ld a,(de)		; $5525
	rst_jumpTable			; $5526
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $552b
	ld (de),a		; $552d
	call interactionInitGraphics		; $552e

	ld bc,$0140		; $5531
	call objectSetSpeedZ		; $5534
	ld l,Interaction.counter1		; $5537
	ld (hl),$14		; $5539
	ld l,Interaction.zh		; $553b
	ld (hl),$a0		; $553d

	call objectSetVisiblec3		; $553f

@state1:
	call interactionAnimate		; $5542
	ld e,Interaction.state2		; $5545
	ld a,(de)		; $5547
	rst_jumpTable			; $5548
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate0:
	call interactionDecCounter1		; $5551
	ret nz			; $5554
	jp interactionIncState2		; $5555

@substate1:
	ld c,$00		; $5558
	call objectUpdateSpeedZ_paramC		; $555a
	ret nz			; $555d
	ld a,$01		; $555e
	call interactionSetAnimation		; $5560
	jp interactionIncState2		; $5563

@substate2:
	ld e,Interaction.animParameter		; $5566
	ld a,(de)		; $5568
	bit 7,a			; $5569
	jp nz,interactionIncState2		; $556b

	or a			; $556e
	ret z			; $556f

	xor a			; $5570
	ld (w1Link.visible),a		; $5571
	ld a,$1e		; $5574
	ld e,Interaction.counter1		; $5576
	ld (de),a		; $5578
	ld a,SND_BOSS_DEAD		; $5579
	jp playSound		; $557b

@substate3:
	ld e,Interaction.counter1		; $557e
	ld a,(de)		; $5580
	or a			; $5581
	jr z,++			; $5582
	dec a			; $5584
	ld (de),a		; $5585
	ret			; $5586
++
	ld e,Interaction.zh		; $5587
	ld a,(de)		; $5589
	dec a			; $558a
	ld (de),a		; $558b
	cp $b0			; $558c
	ret nz			; $558e
	ld a,$08		; $558f
	ld (wTmpcbb5),a		; $5591
	jp interactionDelete		; $5594


; ==============================================================================
; INTERACID_VERAN_CUTSCENE_FACE
; ==============================================================================
interactionCode2d:
	ld e,Interaction.state		; $5597
	ld a,(de)		; $5599
	rst_jumpTable			; $559a
	.dw @state0
	.dw @state1
	.dw @state2

@state0:
	ld a,$01		; $55a1
	ld (de),a		; $55a3
	call interactionInitGraphics		; $55a4
	call interactionSetAlwaysUpdateBit		; $55a7
	ld a,PALH_87		; $55aa
	call loadPaletteHeader		; $55ac
	ld hl,veranFaceCutsceneScript		; $55af
	call interactionSetScript		; $55b2

@state2:
	ret			; $55b5

@state1:
	call interactionAnimate		; $55b6
	call interactionRunScript		; $55b9
	ret nc			; $55bc
	ld hl,@warpDestVariables		; $55bd
	call setWarpDestVariables		; $55c0
	xor a			; $55c3
	ld (wcc50),a		; $55c4
	jp interactionIncState		; $55c7

@warpDestVariables:
	.db $84 $d4 $0c $67 $03


; ==============================================================================
; INTERACID_OLD_MAN_WITH_RUPEES
; ==============================================================================
interactionCode2e:
	call checkInteractionState		; $55cf
	jr nz,@state1		; $55d2

@state0:
	inc a			; $55d4
	ld (de),a		; $55d5
	call interactionInitGraphics		; $55d6
	ld a,>TX_3300		; $55d9
	call interactionSetHighTextIndex		; $55db

	ld e,Interaction.subid		; $55de
	ld a,(de)		; $55e0
	ld hl,@scriptTable		; $55e1
	rst_addDoubleIndex			; $55e4
	ldi a,(hl)		; $55e5
	ld h,(hl)		; $55e6
	ld l,a			; $55e7
	call interactionSetScript		; $55e8

	ld h,d			; $55eb
	ld l,Interaction.yh		; $55ec
	ld (hl),$38		; $55ee
	ld l,Interaction.xh		; $55f0
	ld (hl),$28		; $55f2

@state1:
	call interactionRunScript		; $55f4
	jp npcFaceLinkAndAnimate		; $55f7

@scriptTable:
	.dw oldManScript_givesRupees
	.dw oldManScript_takesRupees


; ==============================================================================
; INTERACID_PLAY_NAYRU_MUSIC
; ==============================================================================
interactionCode2f:
	ld a,GLOBALFLAG_INTRO_DONE		; $55fe
	call checkGlobalFlag		; $5600
	jp nz,interactionDelete		; $5603
	ld hl,wActiveMusic		; $5606
	ld a,MUS_NAYRU		; $5609
	cp (hl)			; $560b
	jr z,+			; $560c

	ld (hl),a		; $560e
	call playSound		; $560f
+
	ld a,$02		; $5612
	call setMusicVolume		; $5614
	jp interactionDelete		; $5617


; ==============================================================================
; INTERACID_SHOOTING_GALLERY
; ==============================================================================
interactionCode30:
	ld e,Interaction.subid		; $561a
	ld a,(de)		; $561c
	rst_jumpTable			; $561d
	.dw shootingGalleryNpc
	.dw shootingGalleryNpc
	.dw shootingGalleryNpc
	.dw _shootingGalleryGame


;;
; Interaction $8b (goron elder) also calls this.
; @addr{5626}
shootingGalleryNpc:
	ld e,Interaction.state		; $5626
	ld a,(de)		; $5628
	rst_jumpTable			; $5629
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3

; State 0: initializing
@state0:
	ld a,$01		; $5632
	ld (de),a		; $5634
	call interactionInitGraphics		; $5635
	xor a			; $5638
	ld (wTmpcfc0.shootingGallery.disableGoronNpcs),a		; $5639
	call @setScript		; $563c

; State 1: waiting for player to talk to the npc and start the game
@state1:
	call interactionRunScript		; $563f
	jr nc,@updateAnimation	; $5642
	xor a			; $5644
	ld (wTmpcfc0.shootingGallery.gameStatus),a		; $5645
	call interactionIncState		; $5648

; State 2: waiting for the game to finish
@state2:
	ld a,(wTmpcfc0.shootingGallery.gameStatus)		; $564b
	or a			; $564e
	jr z,@updateAnimation	; $564f
	ld a,$01		; $5651
	call @setScript		; $5653
	call interactionIncState		; $5656

; State 3: waiting for "game wrapup" script to finish, then asks you to try again
@state3:
	call interactionRunScript		; $5659
	call c,@loadRetryScriptAndGotoState1		; $565c

@updateAnimation:
	ld e,Interaction.subid		; $565f
	ld a,(de)		; $5661
	cp $02			; $5662
	jp nz,interactionAnimateAsNpc		; $5664
	jp npcFaceLinkAndAnimate		; $5667

;;
; @addr{566a}
@loadRetryScriptAndGotoState1:
	ld h,d			; $566a
	ld l,Interaction.state		; $566b
	ld (hl),$01		; $566d
	ld a,$02		; $566f

;;
; @param	a	Script index.
; @addr{5671}
@setScript:
	; a *= 3
	ld b,a			; $5671
	add a			; $5672
	add b			; $5673

	ld h,d			; $5674
	ld l,Interaction.subid		; $5675
	add (hl)		; $5677
	ld hl,_shootingGalleryScriptTable		; $5678
	rst_addDoubleIndex			; $567b
	ldi a,(hl)		; $567c
	ld h,(hl)		; $567d
	ld l,a			; $567e
	jp interactionSetScript		; $567f

;;
; Interaction $30, subid $03 runs the shooting gallery game.
; It cycles through states 1-6 a total of 10 times.
; var3f is the round counter.
; @addr{5682}
_shootingGalleryGame:
	ld e,Interaction.state		; $5682
	ld a,(de)		; $5684
	rst_jumpTable			; $5685
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3
	.dw @state4
	.dw @state5
	.dw @state6

@state0:
	ld a,$01		; $5694
	ld (wTmpcfc0.shootingGallery.disableGoronNpcs),a		; $5696

	ld b,$0a		; $5699
	call shootingGallery_initializeGameRounds		; $569b

	; Initialize score
	xor a			; $569e
	ld (wTextNumberSubstitution),a		; $569f
	ld (wTextNumberSubstitution+1),a		; $56a2

	ld e,Interaction.var3f		; $56a5
	ld (de),a		; $56a7
	call interactionIncState		; $56a8

	ld l,Interaction.yh		; $56ab
	ld (hl),$2a		; $56ad
	ld l,Interaction.xh		; $56af
	ld (hl),$50		; $56b1

	ld l,Interaction.counter1		; $56b3
	ld (hl),$78		; $56b5

	ld a,SND_WHISTLE		; $56b7
	call playSound		; $56b9

@state1:
	call interactionDecCounter1		; $56bc
	ret nz			; $56bf

	; These variables will be set by the "ball" object later?
	xor a			; $56c0
	ld (wShootingGalleryBallStatus),a		; $56c1
	ld (wShootingGalleryccd5),a		; $56c4
	ld (wShootingGalleryHitTargets),a		; $56c7

	call interactionIncState		; $56ca

	ld l,Interaction.counter1		; $56cd
	ld (hl),$28		; $56cf
	ld a,SND_BASEBALL		; $56d1
	call playSound		; $56d3

@state2:
	call interactionDecCounter1		; $56d6
	ret nz			; $56d9

	call _shootingGallery_createPuffAtEachTargetPosition		; $56da
	call interactionIncState		; $56dd
	ld l,Interaction.counter1		; $56e0
	ld (hl),$0a		; $56e2
	ret			; $56e4

@state3:
	call interactionDecCounter1		; $56e5
	ret nz			; $56e8

	call _shootingGallery_setRandomTargetLayout		; $56e9
	call interactionIncState		; $56ec
	ld l,Interaction.counter1		; $56ef
	ld (hl),$5a		; $56f1
	ret			; $56f3

@state4:
	call interactionDecCounter1		; $56f4
	ret nz			; $56f7

	call interactionIncState		; $56f8

	; Increment the "round" of the game
	ld l,Interaction.var3f		; $56fb
	inc (hl)		; $56fd

	jp _shootingGallery_createBallHere		; $56fe

@state5:
	ld a,(wShootingGalleryBallStatus)		; $5701
	bit 7,a			; $5704
	ret z			; $5706

; Ball has gone out-of-bounds

	and $7f			; $5707
	jr nz,@hitSomething	; $5709

	ld a,(wTmpcfc0.shootingGallery.isStrike)		; $570b
	or a			; $570e
	jr nz,@strike	; $570f

	; Hit nothing, but not a strike.
	ld a,$14		; $5711
	jr @setScript		; $5713

@strike:
	ld a,$14		; $5715
	call _shootingGallery_addValueToScore		; $5717
	ld a,$15		; $571a
	jr @setScript		; $571c

@hitSomething:
	cp $02			; $571e
	jr z,@hit2Things	; $5720

	ld a,(wShootingGalleryHitTargets)		; $5722
	and $0f			; $5725
	call getHighestSetBit		; $5727
	jr @addValueToScore		; $572a

@hit2Things:
	ld a,($ccd4)		; $572c
	and $0f			; $572f
	call getHighestSetBit		; $5731
	inc a			; $5734
	add a			; $5735
	add a			; $5736
	ld b,a			; $5737
	ld a,(wShootingGalleryHitTargets)		; $5738
	swap a			; $573b
	and $0f			; $573d
	call getHighestSetBit		; $573f
	add b			; $5742

@addValueToScore:
	ldh (<hFF93),a	; $5743
	call _shootingGallery_addValueToScore		; $5745
	ldh a,(<hFF93)	; $5748

@setScript:
	ld hl,_shootingGalleryHitScriptTable		; $574a
	rst_addDoubleIndex			; $574d
	ldi a,(hl)		; $574e
	ld h,(hl)		; $574f
	ld l,a			; $5750
	call interactionSetScript		; $5751
	call interactionIncState		; $5754

	ld l,Interaction.counter1		; $5757
	ld (hl),$28		; $5759
	ld a,$81		; $575b
	ld (wDisabledObjects),a		; $575d
	ld a,$80		; $5760
	ld (wMenuDisabled),a		; $5762

@state6:
	call interactionRunScript		; $5765
	ret nc			; $5768

	; End the game on the tenth round
	ld e,Interaction.var3f		; $5769
	ld a,(de)		; $576b
	cp $0a			; $576c
	jr z,++			; $576e

	ld h,d			; $5770
	ld l,Interaction.state		; $5771
	ld (hl),$01		; $5773
	ld l,Interaction.counter1		; $5775
	ld (hl),$14		; $5777
	ret			; $5779
++
	; Game is over
	ld a,$01		; $577a
	ld (wTmpcfc0.shootingGallery.gameStatus),a		; $577c
	xor a			; $577f
	ld (wTmpcfc0.shootingGallery.disableGoronNpcs),a		; $5780
	jp interactionDelete		; $5783

;;
; Also used by goron dance minigame.
;
; @param	b	Number of rounds
; @addr{5786}
shootingGallery_initializeGameRounds:
	ld hl,wShootingGalleryTileLayoutsToShow		; $5786
	xor a			; $5789
--
	ldi (hl),a		; $578a
	inc a			; $578b
	cp b			; $578c
	jr nz,--		; $578d

	ld (wTmpcfc0.shootingGallery.remainingRounds),a		; $578f
	ret			; $5792

;;
; Randomly choose the next layout to use. This uses a 10-byte buffer; each time a layout
; is picked, that value is removed from the buffer, and the buffer's size decreases by
; one.
;
; @param[out]	wTmpcfc0.shootingGallery.targetLayoutIndex	Index of the layout to use
; @addr{5793}
shootingGallery_getNextTargetLayout:
	ld a,(wTmpcfc0.shootingGallery.remainingRounds)		; $5793
	ld b,a			; $5796
	dec a			; $5797
	ld (wTmpcfc0.shootingGallery.remainingRounds),a		; $5798

	; Get a random number between 0 and b-1
	call getRandomNumber		; $579b
--
	sub b			; $579e
	jr nc,--		; $579f
	add b			; $57a1

	ld c,a			; $57a2
	ld hl,wShootingGalleryTileLayoutsToShow		; $57a3
	rst_addAToHl			; $57a6
	ld a,(hl)		; $57a7
	ld (wTmpcfc0.shootingGallery.targetLayoutIndex),a		; $57a8

	; Now shift the contents of the buffer down so that its total size decreases by
	; one, and the value we just read gets overwritten.
	push de			; $57ab
	ld d,c			; $57ac
	ld e,b			; $57ad
	dec e			; $57ae
	ld b,h			; $57af
	ld c,l			; $57b0
--
	ld a,d			; $57b1
	cp e			; $57b2
	jr z,++			; $57b3
	inc bc			; $57b5
	ld a,(bc)		; $57b6
	ldi (hl),a		; $57b7
	inc d			; $57b8
	jr --			; $57b9
++
	pop de			; $57bb
	ret			; $57bc

;;
; @addr{57bd}
shootingGallery_removeAllTargets:
	ld a,$01		; $57bd
	ld (wTmpcfc0.shootingGallery.useTileIndexData),a		; $57bf
	ld e,Interaction.subid		; $57c2
	ld a,(de)		; $57c4
	sub $01			; $57c5
	jr z,@subid1		; $57c7
	jr nc,@subid2		; $57c9

@subid0:
	ld bc,_shootingGallery_targetPositions_lynna		; $57cb
	jr _shootingGallery_setTiles		; $57ce
@subid1:
	ld bc,_shootingGallery_targetPositions_goron		; $57d0
	jr _shootingGallery_setTiles		; $57d3
@subid2:
	ld bc,_shootingGallery_targetPositions_biggoron		; $57d5
	jr _shootingGallery_setTiles		; $57d8


;;
; Chooses one of the 10 target layouts to use and loads the tiles. (It never uses the same
; layout more than once, though.)
; @addr{57da}
_shootingGallery_setRandomTargetLayout:
	xor a			; $57da
	ld (wTmpcfc0.shootingGallery.useTileIndexData),a		; $57db
	call shootingGallery_getNextTargetLayout		; $57de

	ld a,(wTmpcfc0.shootingGallery.targetLayoutIndex)		; $57e1

	; l = a*5
	ld l,a			; $57e4
	add a			; $57e5
	add a			; $57e6
	add l			; $57e7
	ld l,a			; $57e8

	ld e,Interaction.var03		; $57e9
	ld a,(de)		; $57eb
	sub $01			; $57ec
	ld a,l			; $57ee
	jr z,@goronGallery	; $57ef
	jr nc,@biggoronGallery	; $57f1

@lynnaGallery:
	ld hl,_shootingGallery_targetTiles_lynna		; $57f3
	rst_addDoubleIndex			; $57f6
	ld bc,_shootingGallery_targetPositions_lynna		; $57f7
	jr _shootingGallery_setTiles		; $57fa

@goronGallery:
	ld hl,_shootingGallery_targetTiles_goron		; $57fc
	rst_addDoubleIndex			; $57ff
	ld bc,_shootingGallery_targetPositions_goron		; $5800
	jr _shootingGallery_setTiles		; $5803

@biggoronGallery:
	ld hl,_shootingGallery_targetTiles_biggoron		; $5805
	rst_addDoubleIndex			; $5808
	ld bc,_shootingGallery_targetPositions_biggoron		; $5809

;;
; @param	bc	Pointer to data containing positions of tiles to be replaced.
; @param	hl	Pointer to data containing tile indices for tiles to be replaced.
;			(optional)
; @param	wTmpcfc0.shootingGallery.useTileIndexData
;			If zero, it uses hl to get the tile indices; otherwise, all tiles
;			are replaced with TILEINDEX_STANDARD_FLOOR.
; @addr{580c}
_shootingGallery_setTiles:
	ld a,$0a		; $580c
@nextTile:
	ldh (<hFF92),a	; $580e
	ld a,(bc)		; $5810
	inc bc			; $5811
	push bc			; $5812
	ld c,a			; $5813
	ld a,(wTmpcfc0.shootingGallery.useTileIndexData)		; $5814
	or a			; $5817
	ld a,TILEINDEX_STANDARD_FLOOR		; $5818
	jr nz,+			; $581a
	ldi a,(hl)		; $581c
+
	push hl			; $581d
	call setTile		; $581e
	pop hl			; $5821
	pop bc			; $5822
	ldh a,(<hFF92)	; $5823
	dec a			; $5825
	jr nz,@nextTile	; $5826
	ret			; $5828


; These are the positions of the tiles for the respective shooting gallery games.
_shootingGallery_targetPositions_lynna:
	.db $31 $21 $12 $03 $04 $05 $06 $17 $28 $38

_shootingGallery_targetPositions_goron:
	.db $21 $32 $12 $23 $04 $05 $26 $37 $17 $28

_shootingGallery_targetPositions_biggoron:
	.db $21 $12 $03 $23 $14 $15 $06 $26 $17 $28


; These are the possible layouts of the tiles for the respective shooting gallery games.
; (One layout per line.)
_shootingGallery_targetTiles_lynna:
	.db $d9 $dc $d9 $d9 $dc $d8 $d9 $d9 $dc $d9
	.db $dc $d9 $d9 $d8 $d9 $dc $dc $d9 $dc $d9
	.db $d9 $dc $d9 $dc $d7 $d9 $dc $d9 $d9 $d9
	.db $d9 $d9 $dc $d9 $d8 $d9 $dc $d8 $d9 $d9
	.db $dc $d8 $d9 $d9 $dc $d9 $d9 $dc $d9 $dc
	.db $d9 $d7 $d9 $d9 $d9 $d9 $d7 $d9 $d9 $d9
	.db $dc $dc $d9 $d9 $dc $d9 $d9 $d8 $d9 $d9
	.db $d9 $d9 $dc $d7 $d9 $d8 $d9 $d8 $d9 $d9
	.db $d9 $d9 $dc $d9 $d9 $dc $d9 $d9 $dc $dc
	.db $dc $d9 $d9 $d9 $d8 $d9 $dc $d9 $d9 $d9

_shootingGallery_targetTiles_goron:
	.db $d9 $dc $d9 $d9 $d9 $d8 $d9 $d9 $dc $d9
	.db $dc $d9 $d9 $d8 $d9 $dc $d7 $d9 $dc $d9
	.db $d9 $dc $d9 $dc $d7 $d9 $d9 $dc $d9 $d9
	.db $d9 $d9 $dc $d9 $d8 $d9 $dc $d7 $d9 $d9
	.db $dc $d9 $d9 $d9 $d8 $d9 $d9 $dc $d9 $dc
	.db $d9 $dc $d9 $d9 $d9 $dc $d9 $d7 $d8 $d9
	.db $dc $d9 $d9 $d9 $dc $d9 $d9 $dc $d9 $d9
	.db $d9 $d9 $dc $d7 $d9 $d8 $d9 $d8 $d9 $d9
	.db $d9 $d9 $dc $d9 $d9 $dc $d8 $d9 $dc $d9
	.db $dc $d9 $d9 $dc $d9 $d9 $dc $d9 $d9 $dc

_shootingGallery_targetTiles_biggoron:
	.db $d9 $d9 $dc $d7 $d9 $dc $d9 $d9 $d8 $dc
	.db $d9 $dc $d9 $d9 $d9 $d8 $dc $d9 $d9 $d8
	.db $d9 $d9 $d7 $dc $dc $d9 $dc $d9 $d9 $dc
	.db $d9 $d9 $dc $d9 $d8 $d9 $dc $d7 $d9 $d9
	.db $dc $d9 $d9 $dc $d9 $dc $dc $d9 $d9 $d8
	.db $d9 $dc $d9 $d9 $dc $d7 $dc $d9 $d9 $d9
	.db $d9 $d9 $d8 $d9 $dc $dc $d7 $d9 $d9 $dc
	.db $d9 $dc $d9 $dc $d9 $d8 $d9 $dc $dc $dc
	.db $dc $d9 $dc $d9 $d9 $dc $d9 $d8 $d9 $d7
	.db $d9 $d9 $d7 $d8 $dc $dc $d9 $dc $d9 $d9

;;
; @addr{5973}
_shootingGallery_createPuffAtEachTargetPosition:
	ld e,Interaction.var03		; $5973
	ld a,(de)		; $5975
	sub $01			; $5976
	jr z,@subid1		; $5978
	jr nc,@subid2		; $597a

@subid0:
	ld bc,_shootingGallery_targetPositions_lynna		; $597c
	jr ++			; $597f
@subid1:
	ld bc,_shootingGallery_targetPositions_goron		; $5981
	jr ++			; $5984
@subid2:
	ld bc,_shootingGallery_targetPositions_biggoron		; $5986

++
	ld a,$0a		; $5989
@nextTile:
	ldh (<hFF92),a	; $598b
	call getFreeInteractionSlot		; $598d
	ret nz			; $5990

	ld (hl),INTERACID_PUFF		; $5991
	ld a,(bc)		; $5993
	inc bc			; $5994
	push bc			; $5995
	ld l,Interaction.yh		; $5996
	call setShortPosition		; $5998
	pop bc			; $599b
	ldh a,(<hFF92)	; $599c
	dec a			; $599e
	jr nz,@nextTile		; $599f
	ret			; $59a1

;;
; @addr{59a2}
_shootingGallery_createBallHere:
	call getFreePartSlot		; $59a2
	ret nz			; $59a5
	ld (hl),PARTID_BALL		; $59a6
	jp objectCopyPosition		; $59a8

;;
; @param	a	Index?
; @addr{59ab}
_shootingGallery_addValueToScore:
	ld hl,@scores		; $59ab
	rst_addDoubleIndex			; $59ae
	ld c,(hl)		; $59af
	inc hl			; $59b0
	ld b,(hl)		; $59b1
	ld hl,wTextNumberSubstitution		; $59b2
	bit 0,c			; $59b5
	jr nz,+			; $59b7
	jp addDecimalToHlRef		; $59b9
+
	res 0,c			; $59bc
	jp subDecimalFromHlRef		; $59be


; If the last digit is "1", the score is subtracted instead of added.
@scores:
	.dw $0030 ; $00
	.dw $0100 ; $01
	.dw $0011 ; $02
	.dw $0051 ; $03
	.dw $0060 ; $04
	.dw $0130 ; $05
	.dw $0020 ; $06
	.dw $0021 ; $07
	.dw $0130 ; $08
	.dw $0200 ; $09
	.dw $0090 ; $0a
	.dw $0050 ; $0b
	.dw $0020 ; $0c
	.dw $0090 ; $0d
	.dw $0021 ; $0e
	.dw $0061 ; $0f
	.dw $0021 ; $10
	.dw $0050 ; $11
	.dw $0061 ; $12
	.dw $00a1 ; $13
	.dw $0051 ; $14 (strike)


; Scripts for INTERACID_SHOOTING_GALLERY.

; NPC scripts
_shootingGalleryScriptTable:
	; NPCs waiting to be talked to
	.dw shootingGalleryScript_humanNpc
	.dw shootingGalleryScript_goronNpc
	.dw shootingGalleryScript_goronElderNpc

	; Cleanup after finishing a game
	.dw shootingGalleryScript_humanNpc_gameDone
	.dw shootingGalleryScript_goronNpc_gameDone
	.dw shootingGalleryScript_goronElderNpc_gameDone

	; NPCs ask if you want to play again
	.dw shootingGalleryScript_humanNpc@tryAgain
	.dw shootingGalleryScript_goronNpc@tryAgain
	.dw shootingGalleryScript_goronElderNpc@beginGame


; Scripts to run when tile(s) of the corresponding types are hit.
_shootingGalleryHitScriptTable:
	.dw shootingGalleryScript_hit1Blue        ; $00
	.dw shootingGalleryScript_hit1Fairy       ; $01
	.dw shootingGalleryScript_hit1Red         ; $02
	.dw shootingGalleryScript_hit1Imp         ; $03
	.dw shootingGalleryScript_hit2Blue        ; $04
	.dw shootingGalleryScript_hit1Blue1Fairy  ; $05
	.dw shootingGalleryScript_hit1Red1Blue    ; $06
	.dw shootingGalleryScript_hit1Blue1Imp    ; $07
	.dw shootingGalleryScript_hit1Blue1Fairy  ; $08
	.dw shootingGalleryScript_hit2Blue        ; $09
	.dw shootingGalleryScript_hit1Red1Fairy   ; $0a
	.dw shootingGalleryScript_hit1Fairy1Imp   ; $0b
	.dw shootingGalleryScript_hit1Red1Blue    ; $0c
	.dw shootingGalleryScript_hit1Red1Fairy   ; $0d
	.dw shootingGalleryScript_hit2Red         ; $0e
	.dw shootingGalleryScript_hit1Red1Imp     ; $0f
	.dw shootingGalleryScript_hit1Blue1Imp    ; $10
	.dw shootingGalleryScript_hit1Fairy1Imp   ; $11
	.dw shootingGalleryScript_hit1Red1Imp     ; $12
	.dw shootingGalleryScript_hit2Red         ; $13

	.dw shootingGalleryScript_hitNothing      ; $14
	.dw shootingGalleryScript_strike          ; $15


; ==============================================================================
; INTERACID_IMPA_IN_CUTSCENE
;
; Variables:
;   var3b: For subid 1, saves impa's "oamTileIndexBase" so it can be restored after Impa
;          gets up (she references a different sprite sheet for her "collapsed" sprite)
; ==============================================================================
interactionCode31:
	ld e,Interaction.state		; $5a29
	ld a,(de)		; $5a2b
	rst_jumpTable			; $5a2c
	.dw @state0
	.dw _impaState1

@state0:
	ld a,$01		; $5a31
	ld (de),a		; $5a33
	call interactionInitGraphics		; $5a34
	call objectSetVisiblec2		; $5a37
	call @initSubid		; $5a3a
	ld e,Interaction.enabled		; $5a3d
	ld a,(de)		; $5a3f
	or a			; $5a40
	jp nz,objectMarkSolidPosition		; $5a41
	ret			; $5a44

@initSubid:
	ld e,Interaction.subid		; $5a45
	ld a,(de)		; $5a47
	rst_jumpTable			; $5a48
	.dw @init0
	.dw @init1
	.dw @init2
	.dw @init3
	.dw @init4
	.dw @init5
	.dw @loadScript
	.dw @init7
	.dw @init8
	.dw @init9
	.dw @initA

@init0:
	call getThisRoomFlags	; $5a5f
	bit 6,a			; $5a62
	jp nz,interactionDelete		; $5a64

	; Load a custom palette and use it for possessed impa
	ld a,PALH_97		; $5a67
	call loadPaletteHeader		; $5a69
	ld e,Interaction.oamFlags		; $5a6c
	ld a,$07		; $5a6e
	ld (de),a		; $5a70

	ld hl,objectData.impaOctoroks		; $5a71
	call parseGivenObjectData		; $5a74

	ld a,LINK_STATE_08		; $5a77
	call setLinkIDOverride		; $5a79
	ld l,<w1Link.subid		; $5a7c
	ld (hl),$01		; $5a7e
	jr @loadScript		; $5a80

@init1:
	ld h,d			; $5a82
	ld l,Interaction.oamTileIndexBase		; $5a83
	ld a,(hl)		; $5a85
	ld l,Interaction.var3b		; $5a86
	ld (hl),a	; $5a88

	call _impaLoadCollapsedGraphic		; $5a89

@loadScript:
	ld e,Interaction.subid		; $5a8c
	ld a,(de)		; $5a8e
	ld hl,_impaScriptTable		; $5a8f
	rst_addDoubleIndex			; $5a92
	ldi a,(hl)		; $5a93
	ld h,(hl)		; $5a94
	ld l,a			; $5a95
	jp interactionSetScript		; $5a96

@init2:
	ld h,d			; $5a99
	ld l,Interaction.counter1		; $5a9a
	ld (hl),$1e		; $5a9c
	jp objectSetVisible82		; $5a9e

@init7:
	; Delete self if Zelda hasn't been kidnapped by vire yet, or she's been rescued
	; already, or this isn't a linked game
	ld a,(wEssencesObtained)		; $5aa1
	bit 2,a			; $5aa4
	jp z,interactionDelete		; $5aa6
	call checkIsLinkedGame		; $5aa9
	jp z,interactionDelete		; $5aac
	ld a,GLOBALFLAG_GOT_RING_FROM_ZELDA		; $5aaf
	call checkGlobalFlag		; $5ab1
	jp nz,interactionDelete		; $5ab4

	ld a,GLOBALFLAG_IMPA_MOVED_AFTER_ZELDA_KIDNAPPED		; $5ab7
	call checkGlobalFlag		; $5ab9
	ld a,$09		; $5abc
	jr z,@setAnimationAndLoadScript	; $5abe

	ld e,Interaction.xh		; $5ac0
	ld a,$38		; $5ac2
	ld (de),a		; $5ac4

	ld a,GLOBALFLAG_ZELDA_SAVED_FROM_VIRE		; $5ac5
	call checkGlobalFlag		; $5ac7
	ld a,$02		; $5aca
	jr z,@setAnimationAndLoadScript	; $5acc

	ld a,$48		; $5ace
	ld (de),a ; [xh] = $48
	ld e,Interaction.yh		; $5ad1
	ld a,$58		; $5ad3
	ld (de),a ; [yh] = $58		; $5ad5

	ld a,$81		; $5ad6
	ld (wMenuDisabled),a		; $5ad8
	ld (wDisabledObjects),a		; $5adb
	ld a,$00		; $5ade
	ld (wScrollMode),a		; $5ae0
	ld hl,$cfd0		; $5ae3
	ld b,$10		; $5ae6
	call clearMemory		; $5ae8

	ldbc INTERACID_ZELDA, $06		; $5aeb
	call objectCreateInteraction		; $5aee
	ld l,Interaction.yh		; $5af1
	ld (hl),$8c		; $5af3
	ld l,Interaction.xh		; $5af5
	ld (hl),$50		; $5af7

	ld a,$02		; $5af9
	jr @setAnimationAndLoadScript		; $5afb

@init3:
	ld a,$03		; $5afd

@setAnimationAndLoadScript:
	call interactionSetAnimation		; $5aff
	call objectSetVisible82		; $5b02
	jr @loadScript		; $5b05

@init4:
	call checkIsLinkedGame		; $5b07
	jp nz,interactionDelete		; $5b0a
	xor a			; $5b0d
	ld ($cfc0),a		; $5b0e

@preBlackTowerCutscene:
	ld a,TREASURE_MAKU_SEED		; $5b11
	call checkTreasureObtained		; $5b13
	jp nc,interactionDelete		; $5b16
	ld a,GLOBALFLAG_PRE_BLACK_TOWER_CUTSCENE_DONE		; $5b19
	call checkGlobalFlag		; $5b1b
	jp nz,interactionDelete		; $5b1e
	jp @loadScript		; $5b21

@init5:
	call checkIsLinkedGame		; $5b24
	jp z,interactionDelete		; $5b27
	ld a,$03		; $5b2a
	call interactionSetAnimation		; $5b2c
	jr @preBlackTowerCutscene		; $5b2f

@initA:
	ld a,$02		; $5b31
	jp interactionSetAnimation		; $5b33

@init9:
	call checkIsLinkedGame		; $5b36
	jp z,interactionDelete		; $5b39

@init8:
	ld a,$03		; $5b3c
	call interactionSetAnimation		; $5b3e
	call @loadScript		; $5b41

_impaState1:
	ld e,Interaction.subid		; $5b44
	ld a,(de)		; $5b46
	rst_jumpTable			; $5b47
	.dw _impaSubid0
	.dw _impaSubid1
	.dw _impaSubid2
	.dw _impaAnimateAndRunScript
	.dw _impaSubid4
	.dw _impaSubid5
	.dw _impaAnimateAndRunScript
	.dw _impaSubid7
	.dw _impaSubid8
	.dw _impaSubid9
	.dw interactionAnimate

;;
; Possessed Impa.
;
; Variables:
;   var37-var3a: Last frame's Y, X, and Direction values. Used for checking whether to
;                update Impa's animation (update if any one has changed).
; @addr{5b5e}
_impaSubid0:
	ld e,Interaction.state2		; $5b5e
	ld a,(de)		; $5b60
	cp $0e			; $5b61
	jr nc,+			; $5b63

	ld hl,wActiveMusic		; $5b65
	ld a,MUS_FAIRY		; $5b68
	cp (hl)			; $5b6a
	jr z,+			; $5b6b

	ld a,(wActiveRoom)		; $5b6d
	cp $39			; $5b70
	jr z,+			; $5b72
	cp $49			; $5b74
	jr z,+			; $5b76

	ld a,MUS_FAIRY		; $5b78
	ld (hl),a		; $5b7a
	call playSound		; $5b7b
	ld a,$03		; $5b7e
	call setMusicVolume		; $5b80

	ld e,Interaction.state2		; $5b83
+
	ld a,(de)		; $5b85
	rst_jumpTable			; $5b86
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4
	.dw @substate5
	.dw @substate6
	.dw @substate7
	.dw @substate8
	.dw @substate9
	.dw @substateA
	.dw @substateB
	.dw @substateC
	.dw @substateD
	.dw @substateE
	.dw @substateF
	.dw _impaRet


; Running a script until Impa joins Link
@substate0:
	call _impaAnimateAndRunScript		; $5ba9
	ret nc			; $5bac

; When the script has finished, make Impa follow Link and go to substate 1

	xor a			; $5bad
	ld (wUseSimulatedInput),a		; $5bae
	call setLinkIDOverride		; $5bb1
	ld l,<w1Link.direction		; $5bb4
	ld (hl),DIR_UP		; $5bb6

@beginFollowingLink:
	call interactionIncState2		; $5bb8
	call makeActiveObjectFollowLink		; $5bbb
	call interactionSetAlwaysUpdateBit		; $5bbe
	call objectSetReservedBit1		; $5bc1

	ld l,Interaction.var37		; $5bc4
	ld e,Interaction.yh		; $5bc6
	ld a,(de)		; $5bc8
	ldi (hl),a		; $5bc9
	ld e,Interaction.xh		; $5bca
	ld a,(de)		; $5bcc
	ldi (hl),a		; $5bcd
	ld e,Interaction.direction		; $5bce
	ld a,(w1Link.direction)		; $5bd0
	ld (de),a		; $5bd3
	ld (hl),$00		; $5bd4

	call interactionSetAnimation		; $5bd6
	call objectSetVisiblec3		; $5bd9
	jp objectSetPriorityRelativeToLink_withTerrainEffects		; $5bdc

; Impa following Link (before stone is pushed)
@substate1:
	call objectSetPriorityRelativeToLink_withTerrainEffects		; $5bdf
	call _impaCheckApproachedStone		; $5be2
	jr nc,@updateAnimationWhileFollowingLink	; $5be5

; Link has approached the stone; trigger cutscene.

	ld a,LINK_STATE_08		; $5be7
	call setLinkIDOverride		; $5be9
	ld l,<w1Link.subid		; $5bec
	ld (hl),$02		; $5bee

	call interactionIncState2		; $5bf0
	ld l,Interaction.counter1		; $5bf3
	ld (hl),$1e		; $5bf5
	ld l,Interaction.enabled		; $5bf7
	res 7,(hl)		; $5bf9

	ld a,SND_CLINK		; $5bfb
	call playSound		; $5bfd

	ld bc,-$1c0		; $5c00
	call objectSetSpeedZ		; $5c03
	call clearFollowingLinkObject		; $5c06
	call @setAngleTowardStone		; $5c09
	call convertAngleDeToDirection		; $5c0c
	jp interactionSetAnimation		; $5c0f

@updateAnimationWhileFollowingLink:
	; Nothing to do here except check whether to update the animation. (It must update
	; if her position or direction has changed.)
	call _impaUpdateAnimationIfDirectionChanged		; $5c12
	ld h,d			; $5c15
	ld l,Interaction.yh		; $5c16
	ld a,(hl)		; $5c18
	ld b,a			; $5c19
	ld l,Interaction.var37		; $5c1a
	cp (hl)			; $5c1c
	jr nz,++		; $5c1d

	ld l,Interaction.xh		; $5c1f
	ld a,(hl)		; $5c21
	ld c,a			; $5c22
	ld l,Interaction.var38		; $5c23
	cp (hl)			; $5c25
	ret z			; $5c26
++
	ld l,Interaction.var37		; $5c27
	ld (hl),b		; $5c29
	inc l			; $5c2a
	ld (hl),c		; $5c2b
	call interactionAnimate		; $5c2c
	jp interactionAnimate		; $5c2f

;;
; @addr{5c32}
@setAngleTowardStone:
	ldbc $38,$38		; $5c32
	call objectGetRelativeAngle		; $5c35
	ld e,Interaction.angle		; $5c38
	ld (de),a		; $5c3a
	ret			; $5c3b

; Jumping after spotting stone
@substate2:
	call _impaAnimateAndDecCounter1		; $5c3c
	ret nz			; $5c3f

	; Wait until she lands
	ld c,$20		; $5c40
	call objectUpdateSpeedZ_paramC		; $5c42
	ret nz			; $5c45

	call interactionIncState2		; $5c46
	ld l,Interaction.counter1		; $5c49
	ld (hl),$0a		; $5c4b
	ret			; $5c4d

@substate3:
	call _impaAnimateAndDecCounter1		; $5c4e
	ret nz			; $5c51

	ld (hl),$14		; $5c52

	ld bc,TX_0104		; $5c54
	call showText		; $5c57
	jp interactionIncState2		; $5c5a

@substate4:
	call interactionDecCounter1IfTextNotActive		; $5c5d
	ret nz			; $5c60

	ld l,Interaction.speed		; $5c61
	ld (hl),SPEED_300		; $5c63
	jp interactionIncState2		; $5c65

; Moving toward stone
@substate5:
	call interactionAnimate3Times		; $5c68
	call objectApplySpeed		; $5c6b
	call @setAngleTowardStone		; $5c6e

	ld a,$02		; $5c71
	ldh (<hFF8B),a	; $5c73
	ldbc $38,$38		; $5c75
	ld h,d			; $5c78
	ld l,Interaction.yh		; $5c79
	call checkObjectIsCloseToPosition		; $5c7b
	ret nc			; $5c7e

; Reached the stone

	ld h,d			; $5c7f
	call interactionIncState2		; $5c80
	ld a,$38		; $5c83
	ld l,Interaction.yh		; $5c85
	ldi (hl),a		; $5c87
	inc l			; $5c88
	ld (hl),a		; $5c89
	ld l,Interaction.counter1		; $5c8a
	ld (hl),$1e		; $5c8c
	xor a			; $5c8e
	jp interactionSetAnimation		; $5c8f

@substate6:
	call _impaAnimateAndDecCounter1		; $5c92
	ret nz			; $5c95

	; Start a jump
	ld (hl),$1e		; $5c96
	ld bc,-$180		; $5c98
	call objectSetSpeedZ		; $5c9b
	jp interactionIncState2		; $5c9e

; Jumping in front of stone
@substate7:
	call _impaAnimateAndDecCounter1		; $5ca1
	ret nz			; $5ca4

	ld c,$20		; $5ca5
	call objectUpdateSpeedZ_paramC		; $5ca7
	ret nz			; $5caa

	call interactionIncState2		; $5cab
	ld l,Interaction.counter1		; $5cae
	ld (hl),$0a		; $5cb0
	ret			; $5cb2

@substate8:
	call interactionDecCounter1		; $5cb3
	ret nz			; $5cb6

	ld (hl),$1e		; $5cb7
	call interactionIncState2		; $5cb9
	ld bc,TX_0105		; $5cbc
	jp showText		; $5cbf

@substate9:
	call interactionDecCounter1IfTextNotActive		; $5cc2
	ret nz			; $5cc5

	ld hl,$cfd0		; $5cc6
	ld (hl),$02		; $5cc9
	ld hl,impaScript_moveAwayFromRock		; $5ccb
	call interactionSetScript		; $5cce
	jp interactionIncState2		; $5cd1

; Moving away from rock (the previously loaded script handles this)
@substateA:
	call _impaAnimateAndRunScript		; $5cd4
	ret nc			; $5cd7

; Done moving away; return control to Link

	xor a			; $5cd8
	call setLinkIDOverride		; $5cd9
	ld l,<w1Link.direction		; $5cdc
	ld (hl),DIR_UP		; $5cde
	ld hl,impaScript_waitForRockToBeMoved		; $5ce0
	call interactionSetScript		; $5ce3
	jp interactionIncState2		; $5ce6

; Waiting for Link to start pushing the rock
@substateB:
	call interactionAnimateAsNpc		; $5ce9
	call interactionRunScript		; $5cec
	call _impaPreventLinkFromLeavingStoneScreen		; $5cef
	ld a,($cfd0)		; $5cf2
	cp $06			; $5cf5
	ret nz			; $5cf7

; The rock has started moving.

	ld hl,impaScript_rockJustMoved		; $5cf8
	call interactionSetScript		; $5cfb
	jp interactionIncState2		; $5cfe

@substateC:
	call _impaAnimateAndRunScript		; $5d01
	ret nc			; $5d04
	xor a			; $5d05
	call setLinkIDOverride		; $5d06
	ld l,<w1Link.direction		; $5d09
	ld (hl),DIR_DOWN		; $5d0b
	jp @beginFollowingLink		; $5d0d

; Following Link, waiting for signal to begin the part of the cutscene where she reveals
; she's evil
@substateD:
	call objectSetPriorityRelativeToLink_withTerrainEffects		; $5d10
	ld a,($cfd0)		; $5d13
	cp $09			; $5d16
	jp nz,@updateAnimationWhileFollowingLink		; $5d18

	; Start the next part of the cutscene
	call interactionIncState2		; $5d1b
	call clearFollowingLinkObject		; $5d1e
	ldbc $68,$38		; $5d21
	call interactionSetPosition		; $5d24
	ld hl,impaScript_revealPossession		; $5d27
	jp interactionSetScript		; $5d2a

@substateE:
	call _impaAnimateAndRunScript		; $5d2d
	ret nc			; $5d30

; Impa has just moved into the corner, Veran will now come out.

	call interactionIncState2		; $5d31
	ld l,Interaction.oamFlags		; $5d34
	ld (hl),$02		; $5d36
	ld a,$05		; $5d38
	call interactionSetAnimation		; $5d3a

	ld b,INTERACID_GHOST_VERAN		; $5d3d
	call objectCreateInteractionWithSubid00		; $5d3f

	ld a,SND_BOSS_DEAD		; $5d42
	call playSound		; $5d44
	jp objectSetVisiblec2		; $5d47

@substateF:
	call interactionAnimate		; $5d4a
	ld h,d			; $5d4d
	ld l,Interaction.animParameter		; $5d4e
	ld a,(hl)		; $5d50
	or a			; $5d51
	ret nz			; $5d52
	call interactionIncState2		; $5d53

;;
; Changes impa's "oamTileIndexBase" to reference her "collapsed" graphic, which is not in
; her normal sprite sheet.
; @addr{5d56}
_impaLoadCollapsedGraphic:
	ld l,Interaction.oamFlags		; $5d56
	ld (hl),$0a		; $5d58
	ld l,Interaction.oamTileIndexBase		; $5d5a
	ld (hl),$60		; $5d5c

_impaRet:
	ret			; $5d5e


;;
; Impa talking to you after Nayru is kidnapped
; @addr{5d5f}
_impaSubid1:
	ld e,Interaction.state2		; $5d5f
	ld a,(de)		; $5d61
	rst_jumpTable			; $5d62
	.dw @substate0
	.dw @substate1
	.dw _impaSubid1Substate2

@substate0:
	ld a,($cfd0)		; $5d69
	cp $20			; $5d6c
	jp nz,interactionAnimate		; $5d6e

	call interactionIncState2		; $5d71
	ld e,Interaction.xh		; $5d74
	ld a,(de)		; $5d76
	ld l,Interaction.var3d		; $5d77
	ld (hl),a		; $5d79
	ld l,Interaction.counter1		; $5d7a
	ld (hl),$3c		; $5d7c
	ret			; $5d7e

@substate1:
	call interactionDecCounter1		; $5d7f
	jr nz,interactionOscillateXRandomly	; $5d82
	jp interactionIncState2		; $5d84

;;
; Uses var3d as the interaction's "base" position, and randomly shifts this position left
; by one or not at all.
; @addr{5d87}
interactionOscillateXRandomly:
	call getRandomNumber		; $5d87
	and $01			; $5d8a
	sub $01			; $5d8c
	ld h,d			; $5d8e
	ld l,Interaction.var3d		; $5d8f
	add (hl)		; $5d91
	ld l,Interaction.xh		; $5d92
	ld (hl),a		; $5d94
	ret			; $5d95

_impaSubid1Substate2:
	call interactionRunScript		; $5d96
	jp c,interactionDelete		; $5d99
	ld e,Interaction.counter2		; $5d9c
	ld a,(de)		; $5d9e
	or a			; $5d9f
	jp nz,interactionAnimate2Times		; $5da0
	jp interactionAnimate		; $5da3

;;
; Impa in the credits cutscene
; @addr{5da6}
_impaSubid2:
	ld e,Interaction.state2		; $5da6
	ld a,(de)		; $5da8
	rst_jumpTable			; $5da9
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw _impaAnimateAndRunScript
	.dw _impaSubid2Substate4
	.dw _impaSubid2Substate5
	.dw _impaSubid2Substate6
	.dw _impaSubid2Substate7

@substate0:
	call interactionDecCounter1IfPaletteNotFading		; $5dba
	ret nz			; $5dbd
	ld (hl),$3c		; $5dbe
	call interactionIncState2		; $5dc0
	ld a,$50		; $5dc3
	ld bc,$6050		; $5dc5
	jp createEnergySwirlGoingIn		; $5dc8

@substate1:
	call interactionDecCounter1		; $5dcb
	ret nz			; $5dce
	ld hl,wTmpcbb3		; $5dcf
	xor a			; $5dd2
	ld (hl),a		; $5dd3
	dec a			; $5dd4
	ld (wTmpcbba),a		; $5dd5
	jp interactionIncState2		; $5dd8

@substate2:
	ld hl,wTmpcbb3		; $5ddb
	ld b,$02		; $5dde
	call flashScreen		; $5de0
	ret z			; $5de3

	call interactionIncState2		; $5de4
	call interactionCode31@loadScript		; $5de7
	ld a,$01		; $5dea
	ld ($cfc0),a		; $5dec
	jp fadeinFromWhite		; $5def

;;
; @addr{5df2}
_impaAnimateAndRunScript:
	call interactionAnimateBasedOnSpeed		; $5df2
	jp interactionRunScript		; $5df5


_impaSubid2Substate4:
	ld h,d			; $5df8
	ld l,Interaction.var38		; $5df9
	dec (hl)		; $5dfb
	ret nz			; $5dfc
	call interactionIncState2		; $5dfd
	ld l,Interaction.counter1		; $5e00
	ld (hl),$02		; $5e02

_impaSetVisibleAndJump:
	call objectSetVisiblec2		; $5e04
	ld bc,-$180		; $5e07
	jp objectSetSpeedZ		; $5e0a

_impaSubid2Substate5:
	ld c,$20		; $5e0d
	call objectUpdateSpeedZ_paramC		; $5e0f
	ret nz			; $5e12

	call interactionDecCounter1		; $5e13
	jr nz,_impaSetVisibleAndJump	; $5e16

	call objectSetVisible82		; $5e18
	ld h,d			; $5e1b
	ld l,Interaction.var38		; $5e1c
	ld (hl),$10		; $5e1e
	jp interactionIncState2		; $5e20

_impaSubid2Substate6:
	ld h,d			; $5e23
	ld l,Interaction.var38		; $5e24
	dec (hl)		; $5e26
	ret nz			; $5e27

	ld (hl),$10		; $5e28

	ld l,Interaction.counter2		; $5e2a
	ld a,(hl)		; $5e2c
	inc (hl)		; $5e2d
	cp $02			; $5e2e
	jr z,@nextState		; $5e30
	or a			; $5e32
	ld a,$03		; $5e33
	jr z,+			; $5e35
	xor $02			; $5e37
+
	ld l,Interaction.state2		; $5e39
	dec (hl)		; $5e3b
	dec (hl)		; $5e3c
	jp interactionSetAnimation		; $5e3d

@nextState:
	ld (hl),$00		; $5e40
	ld a,$02		; $5e42
	ld ($cfc0),a		; $5e44
	jp interactionIncState2		; $5e47

_impaSubid2Substate7:
	call _impaAnimateAndRunScript		; $5e4a
	ld a,($cfc0)		; $5e4d
	cp $03			; $5e50
	ret c			; $5e52
	jpab scriptHlp.turnToFaceSomething		; $5e53

;;
; Impa tells you about Ralph's heritage (unlinked)
; @addr{5e5b}
_impaSubid4:
	call checkInteractionState2		; $5e5b
	jr nz,@substate1	; $5e5e

@substate0:
	; Wait for Link to move a certain distance down
	ld hl,w1Link.yh		; $5e60
	ldi a,(hl)		; $5e63
	cp $60			; $5e64
	ret c			; $5e66

	ld l,<w1Link.zh		; $5e67
	bit 7,(hl)		; $5e69
	ret nz			; $5e6b
	call checkLinkCollisionsEnabled		; $5e6c
	ret nc			; $5e6f

	call resetLinkInvincibility		; $5e70
	call setLinkForceStateToState08		; $5e73
	inc a			; $5e76
	ld (wDisabledObjects),a		; $5e77
	ld (wMenuDisabled),a		; $5e7a
	jp interactionIncState2		; $5e7d

@substate1:
	ld c,$20		; $5e80
	call objectUpdateSpeedZ_paramC		; $5e82
	ret nz			; $5e85
	call interactionRunScript		; $5e86
	jp c,interactionDelete		; $5e89
	call interactionAnimateBasedOnSpeed		; $5e8c
	ld e,Interaction.var38		; $5e8f
	ld a,(de)		; $5e91
	rst_jumpTable			; $5e92
	.dw @thing0
	.dw @thing1
	.dw @thing2
	.dw @thing3
	.dw @thing4

@thing0:
	ld a,($cfc0)		; $5e9d
	rrca			; $5ea0
	ret nc			; $5ea1
	ld e,Interaction.var39		; $5ea2
	ld a,$10		; $5ea4
	ld (de),a		; $5ea6
	jr @incVar38		; $5ea7

; Move Link horizontally toward Impa
@thing1:
	ld h,d			; $5ea9
	ld l,Interaction.var39		; $5eaa
	dec (hl)		; $5eac
	ret nz			; $5ead

	ld a,(w1Link.xh)		; $5eae
	sub $50			; $5eb1
	ld b,a			; $5eb3
	add $02			; $5eb4
	cp $05			; $5eb6
	jr c,@incVar38	; $5eb8

	ld a,b			; $5eba
	bit 7,a			; $5ebb
	ld b,$18		; $5ebd
	jr z,+			; $5ebf

	ld b,$08		; $5ec1
	cpl			; $5ec3
	inc a			; $5ec4
+
	ld (wLinkStateParameter),a		; $5ec5
	ld a,LINK_STATE_FORCE_MOVEMENT		; $5ec8
	ld (wLinkForceState),a		; $5eca

	ld hl,w1Link.angle		; $5ecd
	ld a,b			; $5ed0
	ldd (hl),a		; $5ed1
	swap a			; $5ed2
	rlca			; $5ed4
	ld (hl),a		; $5ed5

@incVar38:
	ld h,d			; $5ed6
	ld l,$78		; $5ed7
	inc (hl)		; $5ed9
	ret			; $5eda

; Move Link vertically toward Impa
@thing2:
	ld a,(w1Link.state)		; $5edb
	cp LINK_STATE_FORCE_MOVEMENT			; $5ede
	ret z			; $5ee0

	ld a,(w1Link.yh)		; $5ee1
	sub $48			; $5ee4
	ld (wLinkStateParameter),a		; $5ee6
	xor a			; $5ee9
	ld hl,w1Link.direction		; $5eea
	ldi (hl),a		; $5eed
	ld (hl),a		; $5eee
	ld a,LINK_STATE_FORCE_MOVEMENT		; $5eef
	ld (wLinkForceState),a		; $5ef1
	jp @incVar38		; $5ef4

@thing3:
	ld a,(w1Link.state)		; $5ef7
	cp LINK_STATE_FORCE_MOVEMENT			; $5efa
	ret z			; $5efc
	call setLinkForceStateToState08		; $5efd
	jp @incVar38		; $5f00

@thing4:
	ret			; $5f03

;;
; Like above (explaining ralph's heritage), but for linked game
; @addr{5f04}
_impaSubid5:
	ld c,$20		; $5f04
	call objectUpdateSpeedZ_paramC		; $5f06
	ret nz			; $5f09
	call interactionRunScript		; $5f0a
	jr nc,++		; $5f0d

	; Script over
	xor a			; $5f0f
	ld (wDisabledObjects),a		; $5f10
	ld (wMenuDisabled),a		; $5f13
	ld a,GLOBALFLAG_PRE_BLACK_TOWER_CUTSCENE_DONE		; $5f16
	call setGlobalFlag		; $5f18
	jp interactionDelete		; $5f1b
++
	call interactionAnimateBasedOnSpeed		; $5f1e
	ld e,Interaction.state2		; $5f21
	ld a,(de)		; $5f23
	rst_jumpTable			; $5f24
	.dw @substate0
	.dw @substate1
	.dw @substate2

@substate0:
	ld a,($cfd0)		; $5f2b
	cp $04			; $5f2e
	ret nz			; $5f30

	ld a,$29		; $5f31
	ld (wLinkStateParameter),a		; $5f33
	ld a,LINK_STATE_FORCE_MOVEMENT		; $5f36
	ld (wLinkForceState),a		; $5f38
	ld a,$10		; $5f3b
	ld (w1Link.angle),a		; $5f3d
	jp interactionIncState2		; $5f40

@substate1:
	ld a,(w1Link.state)		; $5f43
	cp LINK_STATE_FORCE_MOVEMENT			; $5f46
	ret z			; $5f48
	call setLinkForceStateToState08		; $5f49
	jp interactionIncState2		; $5f4c

@substate2:
	ret			; $5f4f

;;
; Impa tells you that zelda's been kidnapped by Vire
; @addr{5f50}
_impaSubid7:
	ld c,$20		; $5f50
	call objectUpdateSpeedZ_paramC		; $5f52
	call interactionRunScript		; $5f55
	jp c,interactionDelete		; $5f58

	ld a,GLOBALFLAG_IMPA_MOVED_AFTER_ZELDA_KIDNAPPED		; $5f5b
	call checkGlobalFlag		; $5f5d
	jp z,interactionAnimateAsNpc		; $5f60

	ld a,GLOBALFLAG_ZELDA_SAVED_FROM_VIRE		; $5f63
	call checkGlobalFlag		; $5f65
	jp nz,interactionAnimate		; $5f68
	jp npcFaceLinkAndAnimate		; $5f6b

;;
; @addr{5f6e}
_impaSubid8:
	call _impaAnimateAndRunScript		; $5f6e
	jp c,interactionDelete		; $5f71
	ret			; $5f74

;;
; Impa tells you that Zelda's been kidnapped by Twinrova
; @addr{5f75}
_impaSubid9:
	ld e,Interaction.var38		; $5f75
	ld a,(de)		; $5f77
	or a			; $5f78
	jr z,++			; $5f79
	callab scriptHlp.objectWritePositionTocfd5		; $5f7b
++
	jp _impaAnimateAndRunScript		; $5f83

;;
; Checks that an object is within [hFF8B] pixels of a position on both axes.
;
; @param	bc	Target position
; @param	hl	Object's Y position
; @param	hFF8B	Range we must be within on each axis
; @param[out]	cflag	c if the object is within [hFF8B] pixels of the position
; @addr{5f86}
checkObjectIsCloseToPosition:
	push hl			; $5f86
	call @checkComponent		; $5f87
	pop hl			; $5f8a
	ret nc			; $5f8b

	inc l			; $5f8c
	inc l			; $5f8d
	ld b,c			; $5f8e

;;
; @param	b	Position
; @param	hl	Object position component
; @param	hFF8B
; @param[out]	cflag	Set if we're within [hFF8B] pixels of 'b'.
; @addr{5f8f}
@checkComponent:
	ld a,b			; $5f8f
	sub (hl)		; $5f90
	ld hl,hFF8B		; $5f91
	ld b,(hl)		; $5f94
	add b			; $5f95
	ldh (<hFF8D),a	; $5f96

	ld a,b			; $5f98
	add a			; $5f99
	ld b,a			; $5f9a
	inc b			; $5f9b
	ldh a,(<hFF8D)	; $5f9c
	cp b			; $5f9e
	ret			; $5f9f

;;
; @addr{5fa0}
_impaUpdateAnimationIfDirectionChanged:
	ld h,d			; $5fa0
	ld l,Interaction.direction		; $5fa1
	ld a,(hl)		; $5fa3
	ld l,Interaction.var39		; $5fa4
	cp (hl)			; $5fa6
	ret z			; $5fa7
	ld (hl),a		; $5fa8
	jp interactionSetAnimation		; $5fa9

;;
; @param[out]	cflag	c if Link has approached the stone to trigger Impa's reaction
; @addr{5fac}
_impaCheckApproachedStone:
	ld a,(wActiveRoom)		; $5fac
	cp $59			; $5faf
	jr nz,@notClose		; $5fb1

	ld a,(wScrollMode)		; $5fb3
	and $01			; $5fb6
	ret z			; $5fb8

	ld hl,w1Link.yh		; $5fb9
	ldi a,(hl)		; $5fbc
	cp $58			; $5fbd
	jr nc,@notClose		; $5fbf
	inc l			; $5fc1
	ld a,(hl)		; $5fc2
	cp $78			; $5fc3
	ret			; $5fc5
@notClose:
	xor a			; $5fc6
	ret			; $5fc7

;;
; @param[out]	zflag	z if counter1 has reached 0.
; @addr{5fc8}
_impaAnimateAndDecCounter1:
	ld h,d			; $5fc8
	ld l,Interaction.counter1		; $5fc9
	ld a,(hl)		; $5fcb
	or a			; $5fcc
	ret z			; $5fcd
	dec (hl)		; $5fce
	call interactionAnimate		; $5fcf
	or $01			; $5fd2
	ret			; $5fd4

;;
; Shows text if Link tries to leave the screen with the stone.
; @addr{5fd5}
_impaPreventLinkFromLeavingStoneScreen:
	ld hl,w1Link.yh		; $5fd5
	ld a,(hl)		; $5fd8
	ld b,$76		; $5fd9
	cp b			; $5fdb
	jr c,++			; $5fdc
	ld a,(wKeysPressed)		; $5fde
	and BTN_DOWN			; $5fe1
	jr nz,@showText		; $5fe3
++
	ld l,<w1Link.xh		; $5fe5
	ld a,(hl)		; $5fe7
	ld b,$96		; $5fe8
	cp b			; $5fea
	ret c			; $5feb
	ld a,(wKeysPressed)		; $5fec
	and BTN_RIGHT			; $5fef
	ret z			; $5ff1
@showText:
	ld (hl),b		; $5ff2
	ld bc,TX_010a		; $5ff3
	jp showText		; $5ff6

; @addr{5ff9}
_impaScriptTable:
	.dw impaScript0
	.dw impaScript1
	.dw impaScript2
	.dw impaScript3
	.dw impaScript4
	.dw impaScript5
	.dw impaScript6
	.dw impaScript7
	.dw impaScript8
	.dw impaScript9


; ==============================================================================
; INTERACID_FAKE_OCTOROK
; ==============================================================================
interactionCode32:
	ld e,Interaction.state		; $600d
	ld a,(de)		; $600f
	rst_jumpTable			; $6010
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $6015
	ld (de),a		; $6017
	call interactionInitGraphics		; $6018
	ld e,Interaction.subid		; $601b
	ld a,(de)		; $601d
	rst_jumpTable			; $601e
	.dw @init0
	.dw @init1
	.dw @init2

@init0:
	call getThisRoomFlags		; $6025
	bit 6,a			; $6028
	jp nz,interactionDelete		; $602a
	call objectSetVisible82		; $602d

	ld e,Interaction.var03		; $6030
	ld a,(de)		; $6032
	ld b,a			; $6033
	ld hl,_impaOctorokScriptTable		; $6034
	rst_addDoubleIndex			; $6037
	ldi a,(hl)		; $6038
	ld h,(hl)		; $6039
	ld l,a			; $603a
	call interactionSetScript		; $603b
	ld a,b			; $603e
	ld hl,@animations		; $603f
	rst_addAToHl			; $6042
	ld a,(hl)		; $6043
	jp interactionSetAnimation		; $6044

; Each animation faces a different direction.
@animations:
	.db $02 $01 $03

@init2:
	ld a,GLOBALFLAG_WATER_POLLUTION_FIXED		; $604a
	call checkGlobalFlag	; $604c
	jr z,++			; $604f
	ld a,ENEMYID_GREAT_FAIRY		; $6051
	call getFreeEnemySlot		; $6053
	ld (hl),ENEMYID_GREAT_FAIRY		; $6056
	call objectCopyPosition		; $6058
	jp interactionDelete		; $605b
++
	ld bc,-$80		; $605e
	call objectSetSpeedZ		; $6061
	ld a,>TX_4100		; $6064
	call interactionSetHighTextIndex		; $6066
	ld hl,greatFairyOctorokScript		; $6069
	jr @init1		; $606c

@init1:
	call interactionSetScript		; $606e
	call objectSetVisiblec0		; $6071

@state1:
	ld e,Interaction.subid		; $6074
	ld a,(de)		; $6076
	rst_jumpTable			; $6077
	.dw _impaOctorokCode
	.dw _greatFairyOctorokCode
	.dw _greatFairyOctorokCode

_impaOctorokCode:
	call interactionAnimate		; $607e
	ld e,Interaction.state2		; $6081
	ld a,(de)		; $6083
	rst_jumpTable			; $6084
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate0:
	ld a,($cfd0)		; $608d
	cp $01			; $6090
	ret nz			; $6092
	call interactionIncState2		; $6093
	ld l,Interaction.counter1		; $6096
	ld (hl),$14		; $6098
	ret			; $609a

@substate1:
	call interactionDecCounter1		; $609b
	ret nz			; $609e
	call interactionIncState2		; $609f
	ld l,Interaction.speed		; $60a2
	ld (hl),SPEED_300		; $60a4

	ld l,Interaction.var03		; $60a6
	ld a,(hl)		; $60a8
	ld bc,@countersAndAngles		; $60a9
	call addDoubleIndexToBc		; $60ac
	ld a,(bc)		; $60af
	ld l,Interaction.counter1		; $60b0
	ld (hl),a		; $60b2
	inc bc			; $60b3
	ld a,(bc)		; $60b4
	ld l,Interaction.angle		; $60b5
	ld (hl),a		; $60b7
	swap a			; $60b8
	rlca			; $60ba
	jp interactionSetAnimation		; $60bb

@countersAndAngles:
	.db $50 $00
	.db $3c $18
	.db $5a $00

@substate2:
	call interactionAnimate2Times		; $60c4
	call interactionDecCounter1		; $60c7
	ret nz			; $60ca
	ld a,SND_THROW		; $60cb
	call playSound		; $60cd
	jp interactionIncState2		; $60d0

@substate3:
	call objectCheckWithinScreenBoundary		; $60d3
	jp nc,interactionDelete		; $60d6
	call interactionAnimate2Times		; $60d9
	jp objectApplySpeed		; $60dc


_impaOctorokScriptTable: ; These scripts do nothing
	.dw impaOctorokScript
	.dw impaOctorokScript
	.dw impaOctorokScript


_greatFairyOctorokCode:
	call npcFaceLinkAndAnimate		; $60e5
	call interactionRunScript		; $60e8
	ret nc			; $60eb

; Script over; just used fairy powder.

	xor a			; $60ec
	call objectUpdateSpeedZ		; $60ed
	ld e,Interaction.zh		; $60f0
	ld a,(de)		; $60f2
	cp $f0			; $60f3
	ret nz			; $60f5

	ldbc INTERACID_GREAT_FAIRY, $01		; $60f6
	call objectCreateInteraction		; $60f9
	ld a,TREASURE_FAIRY_POWDER		; $60fc
	call loseTreasure		; $60fe
	jp interactionDelete		; $6101


; ==============================================================================
; INTERACID_SMOG_BOSS
;
; Variables:
;   subid:    The index of the last enemy spawned. Incremented each time "@spawnEnemy" is
;             called. This should start at $ff.
;   var03:    Phase of fight
;   var18/19: Pointer to "tile replacement data" while in the process of replacing the
;             room's tiles
;   var30/31: Destination at which to place Link for the next phase
;   var32-34: For the purpose of removing blocks at the end of a phase, this keeps track
;             of the position we're at in the removal loop, and the number of columns or
;             rows remaining to check.
;   var35:    Remembers the value of "subid" at the start of this phase so it can be
;             restored if Link hits the reset button.
; ==============================================================================
interactionCode33:
	ld e,Interaction.state		; $6104
	ld a,(de)		; $6106
	rst_jumpTable			; $6107
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3
	.dw @state4
	.dw @state5
	.dw @state6
	.dw @state7
	.dw @state8
	.dw @state9
	.dw @stateA

@state0:
	call getThisRoomFlags		; $611e
	bit 7,a			; $6121
	jp nz,interactionDelete		; $6123

	ld a,$01		; $6126
	ld (wMenuDisabled),a		; $6128
	ld (wDisabledObjects),a		; $612b
	ld a,($cc93)		; $612e
	or a			; $6131
	ret nz			; $6132

	inc a			; $6133
	ld (de),a ; [state] = 1

	call @spawnEnemy		; $6135
	jp objectCreatePuff		; $6138

; Waiting for Link to complete this phase
@state1:
	ld a,(wNumEnemies)		; $613b
	dec a			; $613e
	ret nz			; $613f
	ld a,$01		; $6140
	ld (wMenuDisabled),a		; $6142
	ld (wDisabledObjects),a		; $6145
	jp interactionIncState		; $6148

@state2:
	; Raise Link off the floor
	ld hl,w1Link.zh		; $614b
	dec (hl)		; $614e
	ld a,$f9		; $614f
	cp (hl)			; $6151
	ret c			; $6152

	; Get the position to place Link at
	ld e,Interaction.var03		; $6153
	ld a,(de)		; $6155
	ld hl,@linkPlacementPositions		; $6156
	rst_addDoubleIndex			; $6159
	ld e,Interaction.var30		; $615a
	ldi a,(hl)		; $615c
	ld (de),a		; $615d
	inc e			; $615e
	ldi a,(hl)		; $615f
	ld (de),a		; $6160
	jp interactionIncState		; $6161

; Moving Link to the target position (var30/var31)
@state3:
	ld hl,w1Link.yh		; $6164
	ld e,Interaction.var30		; $6167
	ld a,(de)		; $6169
	cp (hl)			; $616a
	jp nz,@incOrDecPosition		; $616b

	ld l,<w1Link.xh		; $616e
	inc e			; $6170
	ld a,(de)		; $6171
	cp (hl)			; $6172
	jp nz,@incOrDecPosition		; $6173
	jp interactionIncState		; $6176

@incOrDecPosition:
	jr c,+			; $6179
	inc (hl)		; $617b
	ret			; $617c
+
	dec (hl)		; $617d
	ret			; $617e

; Moving Link back to the ground
@state4:
	ld hl,w1Link.zh		; $617f
	inc (hl)		; $6182
	ret nz			; $6183
	jp interactionIncState		; $6184

; Waiting for Link to complete this phase?
@state5:
	ld a,(wNumEnemies)		; $6187
	dec a			; $618a
	ret nz			; $618b

	ld e,Interaction.var03		; $618c
	ld a,(de)		; $618e
	ld hl,@tileReplacementTable		; $618f
	rst_addAToHl			; $6192
	ld a,(hl)		; $6193
	rst_addAToHl			; $6194
	ld e,Interaction.var18		; $6195
	ld a,l			; $6197
	ld (de),a		; $6198
	inc e			; $6199
	ld a,h			; $619a
	ld (de),a		; $619b
	ld e,Interaction.counter1		; $619c
	ld a,$05		; $619e
	ld (de),a		; $61a0
	jp interactionIncState		; $61a1

; Generate the tiles to be used in this phase
@state6:
	call interactionDecCounter1		; $61a4
	ret nz			; $61a7

	ld (hl),$05		; $61a8

	; Retrieve pointer to tile replacement data
	ld l,Interaction.var18		; $61aa
	ldi a,(hl)		; $61ac
	ld h,(hl)		; $61ad
	ld l,a			; $61ae

	ld a,(hl)		; $61af
	or a			; $61b0
	jp z,interactionIncState		; $61b1

	; First byte read was position; move interaction here for the purpose of creating
	; the "poof".
	call convertShortToLongPosition		; $61b4
	ld e,Interaction.yh		; $61b7
	ld a,b			; $61b9
	ld (de),a		; $61ba
	ld e,Interaction.xh		; $61bb
	ld a,c			; $61bd
	ld (de),a		; $61be

	; Change the tile index
	ldi a,(hl)		; $61bf
	ld c,a			; $61c0
	ldi a,(hl)		; $61c1
	push hl			; $61c2
	call setTile		; $61c3
	pop hl			; $61c6
	ret z			; $61c7

	; Save pointer
	ld e,Interaction.var18		; $61c8
	ld a,l			; $61ca
	ld (de),a		; $61cb
	inc e			; $61cc
	ld a,h			; $61cd
	ld (de),a		; $61ce

	jp objectCreatePuff		; $61cf

; Spawn the enemies
@state7:
	call interactionDecCounter1		; $61d2
	ret nz			; $61d5

	call getThisRoomFlags		; $61d6
	res 6,(hl)		; $61d9

	ld e,Interaction.subid		; $61db
	ld a,(de)		; $61dd
	ld e,Interaction.var35		; $61de
	ld (de),a		; $61e0

	; Spawn the enemies
	ld e,Interaction.var03		; $61e1
	ld a,(de)		; $61e3
	ld hl,@numEnemiesToSpawn		; $61e4
	rst_addAToHl			; $61e7
	ld a,(hl)		; $61e8
--
	call @spawnEnemy		; $61e9
	dec a			; $61ec
	jr nz,--		; $61ed

	ld (wDisableLinkCollisionsAndMenu),a		; $61ef

	; Return position to top-left corner
	ld a,$18		; $61f2
	ld e,Interaction.xh		; $61f4
	ld (de),a		; $61f6
	sub $04			; $61f7
	ld e,Interaction.yh		; $61f9
	ld (de),a		; $61fb

	jp interactionIncState		; $61fc


; Run the phase; constantly checks whether any 2 enemies are close enough to merge.
@state8:
	; If [wNumEnemies] == 1, this phase is over
	ld a,(wNumEnemies)		; $61ff
	dec a			; $6202
	jp z,interactionIncState		; $6203

	; If [wNumEnemies] == 2, there's only one, big smog on-screen. Don't allow Link to
	; reset the phase at this point?
	dec a			; $6206
	jr z,@checkMergeSmogs	; $6207

	; Check whether the switch tile has changed (Link's stepped on it)
	call objectGetTileAtPosition		; $6209
	cp TILEINDEX_BUTTON			; $620c
	jr nz,@buttonPressed	; $620e

	ld a,(w1Link.state)		; $6210
	cp LINK_STATE_NORMAL			; $6213
	jr nz,@checkMergeSmogs	; $6215

	ld a,(wLinkInAir)		; $6217
	or a			; $621a
	jr nz,@checkMergeSmogs	; $621b

	ld c,$04		; $621d
	call objectCheckLinkWithinDistance		; $621f
	jr nc,@checkMergeSmogs	; $6222

	; Switch pressed
	ld a,TILEINDEX_PRESSED_BUTTON		; $6224
	ld c,$11		; $6226
	call setTile		; $6228

@buttonPressed:
	; Subtract health as a penalty
	ld hl,wLinkHealth		; $622b
	ld a,(hl)		; $622e
	cp $0c			; $622f
	jr c,+			; $6231
	sub $04			; $6233
	ld (hl),a		; $6235
+
	ld a,SND_SPLASH		; $6236
	call playSound		; $6238
	call getThisRoomFlags		; $623b
	set 6,(hl)		; $623e
	ld e,Interaction.var35		; $6240
	ld a,(de)		; $6242
	ld e,Interaction.subid		; $6243
	ld (de),a		; $6245
	call interactionIncState		; $6246
	jr @nextPhase		; $6249

; Check up to 3 smog enemies to see whether they should merge
@checkMergeSmogs:
	call @findFirstSmogEnemy		; $624b
	ret nz			; $624e
	push hl			; $624f
	call @findNextSmogEnemy		; $6250
	pop bc			; $6253
	ret nz			; $6254

	call @checkEnemiesCloseEnoughToMerge		; $6255
	jr c,@mergeSmogs	; $6258

	call @findNextSmogEnemy		; $625a
	ret nz			; $625d
	call @checkEnemiesCloseEnoughToMerge		; $625e
	jr c,@mergeSmogs	; $6261

	push hl			; $6263
	ld h,b			; $6264
	call @findNextSmogEnemy		; $6265
	push hl			; $6268
	pop bc			; $6269
	pop hl			; $626a
	call @checkEnemiesCloseEnoughToMerge		; $626b
	ret nc			; $626e

; Merge smogs 'b' and 'h'
@mergeSmogs:
	ld l,Enemy.subid		; $626f
	ld c,l			; $6271
	ld a,(bc)		; $6272
	xor (hl)		; $6273
	and $80			; $6274
	ld (bc),a		; $6276

	; Set subid to $06; slate it for deletion, maybe?
	ld (hl),$06		; $6277

	; This sets hl to a brand new enemy slot
	call getFreeEnemySlot		; $6279
	ld (hl),ENEMYID_SMOG		; $627c

	ld a,(bc)		; $627e
	ld l,c			; $627f
	or $03			; $6280
	ldi (hl),a ; [new subid] = [old subid] | 3

	; Slate the other old smog for deletion?
	ld a,$06		; $6283
	ld (bc),a		; $6285

	; [New var03] = [Interaction.var03]
	ld e,Interaction.var03		; $6286
	ld a,(de)		; $6288
	ldi (hl),a		; $6289

	ld l,Enemy.counter2		; $628a
	ld (hl),$05		; $628c

	; Copy old smog's direction
	inc l			; $628e
	ld c,l			; $628f
	ld a,(bc)		; $6290
	ld (hl),a		; $6291

	; Copy old smog's position
	ld l,Enemy.yh		; $6292
	ld c,l			; $6294
	ld a,(bc)		; $6295
	ldi (hl),a		; $6296
	inc l			; $6297
	ld c,l			; $6298
	ld a,(bc)		; $6299
	ld (hl),a		; $629a
	ret			; $629b


; Smog destroyed; proceed to the next phase
@state9:
	ld e,Interaction.var03		; $629c
	ld a,(de)		; $629e
	inc a			; $629f
	ld (de),a		; $62a0
	cp $04			; $62a1
	jr nz,@nextPhase	; $62a3

	; Final phase completed
	call decNumEnemies		; $62a5
	jp interactionDelete		; $62a8

@nextPhase:
	ld e,Interaction.counter1		; $62ab
	ld a,$05		; $62ad
	ld (de),a		; $62af

	ld a,$01		; $62b0
	ld (wMenuDisabled),a		; $62b2
	ld (wDisabledObjects),a		; $62b5

; Initialize variables for the next phase (they keep track of the position we're at for
; removing block tiles)

	ld e,Interaction.var32
	ld a,$11
	ld (de),a ; var32

	ld a, LARGE_ROOM_HEIGHT-2
	inc e
	ld (de),a ; var33

	inc e
	ld a, LARGE_ROOM_WIDTH-2
	ld (de),a ; var34

	jp interactionIncState


; Clearing out all blocks on-screen in preparation for next phase
@stateA:
	call interactionDecCounter1		; $62c8
	ret nz			; $62cb

	ld a,$05		; $62cc
	ld (hl),a		; $62ce

	ld l,Interaction.var32		; $62cf
	ldi a,(hl)		; $62d1
	ld b,(hl)		; $62d2
	ld l,a			; $62d3
	ld h,>wRoomCollisions		; $62d4
@nextRow:
	ld e,Interaction.var34		; $62d6
	ld a,(de)		; $62d8
	ld c,a			; $62d9
@nextColumn:
	ld a,(hl)		; $62da
	or a			; $62db
	jr nz,@foundNextBlockTile	; $62dc

	ld e,Interaction.var32		; $62de
	inc l			; $62e0
	ld a,l			; $62e1
	ld (de),a		; $62e2
	dec c			; $62e3
	ld e,Interaction.var34		; $62e4
	ld a,c			; $62e6
	ld (de),a		; $62e7
	jr nz,@nextColumn	; $62e8

	; Reset number of columns to check for the next row
	ld a,LARGE_ROOM_WIDTH-2		; $62ea
	ld (de),a		; $62ec

	; Adjust position for the next row
	ld c,a			; $62ed
	ld e,Interaction.var32		; $62ee
	ld a,l			; $62f0
	add ($10 - (LARGE_ROOM_WIDTH-2))			; $62f1
	ld (de),a		; $62f3

	ld l,a			; $62f4
	inc e ; e = var33
	dec b			; $62f6
	ld a,b			; $62f7
	ld (de),a		; $62f8
	jr nz,@nextRow	; $62f9

	; Return to state 1 to begin the next phase
	ld a,$01		; $62fb
	ld e,Interaction.state		; $62fd
	ld (de),a		; $62ff
	ret			; $6300

@foundNextBlockTile:
	ld a,l			; $6301
	ld e,Interaction.yh		; $6302
	and $f0			; $6304
	or $08			; $6306
	ld (de),a		; $6308
	ld e,Interaction.xh		; $6309
	ld a,l			; $630b
	swap a			; $630c
	and $f0			; $630e
	or $08			; $6310
	ld (de),a		; $6312

	ld c,l			; $6313
	ld a,$a3		; $6314
	call setTile		; $6316
	jp objectCreatePuff		; $6319


;;
; @addr{631c}
@findFirstSmogEnemy:
	ld h,FIRST_ENEMY_INDEX-1		; $631c

;;
; @param	h	Enemy index after which to start looking
; @param[out]	h	Index of first found smog enemy
; @param[out]	zflag	nz if no such enemy was found
; @addr{631c}
@findNextSmogEnemy:
	inc h			; $631e
---
	ld l,Enemy.enabled		; $631f
	ldi a,(hl)		; $6321
	or a			; $6322
	jr z,@nextEnemy	; $6323
	ldi a,(hl)		; $6325
	cp ENEMYID_SMOG			; $6326
	jr nz,@nextEnemy	; $6328
	ldi a,(hl)		; $632a
	bit 1,a			; $632b
	jr z,@nextEnemy	; $632d
	xor a			; $632f
	ret			; $6330

@nextEnemy:
	inc h			; $6331
	ld a,h			; $6332
	cp LAST_ENEMY_INDEX+1			; $6333
	jr c,---		; $6335
	or d			; $6337
	ret			; $6338

;;
; @addr{6339}
@spawnEnemy:
	push af			; $6339
	call getFreeEnemySlot		; $633a
	ld (hl),ENEMYID_SMOG		; $633d

	; Increment this.subid, which acts as the "enemy index" to spawn
	ld b,h			; $633f
	ld e,Interaction.subid		; $6340
	ld a,(de)		; $6342
	inc a			; $6343
	ld (de),a		; $6344
	add a			; $6345
	ld hl,@smogEnemyData		; $6346
	rst_addDoubleIndex			; $6349

	ld c,Enemy.subid		; $634a
	ldi a,(hl)		; $634c
	ld (bc),a		; $634d
	inc c			; $634e
	ld e,Interaction.var03		; $634f
	ld a,(de)		; $6351
	ld (bc),a		; $6352
	ld c,Enemy.yh		; $6353
	ldi a,(hl)		; $6355
	ld (bc),a		; $6356
	ld c,Enemy.xh		; $6357
	ldi a,(hl)		; $6359
	ld (bc),a		; $635a
	ld c,Enemy.direction		; $635b
	ldi a,(hl)		; $635d
	ld (bc),a		; $635e
	pop af			; $635f
	ret			; $6360

;;
; @param	b	Enemy 1
; @param	h	Enemy 2
; @param[out]	cflag	Set if they're close enough to merge (within 4 pixels)
; @addr{6361}
@checkEnemiesCloseEnoughToMerge:
	ld l,Enemy.var31		; $6361
	ld c,l			; $6363
	ld a,(bc)		; $6364
	sub (hl)		; $6365
	add $03			; $6366
	cp $07			; $6368
	ret nc			; $636a

	ld l,Enemy.yh		; $636b
	ld c,l			; $636d
	ld a,(bc)		; $636e
	sub (hl)		; $636f
	add $04			; $6370
	cp $09			; $6372
	ret nc			; $6374

	ld l,Enemy.xh		; $6375
	ld c,l			; $6377
	ld a,(bc)		; $6378
	sub (hl)		; $6379
	add $04			; $637a
	cp $09			; $637c
	ret			; $637e

@tileReplacementTable:
	.db @phase0Tiles - CADDR
	.db @phase1Tiles - CADDR
	.db @phase2Tiles - CADDR
	.db @phase3Tiles - CADDR

; Data format:
;   b0: position
;   b1: tile index to place at that position

@phase0Tiles:
	.db $11 $0c
	.db $37 $1d
	.db $46 $1d
	.db $47 $1d
	.db $48 $1d
	.db $76 $1d
	.db $77 $1d
	.db $78 $1d
	.db $87 $1d
	.db $00

@phase1Tiles:
	.db $11 $0c
	.db $3a $1c
	.db $44 $1d
	.db $47 $1d
	.db $4a $1d
	.db $54 $1c
	.db $57 $1d
	.db $64 $1d
	.db $67 $1d
	.db $00

@phase2Tiles:
	.db $11 $0c
	.db $57 $1c
	.db $62 $1d
	.db $63 $1d
	.db $64 $1d
	.db $6a $1d
	.db $6b $1d
	.db $6c $1d
	.db $77 $1c
	.db $00

@phase3Tiles:
	.db $11 $0c
	.db $25 $1d
	.db $26 $1d
	.db $27 $1d
	.db $32 $1d
	.db $37 $1d
	.db $3a $1c
	.db $3c $1d
	.db $42 $1d
	.db $46 $1d
	.db $4c $1d
	.db $52 $1d
	.db $59 $1d
	.db $5c $1d
	.db $62 $1c
	.db $68 $1d
	.db $6c $1d
	.db $72 $1d
	.db $74 $1d
	.db $77 $1c
	.db $7c $1d
	.db $00

@numEnemiesToSpawn: ; Each byte is for a different phase
	.db $02 $03 $02 $03


; Data format:
;   b0: var03
;   b1: Y position
;   b2: X position
;   b3: direction

@smogEnemyData: ; Each row is for a different enemy (across all phases)
	.db $00 $58 $78 $00
	.db $02 $38 $68 $01
	.db $02 $88 $88 $03
	.db $82 $58 $a8 $01
	.db $02 $38 $48 $01
	.db $02 $78 $78 $03
	.db $02 $58 $38 $01
	.db $82 $78 $b8 $01
	.db $02 $28 $28 $01
	.db $82 $58 $88 $03
	.db $82 $88 $c8 $01


@linkPlacementPositions: ; Positions to drop Link at for each phase
	.db $58 $78
	.db $28 $78
	.db $38 $78
	.db $38 $68


; ==============================================================================
; INTERACID_TRIFORCE_STONE
; ==============================================================================
interactionCode34:
	ld e,Interaction.state		; $641f
	ld a,(de)		; $6421
	rst_jumpTable			; $6422
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $6427
	ld (de),a		; $6429

	; Delete self if the stone was pushed already
	call getThisRoomFlags		; $642a
	and $c0			; $642d
	jp nz,interactionDelete		; $642f

	ld h,d			; $6432
	ld l,Interaction.collisionRadiusY		; $6433
	ld (hl),$03		; $6435
	inc l			; $6437
	ld (hl),$0a		; $6438

	call objectMarkSolidPosition		; $643a
	call interactionInitGraphics		; $643d
	ld a,PALH_98		; $6440
	call loadPaletteHeader		; $6442
	jp objectSetVisible83		; $6445

@state1:
	ld e,Interaction.state2		; $6448
	ld a,(de)		; $644a
	rst_jumpTable			; $644b
	.dw @substate0
	.dw @substate1
	.dw @substate2

@substate0:
	call objectPreventLinkFromPassing		; $6452
	call @checkPushedStoneLongEnough		; $6455
	ret nz			; $6458

; Begin stone-pushing cutscene

	call interactionIncState2		; $6459
	ld l,Interaction.speed		; $645c
	ld (hl),SPEED_40		; $645e
	ld l,Interaction.counter1		; $6460
	ld (hl),$40		; $6462

	ld a,SPECIALOBJECTID_LINK_CUTSCENE		; $6464
	call setLinkIDOverride		; $6466
	ld l,<w1Link.subid		; $6469
	ld (hl),$06		; $646b

	ld e,Interaction.angle		; $646d
	ld l,<w1Link.angle		; $646f
	ld a,(de)		; $6471
	ld (hl),a		; $6472

	ld l,<w1Link.speed		; $6473
	ld (hl),SPEED_80		; $6475

	ld hl,$cfd0		; $6477
	ld (hl),$06		; $647a
	ld a,SND_MAKUDISAPPEAR		; $647c
	jp playSound		; $647e

;;
; @param[out]	zflag	Set if Link has pushed against the stone long enough
; @addr{6481}
@checkPushedStoneLongEnough:
	; Check Link's X is close enough
	ld e,Interaction.xh		; $6481
	ld a,(de)		; $6483
	ld hl,w1Link.xh		; $6484
	sub (hl)		; $6487
	jr nc,+			; $6488
	cpl			; $648a
	inc a			; $648b
+
	cp $11			; $648c
	jr nc,@notPushing	; $648e

	; Check Link's Y is close enough
	ld l,<w1Link.yh		; $6490
	ld a,(hl)		; $6492
	cp $2a			; $6493
	jr nc,@notPushing	; $6495

	; Check he's facing left or right
	ld l,<w1Link.direction		; $6497
	ld a,(hl)		; $6499
	and $01			; $649a
	jr z,@notPushing	; $649c

	; Check if he's pushing
	call objectCheckLinkPushingAgainstCenter		; $649e
	jr nc,@notPushing	; $64a1

	; Make Link do the push animation
	ld a,$01		; $64a3
	ld (wForceLinkPushAnimation),a		; $64a5

	; Wait for him to push for enough frames
	call interactionDecCounter1		; $64a8
	ret nz			; $64ab

	; Get the direction Link is relative to the stone
	ld c,$28		; $64ac
	call objectCheckLinkWithinDistance		; $64ae

	ld e,Interaction.angle		; $64b1
	and $07			; $64b3
	xor $04			; $64b5
	add a			; $64b7
	add a			; $64b8
	ld (de),a		; $64b9
	xor a			; $64ba
	ret			; $64bb

@notPushing:
	xor a			; $64bc
	ld (wForceLinkPushAnimation),a		; $64bd
	ld a,$14		; $64c0
	ld e,Interaction.counter1		; $64c2
	ld (de),a		; $64c4
	or a			; $64c5
	ret			; $64c6


; In the process of pushing the stone
@substate1:
	call objectPreventLinkFromPassing		; $64c7
	call interactionDecCounter1		; $64ca
	jr nz,@applySpeed	; $64cd

; Finished pushing

	; Determine new X-position
	ld b,$48		; $64cf
	ld e,Interaction.angle		; $64d1
	ld a,(de)		; $64d3
	and $10			; $64d4
	jr z,+			; $64d6
	ld b,$28		; $64d8
+
	ld l,Interaction.xh		; $64da
	ld (hl),b		; $64dc

	call interactionIncState2		; $64dd

	; Determine bit to set on room flags (depends which way it was pushed)
	call getThisRoomFlags		; $64e0
	ld a,b			; $64e3
	cp $28			; $64e4
	ld b,$40		; $64e6
	jr z,+			; $64e8
	ld b,$80		; $64ea
+
	ld a,(hl)		; $64ec
	or b			; $64ed
	ld (hl),a		; $64ee

	call @setSolidTile		; $64ef

	ld a,SNDCTRL_STOPSFX		; $64f2
	call playSound		; $64f4
	ld a,SND_SOLVEPUZZLE_2		; $64f7
	jp playSound		; $64f9

@applySpeed:
	jp objectApplySpeed		; $64fc

@substate2:
	ret			; $64ff

;;
; @param	c	Tile to set collisions to "solid" for
; @addr{6500}
@setSolidTile:
	call objectGetShortPosition		; $6500
	ld c,a			; $6503
	ld b,>wRoomLayout		; $6504
	ld a,$00		; $6506
	ld (bc),a		; $6508
	ld b,>wRoomCollisions		; $6509
	ld a,$0f		; $650b
	ld (bc),a		; $650d
	ret			; $650e


; ==============================================================================
; INTERACID_CHILD
;
; Variables:
;   subid: personality type (0-6)
;   var03: index of script and code to run (changes based on personality and growth stage)
;   var37: animation base (depends on subid, or his personality type)
;   var39: $00 is normal; $01 gives "light" solidity (when he moves); $02 gives no solidity.
;   var3a: animation index? (added to base)
;   var3b: scratch variable for scripts
;   var3c: current index in "position list" data
;   var3d: number of entries in "position list" data (minus one)?
;   var3e/3f: pointer to "position list" data for when the child moves around
; ==============================================================================
interactionCode35:
	ld e,Interaction.state		; $650f
	ld a,(de)		; $6511
	rst_jumpTable			; $6512
	.dw @state0
	.dw _interac65_state1

@state0:
	call _childDetermineAnimationBase		; $6517
	call interactionInitGraphics		; $651a
	call interactionIncState		; $651d

	ld e,Interaction.var03		; $6520
	ld a,(de)		; $6522
	ld hl,_childScriptTable		; $6523
	rst_addDoubleIndex			; $6526
	ldi a,(hl)		; $6527
	ld h,(hl)		; $6528
	ld l,a			; $6529
	call interactionSetScript		; $652a

	ld e,Interaction.var03		; $652d
	ld a,(de)		; $652f
	rst_jumpTable			; $6530

	/* $00 */ .dw @initAnimation
	/* $01 */ .dw @hyperactiveStage4Or5
	/* $02 */ .dw @shyStage4Or5
	/* $03 */ .dw @curious
	/* $04 */ .dw @hyperactiveStage4Or5
	/* $05 */ .dw @shyStage4Or5
	/* $06 */ .dw @curious
	/* $07 */ .dw @hyperactiveStage6
	/* $08 */ .dw @shyStage6
	/* $09 */ .dw @curious
	/* $0a */ .dw @slacker
	/* $0b */ .dw @warrior
	/* $0c */ .dw @arborist
	/* $0d */ .dw @singer
	/* $0e */ .dw @slacker
	/* $0f */ .dw @script0f
	/* $10 */ .dw @arborist
	/* $11 */ .dw @singer
	/* $12 */ .dw @slacker
	/* $13 */ .dw @warrior
	/* $14 */ .dw @arborist
	/* $15 */ .dw @singer
	/* $16 */ .dw @val16
	/* $17 */ .dw @initAnimation
	/* $18 */ .dw @curious
	/* $19 */ .dw @slacker
	/* $1a */ .dw @initAnimation
	/* $1b */ .dw @initAnimation
	/* $1c */ .dw @singer

@initAnimation:
	ld e,Interaction.var37		; $656b
	ld a,(de)		; $656d
	call interactionSetAnimation		; $656e
	jp _childUpdateSolidityAndVisibility		; $6571

@hyperactiveStage6:
	ld a,$02		; $6574
	call _childLoadPositionListPointer		; $6576

@hyperactiveStage4Or5:
	ld h,d			; $6579
	ld l,Interaction.var39		; $657a
	ld (hl),$01		; $657c

	ld l,Interaction.speed		; $657e
	ld (hl),SPEED_180		; $6580
	ld l,Interaction.angle		; $6582
	ld (hl),$18		; $6584

	ld a,$00		; $6586

@setAnimation:
	ld h,d			; $6588
	ld l,Interaction.var3a		; $6589
	ld (hl),a		; $658b
	ld l,Interaction.var37		; $658c
	add (hl)		; $658e
	call interactionSetAnimation		; $658f
	jp _childUpdateSolidityAndVisibility		; $6592

@val16:
	call @hyperactiveStage4Or5		; $6595
	ld h,d			; $6598
	ld l,Interaction.speed		; $6599
	ld (hl),SPEED_100		; $659b
	ret			; $659d

@shyStage4Or5:
	ld a,$00		; $659e
	call _childLoadPositionListPointer		; $65a0
	jr ++			; $65a3

@shyStage6:
	ld a,$01		; $65a5
	call _childLoadPositionListPointer		; $65a7
++
	ld h,d			; $65aa
	ld l,Interaction.var39		; $65ab
	ld (hl),$01		; $65ad
	ld l,Interaction.speed		; $65af
	ld (hl),SPEED_200		; $65b1
	ld a,$00		; $65b3
	jr @setAnimation		; $65b5

@curious:
	ld h,d			; $65b7
	ld l,Interaction.var39		; $65b8
	ld (hl),$02		; $65ba
	ld a,$00		; $65bc
	jr @setAnimation		; $65be

@slacker:
	ld a,$00		; $65c0
	jr @setAnimation		; $65c2

@warrior:
	ld a,$03		; $65c4
	call _childLoadPositionListPointer		; $65c6
	jr ++			; $65c9

@script0f:
	ld a,$04		; $65cb
	call _childLoadPositionListPointer		; $65cd
++
	ld h,d			; $65d0
	ld l,Interaction.var39		; $65d1
	ld (hl),$01		; $65d3
	ld l,Interaction.speed		; $65d5
	ld (hl),SPEED_80		; $65d7
	ld a,$00		; $65d9
	jr @setAnimation		; $65db

@arborist:
	ld a,$03		; $65dd
	jr @setAnimation		; $65df

@singer:
	ld a,$00		; $65e1
	jr @setAnimation		; $65e3


_interac65_state1:
	ld e,Interaction.var03		; $65e5
	ld a,(de)		; $65e7
	rst_jumpTable			; $65e8

	/* $00 */ .dw @updateAnimationAndSolidity
	/* $01 */ .dw @hyperactiveMovement
	/* $02 */ .dw @shyMovement
	/* $03 */ .dw @curiousMovement
	/* $04 */ .dw @hyperactiveMovement
	/* $05 */ .dw @shyMovement
	/* $06 */ .dw @curiousMovement
	/* $07 */ .dw @usePositionList
	/* $08 */ .dw @shyMovement
	/* $09 */ .dw @curiousMovement
	/* $0a */ .dw @slackerMovement
	/* $0b */ .dw @usePositionList
	/* $0c */ .dw @arboristMovement
	/* $0d */ .dw @singerMovement
	/* $0e */ .dw @slackerMovement
	/* $0f */ .dw @usePositionList
	/* $10 */ .dw @arboristMovement
	/* $11 */ .dw @singerMovement
	/* $12 */ .dw @slackerMovement
	/* $13 */ .dw @usePositionList
	/* $14 */ .dw @arboristMovement
	/* $15 */ .dw @singerMovement
	/* $16 */ .dw @val16
	/* $17 */ .dw @updateAnimationAndSolidity
	/* $18 */ .dw @val1b
	/* $19 */ .dw @slackerMovement
	/* $1a */ .dw @updateAnimationAndSolidity
	/* $1b */ .dw @updateAnimationAndSolidity
	/* $1c */ .dw @singerMovement

@hyperactiveMovement:
	ld e,Interaction.counter1		; $6623
	ld a,(de)		; $6625
	or a			; $6626
	jr nz,+			; $6627
	call _childUpdateHyperactiveMovement		; $6629
+

@arboristMovement:
	call interactionRunScript		; $662c

@updateAnimationAndSolidity:
	jp _childUpdateAnimationAndSolidity		; $662f

@val16:
	call _childUpdateUnknownMovement		; $6632
	jp _childUpdateAnimationAndSolidity		; $6635

@shyMovement:
	ld e,Interaction.counter1		; $6638
	ld a,(de)		; $663a
	or a			; $663b
	jr nz,+			; $663c
	call _childUpdateShyMovement		; $663e
+
	jr @runScriptAndUpdateAnimation		; $6641

@usePositionList:
	ld e,Interaction.counter1		; $6643
	ld a,(de)		; $6645
	or a			; $6646
	jr nz,++		; $6647
	call _childUpdateAngleAndApplySpeed		; $6649
	call _childCheckAnimationDirectionChanged		; $664c
	call _childCheckReachedDestination		; $664f
	call c,_childIncPositionIndex		; $6652
++
	jr @runScriptAndUpdateAnimation		; $6655

@curiousMovement:
	call _childUpdateCuriousMovement		; $6657
	ld e,Interaction.var3d		; $665a
	ld a,(de)		; $665c
	or a			; $665d
	call z,interactionRunScript		; $665e

@val1b:
	jp _childUpdateAnimationAndSolidity		; $6661

@slackerMovement:
	ld a,(wFrameCounter)		; $6664
	and $1f			; $6667
	jr nz,++		; $6669
	ld e,Interaction.animParameter		; $666b
	ld a,(de)		; $666d
	and $01			; $666e
	ld c,$08		; $6670
	jr nz,+			; $6672
	ld c,$fc		; $6674
+
	ld b,$f4		; $6676
	call objectCreateFloatingMusicNote		; $6678
++
	jr @runScriptAndUpdateAnimation		; $667b

@singerMovement:
	ld a,(wFrameCounter)		; $667d
	and $1f			; $6680
	jr nz,@runScriptAndUpdateAnimation	; $6682
	ld e,Interaction.direction		; $6684
	ld a,(de)		; $6686
	or a			; $6687
	ld c,$fc		; $6688
	jr z,+			; $668a
	ld c,$00		; $668c
+
	ld b,$fc		; $668e
	call objectCreateFloatingMusicNote		; $6690

@runScriptAndUpdateAnimation:
	call interactionRunScript		; $6693
	jp _childUpdateAnimationAndSolidity		; $6696


;;
; @addr{6699}
_childUpdateAnimationAndSolidity:
	call interactionAnimate		; $6699

;;
; @addr{669c}
_childUpdateSolidityAndVisibility:
	ld e,Interaction.var39		; $669c
	ld a,(de)		; $669e
	cp $01			; $669f
	jr z,++			; $66a1
	cp $02			; $66a3
	jp z,objectSetPriorityRelativeToLink_withTerrainEffects		; $66a5
	call objectPreventLinkFromPassing		; $66a8
	jp objectSetPriorityRelativeToLink_withTerrainEffects		; $66ab
++
	call objectPushLinkAwayOnCollision		; $66ae
	jp objectSetPriorityRelativeToLink_withTerrainEffects		; $66b1

;;
; Writes the "base" animation index to var37 based on subid (personality type)?
; @addr{66b4}
_childDetermineAnimationBase:
	ld e,Interaction.subid		; $66b4
	ld a,(de)		; $66b6
	ld hl,@animations		; $66b7
	rst_addAToHl			; $66ba
	ld a,(hl)		; $66bb
	ld e,Interaction.var37		; $66bc
	ld (de),a		; $66be
	ret			; $66bf

@animations:
	.db $00 $02 $05 $08 $0b $11 $15 $17

;;
; @addr{66c8}
_childUpdateHyperactiveMovement:
	call objectApplySpeed		; $66c8
	ld h,d			; $66cb
	ld l,Interaction.xh		; $66cc
	ld a,(hl)		; $66ce
	sub $29			; $66cf
	cp $40			; $66d1
	ret c			; $66d3
	bit 7,a			; $66d4
	jr nz,+			; $66d6
	dec (hl)		; $66d8
	dec (hl)		; $66d9
+
	inc (hl)		; $66da
	ld l,Interaction.var3c		; $66db
	ld a,(hl)		; $66dd
	inc a			; $66de
	and $03			; $66df
	ld (hl),a		; $66e1
	ld bc,_childHyperactiveMovementAngles		; $66e2
	call addAToBc		; $66e5
	ld a,(bc)		; $66e8
	ld l,Interaction.angle		; $66e9
	ld (hl),a		; $66eb

_childFlipAnimation:
	ld l,Interaction.var3a		; $66ec
	ld a,(hl)		; $66ee
	xor $01			; $66ef
	ld (hl),a		; $66f1
	ld l,Interaction.var37		; $66f2
	add (hl)		; $66f4
	jp interactionSetAnimation		; $66f5

_childHyperactiveMovementAngles:
	.db $18 $0a $18 $06

;;
; @addr{66fc}
_childUpdateUnknownMovement:
	call objectApplySpeed		; $66fc
	ld e,Interaction.xh		; $66ff
	ld a,(de)		; $6701
	sub $14			; $6702
	cp $28			; $6704
	ret c			; $6706
	ld h,d			; $6707
	ld l,Interaction.angle		; $6708
	ld a,(hl)		; $670a
	xor $10			; $670b
	ld (hl),a		; $670d
	jr _childFlipAnimation		; $670e

;;
; Updates movement for "shy" personality type (runs away when Link approaches)
; @addr{6710}
_childUpdateShyMovement:
	ld e,Interaction.state2		; $6710
	ld a,(de)		; $6712
	rst_jumpTable			; $6713
	.dw @substate0
	.dw @substate1

@substate0:
	ld c,$18		; $6718
	call objectCheckLinkWithinDistance		; $671a
	ret nc			; $671d

	call interactionIncState2		; $671e

@substate1:
	call _childUpdateAngleAndApplySpeed		; $6721
	call _childCheckReachedDestination		; $6724
	ret nc			; $6727

	ld h,d			; $6728
	ld l,Interaction.state2		; $6729
	ld (hl),$00		; $672b
	jp _childIncPositionIndex		; $672d

;;
; @addr{6730}
_childUpdateAngleAndApplySpeed:
	ld h,d			; $6730
	ld l,Interaction.var3c		; $6731
	ld a,(hl)		; $6733
	add a			; $6734
	ld b,a			; $6735
	ld e,Interaction.var3f		; $6736
	ld a,(de)		; $6738
	ld l,a			; $6739
	ld e,Interaction.var3e		; $673a
	ld a,(de)		; $673c
	ld h,a			; $673d
	ld a,b			; $673e
	rst_addAToHl			; $673f
	ld b,(hl)		; $6740
	inc hl			; $6741
	ld c,(hl)		; $6742
	call objectGetRelativeAngle		; $6743
	ld e,Interaction.angle		; $6746
	ld (de),a		; $6748
	jp objectApplySpeed		; $6749

;;
; @param[out]	cflag	Set if the child's reached the position he's moving toward (or is
;			within 1 pixel from the destination on both axes)
; @addr{674c}
_childCheckReachedDestination:
	ld h,d			; $674c
	ld l,Interaction.var3c		; $674d
	ld a,(hl)		; $674f
	add a			; $6750
	push af			; $6751

	ld e,Interaction.var3f		; $6752
	ld a,(de)		; $6754
	ld c,a			; $6755
	ld e,Interaction.var3e		; $6756
	ld a,(de)		; $6758
	ld b,a			; $6759

	pop af			; $675a
	call addAToBc		; $675b
	ld l,Interaction.yh		; $675e
	ld a,(bc)		; $6760
	sub (hl)		; $6761
	add $01			; $6762
	cp $03			; $6764
	ret nc			; $6766
	inc bc			; $6767
	ld l,Interaction.xh		; $6768
	ld a,(bc)		; $676a
	sub (hl)		; $676b
	add $01			; $676c
	cp $03			; $676e
	ret			; $6770

;;
; Updates animation if the child's direction has changed?
; @addr{6771}
_childCheckAnimationDirectionChanged:
	ld h,d			; $6771
	ld l,Interaction.angle		; $6772
	ld a,(hl)		; $6774
	swap a			; $6775
	and $01			; $6777
	xor $01			; $6779
	ld l,Interaction.direction		; $677b
	cp (hl)			; $677d
	ret z			; $677e
	ld (hl),a		; $677f
	ld l,Interaction.var3a		; $6780
	add (hl)		; $6782
	ld l,Interaction.var37		; $6783
	add (hl)		; $6785
	jp interactionSetAnimation		; $6786

;;
; @addr{6789}
_childIncPositionIndex:
	ld h,d			; $6789
	ld l,Interaction.var3d		; $678a
	ld a,(hl)		; $678c
	ld l,Interaction.var3c		; $678d
	inc (hl)		; $678f
	cp (hl)			; $6790
	ret nc			; $6791
	ld (hl),$00		; $6792
	ret			; $6794

;;
; Loads address of position list into var3e/var3f, and the number of positions to loop
; through (minus one) into var3d.
;
; @param	a	Data index
; @addr{6795}
_childLoadPositionListPointer:
	add a			; $6795
	add a			; $6796
	ld hl,@positionTable		; $6797
	rst_addAToHl			; $679a
	ld e,Interaction.var3f		; $679b
	ldi a,(hl)		; $679d
	ld (de),a		; $679e
	ld e,Interaction.var3e		; $679f
	ldi a,(hl)		; $67a1
	ld (de),a		; $67a2
	ld e,Interaction.var3d		; $67a3
	ldi a,(hl)		; $67a5
	ld (de),a		; $67a6
	ret			; $67a7


; Data format:
;  word: pointer to position list
;  byte: number of entries in the list (minus one)
;  byte: unused
@positionTable:
	dwbb @list0 $07 $00
	dwbb @list1 $03 $00
	dwbb @list2 $0b $00
	dwbb @list3 $01 $00
	dwbb @list4 $03 $00

; Each 2 bytes is a position the child will move to.
@list0:
	.db $68 $18
	.db $68 $68
	.db $28 $68
	.db $68 $18
	.db $38 $18
	.db $68 $68
	.db $28 $68
	.db $38 $18

@list1:
	.db $18 $18
	.db $58 $18
	.db $58 $48
	.db $18 $48

@list2:
	.db $28 $48
	.db $18 $44
	.db $18 $28
	.db $20 $18
	.db $2c $0c
	.db $38 $08
	.db $44 $0c
	.db $50 $18
	.db $58 $28
	.db $58 $44
	.db $48 $48
	.db $38 $4c

@list3:
	.db $48 $18
	.db $48 $68
@list4:
	.db $18 $30
	.db $58 $30
	.db $58 $48
	.db $18 $48

;;
; @addr{67f8}
_childUpdateCuriousMovement:
	ld e,Interaction.state2		; $67f8
	ld a,(de)		; $67fa
	rst_jumpTable			; $67fb
	.dw @substate0
	.dw @substate1
	.dw @substate2

@substate0:
	ld h,d			; $6802
	ld l,Interaction.speed		; $6803
	ld (hl),SPEED_100		; $6805
	ld l,Interaction.angle		; $6807
	ld (hl),$18		; $6809

@gotoSubstate1AndJump:
	ld h,d			; $680b
	ld l,Interaction.state2		; $680c
	ld (hl),$01		; $680e
	ld l,Interaction.var3d		; $6810
	ld (hl),$01		; $6812

	ld l,Interaction.speedZ		; $6814
	ld (hl),$00		; $6816
	inc hl			; $6818
	ld (hl),$fb		; $6819
	ld a,SND_JUMP		; $681b
	jp playSound		; $681d

@substate1:
	ld c,$50		; $6820
	call objectUpdateSpeedZ_paramC		; $6822
	jp nz,objectApplySpeed		; $6825

	call interactionIncState2		; $6828

	ld l,Interaction.var3d		; $682b
	ld (hl),$00		; $682d
	ld l,Interaction.var3c		; $682f
	ld (hl),$78		; $6831

	ld l,Interaction.angle		; $6833
	ld a,(hl)		; $6835
	xor $10			; $6836
	ld (hl),a		; $6838
	ret			; $6839

@substate2:
	ld h,d			; $683a
	ld l,Interaction.var3c		; $683b
	dec (hl)		; $683d
	ret nz			; $683e
	jr @gotoSubstate1AndJump		; $683f


_childScriptTable:
	.dw childScript00
	.dw childScript_stage4_hyperactive
	.dw childScript_stage4_shy
	.dw childScript_stage4_curious
	.dw childScript_stage5_hyperactive
	.dw childScript_stage5_shy
	.dw childScript_stage5_curious
	.dw childScript_stage6_hyperactive
	.dw childScript_stage6_shy
	.dw childScript_stage6_curious
	.dw childScript_stage7_slacker
	.dw childScript_stage7_warrior
	.dw childScript_stage7_arborist
	.dw childScript_stage7_singer
	.dw childScript_stage8_slacker
	.dw childScript_stage8_warrior
	.dw childScript_stage8_arborist
	.dw childScript_stage8_singer
	.dw childScript_stage9_slacker
	.dw childScript_stage9_warrior
	.dw childScript_stage9_arborist
	.dw childScript_stage9_singer
	.dw childScript00
	.dw childScript00
	.dw childScript00
	.dw childScript00
	.dw childScript00
	.dw childScript00
	.dw childScript00


; ==============================================================================
; INTERACID_NAYRU
; ==============================================================================
interactionCode36:
	ld e,Interaction.state		; $687b
	ld a,(de)		; $687d
	rst_jumpTable			; $687e
	.dw nayruState0
	.dw _nayruState1

;;
; @addr{6883}
nayruState0:
	ld a,$01		; $6883
	ld (de),a		; $6885
	call interactionInitGraphics		; $6886
	call objectSetVisiblec2		; $6889
	call @initSubid		; $688c

	ld e,Interaction.enabled		; $688f
	ld a,(de)		; $6891
	or a			; $6892
	jp nz,objectMarkSolidPosition		; $6893
	ret			; $6896

@initSubid:
	ld e,Interaction.subid		; $6897
	ld a,(de)		; $6899
	rst_jumpTable			; $689a
	.dw @init00
	.dw @init01
	.dw @init02
	.dw @init03
	.dw @init04
	.dw @init05
	.dw @init06
	.dw @init07
	.dw @init08
	.dw @init09
	.dw @init0a
	.dw @init0b
	.dw @init0c
	.dw @init0d
	.dw @init0e
	.dw @init0f
	.dw @init10
	.dw @init11
	.dw @init12
	.dw @init13

@init00:
	ld a,$03		; $68c3
	call setMusicVolume		; $68c5
	call @loadEvilPalette		; $68c8

@setSingingAnimation:
	ld a,$04		; $68cb
	call interactionSetAnimation		; $68cd
	jp interactionLoadExtraGraphics		; $68d0

@init01:
	ld a,GLOBALFLAG_0b		; $68d3
	call checkGlobalFlag		; $68d5
	jp nz,interactionDelete		; $68d8

	call objectSetInvisible		; $68db

	ld hl,nayruScript01		; $68de
	call interactionSetScript		; $68e1

@init0e: ; This is also called from ambi subids 4 and 5 (to initialize possessed palettes)
	ld a,$06		; $68e4
	ld e,Interaction.oamFlags		; $68e6
	ld (de),a		; $68e8

@loadEvilPalette:
	; Load the possessed version of her palette into palette 6.
	ld a,PALH_97		; $68e9
	jp loadPaletteHeader		; $68eb

@init02:
	ld a,($cfd0)		; $68ee
	cp $03			; $68f1
	jr z,++			; $68f3

	ld a,$05		; $68f5
	call interactionSetAnimation		; $68f7
	ld hl,nayruScript02_part1		; $68fa
	call interactionSetScript		; $68fd
	jp objectSetInvisible		; $6900
++
	ld a,$02		; $6903
	call interactionSetAnimation		; $6905

	ld hl,nayruScript02_part2		; $6908
	jp interactionSetScript		; $690b

@init04:
	ld hl,nayruScript04_part1		; $690e
	ld a,($cfd0)		; $6911
	cp $0b			; $6914
	jr nz,++		; $6916

	ld bc,$4840		; $6918
	call interactionSetPosition		; $691b
	call checkIsLinkedGame		; $691e
	jr nz,@init03	; $6921

	ld hl,nayruScript04_part2		; $6923
++
	call interactionSetScript		; $6926

@init03:
	xor a			; $6929
	jp interactionSetAnimation		; $692a

@init05:
	ld a,$05		; $692d
	call interactionSetAnimation		; $692f
	ld hl,nayruScript05		; $6932
	call interactionSetScript		; $6935
	jp objectSetInvisible		; $6938

@init06:
	ld a,$07		; $693b
	jp interactionSetAnimation		; $693d

@init07:
	ld e,Interaction.counter1		; $6940
	ld a,$1e		; $6942
	ld (de),a		; $6944
	call interactionLoadExtraGraphics		; $6945
	jp interactionSetAlwaysUpdateBit		; $6948

@init08:
	ld hl,nayruScript08		; $694b
	call interactionSetScript		; $694e
	call objectSetVisible82		; $6951
	ld a,$03		; $6954
	jp interactionSetAnimation		; $6956

@init09:
	ld hl,nayruScript09		; $6959
	jp interactionSetScript		; $695c

@init0a:
	call checkIsLinkedGame		; $695f
	jp z,interactionDelete		; $6962

	ld a,TREASURE_MAKU_SEED		; $6965
	call checkTreasureObtained		; $6967
	jp nc,interactionDelete		; $696a

	ld a,GLOBALFLAG_PRE_BLACK_TOWER_CUTSCENE_DONE		; $696d
	call checkGlobalFlag		; $696f
	jp nz,interactionDelete		; $6972

	ld a,$01		; $6975
	call interactionSetAnimation		; $6977
	ld hl,nayruScript0a		; $697a
	jp interactionSetScript		; $697d

@init0b:
	ld a,GLOBALFLAG_FINISHEDGAME		; $6980
	call checkGlobalFlag		; $6982
	jp nz,interactionDelete		; $6985

	ld a,GLOBALFLAG_SAVED_NAYRU		; $6988
	call checkGlobalFlag		; $698a
	jp z,interactionDelete		; $698d

	ld a,TREASURE_MAKU_SEED		; $6990
	call checkTreasureObtained		; $6992
	jp c,interactionDelete		; $6995

	ld a,<TX_1d14		; $6998

@runGenericNpc:
	ld e,Interaction.textID		; $699a
	ld (de),a		; $699c
	inc e			; $699d
	ld a,>TX_1d00		; $699e
	ld (de),a		; $69a0
	ld hl,genericNpcScript		; $69a1
	jp interactionSetScript		; $69a4

@init0c:
	ld a,GLOBALFLAG_FINISHEDGAME		; $69a7
	call checkGlobalFlag		; $69a9
	jp nz,interactionDelete		; $69ac

	ld a,GLOBALFLAG_PRE_BLACK_TOWER_CUTSCENE_DONE		; $69af
	call checkGlobalFlag		; $69b1
	jp z,interactionDelete		; $69b4

	ld a,GLOBALFLAG_FLAME_OF_DESPAIR_LIT		; $69b7
	call checkGlobalFlag		; $69b9
	jp nz,interactionDelete		; $69bc

	ld a,<TX_1d15		; $69bf
	jr @runGenericNpc		; $69c1

@init0d:
	ld a,GLOBALFLAG_FLAME_OF_DESPAIR_LIT		; $69c3
	call checkGlobalFlag		; $69c5
	jp z,interactionDelete		; $69c8

	ld a,GLOBALFLAG_FINISHEDGAME		; $69cb
	call checkGlobalFlag		; $69cd
	jp nz,interactionDelete		; $69d0

	ld a,<TX_1d17		; $69d3
	jr @runGenericNpc		; $69d5

@init0f:
	ld a,TREASURE_MAKU_SEED		; $69d7
	call checkTreasureObtained		; $69d9
	jp nc,interactionDelete		; $69dc

	ld a,GLOBALFLAG_PRE_BLACK_TOWER_CUTSCENE_DONE		; $69df
	call checkGlobalFlag		; $69e1
	jp nz,interactionDelete		; $69e4

	call checkIsLinkedGame		; $69e7
	ld c,$32		; $69ea
	call nz,objectSetShortPosition		; $69ec
	ld a,<TX_1d20		; $69ef
	jr @runGenericNpc		; $69f1

@init10:
	ld a,>TX_1d00		; $69f3
	call interactionSetHighTextIndex		; $69f5
	ld e,Interaction.var3f		; $69f8
	ld a,$ff		; $69fa
	ld (de),a		; $69fc
	ld hl,nayruScript10		; $69fd
	jp interactionSetScript		; $6a00

@init11:
	xor a			; $6a03
	call interactionSetAnimation		; $6a04
	callab scriptHlp.objectWritePositionTocfd5		; $6a07
	ld a,>TX_1d00		; $6a0f
	call interactionSetHighTextIndex		; $6a11
	ld hl,nayruScript11		; $6a14
	jp interactionSetScript		; $6a17

@init12:
	call interactionSetAlwaysUpdateBit		; $6a1a
	ld bc,$4870		; $6a1d
	jp interactionSetPosition		; $6a20

@init13:
	ld a,GLOBALFLAG_FINISHEDGAME		; $6a23
	call checkGlobalFlag		; $6a25
	jp z,interactionDelete		; $6a28

	ld hl,nayruScript13		; $6a2b
	call interactionSetScript		; $6a2e

	ld a,>TX_1d00		; $6a31
	call interactionSetHighTextIndex		; $6a33

	ld a,MUS_OVERWORLD_PRES		; $6a36
	ld (wActiveMusic2),a		; $6a38
	ld a,$ff		; $6a3b
	ld (wActiveMusic),a		; $6a3d
	jp @setSingingAnimation		; $6a40

;;
; @addr{6a43}
_nayruState1:
	ld e,Interaction.subid		; $6a43
	ld a,(de)		; $6a45
	rst_jumpTable			; $6a46
	.dw _nayruSubid00
	.dw _nayruSubid01
	.dw _nayruSubid02
	.dw _nayruSubid03
	.dw _nayruSubid04
	.dw _nayruSubid05
	.dw _nayruSubid00
	.dw _nayruSubid07
	.dw _nayruAnimateAndRunScript
	.dw _nayruSubid09
	.dw _nayruSubid0a
	.dw _nayruAsNpc
	.dw _nayruAsNpc
	.dw _nayruAsNpc
	.dw interactionAnimate
	.dw _nayruAsNpc
	.dw _nayruSubid10
	.dw _nayruAnimateAndRunScript
	.dw interactionAnimate
	.dw _nayruSubid13


; Subid $00: cutscene at the beginning of the game (Nayru talks, gets possessed, goes back
; in time).
; Variables:
;   var38:    "Status" of possession flickering
;   var39:    Counter for number of times to flicker palette while being possessed.
;   var3a/3b: Number of frames to stay in her "unpossessed" (var3a) or "possessed" (var3b)
;             palette. These are copied to var39. Her "possessed" counter gets longer while
;             the other gets shorter.
_nayruSubid00:
	ld e,Interaction.state2		; $6a6f
	ld a,(de)		; $6a71
	rst_jumpTable			; $6a72
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4
	.dw @substate5
	.dw @substate6
	.dw @substate7
	.dw @substate8

; Waiting for Link to approach (signal in $cfd0)
@substate0:
	call interactionAnimate		; $6a85
	ld a,($cfd0)		; $6a88
	cp $09			; $6a8b
	jp nz,@createMusicNotes		; $6a8d

	call interactionIncState2		; $6a90
	ld a,$0f		; $6a93
	ld l,Interaction.var39		; $6a95
	ldi (hl),a		; $6a97
	ldi (hl),a		; $6a98
	ld (hl),$01		; $6a99
	ld hl,nayruScript00_part1		; $6a9b
	jp interactionSetScript		; $6a9e

; This is also called from outside subid 0
@createMusicNotes:
	ld h,d			; $6aa1
	ld l,Interaction.animParameter		; $6aa2
	ld a,(hl)		; $6aa4
	or a			; $6aa5
	ret z			; $6aa6
	ld (hl),$00		; $6aa7
	dec a			; $6aa9
	ld c,-6		; $6aaa
	jr z,+			; $6aac
	ld c,8		; $6aae
+
	ld b,$fc		; $6ab0
	jp objectCreateFloatingMusicNote		; $6ab2


; Palette is flickering while being possessed
@substate1:
	call interactionAnimate		; $6ab5
	call interactionRunScript		; $6ab8
	ld a,($cfd0)		; $6abb
	cp $16			; $6abe
	ret nz			; $6ac0

	; Sway horizontally while moving
	ld e,Interaction.counter2		; $6ac1
	ld a,(de)		; $6ac3
	or a			; $6ac4
	call nz,@swayHorizontally		; $6ac5

	; Flip the OAM flags when var39 reaches 0
	ld h,d			; $6ac8
	ld l,Interaction.var39		; $6ac9
	dec (hl)		; $6acb
	ret nz			; $6acc
	ld l,Interaction.oamFlags		; $6acd
	ld a,(hl)		; $6acf
	dec a			; $6ad0
	xor $05			; $6ad1
	inc a			; $6ad3
	ld (hl),a		; $6ad4

	call _nayruUpdatePossessionPaletteDurations		; $6ad5
	jr nz,++		; $6ad8

	; Done flickering with possession
	call interactionIncState2		; $6ada
	ld l,Interaction.oamFlags		; $6add
	ld (hl),$06		; $6adf
	ret			; $6ae1
++
	ld l,Interaction.var3a		; $6ae2
	ld b,(hl)		; $6ae4
	inc l			; $6ae5
	ld c,(hl)		; $6ae6
	ld l,Interaction.oamFlags		; $6ae7
	ld a,(hl)		; $6ae9
	cp $06			; $6aea
	ld a,b			; $6aec
	jr nz,+			; $6aed
	ld a,c			; $6aef
+
	ld l,Interaction.var39		; $6af0
	ld (hl),a		; $6af2
	ret			; $6af3

;;
; Nayru sways horizontally (3 pixels left, 3 pixels right, repeat)
; @addr{6af4}
@swayHorizontally:
	ld a,(wFrameCounter)		; $6af4
	and $07			; $6af7
	ret nz			; $6af9
	ld a,(wFrameCounter)		; $6afa
	and $38			; $6afd
	swap a			; $6aff
	rlca			; $6b01
	ld hl,@@xOffsets		; $6b02
	rst_addAToHl			; $6b05
	ld e,Interaction.xh		; $6b06
	ld a,(hl)		; $6b08
	ld b,a			; $6b09
	ld a,(de)		; $6b0a
	add b			; $6b0b
	ld (de),a		; $6b0c
	ret			; $6b0d

@@xOffsets:
	.db $ff $ff $ff $00 $01 $01 $01 $00


; Waiting for script to end
@substate2:
	call interactionRunScript		; $6b16
	ret nc			; $6b19
	jp interactionIncState2		; $6b1a


; Waiting for some kind of signal?
@substate3:
	ld a,($cfd0)		; $6b1d
	cp $1a			; $6b20
	ret nz			; $6b22
	call interactionIncState2		; $6b23
	ld l,Interaction.counter1		; $6b26
	ld (hl),60		; $6b28
	ret			; $6b2a


; Waiting 60 frames before jumping
@substate4:
	call interactionAnimate		; $6b2b
	call interactionDecCounter1		; $6b2e
	ret nz			; $6b31

	call interactionIncState2		; $6b32
	ld bc,-$400		; $6b35
	call objectSetSpeedZ		; $6b38
	ld a,SND_SWORDSPIN		; $6b3b
	call playSound		; $6b3d
	ld a,$05		; $6b40
	jp interactionSetAnimation		; $6b42


; Jumping until off-screen
@substate5:
	xor a			; $6b45
	call objectUpdateSpeedZ		; $6b46
	ld e,Interaction.zh		; $6b49
	ld a,(de)		; $6b4b
	cp $80			; $6b4c
	ret nc			; $6b4e

	; Set position to land at
	ld bc,$3828		; $6b4f
	call interactionSetPosition		; $6b52
	ld l,Interaction.zh		; $6b55
	ld (hl),$80		; $6b57

	ld l,Interaction.counter1		; $6b59
	ld (hl),$1e		; $6b5b

	jp interactionIncState2		; $6b5d


; Brief delay before falling back down
@substate6:
	call interactionDecCounter1		; $6b60
	ret nz			; $6b63
	call interactionIncState2		; $6b64
	ld bc,$0040		; $6b67
	jp objectSetSpeedZ		; $6b6a


; Falling back down
@substate7:
	ld c,$20		; $6b6d
	call objectUpdateSpeedZ_paramC		; $6b6f
	ret nz			; $6b72

	ld a,$1b		; $6b73
	ld ($cfd0),a		; $6b75

	; Start next script
	ld hl,nayruScript00_part2		; $6b78
	call interactionSetScript		; $6b7b
	ld a,SND_SLASH		; $6b7e
	call playSound		; $6b80
	jp interactionIncState2		; $6b83


; Next script running; make Nayru transparent when signal is given. Delete self when the
; script finishes.
@substate8:
	call interactionAnimate		; $6b86
	call interactionRunScript		; $6b89
	jr nc,++		; $6b8c
	jp interactionDelete		; $6b8e
++
	; Wait for signal from script to make her transparent
	ld e,Interaction.var3d		; $6b91
	ld a,(de)		; $6b93
	or a			; $6b94
	ret z			; $6b95
	ld b,$01		; $6b96
	jp objectFlickerVisibility		; $6b98


; Subid $01: Cutscene in Ambi's palace after getting bombs
_nayruSubid01:
	call _nayruAnimateAndRunScript		; $6b9b
	ret nc			; $6b9e

; Script finished; load the next room.

	push de			; $6b9f
	ld bc,$0146		; $6ba0
	call disableLcdAndLoadRoom		; $6ba3
	call resetCamera		; $6ba6

	; Need to load the guards since the "disableLcdAndLoadRoom" function call doesn't
	; load the room's objects
	ld hl,objectData.ambisPalaceEntranceGuards		; $6ba9
	call parseGivenObjectData		; $6bac

	; Need to re-initialize the link object
	ld hl,w1Link.enabled		; $6baf
	ld (hl),$03		; $6bb2
	ld l,<w1Link.yh		; $6bb4
	ld (hl),$38		; $6bb6
	ld l,<w1Link.xh		; $6bb8
	ld (hl),$50		; $6bba

	; Need to re-enable the LCD
	ld a,$02		; $6bbc
	call loadGfxRegisterStateIndex		; $6bbe

	pop de			; $6bc1
	ld a,(wActiveMusic2)		; $6bc2
	ld (wActiveMusic),a		; $6bc5
	call playSound		; $6bc8
	jp clearPaletteFadeVariablesAndRefreshPalettes		; $6bcb


; Subid $02: Cutscene on maku tree screen after being saved
_nayruSubid02:
	ld e,Interaction.state2		; $6bce
	ld a,(de)		; $6bd0
	rst_jumpTable			; $6bd1
	.dw _nayruSubid02Substate0
	.dw _nayruSubid02Substate1
	.dw _nayruSubid02Substate2

;;
; @addr{6bd8}
_nayruSubid02Substate0: ; This is also called by Ralph in the same cutscene
	ld a,($cfd0)		; $6bd8
	cp $07			; $6bdb
	jr nz,@createNotes	; $6bdd

	; When signal is received from $cfd0, choose direction randomly (left/right) and
	; go to substate 1
	call getRandomNumber		; $6bdf
	and $02			; $6be2
	or $01			; $6be4
	ld e,Interaction.direction		; $6be6
	ld (de),a		; $6be8

	call _nayruSetCounter1Randomly		; $6be9
	jp interactionIncState2		; $6bec

@createNotes:
	call _nayruSubid00@createMusicNotes		; $6bef

;;
; @addr{6bf2}
_nayruAnimateAndRunScript:
	call interactionAnimateBasedOnSpeed		; $6bf2
	jp interactionRunScript		; $6bf5

;;
; @addr{6bf8}
_nayruSubid02Substate1:
	ld a,($cfd0)		; $6bf8
	cp $08			; $6bfb
	jr nz,_nayruFlipDirectionAtRandomIntervals		; $6bfd

	call interactionIncState2		; $6bff

	ld hl,nayruScript02_part3		; $6c02
	call interactionSetScript		; $6c05

	ld a,$01		; $6c08
	jp interactionSetAnimation		; $6c0a

;;
; This is also called by Ralph in the same cutscene
; @addr{6c0d}
_nayruFlipDirectionAtRandomIntervals:
	call interactionDecCounter1		; $6c0d
	ret nz			; $6c10
	ld l,Interaction.direction		; $6c11
	ld a,(hl)		; $6c13
	xor $02			; $6c14
	ld (hl),a		; $6c16
	call interactionSetAnimation		; $6c17

;;
; @addr{6c1a}
_nayruSetCounter1Randomly:
	call getRandomNumber_noPreserveVars		; $6c1a
	and $03			; $6c1d
	add a			; $6c1f
	add a			; $6c20
	add $10			; $6c21
	ld e,Interaction.counter1		; $6c23
	ld (de),a		; $6c25
	ret			; $6c26

_nayruSubid02Substate2:
	call _nayruAnimateAndRunScript		; $6c27
	ret nc			; $6c2a
	jp interactionDelete		; $6c2b


; Subid $03: Cutscene with Nayru and Ralph when Link exits the black tower
_nayruSubid03:
	call interactionAnimateBasedOnSpeed		; $6c2e
	ld e,Interaction.state2		; $6c31
	ld a,(de)		; $6c33
	rst_jumpTable			; $6c34
	.dw @substate0
	.dw @substate1
	.dw @substate2

@substate0:
	ld a,($cfd0)		; $6c3b
	cp $01			; $6c3e
	ret nz			; $6c40
	call startJump		; $6c41
	jp interactionIncState2		; $6c44

@substate1:
	ld c,$24		; $6c47
	call objectUpdateSpeedZ_paramC		; $6c49
	ret nz			; $6c4c
	ld hl,nayruScript03		; $6c4d
	call interactionSetScript		; $6c50
	jp interactionIncState2		; $6c53

@substate2:
	jp interactionRunScript		; $6c56


;;
; Subid $04: Cutscene at end of game with Ambi and her guards
; @addr{6c59}
_nayruSubid04:
	call checkIsLinkedGame		; $6c59
	jp z,_nayruAnimateAndRunScript		; $6c5c

	ld a,($cfd0)		; $6c5f
	cp $0b			; $6c62
	jr c,_nayruAnimateAndRunScript	; $6c64
	call interactionAnimate		; $6c66
	jpab scriptHlp.turnToFaceSomething		; $6c69

;;
; Subid $05: ?
; @addr{6c71}
_nayruSubid05:
	call _nayruAnimateAndRunScript		; $6c71

	ld a,($cfc0)		; $6c74
	cp $03			; $6c77
	ret c			; $6c79
	cp $05			; $6c7a
	ret nc			; $6c7c

	jpab scriptHlp.turnToFaceSomething		; $6c7d

;;
; For Nayru subid 0 (getting possessed cutscene), this updates var3a, var3b representing
; how long Nayru's palette should be "normal" or "possessed".
;
; @param[out]	zflag	Set when Nayru is fully possessed
; @addr{6c85}
_nayruUpdatePossessionPaletteDurations:
	ld a,(wFrameCounter)		; $6c85
	and $01			; $6c88
	ret nz			; $6c8a
	ld e,Interaction.var38		; $6c8b
	ld a,(de)		; $6c8d
	rst_jumpTable			; $6c8e
	.dw @var38_0
	.dw @var38_1
	.dw @var38_2
	.dw @var38_3
	.dw @var38_4

@var38_0:
	; Decrement var3a (unpossessed palette duration), increment var3b (possessed
	; palette duration) until the two are equal, then increment var38.
	ld h,d			; $6c99
	ld l,Interaction.var3a		; $6c9a
	dec (hl)		; $6c9c
	inc l			; $6c9d
	inc (hl)		; $6c9e
	ldd a,(hl)		; $6c9f
	cp (hl)			; $6ca0
	ret nz			; $6ca1

@incVar38:
	ld l,Interaction.var38		; $6ca2
	inc (hl)		; $6ca4
	ret			; $6ca5

@var38_1:
	; Decrement both var3a and var3b until they're both 2
	ld h,d			; $6ca6
	ld l,Interaction.var3a		; $6ca7
	dec (hl)		; $6ca9
	inc l			; $6caa
	dec (hl)		; $6cab
	ld a,(hl)		; $6cac
	cp $02			; $6cad
	ret nz			; $6caf

	ld l,Interaction.var3c		; $6cb0
	ld (hl),$10		; $6cb2
	jr @incVar38		; $6cb4

@var38_2:
	; Wait 32 frames
	ld h,d			; $6cb6
	ld l,Interaction.var3c		; $6cb7
	dec (hl)		; $6cb9
	ret nz			; $6cba
	jr @incVar38		; $6cbb

@var38_3:
	; Increment both var3a and var3b until they're both 8
	ld h,d			; $6cbd
	ld l,Interaction.var3a		; $6cbe
	inc (hl)		; $6cc0
	inc l			; $6cc1
	inc (hl)		; $6cc2
	ld a,(hl)		; $6cc3
	cp $08			; $6cc4
	ret nz			; $6cc6
	jr @incVar38		; $6cc7

@var38_4:
	; Decrement var3a, increment var3b until it's 16
	ld h,d			; $6cc9
	ld l,Interaction.var3a		; $6cca
	dec (hl)		; $6ccc
	inc l			; $6ccd
	inc (hl)		; $6cce
	ld a,(hl)		; $6ccf
	cp $10			; $6cd0
	ret nz			; $6cd2
	ret			; $6cd3

;;
; Subid $07: Cutscene with the vision of Nayru teaching you Tune of Echoes
; @addr{6cd4}
_nayruSubid07:
	call checkInteractionState2		; $6cd4
	jr nz,@substate1	; $6cd7

@substate0:
	call interactionDecCounter1		; $6cd9
	jr z,++		; $6cdc

	ld l,Interaction.visible		; $6cde
	ld a,(hl)		; $6ce0
	xor $80			; $6ce1
	ld (hl),a		; $6ce3
	ret			; $6ce4
++
	xor a			; $6ce5
	ld ($cfc0),a		; $6ce6
	call interactionIncState2		; $6ce9
	call objectSetVisible82		; $6cec

	ld a,MUS_NAYRU		; $6cef
	ld (wActiveMusic),a		; $6cf1
	call playSound		; $6cf4

	ld hl,nayruScript07		; $6cf7
	jp interactionSetScript		; $6cfa

@substate1:
	call interactionRunScript		; $6cfd
	jr c,@scriptDone	; $6d00

	ld a,($cfc0)		; $6d02
	rrca			; $6d05
	ret c			; $6d06
	ld e,Interaction.direction		; $6d07
	ld a,(de)		; $6d09
	cp $07			; $6d0a
	call z,_nayruSubid00@createMusicNotes		; $6d0c
	jp interactionAnimate		; $6d0f

@scriptDone:
	ld a,(wTextIsActive)		; $6d12
	or a			; $6d15
	ret nz			; $6d16

	; Re-enable objects, menus
	ld (wDisabledObjects),a		; $6d17
	ld (wMenuDisabled),a		; $6d1a

	ld a,(wActiveMusic2)		; $6d1d
	ld (wActiveMusic),a		; $6d20
	call playSound		; $6d23

	ld a,$04		; $6d26
	call fadeinFromWhiteWithDelay		; $6d28
	call showStatusBar		; $6d2b
	ldh a,(<hActiveObject)	; $6d2e
	ld d,a			; $6d30
	jp interactionDelete		; $6d31

;;
; @addr{6d34}
_nayruAsNpc:
	call interactionRunScript		; $6d34
	jp npcFaceLinkAndAnimate		; $6d37

;;
; Subid $09: Cutscene where Ralph's heritage is revealed (unlinked?)
; @addr{6d3a}
_nayruSubid09:
	call _nayruAnimateAndRunScript		; $6d3a
	ret nc			; $6d3d

	xor a			; $6d3e
	ld (wDisabledObjects),a		; $6d3f
	ld (wMenuDisabled),a		; $6d42
	ld a,GLOBALFLAG_PRE_BLACK_TOWER_CUTSCENE_DONE		; $6d45
	call setGlobalFlag		; $6d47
	jp interactionDelete		; $6d4a

;;
; Subid $10: Cutscene in black tower where Nayru/Ralph meet you to try to escape
; @addr{6d4d}
_nayruSubid10:
	ld a,(wScreenShakeCounterY)		; $6d4d
	cp $5a			; $6d50
	jr nc,_nayruSubid0a	; $6d52
	or a			; $6d54
	jr z,_nayruSubid0a	; $6d55
	ld a,(w1Link.direction)		; $6d57
	dec a			; $6d5a
	and $03			; $6d5b
	ld h,d			; $6d5d
	ld l,$7f		; $6d5e
	cp (hl)			; $6d60
	jr z,_nayruSubid0a	; $6d61
	ld (hl),a		; $6d63
	call interactionSetAnimation		; $6d64

;;
; Subid $0a: Cutscene where Ralph's heritage is revealed (linked?)
; @addr{6d67}
_nayruSubid0a:
	call _nayruAnimateAndRunScript		; $6d67
	ret nc			; $6d6a
	jp interactionDelete		; $6d6b

;;
; Subid $13: NPC after completing game (singing to animals)
; @addr{6d6e}
_nayruSubid13:
	call _nayruSubid00@createMusicNotes		; $6d6e

;;
; This is called by Ralph as well
; @addr{6d71}
_nayruRunScriptWithConditionalAnimation:
	call interactionRunScript		; $6d71
	ld e,Interaction.var39		; $6d74
	ld a,(de)		; $6d76
	or a			; $6d77
	call z,interactionAnimate		; $6d78
	call objectPreventLinkFromPassing		; $6d7b
	jp objectSetPriorityRelativeToLink_withTerrainEffects		; $6d7e


; ==============================================================================
; INTERACID_RALPH
;
; Variables:
;   var3f: for some subids, ralph's animations only updates when this is 0.
; ==============================================================================
interactionCode37:
	ld e,Interaction.state		; $6d81
	ld a,(de)		; $6d83
	rst_jumpTable			; $6d84
	.dw _ralphState0
	.dw _ralphRunSubid

_ralphState0:
	ld a,$01		; $6d89
	ld (de),a		; $6d8b
	call interactionInitGraphics		; $6d8c
	call @initSubid		; $6d8f
	ld e,Interaction.enabled		; $6d92
	ld a,(de)		; $6d94
	or a			; $6d95
	jp nz,objectMarkSolidPosition		; $6d96
	ret			; $6d99

@initSubid:
	ld e,Interaction.subid		; $6d9a
	ld a,(de)		; $6d9c
	rst_jumpTable			; $6d9d
	.dw @initSubid00
	.dw @initSubid01
	.dw @initSubid02
	.dw @initSubid03
	.dw @initSubid04
	.dw @initSubid05
	.dw @initSubid06
	.dw @initSubid07
	.dw @initSubid08
	.dw @initSubid09
	.dw @initSubid0a
	.dw @initSubid0b
	.dw @initSubid0c
	.dw @initSubid0d
	.dw @initSubid0e
	.dw @initSubid0f
	.dw @initSubid10
	.dw @initSubid11
	.dw @initSubid12


@initSubid06:
	ld hl,ralphSubid06Script_part1		; $6dc4
	ld a,($cfd0)		; $6dc7
	cp $0b			; $6dca
	jr nz,++		; $6dcc
	ld bc,$4850		; $6dce
	call interactionSetPosition		; $6dd1
	ld hl,ralphSubid06Script_part2		; $6dd4
++
	call interactionSetScript		; $6dd7

@initSubid00:
@initSubid05:
	xor a			; $6dda

@setAnimation:
	call interactionSetAnimation		; $6ddb
	jp objectSetVisiblec2		; $6dde

@initSubid02:
	ld a,$09		; $6de1
	call interactionSetAnimation		; $6de3

	ld hl,ralphSubid02Script		; $6de6
	call interactionSetScript		; $6de9

	call interactionLoadExtraGraphics		; $6dec
	jp objectSetVisiblec2		; $6def

@initSubid03:
	ld a,GLOBALFLAG_GAVE_ROPE_TO_RAFTON		; $6df2
	call checkGlobalFlag		; $6df4
	jp z,interactionDelete		; $6df7

	call getThisRoomFlags		; $6dfa
	bit 6,a			; $6dfd
	jp nz,interactionDelete		; $6dff

	ld a,$01		; $6e02
	ld (wDisabledObjects),a		; $6e04
	ld (wMenuDisabled),a		; $6e07
	ld a,$03		; $6e0a
	call interactionSetAnimation		; $6e0c

	ld h,d			; $6e0f
	ld l,Interaction.counter1		; $6e10
	ld (hl),$78		; $6e12
	ld l,Interaction.direction		; $6e14
	ld (hl),$01		; $6e16
	jp objectSetVisiblec2		; $6e18

@initSubid04:
	ld a,$01		; $6e1b
	call interactionSetAnimation		; $6e1d
	ld a,($cfd0)		; $6e20
	cp $03			; $6e23
	jr z,++			; $6e25
	ld hl,ralphSubid04Script_part1		; $6e27
	call interactionSetScript		; $6e2a
	jp objectSetInvisible		; $6e2d
++
	ld hl,ralphSubid04Script_part2		; $6e30
	call interactionSetScript		; $6e33
	jp objectSetVisiblec2		; $6e36

@initSubid07:
	ld hl,ralphSubid07Script		; $6e39
	call interactionSetScript		; $6e3c
	jp objectSetInvisible		; $6e3f

@initSubid08:
	callab scriptHlp.createLinkedSwordAnimation		; $6e42

	ld hl,ralphSubid08Script		; $6e4a
	call interactionSetScript		; $6e4d
	jp objectSetVisiblec2		; $6e50

@initSubid09:
	ld a,GLOBALFLAG_RALPH_ENTERED_AMBIS_PALACE		; $6e53
	call checkGlobalFlag		; $6e55
	jr nz,@deleteSelf	; $6e58

	; Check that we have the 5th essence
	ld a,TREASURE_ESSENCE		; $6e5a
	call checkTreasureObtained		; $6e5c
	jr nc,@deleteSelf	; $6e5f
	bit 5,a			; $6e61
	jr nz,++		; $6e63

@deleteSelf:
	jp interactionDelete		; $6e65

++
	ld e,Interaction.speed		; $6e68
	ld a,SPEED_200		; $6e6a
	ld (de),a		; $6e6c

	ld a,MUS_RALPH		; $6e6d
	ld (wActiveMusic),a		; $6e6f
	call playSound		; $6e72

	call setLinkForceStateToState08		; $6e75
	inc a			; $6e78
	ld (wDisabledObjects),a		; $6e79
	ld (wMenuDisabled),a		; $6e7c

	ld a,(wScreenTransitionDirection)		; $6e7f
	ld (w1Link.direction),a		; $6e82

	ld hl,ralphSubid09Script		; $6e85
	call interactionSetScript		; $6e88
	xor a			; $6e8b
	call interactionSetAnimation		; $6e8c
	jp objectSetVisiblec2		; $6e8f

@initSubid0a:
	ld a,TREASURE_MAKU_SEED		; $6e92
	call checkTreasureObtained		; $6e94
	jp nc,interactionDelete		; $6e97

	ld a,GLOBALFLAG_PRE_BLACK_TOWER_CUTSCENE_DONE		; $6e9a
	call checkGlobalFlag		; $6e9c
	jp nz,interactionDelete		; $6e9f

	ld a,GLOBALFLAG_RALPH_ENTERED_BLACK_TOWER		; $6ea2
	call checkGlobalFlag		; $6ea4
	jp nz,interactionDelete		; $6ea7

	call checkIsLinkedGame		; $6eaa
	ld hl,ralphSubid0aScript_unlinked		; $6ead
	jr z,@@setScript		; $6eb0

	; Linked game: adjust position, load a different script
	ld h,d			; $6eb2
	ld l,Interaction.xh		; $6eb3
	ld (hl),$50		; $6eb5
	ld l,Interaction.var38		; $6eb7
	ld (hl),$1e		; $6eb9

	ld hl,ralphSubid0aScript_linked		; $6ebb

@@setScript:
	call interactionSetScript		; $6ebe
	call setLinkForceStateToState08		; $6ec1
	ld ($cfd0),a		; $6ec4
	inc a			; $6ec7
	ld (wDisabledObjects),a		; $6ec8
	ld (wMenuDisabled),a		; $6ecb
	jp objectSetVisiblec2		; $6ece

@initSubid0e:
	ld e,Interaction.var3f		; $6ed1
	ld a,$ff		; $6ed3
	ld (de),a		; $6ed5
	ld hl,ralphSubid0eScript		; $6ed6
	jr @setScriptAndRunState1		; $6ed9

@initSubid0f:
	ld a,$01		; $6edb
	jp @setAnimation		; $6edd

@initSubid01:
	ld hl,ralphSubid01Script		; $6ee0

@setScriptAndRunState1:
	call interactionSetScript		; $6ee3
	jp _ralphRunSubid		; $6ee6

@delete:
	jp interactionDelete		; $6ee9

@initSubid0b:
	ld a,TREASURE_TUNE_OF_CURRENTS		; $6eec
	call checkTreasureObtained		; $6eee
	jr c,@delete	; $6ef1

	call getThisRoomFlags		; $6ef3
	and $40			; $6ef6
	jr nz,@delete	; $6ef8

	; Check that Link has timewarped in from a specific spot
	ld a,(wScreenTransitionDirection)		; $6efa
	or a			; $6efd
	jr nz,@delete	; $6efe
	ld a,(wWarpDestPos)		; $6f00
	cp $24			; $6f03
	jr nz,@delete	; $6f05

	ld hl,ralphSubid0bScript		; $6f07

@setScriptAndDisableObjects:
	call interactionSetScript		; $6f0a

	ld a,$81		; $6f0d
	ld (wDisabledObjects),a		; $6f0f
	ld (wMenuDisabled),a		; $6f12

	call objectSetVisiblec1		; $6f15
	jp _ralphRunSubid		; $6f18

@initSubid10:
	call getThisRoomFlags		; $6f1b
	and $40			; $6f1e
	jp nz,interactionDelete		; $6f20

	ld a,GLOBALFLAG_TALKED_TO_CHEVAL		; $6f23
	call checkGlobalFlag		; $6f25
	jp z,interactionDelete		; $6f28

	ld a,(wWarpDestPos)		; $6f2b
	cp $17			; $6f2e
	jp nz,interactionDelete		; $6f30

	ld hl,ralphSubid10Script		; $6f33
	jr @setScriptAndDisableObjects		; $6f36

@initSubid11:
	ld a,GLOBALFLAG_FINISHEDGAME		; $6f38
	call checkGlobalFlag		; $6f3a
	jp z,interactionDelete		; $6f3d

	ld a,$03		; $6f40
	call interactionSetAnimation		; $6f42
	ld hl,ralphSubid11Script		; $6f45
	call interactionSetScript		; $6f48
	jr _ralphRunSubid		; $6f4b

@initSubid0c:
	ld hl,wGroup4Flags+$fc		; $6f4d
	bit 7,(hl)		; $6f50
	jp nz,interactionDelete		; $6f52

	call interactionLoadExtraGraphics		; $6f55
	callab scriptHlp.createLinkedSwordAnimation		; $6f58
	ld hl,ralphSubid0cScript		; $6f60
	call interactionSetScript		; $6f63
	xor a			; $6f66
	ld ($cfde),a		; $6f67
	ld ($cfdf),a		; $6f6a
	call interactionSetAnimation		; $6f6d
	call interactionRunScript		; $6f70
	jr _ralphRunSubid		; $6f73

@initSubid12:
	call checkIsLinkedGame		; $6f75
	jp z,interactionDelete		; $6f78
	ld hl,$c9fc		; $6f7b
	bit 7,(hl)		; $6f7e
	jp z,interactionDelete		; $6f80
	call objectSetVisiblec2		; $6f83
	ld hl,ralphSubid12Script		; $6f86
	jp interactionSetScript		; $6f89

@initSubid0d:
	ld a,(wScreenTransitionDirection)		; $6f8c
	cp $01			; $6f8f
	jp nz,interactionDelete		; $6f91

	ld hl,ralphSubid0dScript		; $6f94
	call interactionSetScript		; $6f97
	call objectSetVisiblec0		; $6f9a

;;
; @addr{6f9d}
_ralphRunSubid:
	ld e,Interaction.subid		; $6f9d
	ld a,(de)		; $6f9f
	rst_jumpTable			; $6fa0
	.dw _ralphSubid00
	.dw _ralphSubid01
	.dw _ralphSubid02
	.dw _ralphSubid03
	.dw _ralphSubid04
	.dw _ralphSubid05
	.dw _ralphSubid06
	.dw _ralphSubid07
	.dw _ralphSubid08
	.dw _ralphSubid09
	.dw _ralphSubid0a
	.dw _ralphSubid0b
	.dw _ralphRunScriptAndDeleteWhenOver
	.dw _ralphRunScriptWithConditionalAnimation
	.dw _ralphSubid0e
	.dw interactionAnimate
	.dw _ralphSubid10
	.dw _nayruRunScriptWithConditionalAnimation
	.dw _ralphSubid12

;;
; Cutscene where Nayru gets possessed
; @addr{6fc7}
_ralphSubid00:
	ld e,Interaction.state2		; $6fc7
	ld a,(de)		; $6fc9
	rst_jumpTable		; $6fca
	.dw @substate0
	.dw @substate1

@substate0:
	call interactionAnimate		; $6fcf
	ld a,($cfd0)		; $6fd2
	cp $09			; $6fd5
	ret nz			; $6fd7

	call interactionIncState2		; $6fd8
	ld l,Interaction.counter1		; $6fdb
	ld (hl),$3c		; $6fdd

	ld bc,$3088		; $6fdf
	call interactionSetPosition		; $6fe2
	ld a,$03		; $6fe5
	call interactionSetAnimation		; $6fe7

	ld hl,ralphSubid00Script		; $6fea
	jp interactionSetScript		; $6fed

@substate1:
	call interactionAnimate		; $6ff0
	call interactionRunScript		; $6ff3
	ld e,Interaction.counter2		; $6ff6
	ld a,(de)		; $6ff8
	or a			; $6ff9
	ret z			; $6ffa

	; Animate more quickly if moving fast
	ld e,Interaction.speed		; $6ffb
	ld a,(de)		; $6ffd
	cp SPEED_100			; $6ffe
	jp nc,interactionAnimate		; $7000
	ret			; $7003

;;
; Cutscene after Nayru is possessed
; @addr{7004}
_ralphSubid02:
	; They probably meant to call "checkInteractionState2" instead? It looks like
	; @state0 will never be run...
	call checkInteractionState		; $7004
	jr nz,@state1		; $7007

@state0:
	call interactionRunScript		; $7009
	call interactionAnimate		; $700c
	ld a,($cfd0)		; $700f
	cp $1f			; $7012
	ret nz			; $7014
	jp interactionIncState2		; $7015

@state1:
	callab scriptHlp.objectWritePositionTocfd5		; $7018
	ld e,Interaction.counter2		; $7020
	ld a,(de)		; $7022
	or a			; $7023
	call nz,interactionAnimate		; $7024
	call    interactionAnimate		; $7027

	call interactionRunScript		; $702a
	ret nc			; $702d

	; Script done
	ld a,SNDCTRL_MEDIUM_FADEOUT		; $702e
	call playSound		; $7030
	jp interactionDelete		; $7033

;;
; Cutscene outside Ambi's palace before getting mystery seeds
; @addr{7036}
_ralphSubid01:
	call interactionRunScript		; $7036
	jp c,interactionDelete		; $7039

	call _ralphTurnLinkTowardSelf		; $703c
	ld e,Interaction.var3f		; $703f
	ld a,(de)		; $7041
	or a			; $7042
	call z,interactionAnimate2Times		; $7043
	jp interactionPushLinkAwayAndUpdateDrawPriority		; $7046

;;
; Cutscene after talking to Rafton
; @addr{7049}
_ralphSubid03:
	ld e,Interaction.state2		; $7049
	ld a,(de)		; $704b
	rst_jumpTable			; $704c
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4
	.dw @substate5
	.dw @substate6
	.dw @substate7
	.dw @substate8

@substate0:
	call interactionDecCounter1		; $705f
	jr nz,++		; $7062

	ld (hl),$1e		; $7064
	ld a,$02		; $7066
	call interactionSetAnimation		; $7068
	jp interactionIncState2		; $706b
++
	ld a,(wFrameCounter)		; $706e
	and $0f			; $7071
	ret nz			; $7073
	ld e,Interaction.direction		; $7074
	ld a,(de)		; $7076
	xor $02			; $7077
	ld (de),a		; $7079
	jp interactionSetAnimation		; $707a

@substate1:
	call interactionDecCounter1		; $707d
	ret nz			; $7080
	call interactionIncState2		; $7081
	jp startJump		; $7084

@substate2:
	call interactionAnimate		; $7087
	ld c,$20		; $708a
	call objectUpdateSpeedZ_paramC		; $708c
	ret nz			; $708f
	call interactionIncState2		; $7090
	ld l,Interaction.counter1		; $7093
	ld (hl),$0a		; $7095
	ret			; $7097

@substate3:
	call interactionDecCounter1		; $7098
	ret nz			; $709b
	ld (hl),$1e		; $709c
	call interactionIncState2		; $709e
	ld bc,TX_2a0a		; $70a1
	jp showText		; $70a4

@substate4:
	call interactionDecCounter1IfTextNotActive		; $70a7
	ret nz			; $70aa
	ld (hl),$30		; $70ab

	call interactionIncState2		; $70ad

	ld l,Interaction.angle		; $70b0
	ld (hl),$10		; $70b2
	ld l,Interaction.speed		; $70b4
	ld (hl),SPEED_100		; $70b6

	ld a,$02		; $70b8
	jp interactionSetAnimation		; $70ba

@substate5:
	call interactionAnimate2Times		; $70bd
	call interactionDecCounter1		; $70c0
	jp nz,objectApplySpeed		; $70c3

	ld (hl),$06		; $70c6
	jp interactionIncState2		; $70c8

@substate6:
	call interactionDecCounter1		; $70cb
	ret nz			; $70ce
	ld (hl),$0a		; $70cf

	; Align with Link's x-position
	call interactionIncState2		; $70d1
	ld a,(w1Link.xh)		; $70d4
	ld l,Interaction.xh		; $70d7
	sub (hl)		; $70d9
	jr z,@startScript	; $70da
	jr c,@@moveLeft		; $70dc

@@moveRight:
	ld b,$08		; $70de
	ld c,DIR_RIGHT		; $70e0
	jr ++			; $70e2

@@moveLeft:
	cpl			; $70e4
	inc a			; $70e5
	ld b,$18		; $70e6
	ld c,DIR_LEFT		; $70e8
++
	ld l,Interaction.counter1		; $70ea
	ld (hl),a		; $70ec
	ld l,Interaction.angle		; $70ed
	ld (hl),b		; $70ef
	ld a,c			; $70f0
	jp interactionSetAnimation		; $70f1

@substate7:
	call interactionAnimate2Times		; $70f4
	call interactionDecCounter1		; $70f7
	jp nz,objectApplySpeed		; $70fa

@startScript:
	call interactionIncState2		; $70fd
	ld hl,ralphSubid03Script		; $7100
	jp interactionSetScript		; $7103

@substate8:
	call _ralphAnimateBasedOnSpeedAndRunScript		; $7106
	ret nc			; $7109

	ld a,MUS_OVERWORLD_PAST		; $710a
	ld (wActiveMusic2),a		; $710c
	ld (wActiveMusic),a		; $710f
	call playSound		; $7112
	jp interactionDelete		; $7115

;;
; Cutscene on maku tree screen after saving Nayru
; @addr{7118}
_ralphSubid04:
	ld e,Interaction.state2		; $7118
	ld a,(de)		; $711a
	rst_jumpTable			; $711b
	.dw _nayruSubid02Substate0 ; Borrow some of Nayru's code from the same cutscene
	.dw @substate1
	.dw @substate2

@substate1:
	ld a,($cfd0)		; $7122
	cp $08			; $7125
	jp nz,_nayruFlipDirectionAtRandomIntervals		; $7127

	call interactionIncState2		; $712a
	ld hl,ralphSubid04Script_part3		; $712d
	call interactionSetScript		; $7130
	jp @substate2		; $7133

@substate2:
	call _ralphAnimateBasedOnSpeedAndRunScript		; $7136
	ret nc			; $7139
	jp interactionDelete		; $713a

;;
; Cutscene in black tower where Nayru/Ralph meet you to try to escape
; @addr{713d}
_ralphSubid05:
	call interactionAnimateBasedOnSpeed		; $713d
	ld e,Interaction.state2		; $7140
	ld a,(de)		; $7142
	rst_jumpTable			; $7143
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw _ralphRunScript

@substate0:
	ld a,($cfd0)		; $714e
	cp $01			; $7151
	ret nz			; $7153
	call startJump		; $7154
	jp interactionIncState2		; $7157

@substate1:
	ld c,$20		; $715a
	call objectUpdateSpeedZ_paramC		; $715c
	ret nz			; $715f
	ld hl,ralphSubid05Script		; $7160
	call interactionSetScript		; $7163
	jp interactionIncState2		; $7166

@substate2:
	ld a,($cfd0)		; $7169
	cp $02			; $716c
	jp nz,interactionRunScript		; $716e
	call startJump		; $7171
	jp interactionIncState2		; $7174

@substate3:
	ld c,$20		; $7177
	call objectUpdateSpeedZ_paramC		; $7179
	ret nz			; $717c
	call interactionIncState2		; $717d
	ld l,Interaction.var3e		; $7180
	inc (hl)		; $7182

_ralphRunScript:
	jp interactionRunScript		; $7183

;;
; @addr{7186}
_ralphSubid06:
	call interactionAnimateBasedOnSpeed		; $7186
	ld e,Interaction.state2		; $7189
	ld a,(de)		; $718b
	rst_jumpTable			; $718c
	.dw @substate0
	.dw @substate1
	.dw _ralphRunScript

@substate0:
	callab scriptHlp.objectWritePositionTocfd5		; $7193
	ld a,($cfd0)		; $719b
	cp $08			; $719e
	jp nz,interactionRunScript		; $71a0
	call startJump		; $71a3
	jp interactionIncState2		; $71a6

@substate1:
	ld c,$20		; $71a9
	call objectUpdateSpeedZ_paramC		; $71ab
	ret nz			; $71ae
	call interactionIncState2		; $71af
	ld l,Interaction.var3e		; $71b2
	inc (hl)		; $71b4
	jr _ralphRunScript		; $71b5

;;
; Cutscene postgame where they warp to the maku tree, Ralph notices the statue
; @addr{71b7}
_ralphSubid07:
	callab scriptHlp.objectWritePositionTocfd5		; $71b7
	ld e,Interaction.state2		; $71bf
	ld a,(de)		; $71c1
	rst_jumpTable			; $71c2
	.dw _ralphAnimateBasedOnSpeedAndRunScript
	.dw _ralphSubid07Substate1
	.dw _ralphSubid07Substate2
	.dw _ralphAnimateBasedOnSpeedAndRunScript

_ralphAnimateBasedOnSpeedAndRunScript:
	call interactionAnimateBasedOnSpeed		; $71cb
	jp interactionRunScript		; $71ce

_ralphSubid07Substate1:
	call interactionIncState2		; $71d1
	call objectSetVisiblec2		; $71d4
	ld bc,-$1c0		; $71d7
	call objectSetSpeedZ		; $71da

_ralphSubid07Substate2:
	ld c,$20		; $71dd
	call objectUpdateSpeedZ_paramC		; $71df
	ret nz			; $71e2

	call interactionIncState2		; $71e3
	ld l,Interaction.var3e		; $71e6
	inc (hl)		; $71e8
	jp objectSetVisible82		; $71e9

;;
; Cutscene in credits where Ralph is training with his sword
; @addr{71ec}
_ralphSubid08:
	ld e,Interaction.state2		; $71ec
	ld a,(de)		; $71ee
	rst_jumpTable			; $71ef
	.dw @substate0
	.dw @substate1
	.dw @substate2

@substate0:
	call interactionAnimate		; $71f6
	call interactionRunScript		; $71f9
	ret nc			; $71fc

	; Script done

	call interactionIncState2		; $71fd
	ld l,Interaction.speed		; $7200
	ld (hl),SPEED_c0		; $7202

@getNextAngle:
	ld b,$02		; $7204
	callab loadAngleAndCounterPreset		; $7206
	ld a,b			; $720e
	or a			; $720f
	ret			; $7210

@substate1:
	call interactionAnimate		; $7211
	call objectApplySpeed		; $7214
	call interactionDecCounter1		; $7217
	call z,@getNextAngle		; $721a
	ret nz			; $721d

	call interactionIncState2		; $721e
	ld l,Interaction.counter1		; $7221
	ld (hl),$5a		; $7223
	ld a,$08		; $7225
	jp interactionSetAnimation		; $7227

@substate2:
	call interactionAnimate		; $722a
	call interactionDecCounter1		; $722d
	ret nz			; $7230
	ld a,$ff		; $7231
	ld ($cfdf),a		; $7233
	ret			; $7236

;;
; Cutscene where Ralph charges in to Ambi's palace
; @addr{7237}
_ralphSubid09:
	call interactionRunScript		; $7237
	jp nc,interactionAnimateBasedOnSpeed		; $723a

	; Script done
	xor a			; $723d
	ld (wDisabledObjects),a		; $723e
	ld (wMenuDisabled),a		; $7241
	jp interactionDelete		; $7244

;;
; Cutscene where Ralph's about to charge into the black tower
; @addr{7247}
_ralphSubid0a:
	call checkIsLinkedGame		; $7247
	jp nz,_ralphSubid0a_linked		; $724a

; Unlinked game

	ld e,Interaction.state2		; $724d
	ld a,(de)		; $724f
	rst_jumpTable			; $7250
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4

@substate0:
	; Create an exclamation mark above Link
	call getFreeInteractionSlot		; $725b
	ret nz			; $725e
	ld (hl),INTERACID_EXCLAMATION_MARK		; $725f
	ld l,Interaction.counter1		; $7261
	ld (hl),$1e		; $7263
	ld l,Interaction.yh		; $7265
	ld a,(w1Link.yh)		; $7267
	add $0e			; $726a
	ldi (hl),a		; $726c
	inc l			; $726d
	ld a,(w1Link.xh)		; $726e
	sub $0a			; $7271
	ld (hl),a		; $7273

	ld a,SND_CLINK		; $7274
	call playSound		; $7276

	call interactionIncState2		; $7279

	ld l,Interaction.counter1		; $727c
	ld (hl),$1e		; $727e
	ld l,Interaction.speed		; $7280
	ld (hl),SPEED_180		; $7282
	ret			; $7284

@substate1:
	call interactionDecCounter1		; $7285
	ret nz			; $7288

	xor a			; $7289
	call interactionSetAnimation		; $728a

@moveHorizontallyTowardRalph:
	ld a,(w1Link.xh)		; $728d
	sub $50			; $7290
	ld b,a			; $7292
	add $02			; $7293
	cp $05			; $7295
	jr c,@incState2		; $7297

	ld a,b			; $7299
	bit 7,a			; $729a
	ld b,$18		; $729c
	jr z,+			; $729e
	ld b,$08		; $72a0
	cpl			; $72a2
	inc a			; $72a3
+
	ld (wLinkStateParameter),a		; $72a4
	ld a,LINK_STATE_FORCE_MOVEMENT		; $72a7
	ld (wLinkForceState),a		; $72a9
	ld a,b			; $72ac
	ld hl,w1Link.angle		; $72ad
	ldd (hl),a		; $72b0
	swap a			; $72b1
	rlca			; $72b3
	ld (hl),a ; [w1Link.direction]

@incState2:
	jp interactionIncState2		; $72b5

@substate2:
	ld b,$50		; $72b8

@moveVerticallyTowardRalph:
	ld a,(w1Link.state)		; $72ba
	cp LINK_STATE_FORCE_MOVEMENT			; $72bd
	ret z			; $72bf

	; Make Link move vertically toward Ralph
	ld hl,w1Link.angle		; $72c0
	ld (hl),$10		; $72c3
	dec l			; $72c5
	ld (hl),DIR_DOWN		; $72c6
	ld a,b			; $72c8
	ld (wLinkStateParameter),a		; $72c9
	ld a,LINK_STATE_FORCE_MOVEMENT		; $72cc
	ld (wLinkForceState),a		; $72ce
	jp interactionIncState2		; $72d1

@substate3:
	ldbc DIR_RIGHT,$03		; $72d4

@setDirectionAndAnimationWhenLinkFinishedMoving:
	ld a,(w1Link.state)		; $72d7
	cp LINK_STATE_FORCE_MOVEMENT			; $72da
	ret z			; $72dc

	call setLinkForceStateToState08		; $72dd
	ld a,b			; $72e0
	ld (w1Link.direction),a		; $72e1
	ld a,c			; $72e4
	call interactionSetAnimation		; $72e5
	jp interactionIncState2		; $72e8

@substate4:
	call interactionRunScript		; $72eb
	jp nc,interactionAnimateBasedOnSpeed		; $72ee
	xor a			; $72f1
	ld (wDisabledObjects),a		; $72f2
	ld (wMenuDisabled),a		; $72f5
	jp interactionDelete		; $72f8

;;
; @addr{72fb}
_ralphSubid0a_linked:
	call interactionRunScript		; $72fb
	jp c,interactionDelete		; $72fe

	call interactionAnimateBasedOnSpeed		; $7301
	ld e,Interaction.state2		; $7304
	ld a,(de)		; $7306
	rst_jumpTable			; $7307
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate0:
	ld h,d			; $7310
	ld l,Interaction.var38		; $7311
	dec (hl)		; $7313
	ret nz			; $7314
	jp _ralphSubid0a@moveHorizontallyTowardRalph		; $7315

@substate1:
	ld b,$18		; $7318
	jp _ralphSubid0a@moveVerticallyTowardRalph		; $731a

@substate2:
	ldbc DIR_DOWN, $00		; $731d
	jp _ralphSubid0a@setDirectionAndAnimationWhenLinkFinishedMoving		; $7320

@substate3:
	ret			; $7323


;;
; $0b: Cutscene where Ralph tells you about getting Tune of Currents
; $10: Cutscene after talking to Cheval
; @addr{7324}
_ralphSubid0b:
_ralphSubid10:
	ld a,($cfc0)		; $7324
	or a			; $7327
	call nz,_ralphTurnLinkTowardSelf		; $7328

	ld e,Interaction.state2		; $732b
	ld a,(de)		; $732d
	rst_jumpTable			; $732e
	.dw @substate0
	.dw @substate1
	.dw _ralphRunScriptWithConditionalAnimation

@substate0:
	call interactionAnimate		; $7335
	jr _ralphRunScriptWithConditionalAnimation		; $7338

@substate1:
	; Create dust at Ralph's feet every 8 frames
	ld a,(wFrameCounter)		; $733a
	and $07			; $733d
	jr nz,_ralphRunScriptWithConditionalAnimation	; $733f

	call getFreeInteractionSlot		; $7341
	jr nz,_ralphRunScriptWithConditionalAnimation	; $7344

	ld (hl),INTERACID_PUFF		; $7346
	inc l			; $7348
	ld (hl),$81		; $7349
	ld bc,$0804		; $734b
	call objectCopyPositionWithOffset		; $734e
	jr _ralphRunScriptWithConditionalAnimation		; $7351

;;
; Runs script, deletes self when finished, and updates animations only if var3f is 0.
; @addr{7353}
_ralphRunScriptWithConditionalAnimation:
	call interactionRunScript		; $7353
	jp c,interactionDelete		; $7356

	ld e,Interaction.var3f		; $7359
	ld a,(de)		; $735b
	or a			; $735c
	jp z,interactionAnimate		; $735d
	ret			; $7360


;;
; Cutscene with Nayru and Ralph when Link exits the black tower
; @addr{7361}
_ralphSubid0e:
	ld a,(wScreenShakeCounterY)		; $7361
	cp $5a			; $7364
	jr nc,_ralphRunScriptAndDeleteWhenOver	; $7366
	or a			; $7368
	jr z,_ralphRunScriptAndDeleteWhenOver		; $7369

	ld a,(w1Link.direction)		; $736b
	sub $02			; $736e
	and $03			; $7370
	ld h,d			; $7372
	ld l,Interaction.var3f		; $7373
	cp (hl)			; $7375
	jr z,_ralphRunScriptAndDeleteWhenOver		; $7376

	ld (hl),a		; $7378
	call interactionSetAnimation		; $7379

;;
; @addr{737c}
_ralphRunScriptAndDeleteWhenOver:
	call interactionRunScript		; $737c
	jp c,interactionDelete		; $737f
	jp interactionAnimateAsNpc		; $7382


;;
; NPC after beating Veran, before beating Twinrova in a linked game
; @addr{7385}
_ralphSubid12:
	call npcFaceLinkAndAnimate		; $7385
	jp interactionRunScript		; $7388

;;
; Unused?
; @addr{738b}
_ralphFunc_738b:
	ld h,d			; $738b
	ld l,Interaction.var38		; $738c
	ld a,(hl)		; $738e
	or a			; $738f
	jr nz,++		; $7390

	ld bc,$2068		; $7392
	ld a,(wFrameCounter)		; $7395
	rrca			; $7398
	ret nc			; $7399

	ld l,Interaction.angle		; $739a
	ld a,(hl)		; $739c
	inc a			; $739d
	and $1f			; $739e
	ld (hl),a		; $73a0
	cp $0e			; $73a1
	ret nz			; $73a3
	ld l,Interaction.var38		; $73a4
	inc (hl)		; $73a6
	ld l,Interaction.angle		; $73a7
	ld (hl),$1f		; $73a9
++
	ld bc,$6890		; $73ab
	ld a,(wFrameCounter)		; $73ae
	rrca			; $73b1
	ret nc			; $73b2

	ld l,Interaction.angle		; $73b3
	ld a,(hl)		; $73b5
	dec a			; $73b6
	and $1f			; $73b7
	ld (hl),a		; $73b9
	ret			; $73ba

;;
; @addr{73bb}
_ralphTurnLinkTowardSelf:
	ld a,(w1Link.xh)		; $73bb
	add $10			; $73be
	ld b,a			; $73c0
	ld e,Interaction.xh		; $73c1
	ld a,(de)		; $73c3
	add $10			; $73c4
	sub b			; $73c6
	ld b,DIR_RIGHT		; $73c7
	jr nc,+			; $73c9
	ld b,DIR_LEFT		; $73cb
	cpl			; $73cd
+
	cp $0c			; $73ce
	jr nc,+			; $73d0
	ld b,DIR_DOWN		; $73d2
+
	ld hl,w1Link.direction		; $73d4
	ld (hl),b		; $73d7
	jp setLinkForceStateToState08		; $73d8

;;
; @addr{73db}
startJump:
	ld bc,-$1c0		; $73db
	call objectSetSpeedZ		; $73de
	ld a,SND_JUMP		; $73e1
	jp playSound		; $73e3


; ==============================================================================
; INTERACID_PAST_GIRL
; ==============================================================================
interactionCode38:
	ld e,Interaction.state		; $73e6
	ld a,(de)		; $73e8
	rst_jumpTable			; $73e9
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $73ee
	ld (de),a		; $73f0
	call interactionInitGraphics		; $73f1
	call objectSetVisiblec2		; $73f4

	ld a,>TX_1a00		; $73f7
	call interactionSetHighTextIndex		; $73f9

	ld e,Interaction.subid		; $73fc
	ld a,(de)		; $73fe
	rst_jumpTable			; $73ff
	.dw @subid0Init

@subid0Init:
	callab interactionBank2.getGameProgress_2		; $7402

	; NPC doesn't exist between beating d2 and saving Nayru
	ld a,b			; $740a
	cp $01			; $740b
	jp z,interactionDelete		; $740d
	cp $02			; $7410
	jp z,interactionDelete		; $7412

	ld a,b			; $7415
	ld hl,@scriptTable		; $7416
	rst_addDoubleIndex			; $7419
	ldi a,(hl)		; $741a
	ld h,(hl)		; $741b
	ld l,a			; $741c
	call interactionSetScript		; $741d
	call objectMarkSolidPosition		; $7420
	jr @state1		; $7423

@state1:
	ld e,Interaction.subid		; $7425
	ld a,(de)		; $7427
	rst_jumpTable			; $7428
	.dw @subid0

@subid0:
	call interactionRunScript		; $742b
	jp interactionAnimateAsNpc		; $742e


@scriptTable:
	.dw pastGirlScript_earlyGame
	.dw pastGirlScript_afterNayruSaved
	.dw pastGirlScript_afterNayruSaved
	.dw pastGirlScript_afterNayruSaved
	.dw pastGirlScript_afterd7
	.dw pastGirlScript_afterGotMakuSeed
	.dw pastGirlScript_twinrovaKidnappedZelda
	.dw pastGirlScript_gameFinished


; ==============================================================================
; INTERACID_MONKEY
; ==============================================================================
interactionCode39:
	jpab bank3f.interactionCode39_body		; $7441


; ==============================================================================
; INTERACID_VILLAGER
;
; Variables:
;   var03: Nonzero if he's turned to stone
;   var39: For some subids, animations only update when var39 is zero
;   var3d: Saved X position?
; ==============================================================================
interactionCode3a:
	ld e,Interaction.state		; $7449
	ld a,(de)		; $744b
	rst_jumpTable			; $744c
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $7451
	ld (de),a		; $7453

	call interactionInitGraphics		; $7454
	call objectSetVisiblec2		; $7457
	call @initSubid		; $745a

	ld e,Interaction.enabled		; $745d
	ld a,(de)		; $745f
	or a			; $7460
	jp nz,objectMarkSolidPosition		; $7461
	ret			; $7464

@initSubid:
	ld e,Interaction.subid		; $7465
	ld a,(de)		; $7467
	rst_jumpTable			; $7468
	.dw @initSubid00
	.dw @initSubid01
	.dw @initSubid02
	.dw @initSubid03
	.dw @initSubid04
	.dw @initSubid05
	.dw @initSubid06
	.dw @initSubid07
	.dw @initSubid08
	.dw @initAnimationAndLoadScript
	.dw @initSubid0a
	.dw @initSubid0b
	.dw @initSubid0c
	.dw @initSubid0d
	.dw @initSubid0e

@initSubid00:
	ld a,$03		; $7487
	jp interactionSetAnimation		; $7489

@initSubid02:
	ld e,Interaction.pressedAButton		; $748c
	call objectAddToAButtonSensitiveObjectList		; $748e

	ld e,Interaction.speed		; $7491
	ld a,SPEED_100		; $7493
	ld (de),a		; $7495

@saveXAndLoadScript:
	ld e,Interaction.xh		; $7496
	ld a,(de)		; $7498
	ld e,Interaction.var3d		; $7499
	ld (de),a		; $749b

@initSubid01:
	jp @loadScript		; $749c

@initSubid03:
	callab interactionBank2.getGameProgress_1		; $749f
	ld a,b			; $74a7
	ld hl,@subid03ScriptTable		; $74a8
	rst_addDoubleIndex			; $74ab
	ldi a,(hl)		; $74ac
	ld h,(hl)		; $74ad
	ld l,a			; $74ae
	jp interactionSetScript		; $74af

@initSubid04:
@initSubid05:
	ld a,$02		; $74b2
	ld e,Interaction.oamFlags		; $74b4
	ld (de),a		; $74b6

	callab interactionBank2.getGameProgress_1		; $74b7
	ld c,$04		; $74bf
	ld a,$03		; $74c1
	call checkNpcShouldExistAtGameStage		; $74c3
	jp nz,interactionDelete		; $74c6

	ld a,b			; $74c9
	ld hl,@subid4And5ScriptTable		; $74ca
	rst_addDoubleIndex			; $74cd
	ldi a,(hl)		; $74ce
	ld h,(hl)		; $74cf
	ld l,a			; $74d0
	jp interactionSetScript		; $74d1

@initSubid06:
@initSubid07:
	callab interactionBank2.getGameProgress_2		; $74d4
	ld c,$06		; $74dc
	ld a,$04		; $74de
	call checkNpcShouldExistAtGameStage		; $74e0
	jp nz,interactionDelete		; $74e3

	ld a,b			; $74e6
	ld hl,@subid6And7ScriptTable		; $74e7
	rst_addDoubleIndex			; $74ea
	ldi a,(hl)		; $74eb
	ld h,(hl)		; $74ec
	ld l,a			; $74ed
	jp interactionSetScript		; $74ee

@initSubid08:
	ld a,$03		; $74f1
	ld e,Interaction.oamFlags		; $74f3
	ld (de),a		; $74f5

	; Delete if you haven't beaten d7 yet?
	callab interactionBank2.getGameProgress_2		; $74f6
	ld a,b			; $74fe
	cp $04			; $74ff
	jp c,interactionDelete		; $7501

	sub $04			; $7504
	ld hl,@subid08ScriptTable		; $7506
	rst_addDoubleIndex			; $7509
	ldi a,(hl)		; $750a
	ld h,(hl)		; $750b
	ld l,a			; $750c
	jp interactionSetScript		; $750d

@initSubid0a:
	ld h,d			; $7510
	jr @loadStoneAnimation		; $7511

@initAnimationAndLoadScript:
	ld a,$01		; $7513
	call interactionSetAnimation		; $7515
	jp @loadScript		; $7518

@initSubid0c:
	; Check whether the villager should be stone right now

	; Have we beaten Veran?
	ld hl,wGroup4Flags+$fc		; $751b
	bit 7,(hl)		; $751e
	jr nz,@initAnimationAndLoadScript	; $7520

	ld a,(wEssencesObtained)		; $7522
	bit 6,a			; $7525
	jr z,@initAnimationAndLoadScript	; $7527

	ld h,d			; $7529
	ld l,Interaction.var03		; $752a
	inc (hl)		; $752c

@loadStoneAnimation:
	ld l,Interaction.oamFlags		; $752d
	ld (hl),$06		; $752f
	ld a,$06		; $7531
	call objectSetCollideRadius		; $7533
	ld a,$0d		; $7536
	jp interactionSetAnimation		; $7538

@initSubid0b:
	ld h,d			; $753b
	call @loadStoneAnimation		; $753c
	ld e,Interaction.counter1		; $753f
	ld a,$3c		; $7541
	ld (de),a		; $7543
	jr @state1		; $7544

@initSubid0d:
	call @loadScript		; $7546
	jr @state1		; $7549

@initSubid0e:
	call loadStoneNpcPalette		; $754b
	ld h,d			; $754e
	ld l,Interaction.oamFlags		; $754f
	ld (hl),$06		; $7551
	ld a,$0d		; $7553
	call interactionSetAnimation		; $7555

@state1:
	ld e,Interaction.subid		; $7558
	ld a,(de)		; $755a
	rst_jumpTable			; $755b
	.dw @runSubid00
	.dw @runSubid01
	.dw @runSubid02
	.dw @runScriptAndFaceLink
	.dw @runScriptAndFaceLink
	.dw @runScriptAndFaceLink
	.dw @runScriptAndFaceLink
	.dw @runScriptAndFaceLink
	.dw @runScriptAndFaceLink
	.dw @runSubid09
	.dw @ret
	.dw @runSubid0b
	.dw @runSubid0c
	.dw @runSubid0d
	.dw @runSubid0e


; Cutscene where guy is struck by lightning in intro
@runSubid00:
	ld e,Interaction.state2		; $757a
	ld a,(de)		; $757c
	rst_jumpTable			; $757d
	.dw @@substate0
	.dw @@substate1
	.dw @@substate2

@@substate0:
	ld a,($cfd1)		; $7584
	cp $02			; $7587
	jp nz,interactionAnimate		; $7589

	call interactionIncState2		; $758c
	ld l,Interaction.counter1		; $758f
	ld (hl),$3c		; $7591
	ld l,Interaction.xh		; $7593
	ld a,(hl)		; $7595
	ld l,Interaction.var3d		; $7596
	ld (hl),a		; $7598
	ret			; $7599

@@substate1:
	callab interactionOscillateXRandomly		; $759a
	ld a,($cfd1)		; $75a2
	cp $03			; $75a5
	ret nz			; $75a7

	call interactionIncState2		; $75a8
	ld l,Interaction.counter1		; $75ab
	ld (hl),$10		; $75ad

	call getFreePartSlot		; $75af
	ret nz			; $75b2
	ld (hl),PARTID_LIGHTNING		; $75b3

	; Write something to subid? This shouldn't matter, this lightning object doesn't
	; seem to use subid anyway.
	inc l			; $75b5
	ld (hl),e		; $75b6

	; [var03] = 1
	inc l			; $75b7
	inc (hl)		; $75b8

	jp objectCopyPosition		; $75b9

@@substate2:
	call interactionDecCounter1		; $75bc
	ret nz			; $75bf
	ld a,$04		; $75c0
	ld ($cfd1),a		; $75c2
	jp interactionDelete		; $75c5


; Past villager?
@runSubid01:
	call interactionRunScript		; $75c8
	jp interactionAnimateAsNpc		; $75cb


; Construction worker blocking path to upper part of black tower.
@runSubid02:
	ld e,Interaction.state2		; $75ce
	ld a,(de)		; $75d0
	rst_jumpTable			; $75d1
	.dw @@substate0
	.dw @@substate1

@@substate0:
	call npcFaceLinkAndAnimate		; $75d6
	call interactionRunScript		; $75d9
	ld bc,$0503		; $75dc
	call objectSetCollideRadii		; $75df

	; Temporarily overwrite the worker's X position to check for "collision" at the
	; position he's left open. His position will be reverted before returning.
	ld b,$11		; $75e2
	ld e,Interaction.direction		; $75e4
	ld a,(de)		; $75e6
	or a			; $75e7
	jr z,+			; $75e8
	ld b,$ef		; $75ea
+
	ld e,Interaction.xh		; $75ec
	ld a,(de)		; $75ee
	add b			; $75ef
	ld (de),a		; $75f0
	push bc			; $75f1
	call objectCheckCollidedWithLink_ignoreZ		; $75f2
	pop bc			; $75f5
	jr nc,++		; $75f6

	; Link tried to approach; move over to block his path
	call interactionIncState2		; $75f8
	ld hl,villagerSubid02Script_part2		; $75fb
	call interactionSetScript		; $75fe
++
	ld hl,w1Link.yh		; $7601
	ld e,Interaction.var39		; $7604
	ld a,(hl)		; $7606
	ld (de),a		; $7607
	ld bc,$0606		; $7608
	call objectSetCollideRadii		; $760b

	ld e,Interaction.var3d		; $760e
	ld a,(de)		; $7610
	ld e,Interaction.xh		; $7611
	ld (de),a		; $7613
	ret			; $7614

@@substate1:
	call interactionAnimateAsNpc		; $7615
	call interactionRunScript		; $7618
	jp nc,interactionAnimateBasedOnSpeed		; $761b

	call @saveXAndLoadScript		; $761e
	ld h,d			; $7621
	ld l,Interaction.direction		; $7622
	ld a,(hl)		; $7624
	xor $01			; $7625
	ld (hl),a		; $7627
	ld l,Interaction.state2		; $7628
	ld (hl),$00		; $762a
	jp @loadScript		; $762c


@runScriptAndFaceLink:
	call interactionRunScript		; $762f
	jp npcFaceLinkAndAnimate		; $7632


@runSubid09:
	ld e,Interaction.state2		; $7635
	ld a,(de)		; $7637
	rst_jumpTable			; $7638
	.dw @@substate0
	.dw @@substate1
	.dw @ret

@@substate0:
	call interactionRunScript		; $763f
	ld a,($cfd1)		; $7642
	cp $01			; $7645
	ret nz			; $7647
	jp interactionIncState2		; $7648

@@substate1:
	ld a,($cfd1)		; $764b
	cp $02			; $764e
	ret nz			; $7650
	call interactionIncState2		; $7651
	ld l,Interaction.oamFlags		; $7654
	ld (hl),$06		; $7656

@ret:
	ret			; $7658


; Villager being restored from stone, resumes playing catch
@runSubid0b:
	ld e,Interaction.state2		; $7659
	ld a,(de)		; $765b
	rst_jumpTable			; $765c
	.dw @@substate0
	.dw @@substate1
	.dw @@substate2

@@substate0:
	call interactionDecCounter1IfPaletteNotFading		; $7663
	ret nz			; $7666

	ld a,$01		; $7667
	ld ($cfd1),a		; $7669
	ld a,SND_RESTORE		; $766c
	call playSound		; $766e
	jpab setCounter1To120AndPlaySoundEffectAndIncState2		; $7671

@@substate1:
	call interactionDecCounter1		; $7679
	jr nz,++		; $767c

	call interactionIncState2		; $767e
	ld l,Interaction.oamFlags		; $7681
	ld (hl),$01		; $7683
	jp @loadScript		; $7685
++
	; Flicker palette every 8 frames
	ld a,(wFrameCounter)		; $7688
	and $07			; $768b
	ret nz			; $768d
	ld e,Interaction.oamFlags		; $768e
	ld a,(de)		; $7690
	dec a			; $7691
	xor $05			; $7692
	inc a			; $7694
	ld (de),a		; $7695
	ret			; $7696

@@substate2:
	ld e,Interaction.var39		; $7697
	ld a,(de)		; $7699
	or a			; $769a
	call z,interactionAnimateBasedOnSpeed		; $769b
	jp interactionRunScript		; $769e


; Villager playing catch with son
@runSubid0c:
	call interactionPushLinkAwayAndUpdateDrawPriority		; $76a1
	ld e,Interaction.var03		; $76a4
	ld a,(de)		; $76a6
	or a			; $76a7
	ret nz			; $76a8

	call interactionRunScript		; $76a9

	; If you press the A button, show text
	ld e,Interaction.pressedAButton		; $76ac
	ld a,(de)		; $76ae
	or a			; $76af
	ret z			; $76b0

	xor a			; $76b1
	ld (de),a		; $76b2
	ld bc,TX_1442		; $76b3
	ld hl,wGroup4Flags+$fc		; $76b6
	bit 7,(hl) ; Has Veran been beaten?
	jr z,+			; $76bb
	ld c,<TX_1443		; $76bd
+
	jp showText		; $76bf


; Cutscene when you first enter the past
@runSubid0d:
	call interactionRunScript		; $76c2
	jp c,interactionDelete		; $76c5
	call interactionAnimateBasedOnSpeed		; $76c8
	jp interactionPushLinkAwayAndUpdateDrawPriority		; $76cb


; Stone villager? Not much to do.
@runSubid0e:
	ret			; $76ce


@loadScript:
	ld e,Interaction.subid		; $76cf
	ld a,(de)		; $76d1
	ld hl,@scriptTable		; $76d2
	rst_addDoubleIndex			; $76d5
	ldi a,(hl)		; $76d6
	ld h,(hl)		; $76d7
	ld l,a			; $76d8
	jp interactionSetScript		; $76d9


@scriptTable:
	.dw stubScript
	.dw villagerSubid01Script
	.dw villagerSubid02Script_part1
	.dw stubScript
	.dw stubScript
	.dw stubScript
	.dw stubScript
	.dw stubScript
	.dw stubScript
	.dw villagerSubid09Script
	.dw stubScript
	.dw villagerSubid0bScript
	.dw villagerSubid0cScript
	.dw villagerSubid0dScript


@subid03ScriptTable:
	.dw villagerSubid03Script_befored3
	.dw villagerSubid03Script_afterd3
	.dw villagerSubid03Script_afterNayruSaved
	.dw villagerSubid03Script_afterd7
	.dw villagerSubid03Script_afterGotMakuSeed
	.dw villagerSubid03Script_postGame


@subid4And5ScriptTable:
	.dw villagerSubid4And5Script_befored3
	.dw villagerSubid4And5Script_afterd3
	.dw villagerSubid4And5Script_afterGotMakuSeed
	.dw villagerSubid4And5Script_afterGotMakuSeed
	.dw villagerSubid4And5Script_afterGotMakuSeed
	.dw villagerSubid4And5Script_postGame

@subid6And7ScriptTable:
	.dw villagerSubid6And7Script_befored2
	.dw villagerSubid6And7Script_afterd2
	.dw villagerSubid6And7Script_afterd4
	.dw villagerSubid6And7Script_afterNayruSaved
	.dw villagerSubid6And7Script_afterd7
	.dw villagerSubid6And7Script_afterGotMakuSeed
	.dw villagerSubid6And7Script_twinrovaKidnappedZelda
	.dw villagerSubid6And7Script_postGame

@subid08ScriptTable:
	.dw villagerSubid08Script_afterd7
	.dw villagerSubid08Script_afterGotMakuSeed
	.dw villagerSubid08Script_twinrovaKidnappedZelda
	.dw villagerSubid08Script_postGame


; ==============================================================================
; INTERACID_FEMALE_VILLAGER
; ==============================================================================
interactionCode3b:
	ld e,Interaction.state		; $7728
	ld a,(de)		; $772a
	rst_jumpTable			; $772b
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $7730
	ld (de),a		; $7732

	call interactionInitGraphics		; $7733
	call objectSetVisiblec2		; $7736
	call @initSubid		; $7739

	ld e,Interaction.enabled		; $773c
	ld a,(de)		; $773e
	or a			; $773f
	jp nz,objectMarkSolidPosition		; $7740
	ret			; $7743

@initSubid:
	ld e,Interaction.subid		; $7744
	ld a,(de)		; $7746
	rst_jumpTable			; $7747
	.dw @initSubid00
	.dw @initSubid01
	.dw @initSubid02
	.dw @initSubid03
	.dw @initSubid04
	.dw @initSubid05
	.dw @initSubid06
	.dw @initSubid07
	.dw @initSubid08

@initSubid00:
	ld a,$01		; $775a
	jp interactionSetAnimation		; $775c

@initSubid01:
@initSubid02:
	callab interactionBank2.getGameProgress_1		; $775f
	ld c,$01		; $7767
	xor a			; $7769
	call checkNpcShouldExistAtGameStage		; $776a
	jp nz,interactionDelete		; $776d

	ld a,b			; $7770
	ld hl,@subid1And2ScriptTable		; $7771
	rst_addDoubleIndex			; $7774
	ldi a,(hl)		; $7775
	ld h,(hl)		; $7776
	ld l,a			; $7777
	call interactionSetScript		; $7778
	jp objectSetVisible82		; $777b

@initSubid03:
@initSubid04:
	callab interactionBank2.getGameProgress_2		; $777e
	ld c,$03		; $7786
	ld a,$01		; $7788
	call checkNpcShouldExistAtGameStage		; $778a
	jp nz,interactionDelete		; $778d

	ld a,b			; $7790
	ld hl,@subid3And4ScriptTable		; $7791
	rst_addDoubleIndex			; $7794
	ldi a,(hl)		; $7795
	ld h,(hl)		; $7796
	ld l,a			; $7797
	call interactionSetScript		; $7798
	jp objectSetVisible82		; $779b

@initSubid05:
	ld a,$01		; $779e
	ld e,Interaction.oamFlags		; $77a0
	ld (de),a		; $77a2
	callab interactionBank2.getGameProgress_2		; $77a3
	ld c,$05		; $77ab
	ld a,$02		; $77ad
	call checkNpcShouldExistAtGameStage		; $77af
	jp nz,interactionDelete		; $77b2

	ld a,b			; $77b5
	ld hl,@subid5ScriptTable		; $77b6
	rst_addDoubleIndex			; $77b9
	ldi a,(hl)		; $77ba
	ld h,(hl)		; $77bb
	ld l,a			; $77bc
	call interactionSetScript		; $77bd
	jp objectSetVisible82		; $77c0

@initSubid07:
	ld a,GLOBALFLAG_WATER_POLLUTION_FIXED		; $77c3
	call checkGlobalFlag		; $77c5
	ld a,<TX_1526		; $77c8
	jr z,+			; $77ca
	ld a,<TX_1527		; $77cc
+
	ld e,Interaction.textID		; $77ce
	ld (de),a		; $77d0

	inc e			; $77d1
	ld a,>TX_1500		; $77d2
	ld (de),a		; $77d4

	xor a			; $77d5
	call interactionSetAnimation		; $77d6

	ld hl,villagerGalSubid07Script		; $77d9
	jp interactionSetScript		; $77dc

@initSubid08:
	ld e,Interaction.textID		; $77df
	ld a,<TX_0f03		; $77e1
	ld (de),a		; $77e3
	inc e			; $77e4
	ld a,>TX_0f03		; $77e5
	ld (de),a		; $77e7

	ld hl,genericNpcScript		; $77e8
	jp interactionSetScript		; $77eb

@initSubid06:
	ld a,$05		; $77ee
	ld e,Interaction.var3f		; $77f0
	ld (de),a		; $77f2
	ld hl,linkedGameNpcScript		; $77f3
	call interactionSetScript		; $77f6
	call interactionRunScript		; $77f9

@state1:
	ld e,Interaction.subid		; $77fc
	ld a,(de)		; $77fe
	rst_jumpTable			; $77ff
	.dw @runSubid00
	.dw @runScriptAndAnimateFacingLink
	.dw @runScriptAndAnimateFacingLink
	.dw @runScriptAndAnimateFacingLink
	.dw @runScriptAndAnimateFacingLink
	.dw @runScriptAndAnimateFacingLink
	.dw @runSubid06
	.dw @runSubid07
	.dw @runScriptAndAnimateFacingLink


; Cutscene where guy is struck by lightning in intro
@runSubid00:
	ld e,Interaction.state2		; $7812
	ld a,(de)		; $7814
	rst_jumpTable			; $7815
	.dw @@substate0
	.dw @@substate1
	.dw @@substate2
	.dw @@substate3
	.dw @@substate4

@@substate0:
	ld a,($cfd1)		; $7820
	cp $02			; $7823
	jp nz,interactionAnimate		; $7825

	call interactionIncState2		; $7828
	ld l,Interaction.xh		; $782b
	ld a,(hl)		; $782d
	ld l,Interaction.var3d		; $782e
	ld (hl),a		; $7830
	ret			; $7831

@@substate1:
	callab interactionOscillateXRandomly		; $7832
	ld a,($cfd1)		; $783a
	cp $04			; $783d
	ret nz			; $783f

	call interactionIncState2		; $7840
	ld l,Interaction.counter1		; $7843
	ld (hl),$1e		; $7845
	ret			; $7847

@@substate2:
	call interactionDecCounter1		; $7848
	ret nz			; $784b

	ld bc,-$1c0		; $784c
	call objectSetSpeedZ		; $784f
	ld a,SND_JUMP		; $7852
	call playSound		; $7854
	jp interactionIncState2		; $7857

@@substate3:
	ld c,$20		; $785a
	call objectUpdateSpeedZ_paramC		; $785c
	ret nz			; $785f

	call interactionIncState2		; $7860
	jp @loadScript		; $7863

@@substate4:
	call interactionAnimate2Times		; $7866
	call interactionRunScript		; $7869
	ret nc			; $786c
	jp interactionDelete		; $786d


; Generic NPCs
@runScriptAndAnimateFacingLink:
	call interactionRunScript		; $7870
	jp npcFaceLinkAndAnimate		; $7873

; Linked game NPC
@runSubid06:
	call interactionRunScript		; $7876
	jp c,interactionDelete		; $7879
	jp npcFaceLinkAndAnimate		; $787c

; NPC in eyeglasses library (present)
@runSubid07:
	call interactionRunScript		; $787f
	jp interactionAnimateAsNpc		; $7882


@loadScript:
	ld e,Interaction.subid		; $7885
	ld a,(de)		; $7887
	ld hl,@scriptTable		; $7888
	rst_addDoubleIndex			; $788b
	ldi a,(hl)		; $788c
	ld h,(hl)		; $788d
	ld l,a			; $788e
	jp interactionSetScript		; $788f


@scriptTable:
	.dw villagerGalSubid00Script
	.dw stubScript
	.dw stubScript
	.dw stubScript
	.dw stubScript
	.dw stubScript
	.dw stubScript

@subid1And2ScriptTable:
	.dw villagerGalSubid1And2Script_befored3
	.dw villagerGalSubid1And2Script_afterd3
	.dw villagerGalSubid1And2Script_afterNayruSaved
	.dw villagerGalSubid1And2Script_afterd7
	.dw villagerGalSubid1And2Script_afterGotMakuSeed
	.dw villagerGalSubid1And2Script_postGame

@subid3And4ScriptTable:
	.dw villagerGalSubid3And4Script_befored2
	.dw villagerGalSubid3And4Script_afterd2
	.dw villagerGalSubid3And4Script_afterd4
	.dw villagerGalSubid3And4Script_afterNayruSaved
	.dw villagerGalSubid3And4Script_afterd7
	.dw villagerGalSubid3And4Script_afterGotMakuSeed
	.dw villagerGalSubid3And4Script_twinrovaKidnappedZelda
	.dw villagerGalSubid3And4Script_postGame

@subid5ScriptTable:
	.dw villagerGalSubid05Script_befored2
	.dw villagerGalSubid05Script_afterd2
	.dw villagerGalSubid05Script_afterd4
	.dw villagerGalSubid05Script_afterNayruSaved
	.dw villagerGalSubid05Script_afterd7
	.dw villagerGalSubid05Script_afterd7
	.dw villagerGalSubid05Script_twinrovaKidnappedZelda
	.dw villagerGalSubid05Script_twinrovaKidnappedZelda ; Not used


; ==============================================================================
; INTERACID_BOY
; ==============================================================================
interactionCode3c:
	ld e,Interaction.state		; $78cc
	ld a,(de)		; $78ce
	rst_jumpTable			; $78cf
	.dw @state0
	.dw _boyState1

@state0:
	ld a,$01		; $78d4
	ld (de),a		; $78d6

	call interactionInitGraphics		; $78d7
	call objectSetVisiblec2		; $78da
	call @initSubid		; $78dd

	ld e,Interaction.enabled		; $78e0
	ld a,(de)		; $78e2
	or a			; $78e3
	jp nz,objectMarkSolidPosition		; $78e4
	ret			; $78e7

@initSubid:
	ld e,Interaction.subid		; $78e8
	ld a,(de)		; $78ea
	rst_jumpTable			; $78eb
	.dw @initSubid00
	.dw @initSubid01
	.dw @initSubid02
	.dw @initSubid03
	.dw @initSubid04
	.dw @initSubid05
	.dw @setStoneAnimationAndLoadScript
	.dw @initSubid07
	.dw @initSubid08
	.dw @initSubid09
	.dw @setStoneAnimationAndLoadScript
	.dw @initSubid0b
	.dw @setStoneAnimationAndLoadScript
	.dw @initSubid0d
	.dw @initSubid0e
	.dw @initSubid0f
	.dw @initSubid10


@initSubid03:
	call getThisRoomFlags		; $790e
	bit 6,a			; $7911
	jp nz,interactionDelete		; $7913

	call @saveXToVar3d		; $7916
	ld a,$01		; $7919
	ld (wDisabledObjects),a		; $791b
	ld (wMenuDisabled),a		; $791e

	jr @setRedPaletteAndLoadScript		; $7921

@initSubid01:
	ld a,$01		; $7923
	call interactionSetAnimation		; $7925

@setRedPaletteAndLoadScript:
	ld a,$02		; $7928
	ld e,Interaction.oamFlags		; $792a
	ld (de),a		; $792c
	jp _boyLoadScript		; $792d

@initSubid04:
	call getThisRoomFlags		; $7930
	bit 6,a			; $7933
	jp nz,interactionDelete		; $7935

	ld e,Interaction.counter1		; $7938
	ld a,$3c		; $793a
	ld (de),a		; $793c
	xor a			; $793d
	call interactionSetAnimation		; $793e

@saveXToVar3d:
	ld e,Interaction.xh		; $7941
	ld a,(de)		; $7943
	ld e,Interaction.var3d		; $7944
	ld (de),a		; $7946
	ret			; $7947

@initSubid05:
	call loadStoneNpcPalette		; $7948
	ld e,Interaction.oamFlags		; $794b
	ld a,$06		; $794d
	ld (de),a		; $794f
	ld e,Interaction.counter1		; $7950
	ld a,$3c		; $7952
	ld (de),a		; $7954
	ld a,$03		; $7955
	jp interactionSetAnimation		; $7957

@setStoneAnimationAndLoadScript:
	ld a,$03		; $795a
	call interactionSetAnimation		; $795c
	ld a,$02		; $795f
	ld e,Interaction.var38		; $7961
	ld (de),a		; $7963
	call loadStoneNpcPalette		; $7964
	jp _boyLoadScript		; $7967

@initSubid0e:
	; Was Veran defeated?
	ld hl,wGroup4Flags+$fc		; $796a
	bit 7,(hl)		; $796d
	ld a,<TX_251e		; $796f
	jr nz,@@notStone	; $7971

	ld a,(wEssencesObtained)		; $7973
	bit 6,a			; $7976
	ld a,<TX_251d		; $7978
	jr z,@@notStone	; $797a

	; If Veran's not defeated and d7 is beaten, change position to be in front of his
	; stone dad
	call objectUnmarkSolidPosition		; $797c
	ld bc,$4848		; $797f
	call interactionSetPosition		; $7982
	call objectMarkSolidPosition		; $7985

	ld h,d			; $7988
	ld l,Interaction.var03		; $7989
	inc (hl)		; $798b

	ld a,$06		; $798c
	call objectSetCollideRadius		; $798e
	ld e,Interaction.pressedAButton		; $7991
	call objectAddToAButtonSensitiveObjectList		; $7993

	ld a,<TX_251b		; $7996
	jr @setTextIDAndLoadScript		; $7998

@@notStone:
	push af			; $799a
	xor a			; $799b
	ld ($cfd3),a		; $799c

	ldbc INTERACID_BALL,$00		; $799f
	call objectCreateInteraction		; $79a2
	ld bc,$4a75		; $79a5
	call interactionHSetPosition		; $79a8

	pop af			; $79ab

@setTextIDAndLoadScript:
	ld e,Interaction.textID		; $79ac
	ld (de),a		; $79ae
	jr @setStoneAnimationAndLoadScript		; $79af

@initSubid00:
	xor a			; $79b1
	call interactionSetAnimation		; $79b2
	jp _boyLoadScript		; $79b5

@initSubid02:
	callab interactionBank2.getGameProgress_1		; $79b8
	ld a,b			; $79c0
	or a			; $79c1
	jr nz,++		; $79c2

	; In the early game, the boy only exists once you've gotten the satchel
	ld a,TREASURE_SEED_SATCHEL		; $79c4
	call checkTreasureObtained		; $79c6
	jp nc,interactionDelete		; $79c9
	xor a			; $79cc
++
	ld hl,_boySubid02ScriptTable		; $79cd
	rst_addDoubleIndex			; $79d0
	ldi a,(hl)		; $79d1
	ld h,(hl)		; $79d2
	ld l,a			; $79d3
	call interactionSetScript		; $79d4
	jr _boyState1		; $79d7

@initSubid07:
	ld h,d			; $79d9
	ld l,Interaction.var3f		; $79da
	inc (hl)		; $79dc
	call _boyLoadScript		; $79dd
	jr _boyState1		; $79e0

@initSubid08:
@initSubid09:
	ld h,d			; $79e2
	ld l,Interaction.counter1		; $79e3
	ld (hl),$78		; $79e5
	jp objectSetVisiblec1		; $79e7

@initSubid0b:
	xor a			; $79ea
	call interactionSetAnimation		; $79eb
	ld a,GLOBALFLAG_WATER_POLLUTION_FIXED		; $79ee
	call checkGlobalFlag		; $79f0
	ld a,<TX_2519		; $79f3
	jr z,+			; $79f5
	ld a,<TX_251a		; $79f7
+
	ld e,Interaction.textID		; $79f9
	ld (de),a		; $79fb
	inc e			; $79fc
	ld a,>TX_2500		; $79fd
	ld (de),a		; $79ff
	jp _boyLoadScript		; $7a00

@initSubid0d:
	ld a,GLOBALFLAG_SAVED_NAYRU		; $7a03
	call checkGlobalFlag		; $7a05
	jr nz,@@notStone		; $7a08

	call loadStoneNpcPalette		; $7a0a
	ld h,d			; $7a0d
	ld l,Interaction.oamFlags		; $7a0e
	ld (hl),$06		; $7a10
	ld a,$06		; $7a12
	call objectSetCollideRadius		; $7a14
	ld l,Interaction.var03		; $7a17
	inc (hl)		; $7a19
	ld a,$0c		; $7a1a
	jp interactionSetAnimation		; $7a1c

@@notStone:
	ld bc,$4868		; $7a1f
	call interactionSetPosition		; $7a22

	; Load red palette
	ld l,Interaction.oamFlags		; $7a25
	ld (hl),$02		; $7a27

	jp _boyLoadScript		; $7a29

@initSubid10:
	ld a,GLOBALFLAG_FINISHEDGAME		; $7a2c
	call checkGlobalFlag		; $7a2e
	jp z,interactionDelete		; $7a31

@initSubid0f:
	jp _boyLoadScript		; $7a34

;;
; @addr{7a37}
_boyState1:
	ld e,Interaction.subid		; $7a37
	ld a,(de)		; $7a39
	rst_jumpTable			; $7a3a
	.dw _boyRunSubid00
	.dw _boyRunSubid01
	.dw _boyRunSubid02
	.dw  boyRunSubid03
	.dw _boyRunSubid04
	.dw _boyRunSubid05
	.dw _boyRunSubid06
	.dw _boyRunSubid07
	.dw  boyRunSubid08
	.dw  boyRunSubid09
	.dw _boyRunSubid0a
	.dw _boyRunSubid0b
	.dw _boyRunSubid0c
	.dw _boyRunSubid0d
	.dw _boyRunSubid0e
	.dw _boyRunSubid0f
	.dw _boyRunSubid10


; Watching Nayru sing in intro
_boyRunSubid00:
	call interactionAnimate		; $7a5d
	call objectSetPriorityRelativeToLink_withTerrainEffects		; $7a60

	ld e,Interaction.state2		; $7a63
	ld a,(de)		; $7a65
	or a			; $7a66
	call z,objectPreventLinkFromPassing		; $7a67

	ld e,Interaction.state2		; $7a6a
	ld a,(de)		; $7a6c
	rst_jumpTable			; $7a6d
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate0:
	ld a,($cfd0)		; $7a76
	cp $0e			; $7a79
	jp nz,interactionRunScript		; $7a7b

	call interactionIncState2		; $7a7e
	ld a,$02		; $7a81
	jp interactionSetAnimation		; $7a83

@substate1:
	call interactionAnimate		; $7a86
	ld a,($cfd0)		; $7a89
	cp $10			; $7a8c
	ret nz			; $7a8e

	call interactionIncState2		; $7a8f
	ld bc,-$180		; $7a92
	call objectSetSpeedZ		; $7a95
	ld a,$02		; $7a98
	jp interactionSetAnimation		; $7a9a

@substate2:
	ld c,$20		; $7a9d
	call objectUpdateSpeedZ_paramC		; $7a9f
	ret nz			; $7aa2

	; Run away
	call interactionIncState2		; $7aa3
	ld l,Interaction.angle		; $7aa6
	ld (hl),$02		; $7aa8
	ld l,Interaction.speed		; $7aaa
	ld (hl),SPEED_180		; $7aac
	xor a			; $7aae
	jp interactionSetAnimation		; $7aaf

@substate3:
	call objectCheckWithinScreenBoundary		; $7ab2
	jp nc,interactionDelete		; $7ab5
	jp objectApplySpeed		; $7ab8


; Kid turning to stone cutscene
_boyRunSubid01:
	ld e,Interaction.state2		; $7abb
	ld a,(de)		; $7abd
	rst_jumpTable			; $7abe
	.dw @substate0
	.dw @substate1
	.dw @substate2

@substate0:
	call interactionRunScript		; $7ac5
	ld a,($cfd1)		; $7ac8
	cp $01			; $7acb
	jr nz,+			; $7acd
	jp interactionIncState2		; $7acf
+
	ld e,Interaction.counter2		; $7ad2
	ld a,(de)		; $7ad4
	or a			; $7ad5
	ret z			; $7ad6
	jp interactionAnimate2Times		; $7ad7

@substate1:
	call interactionRunScript		; $7ada
	ld a,($cfd1)		; $7add
	cp $02			; $7ae0
	jr nz,++		; $7ae2

	call interactionIncState2		; $7ae4
	ld l,Interaction.oamFlags		; $7ae7
	ld (hl),$06		; $7ae9
	ret			; $7aeb
++
	; Flicker palette from red to stone every 8 frames
	ld a,(wFrameCounter)		; $7aec
	and $07			; $7aef
	ret nz			; $7af1
	ld e,Interaction.oamFlags		; $7af2
	ld a,(de)		; $7af4
	xor $04			; $7af5
	ld (de),a		; $7af7
	ret			; $7af8

@substate2:
	call interactionRunScript		; $7af9
	jp nc,interactionAnimate		; $7afc
	ret			; $7aff


; Kid outside shop
_boyRunSubid02:
	call interactionRunScript		; $7b00
	jp npcFaceLinkAndAnimate		; $7b03


; Cutscene where kids talk about how they're scared of a ghost (red kid)
; Also called the "other" child interaction?
boyRunSubid03:
	call interactionRunScript		; $7b06

	ld e,Interaction.var39		; $7b09
	ld a,(de)		; $7b0b
	or a			; $7b0c
	call z,interactionAnimateBasedOnSpeed		; $7b0d

	call objectCheckWithinScreenBoundary		; $7b10
	ret c			; $7b13

	xor a			; $7b14
	ld (wDisabledObjects),a		; $7b15
	ld (wMenuDisabled),a		; $7b18
	call getThisRoomFlags		; $7b1b
	set 6,(hl)		; $7b1e
	jp interactionDelete		; $7b20


; Cutscene where kids talk about how they're scared of a ghost (green kid)
_boyRunSubid04:
	ld e,Interaction.state2		; $7b23
	ld a,(de)		; $7b25
	rst_jumpTable			; $7b26
	.dw @substate0
	.dw @substate1
	.dw boyRunSubid03

@substate0:
	call interactionAnimate		; $7b2d
	call interactionDecCounter1		; $7b30
	ret nz			; $7b33
	call interactionIncState2		; $7b34
	jp startJump		; $7b37

@substate1:
	ld c,$20		; $7b3a
	call objectUpdateSpeedZ_paramC		; $7b3c
	ret nz			; $7b3f
	call interactionIncState2		; $7b40
	jp _boyLoadScript		; $7b43


; Cutscene where kid is restored from stone
_boyRunSubid05:
	ld e,Interaction.state2		; $7b46
	ld a,(de)		; $7b48
	rst_jumpTable			; $7b49
	.dw @substate0
	.dw _childSubid05Substate1
	.dw _childAnimateIfVar39IsZeroAndRunScript

@substate0:
	call interactionDecCounter1		; $7b50
	ret nz			; $7b53

;;
; Used in cutscenes where people get restored from stone?
; @addr{7b54}
setCounter1To120AndPlaySoundEffectAndIncState2:
	ld a,120		; $7b54
	ld e,Interaction.counter1		; $7b56
	ld (de),a		; $7b58
	ld a,SND_ENERGYTHING		; $7b59
	call playSound		; $7b5b
	jp interactionIncState2		; $7b5e


_childSubid05Substate1:
	call interactionDecCounter1		; $7b61
	jr nz,childFlickerBetweenStone		; $7b64

	call interactionIncState2		; $7b66
	ld l,Interaction.oamFlags		; $7b69
	ld (hl),$02		; $7b6b
	jp _boyLoadScript		; $7b6d

;;
; Called from other interactions as well?
childFlickerBetweenStone:
	ld a,(wFrameCounter)		; $7b70
	and $07			; $7b73
	ret nz			; $7b75
	ld e,Interaction.oamFlags		; $7b76
	ld a,(de)		; $7b78
	xor $04			; $7b79
	ld (de),a		; $7b7b
	ret			; $7b7c

_childAnimateIfVar39IsZeroAndRunScript:
	ld e,Interaction.var39		; $7b7d
	ld a,(de)		; $7b7f
	or a			; $7b80
	call z,interactionAnimateBasedOnSpeed		; $7b81
	jp interactionRunScript		; $7b84


; Cutscene where kid sees his dad turn to stone
_boyRunSubid06:
	call checkInteractionState2		; $7b87
	call nz,interactionAnimateBasedOnSpeed		; $7b8a
	jp interactionRunScript		; $7b8d


; Depressed kid in trade sequence
_boyRunSubid07:
	call interactionRunScript		; $7b90
	ld e,Interaction.var3d		; $7b93
	ld a,(de)		; $7b95
	or a			; $7b96
	jp z,npcFaceLinkAndAnimate		; $7b97
	call interactionAnimate		; $7b9a
	jp objectSetPriorityRelativeToLink_withTerrainEffects		; $7b9d


; Kid who runs around in a pattern? Used in a credits cutscene maybe?
; Also called by another interaction?
boyRunSubid08:
boyRunSubid09:
	ld e,Interaction.state2		; $7ba0
	ld a,(de)		; $7ba2
	rst_jumpTable			; $7ba3
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4
	.dw @substate5
	.dw @substate6
	.dw @substate7
	.dw @substate8
	.dw @substate9
	.dw @substateA
	.dw @substateB

@substate0:
	call interactionDecCounter1		; $7bbc
	ret nz			; $7bbf
	ld (hl),$66		; $7bc0

	ld l,Interaction.speed		; $7bc2
	ld (hl),SPEED_140		; $7bc4
	ld l,Interaction.angle		; $7bc6
	ld (hl),$18		; $7bc8

	call interactionIncState2		; $7bca

@setAnimationFromAngle:
	ld e,Interaction.angle		; $7bcd
	ld a,(de)		; $7bcf
	call convertAngleDeToDirection		; $7bd0
	jp interactionSetAnimation		; $7bd3


@substate1:
	call @updateAnimationTwiceAndApplySpeed		; $7bd6
	call interactionDecCounter1		; $7bd9
	ret nz			; $7bdc

	call getRandomNumber		; $7bdd
	and $0f			; $7be0
	add $1e			; $7be2
	ld (hl),a		; $7be4

	ld l,Interaction.angle		; $7be5
	ld (hl),$08		; $7be7
	call @setAnimationFromAngle		; $7be9
	jp interactionIncState2		; $7bec

@updateAnimationTwiceAndApplySpeed:
	call interactionAnimate2Times		; $7bef
	jp objectApplySpeed		; $7bf2


@substate2:
	call interactionDecCounter1		; $7bf5
	ret nz			; $7bf8
	call _boyStartHop		; $7bf9
	jp interactionIncState2		; $7bfc

@substate3:
	call _boyUpdateGravityAndHopWhenLanded		; $7bff
	ld a,($cfd0)		; $7c02
	cp $01			; $7c05
	ret nz			; $7c07

	ld e,Interaction.zh		; $7c08
	ld a,(de)		; $7c0a
	or a			; $7c0b
	ret nz			; $7c0c

	call interactionIncState2		; $7c0d
	ld l,Interaction.counter1		; $7c10
	ld (hl),$1e		; $7c12
	ret			; $7c14

@substate4:
	call interactionDecCounter1		; $7c15
	ret nz			; $7c18

	ld l,Interaction.speed		; $7c19
	ld (hl),SPEED_200		; $7c1b
	call @updateAngleAndCounter		; $7c1d
	jp interactionIncState2		; $7c20

@substate5:
	ld a,($cfd0)		; $7c23
	cp $02			; $7c26
	jr nz,++		; $7c28
	ld e,Interaction.zh		; $7c2a
	ld a,(de)		; $7c2c
	or a			; $7c2d
	jr nz,++		; $7c2e

	call interactionIncState2		; $7c30

	ld l,Interaction.counter1		; $7c33
	ld (hl),$0a		; $7c35
	ld l,Interaction.angle		; $7c37
	ld (hl),$18		; $7c39
	jp @setAnimationFromAngle		; $7c3b
++
	ld e,Interaction.var37		; $7c3e
	ld a,(de)		; $7c40
	rst_jumpTable			; $7c41
	.dw @@val0
	.dw @@val1
	.dw @@val2

@@val0:
	call @updateAnimationTwiceAndApplySpeed		; $7c48
	call interactionDecCounter1		; $7c4b
	ret nz			; $7c4e
	ld (hl),$0a		; $7c4f

	ld l,Interaction.var37		; $7c51
	inc (hl)		; $7c53
	cp $68			; $7c54
	ld a,$01		; $7c56
	jr c,+			; $7c58
	ld a,$03		; $7c5a
+
	jp interactionSetAnimation		; $7c5c

@@val1:
	call interactionDecCounter1		; $7c5f
	ret nz			; $7c62
	ld (hl),$1e		; $7c63
	ld l,Interaction.var37		; $7c65
	inc (hl)		; $7c67
	jp _boyStartHop		; $7c68

@@val2:
	call _boyUpdateGravityAndHopWhenLanded		; $7c6b
	call interactionDecCounter1		; $7c6e
	ret nz			; $7c71

	xor a			; $7c72
	ld l,Interaction.z		; $7c73
	ldi (hl),a		; $7c75
	ld (hl),a		; $7c76

	ld l,Interaction.var37		; $7c77
	ld (hl),$00		; $7c79

;;
; @addr{7c7b}
@updateAngleAndCounter:
	ld e,Interaction.id		; $7c7b
	ld a,(de)		; $7c7d
	cp INTERACID_BOY			; $7c7e
	jr z,@boy		; $7c80

	; Which interaction is this for?
	ld a,$02		; $7c82
	jr ++			; $7c84

@boy:
	ld e,Interaction.subid		; $7c86
	ld a,(de)		; $7c88
	sub $08			; $7c89
++
	; a *= 9
	ld b,a			; $7c8b
	swap a			; $7c8c
	sra a			; $7c8e
	add b			; $7c90

	ld hl,@movementData		; $7c91
	rst_addAToHl			; $7c94
	ld e,Interaction.counter2		; $7c95
	ld a,(de)		; $7c97
	rst_addDoubleIndex			; $7c98

	ldi a,(hl)		; $7c99
	ld b,(hl)		; $7c9a
	inc l			; $7c9b
	ld e,Interaction.counter1		; $7c9c
	ld (de),a		; $7c9e
	ld e,Interaction.angle		; $7c9f
	ld a,b			; $7ca1
	ld (de),a		; $7ca2

	ld e,Interaction.counter2		; $7ca3
	ld a,(de)		; $7ca5
	ld b,a			; $7ca6
	inc b			; $7ca7
	ld a,(hl)		; $7ca8
	or a			; $7ca9
	jr nz,+			; $7caa
	ld b,$00		; $7cac
+
	ld a,b			; $7cae
	ld (de),a		; $7caf
	jp @setAnimationFromAngle		; $7cb0


; Data format:
;   b0: Number of frames to move
;   b1: Angle to move in
@movementData:
	.db $1a $09 ; Subid $08
	.db $16 $1f
	.db $17 $17
	.db $0c $0f
	.db $00

	.db $0c $09 ; Subid $09
	.db $18 $0a
	.db $16 $18
	.db $12 $1f
	.db $00

	.db $1d $08 ; Subid $0a
	.db $19 $16
	.db $18 $0a
	.db $06 $01
	.db $00

@substate6:
	call interactionDecCounter1		; $7cce
	ret nz			; $7cd1

	ld e,Interaction.id		; $7cd2
	ld a,(de)		; $7cd4
	ld b,$34		; $7cd5
	cp INTERACID_BOY_2			; $7cd7
	jr z,+			; $7cd9
	ld b,$20		; $7cdb
+
	ld (hl),b		; $7cdd
	ld l,Interaction.speed		; $7cde
	ld (hl),SPEED_180		; $7ce0
	jp interactionIncState2		; $7ce2


@substate7:
	call @updateAnimationTwiceAndApplySpeed		; $7ce5
	call interactionDecCounter1		; $7ce8
	ret nz			; $7ceb

	call getRandomNumber		; $7cec
	and $07			; $7cef
	inc a			; $7cf1
	ld (hl),a		; $7cf2

	ld a,$01		; $7cf3
	call interactionSetAnimation		; $7cf5
	jp interactionIncState2		; $7cf8


; Waiting for signal to start hopping again
@substate8:
	ld a,($cfd0)		; $7cfb
	cp $03			; $7cfe
	ret nz			; $7d00
	call interactionDecCounter1		; $7d01
	ret nz			; $7d04
	call interactionIncState2		; $7d05
	jp _boyStartHop		; $7d08


; Waiting for signal to move off the left side of the screen
@substate9:
	call _boyUpdateGravityAndHopWhenLanded		; $7d0b

	ld a,($cfd0)		; $7d0e
	cp $04			; $7d11
	ret nz			; $7d13
	ld e,Interaction.zh		; $7d14
	ld a,(de)		; $7d16
	or a			; $7d17
	ret nz			; $7d18

	call interactionIncState2		; $7d19
	ld l,Interaction.counter1		; $7d1c
	ld (hl),$0c		; $7d1e
	ret			; $7d20

@substateA:
	call interactionDecCounter1		; $7d21
	ret nz			; $7d24

	call interactionIncState2		; $7d25
	ld l,Interaction.counter1		; $7d28
	ld (hl),$50		; $7d2a
	ld l,Interaction.speed		; $7d2c
	ld (hl),SPEED_180		; $7d2e
	ld a,$03		; $7d30
	jp interactionSetAnimation		; $7d32

@substateB:
	call @updateAnimationTwiceAndApplySpeed		; $7d35
	call interactionDecCounter1		; $7d38
	jp z,interactionDelete		; $7d3b
	ret			; $7d3e


; Cutscene?
_boyRunSubid0a:
	call interactionAnimate		; $7d3f
	jp _childAnimateIfVar39IsZeroAndRunScript		; $7d42


; NPC in eyeglasses library present
_boyRunSubid0b:
	call interactionRunScript		; $7d45
	jp interactionAnimateAsNpc		; $7d48


; Cutscene where kid's dad gets restored from stone
_boyRunSubid0c:
	ld e,Interaction.state2		; $7d4b
	ld a,(de)		; $7d4d
	rst_jumpTable			; $7d4e
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4
	.dw _childAnimateIfVar39IsZeroAndRunScript

@substate0:
	call interactionAnimate2Times		; $7d5b
	ld a,($cfd1)		; $7d5e
	cp $01			; $7d61
	ret nz			; $7d63

	call interactionIncState2		; $7d64
	ld l,Interaction.counter1		; $7d67
	ld (hl),$78		; $7d69

	ld a,$03		; $7d6b
	call interactionSetAnimation		; $7d6d

	ld a,$3c		; $7d70
	ld bc,$f408		; $7d72
	jp objectCreateExclamationMark		; $7d75

@substate1:
	call interactionDecCounter1		; $7d78
	ret nz			; $7d7b
	call interactionIncState2		; $7d7c
	ld bc,-$1c0		; $7d7f
	jp objectSetSpeedZ		; $7d82

@substate2:
	ld c,$20		; $7d85
	call objectUpdateSpeedZ_paramC		; $7d87
	ret nz			; $7d8a

	ld a,$02		; $7d8b
	ld ($cfd1),a		; $7d8d
	call interactionIncState2		; $7d90
	ld l,Interaction.counter1		; $7d93
	ld (hl),120		; $7d95
	ret			; $7d97

@substate3:
	call interactionDecCounter1		; $7d98
	ret nz			; $7d9b
	ld (hl),$3c		; $7d9c
	jp interactionIncState2		; $7d9e

@substate4:
	call interactionAnimate2Times		; $7da1
	call interactionDecCounter1		; $7da4
	ret nz			; $7da7
	jp interactionIncState2		; $7da8


; Kid with grandma who's either stone or was restored from stone
_boyRunSubid0d:
	ld e,Interaction.var03		; $7dab
	ld a,(de)		; $7dad
	or a			; $7dae
	jp nz,interactionPushLinkAwayAndUpdateDrawPriority		; $7daf
	call interactionRunScript		; $7db2
	jp npcFaceLinkAndAnimate		; $7db5


; NPC playing catch with dad, or standing next to his stone dad
_boyRunSubid0e:
	; Check if his dad is stone
	ld e,Interaction.var03		; $7db8
	ld a,(de)		; $7dba
	or a			; $7dbb
	jr z,+			; $7dbc

	call interactionAnimate2Times		; $7dbe
	jr ++			; $7dc1
+
	call interactionRunScript		; $7dc3
++
	call interactionPushLinkAwayAndUpdateDrawPriority		; $7dc6
	ld h,d			; $7dc9
	ld l,Interaction.pressedAButton		; $7dca
	ld a,(hl)		; $7dcc
	or a			; $7dcd
	ret z			; $7dce

	ld (hl),$00		; $7dcf
	ld b,>TX_2500		; $7dd1
	ld l,Interaction.textID		; $7dd3
	ld c,(hl)		; $7dd5
	jp showText		; $7dd6

; Subid $0f: Cutscene where kid runs away?
; Subid $10: Kid listening to Nayru postgame
_boyRunSubid0f:
_boyRunSubid10:
	call interactionRunScript		; $7dd9
	jp c,interactionDelete		; $7ddc
	call interactionAnimateBasedOnSpeed		; $7ddf
	jp interactionPushLinkAwayAndUpdateDrawPriority		; $7de2

;;
; Load palette used for turning npcs to stone?
; @addr{7de5}
loadStoneNpcPalette:
	ld a,PALH_a2		; $7de5
	jp loadPaletteHeader		; $7de7

;;
; @addr{7dea}
_boyUpdateGravityAndHopWhenLanded:
	ld c,$20		; $7dea
	call objectUpdateSpeedZ_paramC		; $7dec
	ret nz			; $7def

;;
; @addr{7df0}
_boyStartHop:
	ld bc,-$e0		; $7df0
	jp objectSetSpeedZ		; $7df3

;;
; Load a script for INTERACID_BOY.
; @addr{7df6}
_boyLoadScript:
	ld e,Interaction.subid		; $7df6
	ld a,(de)		; $7df8
	ld hl,@scriptTable		; $7df9
	rst_addDoubleIndex			; $7dfc
	ldi a,(hl)		; $7dfd
	ld h,(hl)		; $7dfe
	ld l,a			; $7dff
	jp interactionSetScript		; $7e00

; @addr{7e03}
@scriptTable:
	.dw boySubid00Script
	.dw boySubid01Script
	.dw boyStubScript
	.dw boySubid03Script
	.dw boySubid04Script
	.dw boySubid05Script
	.dw boySubid06Script
	.dw boySubid07Script
	.dw boyStubScript
	.dw boyStubScript
	.dw boySubid0aScript
	.dw boySubid0bScript
	.dw boySubid0cScript
	.dw boySubid0dScript
	.dw boySubid0eScript
	.dw boySubid0fScript
	.dw boySubid00Script

_boySubid02ScriptTable:
	.dw boySubid02Script_afterGotSeedSatchel
	.dw boySubid02Script_afterd3
	.dw boySubid02Script_afterNayruSaved
	.dw boySubid02Script_afterd7
	.dw boySubid02Script_afterGotMakuSeed
	.dw boySubid02Script_postGame


; ==============================================================================
; INTERACID_OLD_LADY
; ==============================================================================
interactionCode3d:
	ld e,Interaction.state		; $7e31
	ld a,(de)		; $7e33
	rst_jumpTable			; $7e34
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $7e39
	ld (de),a		; $7e3b

	call interactionInitGraphics		; $7e3c
	call objectSetVisiblec2		; $7e3f
	call @initSubid		; $7e42

	ld e,Interaction.enabled		; $7e45
	ld a,(de)		; $7e47
	or a			; $7e48
	jp nz,objectMarkSolidPosition		; $7e49
	ret			; $7e4c

@initSubid:
	ld e,Interaction.subid		; $7e4d
	ld a,(de)		; $7e4f
	rst_jumpTable			; $7e50
	.dw @initSubid0
	.dw @loadScript
	.dw @initSubid2
	.dw @initSubid3
	.dw @initSubid4
	.dw @initSubid5

@initSubid0:
	ld a,$03		; $7e5d
	call interactionSetAnimation		; $7e5f

	; Check whether her grandson is stone
	ld a,GLOBALFLAG_SAVED_NAYRU		; $7e62
	call checkGlobalFlag		; $7e64
	jr z,@loadScript	; $7e67

	; Set var03 to nonzero if her grandson is stone, also change her position
	ld a,$01		; $7e69
	ld e,Interaction.var03		; $7e6b
	ld (de),a		; $7e6d
	ld bc,$4878		; $7e6e
	call interactionSetPosition		; $7e71

@loadScript:
	ld e,Interaction.subid		; $7e74
	ld a,(de)		; $7e76
	ld hl,_oldLadyScriptTable		; $7e77
	rst_addDoubleIndex			; $7e7a
	ldi a,(hl)		; $7e7b
	ld h,(hl)		; $7e7c
	ld l,a			; $7e7d
	jp interactionSetScript		; $7e7e

@initSubid2:
	; This NPC only exists between saving Nayru and beating d7?
	callab interactionBank2.getGameProgress_1		; $7e81
	ld e,Interaction.subid		; $7e89
	ld a,(de)		; $7e8b
	cp b			; $7e8c
	jp nz,interactionDelete		; $7e8d
	jr @loadScript		; $7e90

@initSubid3:
	ld e,Interaction.counter1		; $7e92
	ld a,220		; $7e94
	ld (de),a		; $7e96

	ld a,$03		; $7e97
	jp interactionSetAnimation		; $7e99

@initSubid4:
	ld a,$00		; $7e9c
	jr ++			; $7e9e

@initSubid5:
	ld a,$09		; $7ea0
++
	ld e,Interaction.var3f		; $7ea2
	ld (de),a		; $7ea4
	ld hl,linkedGameNpcScript		; $7ea5
	call interactionSetScript		; $7ea8
	call interactionRunScript		; $7eab
	jr @state1		; $7eae

@state1:
	ld e,Interaction.subid		; $7eb0
	ld a,(de)		; $7eb2
	rst_jumpTable			; $7eb3
	.dw @runSubid0
	.dw @runSubid1
	.dw @runSubid2
	.dw @runSubid3
	.dw @runSubid4
	.dw @runSubid5


; NPC with a grandson that is stone for part of the game
@runSubid0:
	call interactionRunScript		; $7ec0

	ld e,Interaction.var03		; $7ec3
	ld a,(de)		; $7ec5
	or a			; $7ec6
	jp z,interactionAnimateAsNpc		; $7ec7
	jp npcFaceLinkAndAnimate		; $7eca


; Cutscene where her grandson gets turned to stone
@runSubid1:
	ld e,Interaction.state2		; $7ecd
	ld a,(de)		; $7ecf
	rst_jumpTable			; $7ed0
	.dw @@substate0
	.dw @@substate1
	.dw @@substate2
	.dw @@substate3

@@substate0:
	call interactionAnimate		; $7ed9
	call interactionRunScript		; $7edc
	jr nc,++		; $7edf

	; Script ended
	call interactionIncState2		; $7ee1
	ld l,Interaction.counter1		; $7ee4
	ld (hl),60		; $7ee6
	ret			; $7ee8
++
	ld e,Interaction.counter2		; $7ee9
	ld a,(de)		; $7eeb
	or a			; $7eec
	jp nz,interactionAnimate2Times		; $7eed
	ret			; $7ef0

@@substate1:
	call interactionDecCounter1		; $7ef1
	ret nz			; $7ef4
	ld (hl),20		; $7ef5
	jp interactionIncState2		; $7ef7

@@substate2:
	call interactionDecCounter1		; $7efa
	jp nz,interactionAnimate3Times		; $7efd
	ld (hl),60		; $7f00
	jp interactionIncState2		; $7f02

@@substate3:
	call interactionDecCounter1		; $7f05
	ret nz			; $7f08
	ld a,$ff		; $7f09
	ld ($cfdf),a		; $7f0b
	ret			; $7f0e


; NPC in present, screen left from bipin&blossom's house
@runSubid2:
	call interactionRunScript		; $7f0f
	jp npcFaceLinkAndAnimate		; $7f12


; Cutscene where her grandson is restored from stone
@runSubid3:
	ld e,Interaction.state2		; $7f15
	ld a,(de)		; $7f17
	rst_jumpTable			; $7f18
	.dw @@substate0
	.dw @@substate1
	.dw @@substate2

@@substate0:
	call interactionDecCounter1		; $7f1f
	ret nz			; $7f22
	call startJump		; $7f23
	jp interactionIncState2		; $7f26

@@substate1:
	ld c,$20		; $7f29
	call objectUpdateSpeedZ_paramC		; $7f2b
	ret nz			; $7f2e

	call interactionIncState2		; $7f2f
	ld l,Interaction.var38		; $7f32
	ld (hl),$b4		; $7f34
	jp @loadScript		; $7f36

@@substate2:
	ld h,d			; $7f39
	ld l,Interaction.var38		; $7f3a
	dec (hl)		; $7f3c
	jr nz,++		; $7f3d
	ld a,$ff		; $7f3f
	ld ($cfdf),a		; $7f41
++
	call interactionRunScript		; $7f44
	jp interactionAnimateBasedOnSpeed		; $7f47


; Linked game NPC
@runSubid4:
@runSubid5:
	call interactionRunScript		; $7f4a
	jp c,interactionDelete		; $7f4d
	jp npcFaceLinkAndAnimate		; $7f50


_oldLadyScriptTable:
	.dw oldLadySubid0Script
	.dw oldLadySubid1Script
	.dw oldLadySubid2Script
	.dw oldLadySubid3Script

.ends


.BANK $09 SLOT 1
.ORG 0

 m_section_force Interactions_Bank9 NAMESPACE interactionBank2

;;
; Reloads the tiles for "price" on the item selection area when necessary.
; @addr{4000}
checkReloadShopItemTiles:
	ld a,(wScrollMode)		; $4000
	cp $02			; $4003
	ret z			; $4005

	ld hl,wInShop		; $4006
	bit 2,(hl)		; $4009
	ret z			; $400b

	res 2,(hl)		; $400c
	push de			; $400e
	ld a,UNCMP_GFXH_11		; $400f
	call loadUncompressedGfxHeader		; $4011
	pop de			; $4014
	ret			; $4015


; ==============================================================================
; INTERACID_SHOPKEEPER
;
; Variables:
;   var37: Index of item that Link is holding (the item's "subid")
;   var38: Nonzero if the item can't be sold (ie. Link already has a shield)
;   var39: Which chest is the correct one in the chest minigame (0 or 1)
;   var3a: "Return value" from purchase script (if $ff, the purchase failed)
;   var3b: Object index of item that Link is holding
;   var3c: The current round in the chest minigame.
;   var3f: If nonzero, this is the tier of the ring Link is buying.
; ==============================================================================
interactionCode46:
	call checkReloadShopItemTiles		; $4016
	call @runState		; $4019
	jp interactionAnimateAsNpc		; $401c

@runState:
	ld e,Interaction.state		; $401f
	ld a,(de)		; $4021
	rst_jumpTable			; $4022
	.dw _shopkeeperState0
	.dw _shopkeeperState1
	.dw _shopkeeperState2
	.dw _shopkeeperState3
	.dw _shopkeeperState4
	.dw _shopkeeperState5
	.dw _shopkeeperState6

_shopkeeperState0:
	ld a,$01		; $4031
	ld (de),a		; $4033

	; Set this guy to always be active even when textboxes are up
	ld e,Interaction.enabled		; $4034
	ld a,(de)		; $4036
	or $80			; $4037
	ld (de),a		; $4039

	ld a,$80		; $403a
	ld ($cca2),a		; $403c

	call interactionInitGraphics		; $403f

	ld e,Interaction.angle		; $4042
	ld a,$04		; $4044
	ld (de),a		; $4046
	ld bc,$0614		; $4047
	call objectSetCollideRadii		; $404a

	ld l,Interaction.subid		; $404d
	ld a,(hl)		; $404f
	cp $01			; $4050
	jr nz,++		; $4052

	; Set bit 7 of subid if the chest game should be run
	ld a,(wBoughtShopItems1)		; $4054
	and $0f			; $4057
	cp $0f			; $4059
	jr nz,++		; $405b
	set 7,(hl)		; $405d
++
	ld e,Interaction.subid		; $405f
	ld a,(de)		; $4061
	or a			; $4062
	ld a,$03		; $4063
	call z,interactionSetAnimation		; $4065

	ld a,>TX_0e00		; $4068
	call interactionSetHighTextIndex		; $406a
	ld e,Interaction.pressedAButton		; $406d
	jp objectAddToAButtonSensitiveObjectList		; $406f


; State 1: waiting for Link to do something
_shopkeeperState1:
	call retIfTextIsActive		; $4072

	ld e,Interaction.pressedAButton		; $4075
	ld a,(de)		; $4077
	or a			; $4078
	jr nz,@pressedA	; $4079

	; Check Link's position to see if he's trying to steal something
	ld e,Interaction.subid		; $407b
	ld a,(de)		; $407d
	or a			; $407e
	ld hl,w1Link.xh		; $407f
	jr nz,+			; $4082
+
	ld l,<w1Link.yh		; $4084
	ld e,Interaction.subid		; $4086
	ld a,(de)		; $4088
	and $01			; $4089
	ld c,$69		; $408b
	ld b,(hl)		; $408d
	ld a,$69		; $408e
	jr z,+			; $4090
	ld b,$27		; $4092
	ld c,(hl)		; $4094
	ld a,$27		; $4095
+
	ld l,a			; $4097
	ld a,c			; $4098
	cp b			; $4099
	jr nc,@setNormalCollisionRadii	; $409a
	ld a,(wLinkGrabState)		; $409c
	or a			; $409f
	jr z,@setNormalCollisionRadii	; $40a0

	; He's trying to steal something, stop him!
	ld a,$81		; $40a2
	ld (wDisabledObjects),a		; $40a4
	ld a,l			; $40a7
	ld hl,w1Link.yh		; $40a8
	ld (hl),a		; $40ab

	ld bc,$0606		; $40ac
	call objectSetCollideRadii		; $40af

	ld e,Interaction.subid		; $40b2
	ld a,(de)		; $40b4
	ld hl,_shopkeeperTheftPreventionScriptTable		; $40b5
	rst_addDoubleIndex			; $40b8
	ldi a,(hl)		; $40b9
	ld h,(hl)		; $40ba
	ld l,a			; $40bb
	jp _shopkeeperLoadScript		; $40bc

@setNormalCollisionRadii:
	ld bc,$0614		; $40bf
	jp objectSetCollideRadii		; $40c2

@pressedA:
	xor a			; $40c5
	ld (de),a		; $40c6
	call objectRemoveFromAButtonSensitiveObjectList		; $40c7
	call _shopkeeperTurnToFaceLink		; $40ca

	ld a,$81		; $40cd
	ld (wDisabledObjects),a		; $40cf

	ld e,Interaction.state		; $40d2
	ld a,$02		; $40d4
	ld (de),a		; $40d6
	ret			; $40d7


; State 6: ?
_shopkeeperState6:
	ld e,Interaction.pressedAButton		; $40d8
	ld a,(de)		; $40da
	or a			; $40db
	jr nz,@pressedA		; $40dc

	ld hl,w1Link.xh		; $40de
	ld e,Interaction.xh		; $40e1
	ld a,(de)		; $40e3
	cp (hl)			; $40e4
	ret nc			; $40e5
	jp _shopkeeperGotoState1		; $40e6

@pressedA:
	xor a			; $40e9
	ld (de),a		; $40ea
	call objectRemoveFromAButtonSensitiveObjectList		; $40eb

	ld a,$81		; $40ee
	ld (wDisabledObjects),a		; $40f0

	ld e,Interaction.state		; $40f3
	ld a,$02		; $40f5
	ld (de),a		; $40f7
	jp _shopkeeperTurnToFaceLink		; $40f8


; State 2: talking to Link (this code still runs even while text is up)
_shopkeeperState2:
	ld e,Interaction.subid		; $40fb
	ld a,(de)		; $40fd
	and $80			; $40fe
	jr nz,_shopkeeperPromptChestGame	; $4100

	ld a,(wLinkGrabState)		; $4102
	or a			; $4105
	jr z,@holdingNothing	; $4106

	; Check what Link is holding
	ld a,(w1Link.relatedObj2+1)		; $4108
	ld h,a			; $410b
	ld e,Interaction.var3b		; $410c
	ld (de),a		; $410e

	ld l,Interaction.subid		; $410f
	ld a,(hl)		; $4111
	ld e,Interaction.var37		; $4112
	ld (de),a		; $4114

	call _shopkeeperGetItemPrice		; $4115

	ld e,Interaction.var37		; $4118
	ld a,(de)		; $411a
	call _shopkeeperCheckLinkHasItemAlready		; $411b
	ld hl,shopkeeperScript_purchaseItem		; $411e
	jp _shopkeeperLoadScript		; $4121

@holdingNothing:
	call _shopkeeperCheckAllItemsBought		; $4124
	jr nz,_shopkeeperLoadScript	; $4127

	ld e,Interaction.subid		; $4129
	ld a,(de)		; $412b
	cp $02			; $412c
	ld hl,shopkeeperScript_lynnaShopWelcome		; $412e
	jr nz,_shopkeeperLoadScript	; $4131
	ld hl,shopkeeperScript_advanceShopWelcome		; $4133


_shopkeeperLoadScript:
	ld e,Interaction.state		; $4136
	ld a,$04		; $4138
	ld (de),a		; $413a
	jp interactionSetScript		; $413b


_shopkeeperPromptChestGame:
	ld a,$0c		; $413e
	call _shopkeeperGetItemPrice		; $4140
	ld hl,shopkeeperChestGameScript		; $4143
	jr _shopkeeperLoadScript		; $4146


; State 3: ?
; State 4: Running a script (prompting whether to buy, playing chest game, etc...)
_shopkeeperState3:
_shopkeeperState4:
	ld e,Interaction.subid		; $4148
	ld a,(de)		; $414a
	and $80			; $414b
	ld a,$0c		; $414d
	call nz,_shopkeeperGetItemPrice		; $414f
	call interactionRunScript		; $4152
	ret nc			; $4155

	; Script over

	xor a			; $4156
	ld (wDisabledObjects),a		; $4157

	ld e,Interaction.var3f		; $415a
	ld a,(de)		; $415c
	or a			; $415d
	jr z,@notRing	; $415e

	ld c,a			; $4160
	xor a			; $4161
	ld (de),a		; $4162
	call getRandomRingOfGivenTier		; $4163
	ld b,c			; $4166
	ld c,$00		; $4167
	call giveRingToLink		; $4169

	ld a,$01		; $416c
	ld (wDisabledObjects),a		; $416e
	jr _shopkeeperGotoState1		; $4171

@notRing:
	; Check var3a to see what the response from the script was (purchase succeeded or
	; failed?)
	ld e,Interaction.var3a		; $4173
	ld a,(de)		; $4175
	or a			; $4176
	jr z,_shopkeeperGotoState1	; $4177

	; Set the item to state 4 to put it back (purchase failed)
	inc a			; $4179
	ld c,$04		; $417a
	jr z,@setItemState	; $417c

	; Set the item to state 3 to obtain it
	ld c,$03		; $417e
	ld a,$81		; $4180
	ld (wDisabledObjects),a		; $4182

@setItemState:
	xor a			; $4185
	ld (de),a ; [var3a] = 0

	; Set the held item's state to 'c'.
	ld e,Interaction.var3b		; $4187
	ld a,(de)		; $4189
	ld h,a			; $418a
	ld l,Interaction.state		; $418b
	ld (hl),c		; $418d
	call dropLinkHeldItem		; $418e


_shopkeeperGotoState1:
	ld e,Interaction.state		; $4191
	ld a,$01		; $4193
	ld (de),a		; $4195

	ld bc,$0614		; $4196
	call objectSetCollideRadii		; $4199

	ld e,Interaction.subid		; $419c
	ld a,(de)		; $419e
	or a			; $419f
	ld a,$03		; $41a0
	jr z,+			; $41a2
	ld a,$01		; $41a4
+
	call interactionSetAnimation		; $41a6
	ld e,Interaction.pressedAButton		; $41a9
	jp objectAddToAButtonSensitiveObjectList		; $41ab


; Playing the chest-choosing minigame. The script tends to change the state.
; It jumps to state 5, substate 0 after relinquishing control for Link to pick a chest.
; It jumps to state 5, substate 2 after relinquishing control for Link to pick a chest.
_shopkeeperState5:
	ld e,Interaction.state2		; $41ae
	ld a,(de)		; $41b0
	rst_jumpTable			; $41b1
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate0:
	ld a,$01		; $41ba
	ld (de),a		; $41bc

	; Decide which chest is the correct one
	call getRandomNumber		; $41bd
	and $01			; $41c0
	ld e,Interaction.var39		; $41c2
	ld (de),a		; $41c4

	call _shopkeeperCloseOpenedChest		; $41c5
	xor a			; $41c8
	ld ($cca2),a		; $41c9
	ld e,Interaction.var3f		; $41cc
	ld (de),a		; $41ce
	ret			; $41cf

@substate1:
	ld e,Interaction.pressedAButton		; $41d0
	ld a,(de)		; $41d2
	or a			; $41d3
	jr z,++			; $41d4

	; Talked to shopkeep
	xor a			; $41d6
	ld (de),a		; $41d7
	ld hl,shopkeeperScript_talkDuringChestGame		; $41d8
	jp _shopkeeperLoadScript		; $41db
++
	; Check if Link's opened a chest
	ld a,($cca2)		; $41de
	or a			; $41e1
	ret z			; $41e2

	ld e,Interaction.state2		; $41e3
	xor a			; $41e5
	ld (de),a		; $41e6

	ld a,TILEINDEX_CHEST		; $41e7
	call findTileInRoom		; $41e9
	ld a,($cca2)		; $41ec
	sub l			; $41ef
	rlca			; $41f0
	xor $01			; $41f1
	and $01			; $41f3
	ld h,d			; $41f5
	ld l,Interaction.var39		; $41f6
	xor (hl)		; $41f8

	ld l,Interaction.var3c		; $41f9
	jr nz,@correctChest	; $41fb

	; Wrong chest
	ld (hl),a		; $41fd
	ld hl,shopkeeperScript_openedWrongChest		; $41fe
	jp _shopkeeperLoadScript		; $4201

@correctChest:
	; Increment round (var3c)
	add (hl)		; $4204
	ld (hl),a		; $4205

	; Spawn a rupee "treasure" that doesn't actually give you anything?
	call getFreeInteractionSlot		; $4206
	ld (hl),INTERACID_TREASURE		; $4209
	ld l,Interaction.subid		; $420b
	ld (hl),TREASURE_RUPEES		; $420d
	inc l			; $420f
	ld (hl),$08		; $4210
	ld l,Interaction.var31		; $4212
	ld (hl),$03		; $4214
	ld l,Interaction.var39		; $4216
	ld (hl),$01		; $4218

	; Determine position for rupee treasure
	ld e,Interaction.var39		; $421a
	ld a,(de)		; $421c
	ld bc,_shopkeeperChestXPositions		; $421d
	call addAToBc		; $4220
	ld l,Interaction.yh		; $4223
	ld (hl),$20		; $4225
	ld l,Interaction.xh		; $4227
	ld a,(bc)		; $4229
	ld (hl),a		; $422a

	ld hl,shopkeeperScript_openedCorrectChest		; $422b
	jp _shopkeeperLoadScript		; $422e

@substate2:
	; Close the chest that the shopkeeper is facing toward.
	ld e,Interaction.angle		; $4231
	ld a,(de)		; $4233
	swap a			; $4234
	and $01			; $4236
	ld h,d			; $4238
	ld l,Interaction.var39		; $4239
	xor (hl)		; $423b
	jr nz,@substate3	; $423c

	call _shopkeeperCloseOpenedChest		; $423e
	ld e,Interaction.state2		; $4241
	ld a,$03		; $4243
	ld (de),a		; $4245

@substate3:
	call interactionRunScript		; $4246
	ret nc			; $4249

	ld e,Interaction.state2		; $424a
	xor a			; $424c
	ld (de),a		; $424d

;;
; @param	a	Item index?
; @addr{424e}
_shopkeeperGetItemPrice:
	ld hl,_shopItemPrices		; $424e
	rst_addAToHl			; $4251
	ld a,(hl)		; $4252
	call cpRupeeValue		; $4253
	ld (wShopHaveEnoughRupees),a		; $4256
	ld ($cbad),a		; $4259
	ld hl,wTextNumberSubstitution		; $425c
	ld (hl),c		; $425f
	inc l			; $4260
	ld (hl),b		; $4261
	ret			; $4262

;;
; @addr{4263}
_shopkeeperCloseOpenedChest:
	ld a,($cca2)		; $4263
	bit 7,a			; $4266
	ld c,a			; $4268
	ld a,TILEINDEX_CHEST		; $4269
	jp z,setTile		; $426b
	ret			; $426e

;;
; Sets var38 to nonzero if Link already has this item, or already has the maximum amount
; he can carry.
;
; @param	a	Item index
; @addr{426f}
_shopkeeperCheckLinkHasItemAlready:
	ld b,a			; $426f
	xor a			; $4270
	ld e,Interaction.var38		; $4271
	ld (de),a		; $4273
	ld e,Interaction.subid		; $4274
	ld a,(de)		; $4276
	ld e,Interaction.var38		; $4277
	or a			; $4279
	ret nz			; $427a

	ld h,>wc600Block		; $427b
	ld a,b			; $427d
	cp $13			; $427e
	ret z			; $4280

	cp $03			; $4281
	jr z,@shield	; $4283
	cp $11			; $4285
	jr z,@shield	; $4287
	cp $12			; $4289
	jr z,@shield	; $428b

	cp $0d			; $428d
	jr z,@flute	; $428f

	ld l,<wNumBombs		; $4291
	cp $04			; $4293
	jr z,+			; $4295

	ld l,<wLinkHealth		; $4297
+
	ldi a,(hl)		; $4299
	cp (hl)			; $429a
	ret nz			; $429b

@cantSell:
	ld a,$01		; $429c
	ld (de),a		; $429e
	ret			; $429f

@shield:
	ld a,TREASURE_SHIELD		; $42a0
	jr @checkObtained		; $42a2

@flute:
	ld a,TREASURE_FLUTE		; $42a4

@checkObtained:
	call checkTreasureObtained		; $42a6
	ld e,Interaction.var38		; $42a9
	ret nc			; $42ab
	jr @cantSell		; $42ac

;;
; @param[out]	hl	Script to run if no shop items exist
; @param[out]	zflag	Set if at least one shop item exists
; @addr{42ae}
_shopkeeperCheckAllItemsBought:
	ldhl FIRST_DYNAMIC_INTERACTION_INDEX, Interaction.enabled		; $42ae
---
	ld l,Interaction.enabled		; $42b1
	ldi a,(hl)		; $42b3
	or a			; $42b4
	jr z,@next		; $42b5
	ld a,(hl)		; $42b7
	cp INTERACID_SHOP_ITEM			; $42b8
	ret z			; $42ba
@next:
	inc h			; $42bb
	ld a,h			; $42bc
	cp LAST_INTERACTION_INDEX+1			; $42bd
	jr c,---		; $42bf

	ld hl,shopkeeperScript_boughtEverything		; $42c1
	or d			; $42c4
	ret			; $42c5

_shopkeeperTurnToFaceLink:
	call objectGetAngleTowardLink		; $42c6
	ld e,Interaction.angle		; $42c9
	ld (de),a		; $42cb
	call convertAngleDeToDirection		; $42cc
	dec e			; $42cf
	ld (de),a		; $42d0
	jp interactionSetAnimation		; $42d1


_shopkeeperTheftPreventionScriptTable:
	.dw shopkeeperSubid0Script_stopLink
	.dw shopkeeperSubid1Script_stopLink
	.dw shopkeeperSubid2Script_stopLink


; X positions of the chests in the chest minigame (used for spawning rupee "prizes")
_shopkeeperChestXPositions:
	.db $78, $58


; ==============================================================================
; INTERACID_SHOP_ITEM
;
; Variables:
;   var30/31: Y/X position where the item rests in the selection area
; ==============================================================================
interactionCode47:
	ld e,Interaction.state		; $42dc
	ld a,(de)		; $42de
	rst_jumpTable			; $42df
	.dw _shopItemState0
	.dw objectAddToGrabbableObjectBuffer
	.dw _shopItemState2
	.dw _shopItemState3
	.dw _shopItemState4
	.dw _shopItemState5


_shopItemState0:
	; Check that we're actually in a shop
	ld a,(wInShop)		; $42ec
	and $02			; $42ef
	ret z			; $42f1

	ld a,$01		; $42f2
	ld (de),a		; $42f4

	; If this is the ring box upgrade, check whether to change it to the L3 box
	ld e,Interaction.subid		; $42f5
	ld a,(de)		; $42f7
	cp $00			; $42f8
	jr nz,++		; $42fa

	ld a,TREASURE_RING_BOX		; $42fc
	call checkTreasureObtained		; $42fe
	jr nc,++		; $4301

	ld a,(wRingBoxLevel)		; $4303
	dec a			; $4306
	jr z,++		; $4307
	ld a,$14		; $4309
	ld (de),a		; $430b
++
	; If this is 10 bombs, delete self if Link doesn't have bombs
	ld a,(de)		; $430c
	cp $04			; $430d
	jr nz,++		; $430f
	ld a,TREASURE_BOMBS		; $4311
	call checkTreasureObtained		; $4313
	jp nc,_shopItemPopStackAndDeleteSelf		; $4316
	jr @checkFlutePurchasable		; $4319
++
	; If this is the shield, check whether to replace it with a gasha seed (linked)
	cp $03			; $431b
	jr nz,@checkFlutePurchasable	; $431d
	call checkIsLinkedGame		; $431f
	jr z,@checkFlutePurchasable	; $4322

	; Replace with gasha seed
	ld a,$13		; $4324
	ld (de),a		; $4326

@checkFlutePurchasable:
	; Decide whether the flute is purchasable (update bit 3 of wBoughtShopItems2)
	ld a,TREASURE_FLUTE		; $4327
	call checkTreasureObtained		; $4329
	jr c,@fluteNotPurchasable	; $432c

	ld a,GLOBALFLAG_CAN_BUY_FLUTE		; $432e
	call checkGlobalFlag		; $4330
	jr z,@fluteNotPurchasable	; $4333

	; Flute purchasable
	ld c,$08		; $4335
	jr ++			; $4337

@fluteNotPurchasable:
	ld c,$00		; $4339
++
	ld a,(wBoughtShopItems2)		; $433b
	and $f7			; $433e
	or c			; $4340
	ld (wBoughtShopItems2),a		; $4341

	; Update bits in wBoughtShopItems2 based on if Link has bombchus?
	ld a,TREASURE_BOMBCHUS		; $4344
	call checkTreasureObtained		; $4346
	ld c,$10		; $4349
	jr c,+			; $434b
	ld c,$20		; $434d
+
	ld a,(wBoughtShopItems2)		; $434f
	and $cf			; $4352
	or c			; $4354
	ld (wBoughtShopItems2),a		; $4355

	; Check whether the item can be sold by reading from "_shopItemReplacementTable".
	; This checks for particular bits in memory to see if an item is purchasable. If
	; it's not, it may be replaced with a different item.
@checkReplaceItem:
	ld e,Interaction.subid		; $4358
	ld a,(de)		; $435a
	add a			; $435b
	ld hl,_shopItemReplacementTable		; $435c
	rst_addDoubleIndex			; $435f

	; Check the bit in memory stating if the item should be replaced with another
	ldi a,(hl)		; $4360
	ld c,a			; $4361
	ld b,>wc600Block		; $4362
	ld a,(bc)		; $4364
	and (hl)		; $4365
	jr z,@itemOK		; $4366

	; The item should be replaced. Check if the next byte is a valid item index.
	inc hl			; $4368
	ldi a,(hl)		; $4369
	bit 7,a			; $436a
	jr nz,_shopItemPopStackAndDeleteSelf	; $436c

	; Try this item. Need to run the above checks again.
	ld (de),a		; $436e
	ld e,Interaction.xh		; $436f
	ld a,(de)		; $4371
	add (hl)		; $4372
	ld (de),a		; $4373
	jr @checkReplaceItem		; $4374

@itemOK:
	call interactionInitGraphics		; $4376
	ld a,$07		; $4379
	call objectSetCollideRadius		; $437b

	ld l,Interaction.var30		; $437e
	ld e,Interaction.yh		; $4380
	ld a,(de)		; $4382
	ldi (hl),a		; $4383
	ld e,Interaction.xh		; $4384
	ld a,(de)		; $4386
	ldi (hl),a		; $4387

	call objectSetVisible83		; $4388
	jr _shopItemUpdateRupeeDisplay		; $438b

_shopItemState5:
	call retIfTextIsActive		; $438d
	xor a			; $4390
	ld (wDisabledObjects),a		; $4391
	ld (wMenuDisabled),a		; $4394


;;
; The fact that this pops the stack means that it will return one level higher than it's
; supposed to? This ultimately isn't a big deal, it just means that other interactions
; won't be updated until next frame, but it's probably unintentional...
; @addr{4397}
_shopItemPopStackAndDeleteSelf:
	pop af			; $4397
	jp interactionDelete		; $4398


; State 2: item picked up by Link
_shopItemState2:
	ld e,Interaction.state2		; $439b
	ld a,(de)		; $439d
	rst_jumpTable			; $439e
	.dw @substate0
	.dw @substate1

@substate0:
	ld a,$01		; $43a3
	ld (de),a		; $43a5

	; Item should be fully lifted instantly
	ld a,$08		; $43a6
	ld (wLinkGrabState2),a		; $43a8

	call objectSetVisible80		; $43ab
	jr _shopItemClearRupeeDisplay		; $43ae

@substate1:
	call _shopItemCheckGrabbed		; $43b0
	ret nz			; $43b3

	; Fall through to state 4 if Link pressed the button near the selection area


; State 4: Return to selection area
_shopItemState4:
	; Set Y/X to selection area
	ld h,d			; $43b4
	ld e,Interaction.yh		; $43b5
	ld l,Interaction.var30		; $43b7
	ldi a,(hl)		; $43b9
	ld (de),a		; $43ba
	ld e,Interaction.xh		; $43bb
	ld a,(hl)		; $43bd
	ld (de),a		; $43be

	ld l,Interaction.zh		; $43bf
	ld (hl),$00		; $43c1

	ld l,Interaction.state		; $43c3
	ld (hl),$01		; $43c5

	call _shopItemUpdateRupeeDisplay		; $43c7
	call objectSetVisible83		; $43ca
	jp dropLinkHeldItem		; $43cd

;;
; Clears the tiles in w3VramLayout corresponding to item price, and sets bit 2 of wInShop
; in order to request a tilemap update.
;
; @addr{43d0}
_shopItemClearRupeeDisplay:
	call _shopItemGetTilesForRupeeDisplay		; $43d0
	ret nc			; $43d3

	; Replace the tiles generated by above function call with spaces
	push hl			; $43d4
	ld a,$03		; $43d5
	rst_addAToHl			; $43d7
	ld a,$20		; $43d8
	ldi (hl),a		; $43da
	inc l			; $43db
	ldi (hl),a		; $43dc
	inc l			; $43dd
	ldi (hl),a		; $43de
	pop hl			; $43df
	jr ++		; $43e0

;;
; Updates the tiles in w3VramLayout corresponding to item price, and sets bit 2 of wInShop
; in order to request a tilemap update.
;
; @addr{43e2}
_shopItemUpdateRupeeDisplay:
	call _shopItemGetTilesForRupeeDisplay		; $43e2
	ret nc			; $43e5
++
	ld a,($ff00+R_SVBK)	; $43e6
	push af			; $43e8
	ld a,:w3VramTiles		; $43e9
	ld ($ff00+R_SVBK),a	; $43eb
	push de			; $43ed
	ldi a,(hl)		; $43ee
	ld e,a			; $43ef
	ldi a,(hl)		; $43f0
	ld d,a			; $43f1
	ldi a,(hl)		; $43f2
	ld b,a			; $43f3

@nextTile:
	ldi a,(hl)		; $43f4
	ld (de),a		; $43f5
	set 2,d			; $43f6
	ldi a,(hl)		; $43f8
	ld (de),a		; $43f9
	res 2,d			; $43fa
	inc de			; $43fc
	dec b			; $43fd
	jr nz,@nextTile	; $43fe

	pop de			; $4400
	pop af			; $4401
	ld ($ff00+R_SVBK),a	; $4402
	ld hl,wInShop		; $4404
	set 2,(hl)		; $4407
	ret			; $4409


; State 3: Link obtains the item (he just bought it, the shopkeeper set the state to this)
_shopItemState3:
	; Take rupees
	ld e,Interaction.subid		; $440a
	ld a,(de)		; $440c
	ld hl,_shopItemPrices		; $440d
	rst_addAToHl			; $4410
	ldi a,(hl)		; $4411
	call removeRupeeValue		; $4412

	; Determine what the treasure is, give it to him
	ld e,Interaction.subid		; $4415
	ld a,(de)		; $4417
	ld hl,shopItemTreasureToGive		; $4418
	rst_addDoubleIndex			; $441b
	ldi a,(hl)		; $441c
	ld c,(hl)		; $441d
	cp $00			; $441e
	jr nz,+			; $4420
	call getRandomRingOfGivenTier		; $4422
+
	call giveTreasure		; $4425

	ld e,Interaction.state		; $4428
	ld a,$05		; $442a
	ld (de),a		; $442c

	ld a,LINK_STATE_04		; $442d
	ld (wLinkForceState),a		; $442f
	ld a,$01		; $4432
	ld (wcc50),a		; $4434

	; Show text for the item
	ld e,Interaction.subid		; $4437
	ld a,(de)		; $4439
	ld hl,_shopItemTextTable		; $443a
	rst_addAToHl			; $443d
	ld a,(hl)		; $443e
	ld c,a			; $443f
	or a			; $4440
	ld b,>TX_0000		; $4441
	jp nz,showText		; $4443
	ret			; $4446

;;
; Gets the tiles to replace in the rupee display.
;
; @param[out]	hl	Pointer to tile data (always at wTmpcec0). Data format:
;			* Destination in w3VramTiles to write to (word)
;			* Number of tiles to write (byte)
;			* For each tile:
;				* Tile index (byte)
;				* Tile attribute (byte
; @param[out]	cflag	nc if nothing to do?
; @addr{4447}
_shopItemGetTilesForRupeeDisplay:
	ld e,Interaction.subid		; $4447
	ld a,(de)		; $4449
	ld c,a			; $444a
	ld hl,@itemPricePositions		; $444b
	rst_addDoubleIndex			; $444e
	ldi a,(hl)		; $444f
	cp $ff			; $4450
	ret z			; $4452

	push de			; $4453
	ld e,a			; $4454
	ld d,(hl)		; $4455

	ld a,c			; $4456
	ld hl,_shopItemPrices		; $4457
	rst_addAToHl			; $445a
	ld a,(hl)		; $445b
	call getRupeeValue		; $445c

	ld hl,wTmpcec0		; $445f
	ld (hl),e		; $4462
	inc l			; $4463
	ld (hl),d		; $4464
	inc l			; $4465

	ld e,$06 ; Attribute value to use
	ld d,$30 ; Tile index "base" (digit 0 is tile $30)
	ld a,$02 ; Number of tiles to write
	ldi (hl),a		; $446c
	ld a,b			; $446d
	or a			; $446e
	jr z,+			; $446f

	; If this is a 3 digit number, go back, increment the size, and draw the first
	; digit.
	dec l			; $4471
	inc (hl)		; $4472
	inc l			; $4473
	call @drawDigit		; $4474
+
	ld a,c			; $4477
	swap a			; $4478
	call @drawDigit		; $447a

	ld a,c			; $447d
	call @drawDigit		; $447e

	ld hl,wTmpcec0		; $4481
	pop de			; $4484
	scf			; $4485
	ret			; $4486

@drawDigit:
	and $0f			; $4487
	add d			; $4489
	ldi (hl),a		; $448a
	ld (hl),e		; $448b
	inc l			; $448c
	ret			; $448d

@itemPricePositions:
	.dw w3VramTiles+$66
	.dw w3VramTiles+$6f
	.dw w3VramTiles+$6a
	.dw w3VramTiles+$6c
	.dw w3VramTiles+$69
	.dw w3VramTiles+$6e
	.dw w3VramTiles+$6a
	.dw w3VramTiles+$68
	.dw w3VramTiles+$6d
	.dw w3VramTiles+$6b
	.dw w3VramTiles+$6f
	.dw w3VramTiles+$67
	.dw $ffff
	.dw w3VramTiles+$6f
	.dw w3VramTiles+$67
	.dw w3VramTiles+$6b
	.dw w3VramTiles+$6f
	.dw w3VramTiles+$6c
	.dw w3VramTiles+$6c
	.dw w3VramTiles+$6c
	.dw w3VramTiles+$66
	.dw w3VramTiles+$6e

_shopItemPrices:
	/* $00 */ .db RUPEEVAL_300
	/* $01 */ .db RUPEEVAL_010
	/* $02 */ .db RUPEEVAL_300
	/* $03 */ .db RUPEEVAL_030
	/* $04 */ .db RUPEEVAL_020
	/* $05 */ .db RUPEEVAL_300
	/* $06 */ .db RUPEEVAL_500
	/* $07 */ .db RUPEEVAL_300
	/* $08 */ .db RUPEEVAL_300
	/* $09 */ .db RUPEEVAL_300
	/* $0a */ .db RUPEEVAL_300
	/* $0b */ .db RUPEEVAL_100
	/* $0c */ .db RUPEEVAL_010
	/* $0d */ .db RUPEEVAL_150
	/* $0e */ .db RUPEEVAL_100
	/* $0f */ .db RUPEEVAL_100
	/* $10 */ .db RUPEEVAL_100
	/* $11 */ .db RUPEEVAL_050
	/* $12 */ .db RUPEEVAL_080
	/* $13 */ .db RUPEEVAL_030
	/* $14 */ .db RUPEEVAL_300
	/* $15 */ .db RUPEEVAL_500

;;
; @param[out]	zflag	z if Link should grab or release the item
; @addr{44d0}
_shopItemCheckGrabbed:
	ld a,(wGameKeysJustPressed)		; $44d0
	and (BTN_A|BTN_B)			; $44d3
	jr z,@dontGrab		; $44d5

	; Check Link's close enough to the selection area (horizontally)
	ld e,Interaction.var31		; $44d7
	ld a,(de)		; $44d9
	sub $0d			; $44da
	ld b,a			; $44dc
	add $1a			; $44dd
	ld hl,w1Link.xh		; $44df
	cp (hl)			; $44e2
	jr c,@dontGrab		; $44e3

	ld a,b			; $44e5
	cp (hl)			; $44e6
	jr nc,@dontGrab		; $44e7

	; Check Link's close enough to the selection area (vertically)
	ld l,<w1Link.yh		; $44e9
	ld a,(hl)		; $44eb
	cp $3d			; $44ec
	jr nc,@dontGrab		; $44ee

	; Check that Link's facing the selection area (DIR_UP)
	ld l,<w1Link.direction		; $44f0
	ld a,(hl)		; $44f2
	or a			; $44f3
	ret			; $44f4

@dontGrab:
	or d			; $44f5
	ret			; $44f6


; These are the treasures that Link receives when he buys a shop item.
;   b0: Treasure index to give (if $00, it's a random ring)
;   b1: Treasure parameter (if it's random ring, this is the tier of the ring)
shopItemTreasureToGive:
	/* $00 */ .db  TREASURE_RING_BOX      $02
	/* $01 */ .db  TREASURE_HEART_REFILL  $0c
	/* $02 */ .db  TREASURE_GASHA_SEED    $01
	/* $03 */ .db  TREASURE_SHIELD        $01
	/* $04 */ .db  TREASURE_BOMBS         $10
	/* $05 */ .db  $00                    $03
	/* $06 */ .db  TREASURE_GASHA_SEED    $01
	/* $07 */ .db  TREASURE_POTION        $01
	/* $08 */ .db  TREASURE_GASHA_SEED    $01
	/* $09 */ .db  TREASURE_POTION        $01
	/* $0a */ .db  TREASURE_GASHA_SEED    $01
	/* $0b */ .db  TREASURE_BOMBCHUS      $05
	/* $0c */ .db  $00                    $00
	/* $0d */ .db  TREASURE_FLUTE         SPECIALOBJECTID_DIMITRI
	/* $0e */ .db  TREASURE_GASHA_SEED    $01
	/* $0f */ .db  TREASURE_RING          GBA_TIME_RING
	/* $10 */ .db  $00                    $01
	/* $11 */ .db  TREASURE_SHIELD        $02
	/* $12 */ .db  TREASURE_SHIELD        $03
	/* $13 */ .db  TREASURE_GASHA_SEED    $01
	/* $14 */ .db  TREASURE_RING_BOX      $03
	/* $15 */ .db  TREASURE_HEART_PIECE   $01


; This lists conditions where a shop item may be replaced with something else.
;   b0: Low byte of an address in $c6xx block
;   b1: Bitmask to check at that address. If result is 0, the item can be sold.
;       If the result is nonzero, a different item is sold instead based on b2.
;   b2: Item to sell if the first one is unavailable (or $ff to sell nothing)
;   b3: Value to add to x position if the first item was sold out
_shopItemReplacementTable:
	/* $00 */ .db <wBoughtShopItems1  $01 $ff $00
	/* $01 */ .db <wBoughtShopItems2  $08 $0d $04
	/* $02 */ .db <wBoughtShopItems1  $02 $06 $00
	/* $03 */ .db <wShieldLevel       $02 $11 $00
	/* $04 */ .db <wBoughtShopItems1  $00 $ff $00
	/* $05 */ .db <wBoughtShopItems1  $08 $ff $00
	/* $06 */ .db <wBoughtShopItems1  $04 $ff $00
	/* $07 */ .db <wBoughtShopItems2  $10 $09 $18
	/* $08 */ .db <wBoughtShopItems2  $10 $0a $10
	/* $09 */ .db <wBoughtShopItems1  $00 $ff $00
	/* $0a */ .db <wBoughtShopItems1  $40 $ff $00
	/* $0b */ .db <wBoughtShopItems2  $20 $ff $00
	/* $0c */ .db <wBoughtShopItems1  $00 $ff $00
	/* $0d */ .db <wBoughtShopItems2  $00 $ff $00
	/* $0e */ .db <wBoughtShopItems2  $01 $ff $00
	/* $0f */ .db <wBoughtShopItems2  $02 $ff $00
	/* $10 */ .db <wBoughtShopItems2  $04 $ff $00
	/* $11 */ .db <wShieldLevel       $01 $12 $00
	/* $12 */ .db <wShieldLevel       $00 $ff $00
	/* $13 */ .db <wBoughtShopItems1  $20 $03 $00
	/* $14 */ .db <wBoughtShopItems1  $01 $ff $00
	/* $15 */ .db <wBoughtShopItems2  $40 $05 $00


; Text to show upon buying a shop item (or $00 for no text)
_shopItemTextTable:
	/* $00 */ .db <TX_0058
	/* $01 */ .db <TX_004c
	/* $02 */ .db <TX_004b
	/* $03 */ .db <TX_001f
	/* $04 */ .db <TX_004d
	/* $05 */ .db <TX_0054
	/* $06 */ .db <TX_004b
	/* $07 */ .db <TX_006d
	/* $08 */ .db <TX_004b
	/* $09 */ .db <TX_006d
	/* $0a */ .db <TX_004b
	/* $0b */ .db <TX_0032
	/* $0c */ .db $00
	/* $0d */ .db <TX_003b
	/* $0e */ .db <TX_004b
	/* $0f */ .db <TX_0054
	/* $10 */ .db <TX_0054
	/* $11 */ .db <TX_0020
	/* $12 */ .db <TX_0021
	/* $13 */ .db <TX_004b
	/* $14 */ .db <TX_0059
	/* $15 */ .db <TX_0017


; ==============================================================================
; INTERACID_INTRO_SPRITES_1
; ==============================================================================
interactionCode4a:
	ld e,Interaction.state		; $4591
	ld a,(de)		; $4593
	rst_jumpTable			; $4594
	.dw @state0
	.dw _introSpritesState1

@state0:
	call _introSpriteIncStateAndLoadGraphics		; $4599
	ld e,$42		; $459c
	ld a,(de)		; $459e
	rst_jumpTable			; $459f
	.dw @initSubid00
	.dw @initSubid01
	.dw @initSubid02
	.dw @initSubid03
	.dw @initSubid04
	.dw _introSpriteIncStateAndLoadGraphics
	.dw _introSpriteIncStateAndLoadGraphics
	.dw @initSubid07
	.dw objectSetVisible82
	.dw @initSubid09
	.dw @initSubid0a


; Triforce pieces
@initSubid00:
@initSubid01:
@initSubid02:
	call getFreeInteractionSlot		; $45b6
	jr nz,++		; $45b9

	; Create the "glow" behind the triforce
	ld (hl),INTERACID_INTRO_SPRITES_1		; $45bb
	inc l			; $45bd
	ld (hl),$04		; $45be
	inc l			; $45c0
	ld e,Interaction.subid		; $45c1
	ld a,(de)		; $45c3
	inc a			; $45c4
	ld (hl),a		; $45c5
	call _introSpriteSetChildRelatedObject1ToSelf		; $45c6
++
	jp objectSetVisible82		; $45c9

@initSubid03:
@initSubid07:
@initSubid0a:
	ld e,Interaction.var03		; $45cc
	ld a,(de)		; $45ce
	add a			; $45cf
	add a			; $45d0
	ld h,d			; $45d1
	ld l,Interaction.animCounter		; $45d2
	add (hl)		; $45d4
	ld (hl),a		; $45d5

	call interactionSetAlwaysUpdateBit		; $45d6
	call _introSpriteFunc_461a		; $45d9
	jp objectSetVisible80		; $45dc

@initSubid09:
	ld e,Interaction.var03		; $45df
	ld a,(de)		; $45e1
	ld hl,@data		; $45e2
	rst_addDoubleIndex			; $45e5
	ldi a,(hl)		; $45e6
	ld e,Interaction.yh		; $45e7
	ld (de),a		; $45e9
	inc e			; $45ea
	inc e			; $45eb
	ld a,(hl)		; $45ec
	ld (de),a		; $45ed
	ld b,$03		; $45ee
--
	call getFreeInteractionSlot		; $45f0
	jr nz,++		; $45f3

	ld (hl),INTERACID_INTRO_SPRITES_1		; $45f5
	inc l			; $45f7
	ld (hl),$0a		; $45f8
	inc l			; $45fa
	ld (hl),b		; $45fb
	dec (hl)		; $45fc
	call _introSpriteSetChildRelatedObject1ToSelf		; $45fd
	dec b			; $4600
	jr nz,--		; $4601
++
	jp objectSetVisible82		; $4603

@data:
	.db $40 $78
	.db $40 $48
	.db $18 $60

@initSubid04:
	call objectSetVisible83		; $460c
	xor $80			; $460f
	ld (de),a		; $4611
	ret			; $4612

;;
; @addr{4613}
_introSpriteIncStateAndLoadGraphics:
	ld h,d			; $4613
	ld l,Interaction.state		; $4614
	inc (hl)		; $4616
	jp interactionInitGraphics		; $4617

;;
; Sets up X and Y positions with some slight random variance?
; @addr{461a}
_introSpriteFunc_461a:
	call objectGetRelatedObject1Var		; $461a
	call objectTakePosition		; $461d
	push bc			; $4620
	ld e,Interaction.subid		; $4621
	ld a,(de)		; $4623
	ld hl,@data_4660		; $4624
	cp $03			; $4627
	jr z,@label_09_043	; $4629
	cp $0a			; $462b
	jr z,@label_09_043	; $462d

	ld hl,@data_4666		; $462f
	ld e,Interaction.counter2		; $4632
	ld a,(de)		; $4634
	inc a			; $4635
	ld (de),a		; $4636
	and $03			; $4637
	ld c,a			; $4639
	add a			; $463a
	add c			; $463b
	rst_addDoubleIndex			; $463c

@label_09_043:
	ld e,Interaction.var03		; $463d
	ld a,(de)		; $463f
	rst_addDoubleIndex			; $4640

	ldi a,(hl)		; $4641
	call @addRandomVariance		; $4642
	ld b,a			; $4645
	ld e,Interaction.yh		; $4646
	ld a,(de)		; $4648
	add b			; $4649
	ld (de),a		; $464a

	ld a,(hl)		; $464b
	call @addRandomVariance		; $464c
	ld h,d			; $464f
	ld l,Interaction.xh		; $4650
	add (hl)		; $4652
	ld (hl),a		; $4653
	pop bc			; $4654
	ret			; $4655

; Adds a random value between -2 and +1 to the given number.
@addRandomVariance:
	ld b,a			; $4656
	call getRandomNumber		; $4657
	and $03			; $465a
	sub $02			; $465c
	add b			; $465e
	ret			; $465f

@data_4660:
	.db $fc $fc
	.db $07 $ff
	.db $ff $06

@data_4666:
	.db $f4 $f4
	.db $0e $fe
	.db $fa $09

	.db $fb $f0
	.db $09 $ff
	.db $04 $0e

	.db $06 $f8
	.db $f4 $08
	.db $0a $07

	.db $0b $fa
	.db $f4 $00
	.db $03 $0a


;;
; @addr{467e}
_introSpritesState1:
	ld e,Interaction.subid		; $467e
	ld a,(de)		; $4680
	cp $05			; $4681
	jr nc,++		; $4683

	; For subids 0-4 (triforce objects): watch for signal to delete self
	ld a,(wIntro.triforceState)		; $4685
	cp $04			; $4688
	jp z,interactionDelete		; $468a
++
	ld a,(de)		; $468d
	rst_jumpTable			; $468e
	.dw _introSpriteTriforceSubid
	.dw _introSpriteTriforceSubid
	.dw _introSpriteTriforceSubid
	.dw _introSpriteRunTriforceGlowSubid
	.dw _introSpriteRunSubid04
	.dw _introSpriteRunSubid05
	.dw _introSpriteRunSubid06
	.dw _introSpriteRunSubid07
	.dw _introSpriteRunSubid08
	.dw interactionAnimate
	.dw _introSpriteRunTriforceGlowSubid


; Triforce pieces
_introSpriteTriforceSubid:
	ld e,Interaction.state2		; $46a5
	ld a,(de)		; $46a7
	rst_jumpTable			; $46a8
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4
	.dw interactionAnimate

@substate0:
	ld a,(wIntro.triforceState)		; $46b5
	cp $01			; $46b8
	jp nz,interactionAnimate	; $46ba

	ld b,$00		; $46bd
	ld e,Interaction.subid		; $46bf
	ld a,(de)		; $46c1
	cp $01			; $46c2
	jr z,+			; $46c4
	ld b,$0a		; $46c6
+
	call func_2d48		; $46c8
	call interactionIncState2		; $46cb
	ld l,Interaction.counter1		; $46ce
	ld (hl),b		; $46d0

@substate1:
	call interactionDecCounter1		; $46d1
	jp nz,interactionAnimate		; $46d4

	ld l,Interaction.subid		; $46d7
	ld a,(hl)		; $46d9
	cp $01			; $46da
	jr nz,@centerTriforcePiece	; $46dc
	ld l,Interaction.angle		; $46de
	ld (hl),$00		; $46e0
	ld l,Interaction.speed		; $46e2
	ld (hl),SPEED_20		; $46e4
	ld b,$01		; $46e6
	jr @label_09_048		; $46e8

@centerTriforcePiece:
	or a			; $46ea
	ld a,$18		; $46eb
	jr z,+			; $46ed
	ld a,$08		; $46ef
+
	ld l,Interaction.angle		; $46f1
	ld (hl),a		; $46f3
	ld l,Interaction.speed		; $46f4
	ld (hl),SPEED_20		; $46f6
	ld b,$0b		; $46f8

@label_09_048:
	call func_2d48		; $46fa
	call interactionIncState2		; $46fd
	ld l,Interaction.counter1		; $4700
	ld (hl),b		; $4702

@substate2:
	call interactionDecCounter1		; $4703
	jr nz,++		; $4706

	ld b,$02		; $4708
	call func_2d48		; $470a
	call interactionIncState2		; $470d
	ld l,Interaction.counter1		; $4710
	ld (hl),b		; $4712
++
	call objectApplySpeed		; $4713
	jp interactionAnimate		; $4716

@substate3:
	call interactionDecCounter1		; $4719
	jp nz,interactionAnimate		; $471c

	ld b,$03		; $471f
	call func_2d48		; $4721
	call interactionIncState2		; $4724
	ld l,Interaction.counter1		; $4727
	ld (hl),b		; $4729

	ld e,Interaction.subid		; $472a
	ld a,(de)		; $472c
	cp $01			; $472d
	jr z,+			; $472f

	jp interactionIncState2		; $4731
+
	ld a,SND_ENERGYTHING		; $4734
	jp playSound		; $4736

@substate4:
	call interactionAnimate		; $4739
	call interactionDecCounter1		; $473c
	ret nz			; $473f

	call interactionIncState2		; $4740
	ld a,$02		; $4743
	ld (wIntro.triforceState),a		; $4745

	ld a,SND_AQUAMENTUS_HOVER		; $4748
	jp playSound		; $474a


_introSpriteRunSubid07:
	call objectSetVisible		; $474d
	ld e,Interaction.var03		; $4750
	ld a,(de)		; $4752
	and $01			; $4753
	ld b,a			; $4755
	ld a,(wIntro.frameCounter)		; $4756
	and $01			; $4759
	xor b			; $475b
	call z,objectSetInvisible		; $475c

_introSpriteRunTriforceGlowSubid:
	ld e,Interaction.animParameter		; $475f
	ld a,(de)		; $4761
	inc a			; $4762
	call z,_introSpriteFunc_461a		; $4763
	jp interactionAnimate		; $4766

_introSpriteRunSubid04:
_introSpriteRunSubid05:
_introSpriteRunSubid06:
	call interactionAnimate		; $4769

	ld a,Object.start		; $476c
	call objectGetRelatedObject1Var		; $476e
	call objectTakePosition		; $4771
	ld e,Interaction.var03		; $4774
	ld a,(de)		; $4776
	ld h,d			; $4777
	ld l,Interaction.animCounter		; $4778
	cp (hl)			; $477a
	ld l,Interaction.visible		; $477b
	jr nz,++		; $477d

	set 7,(hl)		; $477f
	ret			; $4781
++
	res 7,(hl)		; $4782
	ret			; $4784


; Extra tree branches in intro
_introSpriteRunSubid08:
	ld a,(wGfxRegs1.SCY)		; $4785
	or a			; $4788
	jp z,interactionDelete		; $4789

	ld b,a			; $478c
	ld e,Interaction.y		; $478d
	ld a,(de)		; $478f
	sub b			; $4790
	inc e			; $4791
	ld (de),a		; $4792
	ret			; $4793

;;
; Sets relatedObj1 of object 'h' to object 'd' (self).
; @addr{4794}
_introSpriteSetChildRelatedObject1ToSelf:
	ld l,Interaction.relatedObj1		; $4794
	ld (hl),Interaction.start		; $4796
	inc l			; $4798
	ld (hl),d		; $4799
	ret			; $479a


; ==============================================================================
; Unused, unreferenced "Fairy" interaction from Seasons that resides in each of the season
; temples
; ==============================================================================
unusedInteraction:
	ld e,Interaction.state		; $479b
	ld a,(de)		; $479d
	rst_jumpTable			; $479e
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3
	.dw @state4
	.dw @state5

@state0:
	ld e,Interaction.state2		; $47ab
	ld a,(de)		; $47ad
	rst_jumpTable			; $47ae
	.dw @@substate0
	.dw @@substate1
	.dw @@substate2

@@substate0:
	call interactionSetAlwaysUpdateBit		; $47b5

	ld l,Interaction.state2		; $47b8
	ld (hl),$01		; $47ba
	ld l,Interaction.counter1		; $47bc
	ld (hl),$01		; $47be
	ld l,Interaction.zh		; $47c0
	ld (hl),$00		; $47c2

	ld a,MUS_FAIRY		; $47c4
	ld (wActiveMusic),a		; $47c6
	jp playSound		; $47c9

@@substate1:
	call interactionDecCounter1		; $47cc
	ret nz			; $47cf

	ld l,Interaction.state2		; $47d0
	ld (hl),$02		; $47d2
	ld l,Interaction.counter1		; $47d4
	ld (hl),$10		; $47d6
	jr @createPuff		; $47d8

@@substate2:
	call interactionDecCounter1		; $47da
	ret nz			; $47dd

	call interactionInitGraphics		; $47de
	call objectSetVisible80		; $47e1

	ld h,d			; $47e4
	ld l,Interaction.state		; $47e5
	ld (hl),$01		; $47e7
	ld l,Interaction.state2		; $47e9
	ld (hl),$00		; $47eb

	ld l,Interaction.var03		; $47ed
	ld a,(hl)		; $47ef
	or a			; $47f0
	jr nz,++		; $47f1

	ld l,Interaction.counter1		; $47f3
	ld (hl),120		; $47f5
	call @createSparkle0		; $47f7
	jp @updateAnimation		; $47fa
++
	ld l,Interaction.counter1		; $47fd
	ld (hl),60		; $47ff
	call @createSparkle1		; $4801
	jp @updateAnimation		; $4804


@createPuff:
	jp objectCreatePuff		; $4807

@createSparkle0:
	ld bc,$8400		; $480a
	jr @createInteraction		; $480d

@createSparkle1:
	ldbc INTERACID_SPARKLE,$07		; $480f
	call objectCreateInteraction		; $4812
	ld e,Interaction.counter1		; $4815
	ld a,(de)		; $4817
	ld l,e			; $4818
	ld (hl),a		; $4819
	ret			; $481a

@createSparkle2:
	ldbc INTERACID_SPARKLE,$01		; $481b

@createInteraction:
	jp objectCreateInteraction		; $481e


@state1:
	call objectOscillateZ_body		; $4821
	call interactionDecCounter1		; $4824
	jr z,++			; $4827

	call @updateAnimation		; $4829
	ld a,(wFrameCounter)		; $482c
	rrca			; $482f
	jp nc,objectSetInvisible		; $4830
	jp objectSetVisible		; $4833
++
	ld l,Interaction.var03		; $4836
	ld a,(hl)		; $4838
	or a			; $4839
	jr z,++			; $483a

	ld l,Interaction.state		; $483c
	ld (hl),$05		; $483e
	ld hl,$cfc0		; $4840
	set 1,(hl)		; $4843
	call objectSetVisible		; $4845
	jr @updateAnimation		; $4848
++
	ld l,Interaction.state		; $484a
	inc (hl)		; $484c
	ld l,Interaction.zh		; $484d
	ld (hl),$00		; $484f
	ld l,Interaction.var3a		; $4851
	ld (hl),$30		; $4853

	ld l,Interaction.angle		; $4855
	ld (hl),$00		; $4857
	ld l,Interaction.speed		; $4859
	ld (hl),SPEED_80		; $485b

	call objectSetVisible		; $485d
	ld a,SND_CHARGE_SWORD		; $4860
	call playSound		; $4862

@state2:
	call objectApplySpeed		; $4865

	ld h,d			; $4868
	ld l,Interaction.yh		; $4869
	ld a,(hl)		; $486b
	cp $10			; $486c
	jr nc,@updateAnimation	; $486e

	ld l,Interaction.state		; $4870
	inc (hl)		; $4872
	ld l,Interaction.counter1		; $4873
	ld (hl),$04		; $4875
	ld l,Interaction.var3b		; $4877
	ld (hl),$00		; $4879

	ld a,(w1Link.yh)		; $487b
	ld l,Interaction.yh		; $487e
	ld (hl),a		; $4880
	ld a,(w1Link.xh)		; $4881
	ld l,Interaction.xh		; $4884
	ld (hl),a		; $4886

	call @func_48eb		; $4887

@state3:
	call @checkLinkIsClose		; $488a
	jr c,++			; $488d

	call @func_48d0		; $488f
	call @func_48f9		; $4892
	ld a,(de)		; $4895
	ld e,Interaction.var3b		; $4896
	call objectSetPositionInCircleArc		; $4898
	call @func_4907		; $489b
	ld a,(wFrameCounter)		; $489e
	and $07			; $48a1
	call z,@createSparkle2		; $48a3
	jr @updateAnimation		; $48a6
++
	ld l,Interaction.state		; $48a8
	inc (hl)		; $48aa
	ld hl,$cfc0		; $48ab
	set 1,(hl)		; $48ae

@updateAnimation:
	jp interactionAnimate		; $48b0

@state4:
	call objectOscillateZ_body		; $48b3
	ld a,($cfc0)		; $48b6
	cp $07			; $48b9
	jp z,interactionDelete		; $48bb
	jr @updateAnimation		; $48be

@state5:
	call objectOscillateZ_body		; $48c0
	ld a,($cfc0)		; $48c3
	cp $07			; $48c6
	jr nz,@updateAnimation	; $48c8
	call @createPuff		; $48ca
	jp interactionDelete		; $48cd

;;
; @addr{48d0}
@func_48d0:
	ld l,Interaction.yh		; $48d0
	ld e,Interaction.var38		; $48d2
	ld a,(de)		; $48d4
	ldi (hl),a		; $48d5
	inc l			; $48d6
	inc e			; $48d7
	ld a,(de)		; $48d8
	ld (hl),a		; $48d9
	ld a,(w1Link.yh)		; $48da
	ld b,a			; $48dd
	ld a,(w1Link.xh)		; $48de
	ld c,a			; $48e1
	call objectGetRelativeAngle		; $48e2
	ld e,Interaction.angle		; $48e5
	ld (de),a		; $48e7
	call objectApplySpeed		; $48e8

;;
; @addr{48eb}
@func_48eb:
	ld h,d			; $48eb
	ld l,Interaction.yh		; $48ec
	ld e,Interaction.var38		; $48ee
	ldi a,(hl)		; $48f0
	ld (de),a		; $48f1
	ld b,a			; $48f2
	inc l			; $48f3
	inc e			; $48f4
	ld a,(hl)		; $48f5
	ld (de),a		; $48f6
	ld c,a			; $48f7
	ret			; $48f8

;;
; @addr{48f9}
@func_48f9:
	ld e,Interaction.var3a		; $48f9
	ld a,(de)		; $48fb
	or a			; $48fc
	ret z			; $48fd
	call interactionDecCounter1		; $48fe
	ret nz			; $4901

	ld (hl),$04		; $4902

	ld l,e			; $4904
	dec (hl)		; $4905
	ret			; $4906

;;
; @addr{4907}
@func_4907:
	ld a,(wFrameCounter)		; $4907
	rrca			; $490a
	ret nc			; $490b

	ld e,Interaction.var3b		; $490c
	ld a,(de)		; $490e
	inc a			; $490f
	and $1f			; $4910
	ld (de),a		; $4912
	ret			; $4913

;;
; @param[out]	cflag	Set if Link is close to this object
; @addr{4914}
@checkLinkIsClose:
	ld h,d			; $4914
	ld l,Interaction.yh		; $4915
	ld a,(w1Link.yh)		; $4917
	add $f0			; $491a
	sub (hl)		; $491c
	add $04			; $491d
	cp $09			; $491f
	ret nc			; $4921
	ld l,Interaction.xh		; $4922
	ld a,(w1Link.xh)		; $4924
	sub (hl)		; $4927
	add $02			; $4928
	cp $05			; $492a
	ret			; $492c


;;
; When called once per frame, the object's Z positon will gently oscillate up and down.
;
; @addr{492d}
objectOscillateZ_body:
	ld a,(wFrameCounter)		; $492d
	and $07			; $4930
	ret nz			; $4932

	ld a,(wFrameCounter)		; $4933
	and $38			; $4936
	swap a			; $4938
	rlca			; $493a

	ld hl,@zOffsets		; $493b
	rst_addAToHl			; $493e
	ldh a,(<hActiveObjectType)	; $493f
	add Object.zh			; $4941
	ld e,a			; $4943
	ld a,(de)		; $4944
	add (hl)		; $4945
	ld (de),a		; $4946
	ret			; $4947

@zOffsets:
	.db $ff $fe $ff $00
	.db $01 $02 $01 $00


; ==============================================================================
; INTERACID_EXPLOSION
; ==============================================================================
interactionCode56:
	call checkInteractionState		; $4950
	jr z,@state0	; $4953

@state1:
	ld e,Interaction.animParameter		; $4955
	ld a,(de)		; $4957
	inc a			; $4958
	jp nz,interactionAnimate		; $4959
	jp interactionDelete		; $495c

@state0:
	inc a			; $495f
	ld (de),a		; $4960
	call interactionInitGraphics		; $4961
	ld a,SND_EXPLOSION		; $4964
	call playSound		; $4966
	ld e,Interaction.var03		; $4969
	ld a,(de)		; $496b
	rrca			; $496c
	jp c,objectSetVisible81		; $496d
	jp objectSetVisible82		; $4970


; ==============================================================================
; INTERACID_TREASURE
;
; State $04 is used as a way to delete a treasure? (Bomb flower cutscene with goron elder
; sets the bomb flower to state 4 to delete it.)
;
; Variables:
;   subid: overwritten by call to "interactionLoadTreasureData" to correspond to a certain
;          graphic.
;   var30: former value of subid (treasure index)
;
;   var31-var35 based on data from "treasureObjectData.s":
;     var31: spawn mode
;     var32: collect mode
;     var33: a boolean?
;     var34: parameter (value of 'c' for "giveTreasure" function)
;     var35: low text ID
;   var39: If set, this is part of the chest minigame? Gets written to "wDisabledObjects"?
; ==============================================================================
interactionCode60:
	ld e,Interaction.state		; $4973
	ld a,(de)		; $4975
	rst_jumpTable			; $4976
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3
	.dw interactionDelete

@state0:
	ld a,$01		; $4981
	ld (de),a		; $4983
	callab bank16.interactionLoadTreasureData		; $4984
	ld a,$06		; $498c
	call objectSetCollideRadius		; $498e

	; Check whether to overwrite the "parameter" for the treasure?
	ld l,Interaction.var38		; $4991
	ld a,(hl)		; $4993
	or a			; $4994
	jr z,+			; $4995
	cp $ff			; $4997
	jr z,+			; $4999
	ld l,Interaction.var34		; $499b
	ld (hl),a		; $499d
+
	call interactionInitGraphics		; $499e

	ld e,Interaction.var31		; $49a1
	ld a,(de)		; $49a3
	or a			; $49a4
	ret nz			; $49a5
	jp objectSetVisiblec2		; $49a6


; State 1: spawning in; goes to state 2 when finished spawning.
@state1:
	ld e,Interaction.var31		; $49a9
	ld a,(de)		; $49ab
	rst_jumpTable			; $49ac
	.dw @spawnMode0
	.dw @spawnMode1
	.dw @spawnMode2
	.dw @spawnMode3
	.dw @spawnMode4
	.dw @spawnMode5
	.dw @spawnMode6

; Spawns instantly
@spawnMode0:
	ld h,d			; $49bb
	ld l,Interaction.state		; $49bc
	ld (hl),$02		; $49be
	inc l			; $49c0
	ld (hl),$00		; $49c1
	call @checkLinkTouched		; $49c3
	jp c,@gotoState3		; $49c6
	jp objectSetVisiblec2		; $49c9

; Appears with a poof
@spawnMode1:
	ld e,Interaction.state2		; $49cc
	ld a,(de)		; $49ce
	or a			; $49cf
	jr nz,++		; $49d0

	ld a,$01		; $49d2
	ld (de),a		; $49d4
	ld e,Interaction.counter1		; $49d5
	ld a,$1e		; $49d7
	ld (de),a		; $49d9
	call objectCreatePuff		; $49da
	ret nz			; $49dd
++
	call interactionDecCounter1		; $49de
	ret nz			; $49e1
	jr @spawnMode0			; $49e2

; Falls from top of screen
@spawnMode2:
	ld e,Interaction.state2		; $49e4
	ld a,(de)		; $49e6
	rst_jumpTable			; $49e7
	.dw @@substate0
	.dw @@substate1
	.dw @@substate2

@@substate0:
	ld a,$01		; $49ee
	ld (de),a		; $49f0
	ld h,d			; $49f1
	ld l,Interaction.counter1		; $49f2
	ld (hl),$28		; $49f4
	ld a,SND_SOLVEPUZZLE	; $49f6
	jp playSound		; $49f8

@@substate1:
	call interactionDecCounter1		; $49fb
	ret nz			; $49fe
	ld (hl),$02		; $49ff
	inc l			; $4a01
	ld (hl),$02		; $4a02

	ld l,Interaction.state2		; $4a04
	inc (hl)		; $4a06

	call objectGetZAboveScreen		; $4a07
	ld h,d			; $4a0a
	ld l,Interaction.zh		; $4a0b
	ld (hl),a		; $4a0d

	call objectSetVisiblec0		; $4a0e
	jp @setVisibleIfWithinScreenBoundary		; $4a11

@@substate2:
	call @checkLinkTouched		; $4a14
	jr c,@gotoState3		; $4a17
	call @setVisibleIfWithinScreenBoundary		; $4a19
	ld c,$10		; $4a1c
	call objectUpdateSpeedZ_paramC		; $4a1e
	ret nz			; $4a21
	call objectCheckIsOnHazard		; $4a22
	jr nc,+			; $4a25

	dec a			; $4a27
	jr z,@landedOnWater		; $4a28
	jp objectReplaceWithFallingDownHoleInteraction		; $4a2a
+
	ld a,SND_DROPESSENCE		; $4a2d
	call playSound		; $4a2f
	call interactionDecCounter1		; $4a32
	jr z,@gotoState2			; $4a35

	ld bc,$ff56		; $4a37
	jp objectSetSpeedZ		; $4a3a

@gotoState2:
	call objectSetVisible		; $4a3d
	call objectSetVisiblec2		; $4a40
	ld a,$02		; $4a43
	jr @gotoStateAndAlwaysUpdate			; $4a45

@setVisibleIfWithinScreenBoundary:
	call objectCheckWithinScreenBoundary		; $4a47
	jp nc,objectSetInvisible		; $4a4a
	jp objectSetVisible		; $4a4d

@gotoState3:
	call @giveTreasure		; $4a50
	ld a,$03		; $4a53

@gotoStateAndAlwaysUpdate:
	ld h,d			; $4a55
	ld l,Interaction.state		; $4a56
	ldi (hl),a		; $4a58
	xor a			; $4a59
	ld (hl),a		; $4a5a

	ld l,Interaction.z		; $4a5b
	ldi (hl),a		; $4a5d
	ld (hl),a		; $4a5e

	jp interactionSetAlwaysUpdateBit		; $4a5f

; If the treasure fell into the water, "reset" this object to state 0, increment var03.
@landedOnWater:
	ld h,d			; $4a62
	ld l,Interaction.var30		; $4a63
	ld a,(hl)		; $4a65
	ld l,Interaction.subid		; $4a66
	ldi (hl),a		; $4a68

	inc (hl) ; [var03]++ (use the subsequent entry in treasureObjectData)

	; Clear state
	inc l			; $4a6a
	xor a			; $4a6b
	ldi (hl),a		; $4a6c
	ld (hl),a		; $4a6d

	ld l,Interaction.visible		; $4a6e
	res 7,(hl)		; $4a70
	ld b,INTERACID_SPLASH		; $4a72
	jp objectCreateInteractionWithSubid00		; $4a74


; Spawns from a chest
@spawnMode3:
	ld a,$80		; $4a77
	ld (wForceLinkPushAnimation),a		; $4a79
	ld e,Interaction.state2		; $4a7c
	ld a,(de)		; $4a7e
	rst_jumpTable			; $4a7f
	.dw @m3State0
	.dw @m3State1
	.dw @m3State2

@m3State0:
	ld a,$01		; $4a86
	ld (de),a		; $4a88
	ld (wDisableLinkCollisionsAndMenu),a		; $4a89
	call interactionSetAlwaysUpdateBit		; $4a8c

	; Angle is already $00 (up), so don't need to set it
	ld l,Interaction.speed		; $4a8f
	ld (hl),SPEED_40		; $4a91

	ld l,Interaction.counter1		; $4a93
	ld (hl),$20		; $4a95
	jp objectSetVisible80		; $4a97

@m3State1:
	; Move up
	call objectApplySpeed		; $4a9a
	call interactionDecCounter1		; $4a9d
	ret nz			; $4aa0

	; Finished moving up
	ld l,Interaction.state2		; $4aa1
	inc (hl)		; $4aa3
	ld l,Interaction.var39		; $4aa4
	ld a,(hl)		; $4aa6
	or a			; $4aa7
	call z,@giveTreasure		; $4aa8
	ld a,SND_GETITEM	; $4aab
	call playSound		; $4aad

	; Wait for player to close text
@m3State2:
	ld a,(wTextIsActive)		; $4ab0
	and $7f			; $4ab3
	ret nz			; $4ab5

	xor a			; $4ab6
	ld (wDisableLinkCollisionsAndMenu),a		; $4ab7
	ld e,Interaction.var39		; $4aba
	ld a,(de)		; $4abc
	ld (wDisabledObjects),a		; $4abd
	jp interactionDelete		; $4ac0


; Appears at Link's position after a short delay
@spawnMode6:
	ld e,Interaction.state2		; $4ac3
	ld a,(de)		; $4ac5
	rst_jumpTable			; $4ac6
	.dw @m6State0
	.dw @m6State1
	.dw @m6State2

@m6State0:
	ld a,$01		; $4acd
	ld (de),a		; $4acf
	ld (wDisableLinkCollisionsAndMenu),a		; $4ad0
	call interactionSetAlwaysUpdateBit		; $4ad3
	ld l,Interaction.counter1		; $4ad6
	ld (hl),$0f		; $4ad8
@m6State1:
	call interactionDecCounter1		; $4ada
	ret nz			; $4add

	; Delay done, give treasure to Link

	call interactionIncState2		; $4ade
	call objectSetVisible80		; $4ae1
	call @giveTreasure		; $4ae4
	ldbc $81,$00		; $4ae7
	call @setLinkAnimationAndDeleteIfTextClosed		; $4aea
	ld a,SND_GETITEM	; $4aed
	jp playSound		; $4aef

@m6State2:
	ld a,(wTextIsActive)		; $4af2
	and $7f			; $4af5
	ret nz			; $4af7
	xor a			; $4af8
	ld (wDisableLinkCollisionsAndMenu),a		; $4af9
	ld (wDisabledObjects),a		; $4afc
	jp interactionDelete		; $4aff


; Item that's underwater, must dive to get it (only used in seasons dungeon 4)
@spawnMode4:
	call @checkLinkTouched		; $4b02
	ret nc			; $4b05
	ld a,(wLinkSwimmingState)		; $4b06
	bit 7,a			; $4b09
	ret z			; $4b0b
	call objectSetVisible82		; $4b0c
	call @giveTreasure		; $4b0f
	ld a,SND_GETITEM		; $4b12
	call playSound		; $4b14
	ld a,$03		; $4b17
	jp @gotoStateAndAlwaysUpdate		; $4b19


; Item that falls to Link's position when [wccaa]=$ff?
@spawnMode5:
	ld e,Interaction.state2		; $4b1c
	ld a,(de)		; $4b1e
	rst_jumpTable			; $4b1f
	.dw @m5State0
	.dw @m5State1
	.dw @m5State2

@m5State0:
	ld a,$01		; $4b26
	ld (de),a		; $4b28
	call objectGetShortPosition		; $4b29
	ld (wccaa),a		; $4b2c
	ret			; $4b2f

@m5State1:
	ld a,(wScrollMode)		; $4b30
	and $0c			; $4b33
	jp nz,interactionDelete		; $4b35

	ld a,(wccaa)		; $4b38
	inc a			; $4b3b
	ret nz			; $4b3c

	ld bc,$ff00		; $4b3d
	call objectSetSpeedZ		; $4b40
	ld l,Interaction.state2		; $4b43
	inc (hl)		; $4b45
	ld a,(w1Link.direction)		; $4b46
	swap a			; $4b49
	rrca			; $4b4b
	ld l,$49		; $4b4c
	ld (hl),a		; $4b4e
	ld l,$50		; $4b4f
	ld (hl),$14		; $4b51
	jp objectSetVisiblec2		; $4b53

@m5State2:
	call objectCheckTileCollision_allowHoles		; $4b56
	call nc,objectApplySpeed		; $4b59
	ld c,$10		; $4b5c
	call objectUpdateSpeedZAndBounce		; $4b5e
	ret nz			; $4b61
	push af			; $4b62
	call objectReplaceWithAnimationIfOnHazard		; $4b63
	pop bc			; $4b66
	jp c,interactionDelete		; $4b67

	ld a,SND_DROPESSENCE		; $4b6a
	call playSound		; $4b6c
	bit 4,c			; $4b6f
	ret z			; $4b71
	jp @gotoState2		; $4b72


; State 2: done spawning, waiting for Link to grab it
@state2:
	call returnIfScrollMode01Unset		; $4b75
	call @checkLinkTouched		; $4b78
	ret nc			; $4b7b
	jp @gotoState3		; $4b7c


; State 3: Link just grabbed it
@state3:
	ld e,Interaction.var32		; $4b7f
	ld a,(de)		; $4b81
	rst_jumpTable			; $4b82
	.dw interactionDelete
	.dw @grabMode1
	.dw @grabMode2
	.dw @grabMode3
	.dw @grabMode1
	.dw @grabMode2

; Hold over head with 1 hand
@grabMode1:
	ldbc $80,$fc		; $4b8f
	jr +			; $4b92

; Hold over head with 2 hands
@grabMode2:
	ldbc $81,$00		; $4b94
+
	ld e,Interaction.state2		; $4b97
	ld a,(de)		; $4b99
	or a			; $4b9a
	jr nz,++		; $4b9b

	inc a			; $4b9d
	ld (de),a		; $4b9e

;;
; @param	b	Animation to do (0 = 1-hand grab, 1 = 2-hand grab)
; @param	c	x-offset to put item relative to Link
; @addr{4b9f}
@setLinkAnimationAndDeleteIfTextClosed:
	ld a,LINK_STATE_04		; $4b9f
	ld (wLinkForceState),a		; $4ba1
	ld a,b			; $4ba4
	ld (wcc50),a		; $4ba5
	ld hl,wDisabledObjects		; $4ba8
	set 0,(hl)		; $4bab
	ld hl,w1Link		; $4bad
	ld b,$f2		; $4bb0
	call objectTakePositionWithOffset		; $4bb2
	call objectSetVisible80		; $4bb5
	ld a,SND_GETITEM		; $4bb8
	call playSound		; $4bba
++
	call retIfTextIsActive		; $4bbd
	ld hl,wDisabledObjects		; $4bc0
	res 0,(hl)		; $4bc3
	ld a,$0f		; $4bc5
	ld (wInstrumentsDisabledCounter),a		; $4bc7
	jp interactionDelete		; $4bca


; Performs a spin slash upon obtaining the item
@grabMode3:
	ld a,Interaction.var38		; $4bcd
	ld (wInstrumentsDisabledCounter),a		; $4bcf
	ld e,Interaction.state2		; $4bd2
	ld a,(de)		; $4bd4
	rst_jumpTable			; $4bd5
	.dw @gm3State0
	.dw @gm3State1
	.dw @gm3State2
	.dw @gm3State3

@gm3State0:
	ld a,$01		; $4bde
	ld (de),a		; $4be0
	inc e			; $4be1

	ld a,$04		; $4be2
	ld (de),a ; [counter1] = $04

	ld a,$81		; $4be5
	ld (wDisabledObjects),a		; $4be7
	ld a,$ff		; $4bea
	call setLinkForceStateToState08_withParam		; $4bec
	ld hl,wLinkForceState		; $4bef
	jp objectSetInvisible		; $4bf2

@gm3State1:
	call interactionDecCounter1		; $4bf5
	ret nz			; $4bf8

	ld l,Interaction.state2		; $4bf9
	inc (hl)		; $4bfb

	; Forces spinslash animation
	ld a,$ff		; $4bfc
	ld (wcc63),a		; $4bfe
	ret			; $4c01

@gm3State2:
	; Wait for spin to finish
	ld a,(wcc63)		; $4c02
	or a			; $4c05
	ret nz			; $4c06

	ld a,LINK_ANIM_MODE_GETITEM1HAND		; $4c07
	ld (wcc50),a		; $4c09

	; Calculate x/y position just above Link
	ld e,Interaction.yh		; $4c0c
	ld a,(w1Link.yh)		; $4c0e
	sub $0e			; $4c11
	ld (de),a		; $4c13
	ld e,Interaction.xh		; $4c14
	ld a,(w1Link.xh)		; $4c16
	sub $04			; $4c19
	ld (de),a		; $4c1b

	call objectSetVisible		; $4c1c
	call objectSetVisible80		; $4c1f
	call interactionIncState2		; $4c22
	ld a,SND_SWORD_OBTAINED		; $4c25
	jp playSound		; $4c27

@gm3State3:
	ld a,(wDisabledObjects)		; $4c2a
	or a			; $4c2d
	ret nz			; $4c2e
	jp interactionDelete		; $4c2f

@giveTreasure:
	ld e,Interaction.var34		; $4c32
	ld a,(de)		; $4c34
	ld c,a			; $4c35
	ld e,Interaction.var30		; $4c36
	ld a,(de)		; $4c38
	ld b,a			; $4c39

	; If this is ore chunks, double the value if wearing an appropriate ring?
	cp TREASURE_ORE_CHUNKS			; $4c3a
	jr nz,++		; $4c3c

	ld a,GOLD_JOY_RING		; $4c3e
	call cpActiveRing		; $4c40
	jr z,+			; $4c43

	ld a,GREEN_JOY_RING		; $4c45
	call cpActiveRing		; $4c47
	jr nz,++		; $4c4a
+
	inc c			; $4c4c
++
	ld a,b			; $4c4d
	call giveTreasure		; $4c4e
	ld b,a			; $4c51

	ld e,Interaction.var32		; $4c52
	ld a,(de)		; $4c54
	cp $03			; $4c55
	jr z,+			; $4c57

	ld a,b			; $4c59
	call playSound		; $4c5a
+
	ld e,Interaction.var35		; $4c5d
	ld a,(de)		; $4c5f
	cp $ff			; $4c60
	jr z,++			; $4c62

	ld c,a			; $4c64
	ld b,>TX_0000		; $4c65
	call showText		; $4c67

	; Determine textbox position (after showText call...?)
	ldh a,(<hCameraY)	; $4c6a
	ld b,a			; $4c6c
	ld a,(w1Link.yh)		; $4c6d
	sub b			; $4c70
	sub $10			; $4c71
	cp $48			; $4c73
	ld a,$02		; $4c75
	jr c,+			; $4c77
	xor a			; $4c79
+
	ld (wTextboxPosition),a		; $4c7a
++
	ld e,Interaction.var33		; $4c7d
	ld a,(de)		; $4c7f
	or a			; $4c80
	ret z			; $4c81

	; Mark item as obtained
	call getThisRoomFlags		; $4c82
	set ROOMFLAG_BIT_ITEM,(hl)		; $4c85
	ret			; $4c87

;;
; @param[out]	cflag	Set if Link's touched this object so he should collect it
; @addr{4c88}
@checkLinkTouched:
	ld a,(wLinkForceState)		; $4c88
	or a			; $4c8b
	ret nz			; $4c8c

	ld a,(wLinkPlayingInstrument)		; $4c8d
	or a			; $4c90
	ret nz			; $4c91

	ld a,(w1Link.state)		; $4c92
	cp LINK_STATE_NORMAL			; $4c95
	jr z,+			; $4c97
	cp LINK_STATE_08			; $4c99
	jr nz,++		; $4c9b
+
	ld a,(wLinkObjectIndex)		; $4c9d
	rrca			; $4ca0
	jr c,++			; $4ca1

	; Check if Link's touched this
	ld e,Interaction.var2a		; $4ca3
	ld a,(de)		; $4ca5
	or a			; $4ca6
	jp z,objectCheckCollidedWithLink_notDeadAndNotGrabbing		; $4ca7
	scf			; $4caa
	ret			; $4cab
++
	xor a			; $4cac
	ret			; $4cad


; ==============================================================================
; INTERACID_GHOST_VERAN
; ==============================================================================
interactionCode3e:
	ld e,Interaction.state		; $4cae
	ld a,(de)		; $4cb0
	rst_jumpTable			; $4cb1
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $4cb6
	ld (de),a		; $4cb8
	call interactionInitGraphics		; $4cb9
	call objectSetVisible83		; $4cbc
	ld e,Interaction.subid	; $4cbf
	ld a,(de)		; $4cc1
	rst_jumpTable			; $4cc2
	.dw @subid0Init
	.dw @subid1Init
	.dw @subid2Init

@subid0Init:
	ld e,Interaction.counter1	; $4cc9
	ld a,Interaction.var38		; $4ccb
	ld (de),a		; $4ccd
	jp interactionSetAlwaysUpdateBit		; $4cce

@subid1Init:
	ld h,d			; $4cd1
	ld l,Interaction.angle		; $4cd2
	ld (hl),$10		; $4cd4
	ld l,Interaction.speed		; $4cd6
	ld (hl),SPEED_c0		; $4cd8
	ld hl,ghostVeranSubid1Script		; $4cda
	call interactionSetScript		; $4cdd
	call interactionSetAlwaysUpdateBit		; $4ce0
	jp objectSetVisible81		; $4ce3

@subid2Init:
	ld e,Interaction.speed		; $4ce6
	ld a,SPEED_200		; $4ce8
	ld (de),a		; $4cea
	ld a,SND_BEAM		; $4ceb
	jp playSound		; $4ced


@state1:
	ld e,Interaction.subid	; $4cf0
	ld a,(de)		; $4cf2
	rst_jumpTable			; $4cf3
	.dw _runVeranGhostSubid0
	.dw _runVeranGhostSubid1
	.dw _runVeranGhostSubid2


; Cutscene at start of game (unpossessing Impa)
_runVeranGhostSubid0:
	ld e,Interaction.var39		; $4cfa
	ld a,(de)		; $4cfc
	or a			; $4cfd
	call z,interactionAnimate		; $4cfe
	ld e,Interaction.state2		; $4d01
	ld a,(de)		; $4d03
	rst_jumpTable			; $4d04
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4
	.dw @substate5
	.dw @substate6
	.dw @substate7
	.dw @substate8

@substate0:
	call interactionDecCounter1		; $4d17
	jr nz,++		; $4d1a

	; Appear out of Impa
	ld (hl),$5a		; $4d1c
	ld l,Interaction.angle	; $4d1e
	ld (hl),$00		; $4d20
	ld l,Interaction.speed	; $4d22
	ld (hl),$0a		; $4d24
	call interactionIncState2		; $4d26
	ld a,MUS_ROOM_OF_RITES		; $4d29
	call playSound		; $4d2b
	jp objectSetVisible80		; $4d2e
++
	ld a,(wFrameCounter)		; $4d31
	rrca			; $4d34
	jp nc,objectSetVisible83		; $4d35
	jp objectSetVisible80		; $4d38

@substate1:
	call interactionDecCounter1		; $4d3b
	jp nz,objectApplySpeed		; $4d3e
	call interactionIncState2		; $4d41
	ld hl,ghostVeranSubid0Script_part1		; $4d44
	jp interactionSetScript		; $4d47

@substate2:
	ld a,($cfd1)		; $4d4a
	or a			; $4d4d
	jr z,++			; $4d4e

	ldbc INTERACID_HUMAN_VERAN, $00	; $4d50
	call objectCreateInteraction		; $4d53
	ret nz			; $4d56

	ld l,Interaction.relatedObj1		; $4d57
	ld a,Interaction.start	; $4d59
	ldi (hl),a		; $4d5b
	ld (hl),d		; $4d5c
---
	call interactionIncState2		; $4d5d
	ld l,Interaction.var38		; $4d60
	ld (hl),$78		; $4d62
	ld l,Interaction.var39		; $4d64
	inc (hl)		; $4d66
	xor a			; $4d67
	call interactionSetAnimation		; $4d68
	ld a,SND_TELEPORT	; $4d6b
	jp playSound		; $4d6d
++
	call objectGetPosition		; $4d70
	ld hl,$cfd5		; $4d73
	ld (hl),b		; $4d76
	inc l			; $4d77
	ld e,Interaction.var3d		; $4d78
	ld a,c			; $4d7a
	ld (de),a		; $4d7b
	ld (hl),a		; $4d7c
	jp interactionRunScript		; $4d7d

@substate3:
@substate5:
	ld h,d			; $4d80
	ld l,Interaction.var38		; $4d81
	dec (hl)		; $4d83
	ld b,$01		; $4d84
	jp nz,objectFlickerVisibility		; $4d86

	ld l,Interaction.var39		; $4d89
	dec (hl)		; $4d8b
	call interactionIncState2		; $4d8c
	ld a,(hl)		; $4d8f
	cp $04			; $4d90
	jp nz,objectSetVisible		; $4d92
	call objectSetInvisible		; $4d95
	ld a,SND_SWORD_OBTAINED		; $4d98
	jp playSound		; $4d9a

@substate4:
	ld a,($cfd1)		; $4d9d
	cp $02			; $4da0
	ret nz			; $4da2
	jr ---			; $4da3

@substate6:
	ld a,($cfd0)		; $4da5
	cp $12			; $4da8
	jr nz,+			; $4daa
	ld bc,$0302		; $4dac
	call @rumbleAndRandomizeX		; $4daf
	jr ++			; $4db2
+
	call objectGetPosition		; $4db4
	ld hl,$cfd5		; $4db7
	ld (hl),b		; $4dba
	inc l			; $4dbb
	ld e,Interaction.var3d		; $4dbc
	ld a,c			; $4dbe
	ld (de),a		; $4dbf
	ld (hl),a		; $4dc0
++
	call interactionRunScript		; $4dc1
	ret nc			; $4dc4
	call objectSetInvisible		; $4dc5
	jp interactionIncState2		; $4dc8

;;
; @addr{4dcb}
@rumbleAndRandomizeX:
	ld a,(wFrameCounter)		; $4dcb
	and $0f			; $4dce
	ld a,SND_RUMBLE2	; $4dd0
	call z,playSound		; $4dd2
	call getRandomNumber		; $4dd5
	and b			; $4dd8
	sub c			; $4dd9
	ld h,d			; $4dda
	ld l,Interaction.var3d		; $4ddb
	add (hl)		; $4ddd
	ld l,Interaction.xh		; $4dde
	ld (hl),a		; $4de0
	ret			; $4de1

@substate7:
	ld a,($cfd0)		; $4de2
	cp $17			; $4de5
	ret nz			; $4de7

	call interactionIncState2		; $4de8
	ld hl,ghostVeranSubid1Script_part2		; $4deb
	call interactionSetScript		; $4dee
	call objectSetVisible80		; $4df1

@substate8:
	call interactionRunScript		; $4df4
	ret nc			; $4df7
	jp interactionDelete		; $4df8


; Cutscene just before fighting possessed Ambi
_runVeranGhostSubid1:
	ld a,(wTextIsActive)		; $4dfb
	or a			; $4dfe
	jr nz,+			; $4dff
	call interactionRunScript		; $4e01
	jp c,interactionDelete		; $4e04
+
	jp interactionAnimate		; $4e07


; Cutscene just after fighting possessed Ambi
_runVeranGhostSubid2:
	ld e,Interaction.state2		; $4e0a
	ld a,(de)		; $4e0c
	rst_jumpTable			; $4e0d
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate0:
	ld bc,$5878		; $4e16
	ld e,Interaction.yh		; $4e19
	ld a,(de)		; $4e1b
	ldh (<hFF8F),a	; $4e1c
	ld e,Interaction.xh		; $4e1e
	ld a,(de)		; $4e20
	ldh (<hFF8E),a	; $4e21
	sub c			; $4e23
	inc a			; $4e24
	cp $03			; $4e25
	jr nc,++		; $4e27

	ldh a,(<hFF8F)	; $4e29
	sub b			; $4e2b
	inc a			; $4e2c
	cp $03			; $4e2d
	jr nc,++		; $4e2f

	call interactionIncState2		; $4e31
	ld l,Interaction.yh		; $4e34
	ld (hl),b		; $4e36
	ld l,Interaction.xh		; $4e37
	ld (hl),c		; $4e39
	ld l,Interaction.counter1	; $4e3a
	ld (hl),$3c		; $4e3c
	jr @animate		; $4e3e
++
	call objectGetRelativeAngleWithTempVars		; $4e40
	ld e,Interaction.angle	; $4e43
	ld (de),a		; $4e45
	call objectApplySpeed		; $4e46

@animate:
	jp interactionAnimate		; $4e49

@substate1:
	call interactionDecCounter1		; $4e4c
	jr nz,@animate	; $4e4f
	ld l,e			; $4e51
	inc (hl)		; $4e52
	ld bc,TX_560e		; $4e53
	jp showText		; $4e56

@substate2:
	call getFreeEnemySlot		; $4e59
	ret nz			; $4e5c
	ld (hl),ENEMYID_VERAN_FAIRY		; $4e5d
	call objectCopyPosition		; $4e5f
	ld e,Interaction.relatedObj2		; $4e62
	ld a,Enemy.start		; $4e64
	ld (de),a		; $4e66
	inc e			; $4e67
	ld a,h			; $4e68
	ld (de),a		; $4e69
	call interactionIncState2		; $4e6a
	ld l,Interaction.counter1		; $4e6d
	ld (hl),$3d		; $4e6f
	ret			; $4e71

@substate3:
	call interactionDecCounter1		; $4e72
	jr z,++			; $4e75

	ld a,Object.visible		; $4e77
	call objectGetRelatedObject2Var		; $4e79
	bit 7,(hl)		; $4e7c
	jp z,objectSetVisible82		; $4e7e
	jp objectSetInvisible		; $4e81
++
	ld a,$01		; $4e84
	ld (wLoadedTreeGfxIndex),a		; $4e86
	jp interactionDelete		; $4e89


; ==============================================================================
; INTERACID_BOY_2
; ==============================================================================
interactionCode3f:
	ld e,Interaction.subid		; $4e8c
	ld a,(de)		; $4e8e
	rst_jumpTable			; $4e8f
	.dw @subid0
	.dw @subid1
	.dw @subid2
	.dw @subid3

@subid0:
	call checkInteractionState		; $4e98
	jr nz,@@state1		; $4e9b

@@state0:
	ld a,GLOBALFLAG_FINISHEDGAME		; $4e9d
	call checkGlobalFlag		; $4e9f
	jp nz,interactionDelete		; $4ea2
	ld a,GLOBALFLAG_0b		; $4ea5
	call checkGlobalFlag		; $4ea7
	jp nz,interactionDelete		; $4eaa

	call @initializeGraphicsAndScript		; $4ead
@@state1:
	call interactionRunScript		; $4eb0
	jp npcFaceLinkAndAnimate		; $4eb3


@subid1:
	call checkInteractionState		; $4eb6
	jr nz,@@state1		; $4eb9

@@state0:
	callab getGameProgress_1		; $4ebb
	ld a,b			; $4ec3
	cp $03			; $4ec4
	jp nz,interactionDelete		; $4ec6
	call @initializeGraphicsAndScript		; $4ec9
@@state1:
	call interactionRunScript		; $4ecc
	jp npcFaceLinkAndAnimate		; $4ecf


@subid2:
	call checkInteractionState		; $4ed2
	jr nz,@@state1		; $4ed5

@@state0:
	call getThisRoomFlags		; $4ed7
	bit 6,a			; $4eda
	jp nz,interactionDelete		; $4edc
	call @initGraphicsAndIncState		; $4edf

	ld l,Interaction.var3d		; $4ee2
	ld e,Interaction.xh		; $4ee4
	ld a,(de)		; $4ee6
	ld (hl),a		; $4ee7

	jp objectSetVisiblec2		; $4ee8

@@state1:
	ld e,Interaction.state2		; $4eeb
	ld a,(de)		; $4eed
	rst_jumpTable			; $4eee
	.dw @@substate0
	.dw @@substate1
	.dw @@substate2

@@substate0:
	call interactionAnimate		; $4ef5
	ld a,($cfd1)		; $4ef8
	cp $01			; $4efb
	ret nz			; $4efd
	call interactionIncState2		; $4efe
	jpab interactionBank1.startJump		; $4f01

@@substate1:
	ld c,$20		; $4f09
	call objectUpdateSpeedZ_paramC		; $4f0b
	ret nz			; $4f0e
	call interactionIncState2		; $4f0f
	call @initializeScript		; $4f12
	dec (hl)		; $4f15
	ret			; $4f16

@@substate2:
	jpab interactionBank1.boyRunSubid03		; $4f17


@subid3:
	call checkInteractionState		; $4f1f
	jr z,@@state0			; $4f22

@@state1:
	jpab interactionBank1.boyRunSubid09		; $4f24

@@state0:
	call @initGraphicsAndIncState		; $4f2c
	ld l,Interaction.counter1		; $4f2f
	ld (hl),$78		; $4f31
	ld l,Interaction.oamFlags		; $4f33
	ld (hl),$02		; $4f35
	jp objectSetVisiblec1		; $4f37

@initGraphicsAndIncState:
	call interactionInitGraphics		; $4f3a
	call objectMarkSolidPosition		; $4f3d
	jp interactionIncState		; $4f40


@initializeGraphicsAndScript:
	call interactionInitGraphics		; $4f43
	call objectMarkSolidPosition		; $4f46

@initializeScript:
	ld a,>TX_2900		; $4f49
	call interactionSetHighTextIndex		; $4f4b

	ld e,Interaction.subid		; $4f4e
	ld a,(de)		; $4f50
	ld hl,@scriptTable		; $4f51
	rst_addDoubleIndex			; $4f54
	ldi a,(hl)		; $4f55
	ld h,(hl)		; $4f56
	ld l,a			; $4f57
	call interactionSetScript		; $4f58
	jp interactionIncState		; $4f5b

@scriptTable:
	.dw boy2Subid0Script
	.dw boy2Subid1Script
	.dw boy2Subid2Script
	.dw stubScript


; ==============================================================================
; INTERACID_SOLDIER
; ==============================================================================
interactionCode40:
	ld e,Interaction.subid		; $4f66
	ld a,(de)		; $4f68
	rst_jumpTable			; $4f69
	.dw _soldierSubid00
	.dw _soldierSubid01
	.dw _soldierSubid02
	.dw _soldierSubid03
	.dw _soldierSubid04
	.dw _soldierSubid05
	.dw _soldierSubid06
	.dw _soldierSubid07
	.dw _soldierSubid08
	.dw _soldierSubid09
	.dw _soldierSubid0a
	.dw _soldierSubid0b
	.dw _soldierSubid0c
	.dw _soldierSubid0d

_soldierSubid00:
_soldierSubid01:
	ld a,GLOBALFLAG_FINISHEDGAME		; $4f86
	call checkGlobalFlag		; $4f88
	jp nz,interactionDelete		; $4f8b

	ld a,GLOBALFLAG_0b		; $4f8e
	call checkGlobalFlag		; $4f90
	ld e,Interaction.var03		; $4f93
	ld a,(de)		; $4f95
	jr nz,_label_09_090	; $4f96
	or a			; $4f98
	jp nz,interactionDelete		; $4f99
	jr _soldierSubid0c		; $4f9c

_label_09_090:
	or a			; $4f9e
	jp z,interactionDelete		; $4f9f


_soldierSubid0c:
	call checkInteractionState		; $4fa2
	jr nz,_label_09_092	; $4fa5
	call _soldierInitGraphicsAndLoadScript		; $4fa7
_label_09_092:
	call interactionRunScript		; $4faa
	jp c,interactionDelete		; $4fad
	jp npcFaceLinkAndAnimate		; $4fb0


; Palace guards
_soldierSubid02:
_soldierSubid09:
	call checkInteractionState		; $4fb3
	jr nz,_label_09_093	; $4fb6
	call _soldierCheckBeatD6		; $4fb8
	jp nc,interactionDelete		; $4fbb
	call _soldierInitGraphicsAndLoadScript		; $4fbe
	call objectSetVisible82		; $4fc1
_label_09_093:
	call objectCheckWithinScreenBoundary		; $4fc4
	jp nc,interactionDelete		; $4fc7
	call _soldierUpdateAnimationAndRunScript		; $4fca
	call objectSetPriorityRelativeToLink_withTerrainEffects		; $4fcd
	ld a,GLOBALFLAG_10		; $4fd0
	call checkGlobalFlag		; $4fd2
	jr z,_label_09_094	; $4fd5
	ld a,GLOBALFLAG_0b		; $4fd7
	call checkGlobalFlag		; $4fd9
	ret z			; $4fdc
_label_09_094:
	jp objectPreventLinkFromPassing		; $4fdd


_soldierSubid03:
	call checkInteractionState		; $4fe0
	jr nz,_label_09_095	; $4fe3
	call _soldierCheckBeatD6		; $4fe5
	jp nc,interactionDelete		; $4fe8
	call _soldierInitGraphicsAndLoadScript		; $4feb
	jp objectSetVisible82		; $4fee
_label_09_095:
	call interactionRunScript		; $4ff1
	jp interactionAnimate		; $4ff4


; Guard who gives bombs to Link
_soldierSubid04:
	call checkInteractionState		; $4ff7
	jr nz,@state1	; $4ffa

@state0:
	call _soldierCheckBeatD6		; $4ffc
	jp nc,interactionDelete		; $4fff
	ld a,GLOBALFLAG_0b		; $5002
	call checkGlobalFlag		; $5004
	jp nz,interactionDelete		; $5007

	call _soldierInitGraphicsAndLoadScript		; $500a
	ld e,Interaction.oamFlags		; $500d
	ld a,$03		; $500f
	ld (de),a		; $5011
	jp objectSetVisiblec2		; $5012

@state1:
	ld e,Interaction.state2		; $5015
	ld a,(de)		; $5017
	rst_jumpTable			; $5018
	.dw _soldierSubid04Substate0
	.dw _soldierSubid04Substate1
	.dw _soldierSubid04Substate2
	.dw _soldierSubid04Substate3
	.dw _soldierSubid04Substate4

_soldierSubid04Substate0:
	ld a,($cfd1)		; $5023
	cp $06			; $5026
	jr nz,_soldierUpdateAnimationAndRunScript	; $5028

	call interactionIncState2		; $502a
	ld l,Interaction.counter1		; $502d
	ld (hl),30		; $502f
	xor a			; $5031
	jp interactionSetAnimation		; $5032

_soldierUpdateAnimationAndRunScript:
	call interactionAnimateBasedOnSpeed		; $5035
	jp interactionRunScript		; $5038

_soldierSubid04Substate1:
	call interactionAnimate		; $503b
	call interactionDecCounter1		; $503e
	ret nz			; $5041
	call interactionIncState2		; $5042
	ld bc,$fe40		; $5045
	call objectSetSpeedZ		; $5048
	ld a,SND_JUMP		; $504b
	jp playSound		; $504d

_soldierSubid04Substate2:
	ld c,$20		; $5050
	call objectUpdateSpeedZ_paramC		; $5052
	ret nz			; $5055
	call interactionIncState2		; $5056
	ld l,Interaction.counter1		; $5059
	ld (hl),$08		; $505b
	ld a,$02		; $505d
	jp interactionSetAnimation		; $505f

_soldierSubid04Substate3:
	call interactionDecCounter1		; $5062
	ret nz			; $5065
	ld l,Interaction.angle		; $5066
	ld (hl),$10		; $5068
	ld l,Interaction.speed		; $506a
	ld (hl),SPEED_200		; $506c
	jp interactionIncState2		; $506e

_soldierSubid04Substate4:
	call objectApplySpeed		; $5071
	call objectCheckWithinScreenBoundary		; $5074
	jp nc,interactionDelete		; $5077
	jp interactionAnimateBasedOnSpeed		; $507a


; Guard escorting Link in intermediate screens (just moves straight up)
_soldierSubid05:
	call checkInteractionState		; $507d
	jr nz,@state1	; $5080

@state0:
	call _soldierCheckBeatD6		; $5082
	jp nc,interactionDelete		; $5085

	ld a,GLOBALFLAG_0b		; $5088
	call checkGlobalFlag		; $508a
	jp nz,interactionDelete		; $508d

	call _soldierInitGraphicsAndLoadScript		; $5090
	xor a			; $5093
	call interactionSetAnimation		; $5094
	ld hl,w1Link.xh		; $5097
	ld (hl),$50		; $509a
	jp objectSetVisible82		; $509c

@state1:
	call objectCheckWithinScreenBoundary		; $509f
	jp nc,interactionDelete		; $50a2
	call objectGetTileAtPosition		; $50a5
	cp TILEINDEX_STAIRS			; $50a8
	ld a,SPEED_100		; $50aa
	jr nz,+			; $50ac
	ld a,SPEED_a0		; $50ae
+
	ld e,Interaction.speed		; $50b0
	ld (de),a		; $50b2
	call interactionRunScript		; $50b3
	jp interactionAnimate2Times		; $50b6


; Guard in cutscene who takes mystery seeds from Link
_soldierSubid06:
	call checkInteractionState		; $50b9
	jr nz,@state1	; $50bc

	call _soldierCheckBeatD6		; $50be
	jp nc,interactionDelete		; $50c1
	ld a,GLOBALFLAG_0b		; $50c4
	call checkGlobalFlag		; $50c6
	jp nz,interactionDelete		; $50c9

	call _soldierInitGraphicsAndLoadScript		; $50cc
	xor a			; $50cf
	call interactionSetAnimation		; $50d0
	jp objectSetVisible82		; $50d3

@state1:
	call checkInteractionState2		; $50d6
	jr nz,@substate1	; $50d9

@substate0:
	ld a,(w1Link.yh)		; $50db
	cp $68			; $50de
	jr nz,@substate1	; $50e0

	xor a			; $50e2
	ld (wUseSimulatedInput),a		; $50e3
	inc a			; $50e6
	ld (wDisabledObjects),a		; $50e7
	call interactionIncState2		; $50ea

@substate1:
	jp _soldierUpdateAnimationAndRunScript		; $50ed


; Guard just after Link is escorted out of the palace
_soldierSubid07:
	call checkInteractionState		; $50f0
	jr nz,@state1	; $50f3

@state0:
	call _soldierCheckBeatD6		; $50f5
	jp nc,interactionDelete		; $50f8
	call _soldierInitGraphicsAndLoadScript		; $50fb
	jp objectSetVisible82		; $50fe

@state1:
	call interactionRunScript		; $5101
	jp interactionAnimateAsNpc		; $5104


; Used in a cutscene? (doesn't do anything)
_soldierSubid08:
	call checkInteractionState		; $5107
	jr nz,@state1		; $510a

@state0:
	call _soldierInitGraphics		; $510c
	ld l,Interaction.oamFlags		; $510f
	ld (hl),$03		; $5111
	jp objectSetVisible82		; $5113

@state1:
	callab scriptHlp.turnToFaceSomething		; $5116
	jp interactionAnimate		; $511e


; Red soldier that brings you to Ambi (escorts you from deku forest)
_soldierSubid0a:
	call checkInteractionState		; $5121
	jr nz,@state1		; $5124

@state0:
	call _soldierInitGraphicsAndLoadScript		; $5126
	ld l,Interaction.oamFlags		; $5129
	ld (hl),$02		; $512b
	ld bc,$68f0		; $512d
	jp interactionSetPosition		; $5130

@state1:
	call _soldierUpdateAnimationAndRunScript		; $5133
	ret nc			; $5136
	ld hl,wcc05		; $5137
	set 1,(hl)		; $513a
	ld hl,@warpDest		; $513c
	jp setWarpDestVariables		; $513f

@warpDest:
	.db $81 $46 $00 $34 $03


; Red soldier that brings you to Ambi (just standing there after taking you)
_soldierSubid0b:
	call checkInteractionState		; $5147
	jp nz,interactionAnimate		; $514a

@state0:
	ld a,GLOBALFLAG_0b		; $514d
	call checkGlobalFlag		; $514f
	jp nz,interactionDelete		; $5152

	ld a,TREASURE_MYSTERY_SEEDS		; $5155
	call checkTreasureObtained		; $5157
	jp nc,interactionDelete		; $515a

	call _soldierInitGraphics		; $515d
	ld l,Interaction.oamFlags		; $5160
	ld (hl),$02		; $5162
	ld a,$01		; $5164
	call interactionSetAnimation		; $5166
	jp objectSetVisible82		; $5169


; Friendly soldier after finishing game. var03 is soldier index.
_soldierSubid0d:
	call checkInteractionState		; $516c
	jr nz,@state1		; $516f

@state0:
	ld a,GLOBALFLAG_FINISHEDGAME		; $5171
	call checkGlobalFlag		; $5173
	jp z,interactionDelete		; $5176

	call _soldierInitGraphicsAndLoadScript		; $5179
	ld e,Interaction.var03		; $517c
	ld a,(de)		; $517e
	ld l,Interaction.oamFlags		; $517f
	ld (hl),$01		; $5181
	cp $07			; $5183
	jr c,+			; $5185
	inc (hl)		; $5187
+
	ld bc,@behaviours		; $5188
	call addAToBc		; $518b
	ld a,(bc)		; $518e
	ld l,Interaction.var3b		; $518f
	ld (hl),a		; $5191
	call interactionRunScript		; $5192
	jr @state1		; $5195

@behaviours:
	.db $01 $02 $00 $00 $00 $00 $00 $03
	.db $00 $00 $00 $00 $00 $00 $00 $00

@state1:
	call interactionRunScript		; $51a7
	jp c,interactionDelete		; $51aa

	ld e,Interaction.var3b		; $51ad
	ld a,(de)		; $51af
	or a			; $51b0
	jr nz,++		; $51b1
	call interactionRunScript		; $51b3
	jp c,interactionDelete		; $51b6
	jp npcFaceLinkAndAnimate		; $51b9
++
	ld e,Interaction.var3f		; $51bc
	ld a,(de)		; $51be
	or a			; $51bf
	jp z,npcFaceLinkAndAnimate		; $51c0

	call interactionAnimateBasedOnSpeed		; $51c3
	jp interactionPushLinkAwayAndUpdateDrawPriority		; $51c6


_soldierInitGraphics:
	call interactionInitGraphics		; $51c9
	call objectMarkSolidPosition		; $51cc
	jp interactionIncState		; $51cf


_soldierInitGraphicsAndLoadScript:
	call interactionInitGraphics		; $51d2
	call objectMarkSolidPosition		; $51d5
	ld e,Interaction.subid		; $51d8
	ld a,(de)		; $51da
	ld hl,_soldierScriptTable		; $51db
	rst_addDoubleIndex			; $51de
	ldi a,(hl)		; $51df
	ld h,(hl)		; $51e0
	ld l,a			; $51e1
	call interactionSetScript		; $51e2
	jp interactionIncState		; $51e5


linkEnterPalaceSimulatedInput:
	dwb $7fff BTN_UP
	.dw $ffff

linkExitPalaceSimulatedInput
	dwb 30    $00
	dwb 40    BTN_DOWN
	dwb $7fff $00
	.dw $ffff

;;
; @param[out]	cflag	nc if dungeon 6 is beaten (can enter the palace)
; @addr{51f8}
_soldierCheckBeatD6:
	ld a,TREASURE_ESSENCE		; $51f8
	call checkTreasureObtained		; $51fa
	jr nc,++		; $51fd
	call getHighestSetBit		; $51ff
	cp $05			; $5202
	ret			; $5204
++
	scf			; $5205
	ret			; $5206

; @addr{5207}
_soldierScriptTable:
	.dw soldierSubid00Script
	.dw soldierSubid01Script
	.dw soldierSubid02Script
	.dw soldierSubid03Script
	.dw soldierSubid04Script
	.dw soldierSubid05Script
	.dw soldierSubid06Script
	.dw soldierSubid07Script
	.dw stubScript
	.dw soldierSubid09Script
	.dw soldierSubid0aScript
	.dw stubScript
	.dw soldierSubid0cScript
	.dw soldierSubid0dScript

; ==============================================================================
; INTERACID_MISC_MAN
; ==============================================================================
interactionCode41:
	ld e,Interaction.subid		; $5223
	ld a,(de)		; $5225
	rst_jumpTable			; $5226
	.dw @subid0
	.dw @subidNonzero
	.dw @subidNonzero
	.dw @subidNonzero
	.dw @subidNonzero
	.dw @subidNonzero
	.dw @subidNonzero

@subid0:
	call checkInteractionState		; $5235
	jr nz,++		; $5238
	ld a,GLOBALFLAG_FINISHEDGAME		; $523a
	call checkGlobalFlag		; $523c
	jp nz,interactionDelete		; $523f
	ld a,GLOBALFLAG_0b		; $5242
	call checkGlobalFlag		; $5244
	jp nz,interactionDelete		; $5247
	call @initGraphicsIncStateAndLoadScript		; $524a
++
	call interactionRunScript		; $524d
	jp npcFaceLinkAndAnimate		; $5250

@subidNonzero:
	call checkInteractionState		; $5253
	jr nz,@@initialized	; $5256

	ld a,$01		; $5258
	ld e,Interaction.oamFlags		; $525a
	ld (de),a		; $525c

	callab getGameProgress_1		; $525d
	ld e,Interaction.subid		; $5265
	ld a,(de)		; $5267
	dec a			; $5268
	cp b			; $5269
	jp nz,interactionDelete		; $526a

	ld hl,@scriptTable+2		; $526d
	rst_addDoubleIndex			; $5270
	ldi a,(hl)		; $5271
	ld h,(hl)		; $5272
	ld l,a			; $5273
	call interactionSetScript		; $5274

	ld a,>TX_2600		; $5277
	call interactionSetHighTextIndex		; $5279
	call @initGraphicsAndIncState		; $527c

@@initialized:
	call interactionRunScript		; $527f
	jp interactionAnimateAsNpc		; $5282

@initGraphicsAndIncState:
	call interactionInitGraphics		; $5285
	call objectMarkSolidPosition		; $5288
	jp interactionIncState		; $528b

;;
; @addr{528e}
@initGraphicsIncStateAndLoadScript:
	call interactionInitGraphics		; $528e
	call objectMarkSolidPosition		; $5291
	ld a,>TX_2600		; $5294
	call interactionSetHighTextIndex		; $5296
	ld e,Interaction.subid		; $5299
	ld a,(de)		; $529b
	ld hl,@scriptTable		; $529c
	rst_addDoubleIndex			; $529f
	ldi a,(hl)		; $52a0
	ld h,(hl)		; $52a1
	ld l,a			; $52a2
	call interactionSetScript		; $52a3
	jp interactionIncState		; $52a6

; @addr{52a9}
@scriptTable:
	.dw manOutsideD2Script
	.dw lynnaManScript_befored3
	.dw lynnaManScript_afterd3
	.dw lynnaManScript_afterNayruSaved
	.dw lynnaManScript_afterd7
	.dw lynnaManScript_afterGotMakuSeed
	.dw lynnaManScript_postGame


; ==============================================================================
; INTERACID_MUSTACHE_MAN
; ==============================================================================
interactionCode42:
	ld e,Interaction.subid		; $52b7
	ld a,(de)		; $52b9
	rst_jumpTable			; $52ba
	.dw @subid0
	.dw @subid1

@subid0:
	call checkInteractionState		; $52bf
	jr nz,@@initialized	; $52c2

	ld a,GLOBALFLAG_FINISHEDGAME		; $52c4
	call checkGlobalFlag		; $52c6
	jp nz,interactionDelete		; $52c9
	call @initGraphicsAndScript		; $52cc
@@initialized:
	call interactionRunScript		; $52cf
	jp interactionAnimateAsNpc		; $52d2

@subid1:
	call checkInteractionState		; $52d5
	jr nz,@@initialized	; $52d8

	ld e,Interaction.var32		; $52da
	ld a,$02		; $52dc
	ld (de),a		; $52de
	call @initGraphicsAndScript		; $52df

@@initialized:
	call interactionRunScript		; $52e2
	jp interactionAnimateAsNpc		; $52e5

; Unused
@func_52e8:
	call interactionInitGraphics		; $52e8
	call objectMarkSolidPosition		; $52eb
	jp interactionIncState		; $52ee

@initGraphicsAndScript:
	call interactionInitGraphics		; $52f1
	call objectMarkSolidPosition		; $52f4

	ld a,>TX_0f00		; $52f7
	call interactionSetHighTextIndex		; $52f9

	ld e,Interaction.subid		; $52fc
	ld a,(de)		; $52fe
	ld hl,@scriptTable		; $52ff
	rst_addDoubleIndex			; $5302
	ldi a,(hl)		; $5303
	ld h,(hl)		; $5304
	ld l,a			; $5305
	call interactionSetScript		; $5306
	jp interactionIncState		; $5309

@scriptTable:
	.dw mustacheManScript
	.dw genericNpcScript


; ==============================================================================
; INTERACID_PAST_GUY
; ==============================================================================
interactionCode43:
	ld e,Interaction.subid		; $5310
	ld a,(de)		; $5312
	rst_jumpTable			; $5313
	.dw @subid0
	.dw @subid1
	.dw @subid2
	.dw @subid3
	.dw @subid4
	.dw @subid5
	.dw @subid6
	.dw @subid7

; Guy who wants to find something Ambi desires
@subid0:
	ld a,GLOBALFLAG_FINISHEDGAME		; $5324
	call checkGlobalFlag		; $5326
	jp nz,interactionDelete		; $5329

	ld a,GLOBALFLAG_0b		; $532c
	call checkGlobalFlag		; $532e
	ld e,Interaction.var03		; $5331
	ld a,(de)		; $5333
	jr nz,+			; $5334
	or a			; $5336
	jp nz,interactionDelete		; $5337
	jr ++			; $533a
+
	or a			; $533c
	jp z,interactionDelete		; $533d
++
	call checkInteractionState		; $5340
	jr nz,+			; $5343
	call @initGraphicsIncStateAndLoadScript		; $5345
+
	call interactionRunScript		; $5348
	jp interactionAnimateAsNpc		; $534b

@subid1:
@subid2:
	call checkInteractionState		; $534e
	jr nz,@label_09_117	; $5351

	callab getGameProgress_2		; $5353
	ld c,$01		; $535b
	ld a,$05		; $535d
	call checkNpcShouldExistAtGameStage		; $535f
	jp nz,interactionDelete		; $5362

	ld a,b			; $5365
	ld hl,@subid1And2ScriptTable		; $5366
	rst_addDoubleIndex			; $5369
	ldi a,(hl)		; $536a
	ld h,(hl)		; $536b
	ld l,a			; $536c
	call interactionSetScript		; $536d

	ld a,>TX_1700		; $5370
	call interactionSetHighTextIndex		; $5372
	call @initGraphicsAndIncState		; $5375
	ld a,$03		; $5378
	ld e,Interaction.oamFlags		; $537a
	ld (de),a		; $537c

@label_09_117:
	call interactionRunScript		; $537d
	jp interactionAnimateAsNpc		; $5380


; Guy in a cutscene (turning to stone?)
@subid3:
	call checkInteractionState		; $5383
	jr nz,+			; $5386
	call @initGraphicsIncStateAndLoadScript		; $5388
	jp objectSetVisiblec2		; $538b
+
	call interactionRunScript		; $538e
	ld a,($cfd1)		; $5391
	cp $02			; $5394
	jp c,interactionAnimate		; $5396
	ret			; $5399


; Guy in a cutscene (stuck as stone?)
@subid4:
	call checkInteractionState		; $539a
	ret nz			; $539d

	call @initGraphicsAndIncState		; $539e
	ld l,Interaction.oamFlags		; $53a1
	ld (hl),$06		; $53a3
	jp objectSetVisible82		; $53a5


; Guy in a cutscene (being restored from stone?)
@subid5:
	call checkInteractionState		; $53a8
	jr nz,@@initialized	; $53ab

	call @initGraphicsIncStateAndLoadScript		; $53ad
	ld l,Interaction.oamFlags		; $53b0
	ld (hl),$06		; $53b2
	jp objectSetVisiblec2		; $53b4

@@initialized:
	ld e,Interaction.state2		; $53b7
	ld a,(de)		; $53b9
	rst_jumpTable			; $53ba
	.dw @@substate0
	.dw @@substate1
	.dw @@substate2

@@substate0:
	ld a,($cfd1)		; $53c1
	cp $01			; $53c4
	ret nz			; $53c6
	jpab interactionBank1.setCounter1To120AndPlaySoundEffectAndIncState2		; $53c7

@@substate1:
	call interactionDecCounter1		; $53cf
	jr z,+			; $53d2
	jpab interactionBank1.childFlickerBetweenStone		; $53d4
+
	call interactionIncState2		; $53dc
	ld l,Interaction.oamFlags		; $53df
	ld (hl),$02		; $53e1

	ld l,Interaction.counter1		; $53e3
	ld (hl),$a4		; $53e5
	inc l			; $53e7
	ld (hl),$01		; $53e8
	ret			; $53ea

@@substate2:
	call interactionAnimate		; $53eb
	ld l,Interaction.counter1		; $53ee
	call decHlRef16WithCap		; $53f0
	ret nz			; $53f3
	ld a,$ff		; $53f4
	ld ($cfdf),a		; $53f6
	ret			; $53f9


; Guy watching family play catch (or is stone)
@subid6:
	call checkInteractionState		; $53fa
	jr nz,@initialized	; $53fd
	ld hl,wGroup4Flags+$fc		; $53ff
	bit 7,(hl)		; $5402
	jr nz,@@initAndLoadScript	; $5404

	ld a,(wEssencesObtained)		; $5406
	bit 6,a			; $5409
	jr z,@@initAndLoadScript	; $540b

	; He's stone, set the palette accordingly.
	call @initGraphicsAndIncState		; $540d
	ld l,Interaction.oamFlags		; $5410
	ld (hl),$06		; $5412
	ld l,Interaction.var03		; $5414
	inc (hl)		; $5416

	ld a,$06		; $5417
	call objectSetCollideRadius		; $5419
	jr @initialized		; $541c

@@initAndLoadScript:
	call @initGraphicsIncStateAndLoadScript		; $541e

@initialized:
	ld e,Interaction.var03		; $5421
	ld a,(de)		; $5423
	or a			; $5424
	jp nz,interactionPushLinkAwayAndUpdateDrawPriority		; $5425
	call interactionRunScript		; $5428
	jp c,interactionDelete		; $542b
	jp interactionAnimateAsNpc		; $542e

@subid7:
	call checkInteractionState		; $5431
	jp z,+		; $5434
	ret			; $5437
+
	call @initGraphicsAndIncState		; $5438
	ld l,Interaction.oamFlags		; $543b
	ld (hl),$06		; $543d
	jp objectSetVisiblec2		; $543f

@initGraphicsAndIncState:
	call interactionInitGraphics		; $5442
	call objectMarkSolidPosition		; $5445
	jp interactionIncState		; $5448


@initGraphicsIncStateAndLoadScript:
	call interactionInitGraphics		; $544b
	call objectMarkSolidPosition		; $544e

	ld a,>TX_1700		; $5451
	call interactionSetHighTextIndex		; $5453

	ld e,Interaction.subid		; $5456
	ld a,(de)		; $5458
	ld hl,@scriptTable		; $5459
	rst_addDoubleIndex			; $545c
	ldi a,(hl)		; $545d
	ld h,(hl)		; $545e
	ld l,a			; $545f
	call interactionSetScript		; $5460
	jp interactionIncState		; $5463

; @addr{5466}
@scriptTable:
	.dw pastGuySubid0Script
	.dw stubScript
	.dw stubScript
	.dw pastGuySubid3Script
	.dw stubScript
	.dw stubScript
	.dw pastGuySubid6Script

; @addr{5474}
@subid1And2ScriptTable:
	.dw pastGuySubid1And2Script_befored4
	.dw pastGuySubid1And2Script_befored4
	.dw pastGuySubid1And2Script_afterd4
	.dw pastGuySubid1And2Script_afterNayruSaved
	.dw pastGuySubid1And2Script_afterd7
	.dw pastGuySubid1And2Script_afterGotMakuSeed
	.dw pastGuySubid1And2Script_afterGotMakuSeed
	.dw pastGuySubid1And2Script_afterGotMakuSeed


; ==============================================================================
; INTERACID_MISC_MAN_2
; ==============================================================================
interactionCode44:
	ld e,Interaction.subid		; $5484
	ld a,(de)		; $5486
	rst_jumpTable			; $5487
	.dw @subid0
	.dw @subid1
	.dw @subid2
	.dw @subid3
	.dw @subid4

; NPC giving hint about what ambi wants
@subid0:
	call checkInteractionState		; $5492
	jr nz,@@initialized	; $5495

	ld a,GLOBALFLAG_FINISHEDGAME		; $5497
	call checkGlobalFlag		; $5499
	jp nz,interactionDelete		; $549c
	call @initGraphicsIncStateAndLoadScript		; $549f

@@initialized:
	call interactionRunScript		; $54a2
	jp c,interactionDelete		; $54a5
	jp interactionAnimateAsNpc		; $54a8


; NPC in start-of-game cutscene who turns into an old man
@subid1:
	call checkInteractionState		; $54ab
	jr nz,+			; $54ae
	call @initGraphicsIncStateAndLoadScript		; $54b0
+
	call interactionRunScript		; $54b3
	jp interactionAnimateBasedOnSpeed		; $54b6


; Bearded NPC in Lynna City
@subid2:
@subid3:
	call checkInteractionState		; $54b9
	jr nz,@@initialized	; $54bc

	call getGameProgress_1		; $54be
	ld c,$02		; $54c1
	ld a,$06		; $54c3
	call checkNpcShouldExistAtGameStage_body		; $54c5
	jp nz,interactionDelete		; $54c8

	ld a,b			; $54cb
	ld hl,lynnaMan2ScriptTable		; $54cc
	rst_addDoubleIndex			; $54cf
	ldi a,(hl)		; $54d0
	ld h,(hl)		; $54d1
	ld l,a			; $54d2
	call interactionSetScript		; $54d3
	call @initGraphicsAndIncState		; $54d6

@@initialized:
	call interactionRunScript		; $54d9
	jp interactionAnimateAsNpc		; $54dc


; Bearded hobo in the past, outside shooting gallery
@subid4:
	call checkInteractionState		; $54df
	jr nz,@@initialized	; $54e2
	call getGameProgress_2		; $54e4
	ld a,b			; $54e7
	cp $03			; $54e8
	jp z,interactionDelete		; $54ea

	cp $06			; $54ed
	jr nz,++		; $54ef

	ld bc,$5878		; $54f1
	call interactionSetPosition		; $54f4
	ld a,$06		; $54f7
++
	ld hl,pastHoboScriptTable		; $54f9
	rst_addDoubleIndex			; $54fc
	ldi a,(hl)		; $54fd
	ld h,(hl)		; $54fe
	ld l,a			; $54ff
	call interactionSetScript		; $5500
	call @initGraphicsAndIncState		; $5503

@@initialized:
	call interactionRunScript		; $5506
	jp interactionAnimateAsNpc		; $5509


@initGraphicsAndIncState:
	call interactionInitGraphics		; $550c
	call objectMarkSolidPosition		; $550f
	jp interactionIncState		; $5512


@initGraphicsIncStateAndLoadScript:
	call interactionInitGraphics		; $5515
	call objectMarkSolidPosition		; $5518
	ld e,Interaction.subid		; $551b
	ld a,(de)		; $551d
	ld hl,miscMan2ScriptTable		; $551e
	rst_addDoubleIndex			; $5521
	ldi a,(hl)		; $5522
	ld h,(hl)		; $5523
	ld l,a			; $5524
	call interactionSetScript		; $5525
	jp interactionIncState		; $5528

;;
; @param[out]	b	$00 before beating d3;
;			$01 if beat d3
;			$02 if saved Nayru;
;			$03 if beat d7;
;			$04 if got the maku seed (saw twinrova cutscene);
;			$05 if game finished (unlinked only)
; @addr{552b}
getGameProgress_1:
	ld b,$05		; $552b
	ld a,GLOBALFLAG_FINISHEDGAME		; $552d
	call checkGlobalFlag		; $552f
	ret nz			; $5532

	dec b			; $5533
	ld a,GLOBALFLAG_SAW_TWINROVA_BEFORE_ENDGAME		; $5534
	call checkGlobalFlag		; $5536
	ret nz			; $5539

	ld a,TREASURE_ESSENCE		; $553a
	call checkTreasureObtained		; $553c
	jr nc,@noEssences	; $553f

	call getHighestSetBit		; $5541
	ld c,a			; $5544
	ld b,$03		; $5545
	cp $06			; $5547
	ret nc			; $5549

	dec b			; $554a
	ld a,GLOBALFLAG_SAVED_NAYRU		; $554b
	call checkGlobalFlag		; $554d
	ret nz			; $5550

	dec b			; $5551
	ld a,c			; $5552
	cp $02			; $5553
	ret nc			; $5555

@noEssences:
	ld b,$00		; $5556
	ret			; $5558

;;
; @param[out]	b	$00 before beating d2;
;			$01 if beat d2;
;			$02 if beat d4;
;			$03 if saved nayru;
;			$04 if beat d7;
;			$05 if got the maku seed (saw twinrova cutscene);
;			$06 if beat veran but not twinrova (linked only);
;			$07 if game finished (unlinked only)
; @addr{5559}
getGameProgress_2:
	ld b,$07		; $5559
	ld a,GLOBALFLAG_FINISHEDGAME		; $555b
	call checkGlobalFlag		; $555d
	ret nz			; $5560

	dec b			; $5561
	call checkIsLinkedGame		; $5562
	jr z,+			; $5565
	ld hl,wGroup4Flags+$fc		; $5567
	bit 7,(hl)		; $556a
	ret nz			; $556c
+
	dec b			; $556d
	ld a,GLOBALFLAG_SAW_TWINROVA_BEFORE_ENDGAME		; $556e
	call checkGlobalFlag		; $5570
	ret nz			; $5573

	ld a,TREASURE_ESSENCE		; $5574
	call checkTreasureObtained		; $5576
	jr nc,@noEssences	; $5579

	call getHighestSetBit		; $557b
	ld c,a			; $557e
	ld b,$04		; $557f
	cp $06			; $5581
	ret nc			; $5583

	dec b			; $5584
	ld a,GLOBALFLAG_SAVED_NAYRU		; $5585
	call checkGlobalFlag		; $5587
	ret nz			; $558a

	dec b			; $558b
	ld a,c			; $558c
	cp $03			; $558d
	ret nc			; $558f
	dec b			; $5590
	ld a,c			; $5591
	cp $01			; $5592
	ret nc			; $5594

@noEssences:
	ld b,$00		; $5595
	ret			; $5597


;;
; @addr{5598}
_unusedFunc5598:
	ld a,b			; $5598
	ld hl,lynnaMan2ScriptTable		; $5599
	rst_addDoubleIndex			; $559c
	ldi a,(hl)		; $559d
	ld h,(hl)		; $559e
	ld l,a			; $559f
	call interactionSetScript		; $55a0
	jp interactionIncState		; $55a3

;;
; Contains some preset data for checking whether certain interactions should exist at
; certain points in the game?
;
; @param	a	(0-8)
; @param	b	Return value from "getGameProgress_1"?
; @param	c	Subid "base"
; @param[out]	zflag	Set if the npc should exist
; @addr{55a6}
checkNpcShouldExistAtGameStage_body:
	ld hl,@table		; $55a6
	rst_addDoubleIndex			; $55a9
	ldi a,(hl)		; $55aa
	ld h,(hl)		; $55ab
	ld l,a			; $55ac

	ld e,Interaction.subid		; $55ad
	ld a,(de)		; $55af
	sub c			; $55b0
	rst_addDoubleIndex			; $55b1

	ldi a,(hl)		; $55b2
	ld h,(hl)		; $55b3
	ld l,a			; $55b4
--
	ldi a,(hl)		; $55b5
	cp b			; $55b6
	ret z			; $55b7
	inc a			; $55b8
	jr z,+			; $55b9
	jr --			; $55bb
+
	or $01			; $55bd
	ret			; $55bf

@table:
	.dw @data0
	.dw @data1
	.dw @data2
	.dw @data3
	.dw @data4
	.dw @data5
	.dw @data6

@data0: ; INTERACID_FEMALE_VILLAGER subids 1-2
	.dw @@subid1
	.dw @@subid2
@@subid1:
	.db $00 $01 $02 $ff
@@subid2:
	.db $03 $04 $05 $ff


@data1: ; INTERACID_FEMALE_VILLAGER subids 3-4
	.dw @@subid3
	.dw @@subid4
@@subid3:
	.db $00 $02 $03 $04 $05 $06 $07 $ff
@@subid4:
	.db $01 $ff


@data2: ; INTERACID_FEMALE_VILLAGER subid 5
	.dw @@subid5
@@subid5:
	.db $00 $01 $02 $03 $05 $06 $ff


@data3: ; INTERACID_VILLAGER subids 4-5
	.dw @@subid4
	.dw @@subid5
@@subid4:
	.db $00 $01 $05 $ff
@@subid5:
	.db $04 $ff


@data4: ; INTERACID_VILLAGER subids 6-7
	.dw @@subid6
	.dw @@subid7

@@subid6:
	.db $00 $01 $02 $ff
@@subid7:
	.db $03 $04 $05 $06 $07 $ff


@data5: ; INTERACID_PAST_GUY subids 1-2
	.dw @@subid1
	.dw @@subid2

@@subid1:
	.db $01 $02 $ff
@@subid2:
	.db $03 $04 $07 $ff


@data6: ; INTERACID_MISC_MAN_2 subids 2-3
	.dw @@subid2
	.dw @@subid3
@@subid2:
	.db $00 $01 $02 $ff
@@subid3:
	.db $03 $04 $05 $ff



miscMan2ScriptTable:
	.dw pastHobo2Script
	.dw npcTurnedToOldManCutsceneScript
	.dw stubScript
	.dw stubScript
	.dw stubScript

lynnaMan2ScriptTable:
	.dw lynnaMan2Script_befored3
	.dw lynnaMan2Script_afterd3
	.dw lynnaMan2Script_afterNayruSaved
	.dw lynnaMan2Script_afterd7
	.dw lynnaMan2Script_afterGotMakuSeed
	.dw lynnaMan2Script_postGame

pastHoboScriptTable:
	.dw pastHoboScript_befored2
	.dw pastHoboScript_afterd2
	.dw pastHoboScript_afterd4
	.dw pastHoboScript_afterSavedNayru
	.dw pastHoboScript_afterSavedNayru
	.dw pastHoboScript_afterGotMakuSeed
	.dw pastHoboScript_twinrovaKidnappedZelda
	.dw pastHoboScript_postGame


; ==============================================================================
; INTERACID_PAST_OLD_LADY
; ==============================================================================
interactionCode45:
	ld e,Interaction.subid		; $5646
	ld a,(de)		; $5648
	rst_jumpTable			; $5649
	.dw @subid0
	.dw @subid1


; Lady whose husband was sent to work on black tower
@subid0:
	call checkInteractionState		; $564e
	jr nz,@@initialized	; $5651

	ld a,GLOBALFLAG_FINISHEDGAME		; $5653
	call checkGlobalFlag		; $5655
	jp nz,interactionDelete		; $5658
	call @initGraphicsTextAndScript		; $565b

@@initialized:
	call interactionRunScript		; $565e
	jp interactionAnimateAsNpc		; $5661


@subid1:
	call checkInteractionState		; $5664
	jr nz,@@initialized			; $5667

	callab getGameProgress_2		; $5669
	ld a,b			; $5671
	cp $04			; $5672
	jp nc,interactionDelete		; $5674

	ld hl,@subid1ScriptTable		; $5677
	rst_addDoubleIndex			; $567a
	ldi a,(hl)		; $567b
	ld h,(hl)		; $567c
	ld l,a			; $567d
	call interactionSetScript		; $567e

	ld a,>TX_1800		; $5681
	call interactionSetHighTextIndex		; $5683
	call @initGraphicsAndIncState		; $5686

@@initialized:
	call interactionRunScript		; $5689
	jp interactionAnimateAsNpc		; $568c


@initGraphicsAndIncState:
	call interactionInitGraphics		; $568f
	call objectMarkSolidPosition		; $5692
	jp interactionIncState		; $5695


@initGraphicsTextAndScript:
	call interactionInitGraphics		; $5698
	call objectMarkSolidPosition		; $569b
	ld a,>TX_1800		; $569e
	call interactionSetHighTextIndex		; $56a0
	ld e,Interaction.subid		; $56a3
	ld a,(de)		; $56a5
	ld hl,@scriptTable		; $56a6
	rst_addDoubleIndex			; $56a9
	ldi a,(hl)		; $56aa
	ld h,(hl)		; $56ab
	ld l,a			; $56ac
	call interactionSetScript		; $56ad
	jp interactionIncState		; $56b0


@scriptTable:
	.dw pastOldLadySubid0Script
	.dw stubScript

@subid1ScriptTable:
	.dw pastOldLadySubid1Script_befored2
	.dw pastOldLadySubid1Script_afterd2
	.dw pastOldLadySubid1Script_afterd4
	.dw pastOldLadySubid1Script_afterSavedNayru


; ==============================================================================
; INTERACID_TOKAY
; ==============================================================================
interactionCode48:
	ld e,Interaction.state		; $56bf
	ld a,(de)		; $56c1
	rst_jumpTable			; $56c2
	.dw @state0
	.dw _tokayState1

@state0:
	ld a,$01		; $56c7
	ld (de),a		; $56c9
	call interactionInitGraphics		; $56ca
	call objectSetVisiblec2		; $56cd

	ld a,>TX_0a00		; $56d0
	call interactionSetHighTextIndex		; $56d2

	call @initSubid		; $56d5

	ld e,Interaction.enabled		; $56d8
	ld a,(de)		; $56da
	or a			; $56db
	jp nz,objectMarkSolidPosition		; $56dc
	ret			; $56df

@initSubid:
	ld e,Interaction.subid		; $56e0
	ld a,(de)		; $56e2
	rst_jumpTable			; $56e3
	.dw @initSubid00
	.dw @initSubid01
	.dw @initSubid02
	.dw @initSubid03
	.dw @initSubid04
	.dw @initSubid05
	.dw @initSubid06
	.dw @initSubid07
	.dw @initSubid08
	.dw @initSubid09
	.dw @initSubid0a
	.dw @initSubid0b
	.dw @initSubid0c
	.dw @initSubid0d
	.dw @initSubid0e
	.dw @initSubid0f
	.dw @initSubid10
	.dw @initSubid11
	.dw @initSubid12
	.dw @initSubid13
	.dw @initSubid14
	.dw @initSubid15
	.dw @initSubid16
	.dw @initSubid17
	.dw @initSubid18
	.dw @initSubid19
	.dw @initSubid1a
	.dw @initSubid1b
	.dw @initSubid1c
	.dw @initSubid1d
	.dw @initSubid1e
	.dw @initSubid1f


; Subid $00-$04: Tokays who rob Link

@initSubid00:
@initSubid03:
	ld a,$01		; $5724
	jr @initLinkRobberyTokay		; $5726

@initSubid01:
@initSubid04:
	ld a,$03		; $5728
	jr @initLinkRobberyTokay		; $572a

@initSubid02:
	call getThisRoomFlags		; $572c
	bit 6,a			; $572f
	jp nz,@deleteSelf		; $5731

	xor a			; $5734
	call interactionSetAnimation		; $5735
	call _tokayLoadScript		; $5738

	; Set the Link object to run the cutscene where he gets mugged
	ld a,SPECIALOBJECTID_LINK_CUTSCENE		; $573b
	call setLinkIDOverride		; $573d
	ld l,<w1Link.subid		; $5740
	ld (hl),$07		; $5742

	ld e,Interaction.var38		; $5744
	ld a,$46		; $5746
	ld (de),a		; $5748

	ld a,SNDCTRL_STOPMUSIC		; $5749
	jp playSound		; $574b

@initLinkRobberyTokay:
	call interactionSetAnimation		; $574e
	call getThisRoomFlags		; $5751
	bit 6,a			; $5754
	jp nz,@deleteSelf		; $5756
	jp _tokayLoadScript		; $5759


; NPC holding shield upgrade
@initSubid1d:
	call _tokayLoadScript		; $575c
	call getThisRoomFlags		; $575f
	bit 6,a			; $5762
	ld a,$02		; $5764
	jp nz,interactionSetAnimation		; $5766

	; Set up an "accessory" object (the shield he's holding)
	ld b,$14		; $5769
	ld a,(wShieldLevel)		; $576b
	cp $02			; $576e
	jr c,+			; $5770
	ld b,$15		; $5772
+
	ld a,b			; $5774
	ld e,Interaction.var03		; $5775
	ld (de),a		; $5777
	call getFreeInteractionSlot		; $5778
	ret nz			; $577b

	inc l			; $577c
	ld (hl),b ; [subid] = b (graphic for the accessory)
	dec l			; $577e
	call _tokayInitAccessory		; $577f

	ld a,$06		; $5782
	jp interactionSetAnimation		; $5784


; Past NPC holding shovel
@initSubid07:
	call checkIsLinkedGame		; $5787
	jp nz,interactionDelete		; $578a

; Past NPC holding something (sword, harp, etc)
@initSubid06:
@initSubid08:
@initSubid09:
@initSubid0a:
	call _tokayLoadScript		; $578d

	; Set var03 to the item being held
	ld h,d			; $5790
	ld l,Interaction.subid		; $5791
	ld a,(hl)		; $5793
	sub $06			; $5794
	ld bc,tokayIslandStolenItems		; $5796
	call addAToBc		; $5799
	ld a,(bc)		; $579c
	ld l,Interaction.var03		; $579d
	ld (hl),a		; $579f

	; Check if the item has been retrieved already
	ld c,$00		; $57a0
	call getThisRoomFlags		; $57a2
	bit 6,a			; $57a5
	jr z,@@endLoop			; $57a7

	; Check if Link is still missing any items.
	inc c			; $57a9
	ld b,$09		; $57aa
@@nextItem:
	ld a,b			; $57ac
	dec a			; $57ad

	ld hl,tokayIslandStolenItems		; $57ae
	rst_addAToHl			; $57b1
	ld a,(hl)		; $57b2
	cp TREASURE_SHIELD			; $57b3
	jr z,+			; $57b5

	call checkTreasureObtained		; $57b7
	jp nc,@@endLoop		; $57ba
+
	dec b			; $57bd
	jr nz,@@nextItem	; $57be
	inc c			; $57c0

@@endLoop:
	; var3c gets set to:
	; * 0 if Link hasn't retrieved this tokay's item yet;
	; * 1 if Link has retrieved the item, but others are still missing;
	; * 2 if Link has retrieved all of his items from the tokays.
	ld a,c			; $57c1
	ld e,Interaction.var3c		; $57c2
	ld (de),a		; $57c4
	or a			; $57c5
	jr nz,@@retrievedItem	; $57c6

; Link has not retrieved this tokay's item yet.

	ld a,$06		; $57c8
	call interactionSetAnimation		; $57ca

	ld e,Interaction.subid		; $57cd
	ld a,(de)		; $57cf
	ld b,<TX_0a0a		; $57d0

	; Shovel NPC says something a bit different
	cp $07			; $57d2
	jr z,+			; $57d4
	ld b,<TX_0a0b		; $57d6
+
	ld h,d			; $57d8
	ld l,Interaction.textID		; $57d9
	ld (hl),b		; $57db
	sub $06			; $57dc
	ld b,a			; $57de
	jp _tokayInitHeldItem		; $57df

@@retrievedItem:
	ld a,$02		; $57e2
	jp interactionSetAnimation		; $57e4


; Past NPC looking after scent seedling
@initSubid11:
	call getThisRoomFlags		; $57e7
	bit 7,a			; $57ea
	jr z,@initSubid0e	; $57ec

	; Seedling has been planted
	ld e,Interaction.xh		; $57ee
	ld a,(de)		; $57f0
	add $10			; $57f1
	ld (de),a		; $57f3
	call objectMarkSolidPosition		; $57f4
	jr @initSubid0e		; $57f7


; Present NPC who talks to you after climbing down vine
@initSubid1e:
	call objectMakeTileSolid		; $57f9
	ld h,>wRoomLayout		; $57fc
	ld (hl),$00		; $57fe
	jr @initSubid0e		; $5800


; Subid $0f-$10: Tokays who try to eat Dimitri
@initSubid0f:
	ld a,$01		; $5802
	jr ++			; $5804

@initSubid10:
	xor a			; $5806
++
	call interactionSetAnimation		; $5807

	ld hl,wDimitriState		; $580a
	bit 1,(hl)		; $580d
	jr nz,@deleteSelf	; $580f

	ld l,<wEssencesObtained		; $5811
	bit 2,(hl)		; $5813
	jr z,@deleteSelf	; $5815

	ld e,Interaction.speed		; $5817
	ld a,SPEED_200		; $5819
	ld (de),a		; $581b
	; Fall through


; Shopkeeper (trades items)
@initSubid0e:
	ld a,$06		; $581c
	call objectSetCollideRadius		; $581e
	; Fall through


; NPC who trades meat for stink bag
@initSubid05:
	call interactionSetAlwaysUpdateBit		; $5821
	call _tokayLoadScript		; $5824
	jp _tokayState1		; $5827


@deleteSelf:
	jp interactionDelete		; $582a


; Linked game cutscene where tokay runs away from Rosa
@initSubid0b:
	call checkIsLinkedGame		; $582d
	jp z,interactionDelete		; $5830

	ld a,TREASURE_SHOVEL		; $5833
	call checkTreasureObtained		; $5835
	jp c,interactionDelete		; $5838

	call getThisRoomFlags		; $583b
	bit 7,a			; $583e
	jp nz,interactionDelete		; $5840

	ld a,$01		; $5843
	ld (wDiggingUpEnemiesForbidden),a		; $5845
	jp _tokayLoadScript		; $5848


; Participant in Wild Tokay game
@initSubid0c:
	; If this is the last tokay, make it red
	ld h,d			; $584b
	ld a,(wTmpcfc0.wildTokay.cfdf)		; $584c
	or a			; $584f
	jr z,+			; $5850
	ld l,Interaction.oamFlags		; $5852
	ld (hl),$02		; $5854
+
	ld l,Interaction.angle		; $5856
	ld (hl),$10		; $5858
	ld l,Interaction.counter2		; $585a
	inc (hl)		; $585c

	ld l,Interaction.xh		; $585d
	ld a,(hl)		; $585f
	cp $88			; $5860
	jr z,+			; $5862

	; Direction variable functions to determine what side he's on?
	; 0 for right side, 1 for left side?
	ld l,Interaction.direction		; $5864
	inc (hl)		; $5866
+
	ld a,(wWildTokayGameLevel)		; $5867
	ld hl,@speedTable		; $586a
	rst_addAToHl			; $586d
	ld a,(hl)		; $586e
	ld e,Interaction.speed		; $586f
	ld (de),a		; $5871
	ret			; $5872

@speedTable:
	.db SPEED_80
	.db SPEED_80
	.db SPEED_80
	.db SPEED_a0
	.db SPEED_a0


; Past NPC in charge of wild tokay game
@initSubid0d:
	call getThisRoomFlags		; $5878
	bit 6,a			; $587b
	jr z,@@gameNotActive	; $587d

	ld a,$81		; $587f
	ld (wDisabledObjects),a		; $5881
	ld (wMenuDisabled),a		; $5884
	ld hl,w1Link.yh		; $5887
	ld (hl),$48		; $588a
	ld l,<w1Link.xh		; $588c
	ld (hl),$50		; $588e
	xor a			; $5890
	ld l,<w1Link.direction		; $5891
	ld (hl),a		; $5893

@@gameNotActive:
	ld h,d			; $5894
	ld l,Interaction.oamFlags		; $5895
	ld (hl),$03		; $5897
	jp _tokayLoadScript		; $5899


; Generic NPCs
@initSubid12:
@initSubid13:
@initSubid14:
@initSubid15:
@initSubid16:
@initSubid17:
@initSubid18:
	ld e,Interaction.subid		; $589c
	ld a,(de)		; $589e
	sub $12			; $589f
	ld hl,@textIndices		; $58a1
	rst_addAToHl			; $58a4
	ld e,Interaction.textID		; $58a5
	ld a,(hl)		; $58a7
	ld (de),a		; $58a8
	jp _tokayLoadScript		; $58a9

@textIndices:
	.db <TX_0a64 ; Subid $12
	.db <TX_0a65 ; Subid $13
	.db <TX_0a66 ; Subid $14
	.db <TX_0a60 ; Subid $15
	.db <TX_0a61 ; Subid $16
	.db <TX_0a62 ; Subid $17
	.db <TX_0a63 ; Subid $18


; Present NPC in charge of the wild tokay museum
@initSubid19:
	call @initSubid0d		; $58b3
	jp _tokayLoadScript		; $58b6


; Subid $1a-$ac: Tokay "statues" in the wild tokay museum

@initSubid1a:
	ld e,Interaction.oamFlags		; $58b9
	ld a,$02		; $58bb
	ld (de),a		; $58bd
	ld e,Interaction.animCounter		; $58be
	ld a,$01		; $58c0
	ld (de),a		; $58c2
	jp interactionAnimate		; $58c3

@initSubid1c:
	ld a,$09		; $58c6
	call interactionSetAnimation		; $58c8
	call _tokayInitMeatAccessory		; $58cb

@initSubid1b:
	ret			; $58ce


; Past NPC standing on cliff at north shore
@initSubid1f:
	ld e,Interaction.textID		; $58cf
	ld a,<TX_0a6c		; $58d1
	ld (de),a		; $58d3
	jp _tokayLoadScript		; $58d4




_tokayState1:
	ld e,Interaction.subid		; $58d7
	ld a,(de)		; $58d9
	rst_jumpTable			; $58da
	.dw _tokayRunSubid00
	.dw _tokayRunSubid01
	.dw _tokayRunSubid02
	.dw _tokayRunSubid03
	.dw _tokayRunSubid04
	.dw _tokayRunSubid05
	.dw _tokayRunSubid06
	.dw _tokayRunSubid07
	.dw _tokayRunSubid08
	.dw _tokayRunSubid09
	.dw _tokayRunSubid0a
	.dw _tokayRunSubid0b
	.dw _tokayRunSubid0c
	.dw _tokayRunSubid0d
	.dw _tokayRunSubid0e
	.dw _tokayRunSubid0f
	.dw _tokayRunSubid10
	.dw _tokayRunSubid11
	.dw _tokayRunSubid12
	.dw _tokayRunSubid13
	.dw _tokayRunSubid14
	.dw _tokayRunSubid15
	.dw _tokayRunSubid16
	.dw _tokayRunSubid17
	.dw _tokayRunSubid18
	.dw _tokayRunSubid19
	.dw _tokayRunSubid1a
	.dw _tokayRunSubid1b
	.dw _tokayRunSubid1c
	.dw _tokayRunSubid1d
	.dw _tokayRunSubid1e
	.dw _tokayRunSubid1f


; Tokays in cutscene who steal your stuff
_tokayRunSubid00:
_tokayRunSubid01:
_tokayRunSubid02:
_tokayRunSubid03:
_tokayRunSubid04:
	ld e,Interaction.state2		; $591b
	ld a,(de)		; $591d
	rst_jumpTable			; $591e
	.dw _tokayThiefSubstate0
	.dw _tokayThiefSubstate1
	.dw _tokayThiefSubstate2
	.dw _tokayThiefSubstate3
	.dw _tokayThiefSubstate4
	.dw _tokayThiefSubstate5
	.dw _tokayThiefSubstate6


; Substate 0: In the process of removing items from Link's inventory
_tokayThiefSubstate0:
	ld e,Interaction.subid		; $592d
	ld a,(de)		; $592f
	cp $02			; $5930
	call z,_tokayThief_countdownToStealNextItem		; $5932

	ld e,Interaction.var39		; $5935
	ld a,(de)		; $5937
	or a			; $5938
	call z,interactionAnimateBasedOnSpeed		; $5939
	call interactionRunScript		; $593c
	ret nc			; $593f

; Script finished; the tokay will now raise the item over its head.

	ld a,$05		; $5940
	call interactionSetAnimation		; $5942
	call interactionIncState2		; $5945
	ld l,Interaction.subid		; $5948
	ld a,(hl)		; $594a
	ld b,a			; $594b

	; Only one of them plays the sound effect
	or a			; $594c
	jr nz,+			; $594d
	ld a,SND_GETITEM		; $594f
	call playSound		; $5951
	ld h,d			; $5954
+
	ld l,Interaction.counter1		; $5955
	ld (hl),$5a		; $5957

;;
; Sets up the graphics for the item that the tokay is holding (ie. shovel, sword)
;
; @param	b	Held item index (0-4)
; @addr{5959}
_tokayInitHeldItem:
	call getFreeInteractionSlot		; $5959
	ret nz			; $595c
	inc l			; $595d
	ld a,b			; $595e
	ld bc,_tokayItemGraphics		; $595f
	call addAToBc		; $5962
	ld a,(bc)		; $5965
	ldd (hl),a		; $5966

;;
; @param	hl	Pointer to an object which will be set to type
;			INTERACID_ACCESSORY.
; @addr{5967}
_tokayInitAccessory:
	ld (hl),INTERACID_ACCESSORY		; $5967
	ld l,Interaction.relatedObj1		; $5969
	ld (hl),Interaction.enabled		; $596b
	inc l			; $596d
	ld (hl),d		; $596e
	ret			; $596f

_tokayItemGraphics:
	.db $10 $1b $68 $31 $20


;;
; This function counts down a timer in var38, and removes the next item from Link's
; inventory once it hits zero. The next item index to steal is var3a.
; @addr{5975}
_tokayThief_countdownToStealNextItem:
	ld h,d			; $5975
	ld l,Interaction.var38		; $5976
	dec (hl)		; $5978
	ret nz			; $5979

	ld (hl),$0a		; $597a
	ld l,Interaction.var3a		; $597c
	ld a,(hl)		; $597e
	cp $09			; $597f
	ret z			; $5981

	inc (hl)		; $5982
	ld hl,tokayIslandStolenItems		; $5983
	rst_addAToHl			; $5986
	ld a,(hl)		; $5987

	cp TREASURE_SEED_SATCHEL			; $5988
	jr nz,+			; $598a
	call loseTreasure		; $598c
	ld a,TREASURE_EMBER_SEEDS		; $598f
	call loseTreasure		; $5991
	ld a,TREASURE_MYSTERY_SEEDS		; $5994
+
	call loseTreasure		; $5996
	ld a,SND_UNKNOWN5		; $5999
	jp playSound		; $599b


_tokayThiefSubstate1:
	call interactionDecCounter1		; $599e
	ret nz			; $59a1

	; Set how long to wait before jumping based on subid
	ld l,Interaction.subid		; $59a2
	ld a,(hl)		; $59a4
	swap a			; $59a5
	add $14			; $59a7
	ld l,Interaction.counter1		; $59a9
	ld (hl),a		; $59ab

	jp interactionIncState2		; $59ac


_tokayThiefSubstate2:
	call interactionAnimate3Times		; $59af
	call interactionDecCounter1		; $59b2
	ret nz			; $59b5

	; Jump away
	ld l,Interaction.angle		; $59b6
	ld (hl),$06		; $59b8
	ld l,Interaction.speed		; $59ba
	ld (hl),SPEED_280		; $59bc

_tokayThief_jump:
	call interactionIncState2		; $59be

	ld bc,-$1c0		; $59c1
	call objectSetSpeedZ		; $59c4

	ld a,$05		; $59c7
	call specialObjectSetAnimation		; $59c9
	ld e,Interaction.animCounter		; $59cc
	ld a,$01		; $59ce
	ld (de),a		; $59d0
	call specialObjectAnimate		; $59d1

	ld a,SND_JUMP		; $59d4
	jp playSound		; $59d6


_tokayThiefSubstate3:
	ld c,$20		; $59d9
	call objectUpdateSpeedZ_paramC		; $59db
	jp nz,objectApplySpeed		; $59de

	call interactionIncState2		; $59e1
	ld l,Interaction.counter1		; $59e4
	ld (hl),$06		; $59e6
	ld a,$05		; $59e8
	jp interactionSetAnimation		; $59ea


_tokayThiefSubstate4:
	call interactionDecCounter1		; $59ed
	ret nz			; $59f0
	jr _tokayThief_jump		; $59f1


; Wait for tokay to exit screen
_tokayThiefSubstate5:
	call objectApplySpeed		; $59f3
	call objectCheckWithinScreenBoundary		; $59f6
	jr c,@updateSpeedZ	; $59f9

	ld e,Interaction.subid		; $59fb
	ld a,(de)		; $59fd
	cp $03			; $59fe
	jr nz,@delete	; $5a00

	; Only the tokay with subid $03 goes to state 6
	call interactionIncState2		; $5a02
	ld l,Interaction.counter1		; $5a05
	ld (hl),$3c		; $5a07
	ret			; $5a09

@delete:
	jp interactionDelete		; $5a0a

@updateSpeedZ:
	ld c,$20		; $5a0d
	jp objectUpdateSpeedZ_paramC		; $5a0f


; Wait for a bit before restoring control to Link
_tokayThiefSubstate6:
	call interactionDecCounter1		; $5a12
	ret nz			; $5a15

	xor a			; $5a16
	ld (wDisabledObjects),a		; $5a17
	ld (wUseSimulatedInput),a		; $5a1a
	ld (wMenuDisabled),a		; $5a1d
	call getThisRoomFlags		; $5a20
	set 6,(hl)		; $5a23

	ld a,(wActiveMusic2)		; $5a25
	ld (wActiveMusic),a		; $5a28
	call playSound		; $5a2b

	call setDeathRespawnPoint		; $5a2e
	jp interactionDelete		; $5a31



; NPC who trades meat for stink bag
_tokayRunSubid05:
	call interactionRunScript		; $5a34
	jp c,interactionDelete		; $5a37

	ld e,Interaction.var3f		; $5a3a
	ld a,(de)		; $5a3c
	or a			; $5a3d
	jp z,npcFaceLinkAndAnimate		; $5a3e

	call _tokayRunStinkBagCutscene		; $5a41
	call interactionAnimate		; $5a44
	jp objectSetPriorityRelativeToLink_withTerrainEffects		; $5a47


; NPC holding something (ie. shovel, harp, shield upgrade).
_tokayRunSubid06:
_tokayRunSubid07:
_tokayRunSubid08:
_tokayRunSubid09:
_tokayRunSubid0a:
_tokayRunSubid1d:
	call interactionRunScript		; $5a4a
	ld e,Interaction.var3b		; $5a4d
	ld a,(de)		; $5a4f
	or a			; $5a50
	jp z,interactionAnimateAsNpc		; $5a51
	jp npcFaceLinkAndAnimate		; $5a54


; Linked game cutscene where tokay runs away from Rosa
_tokayRunSubid0b:
	call interactionRunScript		; $5a57
	jp c,interactionDelete		; $5a5a
	jp interactionAnimateBasedOnSpeed		; $5a5d


; Participant in Wild Tokay game
_tokayRunSubid0c:
	ld e,Interaction.state2		; $5a60
	ld a,(de)		; $5a62
	rst_jumpTable			; $5a63
	.dw _wildTokayParticipantSubstate0
	.dw _wildTokayParticipantSubstate1
	.dw _wildTokayParticipantSubstate2


_wildTokayParticipantSubstate0:
	call _wildTokayParticipant_checkGrabMeat		; $5a6a

_wildTokayParticipantSubstate2:
	call objectApplySpeed		; $5a6d
	ld e,Interaction.yh		; $5a70
	ld a,(de)		; $5a72
	add $08			; $5a73
	cp $90			; $5a75
	jp c,interactionAnimateBasedOnSpeed		; $5a77

; Tokay has just left the screen

	; Is he holding meat?
	ld e,Interaction.var3c		; $5a7a
	ld a,(de)		; $5a7c
	or a			; $5a7d
	jr nz,+			; $5a7e

	; If so, set failure flag?
	ld a,$ff		; $5a80
	ld ($cfde),a		; $5a82
	jr @delete		; $5a85
+
	; Delete "meat" accessory
	ld e,Interaction.relatedObj2+1		; $5a87
	ld a,(de)		; $5a89
	push de			; $5a8a
	ld d,a			; $5a8b
	call objectDelete_de		; $5a8c

	; If this is the last tokay (colored red), mark "success" condition in $cfde
	pop de			; $5a8f
	ld e,Interaction.oamFlags		; $5a90
	ld a,(de)		; $5a92
	cp $02			; $5a93
	jr nz,@delete	; $5a95

	ld a,$01		; $5a97
	ld ($cfde),a		; $5a99
@delete:
	jp interactionDelete		; $5a9c

;;
; @addr{5aa9}
_wildTokayParticipant_checkGrabMeat:
	; Check that Link's throwing an item
	ld a,(w1ReservedItemC.enabled)		; $5a9f
	or a			; $5aa2
	ret z			; $5aa3
	ld a,(wLinkGrabState)		; $5aa4
	or a			; $5aa7
	ret nz			; $5aa8

	; Check if the meat has collided with self
	ld a,$0a		; $5aa9
	ld hl,w1ReservedItemC.yh		; $5aab
	ld b,(hl)		; $5aae
	ld l,Item.xh		; $5aaf
	ld c,(hl)		; $5ab1
	ld h,d			; $5ab2
	ld l,Interaction.yh		; $5ab3
	call checkObjectIsCloseToPosition		; $5ab5
	ret nc			; $5ab8

	call interactionIncState2		; $5ab9
	ld l,Interaction.var3c		; $5abc
	inc (hl)		; $5abe
	ld l,Interaction.counter1		; $5abf
	ld (hl),$06		; $5ac1

	ld a,$07		; $5ac3
	ld l,Interaction.direction		; $5ac5
	add (hl)		; $5ac7
	call interactionSetAnimation		; $5ac8
	push de			; $5acb

	; Delete thrown meat
	ld de,w1ReservedItemC.enabled		; $5acc
	call objectDelete_de		; $5acf

	; Delete something?
	ld hl,$cfda		; $5ad2
	ldi a,(hl)		; $5ad5
	ld e,(hl)		; $5ad6
	ld d,a			; $5ad7
	call objectDelete_de		; $5ad8

	pop de			; $5adb
	ld a,SND_OPENCHEST		; $5adc
	call playSound		; $5ade
	; Fall through

;;
; Creates a graphic of "held meat" for a tokay.
; @addr{5ae1}
_tokayInitMeatAccessory:
	call getFreeInteractionSlot		; $5ae1
	ret nz			; $5ae4

	ld (hl),INTERACID_ACCESSORY		; $5ae5
	inc l			; $5ae7
	ld (hl),$73		; $5ae8
	inc l			; $5aea
	inc (hl)		; $5aeb

	ld l,Interaction.relatedObj1		; $5aec
	ld (hl),Interaction.enabled		; $5aee
	inc l			; $5af0
	ld (hl),d		; $5af1

	ld e,Interaction.relatedObj2+1		; $5af2
	ld a,h			; $5af4
	ld (de),a		; $5af5
	ret			; $5af6


_wildTokayParticipantSubstate1:
	call interactionDecCounter1		; $5af7
	ret nz			; $5afa
	jp interactionIncState2		; $5afb



; Past and present NPCs in charge of wild tokay game
_tokayRunSubid0d:
_tokayRunSubid19:
	ld e,Interaction.state2		; $5afe
	ld a,(de)		; $5b00
	rst_jumpTable			; $5b01
	.dw @substate0
	.dw @substate1

; Not running game
@substate0:
	ld a,(wPaletteThread_mode)		; $5b06
	or a			; $5b09
	ret nz			; $5b0a

	call interactionRunScript		; $5b0b
	jp nc,interactionAnimateAsNpc		; $5b0e

; Script ended; that means the game should begin.

	; Create meat spawner?
	call getFreeInteractionSlot		; $5b11
	ret nz			; $5b14
	ld (hl),INTERACID_WILD_TOKAY_CONTROLLER		; $5b15
	call interactionIncState2		; $5b17
	ld a,SNDCTRL_MEDIUM_FADEOUT		; $5b1a
	call playSound		; $5b1c
	jp fadeoutToWhite		; $5b1f

; Beginning game (will delete self when the game is initialized)
@substate1:
	ld a,(wPaletteThread_mode)		; $5b22
	or a			; $5b25
	ret nz			; $5b26

	push de			; $5b27
	call clearAllItemsAndPutLinkOnGround		; $5b28
	pop de			; $5b2b
	ld e,Interaction.subid		; $5b2c
	ld a,(de)		; $5b2e

	; Check if in present or past
	cp $19			; $5b2f
	jr nz,++		; $5b31
	ld a,$01		; $5b33
	ld ($cfc0),a		; $5b35
++
	jp interactionDelete		; $5b38


; Subids $0f-$10: Tokays who try to eat Dimitri
_tokayRunSubid0f:
	ld a,(wScrollMode)		; $5b3b
	and $0e			; $5b3e
	ret nz			; $5b40

_tokayRunSubid10:
	ld a,(w1Companion.var3e)		; $5b41
	and $04			; $5b44
	jr nz,++			; $5b46
	; Fall through


; Shopkeeper, and past NPC looking after scent seedling
_tokayRunSubid0e:
_tokayRunSubid11:
	call interactionAnimateAsNpc		; $5b48
++
	call interactionRunScript		; $5b4b
	ret nc			; $5b4e
	jp interactionDelete		; $5b4f


; Present NPC who talks to you after climbing down vine
_tokayRunSubid1e:
	ld c,$10		; $5b52
	call objectUpdateSpeedZ_paramC		; $5b54
	call interactionAnimateAsNpc		; $5b57
	call getThisRoomFlags		; $5b5a
	bit 6,a			; $5b5d
	jp nz,interactionRunScript		; $5b5f

	ld c,$18		; $5b62
	call objectCheckLinkWithinDistance		; $5b64
	ret nc			; $5b67

	ld e,Interaction.var31		; $5b68
	ld (de),a		; $5b6a
	jp interactionRunScript		; $5b6b


; Subids $12-$18 and $1f: Generic NPCs
_tokayRunSubid12:
_tokayRunSubid13:
_tokayRunSubid14:
_tokayRunSubid15:
_tokayRunSubid16:
_tokayRunSubid17:
_tokayRunSubid18:
_tokayRunSubid1f:
	call interactionRunScript		; $5b6e
	jp npcFaceLinkAndAnimate		; $5b71


; Subids $1a-$1c: Tokay "statues" in the wild tokay museum
_tokayRunSubid1a:
_tokayRunSubid1b:
_tokayRunSubid1c:
	ld a,(wTmpcfc0.wildTokay.inPresent)		; $5b74
	or a			; $5b77
	ret z			; $5b78
	jp interactionDelete		; $5b79


;;
; Cutscene where tokay smells stink bag and jumps around like a madman.
;
; On return, var3e will be 0 if he's currently at his starting position, otherwise it will
; be 1.
; @addr{5b7c}
_tokayRunStinkBagCutscene:
	ld e,Interaction.state2		; $5b7c
	ld a,(de)		; $5b7e
	rst_jumpTable			; $5b7f
	.dw @substate0
	.dw @substate1
	.dw @substate2

@substate0:
	ld h,d			; $5b86
	ld l,Interaction.speed		; $5b87
	ld (hl),SPEED_300		; $5b89

@beginNextJump:
	ld h,d			; $5b8b
	ld l,Interaction.yh		; $5b8c
	ld a,(hl)		; $5b8e
	ld l,Interaction.var39		; $5b8f
	ld (hl),a		; $5b91

	ld l,Interaction.xh		; $5b92
	ld a,(hl)		; $5b94
	ld l,Interaction.var3a		; $5b95
	ld (hl),a		; $5b97

	ld h,d			; $5b98
	ld l,Interaction.state2		; $5b99
	ld (hl),$01		; $5b9b
	ld l,Interaction.var3e		; $5b9d
	ld (hl),$01		; $5b9f

	call @initJumpVariables		; $5ba1

	ld a,SND_JUMP		; $5ba4
	jp playSound		; $5ba6

; Set angle, speedZ, and var3c (gravity) for the next jump.
@initJumpVariables:
	ld h,d			; $5ba9
	ld l,Interaction.var3b		; $5baa
	ld a,(hl)		; $5bac
	add a			; $5bad
	ld bc,@jumpPaths		; $5bae
	call addDoubleIndexToBc		; $5bb1

	ld a,(bc)		; $5bb4
	inc bc			; $5bb5
	ld l,Interaction.angle		; $5bb6
	ld (hl),a		; $5bb8
	ld a,(bc)		; $5bb9
	inc bc			; $5bba
	ld l,Interaction.speedZ		; $5bbb
	ldi (hl),a		; $5bbd
	ld a,(bc)		; $5bbe
	inc bc			; $5bbf
	ld (hl),a		; $5bc0
	ld a,(bc)		; $5bc1
	ld l,Interaction.var3c		; $5bc2
	ld (hl),a		; $5bc4
	ret			; $5bc5

; Data format:
;   byte: angle
;   word: speedZ
;   byte: var3c (gravity)
@jumpPaths:
	dbwb $18, -$800, -$08
	dbwb $0a, -$c00, -$08
	dbwb $02, -$800, -$08
	dbwb $14, -$c00, -$08
	dbwb $06, -$e00, -$08
	dbwb $18, -$a00, -$08

@substate1:
	; Apply gravity and update speed
	ld e,Interaction.var3c		; $5bde
	ld a,(de)		; $5be0
	ld c,a			; $5be1
	call objectUpdateSpeedZ_paramC		; $5be2
	jp nz,objectApplySpeed		; $5be5

	call interactionIncState2		; $5be8
	ld l,Interaction.var3b		; $5beb
	ld a,(hl)		; $5bed
	cp $05			; $5bee
	ret nz			; $5bf0

	; He's completed one loop. Restore y/x to precise values to prevent "drifting" off
	; course?
	ld l,Interaction.y		; $5bf1
	ld (hl),$00		; $5bf3
	inc l			; $5bf5
	ld (hl),$28		; $5bf6
	ld l,Interaction.x		; $5bf8
	ld (hl),$00		; $5bfa
	inc l			; $5bfc
	ld (hl),$48		; $5bfd

	ld l,Interaction.var3e		; $5bff
	ld (hl),$00		; $5c01
	ret			; $5c03

@substate2:
	; Increment "jump index", and loop back to 0 when appropriate.
	ld h,d			; $5c04
	ld l,Interaction.var3b		; $5c05
	inc (hl)		; $5c07
	ld a,(hl)		; $5c08
	cp $06			; $5c09
	jr c,+			; $5c0b
	ld (hl),$00		; $5c0d
+
	jp @beginNextJump		; $5c0f

;;
; @addr{5c12}
_tokayLoadScript:
	ld e,Interaction.subid		; $5c12
	ld a,(de)		; $5c14
	ld hl,tokayScriptTable		; $5c15
	rst_addDoubleIndex			; $5c18
	ldi a,(hl)		; $5c19
	ld h,(hl)		; $5c1a
	ld l,a			; $5c1b
	jp interactionSetScript		; $5c1c

tokayScriptTable:
	/* $00 */ .dw tokayThiefScript
	/* $01 */ .dw tokayThiefScript
	/* $02 */ .dw tokayMainThiefScript
	/* $03 */ .dw tokayThiefScript
	/* $04 */ .dw tokayThiefScript
	/* $05 */ .dw tokayCookScript
	/* $06 */ .dw tokayHoldingItemScript
	/* $07 */ .dw tokayHoldingItemScript
	/* $08 */ .dw tokayHoldingItemScript
	/* $09 */ .dw tokayHoldingItemScript
	/* $0a */ .dw tokayHoldingItemScript
	/* $0b */ .dw tokayRunningFromRosaScript
	/* $0c */ .dw stubScript
	/* $0d */ .dw tokayGameManagerScript_past
	/* $0e */ .dw tokayShopkeeperScript
	/* $0f */ .dw tokayWithDimitri1Script
	/* $10 */ .dw tokayWithDimitri2Script
	/* $11 */ .dw tokayAtSeedlingPlotScript
	/* $12 */ .dw genericNpcScript
	/* $13 */ .dw genericNpcScript
	/* $14 */ .dw genericNpcScript
	/* $15 */ .dw genericNpcScript
	/* $16 */ .dw genericNpcScript
	/* $17 */ .dw genericNpcScript
	/* $18 */ .dw genericNpcScript
	/* $19 */ .dw tokayGameManagerScript_present
	/* $1a */ .dw $0000
	/* $1b */ .dw $0000
	/* $1c */ .dw $0000
	/* $1d */ .dw tokayWithShieldUpgradeScript
	/* $1e */ .dw tokayExplainingVinesScript
	/* $1f */ .dw genericNpcScript



; ==============================================================================
; INTERACID_FOREST_FAIRY
; ==============================================================================
interactionCode49:
	ld e,Interaction.subid		; $5c5f
	ld a,(de)		; $5c61
	ld e,Interaction.state		; $5c62
	rst_jumpTable			; $5c64
	.dw _forestFairy_subid00
	.dw _forestFairy_subid01
	.dw _forestFairy_subid02
	.dw _forestFairy_subid03
	.dw _forestFairy_subid04
	.dw _forestFairy_subid05
	.dw _forestFairy_subid06
	.dw _forestFairy_subid07
	.dw _forestFairy_subid08
	.dw _forestFairy_subid09
	.dw _forestFairy_subid0a
	.dw _forestFairy_subid0b
	.dw _forestFairy_subid0c
	.dw _forestFairy_subid0d
	.dw _forestFairy_subid0e
	.dw _forestFairy_subid0f
	.dw _forestFairy_subid10

_forestFairy_subid00:
	ld a,(de)		; $5c87
	rst_jumpTable			; $5c88
	.dw _forestFairy_subid00State0
	.dw _forestFairy_subid00State1
	.dw _forestFairy_subid00State2
	.dw _forestFairy_subid00State3
	.dw _forestFairy_deleteSelf


_forestFairy_subid00State0:
_forestFairy_subid03State0:
_forestFairy_subid04State0:
	call interactionInitGraphics		; $5c93
	call _forestFairy_initCollisionRadiusAndSetZAndIncState		; $5c96
	ld l,Interaction.speed		; $5c99
	ld (hl),SPEED_200		; $5c9b
	ld l,Interaction.var3a		; $5c9d
	ld (hl),$5a		; $5c9f

_forestFairy_loadMovementPreset:
	ld e,Interaction.var03		; $5ca1
	ld a,(de)		; $5ca3
	add a			; $5ca4
	ld hl,@data		; $5ca5
	rst_addDoubleIndex			; $5ca8

	ld e,Interaction.yh		; $5ca9
	ld a,(hl)		; $5cab
	and $f8			; $5cac
	ld (de),a		; $5cae
	ld e,Interaction.angle		; $5caf
	ldi a,(hl)		; $5cb1
	and $07			; $5cb2
	add a			; $5cb4
	add a			; $5cb5
	ld (de),a		; $5cb6

	ld e,Interaction.xh		; $5cb7
	ld a,(hl)		; $5cb9
	and $f8			; $5cba
	ld (de),a		; $5cbc
	ld e,Interaction.counter1		; $5cbd
	ldi a,(hl)		; $5cbf
	and $07			; $5cc0
	inc a			; $5cc2
	ld (de),a		; $5cc3
	inc e			; $5cc4
	ld (de),a		; $5cc5

	ld e,Interaction.var38		; $5cc6
	ld a,(hl)		; $5cc8
	and $f8			; $5cc9
	ld (de),a		; $5ccb
	ld e,Interaction.direction		; $5ccc
	ldi a,(hl)		; $5cce
	and $01			; $5ccf
	ld (de),a		; $5cd1

	ld e,Interaction.var39		; $5cd2
	ld a,(hl)		; $5cd4
	and $f8			; $5cd5
	ld (de),a		; $5cd7
	ld e,Interaction.oamFlags		; $5cd8
	ld a,(hl)		; $5cda
	and $07			; $5cdb
	ld (de),a		; $5cdd
	dec e			; $5cde
	ld (de),a		; $5cdf

	ld e,Interaction.direction		; $5ce0
	ld a,(de)		; $5ce2
	jp interactionSetAnimation		; $5ce3


; Each row is data for a corresponding value of "var03".
; Data format:
;   b0: angle (bits 0-2, multiplied by 4) and y-position (bits 3-7)
;   b1: counter1/2 (bits 0-2, plus one) and x-position (bits 3-7)
;   b2: direction (bit 0) and var38 (bits 3-7)
;   b3: oamFlags (bits 0-2) and var39 (bits 3-7)
@data:
	.db $38 $6b $48 $39
	.db $29 $3b $49 $6a
	.db $5d $53 $39 $53
	.db $2e $5a $48 $51
	.db $5d $4a $49 $52
	.db $39 $2a $49 $53
	.db $4c $3c $00 $49
	.db $48 $6c $39 $8a
	.db $3a $54 $59 $03
	.db $4c $54 $00 $a1
	.db $49 $55 $91 $62
	.db $4a $53 $01 $03
	.db $4c $a4 $28 $59
	.db $60 $ac $59 $4a
	.db $03 $7c $39 $2b
	.db $97 $53 $61 $41
	.db $84 $53 $91 $81
	.db $4e $5b $89 $11
	.db $3a $7b $28 $aa
	.db $5a $7b $88 $a3
	.db $36 $ab $21 $69
	.db $86 $53 $91 $39


_forestFairy_subid00State1:
	ld h,d			; $5d3e
	ld l,Interaction.var38		; $5d3f
	ld b,(hl)		; $5d41
	inc l			; $5d42
	ld c,(hl)		; $5d43
	ld l,Interaction.yh		; $5d44
	ldi a,(hl)		; $5d46
	ldh (<hFF8F),a	; $5d47
	inc l			; $5d49
	ld a,(hl)		; $5d4a
	ldh (<hFF8E),a	; $5d4b
	sub c			; $5d4d
	add $04			; $5d4e
	cp $09			; $5d50
	jr nc,@label_09_161	; $5d52

	ldh a,(<hFF8F)	; $5d54
	sub b			; $5d56
	add $04			; $5d57
	cp $09			; $5d59
	jr nc,@label_09_161	; $5d5b

	ld e,Interaction.subid		; $5d5d
	ld a,(de)		; $5d5f
	cp $03			; $5d60
	jr nc,@label_09_160	; $5d62

	ld (hl),c		; $5d64
	ld l,Interaction.yh		; $5d65
	ld (hl),b		; $5d67
	ld l,Interaction.state		; $5d68
	inc (hl)		; $5d6a

@label_09_160:
	ld hl,wTmpcfc0.fairyHideAndSeek.cfd2		; $5d6b
	inc (hl)		; $5d6e
	scf			; $5d6f
	ret			; $5d70

@label_09_161:
	ld l,Interaction.var3a		; $5d71
	dec (hl)		; $5d73
	ld a,(hl)		; $5d74
	jr nz,@label_09_163	; $5d75

	ld (hl),$5a		; $5d77
	ld l,Interaction.counter2		; $5d79
	srl (hl)		; $5d7b
	jr nc,@label_09_164	; $5d7d

	inc (hl)		; $5d7f
@label_09_163:
	and $07			; $5d80
	jr nz,@label_09_164	; $5d82

	push bc			; $5d84
	ldbc INTERACID_SPARKLE, $02		; $5d85
	call objectCreateInteraction		; $5d88
	pop bc			; $5d8b

@label_09_164:
	call interactionDecCounter1		; $5d8c
	jr nz,_forestFairy_updateMovement	; $5d8f

	inc l			; $5d91
	ldd a,(hl)		; $5d92
	ld (hl),a		; $5d93
	call objectGetRelativeAngleWithTempVars		; $5d94
	call objectNudgeAngleTowards		; $5d97

_forestFairy_updateMovement:
	call objectApplySpeed		; $5d9a
	ld a,(wFrameCounter)		; $5d9d
	and $1f			; $5da0
	ld a,SND_MAGIC_POWDER		; $5da2
	call z,playSound		; $5da4

_forestFairy_animate:
	call interactionAnimate		; $5da7
	or d			; $5daa
	ret			; $5dab


_forestFairy_subid00State2:
	ld a,(wTmpcfc0.fairyHideAndSeek.cfd2)		; $5dac
	or a			; $5daf
	jr nz,_forestFairy_animate	; $5db0

	ld e,Interaction.var03		; $5db2
	ld a,(de)		; $5db4
	cp $06			; $5db5
	jr nc,@createPuffAndDelete	; $5db7

	add $06			; $5db9
	ld (de),a		; $5dbb
	call interactionIncState		; $5dbc
	jp _forestFairy_loadMovementPreset		; $5dbf

@createPuffAndDelete:
	call objectCreatePuff		; $5dc2
	jr _forestFairy_deleteSelf		; $5dc5

_forestFairy_subid00State3:
	call _forestFairy_subid00State1		; $5dc7
	jr c,_forestFairy_deleteSelf	; $5dca
	ld e,Interaction.yh		; $5dcc
	ld a,(de)		; $5dce
	cp $80			; $5dcf
	jr nc,++		; $5dd1

	ld e,Interaction.xh		; $5dd3
	ld a,(de)		; $5dd5
	cp $a0			; $5dd6
	ret c			; $5dd8
++
	ld hl,wTmpcfc0.fairyHideAndSeek.cfd2		; $5dd9
	inc (hl)		; $5ddc

_forestFairy_deleteSelf:
	jp interactionDelete		; $5ddd


_forestFairy_subid01:
	ld a,(de)		; $5de0
	or a			; $5de1
	jr z,@stateZero	; $5de2

	ld a,($cfd0)		; $5de4
	or a			; $5de7
	jp z,interactionDelete		; $5de8

	ld hl,w1Link		; $5deb
	call preventObjectHFromPassingObjectD		; $5dee
	call interactionAnimate		; $5df1
	jp interactionRunScript		; $5df4

@stateZero:
	ld e,Interaction.var03		; $5df7
	ld a,(de)		; $5df9
	ld hl,$cfd1		; $5dfa
	call checkFlag		; $5dfd
	jp z,interactionDelete		; $5e00

	ld a,($cfd1)		; $5e03
	call getNumSetBits		; $5e06
	dec a			; $5e09
	ld hl,_forestFairyDiscoveredScriptTable		; $5e0a
	rst_addDoubleIndex			; $5e0d
	ldi a,(hl)		; $5e0e
	ld h,(hl)		; $5e0f
	ld l,a			; $5e10
	call interactionSetScript		; $5e11

	call interactionInitGraphics		; $5e14

	; Set color based on index
	ld e,Interaction.var03		; $5e17
	ld a,(de)		; $5e19
	ld b,a			; $5e1a
	inc a			; $5e1b
	ld e,Interaction.oamFlags		; $5e1c
	ld (de),a		; $5e1e
	dec e			; $5e1f
	ld (de),a		; $5e20

	ld a,b			; $5e21
	ld hl,_forestFairy_discoveredPositions		; $5e22
	rst_addDoubleIndex			; $5e25
	ld e,Interaction.yh		; $5e26
	ldi a,(hl)		; $5e28
	ld (de),a		; $5e29
	ld e,Interaction.xh		; $5e2a
	ld a,(hl)		; $5e2c
	ld (de),a		; $5e2d
	ld a,b			; $5e2e
	or a			; $5e2f
	jr z,+			; $5e30
	ld a,$01		; $5e32
+
	call interactionSetAnimation		; $5e34

_forestFairy_initCollisionRadiusAndSetZAndIncState:
	call interactionIncState		; $5e37
	ld l,Interaction.collisionRadiusY		; $5e3a
	ld a,$04		; $5e3c
	ldi (hl),a		; $5e3e
	ld (hl),a		; $5e3f
	ld l,Interaction.zh		; $5e40
	ld (hl),$fc		; $5e42
	jp objectSetVisiblec1		; $5e44


; Scripts used for fairy NPCs after being discovered
_forestFairyDiscoveredScriptTable:
	.dw forestFairyScript_firstDiscovered
	.dw forestFairyScript_secondDiscovered
	.dw stubScript

_forestFairy_discoveredPositions:
	.db $48 $38
	.db $48 $68
	.db $28 $50


_forestFairy_subid02:
	jp interactionDelete		; $5e53

_forestFairy_subid03:
	ld a,(de)		; $5e56
	rst_jumpTable			; $5e57
	.dw _forestFairy_subid03State0
	.dw _forestFairy_subid03State1
	.dw _forestFairy_subid03State2
	.dw _forestFairy_subid03State3
	.dw _forestFairy_subid00State3

_forestFairy_subid04:
	ld a,(de)		; $5e62
	rst_jumpTable			; $5e63
	.dw _forestFairy_subid04State0
	.dw _forestFairy_subid04State1
	.dw _forestFairy_subid00State3

_forestFairy_subid03State1:
	call _forestFairy_subid00State1		; $5e6a
	ret nc			; $5e6d
	call interactionIncState		; $5e6e
	ld a,$02		; $5e71
	ld l,Interaction.counter1		; $5e73
	ldi (hl),a		; $5e75
	ldi (hl),a		; $5e76
	ld l,Interaction.var3b		; $5e77
	ld (hl),$20		; $5e79
	ret			; $5e7b

_forestFairy_subid03State2:
	ld h,d			; $5e7c
	ld l,Interaction.var3a		; $5e7d
	dec (hl)		; $5e7f
	ld a,(hl)		; $5e80
	and $07			; $5e81
	jr nz,++		; $5e83

	push bc			; $5e85
	ldbc INTERACID_SPARKLE, $02		; $5e86
	call objectCreateInteraction		; $5e89
	pop bc			; $5e8c
++
	call interactionDecCounter2		; $5e8d
	jr nz,@updateMovement	; $5e90

	dec l			; $5e92
	ldi a,(hl)		; $5e93
	ldi (hl),a		; $5e94

	; [direction]++ (wrapping $20 to $00)
	inc l			; $5e95
	ld a,(hl)		; $5e96
	inc a			; $5e97
	and $1f			; $5e98
	ld (hl),a		; $5e9a

	ld l,Interaction.var3b		; $5e9b
	dec (hl)		; $5e9d
	jr nz,@updateMovement	; $5e9e

	ld l,e			; $5ea0
	inc (hl)		; $5ea1
	ld hl,wTmpcfc0.fairyHideAndSeek.cfd2		; $5ea2
	inc (hl)		; $5ea5
	ret			; $5ea6

@updateMovement:
	jp _forestFairy_updateMovement		; $5ea7

_forestFairy_subid03State3:
	ld a,(wTmpcfc0.fairyHideAndSeek.cfd2)		; $5eaa
	or a			; $5ead
	jp nz,_forestFairy_animate		; $5eae

	call interactionIncState		; $5eb1
	ld l,Interaction.var03		; $5eb4
	inc (hl)		; $5eb6
	ld l,Interaction.yh		; $5eb7
	ldi a,(hl)		; $5eb9
	inc l			; $5eba
	ld c,(hl)		; $5ebb
	ld b,a			; $5ebc
	push bc			; $5ebd
	call _forestFairy_loadMovementPreset		; $5ebe
	pop bc			; $5ec1
	ld h,d			; $5ec2
	ld l,Interaction.yh		; $5ec3
	ld (hl),b		; $5ec5
	ld l,Interaction.xh		; $5ec6
	ld (hl),c		; $5ec8
	ret			; $5ec9

_forestFairy_subid04State1:
	ld a,(wTmpcfc0.fairyHideAndSeek.cfd2)		; $5eca
	or a			; $5ecd
	jp nz,_forestFairy_animate		; $5ece
	call interactionIncState		; $5ed1
	jp _forestFairy_loadMovementPreset		; $5ed4


; Generic NPC (between completing the maze and entering jabu)
_forestFairy_subid05:
_forestFairy_subid06:
_forestFairy_subid07:
	call checkInteractionState		; $5ed7
	jr nz,_forestFairy_standardUpdate	; $5eda

	ld a,GLOBALFLAG_WON_FAIRY_HIDING_GAME		; $5edc
	call checkGlobalFlag		; $5ede
	jp z,interactionDelete		; $5ee1

	ld a,GLOBALFLAG_FOREST_UNSCRAMBLED		; $5ee4
	call checkGlobalFlag		; $5ee6
	jp z,interactionDelete		; $5ee9

	; Check if jabu-jabu is opened?
	ld a,(wPresentRoomFlags+$90)		; $5eec
	bit 6,a			; $5eef
	jp nz,interactionDelete		; $5ef1

	ld e,Interaction.subid		; $5ef4
	ld a,(de)		; $5ef6
	sub $05			; $5ef7
	ld hl,_forestFairy_subid5To7NpcData		; $5ef9
	rst_addDoubleIndex			; $5efc

;;
; @param	hl	Pointer to 2 bytes (see example data below)
; @addr{5efd}
_forestFairy_initNpcFromData:
	push hl			; $5efd
	call interactionInitGraphics		; $5efe
	pop hl			; $5f01

	ld e,Interaction.textID		; $5f02
	ldi a,(hl)		; $5f04
	ld (de),a		; $5f05

	ld e,Interaction.oamFlagsBackup		; $5f06
	ld a,(hl)		; $5f08
	and $0f			; $5f09
	ld (de),a		; $5f0b
	inc e			; $5f0c
	ld (de),a		; $5f0d

	ld a,(hl)		; $5f0e
	and $f0			; $5f0f
	swap a			; $5f11
	call interactionSetAnimation		; $5f13

	call objectMarkSolidPosition		; $5f16
	call interactionIncState		; $5f19
	ld l,Interaction.zh		; $5f1c
	ld (hl),$fc		; $5f1e

	ld l,Interaction.textID+1		; $5f20
	ld (hl),>TX_1100		; $5f22
	ld hl,forestFairyScript_genericNpc		; $5f24
	call interactionSetScript		; $5f27
	jp objectSetVisiblec1		; $5f2a


; Index is [subid]-5 (for subids $05-$07).
;  b0: Low byte of textID
;  b1: oamFlags (bits 0-3), animation index (bits 4-7)
_forestFairy_subid5To7NpcData:
	.db <TX_110d, $01
	.db <TX_1110, $12
	.db <TX_1113, $13

_forestFairy_standardUpdate:
	call interactionRunScript		; $5f33
	call interactionAnimate		; $5f36
	jp objectPreventLinkFromPassing		; $5f39


; Generic NPC (between jabu and finishing the game)
_forestFairy_subid08:
_forestFairy_subid09:
_forestFairy_subid0a:
	call checkInteractionState		; $5f3c
	jr nz,_forestFairy_standardUpdate	; $5f3f

	ld a,GLOBALFLAG_WON_FAIRY_HIDING_GAME		; $5f41
	call checkGlobalFlag		; $5f43
	jp z,interactionDelete		; $5f46

	ld a,GLOBALFLAG_FOREST_UNSCRAMBLED		; $5f49
	call checkGlobalFlag		; $5f4b
	jp z,interactionDelete		; $5f4e

	ld a,(wPresentRoomFlags+$90)		; $5f51
	bit 6,a			; $5f54
	jp z,interactionDelete		; $5f56

	ld a,GLOBALFLAG_FINISHEDGAME		; $5f59
	call checkGlobalFlag		; $5f5b
	jp nz,interactionDelete		; $5f5e

	ld e,Interaction.subid		; $5f61
	ld a,(de)		; $5f63
	sub $08			; $5f64
	ld hl,@npcData		; $5f66
	rst_addDoubleIndex			; $5f69
	jp _forestFairy_initNpcFromData		; $5f6a

; Index is [subid]-8 (for subids $08-$0a).
;  b0: Low byte of textID
;  b1: oamFlags (bits 0-3), animation index (bits 4-7)
@npcData:
	.db <TX_110e, $01
	.db <TX_1111, $12
	.db <TX_1114, $13 


; NPC in unlinked game who takes a secret
_forestFairy_subid0b:
	call checkInteractionState		; $5f73
	jr nz,_forestFairy_standardUpdate	; $5f76

	ld a,GLOBALFLAG_FINISHEDGAME		; $5f78
	call checkGlobalFlag		; $5f7a
	jp z,interactionDelete		; $5f7d

	call interactionInitGraphics		; $5f80
	call objectMarkSolidPosition		; $5f83
	call interactionIncState		; $5f86
	ld l,Interaction.zh		; $5f89
	ld (hl),$fc		; $5f8b

	ld l,Interaction.oamFlags		; $5f8d
	ld a,$01		; $5f8f
	ldd (hl),a		; $5f91
	ld (hl),a		; $5f92
	ld hl,forestFairyScript_heartContainerSecret		; $5f93
	call interactionSetScript		; $5f96
	jp objectSetVisiblec1		; $5f99


; Generic NPC (after beating game)
_forestFairy_subid0c:
_forestFairy_subid0d:
	call checkInteractionState		; $5f9c
_forestFairy_standardUpdate_2:
	jr nz,_forestFairy_standardUpdate	; $5f9f

	ld a,GLOBALFLAG_FINISHEDGAME		; $5fa1
	call checkGlobalFlag		; $5fa3
	jp z,interactionDelete		; $5fa6

	ld e,Interaction.subid		; $5fa9
	ld a,(de)		; $5fab
	sub $0c			; $5fac
	ld hl,@npcData		; $5fae
	rst_addDoubleIndex			; $5fb1
	jp _forestFairy_initNpcFromData		; $5fb2

; Index is [subid]-$0c (for subids $0c-$0d).
;  b0: Low byte of textID
;  b1: oamFlags (bits 0-3), animation index (bits 4-7)
@npcData:
	.db <TX_1112, $12
	.db <TX_1115, $13


; Generic NPC (while looking for companion trapped in woods)
_forestFairy_subid0e:
_forestFairy_subid0f:
_forestFairy_subid10:
	call checkInteractionState		; $5fb9
	jr nz,_forestFairy_standardUpdate_2	; $5fbc

	ld a,GLOBALFLAG_GOT_FLUTE		; $5fbe
	call checkGlobalFlag		; $5fc0
	jp nz,interactionDelete		; $5fc3

	ld a,GLOBALFLAG_FOREST_UNSCRAMBLED		; $5fc6
	call checkGlobalFlag		; $5fc8
	jp nz,interactionDelete		; $5fcb

	ld a,GLOBALFLAG_COMPANION_LOST_IN_FOREST		; $5fce
	call checkGlobalFlag		; $5fd0
	jp z,interactionDelete		; $5fd3

	ld e,Interaction.subid		; $5fd6
	ld a,(de)		; $5fd8
	sub $0e			; $5fd9
	ld hl,@npcData		; $5fdb
	rst_addDoubleIndex			; $5fde
	jp _forestFairy_initNpcFromData		; $5fdf

; Index is [subid]-$0e (for subids $0e-$10).
;  b0: Low byte of textID
;  b1: oamFlags (bits 0-3), animation index (bits 4-7)
@npcData:
	.db <TX_1127, $01
	.db <TX_1128, $12
	.db <TX_1129, $13


; ==============================================================================
; INTERACID_RABBIT
; ==============================================================================
interactionCode4b:
	jpab bank3f.interactionCode4b_body		; $5fe8


; ==============================================================================
; INTERACID_BIRD
; ==============================================================================
interactionCode4c:
	ld e,Interaction.state		; $5ff0
	ld a,(de)		; $5ff2
	rst_jumpTable			; $5ff3
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $5ff8
	ld (de),a		; $5ffa
	call interactionInitGraphics		; $5ffb
	call objectSetVisiblec2		; $5ffe
	call @initSubid		; $6001
	ld e,Interaction.enabled		; $6004
	ld a,(de)		; $6006
	or a			; $6007
	jp nz,objectMarkSolidPosition		; $6008
	ret			; $600b

@initSubid:
	ld e,Interaction.subid		; $600c
	ld a,(de)		; $600e
	rst_jumpTable			; $600f
	.dw @initSubid00
	.dw @initSubid01
	.dw @initSubid02
	.dw @initSubid03
	.dw @initSubid04


; Listening to Nayru at the start of the game
@initSubid00:
	call _bird_hop		; $601a
	ld hl,birdScript_listeningToNayruGameStart		; $601d
	jp interactionSetScript		; $6020


; Bird with Impa when Zelda gets kidnapped
@initSubid04:
	ld a,(wEssencesObtained)		; $6023
	bit 2,a			; $6026
	jp z,interactionDelete		; $6028

	call checkIsLinkedGame		; $602b
	jp z,interactionDelete		; $602e

	ld a,GLOBALFLAG_GOT_RING_FROM_ZELDA		; $6031
	call checkGlobalFlag		; $6033
	jp nz,interactionDelete		; $6036

	ld hl,birdScript_zeldaKidnapped		; $6039
	call interactionSetScript		; $603c
	call interactionSetAlwaysUpdateBit		; $603f

	ld a,GLOBALFLAG_IMPA_MOVED_AFTER_ZELDA_KIDNAPPED		; $6042
	call checkGlobalFlag		; $6044
	jr z,@setAnimation0AndJump	; $6047

	ld a,GLOBALFLAG_ZELDA_SAVED_FROM_VIRE		; $6049
	call checkGlobalFlag		; $604b
	jr z,@impaNotMoved	; $604e

	; Have talked to impa; adjust position
	ld e,Interaction.yh		; $6050
	ld a,$58		; $6052
	ld (de),a		; $6054
	jr @setAnimation0AndJump		; $6055

@impaNotMoved:
	ld e,Interaction.xh		; $6057
	ld a,$68		; $6059
	ld (de),a		; $605b
	jr @setAnimation0AndJump		; $605c


; Different colored birds that do nothing but hop? Used in a cutscene?
@initSubid01:
@initSubid02:
@initSubid03:
	; [oamFlags] = [subid]
	ld a,(de)		; $605e
	ld e,Interaction.oamFlags		; $605f
	ld (de),a		; $6061

@setAnimation0AndJump:
	xor a			; $6062
	call interactionSetAnimation		; $6063
	jp _bird_hop		; $6066


@state1:
	ld e,Interaction.subid		; $6069
	ld a,(de)		; $606b
	rst_jumpTable			; $606c
	.dw _bird_runSubid0
	.dw interactionAnimate
	.dw interactionAnimate
	.dw interactionAnimate
	.dw _bird_runSubid4


; Listening to Nayru at the start of the game
_bird_runSubid0:
	call interactionAnimateAsNpc		; $6077
	ld e,Interaction.state2		; $607a
	ld a,(de)		; $607c
	rst_jumpTable			; $607d
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate0:
	ld a,($cfd0)		; $6086
	cp $0e			; $6089
	jr nz,++		; $608b

	call interactionIncState2		; $608d
	ld a,$01		; $6090
	jp interactionSetAnimation		; $6092
++
	ld e,Interaction.var37		; $6095
	ld a,(de)		; $6097
	or a			; $6098
	call nz,_bird_updateGravityAndHopWhenHitGround		; $6099
	jp interactionRunScript		; $609c

@substate1:
	ld a,($cfd0)		; $609f
	cp $10			; $60a2
	ret nz			; $60a4

	call interactionIncState2		; $60a5
	ld l,Interaction.counter1		; $60a8
	ld (hl),$1e		; $60aa
	call _bird_hop		; $60ac
	ld a,$02		; $60af
	jp interactionSetAnimation		; $60b1

@substate2:
	call interactionDecCounter1		; $60b4
	jr nz,_bird_updateGravityAndHopWhenHitGround	; $60b7

	; Begin running away
	call interactionIncState2		; $60b9
	ld l,Interaction.zh		; $60bc
	ld (hl),$00		; $60be
	ld l,Interaction.angle		; $60c0
	ld (hl),$01		; $60c2
	ld l,Interaction.speed		; $60c4
	ld (hl),SPEED_100		; $60c6
	ld bc,-$100		; $60c8
	call objectSetSpeedZ		; $60cb
	ld a,$03		; $60ce
	jp interactionSetAnimation		; $60d0

@substate3:
	; Delete self when off-screen
	call objectCheckWithinScreenBoundary		; $60d3
	jp nc,interactionDelete		; $60d6

	xor a			; $60d9
	call objectUpdateSpeedZ		; $60da
	jp objectApplySpeed		; $60dd


; Bird with Impa when Zelda gets kidnapped
_bird_runSubid4:
	call interactionAnimateAsNpc		; $60e0
	call _bird_updateGravityAndHopWhenHitGround		; $60e3
	call interactionRunScript		; $60e6
	jp c,interactionDelete		; $60e9

	; Check whether to move the bird over (to make way to Link)
	ld a,GLOBALFLAG_IMPA_MOVED_AFTER_ZELDA_KIDNAPPED		; $60ec
	call checkGlobalFlag		; $60ee
	ret z			; $60f1

	ld a,GLOBALFLAG_ZELDA_SAVED_FROM_VIRE		; $60f2
	call checkGlobalFlag		; $60f4
	ret nz			; $60f7

	; Increase x position until it reaches $68
	ld e,Interaction.xh		; $60f8
	ld a,(de)		; $60fa
	cp $68			; $60fb
	ret z			; $60fd

	inc a			; $60fe
	ld (de),a		; $60ff
	ret			; $6100

_bird_updateGravityAndHopWhenHitGround:
	ld c,$20		; $6101
	call objectUpdateSpeedZ_paramC		; $6103
	ret nz			; $6106
	ld h,d			; $6107

_bird_hop:
	ld bc,-$c0		; $6108
	jp objectSetSpeedZ		; $610b


; ==============================================================================
; INTERACID_AMBI
; ==============================================================================
interactionCode4d:
	ld e,Interaction.state		; $610e
	ld a,(de)		; $6110
	rst_jumpTable			; $6111
	.dw @state0
	.dw _ambi_state1

@state0:
	ld a,$01		; $6116
	ld (de),a		; $6118
	call interactionInitGraphics		; $6119
	call objectSetVisiblec2		; $611c
	call @initSubid		; $611f
	ld e,Interaction.enabled		; $6122
	ld a,(de)		; $6124
	or a			; $6125
	jp nz,objectMarkSolidPosition		; $6126
	ret			; $6129

@initSubid:
	ld e,Interaction.subid		; $612a
	ld a,(de)		; $612c
	rst_jumpTable			; $612d
	.dw @initSubid00
	.dw @initSubid01
	.dw @initSubid02
	.dw @initSubid03
	.dw @initSubid04
	.dw @initSubid05
	.dw @initSubid06
	.dw @initSubid07
	.dw _ambi_loadScript
	.dw _ambi_ret
	.dw @initSubid0a


; Cutscene after escaping black tower
@initSubid01:
	ld a,($cfd0)		; $6144
	cp $0b			; $6147
	jp nz,_ambi_loadScript		; $6149
	call checkIsLinkedGame		; $614c
	ret nz			; $614f
	ld hl,ambiSubid01Script_part2		; $6150
	jp interactionSetScript		; $6153


; Cutscene where Ambi does evil stuff atop black tower (after d7)
@initSubid03:
	call getThisRoomFlags		; $6156
	bit 6,a			; $6159
	jp nz,interactionDelete		; $615b


; Same cutscene as subid $03, but second part
@initSubid04:
	callab interactionBank1.nayruState0@init0e		; $615e
	jp _ambi_loadScript		; $6166


; Cutscene where you give mystery seeds to Ambi
@initSubid00:
	call _soldierCheckBeatD6		; $6169
	jp nc,interactionDelete		; $616c


; Credits cutscene where Ambi observes construction of Link statue
@initSubid02:
	jp _ambi_loadScript		; $616f


; Cutscene where Ralph confronts Ambi
@initSubid05:
	; Call some of nayru's code to load possessed palette
	callab interactionBank1.nayruState0@init0e		; $6172

	call objectSetVisiblec3		; $617a
	jp _ambi_loadScript		; $617d


; Cutscene just before fighting possessed Ambi
@initSubid06:
	call getThisRoomFlags		; $6180
	bit 7,a			; $6183
	jp nz,interactionDelete		; $6185

	; Load possessed palette and use it
	ld a,PALH_85		; $6188
	call loadPaletteHeader		; $618a
	ld h,d			; $618d
	ld l,Interaction.oamFlags		; $618e
	ld a,$06		; $6190
	ldd (hl),a		; $6192
	ld (hl),a		; $6193

	ld a,$01		; $6194
	ld (wNumEnemies),a		; $6196

	; Create "ghost veran" object above Ambi
	call getFreeInteractionSlot		; $6199
	jr z,++			; $619c

	ld e,Interaction.state		; $619e
	xor a			; $61a0
	ld (de),a		; $61a1
	ret			; $61a2
++
	ld (hl),INTERACID_GHOST_VERAN		; $61a3
	inc l			; $61a5
	inc (hl)		; $61a6
	ld bc,$f000		; $61a7
	call objectCopyPositionWithOffset		; $61aa

	ld a,SNDCTRL_STOPMUSIC		; $61ad
	call playSound		; $61af

	; Set Link's direction & angle to "up"
	ld hl,w1Link.direction		; $61b2
	xor a			; $61b5
	ldi (hl),a		; $61b6
	ld (hl),a		; $61b7

	ld (wDisableLinkCollisionsAndMenu),a		; $61b8
	ld ($cfc0),a		; $61bb
	dec a			; $61be
	ld (wActiveMusic),a		; $61bf

	ld hl,$cc93		; $61c2
	set 7,(hl)		; $61c5

	ld a,LINK_STATE_FORCE_MOVEMENT		; $61c7
	ld (wLinkForceState),a		; $61c9
	ld a,$16		; $61cc
	ld (wLinkStateParameter),a		; $61ce


; Cutscene where Ambi regains control of herself
@initSubid07:
	jp _ambi_loadScript		; $61d1

@initSubid0a:
	call checkIsLinkedGame		; $61d4
	jp z,interactionDelete		; $61d7
	ld hl,wGroup4Flags+$fc		; $61da
	bit 7,(hl)		; $61dd
	jp z,interactionDelete		; $61df
	jp _ambi_loadScript		; $61e2

_ambi_state1:
	ld e,Interaction.subid		; $61e5
	ld a,(de)		; $61e7
	rst_jumpTable			; $61e8
	.dw _ambi_updateAnimationAndRunScript
	.dw _ambi_runSubid01
	.dw _ambi_runSubid02
	.dw _ambi_runSubid03
	.dw _ambi_runSubid04
	.dw _ambi_runSubid05
	.dw _ambi_runSubid06
	.dw _ambi_runSubid07
	.dw _ambi_runSubid08
	.dw interactionAnimate
	.dw _ambi_runSubid0a

_ambi_updateAnimationAndRunScript:
	call interactionAnimate		; $61ff
	jp interactionRunScript		; $6202


; Cutscene after escaping black tower
_ambi_runSubid01:
	call checkIsLinkedGame		; $6205
	jr z,@updateSubstate	; $6208
	ld a,($cfd0)		; $620a
	cp $0b			; $620d
	jp c,@updateSubstate		; $620f

	call interactionAnimate		; $6212
	jpab scriptHlp.turnToFaceSomething		; $6215

@updateSubstate:
	ld e,Interaction.state2		; $621d
	ld a,(de)		; $621f
	rst_jumpTable			; $6220
	.dw @substate0
	.dw @substate1
	.dw _ambi_updateAnimationAndRunScript

@substate0:
	ld a,($cfd0)		; $6227
	cp $0e			; $622a
	jr nz,_ambi_updateAnimationAndRunScript	; $622c

	callab interactionBank1.startJump		; $622e
	jp interactionIncState2		; $6236

@substate1:
	ld c,$20		; $6239
	call objectUpdateSpeedZ_paramC		; $623b
	ret nz			; $623e

	call interactionIncState2		; $623f
	ld l,Interaction.var3e		; $6242
	inc (hl)		; $6244

_ambi_ret:
	ret			; $6245


; Credits cutscene where Ambi observes construction of Link statue
_ambi_runSubid02:
	ld e,Interaction.state2		; $6246
	ld a,(de)		; $6248
	rst_jumpTable			; $6249
	.dw @substate0
	.dw @substate1
	.dw interactionAnimateBasedOnSpeed

@substate0:
	call _ambi_updateAnimationAndRunScript		; $6250
	ret nc			; $6253
	jp interactionIncState2		; $6254

@substate1:
	call interactionAnimateBasedOnSpeed		; $6257
	call objectApplySpeed		; $625a
	ld a,($cfc0)		; $625d
	cp $06			; $6260
	ret nz			; $6262
	call interactionIncState2		; $6263
	ld bc,$5040		; $6266
	jp interactionSetPosition		; $6269


; Cutscene where Ambi does evil stuff atop black tower (after d7)
_ambi_runSubid03:
	ld e,Interaction.state2		; $626c
	ld a,(de)		; $626e
	rst_jumpTable			; $626f
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @updateAnimationAndRunScript

@substate0:
	ld a,($cfc0)		; $627a
	cp $01			; $627d
	jr nz,@updateAnimationAndRunScript	; $627f

	call interactionIncState2		; $6281
	ld l,Interaction.counter1		; $6284
	ld (hl),SPEED_80		; $6286

	call getFreePartSlot		; $6288
	ret nz			; $628b
	ld (hl),PARTID_LIGHTNING		; $628c
	inc l			; $628e
	inc (hl) ; [subid] = $01
	inc l			; $6290
	inc (hl) ; [var03] = $01
	jp objectCopyPosition		; $6292

@updateAnimationAndRunScript:
	call interactionAnimateBasedOnSpeed		; $6295
	jp interactionRunScript		; $6298

@substate1:
	call interactionDecCounter1		; $629b
	ret nz			; $629e
	xor a			; $629f
	ld (wTmpcbb3),a		; $62a0
	dec a			; $62a3
	ld (wTmpcbba),a		; $62a4
	jp interactionIncState2		; $62a7

@substate2:
	ld hl,wTmpcbb3		; $62aa
	ld b,$02		; $62ad
	call flashScreen		; $62af
	ret z			; $62b2

	call interactionIncState2		; $62b3
	ldbc INTERACID_SPARKLE,$08		; $62b6
	call objectCreateInteraction		; $62b9
	ld a,$02		; $62bc
	jp fadeinFromWhiteWithDelay		; $62be

@substate3:
	ld a,(wPaletteThread_mode)		; $62c1
	or a			; $62c4
	ret nz			; $62c5
	ld a,$02		; $62c6
	ld ($cfc0),a		; $62c8
	jp interactionIncState2		; $62cb


; Same cutscene as subid $03 (black tower after d7), but second part
_ambi_runSubid04:
	ld e,Interaction.state2		; $62ce
	ld a,(de)		; $62d0
	rst_jumpTable			; $62d1
	.dw @substate0
	.dw @substate1
	.dw interactionAnimate

@substate0:
	call _ambi_updateAnimationAndRunScript		; $62d8
	ret nc			; $62db
	xor a			; $62dc
	ld (wTmpcbb3),a		; $62dd
	dec a			; $62e0
	ld (wTmpcbba),a		; $62e1
	jp interactionIncState2		; $62e4

@substate1:
	ld hl,wTmpcbb3		; $62e7
	ld b,$02		; $62ea
	call flashScreen		; $62ec
	ret z			; $62ef
	ld a,$03		; $62f0
	ld ($cfc0),a		; $62f2
	jp interactionIncState2		; $62f5

_ambi_runSubid05:
	call interactionRunScript		; $62f8
	jp c,interactionDelete		; $62fb
	ld a,($cfc0)		; $62fe
	bit 1,a			; $6301
	jp z,interactionAnimate		; $6303
	ret			; $6306

; Unused?
@data:
	.db $82 $90 $00 $55 $03


; $06: Cutscene just before fighting possessed Ambi
; $07: Cutscene where Ambi regains control of herself
_ambi_runSubid06:
_ambi_runSubid07:
	call interactionRunScript		; $630c
	jp nc,interactionAnimate		; $630f
	ld a,$01		; $6312
	ld (wLoadedTreeGfxIndex),a		; $6314
	jp interactionDelete		; $6317


; Cutscene after d3 where you're told Ambi's tower will soon be complete
_ambi_runSubid08:
	call _ambi_updateAnimationAndRunScript		; $631a
	ret nc			; $631d

	ld a,$01		; $631e
	ld ($cbb8),a		; $6320
	ld a,CUTSCENE_BLACK_TOWER_EXPLANATION		; $6323
	ld (wCutsceneTrigger),a		; $6325
	jp interactionDelete		; $6328


; NPC after Zelda is kidnapped
_ambi_runSubid0a:
	call npcFaceLinkAndAnimate		; $632b
	jp interactionRunScript		; $632e


_ambi_loadScript:
	ld e,Interaction.subid		; $6331
	ld a,(de)		; $6333
	ld hl,@scriptTable		; $6334
	rst_addDoubleIndex			; $6337
	ldi a,(hl)		; $6338
	ld h,(hl)		; $6339
	ld l,a			; $633a
	jp interactionSetScript		; $633b

@scriptTable:
	.dw ambiSubid00Script
	.dw ambiSubid01Script_part1
	.dw ambiSubid02Script
	.dw ambiSubid03Script
	.dw ambiSubid04Script
	.dw ambiSubid05Script
	.dw ambiSubid06Script
	.dw ambiSubid07Script
	.dw ambiSubid08Script
	.dw stubScript
	.dw ambiSubid0aScript


; ==============================================================================
; INTERACID_SUBROSIAN
; ==============================================================================
interactionCode4e:
	ld e,Interaction.subid		; $6354
	ld a,(de)		; $6356
	rst_jumpTable			; $6357
	.dw _subrosian_subid00
	.dw _subrosian_subid01
	.dw _subrosian_subid02
	.dw _subrosian_subid03
	.dw _subrosian_subid04


; Subrosian in lynna village (linked only)
_subrosian_subid00:
	call checkInteractionState		; $6362
	jr nz,@state1	; $6365

@state0:
	call interactionIncState		; $6367
	call interactionInitGraphics		; $636a
	call objectSetVisiblec2		; $636d
	ld a,>TX_1c00		; $6370
	call interactionSetHighTextIndex		; $6372

	call checkIsLinkedGame		; $6375
	jp z,interactionDeleteAndUnmarkSolidPosition		; $6378

	callab getGameProgress_2		; $637b
	ld a,b			; $6383
	cp $05			; $6384
	ld hl,subrosianInVillageScript_afterGotMakuSeed		; $6386
	jr z,@setScript	; $6389
	cp $07			; $638b
	jp nz,interactionDeleteAndUnmarkSolidPosition		; $638d

	ld hl,subrosianInVillageScript_postGame		; $6390

@setScript:
	call interactionSetScript		; $6393

@state1:
	call interactionRunScript		; $6396
	jp npcFaceLinkAndAnimate		; $6399

_subrosian_subid01:
	; Borrow goron code?
	jpab _goronSubid01		; $639c


; Subrosian in goron dancing game (var03 is 0 or 1 for green or red npcs)
_subrosian_subid02:
	call checkInteractionState		; $63a4
	jr nz,@state1	; $63a7

@state0:
	call _subrosian_initSubid02		; $63a9
	call interactionRunScript		; $63ac
@state1:
	call interactionRunScript		; $63af
	jp c,interactionDelete		; $63b2
	jp npcFaceLinkAndAnimate		; $63b5


; Linked game NPC telling you the subrosian secret (for bombchus)
_subrosian_subid03:
	call checkInteractionState		; $63b8
	jr nz,_subrosian_subid04@state1	; $63bb

@state0:
	call _subrosian_initGraphicsAndIncState		; $63bd
	ld a,$02		; $63c0
	jr _subrosian_subid04@initSecretTellingNpc		; $63c2


; Linked game NPC telling you the smith secret (for shield upgrade)
_subrosian_subid04:
	call checkInteractionState		; $63c4
	jr nz,@state1	; $63c7

@state0:
	call _subrosian_initGraphicsAndIncState		; $63c9
	ld a,$04		; $63cc

@initSecretTellingNpc:
	ld e,Interaction.var3f		; $63ce
	ld (de),a		; $63d0
	ld hl,linkedGameNpcScript		; $63d1
	call interactionSetScript		; $63d4
	call interactionRunScript		; $63d7
@state1:
	call interactionRunScript		; $63da
	jp c,interactionDeleteAndUnmarkSolidPosition		; $63dd
	jp npcFaceLinkAndAnimate		; $63e0

;;
; @addr{63e3}
_subrosian_initGraphicsAndIncState:
	call interactionInitGraphics		; $63e3
	call objectMarkSolidPosition		; $63e6
	jp interactionIncState		; $63e9

;;
; @addr{63ec}
_subrosian_unused_63ec:
	call interactionInitGraphics		; $63ec
	call objectMarkSolidPosition		; $63ef
	jr _subrosian_loadScript		; $63f2


;;
; @addr{63f4}
_subrosian_initSubid02:
	call interactionInitGraphics		; $63f4
	call objectMarkSolidPosition		; $63f7
	jr _subrosian_loadScriptIndex			; $63fa

;;
; Load a script based just on the subid.
; @addr{63fc}
_subrosian_loadScript:
	call _subrosian_getScriptPtr		; $63fc
	call interactionSetScript		; $63ff
	jp interactionIncState		; $6402

;;
; Load a script based on the subid and var03.
; @addr{6405}
_subrosian_loadScriptIndex:
	call _subrosian_getScriptPtr		; $6405
	inc e			; $6408
	ld a,(de)		; $6409
	rst_addDoubleIndex			; $640a
	ldi a,(hl)		; $640b
	ld h,(hl)		; $640c
	ld l,a			; $640d
	call interactionSetScript		; $640e
	jp interactionIncState		; $6411

;;
; @param[out]	hl	Pointer read from scriptTable (either points to a script or to
;			a table of scripts)
; @addr{6414}
_subrosian_getScriptPtr:
	ld a,>TX_1c00		; $6414
	call interactionSetHighTextIndex		; $6416
	ld e,Interaction.subid		; $6419
	ld a,(de)		; $641b
	ld hl,@scriptTable		; $641c
	rst_addDoubleIndex			; $641f
	ldi a,(hl)		; $6420
	ld h,(hl)		; $6421
	ld l,a			; $6422
	ret			; $6423

; @addr{6424}
@scriptTable:
	.dw stubScript
	.dw stubScript
	.dw @subid02Scripts

@subid02Scripts:
	.dw subrosianAtGoronDanceScript_greenNpc
	.dw subrosianAtGoronDanceScript_redNpc


; ==============================================================================
; INTERACID_IMPA_NPC
; ==============================================================================
interactionCode4f:
	ld e,Interaction.subid		; $642e
	ld a,(de)		; $6430
	rst_jumpTable			; $6431
	.dw _impaNpc_subid00
	.dw _impaNpc_subid01
	.dw _impaNpc_subid02
	.dw _impaNpc_subid03

_impaNpc_subid00:
	call checkInteractionState		; $643a
	jr z,@state0	; $643d

@state1:
	call interactionRunScript		; $643f
	ld e,Interaction.var03		; $6442
	ld a,(de)		; $6444
	dec a			; $6445
	jr z,@animate	; $6446

	cp $09			; $6448
	call nz,_impaNpc_faceLinkIfClose		; $644a
@animate:
	jp interactionAnimateAsNpc		; $644d

@state0:
	; Set the tile leading to nayru's basement to behave like stairs
	ld hl,wRoomLayout+$22		; $6450
	ld (hl),TILEINDEX_INDOOR_DOWNSTAIRCASE		; $6453

	call _getImpaNpcState		; $6455
	bit 7,b			; $6458
	jp nz,interactionDelete		; $645a

	call checkIsLinkedGame		; $645d
	jr z,+			; $6460
	ld a,$09		; $6462
+
	add b			; $6464
	call _impaNpc_determineTextAndPositionInHouse		; $6465

;;
; @param	hl	Script address
; @addr{6468}
_impaNpc_setScriptAndInitialize:
	call interactionSetScript		; $6468
	call interactionInitGraphics		; $646b
	call interactionIncState		; $646e
	ld l,Interaction.textID+1		; $6471
	ld (hl),>TX_0100		; $6473

	call objectMarkSolidPosition		; $6475

	ld e,Interaction.var38		; $6478
	ld a,(de)		; $647a
	call interactionSetAnimation		; $647b

	jp objectSetVisiblec2		; $647e

;;
; Sets low byte of textID and returns a script address to use.
;
; May delete itself, then pop the return address from the stack to return from caller...
;
; @param	a	Index of "behaviour" ($00-$08 for unlinked, $09-$11 for linked)
; @param[out]	hl	Script address
; @addr{6481}
_impaNpc_determineTextAndPositionInHouse:
	ld e,Interaction.var03		; $6481
	ld (de),a		; $6483
	rst_jumpTable			; $6484
	.dw @val00
	.dw @val01
	.dw @val02
	.dw @val03
	.dw @val04
	.dw @val05
	.dw @delete
	.dw @delete
	.dw @delete
	.dw @val09
	.dw @val0a
	.dw @val0b
	.dw @delete
	.dw @val0d
	.dw @val0e
	.dw @delete
	.dw @delete
	.dw @delete

@delete:
	pop hl			; $64a9
	jp interactionDelete		; $64aa

@val00:
@val09:
	ld bc,$3838		; $64ad
	ld a,<TX_0120		; $64b0
	jr @setTextAndPosition		; $64b2

@val01:
@val0a:
	ld bc,$4828		; $64b4
	ld a,<TX_0121		; $64b7
	call @setTextAndPosition		; $64b9
	ld (de),a		; $64bc
	ld hl,impaNpcScript_lookingAtPassage		; $64bd
	ret			; $64c0

@val02:
@val03:
@val04:
@val0b:
	ld bc,$2868		; $64c1
	ld a,<TX_0122		; $64c4
	jr @setTextAndPosition		; $64c6

@val0d:
	ld bc,$2868		; $64c8
	ld a,<TX_012c		; $64cb
	jr @setTextAndPosition		; $64cd

@val05:
@val0e:
	ld bc,$2868		; $64cf
	ld a,<TX_0123		; $64d2

@setTextAndPosition:
	ld e,Interaction.textID		; $64d4
	ld (de),a		; $64d6
	ld e,Interaction.yh		; $64d7
	ld a,b			; $64d9
	ld (de),a		; $64da
	ld e,$4d		; $64db
	ld a,c			; $64dd
	ld (de),a		; $64de

	; var38 is the direction to face
	ld e,Interaction.var38		; $64df
	ld a,$02		; $64e1
	ld (de),a		; $64e3

	ld hl,genericNpcScript		; $64e4
	xor a			; $64e7
	ret			; $64e8


; Impa in past (after telling you about Ralph's heritage)
_impaNpc_subid01:
	call checkInteractionState		; $64e9
	jr nz,_impaNpc_runScriptAndFaceLink	; $64ec
	call _getImpaNpcState		; $64ee
	ld a,b			; $64f1
	cp $07			; $64f2
	jp nz,interactionDelete		; $64f4

	call checkIsLinkedGame		; $64f7
	ld a,<TX_012b		; $64fa
	jr z,_impaNpc_setTextIndexAndLoadGenericNpcScript			; $64fc
	ld a,<TX_012e		; $64fe


;;
; @param	a	Low byte of text index (high byte is $01)
_impaNpc_setTextIndexAndLoadGenericNpcScript:
	ld e,Interaction.textID		; $6500
	ld (de),a		; $6502

	; var38 is the direction to face
	ld e,Interaction.var38		; $6503
	ld a,$02		; $6505
	ld (de),a		; $6507

	ld hl,genericNpcScript		; $6508
	jp _impaNpc_setScriptAndInitialize		; $650b


; Impa after Zelda's been kidnapped
_impaNpc_subid02:
	call checkInteractionState		; $650e
	jr nz,_impaNpc_runScriptAndFaceLink	; $6511

@state0:
	call _getImpaNpcState		; $6513
	ld a,b			; $6516
	cp $08			; $6517
	jp nz,interactionDelete		; $6519
	ld a,<TX_012f		; $651c
	jr _impaNpc_setTextIndexAndLoadGenericNpcScript		; $651e


_impaNpc_runScriptAndFaceLink:
	call interactionRunScript		; $6520
	call _impaNpc_faceLinkIfClose		; $6523
	jp interactionAnimateAsNpc		; $6526


; Impa after getting the maku seed
_impaNpc_subid03:
	call checkInteractionState		; $6529
	jr nz,_impaNpc_runScriptAndFaceLink	; $652c

	call _getImpaNpcState		; $652e
	ld a,b			; $6531
	cp $06			; $6532
	jp nz,interactionDelete		; $6534

	ld a,<TX_0123		; $6537
	jr _impaNpc_setTextIndexAndLoadGenericNpcScript		; $6539

;;
; @addr{653b}
_impaNpc_faceLinkIfClose:
	ld c,$28		; $653b
	call objectCheckLinkWithinDistance		; $653d
	jr nc,@noChange	; $6540

	call objectGetAngleTowardEnemyTarget		; $6542
	add $04			; $6545
	and $18			; $6547
	swap a			; $6549
	rlca			; $654b
	jr @updateDirection		; $654c

@noChange:
	ld e,Interaction.var38		; $654e
	ld a,(de)		; $6550
@updateDirection:
	ld h,d			; $6551
	ld l,Interaction.direction		; $6552
	cp (hl)			; $6554
	ret z			; $6555
	ld (hl),a		; $6556
	jp interactionSetAnimation		; $6557

;;
; Returns something in 'b':
; * $00 before d2 breaks down;
; * $01 after d2 breaks down;
; * $02 after obtaining harp;
; * $03 after beating d3;
; * $04 after saving Zelda from vire;
; * $05 after saving Nayru;
; * $06 after getting maku seed;
; * $07 after cutscene where Impa tells you about Ralph's heritage;
; * $08 after flame of despair is lit (beat Veran in a linked game);
; * $ff after finishing game
;
; @param[out]	b	Return value
; @addr{655a}
_getImpaNpcState:
	ld a,GLOBALFLAG_FINISHEDGAME		; $655a
	call checkGlobalFlag		; $655c
	ld b,$ff		; $655f
	ret nz			; $6561
	inc b			; $6562
	ld a,(wPresentRoomFlags+$83)		; $6563
	rlca			; $6566
	ret nc			; $6567

	ld a,TREASURE_HARP		; $6568
	call checkTreasureObtained		; $656a
	ld b,$01		; $656d
	ret nc			; $656f

	ld a,GLOBALFLAG_SAVED_NAYRU		; $6570
	call checkGlobalFlag		; $6572
	jr nz,@savedNayru	; $6575

	ld a,GLOBALFLAG_GOT_RING_FROM_ZELDA		; $6577
	call checkGlobalFlag		; $6579
	ld b,$04		; $657c
	ret nz			; $657e

	ld a,TREASURE_ESSENCE		; $657f
	call checkTreasureObtained		; $6581
	bit 2,a			; $6584
	ld b,$02		; $6586
	ret z			; $6588
	inc b			; $6589
	ret			; $658a

@savedNayru:
	ld a,TREASURE_MAKU_SEED		; $658b
	call checkTreasureObtained		; $658d
	ld b,$05		; $6590
	ret nc			; $6592

	ld a,GLOBALFLAG_PRE_BLACK_TOWER_CUTSCENE_DONE		; $6593
	call checkGlobalFlag		; $6595
	ld b,$06		; $6598
	ret z			; $659a

	ld a,GLOBALFLAG_FLAME_OF_DESPAIR_LIT		; $659b
	call checkGlobalFlag		; $659d
	ld b,$07		; $65a0
	ret z			; $65a2
	inc b			; $65a3
	ret			; $65a4


; ==============================================================================
; INTERACID_DUMBBELL_MAN
; ==============================================================================
interactionCode51:
	call checkInteractionState		; $65a5
	jr nz,@state1		; $65a8

@state0:
	call @initialize		; $65aa
	call interactionSetAlwaysUpdateBit		; $65ad

@state1:
	call interactionRunScript		; $65b0
	jp c,interactionDelete		; $65b3
	jp interactionAnimateAsNpc		; $65b6
	call interactionInitGraphics		; $65b9
	jp interactionIncState		; $65bc

@initialize:
	call interactionInitGraphics		; $65bf
	ld a,>TX_0b00		; $65c2
	call interactionSetHighTextIndex		; $65c4
	ld e,Interaction.subid		; $65c7
	ld a,(de)		; $65c9
	ld hl,@scriptTable		; $65ca
	rst_addDoubleIndex			; $65cd
	ldi a,(hl)		; $65ce
	ld h,(hl)		; $65cf
	ld l,a			; $65d0
	call interactionSetScript		; $65d1
	jp interactionIncState		; $65d4

@scriptTable:
	.dw dumbbellManScript


; ==============================================================================
; INTERACID_OLD_MAN
; ==============================================================================
interactionCode52:
	ld e,Interaction.subid		; $65d9
	ld a,(de)		; $65db
	rst_jumpTable			; $65dc
	.dw @runSubid00
	.dw @runSubid01
	.dw @runSubid02
	.dw @runSubid03
	.dw @runSubid04
	.dw @runSubid05
	.dw @runSubid06

; Old man who takes a secret to give you the shield (same spot as subid $02)
@runSubid00:
	call checkInteractionState		; $65eb
	jr nz,@@state1	; $65ee


@@state0:
	call @loadScriptAndInitGraphics		; $65f0
@@state1:
	call interactionRunScript		; $65f3
	jp c,interactionDelete		; $65f6
	jp npcFaceLinkAndAnimate		; $65f9


; Old man who gives you book of seals
@runSubid01:
	call checkInteractionState		; $65fc
	call z,@loadScriptAndInitGraphics		; $65ff
	call interactionRunScript		; $6602
	jp c,interactionDelete		; $6605
	jp interactionAnimateAsNpc		; $6608


; Old man guarding fairy powder in past (same spot as subid $00)
@runSubid02:
	call checkInteractionState		; $660b
	jr nz,@@state1		; $660e

@@state0:
	ld a,GLOBALFLAG_FINISHEDGAME		; $6610
	call checkGlobalFlag		; $6612
	jp nz,interactionDelete		; $6615
	call @loadScriptAndInitGraphics		; $6618

@@state1:
	call interactionAnimateAsNpc		; $661b
	call interactionRunScript		; $661e
	ret nc			; $6621
	ld a,SND_TELEPORT		; $6622
	call playSound		; $6624
	ld hl,@warpDest		; $6627
	jp setWarpDestVariables		; $662a

@warpDest:
	.db $85 $ec $00 $17 $03


; Generic NPCs in the past library
@runSubid03:
@runSubid04:
@runSubid05:
@runSubid06:
	call checkInteractionState		; $6632
	jr z,@@state0		; $6635

@@state1:
	call interactionRunScript		; $6637
	jp interactionAnimateAsNpc		; $663a

@@state0:
	call interactionInitGraphics		; $663d
	call interactionIncState		; $6640

	ld l,Interaction.textID+1		; $6643
	ld (hl),>TX_3300		; $6645

	ld l,Interaction.collisionRadiusX		; $6647
	ld (hl),$06		; $6649
	ld l,Interaction.direction		; $664b
	dec (hl)		; $664d

	ld a,GLOBALFLAG_WATER_POLLUTION_FIXED		; $664e
	call checkGlobalFlag		; $6650
	ld b,$00		; $6653
	jr z,+			; $6655
	inc b			; $6657
+
	ld e,Interaction.subid		; $6658
	ld a,(de)		; $665a
	sub $03			; $665b
	ld c,a			; $665d
	add a			; $665e
	add b			; $665f
	ld hl,@textIndices		; $6660
	rst_addAToHl			; $6663
	ld e,Interaction.textID		; $6664
	ld a,(hl)		; $6666
	ld (de),a		; $6667

	ld a,c			; $6668
	add a			; $6669
	add c			; $666a
	ld hl,@baseVariables		; $666b
	rst_addAToHl			; $666e
	ld e,Interaction.collisionRadiusY		; $666f
	ldi a,(hl)		; $6671
	ld (de),a		; $6672
	ld e,Interaction.oamFlagsBackup		; $6673
	ldi a,(hl)		; $6675
	ld (de),a		; $6676
	inc e			; $6677
	ld (de),a		; $6678
	ld e,Interaction.var38		; $6679
	ld a,(hl)		; $667b
	ld (de),a		; $667c
	call interactionSetAnimation		; $667d
	call objectSetVisiblec2		; $6680

	ld hl,oldManScript_generic		; $6683
	jp interactionSetScript		; $6686


; b0: collisionRadiusY
; b1: oamFlagsBackup
; b2: animation (can be thought of as direction to face?)
@baseVariables:
	.db $12 $02 $02
	.db $06 $00 $00
	.db $06 $00 $00
	.db $06 $01 $02

; The first and second columns are the text to show before and after the water pollution
; is fixed, respectively.
@textIndices:
	.db <TX_3300, <TX_3301
	.db <TX_3302, <TX_3303
	.db <TX_3304, <TX_3305
	.db <TX_3306, <TX_3307 

@func_669d: ; Unused?
	call interactionInitGraphics		; $669d
	jp interactionIncState		; $66a0

@loadScriptAndInitGraphics:
	call interactionInitGraphics		; $66a3
	ld e,Interaction.subid		; $66a6
	ld a,(de)		; $66a8
	ld hl,@scriptTable		; $66a9
	rst_addDoubleIndex			; $66ac
	ldi a,(hl)		; $66ad
	ld h,(hl)		; $66ae
	ld l,a			; $66af
	call interactionSetScript		; $66b0
	jp interactionIncState		; $66b3

@scriptTable:
	.dw oldManScript_givesShieldUpgrade
	.dw oldManScript_givesBookOfSeals
	.dw oldManScript_givesFairyPowder


; ==============================================================================
; INTERACID_MAMAMU_YAN
; ==============================================================================
interactionCode53:
	call checkInteractionState		; $66bc
	jr nz,@state1		; $66bf

@state0:
	call @initGraphicsLoadScriptAndIncState		; $66c1

@state1:
	call interactionRunScript		; $66c4
	jp c,interactionDelete		; $66c7
	jp npcFaceLinkAndAnimate		; $66ca


@initGraphicsAncIncState: ; Unused?
	call interactionInitGraphics		; $66cd
	jp interactionIncState		; $66d0


@initGraphicsLoadScriptAndIncState:
	call interactionInitGraphics		; $66d3
	ld a,>TX_0b00		; $66d6
	call interactionSetHighTextIndex		; $66d8
	ld e,Interaction.subid		; $66db
	ld a,(de)		; $66dd
	ld hl,@scriptTable		; $66de
	rst_addDoubleIndex			; $66e1
	ldi a,(hl)		; $66e2
	ld h,(hl)		; $66e3
	ld l,a			; $66e4
	call interactionSetScript		; $66e5
	jp interactionIncState		; $66e8

@scriptTable:
	.dw mamamuYanScript


; ==============================================================================
; INTERACID_MAMAMU_DOG
;
; Variables (for subid $01):
;   var3a: Target position index
;   var3b: Highest valid value for "var3a" (before looping?)
;   var3c/3d: Address of "position data" to get target position from
;   var3e: Used as a counter in script
;   var3f: Animation index
; ==============================================================================
interactionCode54:
	ld e,Interaction.subid		; $66ed
	ld a,(de)		; $66ef
	rst_jumpTable			; $66f0
	.dw _dog_subid00
	.dw _dog_subid01

; Dog in mamamu's house
_dog_subid00:
	call checkInteractionState		; $66f5
	jr nz,@state1	; $66f8

@state0:
	ld a,GLOBALFLAG_FINISHEDGAME		; $66fa
	call checkGlobalFlag		; $66fc
	jr z,@dontDelete	; $66ff

	ld a,GLOBALFLAG_RETURNED_DOG		; $6701
	call checkGlobalFlag		; $6703
	jp nz,@dontDelete		; $6706

	call getThisRoomFlags		; $6709
	bit 5,(hl)		; $670c
	jp nz,interactionDelete		; $670e

@dontDelete:
	call _dog_initGraphicsLoadScriptAndIncState		; $6711
	ld h,d			; $6714
	ld l,Interaction.angle		; $6715
	ld (hl),$18		; $6717
	ld l,Interaction.speed		; $6719
	ld (hl),SPEED_100		; $671b

	ld a,$02		; $671d
	ld l,Interaction.var3f		; $671f
	ld (hl),a		; $6721
	call interactionSetAnimation		; $6722
@state1:
	call interactionRunScript		; $6725
	jp c,interactionDelete		; $6728
	call interactionAnimate		; $672b
	jp objectSetPriorityRelativeToLink_withTerrainEffects		; $672e


; Dog outside that Link needs to find for a "sidequest"
_dog_subid01:
	ld e,Interaction.state		; $6731
	ld a,(de)		; $6733
	rst_jumpTable			; $6734
	.dw @state0
	.dw @state1
	.dw @state2

@state0:
	ld a,GLOBALFLAG_RETURNED_DOG		; $673b
	call checkGlobalFlag		; $673d
	jp nz,interactionDelete		; $6740
	ld hl,wPresentRoomFlags+$e7		; $6743
	bit 7,(hl)		; $6746
	jp z,interactionDelete		; $6748

	; Check if the dog's location corresponds to this object; if not, delete self.
	ld a,(wMamamuDogLocation)		; $674b
	ld h,d			; $674e
	ld l,Interaction.var03		; $674f
	cp (hl)			; $6751
	jp nz,interactionDelete		; $6752

	call _dog_initGraphicsLoadScriptAndIncState		; $6755
	ld l,Interaction.speed		; $6758
	ld (hl),SPEED_80		; $675a
	ld l,Interaction.direction		; $675c
	ld (hl),$ff		; $675e

	; a==0 here, which is important. It was set to 0 by the call to
	; "interactionSetScript", and wasn't changed after that...
	; It's probably supposed to equal "var03" here. Bug?
	call _dog_setTargetPositionIndex		; $6760

	ld hl,wMamamuDogLocation		; $6763
@tryAgain:
	call getRandomNumber		; $6766
	and $03			; $6769
	cp (hl)			; $676b
	jr z,@tryAgain		; $676c
	ld (hl),a		; $676e

@state1:
	call _dog_moveTowardTargetPosition		; $676f
	call _dog_checkCloseToTargetPosition		; $6772
	call c,_dog_incTargetPositionIndex		; $6775
	jr c,@delete	; $6778

	call _dog_moveTowardTargetPosition		; $677a
	call _dog_updateDirection		; $677d
	call _dog_checkCloseToTargetPosition		; $6780
	call c,_dog_incTargetPositionIndex		; $6783
	jr c,@delete	; $6786

	callab scriptHlp.mamamuDog_updateSpeedZ		; $6788
	call interactionAnimate		; $6790
	call objectSetPriorityRelativeToLink_withTerrainEffects		; $6793
	jp objectAddToGrabbableObjectBuffer		; $6796

@delete:
	jp interactionDelete		; $6799


; State 2: grabbed by Link (will cause Link to warp to mamamu's house)
@state2:
	inc e			; $679c
	ld a,(de)		; $679d
	rst_jumpTable			; $679e
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3

; Just grabbed
@substate0:
	xor a			; $67a7
	ld (wLinkGrabState2),a		; $67a8
	inc a			; $67ab
	ld (de),a		; $67ac
	ld a,GLOBALFLAG_RETURNED_DOG		; $67ad
	call setGlobalFlag		; $67af
	ld a,$81		; $67b2
	ld (wMenuDisabled),a		; $67b4
	ld (wDisableScreenTransitions),a		; $67b7
	jp objectSetVisiblec1		; $67ba

; Being lifted
@substate1:
	ld e,Interaction.var39		; $67bd
	ld a,(de)		; $67bf
	rst_jumpTable			; $67c0
	.dw @@minorState0
	.dw @@minorState1
	.dw @@minorState2

@@minorState0:
	ld a,(wLinkGrabState)		; $67c7
	cp $83			; $67ca
	ret nz			; $67cc

	ld a,$81		; $67cd
	ld (wDisabledObjects),a		; $67cf
	ld a,$80		; $67d2
	ld (wMenuDisabled),a		; $67d4
	ld h,d			; $67d7
	ld l,Interaction.var39		; $67d8
	inc (hl)		; $67da
	ld l,Interaction.counter1		; $67db
	ld (hl),40		; $67dd

@@minorState1:
	call interactionDecCounter1		; $67df
	ret nz			; $67e2

	ld h,d			; $67e3
	ld l,Interaction.var39		; $67e4
	inc (hl)		; $67e6
	ld bc,TX_007f		; $67e7
	jp showText		; $67ea

@@minorState2:
	ld a,(wTextIsActive)		; $67ed
	or a			; $67f0
	ret nz			; $67f1
	ld hl,@warpDest		; $67f2
	call setWarpDestVariables		; $67f5
	ld a,SND_TELEPORT		; $67f8
	jp playSound		; $67fa

@warpDest:
	.db $82 $e7 $00 $25 $83

@substate2:
	ret			; $6802

@substate3:
	jp objectSetVisiblec2		; $6803


@initGraphicsAndIncState: ; Unused?
	call interactionInitGraphics		; $6806
	call objectMarkSolidPosition		; $6809
	jp interactionIncState		; $680c


_dog_initGraphicsLoadScriptAndIncState:
	call interactionInitGraphics		; $680f
	call objectMarkSolidPosition		; $6812
	ld e,Interaction.subid		; $6815
	ld a,(de)		; $6817
	ld hl,_dog_scriptTable		; $6818
	rst_addDoubleIndex			; $681b
	ldi a,(hl)		; $681c
	ld h,(hl)		; $681d
	ld l,a			; $681e
	call interactionSetScript		; $681f
	jp interactionIncState		; $6822

;;
; @addr{6825}
_dog_moveTowardTargetPosition:
	ld h,d			; $6825
	ld l,Interaction.var3a		; $6826
	ld a,(hl)		; $6828
	add a			; $6829
	ld b,a			; $682a

	ld e,Interaction.var3d		; $682b
	ld a,(de)		; $682d
	ld l,a			; $682e
	ld e,Interaction.var3c		; $682f
	ld a,(de)		; $6831
	ld h,a			; $6832
	ld a,b			; $6833
	rst_addAToHl			; $6834
	ld b,(hl)		; $6835
	inc hl			; $6836
	ld c,(hl)		; $6837
	call objectGetRelativeAngle		; $6838
	ld e,Interaction.angle		; $683b
	ld (de),a		; $683d
	jp objectApplySpeed		; $683e

;;
; @param[out]	cflag	Set if close to target position
; @addr{6841}
_dog_checkCloseToTargetPosition:
	call _dog_getTargetPositionAddress		; $6841
	ld l,Interaction.yh		; $6844
	ld a,(bc)		; $6846
	sub (hl)		; $6847
	add $01			; $6848
	cp $05			; $684a
	ret nc			; $684c
	inc bc			; $684d
	ld l,Interaction.xh		; $684e
	ld a,(bc)		; $6850
	sub (hl)		; $6851
	add $01			; $6852
	cp $05			; $6854
	ret			; $6856

;;
; Update direction based on angle.
; @addr{6857}
_dog_updateDirection:
	ld h,d			; $6857
	ld l,Interaction.angle		; $6858
	ld a,(hl)		; $685a
	swap a			; $685b
	and $01			; $685d
	xor $01			; $685f
	ld l,Interaction.direction		; $6861
	cp (hl)			; $6863
	ret z			; $6864
	ld (hl),a		; $6865
	add $02			; $6866
	jp interactionSetAnimation		; $6868

;;
; @param[out]	cflag	Set if the position index "looped" (dog went off-screen)
; @addr{686b}
_dog_incTargetPositionIndex:
	call _dog_snapToTargetPosition		; $686b
	ld h,d			; $686e
	ld l,Interaction.var3b		; $686f
	ld a,(hl)		; $6871
	ld l,Interaction.var3a		; $6872
	inc (hl)		; $6874

	; Check whether to loop back around
	cp (hl)			; $6875
	ret nc			; $6876
	ld (hl),$00		; $6877
	scf			; $6879
	ret			; $687a

;;
; @addr{687b}
_dog_snapToTargetPosition:
	call _dog_getTargetPositionAddress		; $687b
	ld l,Interaction.y		; $687e
	xor a			; $6880
	ldi (hl),a		; $6881
	ld a,(bc)		; $6882
	ld (hl),a		; $6883
	inc bc			; $6884
	ld l,Interaction.x		; $6885
	xor a			; $6887
	ldi (hl),a		; $6888
	ld a,(bc)		; $6889
	ld (hl),a		; $688a
	ret			; $688b

;;
; @param[out]	bc	Address of target position (2 bytes, Y and X)
; @addr{688c}
_dog_getTargetPositionAddress:
	ld e,Interaction.var3d		; $688c
	ld a,(de)		; $688e
	ld c,a			; $688f
	ld e,Interaction.var3c		; $6890
	ld a,(de)		; $6892
	ld b,a			; $6893
	ld h,d			; $6894
	ld l,Interaction.var3a		; $6895
	ld a,(hl)		; $6897
	call addDoubleIndexToBc		; $6898
	ret			; $689b

;;
; This function is supposed to return the address of a "position list" for a map; however,
; due to an apparent issue with the caller, the data for the first map is always used.
;
; @param	a	Index of data to read (0-3 for corresponding maps)
; @addr{689c}
_dog_setTargetPositionIndex:
	ld hl,@dogPositionLists		; $689c
	rst_addDoubleIndex			; $689f
	ld e,Interaction.var3d		; $68a0
	ldi a,(hl)		; $68a2
	ld (de),a		; $68a3
	ld e,Interaction.var3c		; $68a4
	ldi a,(hl)		; $68a6
	ld (de),a		; $68a7

	ld e,Interaction.var3b		; $68a8
	ld a,$06		; $68aa
	ld (de),a		; $68ac
	ret			; $68ad

@dogPositionLists:
	.dw @map0
	.dw @map1
	.dw @map2
	.dw @map3

@map0:
	.db $68 $68
	.db $48 $48
	.db $68 $18
	.db $68 $48
	.db $48 $28
	.db $68 $58
	.db $48 $00
@map1:
	.db $38 $78
	.db $68 $28
	.db $68 $88
	.db $68 $38
	.db $28 $68
	.db $58 $48
	.db $48 $b0
@map2:
	.db $68 $28
	.db $48 $08
	.db $58 $58
	.db $28 $18
	.db $18 $68
	.db $48 $38
	.db $00 $68
@map3:
	.db $18 $38
	.db $68 $78
	.db $68 $28
	.db $38 $78
	.db $38 $38
	.db $58 $68
	.db $58 $00


_dog_scriptTable:
	.dw dogInMamamusHouseScript


; ==============================================================================
; INTERACID_POSTMAN
; ==============================================================================
interactionCode55:
	call checkInteractionState		; $68f0
	jr nz,@state1		; $68f3

@state0:
	call @loadScriptAndInitGraphics		; $68f5
@state1:
	call interactionRunScript		; $68f8
	jp c,interactionDelete		; $68fb

	ld e,Interaction.var3f		; $68fe
	ld a,(de)		; $6900
	or a			; $6901
	jp z,npcFaceLinkAndAnimate		; $6902
	call interactionAnimateBasedOnSpeed		; $6905
	jp objectSetPriorityRelativeToLink_withTerrainEffects		; $6908

@unusedFunc_690b:
	call interactionInitGraphics		; $690b
	jp interactionIncState		; $690e

@loadScriptAndInitGraphics:
	call interactionInitGraphics		; $6911
	ld a,>TX_0b00		; $6914
	call interactionSetHighTextIndex		; $6916

	ld e,Interaction.subid		; $6919
	ld a,(de)		; $691b
	ld hl,@scriptTable		; $691c
	rst_addDoubleIndex			; $691f
	ldi a,(hl)		; $6920
	ld h,(hl)		; $6921
	ld l,a			; $6922
	call interactionSetScript		; $6923

	jp interactionIncState		; $6926

@scriptTable:
	.dw postmanScript


; ==============================================================================
; INTERACID_PICKAXE_WORKER
; ==============================================================================
interactionCode57:
	ld e,Interaction.subid		; $692b
	ld a,(de)		; $692d
	rst_jumpTable			; $692e
	.dw @subid00
	.dw @subid01
	.dw @subid02
	.dw @subid03

; Subid 0: Worker below Maku Tree screen in past
; Subid 3: Worker in black tower.
@subid00:
@subid03:
	call checkInteractionState		; $6937
	jr nz,@@state1		; $693a

@@state0:
	call @loadScriptAndInitGraphics		; $693c
	call interactionSetAlwaysUpdateBit		; $693f

@@state1:
	call interactionRunScript		; $6942
	jp c,interactionDelete		; $6945

	call interactionAnimateAsNpc		; $6948
	ld e,Interaction.animParameter		; $694b
	ld a,(de)		; $694d
	or a			; $694e
	ret z			; $694f

	; animParameter is nonzero; just struck the ground.
	ld a,SND_CLINK		; $6950
	call playSound		; $6952
	ld a,(wScrollMode)		; $6955
	and $01			; $6958
	ret z			; $695a
	ld a,$03		; $695b
	jp @createDirtChips		; $695d


; Credits cutscene guy making Link statue?
@subid01:
	call checkInteractionState		; $6960
	jr nz,@subid1State1		; $6963

@subid1And2State0:
	ld e,Interaction.subid		; $6965
	ld a,(de)		; $6967
	dec a			; $6968
	ld a,$0c		; $6969
	jr z,+			; $696b
	ld a,$f4		; $696d
+
	ld e,Interaction.var38		; $696f
	ld (de),a		; $6971
	call @loadScriptAndInitGraphics		; $6972

@subid1State1:
	ld e,Interaction.state2		; $6975
	ld a,(de)		; $6977
	rst_jumpTable			; $6978
	.dw @subid1And2Substate0
	.dw @subid1Substate1
	.dw @subid1Substate2
	.dw @subid1Substate3
	.dw @updateAnimationAndRunScript


@subid1And2Substate0:
	ld a,($cfc0)		; $6983
	cp $01			; $6986
	jr nz,@label_09_221	; $6988

	call interactionIncState2		; $698a
	ld l,Interaction.subid		; $698d
	ld a,(hl)		; $698f
	dec a			; $6990
	ld hl,@subid1And2ScriptTable		; $6991
	rst_addDoubleIndex			; $6994
	ldi a,(hl)		; $6995
	ld h,(hl)		; $6996
	ld l,a			; $6997
	jp interactionSetScript		; $6998

@label_09_221:
	call interactionAnimateBasedOnSpeed		; $699b
	call interactionRunScript		; $699e
	ld h,d			; $69a1
	ld l,Interaction.animParameter		; $69a2
	ld a,(hl)		; $69a4
	or a			; $69a5
	jr z,@doneSpawningObjects			; $69a6

	; Spawn in some objects when pickaxe hits statue?
	ld (hl),$00		; $69a8
	ld b,$04		; $69aa
@nextObject:
	call getFreeInteractionSlot		; $69ac
	ret nz			; $69af
	ld (hl),INTERACID_EXPLOSION_WITH_DEBRIS		; $69b0
	inc l			; $69b2
	ld (hl),$02		; $69b3
	inc l			; $69b5
	ld (hl),b		; $69b6
	ld e,Interaction.visible		; $69b7
	ld a,(de)		; $69b9
	ld l,Interaction.var38		; $69ba
	ld (hl),a		; $69bc
	push bc			; $69bd
	ld e,Interaction.var38		; $69be
	ld a,(de)		; $69c0
	ld b,$00		; $69c1
	ld c,a			; $69c3
	call objectCopyPositionWithOffset		; $69c4
	pop bc			; $69c7
	dec b			; $69c8
	jr nz,@nextObject	; $69c9

@doneSpawningObjects:
	ld l,Interaction.yh		; $69cb
	ld a,(hl)		; $69cd
	cp $50			; $69ce
	jp nc,objectSetVisiblec1		; $69d0
	jp objectSetVisiblec3		; $69d3

@subid1Substate1:
	call @updateAnimationAndRunScript		; $69d6
	ret nc			; $69d9
	call interactionIncState2		; $69da
	ld l,Interaction.counter1		; $69dd
	ld (hl),210		; $69df
	ret			; $69e1

@updateAnimationAndRunScript:
	ld e,Interaction.var3f		; $69e2
	ld a,(de)		; $69e4
	or a			; $69e5
	call z,interactionAnimateBasedOnSpeed		; $69e6
	jp interactionRunScript		; $69e9

@subid1Substate2:
	call interactionAnimateBasedOnSpeed		; $69ec
	call objectApplySpeed		; $69ef
	call interactionDecCounter1		; $69f2
	ret nz			; $69f5
	call interactionIncState2		; $69f6
	jp fadeoutToWhite		; $69f9

@subid1Substate3:
	ld a,(wPaletteThread_mode)		; $69fc
	or a			; $69ff
	ret nz			; $6a00

	call interactionIncState2		; $6a01
	ld a,$06		; $6a04
	ld ($cfc0),a		; $6a06
	call disableLcd		; $6a09
	push de			; $6a0c

	; Force-reload maku tree screen?
	ld bc,$0138		; $6a0d
	ld a,$00		; $6a10
	call func_36f6		; $6a12

	ld a,UNCMP_GFXH_2d		; $6a15
	call loadUncompressedGfxHeader		; $6a17
	ld a,PALH_30		; $6a1a
	call loadPaletteHeader		; $6a1c
	ld a,GFXH_84		; $6a1f
	call loadGfxHeader		; $6a21

	ld a,$ff		; $6a24
	ld (wAreaAnimation),a		; $6a26
	ld a,$04		; $6a29
	call loadGfxRegisterStateIndex		; $6a2b

	pop de			; $6a2e
	ld bc,$427e		; $6a2f
	call interactionSetPosition		; $6a32
	ld a,$02		; $6a35
	ld hl,@subid1And2ScriptTable		; $6a37
	rst_addDoubleIndex			; $6a3a
	ldi a,(hl)		; $6a3b
	ld h,(hl)		; $6a3c
	ld l,a			; $6a3d
	call interactionSetScript		; $6a3e
	jp fadeinFromWhite		; $6a41


; Credits cutscene guy making Link statue?
@subid02:
	call checkInteractionState		; $6a44
	jr nz,++		; $6a47
	jp @subid1And2State0		; $6a49
++
	ld e,Interaction.state2		; $6a4c
	ld a,(de)		; $6a4e
	rst_jumpTable			; $6a4f
	.dw @subid1And2Substate0
	.dw @subid2Substate1
	.dw @subid2Substate2
	.dw @updateAnimationAndRunScript

@subid2Substate1:
	call @updateAnimationAndRunScript		; $6a58
	ret nc			; $6a5b
	call interactionIncState2		; $6a5c

@subid2Substate2:
	call interactionAnimateBasedOnSpeed		; $6a5f
	call objectApplySpeed		; $6a62
	ld a,($cfc0)		; $6a65
	cp $06			; $6a68
	ret nz			; $6a6a
	call interactionIncState2		; $6a6b
	ld bc,$388a		; $6a6e
	call interactionSetPosition		; $6a71
	ld a,$03		; $6a74
	ld hl,@subid1And2ScriptTable		; $6a76
	rst_addDoubleIndex			; $6a79
	ldi a,(hl)		; $6a7a
	ld h,(hl)		; $6a7b
	ld l,a			; $6a7c
	jp interactionSetScript		; $6a7d


@unusedFunc_6a80:
	call interactionInitGraphics		; $6a80
	call objectMarkSolidPosition		; $6a83
	jp interactionIncState		; $6a86


@loadScriptAndInitGraphics:
	call interactionInitGraphics		; $6a89
	call objectMarkSolidPosition		; $6a8c
	ld a,>TX_1b00		; $6a8f
	call interactionSetHighTextIndex		; $6a91
	ld e,Interaction.subid		; $6a94
	ld a,(de)		; $6a96
	ld hl,@scriptTable		; $6a97
	rst_addDoubleIndex			; $6a9a
	ldi a,(hl)		; $6a9b
	ld h,(hl)		; $6a9c
	ld l,a			; $6a9d
	call interactionSetScript		; $6a9e
	jp interactionIncState		; $6aa1

;;
; Create the debris that comes out when the pickaxe hits the ground.
; @addr{6aa4}
@createDirtChips:
	ld c,a			; $6aa4
	ld b,$02		; $6aa5

; b = number of objects to create
; c = var03
@next:
	call getFreeInteractionSlot		; $6aa7
	ret nz			; $6aaa
	ld (hl),INTERACID_FALLING_ROCK		; $6aab
	inc l			; $6aad
	ld (hl),$06 ; [new.subid] = $06
	inc l			; $6ab0
	ld (hl),c   ; [new.var03] = c

	ld e,Interaction.visible		; $6ab2
	ld a,(de)		; $6ab4
	and $03			; $6ab5
	ld l,Interaction.counter2		; $6ab7
	ld (hl),a		; $6ab9
	ld l,Interaction.angle		; $6aba
	ld (hl),b		; $6abc
	dec (hl)		; $6abd

	push bc			; $6abe
	call objectCopyPosition		; $6abf
	pop bc			; $6ac2

	; [new.yh] = [this.yh]+4
	ld l,Interaction.yh		; $6ac3
	ld a,(hl)		; $6ac5
	add $04			; $6ac6

	; [new.xh] = [this.xh]-$0e if [this.animParameter] == $01, otherwise [this.xh]+$0e
	ld (hl),a		; $6ac8
	ld e,Interaction.animParameter		; $6ac9
	ld a,(de)		; $6acb
	cp $01			; $6acc
	ld l,Interaction.xh		; $6ace
	ld a,(hl)		; $6ad0
	jr z,+			; $6ad1
	add $0e*2			; $6ad3
+
	sub $0e			; $6ad5
	ld (hl),a		; $6ad7

	dec b			; $6ad8
	jr nz,@next	; $6ad9
	ret			; $6adb


@scriptTable:
	.dw pickaxeWorkerSubid00Script
	.dw pickaxeWorkerSubid01Script_part1
	.dw pickaxeWorkerSubid02Script_part1
	.dw pickaxeWorkerSubid03Script

@subid1And2ScriptTable:
	.dw pickaxeWorkerSubid01Script_part2
	.dw pickaxeWorkerSubid02Script_part2
	.dw pickaxeWorkerSubid01Script_part3
	.dw pickaxeWorkerSubid02Script_part3


; ==============================================================================
; INTERACID_HARDHAT_WORKER
; ==============================================================================
interactionCode58:
	ld e,Interaction.subid		; $6aec
	ld a,(de)		; $6aee
	rst_jumpTable			; $6aef
	.dw @subid00
	.dw @subid01
	.dw @subid02
	.dw @subid03


; NPC who gives you the shovel. If var03 is nonzero, he's just a generic guy.
@subid00:
	call checkInteractionState		; $6af8
	jr nz,@@state1	; $6afb

@@state0:
	call @loadScriptAndInitGraphics		; $6afd
	call interactionSetAlwaysUpdateBit		; $6b00
	ld a,$04		; $6b03
	call interactionSetAnimation		; $6b05
@@state1:
	call interactionRunScript		; $6b08
	jp c,interactionDelete		; $6b0b
	jp interactionAnimateAsNpc		; $6b0e


; Generic NPC.
@subid01:
	call checkInteractionState		; $6b11
	jr nz,@@state1		; $6b14

@@state0:
	call @loadScriptAndInitGraphics		; $6b16
	call interactionRunScript		; $6b19
	call interactionRunScript		; $6b1c
@@state1:
	call interactionRunScript		; $6b1f
	jp c,interactionDeleteAndUnmarkSolidPosition		; $6b22
	jp npcFaceLinkAndAnimate		; $6b25


; NPC who guards the entrance to the black tower.
@subid02:
	call checkInteractionState		; $6b28
	jr nz,@@state1	; $6b2b

@@state0:
	ld a,(wEssencesObtained)		; $6b2d
	bit 3,a			; $6b30
	jp nz,interactionDelete		; $6b32
	call getThisRoomFlags		; $6b35
	bit 7,a			; $6b38
	jr z,+			; $6b3a
	ld bc,$3858		; $6b3c
	call interactionSetPosition		; $6b3f
+
	call @loadScriptAndInitGraphics		; $6b42
@@state1:
	call interactionRunScript		; $6b45
	ld e,Interaction.var38		; $6b48
	ld a,(de)		; $6b4a
	or a			; $6b4b
	jp z,npcFaceLinkAndAnimate		; $6b4c
	jp interactionAnimateAsNpc		; $6b4f


@subid03:
	call checkInteractionState		; $6b52
	jr nz,@@state1		; $6b55

@@state0:
	call @loadScriptAndInitGraphics		; $6b57
	call interactionRunScript		; $6b5a
@@state1:
	call interactionRunScript		; $6b5d
	jp c,interactionDelete		; $6b60

	ld e,Interaction.var3f		; $6b63
	ld a,(de)		; $6b65
	or a			; $6b66
	jp z,npcFaceLinkAndAnimate		; $6b67
	call interactionAnimateBasedOnSpeed		; $6b6a
	jp interactionPushLinkAwayAndUpdateDrawPriority		; $6b6d


@unusedFunc_6b70:
	call interactionInitGraphics		; $6b70
	call objectMarkSolidPosition		; $6b73
	jp interactionIncState		; $6b76


@loadScriptAndInitGraphics:
	call interactionInitGraphics		; $6b79
	call objectMarkSolidPosition		; $6b7c
	ld a,>TX_1000		; $6b7f
	call interactionSetHighTextIndex		; $6b81
	ld e,Interaction.subid		; $6b84
	ld a,(de)		; $6b86
	ld hl,@scriptTable		; $6b87
	rst_addDoubleIndex			; $6b8a
	ldi a,(hl)		; $6b8b
	ld h,(hl)		; $6b8c
	ld l,a			; $6b8d
	call interactionSetScript		; $6b8e
	jp interactionIncState		; $6b91

@scriptTable:
	.dw hardhatWorkerSubid00Script
	.dw hardhatWorkerSubid01Script
	.dw hardhatWorkerSubid02Script
	.dw hardhatWorkerSubid03Script


; ==============================================================================
; INTERACID_POE
;
; var3e: Animations don't update when nonzero. (Used when disappearing.)
; var3f: If nonzero, doesn't face toward Link.
; ==============================================================================
interactionCode59:
	call checkInteractionState		; $6b9c
	jr nz,@state1	; $6b9f

@state0:
	ld e,Interaction.var03		; $6ba1
	ld a,(de)		; $6ba3
	rst_jumpTable			; $6ba4
	.dw @initSubid00
	.dw @initSubid01
	.dw @initSubid02


; (Note, these are labelled as subid, but they're really based on var03.)
; First encounter with poe.
@initSubid00:
	; Delete self if already talked (either in overworld on in tomb)
	call getThisRoomFlags		; $6bab
	bit 6,(hl)		; $6bae
	jp nz,interactionDelete		; $6bb0
	ld hl,wPresentRoomFlags+$2e		; $6bb3
	bit 6,(hl)		; $6bb6
	jp nz,interactionDelete		; $6bb8

	jr @init		; $6bbb


; Final encounter with poe where you get the clock
@initSubid02:
	; Delete self if already got item, or haven't talked yet in either overworld or
	; tomb
	call getThisRoomFlags		; $6bbd
	bit ROOMFLAG_BIT_ITEM,(hl)		; $6bc0
	jp nz,interactionDelete		; $6bc2
	bit 6,(hl)		; $6bc5
	jp z,interactionDelete		; $6bc7
	ld hl,wPresentRoomFlags+$2e		; $6bca
	bit 6,(hl)		; $6bcd
	jp z,interactionDelete		; $6bcf

	jr @init		; $6bd2


; Poe in his tomb
@initSubid01:
	; Delete self if haven't talked in overworld, or have talked in tomb.
	ld hl,wPresentRoomFlags+$7c		; $6bd4
	bit 6,(hl)		; $6bd7
	jp z,interactionDelete		; $6bd9
	call getThisRoomFlags		; $6bdc
	bit 6,(hl)		; $6bdf
	jp nz,interactionDelete		; $6be1

@init:
	call @loadScriptAndInitGraphics		; $6be4
@state1:
	call interactionRunScript		; $6be7
	jp c,interactionDelete		; $6bea

	ld e,Interaction.var3e		; $6bed
	ld a,(de)		; $6bef
	or a			; $6bf0
	ret nz			; $6bf1
	ld e,Interaction.var3f		; $6bf2
	ld a,(de)		; $6bf4
	or a			; $6bf5
	jp z,npcFaceLinkAndAnimate		; $6bf6
	call interactionAnimate		; $6bf9
	jp objectSetPriorityRelativeToLink_withTerrainEffects		; $6bfc


@unusedFunc_6bff:
	call interactionInitGraphics		; $6bff
	call objectMarkSolidPosition		; $6c02
	jp interactionIncState		; $6c05


@loadScriptAndInitGraphics:
	call interactionInitGraphics		; $6c08
	call objectMarkSolidPosition		; $6c0b
	ld e,Interaction.subid		; $6c0e
	ld a,(de)		; $6c10
	ld hl,@scriptTable		; $6c11
	rst_addDoubleIndex			; $6c14
	ldi a,(hl)		; $6c15
	ld h,(hl)		; $6c16
	ld l,a			; $6c17
	call interactionSetScript		; $6c18
	jp interactionIncState		; $6c1b

@scriptTable:
	.dw poeScript


; ==============================================================================
; INTERACID_OLD_ZORA
; ==============================================================================
interactionCode5a:
	call checkInteractionState		; $6c20
	jr nz,@state1	; $6c23

@state0:
	call @loadScriptAndInitGraphics		; $6c25
	call interactionSetAlwaysUpdateBit		; $6c28
@state1:
	call interactionRunScript		; $6c2b
	jp c,interactionDelete		; $6c2e
	jp interactionAnimateAsNpc		; $6c31

@unusedFunc_6c34:
	call interactionInitGraphics		; $6c34
	jp interactionIncState		; $6c37

@loadScriptAndInitGraphics:
	call interactionInitGraphics		; $6c3a
	ld a,>TX_0b00		; $6c3d
	call interactionSetHighTextIndex		; $6c3f
	ld e,Interaction.subid		; $6c42
	ld a,(de)		; $6c44
	ld hl,@scriptTable		; $6c45
	rst_addDoubleIndex			; $6c48
	ldi a,(hl)		; $6c49
	ld h,(hl)		; $6c4a
	ld l,a			; $6c4b
	call interactionSetScript		; $6c4c
	jp interactionIncState		; $6c4f

@scriptTable:
	.dw oldZoraScript


; ==============================================================================
; INTERACID_TOILET_HAND
; ==============================================================================
interactionCode5b:
	ld e,Interaction.state		; $6c54
	ld a,(de)		; $6c56
	rst_jumpTable			; $6c57
	.dw @state0
	.dw @state1
	.dw @state2

@state0:
	call @loadScriptAndInitGraphics		; $6c5e
	call interactionSetAlwaysUpdateBit		; $6c61
	callab interactionBank1.clearFallDownHoleEventBuffer		; $6c64


; Normal script is running; waiting for Link to talk or for something to fall into a hole.
@state1:
	call @respondToObjectInHole		; $6c6c
	jr c,@droppedSomethingIntoHole			; $6c6f

	call interactionRunScript		; $6c71
	ld h,d			; $6c74
	ld l,Interaction.visible		; $6c75
	bit 7,(hl)		; $6c77
	ret z			; $6c79
	jp interactionAnimateAsNpc		; $6c7a

@droppedSomethingIntoHole:
	ld hl,toiletHandScript_reactToObjectInHole		; $6c7d
	call interactionSetScript		; $6c80
	jp interactionIncState		; $6c83


; Running the "object fell in a hole" script; returns to state 1 when that's done.
@state2:
	ld a,(wTextIsActive)		; $6c86
	or a			; $6c89
	ret nz			; $6c8a

	call interactionRunScript		; $6c8b
	jr c,@scriptEnded			; $6c8e

	ld h,d			; $6c90
	ld l,Interaction.visible		; $6c91
	bit 7,(hl)		; $6c93
	ret z			; $6c95
	call interactionAnimateAsNpc		; $6c96
	jp interactionAnimate		; $6c99

@scriptEnded:
	call @loadScript		; $6c9c
	callab interactionBank1.clearFallDownHoleEventBuffer		; $6c9f
	ld e,Interaction.state		; $6ca7
	ld a,$01		; $6ca9
	ld (de),a		; $6cab
	ret			; $6cac


@unusedFunc_6c0d:
	call interactionInitGraphics		; $6cad
	jp interactionIncState		; $6cb0


@loadScriptAndInitGraphics:
	call interactionInitGraphics		; $6cb3
	ld a,>TX_0b00		; $6cb6
	call interactionSetHighTextIndex		; $6cb8
	call interactionIncState		; $6cbb

@loadScript:
	ld e,Interaction.subid		; $6cbe
	ld a,(de)		; $6cc0
	ld hl,@scriptTable		; $6cc1
	rst_addDoubleIndex			; $6cc4
	ldi a,(hl)		; $6cc5
	ld h,(hl)		; $6cc6
	ld l,a			; $6cc7
	jp interactionSetScript		; $6cc8

;;
; Reads from the "object fallen in hole" buffer at $cfd8 to decide on a reaction. Sets
; var38 to an index based on which item it was to be used in a script later.
;
; @param[out]	cflag	c if there is a defined reaction to the object that fell in the
;                       hole (and something did indeed fall in).
; @addr{6ccb}
@respondToObjectInHole:
	ld a,(wTextIsActive)		; $6ccb
	or a			; $6cce
	ret nz			; $6ccf

	ld a,($cfd8)		; $6cd0
	inc a			; $6cd3
	ld e,a			; $6cd4
	ld hl,@objectTypeTable		; $6cd5
	call lookupKey		; $6cd8
	ret nc			; $6cdb

	ld hl,@objectReactionTable		; $6cdc
	rst_addDoubleIndex			; $6cdf
	ldi a,(hl)		; $6ce0
	ld h,(hl)		; $6ce1
	ld l,a			; $6ce2
	ld a,($cfd9)		; $6ce3
	ld e,a			; $6ce6
	call lookupKey		; $6ce7
	ret nc			; $6cea
	ld e,Interaction.var38		; $6ceb
	ld (de),a		; $6ced
	ret			; $6cee

@objectTypeTable:
	.db Item.id,        $00
	.db Interaction.id, $01
	.db $00

@objectReactionTable:
	.dw @items
	.dw @interactions

; First byte is the object ID to detect; second is an index that the script will use later
; (gets written to var38).
@items:
	.db ITEMID_BOMB,          $00
	.db ITEMID_BOMBCHUS,      $01
	.db ITEMID_18,            $02
	.db ITEMID_EMBER_SEED,    $03
	.db ITEMID_SCENT_SEED,    $04
	.db ITEMID_GALE_SEED,     $05
	.db ITEMID_MYSTERY_SEED,  $06
	.db ITEMID_BRACELET,      $07
	.db $00

@interactions:
	.db INTERACID_PUSHBLOCK,  $07
	.db $00

@scriptTable:
	.dw toiletHandScript


; ==============================================================================
; INTERACID_MASK_SALESMAN
; ==============================================================================
interactionCode5c:
	call checkInteractionState		; $6d0e
	jr nz,@state1	; $6d11

@state0:
	call @loadScriptAndInitGraphics		; $6d13
	call interactionSetAlwaysUpdateBit		; $6d16
@state1:
	call interactionRunScript		; $6d19
	jp c,interactionDelete		; $6d1c
	jp interactionAnimateAsNpc		; $6d1f
	call interactionInitGraphics		; $6d22
	jp interactionIncState		; $6d25

@loadScriptAndInitGraphics:
	call interactionInitGraphics		; $6d28
	ld e,Interaction.subid		; $6d2b
	ld a,(de)		; $6d2d
	ld hl,@scriptTable		; $6d2e
	rst_addDoubleIndex			; $6d31
	ldi a,(hl)		; $6d32
	ld h,(hl)		; $6d33
	ld l,a			; $6d34
	call interactionSetScript		; $6d35
	jp interactionIncState		; $6d38

@scriptTable:
	.dw maskSalesmanScript


; ==============================================================================
; INTERACID_BEAR
; ==============================================================================
interactionCode5d:
	ld e,Interaction.state		; $6d3d
	ld a,(de)		; $6d3f
	rst_jumpTable			; $6d40
	.dw _bear_state0
	.dw _bear_state1


_bear_state0:
	ld a,$01		; $6d45
	ld (de),a		; $6d47
	call interactionInitGraphics		; $6d48
	call objectSetVisiblec2		; $6d4b
	call @initSubid		; $6d4e
	ld e,Interaction.enabled		; $6d51
	ld a,(de)		; $6d53
	or a			; $6d54
	jp nz,objectMarkSolidPosition		; $6d55
	ret			; $6d58

@initSubid:
	ld e,Interaction.subid		; $6d59
	ld a,(de)		; $6d5b
	rst_jumpTable			; $6d5c
	.dw @initSubid00
	.dw @initSubid01
	.dw @initSubid02

@initSubid00:
	; If you've talked to the bear already, shift him down 16 pixels
	call getThisRoomFlags		; $6d63
	bit 7,a			; $6d66
	jr nz,++		; $6d68

	ld e,Interaction.yh		; $6d6a
	ld a,(de)		; $6d6c
	add $10			; $6d6d
	ld (de),a		; $6d6f
++
	ld hl,bearSubid00Script_part1		; $6d70
	jp interactionSetScript		; $6d73

@initSubid01:
	ret			; $6d76

@initSubid02:
	ld e,Interaction.var03		; $6d77
	ld a,(de)		; $6d79
	or a			; $6d7a
	jr nz,@var03IsNonzero	; $6d7b

	; var03 is $00.

	ld a,GLOBALFLAG_INTRO_DONE		; $6d7d
	call checkGlobalFlag		; $6d7f
	jp z,interactionDelete		; $6d82

	; Spawn animal buddies
	ld hl,objectData.animalsWaitingForNayru		; $6d85
	call parseGivenObjectData		; $6d88

	ld a,GLOBALFLAG_FINISHEDGAME		; $6d8b
	call checkGlobalFlag		; $6d8d
	jp nz,interactionDelete		; $6d90
	ld a,GLOBALFLAG_MAKU_TREE_SAVED		; $6d93
	call checkGlobalFlag		; $6d95
	jp z,interactionDelete		; $6d98

	; Text changes after saving Nayru
	ld a,GLOBALFLAG_SAVED_NAYRU		; $6d9b
	call checkGlobalFlag		; $6d9d
	ld a,$00		; $6da0
	jp z,+			; $6da2
	inc a			; $6da5
+
	jr ++		; $6da6

@var03IsNonzero:
	ld a,GLOBALFLAG_FINISHEDGAME		; $6da8
	call checkGlobalFlag		; $6daa
	jp z,interactionDelete		; $6dad
	ld a,$02		; $6db0
++
	call @chooseTextID		; $6db2
	ld hl,bearSubid02Script		; $6db5
	jp interactionSetScript		; $6db8

@chooseTextID:
	ld hl,@textIDs		; $6dbb
	rst_addAToHl			; $6dbe
	ld a,(hl)		; $6dbf
	ld e,Interaction.textID		; $6dc0
	ld (de),a		; $6dc2
	ld a,>TX_5700		; $6dc3
	inc e			; $6dc5
	ld (de),a		; $6dc6
	ret			; $6dc7

@textIDs:
	.db <TX_5712
	.db <TX_5713
	.db <TX_5714


_bear_state1:
	ld e,Interaction.subid		; $6dcb
	ld a,(de)		; $6dcd
	rst_jumpTable			; $6dce
	.dw @runSubid00
	.dw interactionAnimate
	.dw @runSubid02


; Bear listening to Nayru at start of game.
@runSubid00:
	call interactionAnimateAsNpc		; $6dd5
	ld e,Interaction.state2		; $6dd8
	ld a,(de)		; $6dda
	rst_jumpTable			; $6ddb
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4

@substate0:
	call interactionRunScript		; $6de6

	; Wait for Link to get close enough to trigger the cutscene
	ld hl,w1Link.xh		; $6de9
	ld a,(hl)		; $6dec
	cp $60			; $6ded
	ret c			; $6def
	ld l,<w1Link.yh		; $6df0
	ld a,(hl)		; $6df2
	cp $3e			; $6df3
	ret nc			; $6df5

	; Put Link into the cutscene state
	ld a,SPECIALOBJECTID_LINK_CUTSCENE		; $6df6
	call setLinkIDOverride		; $6df8
	ld l,<w1Link.subid		; $6dfb
	ld (hl),$03		; $6dfd

	ld hl,bearSubid00Script_part2		; $6dff
	call interactionSetScript		; $6e02
	call interactionIncState2		; $6e05

@substate1:
	call interactionRunScript		; $6e08
	ld a,($cfd0)		; $6e0b
	cp $0e			; $6e0e
	ret nz			; $6e10
	call interactionIncState2		; $6e11
	ld a,$02		; $6e14
	jp interactionSetAnimation		; $6e16

@substate2:
	call interactionAnimate		; $6e19
	ld a,($cfd0)		; $6e1c
	cp $10			; $6e1f
	ret nz			; $6e21
	call interactionIncState2		; $6e22
	ld l,Interaction.counter1		; $6e25
	ld (hl),40		; $6e27
	ret			; $6e29

@substate3:
	call interactionDecCounter1		; $6e2a
	jp nz,interactionAnimate		; $6e2d
	call interactionIncState2		; $6e30
	ld l,Interaction.angle		; $6e33
	ld (hl),$02		; $6e35
	ld l,Interaction.speed		; $6e37
	ld (hl),SPEED_100		; $6e39
	ld a,$01		; $6e3b
	jp interactionSetAnimation		; $6e3d

@substate4:
	call objectCheckWithinScreenBoundary		; $6e40
	jp nc,interactionDelete		; $6e43
	call objectApplySpeed		; $6e46
	jp interactionAnimate		; $6e49


@runSubid02:
	call interactionRunScript		; $6e4c
	jp c,interactionDelete		; $6e4f
	jp interactionAnimateAsNpc		; $6e52


; ==============================================================================
; INTERACID_SWORD
; ==============================================================================
interactionCode5e:
	ld e,Interaction.state		; $6e55
	ld a,(de)		; $6e57
	rst_jumpTable			; $6e58
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $6e5d
	ld (de),a		; $6e5f

	; var37 holds last animation (set $ff to force update)
	ld a,$ff		; $6e60
	ld e,Interaction.var37		; $6e62

	ld (de),a		; $6e64
	call interactionInitGraphics		; $6e65

@state1:
	; Invisible by default
	call objectSetInvisible		; $6e68

	; If [relatedObj1.enabled] & ([this.var3f]+1) == 0, delete self
	ld a,Object.enabled		; $6e6b
	call objectGetRelatedObject1Var		; $6e6d
	ld l,Interaction.var3f		; $6e70
	ld a,(hl)		; $6e72
	inc a			; $6e73
	ld l,Interaction.enabled		; $6e74
	and (hl)		; $6e76
	jp z,interactionDelete		; $6e77

	; Set visible if bit 7 of [relatedObj1.animParameter] is set
	ld l,Interaction.animParameter		; $6e7a
	ld a,(hl)		; $6e7c
	ld b,a			; $6e7d
	and $80			; $6e7e
	ret z			; $6e80

	; Animation number = [relatedObj1.animParameter]&0x7f
	ld a,b			; $6e81
	and $7f			; $6e82
	push hl			; $6e84
	ld h,d			; $6e85
	ld l,Interaction.var37		; $6e86
	cp (hl)			; $6e88
	jr z,+			; $6e89
	ld (hl),a		; $6e8b
	call interactionSetAnimation		; $6e8c
+
	pop hl			; $6e8f
	call objectTakePosition		; $6e90
	jp objectSetVisible83		; $6e93


; ==============================================================================
; INTERACID_SYRUP
;
; Variables:
;   var38: Set to 1 if Link can't purchase an item (because he has too many of it)
;   var3a: "Return value" from purchase script (if $ff, the purchase failed)
;   var3b: Object index of item that Link is holding
; ==============================================================================
interactionCode5f:
	callab checkReloadShopItemTiles		; $6e96
	call @runState		; $6e9e
	jp interactionAnimateAsNpc		; $6ea1

@runState:
	ld e,Interaction.state		; $6ea4
	ld a,(de)		; $6ea6
	rst_jumpTable			; $6ea7
	.dw @state0
	.dw @state1
	.dw @state2

@state0:
	ld a,$01		; $6eae
	ld (de),a		; $6eb0

	call interactionInitGraphics		; $6eb1
	call interactionSetAlwaysUpdateBit		; $6eb4

	ld l,Interaction.collisionRadiusY		; $6eb7
	ld (hl),$12		; $6eb9
	inc l			; $6ebb
	ld (hl),$07		; $6ebc

	ld e,Interaction.pressedAButton		; $6ebe
	call objectAddToAButtonSensitiveObjectList		; $6ec0
	ld hl,syrupScript_spawnShopItems		; $6ec3
	jr @setScriptAndGotoState2		; $6ec6


; State 1: Waiting for Link to talk to her
@state1:
	ld e,Interaction.pressedAButton		; $6ec8
	ld a,(de)		; $6eca
	or a			; $6ecb
	ret z			; $6ecc

	xor a			; $6ecd
	ld (de),a		; $6ece

	ld a,$81		; $6ecf
	ld (wDisabledObjects),a		; $6ed1

	ld a,(wLinkGrabState)		; $6ed4
	or a			; $6ed7
	jr z,@talkToSyrupWithoutItem	; $6ed8

	; Get the object that Link is holding
	ld a,(w1Link.relatedObj2+1)		; $6eda
	ld h,a			; $6edd
	ld e,Interaction.var3b		; $6ede
	ld (de),a		; $6ee0

	; Assume he's holding an INTERACID_SHOP_ITEM. Subids $07-$0c are for syrup's shop.
	ld l,Interaction.subid		; $6ee1
	ld a,(hl)		; $6ee3
	push af			; $6ee4
	ld b,a			; $6ee5
	sub $07			; $6ee6

	ld e,Interaction.var37		; $6ee8
	ld (de),a		; $6eea

	; Check if Link has the rupees for it
	ld a,b			; $6eeb
	ld hl,_shopItemPrices		; $6eec
	rst_addAToHl			; $6eef
	ld a,(hl)		; $6ef0
	call cpRupeeValue		; $6ef1
	ld (wShopHaveEnoughRupees),a		; $6ef4
	ld ($cbad),a		; $6ef7

	; Check the item type, see if Link is allowed to buy any more than he already has
	pop af			; $6efa
	cp $07			; $6efb
	jr z,@checkPotion	; $6efd
	cp $09			; $6eff
	jr z,@checkPotion	; $6f01

	cp $0b			; $6f03
	jr z,@checkBombchus	; $6f05

	ld a,(wNumGashaSeeds)		; $6f07
	jr @checkQuantity		; $6f0a

@checkBombchus:
	ld a,(wNumBombchus)		; $6f0c

@checkQuantity:
	; For bombchus and gasha seeds, amount caps at 99
	cp $99			; $6f0f
	ld a,$01		; $6f11
	jr nc,@setCanPurchase	; $6f13
	jr @canPurchase		; $6f15

@checkPotion:
	ld a,TREASURE_POTION		; $6f17
	call checkTreasureObtained		; $6f19
	ld a,$01		; $6f1c
	jr c,@setCanPurchase	; $6f1e

@canPurchase:
	xor a			; $6f20

@setCanPurchase:
	; Set var38 to 1 if Link can't purchase the item because he has too much of it
	ld e,Interaction.var38		; $6f21
	ld (de),a		; $6f23

	ld hl,syrupScript_purchaseItem		; $6f24
	jr @setScriptAndGotoState2		; $6f27

@talkToSyrupWithoutItem:
	call _shopkeeperCheckAllItemsBought		; $6f29
	jr z,@showWelcomeText	; $6f2c

	ld hl,syrupScript_showClosedText		; $6f2e
	jr @setScriptAndGotoState2		; $6f31

@showWelcomeText:
	ld hl,syrupScript_showWelcomeText		; $6f33

@setScriptAndGotoState2:
	ld e,Interaction.state		; $6f36
	ld a,$02		; $6f38
	ld (de),a		; $6f3a
	jp interactionSetScript		; $6f3b


; State 2: running a script
@state2:
	call interactionRunScript		; $6f3e
	ret nc			; $6f41

	; Script done

	xor a			; $6f42
	ld (wDisabledObjects),a		; $6f43

	; Check response from script (was purchase successful?)
	ld e,Interaction.var3a		; $6f46
	ld a,(de)		; $6f48
	or a			; $6f49
	jr z,@gotoState1 ; Skip below code if he was holding nothing to begin with

	; If purchase was successful, set the held item (INTERACID_SHOP_ITEM) to state
	; 3 (link obtains it)
	inc a			; $6f4c
	ld c,$03		; $6f4d
	jr nz,++		; $6f4f

	; If purchase was not successful, set the held item to state 4 (return to display
	; area)
	ld c,$04		; $6f51
++
	xor a			; $6f53
	ld (de),a		; $6f54
	ld e,Interaction.var3b		; $6f55
	ld a,(de)		; $6f57
	ld h,a			; $6f58
	ld l,Interaction.state		; $6f59
	ld (hl),c		; $6f5b
	call dropLinkHeldItem		; $6f5c

@gotoState1:
	ld e,Interaction.state		; $6f5f
	ld a,$01		; $6f61
	ld (de),a		; $6f63
	ret			; $6f64


; ==============================================================================
; INTERACID_LEVER
;
; subid:    Bit 7 set if this is the "child" object (the part that links the lever base to
;           the part Link is pulling); otherwise, bit 0 set if the lever is pulled upward.
; var03:    Nonzero if the "child" lever (part that extends) has already been created?
; var30:    Y position at which lever is fully retracted.
; var31:    Number of units to pull the lever before it's fully pulled.
; var32/33: Address of something in wram (wLever1PullDistance or wLever2PullDistance)
; var34:    Y offset of Link relative to lever when he's pulling it
; var35:    Nonzero if lever was pulled last frame.
; ==============================================================================
interactionCode61:
	ld e,Interaction.subid		; $6f65
	ld a,(de)		; $6f67
	rlca			; $6f68
	ld e,Interaction.state		; $6f69
	jp c,@updateLeverConnectionObject		; $6f6b

	ld a,(de)		; $6f6e
	rst_jumpTable			; $6f6f
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3

@state0:
	call interactionInitGraphics		; $6f78
	ld e,Interaction.var03		; $6f7b
	ld a,(de)		; $6f7d
	or a			; $6f7e
	jr nz,@label_09_254	; $6f7f

	; Create new INTERACID_LEVER, and set their relatedObj1's to each other.
	; This new "child" object will just be the graphic for the "extending" part.
	call getFreeInteractionSlot		; $6f81
	ret nz			; $6f84
	ld (hl),INTERACID_LEVER		; $6f85
	ld l,Interaction.relatedObj1		; $6f87
	ld e,l			; $6f89
	ld a,Interaction.enabled		; $6f8a
	ld (de),a		; $6f8c
	ldi (hl),a		; $6f8d
	inc e			; $6f8e
	ld (hl),d		; $6f8f
	ld a,h			; $6f90
	ld (de),a		; $6f91

	; Jump if new object's slot >= this object's slot
	cp d			; $6f92
	jr nc,@label_09_253	; $6f93

	; Swap the subids of the two objects to ensure that the "parent" has a lower slot
	; number?
	ld l,Interaction.subid		; $6f95
	ld e,l			; $6f97
	ld a,(de)		; $6f98
	ldi (hl),a ; [new.subid] = [this.subid]

	ld a,$80		; $6f9a
	ld (de),a ; [this.subid] = $80
	inc (hl)  ; [new.var03] = $01

	jp objectCopyPosition		; $6f9e

@label_09_253:
	ld l,Interaction.subid		; $6fa1
	ld (hl),$80		; $6fa3

@label_09_254:
	call interactionIncState		; $6fa5

	; After above function call, h = d.
	ld l,Interaction.collisionRadiusY		; $6fa8
	ld (hl),$05		; $6faa
	inc l			; $6fac
	ld (hl),$01		; $6fad

	; [var30] = [yh]
	ld l,Interaction.yh		; $6faf
	ld a,(hl)		; $6fb1
	ld e,Interaction.var30		; $6fb2
	ld (de),a		; $6fb4

	; [var31] = y-offset of lever when fully extended.
	ld l,Interaction.subid		; $6fb5
	ld a,(hl)		; $6fb7
	and $30			; $6fb8
	swap a			; $6fba
	ld bc,@leverLengths		; $6fbc
	call addAToBc		; $6fbf
	inc e			; $6fc2
	ld a,(bc)		; $6fc3
	ld (de),a		; $6fc4

	; [var32/var33] = address of wLever1PullDistance or wLever2PullDistance
	ld bc,wLever1PullDistance		; $6fc5
	bit 6,(hl) ; Check bit 6 of subid
	jr z,+			; $6fca
	inc bc			; $6fcc
+
	inc e			; $6fcd
	ld a,c			; $6fce
	ld (de),a		; $6fcf
	inc e			; $6fd0
	ld a,b			; $6fd1
	ld (de),a		; $6fd2

	; [subid] &= $01 (only indicates direction of lever now)
	ld a,(hl)		; $6fd3
	and $01			; $6fd4
	ld (hl),a		; $6fd6

	; [var34] = Y offset of Link relative to lever when he's pulling it
	ld a,$0c		; $6fd7
	jr z,+			; $6fd9
	ld a,$f3		; $6fdb
+
	inc e			; $6fdd
	ld (de),a		; $6fde
	ld a,(hl)		; $6fdf
	call interactionSetAnimation		; $6fe0
	jp objectSetVisible83		; $6fe3


; Which byte is read from here depends on bits 4-5 of subid.
@leverLengths:
	.db $08 $10 $20 $40


; Waiting for Link to grab
@state1:
	call objectPushLinkAwayOnCollision		; $6fea

	; Get the rough "direction value" toward link (rounded to a cardinal direction)
	call objectGetAngleTowardEnemyTarget		; $6fed
	add $14			; $6ff0
	and $18			; $6ff2
	swap a			; $6ff4
	rlca			; $6ff6
	ld c,a			; $6ff7

	; Check that this direction matches the valid pulling direction and Link's facing
	; direction
	ld e,Interaction.subid		; $6ff8
	ld a,(de)		; $6ffa
	add a			; $6ffb
	cp c			; $6ffc
	ret nz			; $6ffd
	ld a,(w1Link.direction)		; $6ffe
	cp c			; $7001
	ret nz			; $7002

	; Allow to be grabbed
	jp objectAddToGrabbableObjectBuffer		; $7003


; State 2: Link is grabbing this.
@state2:
	inc e			; $7006
	ld a,(de)		; $7007
	rst_jumpTable			; $7008
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate0:
	ld h,d			; $7011
	ld l,e			; $7012
	inc (hl)		; $7013
	ld a,$80		; $7014
	ld (wLinkGrabState2),a		; $7016

	; Calculate Link's y and x positions
	ld l,Interaction.xh		; $7019
	ld a,(hl)		; $701b
	ld (w1Link.xh),a		; $701c
	ld l,Interaction.var34		; $701f
	ld a,(hl)		; $7021
	ld l,Interaction.yh		; $7022
	add (hl)		; $7024
	ld (w1Link.yh),a		; $7025
	xor a			; $7028
	dec l			; $7029
	ld (hl),a		; $702a
	ld (w1Link.y),a		; $702b

	ld b,SPEED_40		; $702e
	inc a			; $7030
	jr @setSpeedAndAngle		; $7031

@substate1:
	; Check animParameter of the "parent item" for the power bracelet?
	ld a,(w1ParentItem2.animParameter)		; $7033
	or a			; $7036
	jr nz,++		; $7037
	ld e,Interaction.var35		; $7039
	ld (de),a		; $703b
	ret			; $703c
++
	call @checkLeverFullyExtended		; $703d
	ret nc			; $7040

	; Not fully extended yet. Set Link's speed/angle to this lever's speed/angle
	ld l,Interaction.angle		; $7041
	ld c,(hl)		; $7043
	ld l,Interaction.speed		; $7044
	ld b,(hl)		; $7046
	call updateLinkPositionGivenVelocity		; $7047

	; Update Lever's position based on Link's position.
	ld a,(w1Link.yh)		; $704a
	ld h,d			; $704d
	ld l,Interaction.var34		; $704e
	sub (hl)		; $7050
	ld l,Interaction.yh		; $7051
	ld (hl),a		; $7053

	; Take difference from lever's "base" position to get the number of pixels it's
	; been pulled.
	ld l,Interaction.var30		; $7054
	sub (hl)		; $7056
	call @updatePullOffset		; $7057

	; Return if lever position hasn't changed.
	cp b			; $705a
	ret z			; $705b

	; Play moveblock sound if lever was not pulled last frame, and it is not fully
	; pulled.
	ld h,d			; $705c
	ld l,Interaction.var35		; $705d
	bit 0,(hl)		; $705f
	ret nz			; $7061
	inc (hl)		; $7062
	bit 7,b			; $7063
	ret nz			; $7065

	ld a,SND_MOVEBLOCK		; $7066
	jp playSound		; $7068


; Lever just released?
@substate2:
@substate3:
	call interactionIncState		; $706b
	ld l,Interaction.enabled		; $706e
	res 1,(hl)		; $7070
	ld b,SPEED_40		; $7072
	xor a			; $7074

@setSpeedAndAngle:
	ld l,Interaction.speed		; $7075
	ld (hl),b		; $7077

	; Calculate angle using subid (which has direction information)
	ld l,Interaction.subid		; $7078
	xor (hl)		; $707a
	swap a			; $707b
	ld l,Interaction.angle		; $707d
	ld (hl),a		; $707f
	ret			; $7080


; Lever retracting back to original position by itself.
@state3:
	call objectApplySpeed		; $7081

	; Update lever pull offset
	ld e,Interaction.yh		; $7084
	ld a,(de)		; $7086
	ld b,a			; $7087
	ld e,Interaction.var30		; $7088
	ld a,(de)		; $708a
	sub b			; $708b
	call @updatePullOffset		; $708c
	call @checkLeverFullyRetracted		; $708f
	jr c,@makeGrabbable	; $7092

	; Lever fully retracted.
	ld l,Interaction.state		; $7094
	ld (hl),$01		; $7096
	ld b,SPEED_40		; $7098
	ld a,$01		; $709a
	call @setSpeedAndAngle		; $709c

@makeGrabbable:
	; State 1 doesn't do anything except make the lever grabbable, so just reuse it.
	jp @state1		; $709f


; This part is almost entirely separate from the lever code above; this is a separate
; object that graphically connects the lever's base with the part Link is holding.
@updateLeverConnectionObject:
	ld a,(de)		; $70a2
	or a			; $70a3
	jr nz,@@state1	; $70a4

@@state0:
	call interactionInitGraphics		; $70a6
	call interactionIncState		; $70a9
	call objectSetVisible83		; $70ac

	; Copy parent's x position
	ld a,Object.xh		; $70af
	call objectGetRelatedObject1Var		; $70b1
	ld e,l			; $70b4
	ld a,(hl)		; $70b5
	ld (de),a		; $70b6

@@state1:
	; b = [relatedObj1.subid]*5 (either 0 or 5 as a base for the table below)
	ld a,Object.subid		; $70b7
	call objectGetRelatedObject1Var		; $70b9
	ld a,(hl)		; $70bc
	add a			; $70bd
	add a			; $70be
	add (hl)		; $70bf
	ld b,a			; $70c0

	; a = (number of pixels pulled)/16
	ld l,Interaction.yh		; $70c1
	ld a,(hl)		; $70c3
	ld l,Interaction.var30		; $70c4
	sub (hl)		; $70c6
	jr nc,+			; $70c7
	cpl			; $70c9
	inc a			; $70ca
+
	swap a			; $70cb
	and $07			; $70cd
	push af			; $70cf

	; Get Y offset for animation.
	add b			; $70d0
	ld bc,@animationYOffsets		; $70d1
	call addAToBc		; $70d4
	ld a,(bc)		; $70d7
	add (hl)		; $70d8
	ld e,Interaction.yh		; $70d9
	ld (de),a		; $70db

	; Set animation. Animation $02 is just a 16-pixel high lever connection, and
	; animations $03-$06 each add another 16-pixel high connection to the chain.
	pop af			; $70dc
	add $02			; $70dd
	jp interactionSetAnimation		; $70df

@animationYOffsets:
	.db $00 $08 $10 $18 $20 ; Lever facing down
	.db $00 $f8 $f0 $e8 $e0 ; Lever facing up

;;
; If the lever is fully extended, this also caps its position to the max value.
;
; @param[out]	cflag	nc if fully extended.
; @addr{70ec}
@checkLeverFullyExtended:
	ld e,Interaction.var31		; $70ec
	ld a,(de)		; $70ee
	ld h,d			; $70ef

	ld l,Interaction.subid		; $70f0
	bit 0,(hl)		; $70f2
	jr z,@posComparison			; $70f4

	cpl			; $70f6
	inc a			; $70f7

@negComparison:
	ld l,Interaction.var30		; $70f8
	add (hl)		; $70fa
	ld l,Interaction.yh		; $70fb
	cp (hl)			; $70fd
	ret c			; $70fe
	ld (hl),a		; $70ff
	ret			; $7100

;;
; If the lever is fully retracted, this also caps its position to 0.
;
; @param[out]	cflag	nc if fully retracted.
; @addr{7101}
@checkLeverFullyRetracted:
	xor a			; $7101
	ld h,d			; $7102
	ld l,Interaction.subid		; $7103
	bit 0,(hl)		; $7105
	jr z,@negComparison		; $7107

@posComparison:
	ld l,Interaction.var30		; $7109
	add (hl)		; $710b
	ld b,a			; $710c
	ld l,Interaction.yh		; $710d
	ld a,(hl)		; $710f
	cp b			; $7110
	ret c			; $7111
	ld (hl),b		; $7112
	ret			; $7113

;;
; @param	a	Offset of lever from its base (Value to write to
;			wLever1/2PullDistance before possible negation)
; @param	cflag	Set if lever is facing up
; @param[out]	a	Old value of pull distance
; @param[out]	b	New value of pull distance
; @addr{7114}
@updatePullOffset:
	jr nc,++		; $7114
	cpl			; $7116
	inc a			; $7117
++
	ld h,d			; $7118
	ld l,Interaction.var31		; $7119
	cp (hl)			; $711b
	jr nz,++		; $711c

	; Pulled lever all the way?
	ld h,a			; $711e
	push hl			; $711f
	ld a,SND_OPENCHEST		; $7120
	call playSound		; $7122

	; Set bit 7 of pull distance when fully pulled
	pop hl			; $7125
	ld a,h			; $7126
	or $80			; $7127
	ld h,d			; $7129
++
	; Read address in var32/var33; set new value to 'b' and return old value as 'a'.
	ld b,a			; $712a
	inc l			; $712b
	ldi a,(hl)		; $712c
	ld h,(hl)		; $712d
	ld l,a			; $712e
	ld a,(hl)		; $712f
	ld (hl),b		; $7130
	ret			; $7131


; ==============================================================================
; INTERACID_MAKU_CONFETTI
;
; This object uses component speed (instead of using one byte for speed value, two words
; are used, for Y/X speeds respectively).
;
; Variables:
;   var03:    If nonzero, this is an index for the confetti which determines position,
;             acceleration values? (If zero, this is the "spawner" for subsequent
;             confetti.)
;
; Variables for "spawner" / "parent" (var03 == 0, uses state 1):
;   counter1: Number of pieces of confetti spawned so far
;   var37:    Counter until next piece of confetti spawns
;
; Variables for actual pieces of confetti (var03 != 0, uses state 2):
;   var3a:    Counter until another sparkle is created
;   var3c/3d: Y acceleration?
;   var3e/3f: X acceleration?
; ==============================================================================
interactionCode62:
	ld e,Interaction.subid		; $7132
	ld a,(de)		; $7134
	rst_jumpTable			; $7135
	.dw _makuConfetti_subid0
	.dw _makuConfetti_subid1


; Subid 0: Flowers (in the present)
_makuConfetti_subid0:
	ld e,Interaction.state		; $713a
	ld a,(de)		; $713c
	rst_jumpTable			; $713d
	.dw @state0
	.dw @state1
	.dw @state2

@state0:
	ld h,d			; $7144
	ld l,e			; $7145
	inc (hl)		; $7146
	ld l,Interaction.var03		; $7147
	ld a,(hl)		; $7149
	or a			; $714a
	jr nz,+			; $714b

	; var03 is zero; next state is state 1.
	jp @setDelayUntilNextConfettiSpawns		; $714d
+
	; a *= 3 (assume hl still points to a's source)
	add a			; $7150
	add (hl)		; $7151

	; Set Y-pos, X-pos, Y-accel (var3c), X-accel (var3e)
	ld hl,@initialPositionsAndAccelerations-6		; $7152
	rst_addDoubleIndex			; $7155
	ld e,Interaction.yh		; $7156
	ldh a,(<hCameraY)	; $7158
	add (hl)		; $715a
	inc hl			; $715b
	ld (de),a		; $715c
	inc e			; $715d
	inc e			; $715e
	ldh a,(<hCameraX)	; $715f
	add (hl)		; $7161
	inc hl			; $7162
	ld (de),a		; $7163
	ld e,Interaction.var3c		; $7164
	call @copyAccelerationComponent		; $7166
	call @copyAccelerationComponent		; $7169

	; Increment state again; next state is state 2.
	ld h,d			; $716c
	ld l,Interaction.state		; $716d
	inc (hl)		; $716f

	ld l,Interaction.var3a		; $7170
	ld (hl),$10		; $7172

	ld l,Interaction.direction		; $7174
	ld (hl),$00		; $7176
	call interactionInitGraphics		; $7178
	jp objectSetVisible80		; $717b


@copyAccelerationComponent:
	ldi a,(hl)		; $717e
	ld (de),a		; $717f
	inc e			; $7180
	ldi a,(hl)		; $7181
	ld (de),a		; $7182
	inc e			; $7183
	ret			; $7184


; Data format:
;   b0: Y position
;   b1: X position
;   w2: Y-acceleration (var3c)
;   w3: X-acceleration (var3e)
@initialPositionsAndAccelerations:
	dbbww $e8, $38, $0018, $0018 ; $01 == [var03]
	dbbww $e8, $60, $0018, $0018 ; $02
	dbbww $e8, $10, $0010, $0010 ; $03
	dbbww $e8, $50, $0014, $0014 ; $04
	dbbww $e8, $20, $0018, $0018 ; $05


; State 1: this is the "spawner" for confetti, not actually drawn itself.
@state1:
	ld h,d			; $71a3
	ld l,Interaction.var37		; $71a4
	dec (hl)		; $71a6
	ret nz			; $71a7
	ld (hl),$01		; $71a8

	; Spawn a piece of confetti
	call getFreeInteractionSlot		; $71aa
	ret nz			; $71ad
	ld (hl),INTERACID_MAKU_CONFETTI		; $71ae

	; [new.var03] = ++[this.counter1]
	ld e,Interaction.counter1		; $71b0
	ld a,(de)		; $71b2
	inc a			; $71b3
	ld (de),a		; $71b4
	ld l,Interaction.var03		; $71b5
	ld (hl),a		; $71b7

	; [new.counter2] = 180 (counter until it makes magic powder noise)
	ld l,Interaction.counter2		; $71b8
	ld (hl),180		; $71ba

	ld a,SND_MAGIC_POWDER		; $71bc
	call playSound		; $71be

	; Delete self if 5 pieces of confetti have been spawned
	ld e,Interaction.counter1		; $71c1
	ld a,(de)		; $71c3
	cp $05			; $71c4
	jp z,interactionDelete		; $71c6

@setDelayUntilNextConfettiSpawns:
	ld e,Interaction.counter1		; $71c9
	ld a,(de)		; $71cb
	ld hl,@spawnDelayValues		; $71cc
	rst_addAToHl			; $71cf
	ld a,(hl)		; $71d0
	ld e,Interaction.var37		; $71d1
	ld (de),a		; $71d3
	ret			; $71d4

@spawnDelayValues:
	.db $01 $32 $14 $1e $28 $1e


; State 2: This is an individual piece of confetti, falling down the screen.
@state2:
	; Play magic powder sound every 3 seconds
	call interactionDecCounter2		; $71db
	jr nz,++		; $71de
	ld (hl),180		; $71e0
	ld a,SND_MAGIC_POWDER		; $71e2
	call playSound		; $71e4
++
	; Make a sparkle every $18 frames
	ld h,d			; $71e7
	ld l,Interaction.var3a		; $71e8
	dec (hl)		; $71ea
	jr nz,++			; $71eb
	ld (hl),$18		; $71ed
	call @makeSparkle		; $71ef
++
	; Update Y/X position and speed
	ld hl,@yOffset		; $71f2
	ld e,Interaction.y		; $71f5
	call add16BitRefs		; $71f7
	call _makuConfetti_updateSpeedY		; $71fa
	call _makuConfetti_updateSpeedX		; $71fd
	call objectApplyComponentSpeed		; $7200

	; Delete when off-screen
	ld e,Interaction.yh		; $7203
	ld a,(de)		; $7205
	cp $88			; $7206
	jp c,++			; $7208
	cp $d8			; $720b
	jp c,interactionDelete		; $720d
++
	; Invert Y acceleration when speedY > $100.
	ld h,d			; $7210
	ld l,Interaction.speedY		; $7211
	ld c,(hl)		; $7213
	inc l			; $7214
	ld b,(hl)		; $7215
	bit 7,(hl)		; $7216
	jr z,+			; $7218
	call @negateBC		; $721a
+
	ld hl,$0100		; $721d
	call compareHlToBc		; $7220
	cp $01			; $7223
	jr z,+			; $7225
	ld e,Interaction.var3c		; $7227
	call @negateWordAtDE		; $7229
+
	; Invert X acceleration when speedX > $200.
	ld h,d			; $722c
	ld l,Interaction.speedX		; $722d
	ld c,(hl)		; $722f
	inc l			; $7230
	ld b,(hl)		; $7231
	bit 7,(hl)		; $7232
	jr z,+			; $7234
	call @negateBC		; $7236
+
	ld hl,$0200		; $7239
	call compareHlToBc		; $723c
	cp $01			; $723f
	jr z,+			; $7241
	ld e,Interaction.var3e		; $7243
	call @negateWordAtDE		; $7245
+
	; Check whether to invert the animation direction (speed switches from positive to
	; negative or vice-versa).
	ld h,d			; $7248
	ld l,Interaction.speedX+1		; $7249
	bit 7,(hl)		; $724b
	ld l,Interaction.direction		; $724d
	ld a,(hl)		; $724f
	jr z,+			; $7250
	or a			; $7252
	ret nz			; $7253
	jr ++			; $7254
+
	or a			; $7256
	ret z			; $7257
++
	xor $01			; $7258
	ld (hl),a		; $725a
	jp interactionSetAnimation		; $725b


; Value added to y position each frame, in addition to speedY?
@yOffset:
	.dw $00c0

;;
; @param	bc	Speed
; @param[out]	bc	Inverted speed
; @addr{7260}
@negateBC:
	xor a			; $7260
	ld a,c			; $7261
	cpl			; $7262
	add $01			; $7263
	ld c,a			; $7265
	ld a,b			; $7266
	cpl			; $7267
	adc $00			; $7268
	ld b,a			; $726a
	ret			; $726b

;;
; @param	de	Address of value to invert
; @addr{726c}
@negateWordAtDE:
	xor a			; $726c
	ld a,(de)		; $726d
	cpl			; $726e
	add $01			; $726f
	ld (de),a		; $7271
	inc e			; $7272
	ld a,(de)		; $7273
	cpl			; $7274
	adc $00			; $7275
	ld (de),a		; $7277
	ret			; $7278

@makeSparkle:
	call getFreeInteractionSlot		; $7279
	ret nz			; $727c
	ld (hl),INTERACID_SPARKLE		; $727d
	inc l			; $727f
	ld (hl),$02		; $7280
	jp objectCopyPosition		; $7282



; Subid 1: In the past.
_makuConfetti_subid1:
	ld e,Interaction.state		; $7285
	ld a,(de)		; $7287
	rst_jumpTable			; $7288
	.dw @state0
	.dw @state1
	.dw @state2

@state0:
	ld h,d			; $728f
	ld l,e			; $7290
	inc (hl)		; $7291
	ld l,Interaction.var03		; $7292
	ld a,(hl)		; $7294
	or a			; $7295
	jr nz,+			; $7296

	; var03 is zero; next state is state 1.
	ld l,Interaction.counter2		; $7298
	ld (hl),$0a		; $729a
	jp @setDelayUntilNextConfettiSpawns		; $729c
+
	dec a			; $729f
	cp $06			; $72a0
	jr c,+			; $72a2
	sub $06			; $72a4
+
	ld hl,@initialPositions		; $72a6
	rst_addDoubleIndex			; $72a9

	; Set Y-pos, X-pos.
	ld e,Interaction.yh		; $72aa
	ldh a,(<hCameraY)	; $72ac
	add (hl)		; $72ae
	inc hl			; $72af
	ld (de),a		; $72b0
	inc e			; $72b1
	inc e			; $72b2
	ldh a,(<hCameraX)	; $72b3
	add (hl)		; $72b5
	inc hl			; $72b6
	ld (de),a		; $72b7

	; Initialize speedY, speedX
	ld h,d			; $72b8
	ld l,Interaction.speedY		; $72b9
	ld b,$80		; $72bb
	ld c,$fd		; $72bd
	call @setSpeedComponent		; $72bf
	ld b,$00		; $72c2
	ld c,$04		; $72c4
	call @setSpeedComponent		; $72c6

	; Initialize speedZ; this is actually used as X acceleration.
	ld b,$f0		; $72c9
	ld c,$ff		; $72cb
	call @setSpeedComponent		; $72cd

	; Increment state again; next state is state 2.
	ld l,Interaction.state		; $72d0
	inc (hl)		; $72d2

	call interactionInitGraphics		; $72d3
	jp objectSetVisible80		; $72d6

@setSpeedComponent:
	ld (hl),b		; $72d9
	inc l			; $72da
	ld (hl),c		; $72db
	inc l			; $72dc
	ret			; $72dd

; Data format:
;   b0: Y position
;   b1: X position
@initialPositions:
	.db $80 $10 ; $01,$07 == [var03]
	.db $60 $00 ; $02,$08
	.db $80 $18 ; $03,$09
	.db $80 $48 ; $04,$0a
	.db $50 $00 ; $05,$0b
	.db $80 $10 ; $06,$0c


; State 1: this is the "spawner" for confetti, not actually drawn itself.
@state1:
	call interactionDecCounter2		; $72ea
	jr nz,+			; $72ed
	ld (hl),45		; $72ef
	ld a,SND_MAKU_TREE_PAST		; $72f1
	call playSound		; $72f3
+
	ld h,d			; $72f6
	ld l,Interaction.var37		; $72f7
	dec (hl)		; $72f9
	ret nz			; $72fa

	call getFreeInteractionSlot		; $72fb
	ret nz			; $72fe
	ld (hl),INTERACID_MAKU_CONFETTI		; $72ff
	inc l			; $7301
	ld (hl),$01 ; [new.subid] = $02

	; [new.var03] = ++[this.counter1]
	ld e,Interaction.counter1		; $7304
	ld a,(de)		; $7306
	inc a			; $7307
	ld (de),a		; $7308
	ld l,Interaction.var03		; $7309
	ld (hl),a		; $730b

	; Delete self if 12 pieces of confetti have been spawned
	cp 12			; $730c
	jp z,interactionDelete		; $730e

@setDelayUntilNextConfettiSpawns:
	ld e,Interaction.counter1		; $7311
	ld a,(de)		; $7313
	ld hl,@spawnDelayValues		; $7314
	rst_addAToHl			; $7317
	ld a,(hl)		; $7318
	ld e,Interaction.var37		; $7319
	ld (de),a		; $731b
	ret			; $731c

@spawnDelayValues:
	.db $01 $32 $1e $0f $0f $0f $0f $0f
	.db $0f $0f $0f $14


; State 2: This is an individual piece of confetti, falling down the screen.
@state2:
	call _makuConfetti_updateSpeedXUsingSpeedZ		; $7329
	ld e,Interaction.speedX+1		; $732c
	ld a,(de)		; $732e
	bit 7,a			; $732f
	jp nz,interactionDelete		; $7331
	jp objectApplyComponentSpeed		; $7334

_makuConfetti_updateSpeedY:
	ld e,Interaction.speedY		; $7337
	ld l,Interaction.var3c		; $7339
	jr _makuConfetti_add16BitRefs			; $733b

_makuConfetti_updateSpeedX:
	ld e,Interaction.speedX		; $733d
	ld l,Interaction.var3e		; $733f
	jr _makuConfetti_add16BitRefs			; $7341

_makuConfetti_updateSpeedYUsingSpeedZ: ; Unused
	ld e,Interaction.speedY		; $7343
	ld l,Interaction.speedZ		; $7345
	jr _makuConfetti_add16BitRefs			; $7347

; Use speedZ as acceleration for speedX (since speedZ isn't used for anything else)
_makuConfetti_updateSpeedXUsingSpeedZ:
	ld e,Interaction.speedX		; $7349
	ld l,Interaction.speedZ		; $734b

_makuConfetti_add16BitRefs
	ld h,d			; $734d
	call add16BitRefs		; $734e
	ret			; $7351


; ==============================================================================
; INTERACID_ACCESSORY
; ==============================================================================
interactionCode63:
	ld e,Interaction.state		; $7352
	ld a,(de)		; $7354
	rst_jumpTable			; $7355
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $735a
	ld (de),a		; $735c
	call interactionInitGraphics		; $735d

@state1:
	ld a,Object.enabled		; $7360
	call objectGetRelatedObject1Var		; $7362
	ld l,Interaction.enabled		; $7365
	ld a,(hl)		; $7367
	or a			; $7368
	jr z,@delete	; $7369

	ld l,Interaction.var3b		; $736b
	ld a,(hl)		; $736d
	or a			; $736e
	jr nz,@delete	; $736f

	ld l,Interaction.visible		; $7371
	bit 7,(hl)		; $7373
	jp z,objectSetInvisible		; $7375

	call objectSetVisible80		; $7378
	ld bc,$f400		; $737b
	ld e,Interaction.var03		; $737e
	ld a,(de)		; $7380
	or a			; $7381
	jr z,@takePositionWithOffset	; $7382

	ld l,Interaction.animParameter		; $7384
	ld a,(hl)		; $7386
	push hl			; $7387
	add a			; $7388
	ld hl,@data		; $7389
	rst_addDoubleIndex			; $738c
	ld b,(hl)		; $738d
	inc hl			; $738e
	ld c,(hl)		; $738f
	inc hl			; $7390
	ld a,(hl)		; $7391
	ld e,Interaction.visible		; $7392
	ld (de),a		; $7394
	inc hl			; $7395

	; Set animation if it's changed
	ld e,Interaction.var3c		; $7396
	ld a,(de)		; $7398
	cp (hl)			; $7399
	jr z,++			; $739a
	ld a,(hl)		; $739c
	ld (de),a		; $739d
	push bc			; $739e
	call interactionSetAnimation		; $739f
	pop bc			; $73a2
++
	pop hl			; $73a3

@takePositionWithOffset:
	jp objectTakePositionWithOffset		; $73a4

@delete:
	jp interactionDelete		; $73a7


; Each row in this table is a set of values for one value of "relatedObj1.animParameter".
; This is only used when var03 is nonzero.
;
; Data format:
;   b0: Y offset
;   b1: X offset
;   b2: value for Interaction.visible
;   b3: Animation index
@data:
	.db $00 $f3 $80 $03
	.db $f3 $00 $80 $03
	.db $00 $0d $80 $03
	.db $f4 $ff $80 $03
	.db $f4 $00 $80 $03
	.db $f5 $00 $83 $03
	.db $f5 $00 $83 $0a
	.db $02 $04 $80 $00
	.db $02 $05 $80 $00


; ==============================================================================
; INTERACID_RAFTWRECK_CUTSCENE_HELPER
; ==============================================================================
interactionCode64:
	ld e,Interaction.state		; $73ce
	ld a,(de)		; $73d0
	rst_jumpTable			; $73d1
	.dw @state0
	.dw @state1

@state0:
	call interactionIncState		; $73d6
	ld e,Interaction.subid		; $73d9
	ld a,(de)		; $73db
	rst_jumpTable			; $73dc
	.dw @initSubid00
	.dw @initSubid01
	.dw @initSubid02
	.dw @initSubid03
	.dw @initSubid04
	.dw @initSubid05

@initSubid00:
@initSubid01:
@initSubid02:
	call interactionInitGraphics		; $73e9
	call objectSetVisible82		; $73ec

@loadAngleAndCounterPreset:
	ld b,$03		; $73ef
	callab loadAngleAndCounterPreset		; $73f1
	ld a,b			; $73f9
	or a			; $73fa
	ret			; $73fb

@initSubid03:
@initSubid04:
@initSubid05:
	ret			; $73fc

;;
; Reads from a table, gets a position, sets counter1, ...?
;
; @param	counter2	Index from table to read
; @param	hl		Table to read from
; @param[out]	bc		Position for a new object?
; @param[out]	e		Subid for a new object?
@func_73fd:
	ld e,Interaction.counter2		; $73fd
	ld a,(de)		; $73ff
	add a			; $7400
	rst_addDoubleIndex			; $7401
	ld b,(hl)		; $7402
	inc hl			; $7403
	ld c,(hl)		; $7404
	inc hl			; $7405
	ld e,(hl)		; $7406
	inc hl			; $7407
	ld a,(hl)		; $7408
	ld h,d			; $7409
	ld l,Interaction.counter1		; $740a
	ld (hl),a		; $740c
	ret			; $740d

@state1:
	ld e,Interaction.subid		; $740e
	ld a,(de)		; $7410
	rst_jumpTable			; $7411
	.dw @runSubid00
	.dw @runSubid01
	.dw @runSubid02
	.dw @runSubid03
	.dw @runSubid04
	.dw @runSubid05

@runSubid00:
@runSubid01:
@runSubid02:
	call interactionAnimate		; $741e
	call objectApplySpeed		; $7421
	cp $f0			; $7424
	jp nc,interactionDelete		; $7426
	call interactionDecCounter1		; $7429
	call z,@loadAngleAndCounterPreset		; $742c
	jp z,interactionDelete		; $742f
	ret			; $7432

@runSubid03:
@runSubid04:
	ld h,d			; $7433
	ld l,Interaction.counter1		; $7434
	ld a,(hl)		; $7436
	or a			; $7437
	jr z,+			; $7438
	dec (hl)		; $743a
	ret			; $743b
+
	ld hl,@subid3Objects		; $743c
	ld e,Interaction.subid		; $743f
	ld a,(de)		; $7441
	cp $03			; $7442
	jr z,+			; $7444
	ld hl,@subid4Objects		; $7446
+
	call @func_73fd		; $7449

	call getFreeInteractionSlot		; $744c
	ret nz			; $744f
	ld (hl),INTERACID_RAFTWRECK_CUTSCENE_HELPER		; $7450
	inc l			; $7452
	ld (hl),e		; $7453
	inc l			; $7454
	ld e,Interaction.counter2		; $7455
	ld a,(de)		; $7457
	ld (hl),a		; $7458
	ld e,Interaction.subid		; $7459
	ld a,(de)		; $745b
	cp $03			; $745c
	ld a,SPEED_200		; $745e
	jr z,+			; $7460
	ld a,SPEED_300		; $7462
+
	ld l,Interaction.speed		; $7464
	ld (hl),a		; $7466
	call interactionHSetPosition		; $7467

	ld h,d			; $746a
	ld l,Interaction.counter1		; $746b
	ld a,(hl)		; $746d
	or a			; $746e
	jp z,interactionDelete		; $746f
	inc l			; $7472
	inc (hl)		; $7473
	ret			; $7474


; Tables of objects to spawn for the "wind" parts of the cutscene.
;   b0: Y position
;   b1: X position
;   b2: subID of this interaction type to spawn
;   b3: counter1
@subid3Objects:
	.db $00 $b8 $00 $14
	.db $10 $a8 $00 $14
	.db $40 $a8 $00 $14
	.db $48 $b8 $01 $14
	.db $20 $a8 $00 $00

@subid4Objects:
	.db $20 $b8 $00 $10
	.db $40 $a8 $00 $14
	.db $10 $b0 $01 $10
	.db $48 $b8 $00 $14
	.db $08 $b0 $01 $10
	.db $50 $a8 $00 $14
	.db $f0 $b0 $00 $10
	.db $08 $b8 $02 $10
	.db $48 $b8 $00 $14
	.db $08 $b0 $01 $10
	.db $50 $a8 $00 $14
	.db $18 $b0 $01 $10
	.db $38 $b8 $02 $10
	.db $58 $a8 $00 $14
	.db $28 $b0 $01 $10
	.db $00 $a8 $00 $00

@runSubid05:
	ld h,d			; $74c9
	ld l,Interaction.counter1		; $74ca
	ld a,(hl)		; $74cc
	or a			; $74cd
	jr z,+			; $74ce
	dec (hl)		; $74d0
	ret			; $74d1
+
	ld hl,@subid5Objects		; $74d2
	call @func_73fd		; $74d5

	; Create lightning
	call getFreePartSlot		; $74d8
	ret nz			; $74db
	ld (hl),PARTID_LIGHTNING		; $74dc
	inc l			; $74de
	ld (hl),e		; $74df
	inc l			; $74e0
	inc (hl)		; $74e1
	ld l,Part.yh		; $74e2
	ld (hl),b		; $74e4
	ld l,Part.xh		; $74e5
	ld (hl),c		; $74e7

	ld h,d			; $74e8
	ld l,Interaction.counter1		; $74e9
	ld a,(hl)		; $74eb
	or a			; $74ec
	jr z,+			; $74ed
	inc l			; $74ef
	inc (hl)		; $74f0
	ret			; $74f1
+
	; Signal to INTERACID_RAFTWRECK_CUTSCENE that the cutscene is done
	ld a,$03		; $74f2
	ld (wTmpcfc0.genericCutscene.state),a		; $74f4
	jp interactionDelete		; $74f7


; Tables of lightning objects to spawn in the final part of the cutscene.
;   b0: Y position
;   b1: X position
;   b2: subID of this interaction type to spawn
;   b3: counter1
@subid5Objects:
	.db $28 $28 $01 $28
	.db $58 $38 $01 $5a
	.db $40 $50 $01 $00


; ==============================================================================
; INTERACID_COMEDIAN
;
; Variables: (these are only used in scripts / bank 15 functions))
;   var37: base animation index ($00 for no mustache, $04 for mustache)
;   var3e: animation index (to be added to var37)
; ==============================================================================
interactionCode65:
	call checkInteractionState		; $7506
	jr nz,@state1	; $7509

@state0:
	call @loadScriptAndInitGraphics		; $750b
	call interactionRunScript		; $750e
	call interactionRunScript		; $7511
	jp interactionAnimateAsNpc		; $7514

@state1:
	call interactionRunScript		; $7517
	jp c,interactionDelete		; $751a
	callab scriptHlp.comedian_turnToFaceLink		; $751d
	jp interactionAnimateAsNpc		; $7525


@unusedFunc_7528:
	call interactionInitGraphics		; $7528
	call objectMarkSolidPosition		; $752b
	jp interactionIncState		; $752e


@loadScriptAndInitGraphics:
	call interactionInitGraphics		; $7531
	call objectMarkSolidPosition		; $7534
	ld a,>TX_0b00		; $7537
	call interactionSetHighTextIndex		; $7539
	ld e,Interaction.subid		; $753c
	ld a,(de)		; $753e
	ld hl,@scriptTable		; $753f
	rst_addDoubleIndex			; $7542
	ldi a,(hl)		; $7543
	ld h,(hl)		; $7544
	ld l,a			; $7545
	call interactionSetScript		; $7546
	jp interactionIncState		; $7549

@scriptTable:
	.dw comedianScript


; ==============================================================================
; INTERACID_GORON
;
; Variables:
;   var3f: Nonzero when "napping" (link is far away)
; ==============================================================================
interactionCode66:
	ld e,Interaction.subid		; $754e
	ld a,(de)		; $7550
	rst_jumpTable			; $7551
	.dw _goronSubid00
	.dw _goronSubid01
	.dw _goronSubid02
	.dw _goronSubid03
	.dw _goronSubid04
	.dw _goronSubid05
	.dw _goronSubid06
	.dw _goronSubid07
	.dw _goronSubid08
	.dw _goronSubid09
	.dw _goronSubid0a
	.dw _goronSubid0b
	.dw _goronSubid0c
	.dw _goronSubid0d
	.dw _goronSubid0e
	.dw _goronSubid0f
	.dw _goronSubid10


; Graceful goron
_goronSubid00:
	ld e,Interaction.state		; $7574
	ld a,(de)		; $7576
	rst_jumpTable			; $7577
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3
	.dw @state4


; State 0: Initialization
@state0:
	call _goron_initGraphicsAndIncState		; $7582

	; Set palette (red/blue for past/present)
	ld a,(wAreaFlags)		; $7585
	and AREAFLAG_PAST			; $7588
	ld a,$01		; $758a
	jr z,+			; $758c
	ld a,$02		; $758e
+
	ld e,Interaction.oamFlags		; $7590
	ld (de),a		; $7592

	; Load goron or subrosian dancers
	ld hl,objectData.goronDancers		; $7593
	call checkIsLinkedGame		; $7596
	jr z,@loadDancers	; $7599
	ld a,(wAreaFlags)		; $759b
	and AREAFLAG_PAST			; $759e
	jr z,@loadDancers	; $75a0
	ld hl,objectData.subrosianDancers		; $75a2
@loadDancers:
	call parseGivenObjectData		; $75a5

	ld b,wTmpcfc0.goronDance.dataEnd - wTmpcfc0.goronDance		; $75a8
	ld hl,wTmpcfc0.goronDance		; $75aa
	call clearMemory		; $75ad

	ld a,$02		; $75b0
	ld (wTmpcfc0.goronDance.danceAnimation),a		; $75b2

	xor a			; $75b5
	ld hl,goronDanceScriptTable		; $75b6
	rst_addDoubleIndex			; $75b9
	ldi a,(hl)		; $75ba
	ld h,(hl)		; $75bb
	ld l,a			; $75bc
	call interactionSetScript		; $75bd


; State 1: waiting for script to end as a signal to start the dance minigame
@state1:
	call interactionRunScript		; $75c0
	jp c,@scriptDone		; $75c3
	jp npcFaceLinkAndAnimate		; $75c6

@scriptDone:
	; Dance begins when script ends
	ld b,$0a		; $75c9
	callab interactionBank1.shootingGallery_initializeGameRounds		; $75cb

	ld a,DIR_DOWN		; $75d3
	ld (wTmpcfc0.goronDance.danceAnimation),a		; $75d5
	call interactionIncState		; $75d8
	ld l,Interaction.counter1		; $75db
	ld (hl),30		; $75dd


; State 2: demonstrating dance sequence
@state2:
	ld e,Interaction.state2		; $75df
	ld a,(de)		; $75e1
	rst_jumpTable			; $75e2
	.dw @state2Substate0
	.dw @state2Substate1
	.dw @state2Substate2
	.dw @state2Substate3
	.dw @state2Substate4

; Waiting to begin round
@state2Substate0:
	call interactionDecCounter1		; $75ed
	jp nz,@pushLinkAway		; $75f0

	call interactionIncState2		; $75f3
	ld l,Interaction.counter1		; $75f6
	ld (hl),90		; $75f8
	ld a,SND_WHISTLE		; $75fa
	call playSound		; $75fc
	call _goronDance_initNextRound		; $75ff

@state2Substate1:
	call interactionDecCounter1		; $7602
	jp nz,@pushLinkAway		; $7605
	call interactionIncState2		; $7608
	jr @nextMove		; $760b


; Waiting until doing the next "beat" of the dance
@state2Substate2:
	call interactionDecCounter1		; $760d
	jr nz,@pushLinkAway	; $7610

	call _goronDance_incBeat		; $7612
@nextMove:
	call _goronDance_getNextMove		; $7615
	jr nz,@finishedDemonstration	; $7618

	call _goronDance_updateConsecutiveBPressCounter		; $761a
	call _goronDance_updateGracefulGoronAnimation		; $761d
	jr z,@jump	; $7620

	call _goronDance_playMoveSound		; $7622
	ld h,d			; $7625
	ld l,Interaction.counter1		; $7626
	ld (hl),20		; $7628

@pushLinkAway:
	jp interactionPushLinkAwayAndUpdateDrawPriority		; $762a

@jump:
	; Jump after 5 consecutive B presses
	ld h,d			; $762d
	ld l,Interaction.state2		; $762e
	ld (hl),$03		; $7630

	ld l,Interaction.speed		; $7632
	ld (hl),SPEED_100		; $7634
	ld l,Interaction.speedZ		; $7636
	ld (hl),<(-$200)		; $7638
	inc hl			; $763a
	ld (hl),>(-$200)		; $763b

	ld l,Interaction.counter1		; $763d
	ld (hl),20		; $763f
	ld a,SND_GORON_DANCE_B		; $7641
	call playSound		; $7643
	jp interactionPushLinkAwayAndUpdateDrawPriority		; $7646


@finishedDemonstration:
	ld h,d			; $7649
	ld l,Interaction.state2		; $764a
	ld (hl),$04		; $764c
	ld l,Interaction.counter1		; $764e
	ld (hl),60		; $7650
	ld a,DIR_DOWN		; $7652
	call interactionSetAnimation		; $7654
	jr @pushLinkAway		; $7657


; Waiting to land if he jumped
@state2Substate3:
	call interactionDecCounter1		; $7659
	ld c,$40		; $765c
	call objectUpdateSpeedZ_paramC		; $765e
	jr z,@@landed	; $7661

	ld h,d			; $7663
	ld l,Interaction.speedZ+1		; $7664
	ldd a,(hl)		; $7666
	or (hl)			; $7667
	jr nz,@pushLinkAway	; $7668

	ld a,DIR_DOWN		; $766a
	ld (wTmpcfc0.goronDance.danceAnimation),a		; $766c
	call interactionSetAnimation		; $766f
	jr @pushLinkAway		; $7672

@@landed:
	ld h,d			; $7674
	ld l,Interaction.state2		; $7675
	ld (hl),$02		; $7677
	jp @state2Substate2		; $7679


; Counting down until going to state 3 (where Link replicates the dance)
@state2Substate4:
	call interactionDecCounter1		; $767c
	jr nz,@pushLinkAway	; $767f
	call interactionIncState		; $7681
	ld l,Interaction.state2		; $7684
	ld (hl),$00		; $7686
	jr @pushLinkAway		; $7688


; State 3: Link playing back dance sequence
@state3:
	ld e,Interaction.state2		; $768a
	ld a,(de)		; $768c
	rst_jumpTable			; $768d
	.dw @state3Substate0
	.dw @state3Substate1
	.dw @state3Substate2
	.dw @state3Substate3
	.dw @state3Substate4

@state3Substate0:
	call interactionIncState2		; $7698
	call _goronDance_clearDanceVariables		; $769b
	ld a,SND_WHISTLE		; $769e
	call playSound		; $76a0

	ld a,DIR_DOWN		; $76a3
	ld (wTmpcfc0.goronDance.danceAnimation),a		; $76a5

	call _goronDance_turnLinkToDirection		; $76a8
	jp @pushLinkAway		; $76ab

@state3Substate1:
	call _goronDance_updateFrameCounter		; $76ae
	call _goronDance_checkLinkInput		; $76b1
	jp @pushLinkAway		; $76b4

@state3Substate2:
	call _goronDance_updateFrameCounter		; $76b7
	ld a,(wTmpcfc0.goronDance.linkJumping)		; $76ba
	or a			; $76bd
	jp nz,@pushLinkAway		; $76be

	ld h,d			; $76c1
	ld l,Interaction.state2		; $76c2
	dec (hl)		; $76c4
	jp @pushLinkAway		; $76c5

@state3Substate3:
	call interactionDecCounter1		; $76c8
	jp nz,@pushLinkAway		; $76cb
	ld a,(wTmpcfc0.goronDance.roundIndex)		; $76ce
	cp $08			; $76d1
	jr z,@endDanceAndUpdateNpc	; $76d3

@nextRoundAndUpdateNpc:
	call @nextRound		; $76d5
	jp @pushLinkAway		; $76d8

@endDanceAndUpdateNpc:
	call @endDance		; $76db
	jp @pushLinkAway		; $76de


; Messed up?
@state3Substate4:
	ld e,Interaction.var3f		; $76e1
	ld a,(de)		; $76e3
	rst_jumpTable			; $76e4
	.dw @@initializeScript
	.dw @@runScript

@@initializeScript:
	call interactionDecCounter1		; $76e9
	jp nz,@pushLinkAway		; $76ec
	ld a,$01		; $76ef
	ld (wTmpcfc0.goronDance.cfd9),a		; $76f1
	ld hl,wTmpcfc0.goronDance.roundIndex		; $76f4
	inc (hl)		; $76f7
	ld hl,wTmpcfc0.goronDance.numFailedRounds		; $76f8
	inc (hl)		; $76fb
	ld a,(hl)		; $76fc
	cp $03			; $76fd
	jr z,++			; $76ff

	ld a,(wTmpcfc0.goronDance.roundIndex)		; $7701
	cp $08			; $7704
	jr z,@endDanceAndUpdateNpc	; $7706
++
	ld h,d			; $7708
	ld l,Interaction.var3f		; $7709
	inc (hl)		; $770b
	ld a,$01		; $770c
	ld hl,goronDanceScriptTable		; $770e
	rst_addDoubleIndex			; $7711
	ldi a,(hl)		; $7712
	ld h,(hl)		; $7713
	ld l,a			; $7714
	call interactionSetScript		; $7715

@@runScript:
	call interactionRunScript		; $7718
	jp nc,@pushLinkAway		; $771b
	jp @nextRoundAndUpdateNpc		; $771e

@nextRound:
	; Go to state 2 (begin next round)
	ld h,d			; $7721
	ld l,Interaction.state		; $7722
	ld (hl),$02		; $7724
	inc l			; $7726
	ld (hl),$00		; $7727
	ld l,Interaction.counter1		; $7729
	ld (hl),30		; $772b
	jr @resetDanceAnimationToDown		; $772d

@endDance:
	; Go to state 4 (finished the whole minigame)
	ld h,d			; $772f
	ld l,Interaction.state		; $7730
	ld (hl),$04		; $7732
	inc l			; $7734
	ld (hl),$00		; $7735
	ld l,Interaction.counter1		; $7737
	ld (hl),60		; $7739

@resetDanceAnimationToDown:
	xor a			; $773b
	ld (wTmpcfc0.goronDance.linkStartedDance),a		; $773c
	ld a,DIR_DOWN		; $773f
	ld (wTmpcfc0.goronDance.danceAnimation),a		; $7741
	jp _goronDance_turnLinkToDirection		; $7744


; State 4: dance ended successfully
@state4:
	ld e,Interaction.state2		; $7747
	ld a,(de)		; $7749
	rst_jumpTable			; $774a
	.dw @state4Substate0
	.dw @state4Substate1

@state4Substate0:
	call interactionIncState2		; $774f
	xor a			; $7752
	ld (wTmpcfc0.goronDance.linkStartedDance),a		; $7753

	; Run script to give prize
	ld a,$02		; $7756
	ld hl,goronDanceScriptTable		; $7758
	rst_addDoubleIndex			; $775b
	ldi a,(hl)		; $775c
	ld h,(hl)		; $775d
	ld l,a			; $775e
	call interactionSetScript		; $775f

@state4Substate1:
	call interactionRunScript		; $7762
	jp nc,@pushLinkAway		; $7765
	jp @pushLinkAway		; $7768



; Goron support dancer. Code also used by subrosian subid $01?
_goronSubid01:
	ld e,Interaction.state		; $776b
	ld a,(de)		; $776d
	rst_jumpTable			; $776e
	.dw @state0
	.dw @state1
	.dw @state2

@state0:
	call interactionInitGraphics		; $7775
	call _goron_loadScript		; $7778

@faceDown:
	ld a,DIR_DOWN		; $777b
	call interactionSetAnimation		; $777d


; State 1: just running the script
@state1:
	ld a,(wTmpcfc0.goronDance.linkStartedDance)		; $7780
	or a			; $7783
	jr nz,@gotoState2	; $7784
	call interactionRunScript		; $7786
	jp c,interactionDelete		; $7789
	jp npcFaceLinkAndAnimate		; $778c

@gotoState2:
	call interactionIncState		; $778f
	jr @updateAnimation		; $7792


; State 2: doing whatever animation the dance dictates
@state2:
	ld a,(wTmpcfc0.goronDance.linkStartedDance)		; $7794
	or a			; $7797
	jr z,@gotoState1	; $7798

@updateAnimation:
	; Copy Link's z position (for when he jumps)
	ld hl,w1Link.z		; $779a
	ld e,Interaction.z		; $779d
	ldi a,(hl)		; $779f
	ld (de),a		; $77a0
	inc e			; $77a1
	ld a,(hl)		; $77a2
	ld (de),a		; $77a3

	; Set animation based on whatever Link or the graceful goron is doing
	ld a,(wTmpcfc0.goronDance.danceAnimation)		; $77a4
	call interactionSetAnimation		; $77a7
	jp _goronSubid00@pushLinkAway		; $77aa

@gotoState1:
	ld h,d			; $77ad
	ld l,Interaction.state		; $77ae
	ld (hl),$01		; $77b0
	jp @faceDown		; $77b2


; A "fake" goron object that manages jumping in the dancing minigame?
_goronSubid02:
	call checkInteractionState		; $77b5
	jr nz,@state1	; $77b8

@state0:
	call objectSetInvisible		; $77ba
	call interactionIncState		; $77bd
	ld l,Interaction.speed		; $77c0
	ld (hl),SPEED_100		; $77c2
	ld l,Interaction.speedZ		; $77c4
	ld (hl),<(-$200)		; $77c6
	inc hl			; $77c8
	ld (hl),>(-$200)		; $77c9

	ld l,Interaction.counter1		; $77cb
	ld (hl),20		; $77cd

	ld hl,w1Link.yh		; $77cf
	call objectTakePosition		; $77d2

	ld a,DIR_UP		; $77d5
	ld (wTmpcfc0.goronDance.danceAnimation),a		; $77d7
	call _goronDance_turnLinkToDirection		; $77da

	ld a,SND_GORON_DANCE_B		; $77dd
	call playSound		; $77df

@state1:
	ld c,$40		; $77e2
	call objectUpdateSpeedZ_paramC		; $77e4
	jr z,@landed	; $77e7

	ld hl,w1Link.yh		; $77e9
	call objectCopyPosition		; $77ec
	ld h,d			; $77ef
	ld l,Interaction.speedZ+1		; $77f0
	ldd a,(hl)		; $77f2
	or (hl)			; $77f3
	ret nz			; $77f4

	ld a,DIR_DOWN		; $77f5
	jp _goronDance_turnLinkToDirection		; $77f7

@landed:
	ld hl,w1Link.yh		; $77fa
	call objectCopyPosition		; $77fd
	xor a			; $7800
	ld (wTmpcfc0.goronDance.linkJumping),a		; $7801
	jp interactionDelete		; $7804


; Subid $03: Cutscene where goron appears after beating d5; the guy who digs a new tunnel.
; Subid $04: Goron pacing back and forth, worried about elder.
_goronSubid03:
_goronSubid04:
	call checkInteractionState		; $7807
	jr nz,@state1	; $780a

@state0:
	call _goron_loadScriptAndInitGraphics		; $780c
	call interactionRunScript		; $780f
@state1:
	call interactionRunScript		; $7812
	jp c,interactionDelete		; $7815
	jp interactionAnimateAsNpc		; $7818


; An NPC in the past cave near the elder? var03 ranges from 0-5.
_goronSubid05:
	call checkInteractionState		; $781b
	jr nz,@state1	; $781e

@state0:
	call _goron_loadScriptFromTableAndInitGraphics		; $7820
	call interactionRunScript		; $7823
@state1:
	jr _goron_runScriptAndDeleteWhenFinished		; $7826


; NPC trying to break the elder out of the rock.
_goronSubid06:
	call checkInteractionState		; $7828
	jr nz,@state1	; $782b

@state0:
	call _goron_loadScriptFromTableAndInitGraphics		; $782d
	ld l,Interaction.var3e		; $7830
	ld (hl),$0a		; $7832
	ld e,Interaction.var03		; $7834
	ld a,(de)		; $7836
	or a			; $7837
	jr nz,+			; $7838
	ld (wTmpcfc0.goronCutscenes.elderVar_cfdd),a		; $783a
	jr ++		; $783d
+
	ld b,wTmpcfc0.goronCutscenes.dataEnd - wTmpcfc0.goronCutscenes		; $783f
	ld hl,wTmpcfc0.bigBangGame		; $7841
	call clearMemory		; $7844
++
	call interactionRunScript		; $7847
@state1:
	jr _goron_runScriptAndDeleteWhenFinished		; $784a


; Various NPCs...
_goronSubid07:
_goronSubid08:
_goronSubid0a:
_goronSubid0c:
_goronSubid0d:
_goronSubid0e:
_goronSubid10:
	call checkInteractionState		; $784c
	jr nz,_goron_runScriptAndDeleteWhenFinished	; $784f

	; State 0 (Initialize)
	call _goron_loadScriptAndInitGraphics		; $7851
	call interactionRunScript		; $7854

_goron_runScriptAndDeleteWhenFinished:
	call interactionRunScript		; $7857
	jp c,interactionDelete		; $785a

_goron_faceLinkAndAnimateIfNotNapping:
	ld e,Interaction.var3f		; $785d
	ld a,(de)		; $785f
	or a			; $7860
	jp z,npcFaceLinkAndAnimate		; $7861
	jp interactionAnimateAsNpc		; $7864


; Target carts gorons; var03 = 0 or 1 for gorons on left and right.
_goronSubid09:
	call checkInteractionState		; $7867
	jr nz,@state1	; $786a

@state0:
	ld e,Interaction.var03		; $786c
	ld a,(de)		; $786e
	or a			; $786f
	jr nz,@rightGuy	; $7870

@leftGuy:
	call _goron_loadScriptFromTableAndInitGraphics		; $7872
	xor a			; $7875
	ld (wTmpcfc0.targetCarts.cfdf),a		; $7876
	ld (wTmpcfc0.targetCarts.beginGameTrigger),a		; $7879

	; Reload crystals in first room if the game is in progress
	call getThisRoomFlags		; $787c
	bit 7,(hl)		; $787f
	jr z,++			; $7881
	callab scriptHlp.goron_targetCarts_reloadCrystalsInFirstRoom		; $7883
++
	call interactionRunScript		; $788b
	jr @state1		; $788e

@rightGuy:
	call _goron_loadScriptFromTableAndInitGraphics		; $7890
	call interactionRunScript		; $7893
	jr @state1		; $7896

@state1:
	jr _goron_runScriptAndDeleteWhenFinished		; $7898


; Goron running the big bang game
_goronSubid0b:
	call checkInteractionState		; $789a
	jr nz,@state1	; $789d

@state0:
	call _goron_loadScriptFromTableAndInitGraphics		; $789f
	call interactionRunScript		; $78a2
@state1:
	call interactionRunScript		; $78a5
	jp c,interactionDelete		; $78a8
	ld e,Interaction.var3e		; $78ab
	ld a,(de)		; $78ad
	or a			; $78ae
	ret nz			; $78af
	jr _goron_faceLinkAndAnimateIfNotNapping		; $78b0


; Linked NPC telling you the biggoron secret.
_goronSubid0f:
	call checkInteractionState		; $78b2
	jr nz,@state1	; $78b5

@state0:
	call _goron_initGraphicsAndIncState		; $78b7
	ld l,Interaction.var3f		; $78ba
	ld (hl),$08		; $78bc
	ld hl,linkedGameNpcScript		; $78be
	call interactionSetScript		; $78c1
	call interactionRunScript		; $78c4
@state1:
	call interactionRunScript		; $78c7
	jp c,interactionDelete		; $78ca
	jp npcFaceLinkAndAnimate		; $78cd

;;
; @addr{78d0}
_goronDance_updateFrameCounter:
	ld a,(wTmpcfc0.goronDance.linkStartedDance)		; $78d0
	or a			; $78d3
	ret z			; $78d4
	ld hl,wTmpcfc0.goronDance.frameCounter		; $78d5
	jp incHlRef16WithCap		; $78d8

;;
; @addr{78db}
_goronDance_initNextRound:
	ld a,(wTmpcfc0.goronDance.remainingRounds)		; $78db
	or a			; $78de
	jr z,_goronDance_clearDanceVariables			; $78df
	callab interactionBank1.shootingGallery_getNextTargetLayout		; $78e1

;;
; @addr{78e9}
_goronDance_clearDanceVariables:
	xor a			; $78e9
	ld (wTmpcfc0.goronDance.linkJumping),a		; $78ea
	ld (wTmpcfc0.goronDance.linkStartedDance),a		; $78ed
	ld (wTmpcfc0.goronDance.frameCounter),a		; $78f0
	ld (wTmpcfc0.goronDance.frameCounter+1),a		; $78f3
	ld (wTmpcfc0.goronDance.currentMove),a		; $78f6
	ld (wTmpcfc0.goronDance.consecutiveBPressCounter),a		; $78f9
	ld (wTmpcfc0.goronDance.cfd9),a		; $78fc
	ld (wTmpcfc0.goronDance.beat),a		; $78ff
	ret			; $7902

;;
; Waits for input from Link, checks for round failure conditions, updates link and goron
; animations when input is good, etc.
; @addr{7903}
_goronDance_checkLinkInput:
	call _goronDance_getNextMove		; $7903
	cp $00			; $7906
	jr z,@rest	; $7908

	call _goronDance_checkTooLateToInput		; $790a
	jr z,@tooLate	; $790d

	ld a,(wGameKeysJustPressed)		; $790f
	and (BTN_A | BTN_B)			; $7912
	ret z			; $7914

	ld b,a			; $7915
	ld (wTmpcfc0.goronDance.linkStartedDance),a		; $7916
	ld a,(wTmpcfc0.goronDance.currentMove)		; $7919
	cp b			; $791c
	jr nz,@wrongMove	; $791d

	; Check if too early
	call _goronDance_checkInputNotTooEarlyOrLate		; $791f
	jr z,@madeMistake	; $7922
	jp @doDanceMove		; $7924

@rest:
	call _goronDance_checkExactInputTimePassed		; $7927
	jr z,@doDanceMove	; $792a
	ld a,(wGameKeysJustPressed)		; $792c
	and $03			; $792f
	jr nz,@wrongMove	; $7931
	ret			; $7933

@tooLate:
	ld a,$01		; $7934
	ld (wTmpcfc0.goronDance.failureType),a		; $7936
	jr @madeMistake		; $7939

@wrongMove:
	ld a,$02		; $793b
	ld (wTmpcfc0.goronDance.failureType),a		; $793d

@madeMistake:
	ld h,d			; $7940
	ld l,Interaction.state2		; $7941
	ld (hl),$04		; $7943
	ld l,Interaction.var3f		; $7945
	ld (hl),$00		; $7947
	ld l,Interaction.counter1		; $7949
	ld (hl),30		; $794b

	ld a,SND_ERROR		; $794d
	call playSound		; $794f

	ld a,LINK_ANIM_MODE_COLLAPSED		; $7952
	ld (wcc50),a		; $7954

	call checkIsLinkedGame		; $7957
	jr z,@gorons	; $795a
	ld a,(wAreaFlags)		; $795c
	and AREAFLAG_PAST			; $795f
	jr z,@gorons	; $7961

@subrosians:
	ld a,$02		; $7963
	ld (wTmpcfc0.goronDance.danceAnimation),a		; $7965
	ret			; $7968
@gorons:
	ld a,$04		; $7969
	ld (wTmpcfc0.goronDance.danceAnimation),a		; $796b
	ret			; $796e

@doDanceMove:
	call _goronDance_updateConsecutiveBPressCounter		; $796f
	call _goronDance_updateLinkAndBackupDancerAnimation		; $7972
	jr z,@jump	; $7975

	call _goronDance_playMoveSound		; $7977
	call _goronDance_incBeat		; $797a
	call _goronDance_getNextMove		; $797d
	jr nz,@roundFinished	; $7980
	ret			; $7982

@jump:
	call _goronDance_incBeat		; $7983
	call _goronDance_getNextMove		; $7986
	call getFreeInteractionSlot		; $7989
	ret nz			; $798c

	; Spawn a goron with subid $02? (A "fake" object that manages a jump?)
	ld (hl),INTERACID_GORON		; $798d
	inc l			; $798f
	ld (hl),$02		; $7990
	ld a,$01		; $7992
	ld (wTmpcfc0.goronDance.linkJumping),a		; $7994
	jp interactionIncState2		; $7997

@roundFinished:
	xor a			; $799a
	ld (wTmpcfc0.goronDance.cfd9),a		; $799b
	ld hl,wTmpcfc0.goronDance.roundIndex		; $799e
	inc (hl)		; $79a1

	ld h,d			; $79a2
	ld l,Interaction.state2		; $79a3
	ld (hl),$03		; $79a5
	ld l,Interaction.counter1		; $79a7
	ld (hl),30		; $79a9
	ret			; $79ab

;;
; @param[out]	zflag	z if too early or too late
; @addr{79ac}
_goronDance_checkInputNotTooEarlyOrLate:
	call _goronDance_getCurrentAndNeededFrameCounts		; $79ac

	; Add 8 to hl, 8 to bc (the "expected" moment to press the button?)
	ld a,$08		; $79af
	rst_addAToHl			; $79b1
	ld a,$08		; $79b2
	call addAToBc		; $79b4

	; Subtract 8 from hl (check earliest possible frame?)
	push bc			; $79b7
	ld b,$ff		; $79b8
	ld c,$f8		; $79ba
	add hl,bc		; $79bc
	pop bc			; $79bd

	call compareHlToBc		; $79be
	cp $01			; $79c1
	jr z,@tooEarly	; $79c3

	; Add $10 to hl (check latest possible frame?)
	ld a,$10		; $79c5
	rst_addAToHl			; $79c7
	call compareHlToBc		; $79c8
	cp $ff			; $79cb
	jr z,@tooLate	; $79cd
	ret			; $79cf

@tooEarly:
	ld a,$00		; $79d0
	ld (wTmpcfc0.goronDance.failureType),a		; $79d2
	ret			; $79d5

@tooLate:
	ld a,$01		; $79d6
	ld (wTmpcfc0.goronDance.failureType),a		; $79d8
	ret			; $79db

;;
; @param[out]	zflag	z the window for input this beat has passed.
; @addr{79dc}
_goronDance_checkTooLateToInput:
	call _goronDance_getCurrentAndNeededFrameCounts		; $79dc
	ld a,$08		; $79df
	rst_addAToHl			; $79e1
	jr ++			; $79e2

;;
; @param[out]	zflag	z if the exact expected time for the input has passed.
; @addr{79e4}
_goronDance_checkExactInputTimePassed:
	call _goronDance_getCurrentAndNeededFrameCounts		; $79e4
++
	call compareHlToBc		; $79e7
	cp $ff			; $79ea
	ret			; $79ec

;;
; @param[out]	bc	Current frame count
; @param[out]	hl	Needed frame count? (First OK frame to press button?)
; @addr{79ed}
_goronDance_getCurrentAndNeededFrameCounts:
	; hl = [wTmpcfc0.goronDance.beat] * 20
	ld a,(wTmpcfc0.goronDance.beat)		; $79ed
	push af			; $79f0
	call multiplyABy4		; $79f1
	ld l,c			; $79f4
	ld h,b			; $79f5
	pop af			; $79f6
	call multiplyABy16		; $79f7
	add hl,bc		; $79fa

	ld a,(wTmpcfc0.goronDance.frameCounter)		; $79fb
	ld c,a			; $79fe
	ld a,(wTmpcfc0.goronDance.frameCounter+1)		; $79ff
	ld b,a			; $7a02
	ret			; $7a03

;;
; @addr{7a04}
_goronDance_playMoveSound:
	ld a,(wTmpcfc0.goronDance.currentMove)		; $7a04
	bit 7,a			; $7a07
	ret nz			; $7a09
	cp $00			; $7a0a
	ret z			; $7a0c

	cp $02			; $7a0d
	jr z,++			; $7a0f
	ld a,SND_DING		; $7a11
	jp playSound		; $7a13
++
	ld a,SND_GORON_DANCE_B		; $7a16
	jp playSound		; $7a18

;;
; @addr{7a1b}
_goronDance_incBeat:
	ld hl,wTmpcfc0.goronDance.beat		; $7a1b
	inc (hl)		; $7a1e
	ret			; $7a1f

;;
; Get the next dance move, based on "danceLevel", "dancePattern", and "beat".
;
; @param[out]	zflag	nz if the data ran out.
; @addr{7a20}
_goronDance_getNextMove:
	ld a,(wTmpcfc0.goronDance.danceLevel)		; $7a20
	ld hl,_goronDance_sequenceData		; $7a23
	rst_addDoubleIndex			; $7a26
	ldi a,(hl)		; $7a27
	ld h,(hl)		; $7a28
	ld l,a			; $7a29
	ld a,(wTmpcfc0.goronDance.dancePattern)		; $7a2a
	swap a			; $7a2d
	ld b,a			; $7a2f
	ld a,(wTmpcfc0.goronDance.beat)		; $7a30
	add b			; $7a33
	rst_addAToHl			; $7a34
	ld a,(hl)		; $7a35
	ld (wTmpcfc0.goronDance.currentMove),a		; $7a36
	bit 7,a			; $7a39
	ret			; $7a3b

;;
; @addr{7a3c}
_goronDance_updateConsecutiveBPressCounter:
	ld hl,wTmpcfc0.goronDance.consecutiveBPressCounter		; $7a3c
	ld a,(wTmpcfc0.goronDance.currentMove)		; $7a3f
	cp $02			; $7a42
	jr z,+			; $7a44
	ld (hl),$00		; $7a46
	ret			; $7a48
+
	inc (hl)		; $7a49
	ret			; $7a4a

;;
; @param[out]	zflag	z if Link and dancers should jump
; @addr{7a4b}
_goronDance_updateLinkAndBackupDancerAnimation:
	call _goronDance_updateBackupDancerAnimation		; $7a4b
	ld a,(wTmpcfc0.goronDance.currentMove)		; $7a4e
	cp $01			; $7a51
	jr nz,@bButton	; $7a53

@aButton:
	ld a,LINK_ANIM_MODE_DANCELEFT		; $7a55
	ld (wcc50),a		; $7a57
	or d			; $7a5a
	ret			; $7a5b

@bButton:
	ld a,(wTmpcfc0.goronDance.consecutiveBPressCounter)		; $7a5c
	ld hl,_goronDance_linkBButtonAnimations		; $7a5f
	rst_addAToHl			; $7a62

	; Should they jump?
	ld a,(hl)		; $7a63
	cp $50			; $7a64
	ret z			; $7a66

	cp $04			; $7a67
	jr nz,_goronDance_turnLinkToDirection	; $7a69

	ld a,LINK_ANIM_MODE_GETITEM1HAND		; $7a6b
	ld (wcc50),a		; $7a6d
	or d			; $7a70
	ret			; $7a71

;;
; @param	a	Direction
; @addr{7a72}
_goronDance_turnLinkToDirection:
	ld hl,w1Link.direction		; $7a72
	ld (hl),a		; $7a75
	ld a,LINK_ANIM_MODE_WALK		; $7a76
	ld (wcc50),a		; $7a78
	or d			; $7a7b
	ret			; $7a7c


; Link's direction values for consecutive B presses.
; $04 marks a particular animation, and $50 marks that he should jump.
_goronDance_linkBButtonAnimations:
	.db $02 $03 $01 $04 $03 $50


;;
; @param[out]	zflag	z if they should jump
; @addr{7a83}
_goronDance_updateBackupDancerAnimation:
	call checkIsLinkedGame		; $7a83
	jr z,@gorons	; $7a86
	ld a,(wAreaFlags)		; $7a88
	and AREAFLAG_PAST			; $7a8b
	jr z,@gorons	; $7a8d

@subrosians:
	ld a,(wTmpcfc0.goronDance.currentMove)		; $7a8f
	cp $01			; $7a92
	jr nz,@subrosianBButton	; $7a94

	; A button
	ld a,$06		; $7a96
	jr @setDanceAnimation		; $7a98

@subrosianBButton:
	ld a,(wTmpcfc0.goronDance.consecutiveBPressCounter)		; $7a9a
	ld hl,_goronDance_subrosianBAnimations		; $7a9d
	rst_addAToHl			; $7aa0
	ld a,(hl)		; $7aa1
	cp $50			; $7aa2
	ret z			; $7aa4
	ld (wTmpcfc0.goronDance.danceAnimation),a		; $7aa5
	ret			; $7aa8

@gorons:
	ld a,(wTmpcfc0.goronDance.currentMove)		; $7aa9
	cp $01			; $7aac
	jr nz,@goronBButton	; $7aae

	; A button
	ld a,$06		; $7ab0
	jr @setDanceAnimation		; $7ab2

@goronBButton:
	ld a,(wTmpcfc0.goronDance.consecutiveBPressCounter)		; $7ab4
	ld hl,_goronDance_goronBAnimations		; $7ab7
	rst_addAToHl			; $7aba
	ld a,(hl)		; $7abb
	cp $50			; $7abc
	ret z			; $7abe

@setDanceAnimation:
	ld (wTmpcfc0.goronDance.danceAnimation),a		; $7abf
	ret			; $7ac2

_goronDance_goronBAnimations:
	.db $02 $03 $04 $01 $00 $50

_goronDance_subrosianBAnimations:
	.db $02 $03 $01 $03 $00 $50


;;
; @param[out]	zflag	z if the graceful goron should jump (5 consecutive B presses)
; @addr{7acf}
_goronDance_updateGracefulGoronAnimation:
	ld a,(wTmpcfc0.goronDance.currentMove)		; $7acf
	cp $01			; $7ad2
	jr nz,@bButton	; $7ad4

	; A button
	ld a,$06		; $7ad6
	jr @setAnimation		; $7ad8

@bButton:
	ld a,(wTmpcfc0.goronDance.consecutiveBPressCounter)		; $7ada
	ld hl,_goronDance_goronBAnimations		; $7add
	rst_addAToHl			; $7ae0
	ld a,(hl)		; $7ae1
	cp $50			; $7ae2
	ret z			; $7ae4

@setAnimation:
	call interactionSetAnimation		; $7ae5
	or d			; $7ae8
	ret			; $7ae9


; This holds the patterns for the various levels of the goron dance.
_goronDance_sequenceData:
	.dw @platinum
	.dw @gold
	.dw @silver
	.dw @bronze

; Each row represents one possible dance pattern.
;   $00 means "rest";
;   $01 means "A";
;   $02 means "B";
;   $ff means "End".

@platinum:
	.db $02 $02 $02 $01 $00 $00 $02 $01 $ff $00 $00 $00 $00 $00 $00 $00
	.db $02 $00 $02 $01 $00 $02 $02 $01 $ff $00 $00 $00 $00 $00 $00 $00
	.db $02 $02 $01 $00 $02 $02 $01 $00 $02 $00 $01 $00 $01 $ff $00 $00
	.db $02 $00 $02 $02 $00 $02 $02 $01 $ff $00 $00 $00 $00 $00 $00 $00
	.db $02 $01 $00 $02 $01 $00 $02 $02 $01 $ff $00 $00 $00 $00 $00 $00
	.db $02 $02 $02 $00 $02 $02 $02 $00 $02 $02 $02 $02 $02 $01 $01 $ff
	.db $02 $02 $02 $01 $00 $00 $02 $02 $01 $ff $00 $00 $00 $00 $00 $00
	.db $02 $00 $01 $00 $02 $01 $01 $ff $00 $00 $00 $00 $00 $00 $00 $00
	.db $02 $01 $01 $00 $00 $02 $02 $01 $ff $00 $00 $00 $00 $00 $00 $00
	.db $02 $02 $01 $02 $01 $01 $ff $00 $00 $00 $00 $00 $00 $00 $00 $00

@gold:
	.db $02 $01 $02 $00 $00 $02 $01 $02 $01 $ff $00 $00 $00 $00 $00 $00
	.db $02 $00 $02 $01 $00 $02 $01 $02 $01 $ff $00 $00 $00 $00 $00 $00
	.db $02 $02 $02 $00 $02 $01 $02 $ff $00 $00 $00 $00 $00 $00 $00 $00
	.db $02 $01 $02 $00 $02 $01 $02 $01 $ff $00 $00 $00 $00 $00 $00 $00
	.db $02 $01 $00 $02 $01 $00 $02 $02 $01 $ff $00 $00 $00 $00 $00 $00
	.db $02 $02 $00 $02 $01 $02 $ff $00 $00 $00 $00 $00 $00 $00 $00 $00
	.db $02 $02 $02 $01 $02 $02 $01 $ff $00 $00 $00 $00 $00 $00 $00 $00
	.db $02 $02 $02 $00 $02 $02 $02 $00 $02 $02 $02 $01 $02 $02 $01 $ff
	.db $02 $02 $01 $00 $02 $01 $01 $ff $00 $00 $00 $00 $00 $00 $00 $00
	.db $02 $02 $02 $01 $00 $01 $ff $00 $00 $00 $00 $00 $00 $00 $00 $00

@silver:
	.db $02 $02 $02 $00 $02 $02 $01 $ff $00 $00 $00 $00 $00 $00 $00 $00
	.db $02 $00 $02 $00 $01 $ff $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
	.db $02 $01 $01 $02 $01 $ff $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
	.db $02 $02 $01 $00 $02 $01 $02 $ff $00 $00 $00 $00 $00 $00 $00 $00
	.db $02 $00 $02 $02 $01 $ff $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
	.db $02 $02 $00 $02 $02 $01 $ff $00 $00 $00 $00 $00 $00 $00 $00 $00
	.db $02 $02 $02 $01 $02 $02 $01 $ff $00 $00 $00 $00 $00 $00 $00 $00
	.db $02 $01 $02 $01 $02 $02 $01 $ff $00 $00 $00 $00 $00 $00 $00 $00
	.db $02 $02 $02 $01 $ff $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
	.db $02 $02 $01 $00 $02 $02 $01 $ff $00 $00 $00 $00 $00 $00 $00 $00

@bronze:
	.db $02 $02 $01 $ff $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
	.db $02 $00 $02 $00 $01 $ff $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
	.db $02 $02 $01 $02 $01 $ff $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
	.db $02 $02 $02 $01 $ff $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
	.db $02 $00 $01 $ff $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
	.db $02 $01 $01 $ff $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
	.db $02 $01 $00 $02 $01 $ff $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
	.db $02 $01 $02 $01 $02 $02 $01 $ff $00 $00 $00 $00 $00 $00 $00 $00
	.db $02 $00 $02 $02 $00 $02 $02 $01 $ff $00 $00 $00 $00 $00 $00 $00
	.db $02 $02 $01 $02 $02 $02 $01 $ff $00 $00 $00 $00 $00 $00 $00 $00

;;
; @addr{7d72}
_goron_initGraphicsAndIncState:
	call _goron_initGraphics		; $7d72
	jp interactionIncState		; $7d75

;;
; @addr{7d78}
_goron_loadScriptAndInitGraphics:
	call _goron_initGraphics		; $7d78
	jr _goron_loadScript		; $7d7b

;;
; @addr{7d7d}
_goron_loadScriptFromTableAndInitGraphics:
	call _goron_initGraphics		; $7d7d
	jr _goron_loadScriptFromTable		; $7d80

;;
; @addr{7d82}
_goron_initGraphics:
	call interactionLoadExtraGraphics		; $7d82
	jp interactionInitGraphics		; $7d85

;;
; @addr{7d88}
_goron_loadScript:
	ld e,Interaction.subid		; $7d88
	ld a,(de)		; $7d8a
	ld hl,_goron_scriptTable		; $7d8b
	rst_addDoubleIndex			; $7d8e
	ldi a,(hl)		; $7d8f
	ld h,(hl)		; $7d90
	ld l,a			; $7d91
	call interactionSetScript		; $7d92
	jp interactionIncState		; $7d95

;;
; Load a script based on both subid and var03.
; @addr{7d98}
_goron_loadScriptFromTable:
	ld e,Interaction.subid		; $7d98
	ld a,(de)		; $7d9a
	ld hl,_goron_scriptTable		; $7d9b
	rst_addDoubleIndex			; $7d9e
	ldi a,(hl)		; $7d9f
	ld h,(hl)		; $7da0
	ld l,a			; $7da1
	inc e			; $7da2
	ld a,(de)		; $7da3
	rst_addDoubleIndex			; $7da4
	ldi a,(hl)		; $7da5
	ld h,(hl)		; $7da6
	ld l,a			; $7da7
	call interactionSetScript		; $7da8
	jp interactionIncState		; $7dab

; @addr{7dae}
_goron_scriptTable:
	.dw stubScript
	.dw goron_subid01Script
	.dw stubScript
	.dw goron_subid03Script
	.dw goron_subid04Script
	.dw @subid05ScriptTable
	.dw @subid06ScriptTable
	.dw goron_subid07Script
	.dw goron_subid08Script
	.dw @subid09ScriptTable
	.dw goron_subid0aScript
	.dw @subid0bScriptTable
	.dw goron_subid0cScript
	.dw goron_subid0dScript
	.dw goron_subid0eScript
	.dw stubScript
	.dw goron_subid10Script

@subid05ScriptTable:
	.dw goron_subid05Script_A
	.dw goron_subid05Script_A
	.dw goron_subid05Script_A
	.dw goron_subid05Script_B
	.dw goron_subid05Script_B
	.dw goron_subid05Script_B

@subid06ScriptTable:
	.dw goron_subid06Script_A
	.dw goron_subid06Script_B

@subid09ScriptTable:
	.dw goron_subid09Script_A
	.dw goron_subid09Script_B

@subid0bScriptTable:
	.dw goron_subid0bScript
	.dw goron_subid0bScript


; @addr{7de8}
goronDanceScriptTable:
	.dw goron_subid00Script
	.dw goronDanceScript_failedRound
	.dw goronDanceScript_givePrize

.ends


.BANK $0a SLOT 1
.ORG 0


interactionCode6f:
	jp interactionDelete		; $4000


; ==============================================================================
; INTERACID_SWITCH_TILE_TOGGLER
; ==============================================================================
interactionCode78:
	ld e,Interaction.state		; $4003
	ld a,(de)		; $4005
	rst_jumpTable			; $4006
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $400b
	ld (de),a		; $400d
	ld a,(wSwitchState)		; $400e
	ld e,Interaction.var03		; $4011
	ld (de),a		; $4013

@state1:
	ld a,(wSwitchState)		; $4014
	ld b,a			; $4017
	ld e,Interaction.var03		; $4018
	ld a,(de)		; $401a
	cp b			; $401b
	ret z			; $401c

	ld a,b			; $401d
	ld (de),a		; $401e
	ld e,Interaction.xh		; $401f
	ld a,(de)		; $4021
	ld hl,@tileReplacement		; $4022
	rst_addDoubleIndex			; $4025
	ld e,Interaction.subid		; $4026
	ld a,(de)		; $4028
	and b			; $4029
	jr z,+			; $402a
	inc hl			; $402c
+
	ld e,Interaction.yh		; $402d
	ld a,(de)		; $402f
	ld c,a			; $4030
	ld a,(hl)		; $4031
	jp setTile		; $4032

; Index for this table is "Interaction.xh". Determines what tiles will appear when
; a switch is on or off.
;   b0: tile index when switch not pressed
;   b1: tile index when switch pressed
@tileReplacement:
	.db $5d $59 ; $00
	.db $5d $5a ; $01
	.db $5d $5b ; $02
	.db $5d $5c ; $03
	.db $5e $59 ; $04
	.db $5e $5a ; $05
	.db $5e $5b ; $06
	.db $5e $5c ; $07
	.db $59 $5d ; $08
	.db $5a $5d ; $09
	.db $5b $5d ; $0a
	.db $5c $5d ; $0b (patch's minecart game)
	.db $59 $5e ; $0c
	.db $5a $5e ; $0d
	.db $5b $5e ; $0e
	.db $5c $5e ; $0f
	.db $59 $5b ; $10
	.db $5a $5c ; $11
	.db $5b $59 ; $12
	.db $5c $5a ; $13
	.db $59 $5c ; $14
	.db $5a $5b ; $15
	.db $5b $5a ; $16
	.db $5c $59 ; $17


; ==============================================================================
; INTERACID_MOVING_PLATFORM
;
; Variables:
;   Subid: After being processed, this just represents the size (see @collisionRadii).
;   var32: Formerly bits 3-7 of subid; the index of the "script" to use.
; ==============================================================================
interactionCode79:
	ld e,Interaction.state		; $4065
	ld a,(de)		; $4067
	rst_jumpTable			; $4068
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $406d
	ld (de),a		; $406f
	ld e,Interaction.subid		; $4070
	ld a,(de)		; $4072
	ld b,a			; $4073
	and $07			; $4074
	ld (de),a		; $4076

	ld a,b			; $4077
	ld e,Interaction.var32		; $4078
	swap a			; $407a
	rlca			; $407c
	and $1f			; $407d
	ld (de),a		; $407f
	call interactionInitGraphics		; $4080

	ld e,Interaction.speed		; $4083
	ld a,SPEED_80		; $4085
	ld (de),a		; $4087

	ld e,Interaction.subid		; $4088
	ld a,(de)		; $408a
	ld hl,@collisionRadii		; $408b
	rst_addDoubleIndex			; $408e
	ld e,Interaction.collisionRadiusY		; $408f
	ldi a,(hl)		; $4091
	ld (de),a		; $4092
	inc e			; $4093
	ld a,(hl)		; $4094
	ld (de),a		; $4095

	callab scriptHlp.movingPlatform_loadScript		; $4096
	callab scriptHlp.movingPlatform_runScript		; $409e
	jp objectSetVisible83		; $40a6

@collisionRadii:
	.db $08 $08
	.db $10 $08
	.db $18 $08
	.db $08 $10
	.db $08 $18
	.db $10 $10

@state1:
	ld a,(wLinkRidingObject)		; $40b5
	cp d			; $40b8
	jr z,@linkOnPlatform	; $40b9
	or a			; $40bb
	jr nz,@updateSubstate	; $40bc

	call @checkLinkTouching		; $40be
	jr nc,@updateSubstate	; $40c1

	; Just got on platform
	ld a,d			; $40c3
	ld (wLinkRidingObject),a		; $40c4
	jr @updateSubstate		; $40c7

@linkOnPlatform:
	call @checkLinkTouching		; $40c9
	jr c,@updateSubstate	; $40cc
	xor a			; $40ce
	ld (wLinkRidingObject),a		; $40cf

@updateSubstate:
	ld e,Interaction.state2		; $40d2
	ld a,(de)		; $40d4
	rst_jumpTable			; $40d5
	.dw @substate0
	.dw @substate1

;;
; @param[out]	cflag	Set if Link's touching the platform
; @addr{40da}
@checkLinkTouching:
	ld hl,w1Link.yh		; $40da
	ldi a,(hl)		; $40dd
	add $05			; $40de
	ld b,a			; $40e0
	inc l			; $40e1
	ld c,(hl)		; $40e2
	jp interactionCheckContainsPoint		; $40e3


; Substate 0: not moving
@substate0:
	call interactionDecCounter1		; $40e6
	ret nz			; $40e9
	callab scriptHlp.movingPlatform_runScript		; $40ea
	ret			; $40f2

; Substate 1: moving
@substate1:
	ld a,(wLinkPlayingInstrument)		; $40f3
	or a			; $40f6
	ret nz			; $40f7

	call objectApplySpeed		; $40f8
	ld a,(wLinkRidingObject)		; $40fb
	cp d			; $40fe
	jr nz,@substate0	; $40ff

	ld a,(w1Link.state)		; $4101
	cp $01			; $4104
	jr nz,@substate0	; $4106

	ld e,Interaction.speed		; $4108
	ld a,(de)		; $410a
	ld b,a			; $410b
	ld e,Interaction.angle		; $410c
	ld a,(de)		; $410e
	ld c,a			; $410f
	call updateLinkPositionGivenVelocity		; $4110
	jr @substate0		; $4113


; ==============================================================================
; INTERACID_ROLLER
;
; Variables:
;   counter1:
;   counter2:
;   var30: Original X-position, where it returns to
;   var31: Counter before showing "it's too heavy to move" text.
; ==============================================================================
interactionCode7a:
	call retIfTextIsActive		; $4115
	ld e,Interaction.state		; $4118
	ld a,(de)		; $411a
	rst_jumpTable			; $411b
	.dw @state0
	.dw @state1
	.dw @state2

@state0:
	ld a,$01		; $4122
	ld (de),a		; $4124
	call interactionInitGraphics		; $4125

	; [collisionRadiusY] = ([subid]+2)*8
	ld h,d			; $4128
	ld l,Interaction.subid		; $4129
	ld a,(hl)		; $412b
	add $02			; $412c
	swap a			; $412e
	rrca			; $4130
	ld l,Interaction.collisionRadiusY		; $4131
	ldi (hl),a		; $4133

	; [collisionRadiusX] = $06
	ld a,$06		; $4134
	ld (hl),a		; $4136

	ld l,Interaction.speed		; $4137
	ld (hl),SPEED_80		; $4139
	ld l,Interaction.counter1		; $413b
	ld (hl),30		; $413d
	ld l,Interaction.counter2		; $413f
	ld (hl),60		; $4141

	; Remember original X-position
	ld l,Interaction.xh		; $4143
	ld a,(hl)		; $4145
	ld l,Interaction.var30		; $4146
	ld (hl),a		; $4148

	call objectSetVisible83		; $4149

@state1:
	call @preventLinkFromPassing		; $414c
	jr c,@movingTowardRoller	; $414f

@notPushingAgainstRoller:
	ld h,d			; $4151
	ld l,Interaction.var31		; $4152
	ld (hl),30		; $4154

@moveTowardOriginalPosition:
	ld h,d			; $4156
	ld l,Interaction.counter1		; $4157
	ld (hl),30		; $4159

	; Return if already in position
	ld l,Interaction.xh		; $415b
	ld b,(hl)		; $415d
	ld l,Interaction.var30		; $415e
	ld a,(hl)		; $4160
	cp b			; $4161
	ret z			; $4162

	; Return unless counter2 reached 0
	ld l,Interaction.counter2		; $4163
	dec (hl)		; $4165
	ret nz			; $4166

	cp b			; $4167
	ld bc,$0008		; $4168
	jr nc,@moveRollerInDirection	; $416b
	ld bc,$0118		; $416d
	jr @moveRollerInDirection		; $4170


@movingTowardRoller:
	; Check Link's Y position is high or low enough (can't be on the edge)?
	ld h,d			; $4172
	ld l,Interaction.collisionRadiusY		; $4173
	ld a,(hl)		; $4175
	sub $02			; $4176
	ld b,a			; $4178
	ld c,b			; $4179
	sla c			; $417a
	inc c			; $417c
	ld l,Interaction.yh		; $417d
	ld a,(w1Link.yh)		; $417f
	sub (hl)		; $4182
	add b			; $4183
	cp c			; $4184
	jr nc,@notPushingAgainstRoller	; $4185

	; Must be moving directly toward the roller
	ld a,(wLinkAngle)		; $4187
	cp $08			; $418a
	ldbc $00,$08		; $418c
	jr z,++			; $418f
	cp $18			; $4191
	ldbc $01,$18		; $4193
	jr nz,@notPushingAgainstRoller	; $4196
++
	ld a,$01		; $4198
	ld (wForceLinkPushAnimation),a		; $419a
	ld a,(wBraceletGrabbingNothing)		; $419d
	and $03			; $41a0
	swap a			; $41a2
	rrca			; $41a4
	cp c			; $41a5
	jr z,@pushingAgainstRoller	; $41a6

	; Link isn't pushing against it with the bracelet. Check whether to show
	; informative text ("it's too heavy to move").

	; Check bracelet is not on A or B.
	ld hl,wInventoryB		; $41a8
	ld a,ITEMID_BRACELET		; $41ab
	cp (hl)			; $41ad
	jr z,@notPushingAgainstRoller	; $41ae
	inc hl			; $41b0
	cp (hl)			; $41b1
	jr z,@notPushingAgainstRoller	; $41b2

	; Check bracelet not being used.
	ld a,(wBraceletGrabbingNothing)		; $41b4
	or a			; $41b7
	jr nz,@notPushingAgainstRoller	; $41b8

	; Check not in air.
	ld a,(wLinkInAir)		; $41ba
	or a			; $41bd
	jr nz,@notPushingAgainstRoller	; $41be

	; Countdown before showing informative text.
	ld h,d			; $41c0
	ld l,Interaction.var31		; $41c1
	dec (hl)		; $41c3
	jr nz,@moveTowardOriginalPosition	; $41c4

	call showInfoTextForRoller		; $41c6
	jr @notPushingAgainstRoller		; $41c9

@pushingAgainstRoller:
	ld a,60		; $41cb
	ld e,Interaction.counter2		; $41cd
	ld (de),a		; $41cf
	call @checkRollerCanBePushed		; $41d0
	jp nz,@notPushingAgainstRoller		; $41d3

	; Roller can be pushed; decrement counter until it gets pushed.
	call interactionDecCounter1		; $41d6
	ret nz			; $41d9

;;
; @param	b	Animation (0 for right, 1 for left)
; @param	c	Angle
@moveRollerInDirection:
	ld l,Interaction.state		; $41da
	inc (hl)		; $41dc
	ld l,Interaction.angle		; $41dd
	ld (hl),c		; $41df

	; Use animation [subid]*2+b
	ld l,Interaction.subid		; $41e0
	ld a,(hl)		; $41e2
	add a			; $41e3
	add b			; $41e4
	call interactionSetAnimation		; $41e5

	ld hl,wInformativeTextsShown		; $41e8
	set 6,(hl)		; $41eb


; State 2: moving in a direction.
@state2:
	call objectApplySpeed		; $41ed
	call interactionAnimate		; $41f0
	call objectCheckCollidedWithLink_ignoreZ		; $41f3
	jr nc,+			; $41f6
	call @updateLinkPositionWhileRollerMoving		; $41f8
+
	ld h,d			; $41fb
	ld l,Interaction.animParameter		; $41fc
	ld a,(hl)		; $41fe
	or a			; $41ff
	jr z,@rollerSound	; $4200
	inc a			; $4202
	ret nz			; $4203

	; animParameter signaled end of pushing animation.
	ld l,Interaction.counter1		; $4204
	ld (hl),30		; $4206
	inc l			; $4208
	ld (hl),60		; $4209
	ld l,Interaction.state		; $420b
	dec (hl)		; $420d
	ret			; $420e
@rollerSound:
	ld (hl),$01		; $420f
	ld a,SND_ROLLER		; $4211
	jp playSound		; $4213


@updateLinkPositionWhileRollerMoving:
	ld a,(w1Link.adjacentWallsBitset)		; $4216
	cp $53			; $4219
	jr z,@squashLink	; $421b
	cp $ac			; $421d
	jr z,@squashLink	; $421f
	cp $33			; $4221
	jr z,@squashLink	; $4223
	cp $c3			; $4225
	jr z,@squashLink	; $4227
	cp $cc			; $4229
	jr z,@squashLink	; $422b
	cp $3c			; $422d
	jr z,@squashLink	; $422f

	call @preventLinkFromPassing		; $4231

	; If Link's facing any walls on left or right sides, move him left or right; what
	; will actually happen, is the function call will see that he's facing a wall, and
	; move him up or down toward a "wall-free" area. This apparently does not happen
	; with the "@preventLinkFromPassing" call, so it must be done here.
	ld a,(w1Link.adjacentWallsBitset)		; $4234
	and $0f			; $4237
	ret z			; $4239
	call objectGetAngleTowardLink		; $423a
	cp $10			; $423d
	ld c,$08		; $423f
	jr c,+			; $4241
	ld c,$18		; $4243
+
	ld e,Interaction.angle		; $4245
	ld a,(de)		; $4247
	cp c			; $4248
	ret nz			; $4249
	ld b,SPEED_100		; $424a
	jp updateLinkPositionGivenVelocity		; $424c

@squashLink:
	ld a,(w1Link.state)		; $424f
	cp LINK_STATE_NORMAL			; $4252
	ret nz			; $4254
	ld a,LINK_STATE_SQUISHED		; $4255
	ld (wLinkForceState),a		; $4257
	xor a			; $425a
	ld (wcc50),a		; $425b
	ret			; $425e

;;
; @param	c	Angle it's moving toward
; @param[out]	zflag	z if can be pushed.
; @addr{425f}
@checkRollerCanBePushed:
	; Do some weird math to get the topmost tile on the left or right side of the
	; roller?
	push bc			; $425f
	ld e,Interaction.subid		; $4260
	ld a,(de)		; $4262
	add $02			; $4263
	ldh (<hFF8B),a	; $4265
	swap a			; $4267
	rrca			; $4269
	ld b,a			; $426a
	ld e,Interaction.yh		; $426b
	ld a,(de)		; $426d
	sub b			; $426e
	add $08			; $426f
	and $f0			; $4271
	ld b,a			; $4273
	ld a,$08		; $4274
	ld l,$01		; $4276
	cp c			; $4278
	jr z,+			; $4279
	ld l,$ff		; $427b
+
	ld e,Interaction.xh		; $427d
	ld a,(de)		; $427f
	swap a			; $4280
	add l			; $4282
	and $0f			; $4283
	or b			; $4285
	pop bc			; $4286

	; Make sure there's no wall blocking the roller.
	ld l,a			; $4287
	ld h,>wRoomCollisions		; $4288
	ldh a,(<hFF8B)	; $428a
	ld e,a			; $428c
@nextTile:
	ld a,(hl)		; $428d
	cp $10			; $428e
	jr nc,+			; $4290
	or a			; $4292
	ret nz			; $4293
+
	ld a,l			; $4294
	add $10			; $4295
	ld l,a			; $4297
	dec e			; $4298
	jr nz,@nextTile	; $4299
	xor a			; $429b
	ret			; $429c

;;
; @param[out]	cflag	c if Link is pushing against the roller
; @addr{429d}
@preventLinkFromPassing:
	ld a,(w1Link.collisionType)		; $429d
	bit 7,a			; $42a0
	ret z			; $42a2
	ld a,(w1Link.state)		; $42a3
	cp LINK_STATE_NORMAL			; $42a6
	ret nz			; $42a8
	jp objectPreventLinkFromPassing		; $42a9



; ==============================================================================
; INTERACID_SPINNER
;
; Variables:
;   var3a: Bitmask for wSpinnerState (former value of "xh")
; ==============================================================================
interactionCode7d:
	ld e,Interaction.subid		; $42ac
	ld a,(de)		; $42ae
	rst_jumpTable			; $42af
	.dw @subid00
	.dw @subid01
	.dw _spinner_subid02

@subid00:
@subid01:
	ld e,Interaction.state		; $42b6
	ld a,(de)		; $42b8
	rst_jumpTable			; $42b9
	.dw @state0
	.dw interactionRunScript
	.dw @state2
	.dw @state3
	.dw @state4

@state0:
	ld a,$01		; $42c4
	ld (de),a		; $42c6

	ld h,d			; $42c7
	ld l,Interaction.xh		; $42c8
	ld a,(hl)		; $42ca
	ld l,Interaction.var3a		; $42cb
	ld (hl),a		; $42cd

	; Calculate subid (blue or red) based on whether the bit in wSpinnerState is set
	ld a,(wSpinnerState)		; $42ce
	and (hl)		; $42d1
	ld a,$01		; $42d2
	jr nz,+			; $42d4
	dec a			; $42d6
+
	ld l,Interaction.subid		; $42d7
	ld (hl),a		; $42d9

	; Calculate angle? (subid*8)
	swap a			; $42da
	rrca			; $42dc
	ld l,Interaction.angle		; $42dd
	ld (hl),a		; $42df

	ld l,Interaction.yh		; $42e0
	ld a,(hl)		; $42e2
	call setShortPosition		; $42e3

	call interactionInitGraphics		; $42e6
	ld hl,spinnerScript_initialization		; $42e9
	call interactionSetScript		; $42ec
	call objectSetVisible82		; $42ef

	; Create "arrow" object and set it as relatedObj1
	ldbc INTERACID_SPINNER, $02		; $42f2
	call objectCreateInteraction		; $42f5
	ret nz			; $42f8
	ld l,Interaction.relatedObj1		; $42f9
	ld (hl),d		; $42fb
	ret			; $42fc


; State 2: Link just touched the spinner.
@state2:
	ld hl,wcc95		; $42fd
	ld a,(wLinkInAir)		; $4300
	or a			; $4303
	jr nz,@revertToState1	; $4304

	; Check if in midair or swimming?
	bit 4,(hl)		; $4306
	jr nz,@beginTurning	; $4308

@revertToState1:
	; Undo everything we just did
	res 7,(hl)		; $430a
	ld e,Interaction.state		; $430c
	ld a,$01		; $430e
	ld (de),a		; $4310
	ld hl,spinnerScript_waitForLink		; $4311
	jp interactionSetScript		; $4314

@beginTurning:
	; State 3
	ld a,$03		; $4317
	ld (de),a		; $4319

	call clearAllParentItems		; $431a

	; Determine the direction Link entered from
	ld c,$28		; $431d
	call objectCheckLinkWithinDistance		; $431f
	sra a			; $4322
	ld e,Interaction.direction		; $4324
	ld (de),a		; $4326

	; Check angle
	ld b,a			; $4327
	inc e			; $4328
	ld a,(de)		; $4329
	or a			; $432a
	jr nz,@clockwise	; $432b

@counterClockwise:
	ld a,b			; $432d
	add a			; $432e
	ld hl,_spinner_counterClockwiseData		; $432f
	rst_addDoubleIndex			; $4332
	jr ++			; $4333

@clockwise:
	ld a,b			; $4335
	add a			; $4336
	ld hl,_spinner_clockwiseData		; $4337
	rst_addDoubleIndex			; $433a

++
	call _spinner_setLinkRelativePosition		; $433b
	ldi a,(hl)		; $433e
	ld c,<w1Link.direction		; $433f
	ld (bc),a		; $4341

	ld e,Interaction.var39		; $4342
	ld a,(hl)		; $4344
	ld (de),a		; $4345

	call setLinkForceStateToState08		; $4346

	; Disable everything but interactions?
	ld a,(wDisabledObjects)		; $4349
	or $80			; $434c
	ld (wDisabledObjects),a		; $434e

	ld a,$04		; $4351
	call setScreenShakeCounter		; $4353

	ld a,SND_OPENCHEST		; $4356
	jp playSound		; $4358


; State 3: In the process of turning
@state3:
	call _spinner_updateLinkPosition		; $435b

	ld e,Interaction.animParameter		; $435e
	ld a,(de)		; $4360
	inc a			; $4361
	jp nz,interactionAnimate		; $4362

	; Finished turning, set up state 4
	ld h,d			; $4365
	ld l,Interaction.state		; $4366
	ld (hl),$04		; $4368

	ld l,Interaction.counter1		; $436a
	ld (hl),$10		; $436c
	xor a			; $436e
	ld (wDisabledObjects),a		; $436f

	; Update Link's angle based on direction
	ld hl,w1Link.direction		; $4372
	ldi a,(hl)		; $4375
	swap a			; $4376
	rrca			; $4378
	ld (hl),a		; $4379

	; Force him to move out
	ld hl,wLinkForceState		; $437a
	ld a,LINK_STATE_FORCE_MOVEMENT		; $437d
	ldi (hl),a		; $437f
	inc l			; $4380
	ld (hl),$10		; $4381

	; Reset signal that spinner's being used?
	ld hl,wcc95		; $4383
	res 7,(hl)		; $4386
	ret			; $4388

; State 4: Link moving out from spinner
@state4:
	call interactionDecCounter1		; $4389
	ret nz			; $438c

	; Toggle spinner state
	ld l,Interaction.var3a		; $438d
	ld a,(wSpinnerState)		; $438f
	xor (hl)		; $4392
	ld (wSpinnerState),a		; $4393

	; Toggle color
	ld l,Interaction.oamFlags		; $4396
	ld a,(hl)		; $4398
	xor $01			; $4399
	ld (hl),a		; $439b

	; Toggle angle
	ld l,Interaction.angle		; $439c
	ld a,(hl)		; $439e
	xor $08			; $439f
	ld (hl),a		; $43a1

	; Go back to state 1
	ld l,Interaction.state		; $43a2
	ld (hl),$01		; $43a4
	ld hl,spinnerScript_waitForLinkAfterDelay		; $43a6
	jp interactionSetScript		; $43a9


; Arrow rotating around a spinner
_spinner_subid02:
	ld e,Interaction.state		; $43ac
	ld a,(de)		; $43ae
	rst_jumpTable			; $43af
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $43b4
	ld (de),a		; $43b6
	call interactionInitGraphics		; $43b7

	; [this.angle] = [relatedObj1.angle]
	ld e,Interaction.relatedObj1		; $43ba
	ld a,(de)		; $43bc
	ld h,d			; $43bd
	ld l,Interaction.angle		; $43be
	ld e,l			; $43c0
	ld a,(hl)		; $43c1
	ld (de),a		; $43c2
	call objectSetVisible82		; $43c3

@state1:
	; Check if [this.angle] == [relatedObj1.angle]
	ld e,Interaction.relatedObj1		; $43c6
	ld a,(de)		; $43c8
	ld h,a			; $43c9
	ld l,Interaction.angle		; $43ca
	ld e,l			; $43cc
	ld a,(de)		; $43cd
	cp (hl)			; $43ce
	jr z,++			; $43cf

	; Angle changed (red to blue, or blue to red)
	ld a,(hl)		; $43d1
	ld (de),a		; $43d2
	swap a			; $43d3
	rlca			; $43d5
	add $02			; $43d6
	call interactionSetAnimation		; $43d8
++
	; [this.oamFlags] = [relatedObj1.oamFlags]
	ld e,Interaction.relatedObj1		; $43db
	ld a,(de)		; $43dd
	ld h,a			; $43de
	ld l,Interaction.oamFlags		; $43df
	ld e,l			; $43e1
	ld a,(hl)		; $43e2
	ld (de),a		; $43e3

	jp interactionAnimate		; $43e4

;;
; @addr{43e7}
_spinner_updateLinkPosition:
	; Check that the animParameter signals Link should change position (nonzero and
	; not $ff)
	ld e,Interaction.animParameter		; $43e7
	ld a,(de)		; $43e9
	ld b,a			; $43ea
	or a			; $43eb
	ret z			; $43ec
	inc a			; $43ed
	ret z			; $43ee

	xor a			; $43ef
	ld (de),a		; $43f0

	ld a,SND_DOORCLOSE		; $43f1
	call playSound		; $43f3

	; Read from table based on value of "animParameter" and "var39" to determine
	; Link's position relative to the spinner.
	ld e,Interaction.var39		; $43f6
	ld a,(de)		; $43f8
	add b			; $43f9
	and $0f			; $43fa
	ld hl,_spinner_linkRelativePositions		; $43fc
	rst_addDoubleIndex			; $43ff

;;
; @param	hl	Address of 2 bytes (Y/X offset for Link relative to spinner)
; @addr{4400}
_spinner_setLinkRelativePosition:
	ld b,>w1Link		; $4400
	ld e,Interaction.yh		; $4402
	ld c,<w1Link.yh		; $4404
	call @func		; $4406

	ld e,Interaction.xh		; $4409
	ld c,<w1Link.xh		; $440b

@func:
	ld a,(de)		; $440d
	add (hl)		; $440e
	inc hl			; $440f
	ld (bc),a		; $4410
	ret			; $4411


; Each row of below table represents data for a particular direction of transition:
;   b0: Y offset for Link relative to spinner
;   b1: X offset for Link relative to spinner
;   b2: Value for w1Link.direction
;   b3: Value for spinner.var39 (relative index for _spinner_linkRelativePositions)
_spinner_counterClockwiseData:
	.db $f4 $00 $03 $08 ; DIR_UP (Link enters from above)
	.db $00 $0c $00 $04 ; DIR_RIGHT
	.db $0c $00 $01 $00 ; DIR_DOWN
	.db $00 $f4 $02 $0c ; DIR_LEFT

_spinner_clockwiseData:
	.db $f4 $00 $01 $08 ; DIR_UP
	.db $00 $0c $02 $04 ; DIR_RIGHT
	.db $0c $00 $03 $00 ; DIR_DOWN
	.db $00 $f4 $00 $0c ; DIR_LEFT


; Each row is a Y/X offset for Link. The row is selected from the animation's
; "animParameter" and "var39".
_spinner_linkRelativePositions:
	.db $0c $00
	.db $0a $02
	.db $08 $08
	.db $02 $0a
	.db $00 $0c
	.db $fe $0a
	.db $f8 $08
	.db $f6 $02
	.db $f4 $00
	.db $f6 $fe
	.db $f8 $f8
	.db $fe $f6
	.db $00 $f4
	.db $02 $f6
	.db $08 $f8
	.db $0a $fe


; ==============================================================================
; INTERACID_MINIBOSS_PORTAL
; ==============================================================================
interactionCode7e:
	ld e,Interaction.subid		; $4452
	ld a,(de)		; $4454
	rst_jumpTable			; $4455
	.dw @subid00
	.dw @subid01


; Subid $00: miniboss portals
@subid00:
	ld e,Interaction.state		; $445a
	ld a,(de)		; $445c
	rst_jumpTable			; $445d
	.dw @minibossState0
	.dw @state1
	.dw @state2
	.dw @minibossState3

@minibossState0:
	ld a,(wDungeonIndex)		; $4466
	ld hl,@dungeonRoomTable		; $4469
	rst_addDoubleIndex			; $446c
	ld c,(hl)		; $446d
	ld a,(wActiveGroup)		; $446e
	ld hl,flagLocationGroupTable
	rst_addAToHl			; $4474
	ld h,(hl)		; $4475
	ld l,c			; $4476

	; hl now points to room flags for the miniboss room
	; Delete if miniboss is not dead.
	ld a,(hl)		; $4477
	and $80			; $4478
	jp z,interactionDelete		; $447a

	ld c,$57		; $447d
	call objectSetShortPosition		; $447f

@commonState0:
	call interactionInitGraphics		; $4482
	ld a,$03		; $4485
	call objectSetCollideRadius		; $4487

	; Go to state 1 if Link's not touching the portal, state 2 if he is.
	call objectCheckCollidedWithLink_notDeadAndNotGrabbing		; $448a
	ld a,$01		; $448d
	jr nc,+			; $448f
	inc a			; $4491
+
	ld e,Interaction.state		; $4492
	ld (de),a		; $4494
	jp objectSetVisible83		; $4495


; State 1: waiting for Link to touch the portal to initiate the warp.
@state1:
	call interactionAnimate		; $4498
	call objectCheckCollidedWithLink_notDeadAndNotGrabbing		; $449b
	ret nc			; $449e

	; Check that [w1Link.id] == SPECIALOBJECTID_LINK, check collisions are enabled
	ld a,(w1Link.id)		; $449f
	or a			; $44a2
	call z,checkLinkCollisionsEnabled		; $44a3
	ret nc			; $44a6

	call resetLinkInvincibility		; $44a7
	ld a,$03		; $44aa
	ld e,Interaction.state		; $44ac
	ld (de),a		; $44ae
	ld (wLinkCanPassNpcs),a		; $44af

	ld a,$30		; $44b2
	ld e,Interaction.counter1		; $44b4
	ld (de),a		; $44b6
	call setLinkForceStateToState08		; $44b7
	ld hl,w1Link.visible		; $44ba
	ld (hl),$82		; $44bd
	call objectCopyPosition ; Link.position = this.position

	ld a,$01		; $44c2
	ld (wDisabledObjects),a		; $44c4
	ld a,SND_TELEPORT		; $44c7
	jp playSound		; $44c9


; State 2: wait for Link to get off the portal before detecting collisions
@state2:
	call interactionAnimate		; $44cc
	call objectCheckCollidedWithLink_notDeadAndNotGrabbing		; $44cf
	ret c			; $44d2
	ld a,$01		; $44d3
	ld e,Interaction.state		; $44d5
	ld (de),a		; $44d7
	ret			; $44d8


; State 3: Do the warp
@minibossState3:
	ld hl,w1Link		; $44d9
	call objectCopyPosition		; $44dc
	call @spinLink		; $44df
	ret nz			; $44e2

	; Get starting room in 'b', miniboss room in 'c'
	ld a,(wDungeonIndex)		; $44e3
	ld hl,@dungeonRoomTable		; $44e6
	rst_addDoubleIndex			; $44e9
	ldi a,(hl)		; $44ea
	ld c,(hl)		; $44eb
	ld b,a			; $44ec

	ld hl,wWarpDestGroup		; $44ed
	ld a,(wActiveGroup)		; $44f0
	or $80			; $44f3
	ldi (hl),a		; $44f5
	ld a,(wActiveRoom)		; $44f6
	cp b			; $44f9
	jr nz,+			; $44fa
	ld b,c			; $44fc
+
	ld a,b			; $44fd
	ldi (hl),a  ; [wWarpDestIndex] = b
	lda TRANSITION_DEST_0			; $44ff
	ldi (hl),a  ; [wWarpTransition] = TRANSITION_DEST_0
	ld (hl),$57 ; [wWarpDestPos] = $57
	inc l			; $4503
	ld (hl),$03 ; [wWarpTransition2] = $03 (fadeout)
	ret			; $4506

; Each row corresponds to a dungeon. The first byte is the miniboss room index, the second
; is the dungeon entrance (the two locations of the portal).
; If bit 7 is set in the miniboss room's flags, the portal is enabled.
@dungeonRoomTable:
	.db $01 $04
	.db $18 $24
	.db $34 $46
	.db $4d $66
	.db $80 $91
	.db $b4 $bb
	.db $12 $26
	.db $4d $56
	.db $82 $aa


@spinLink:
	call resetLinkInvincibility		; $4519
	call interactionAnimate		; $451c
	ld a,(wLinkDeathTrigger)		; $451f
	or a			; $4522
	ret nz			; $4523
	ld a,(wFrameCounter)		; $4524
	and $03			; $4527
	jr nz,++		; $4529
	ld hl,w1Link.direction		; $452b
	ld a,(hl)		; $452e
	inc a			; $452f
	and $03			; $4530
	ld (hl),a		; $4532
++
	jp interactionDecCounter1		; $4533


; Subid $01: miscellaneous portals used in Hero's Cave
@subid01:
	ld e,Interaction.state		; $4536
	ld a,(de)		; $4538
	rst_jumpTable			; $4539
	.dw @herosCaveState0
	.dw @state1
	.dw @state2
	.dw @herosCaveState3

@herosCaveState0:
	call interactionDeleteAndRetIfEnabled02		; $4542
	ld e,Interaction.xh		; $4545
	ld a,(de)		; $4547
	ld e,Interaction.var03		; $4548
	ld (de),a		; $454a
	bit 7,a			; $454b
	jr z,+			; $454d
	call getThisRoomFlags		; $454f
	and ROOMFLAG_ITEM			; $4552
	ret z			; $4554
+
	ld h,d			; $4555
	ld e,Interaction.yh		; $4556
	ld l,e			; $4558
	ld a,(de)		; $4559
	call setShortPosition		; $455a
	jp @commonState0		; $455d

@herosCaveState3:
	call @spinLink		; $4560
	ret nz			; $4563

	; Initiate the warp
	ld e,Interaction.var03		; $4564
	ld a,(de)		; $4566
	and $0f			; $4567
	call @initHerosCaveWarp		; $4569
	ld a,$84		; $456c
	ld (wWarpDestGroup),a		; $456e
	ret			; $4571

@initHerosCaveWarp:
	ld hl,@herosCaveWarps		; $4572
	rst_addDoubleIndex			; $4575
	ldi a,(hl)		; $4576
	ld (wWarpDestIndex),a		; $4577
	ldi a,(hl)		; $457a
	ld (wWarpDestPos),a		; $457b
	ld a,$85		; $457e
	ld (wWarpDestGroup),a		; $4580
	lda TRANSITION_DEST_0			; $4583
	ld (wWarpTransition),a		; $4584
	ld a,$03		; $4587
	ld (wWarpTransition2),a ; Fadeout transition
	ret			; $458c


; Each row corresponds to a value for bits 0-3 of "X" (later var03).
; First byte is "wWarpDestIndex" (room index), second is "wWarpDestPos".
@herosCaveWarps:
	.db $c2 $11
	.db $c3 $2c
	.db $c4 $11
	.db $c5 $2c
	.db $c6 $7a
	.db $c9 $86
	.db $ce $57
	.db $cf $91


; ==============================================================================
; INTERACID_ESSENCE
; ==============================================================================
interactionCode7f:
	ld a,(wLinkDeathTrigger)		; $459d
	or a			; $45a0
	ret nz			; $45a1

	ld e,Interaction.subid		; $45a2
	ld a,(de)		; $45a4
	rst_jumpTable			; $45a5
	.dw _interaction7f_subid00
	.dw _interaction7f_subid01
	.dw _interaction7f_subid02


; Subid $00: the essence itself
_interaction7f_subid00:
	ld e,Interaction.state		; $45ac
	ld a,(de)		; $45ae
	rst_jumpTable			; $45af
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3
	.dw @state4
	.dw @state5
	.dw @state6
	.dw @state7

@state0:
	ld a,$01		; $45c0
	ld (de),a		; $45c2
	call interactionInitGraphics		; $45c3
	ld a,$04		; $45c6
	call objectSetCollideRadius		; $45c8

	; Create the pedestal
	ldbc INTERACID_ESSENCE, $01		; $45cb
	call objectCreateInteraction		; $45ce

	; Delete self if got essence
	call getThisRoomFlags		; $45d1
	and ROOMFLAG_ITEM			; $45d4
	jp nz,interactionDelete		; $45d6

	; Create the glow behind the essence
	ld hl,w1ReservedInteraction1		; $45d9
	ld b,$40		; $45dc
	call clearMemory		; $45de
	ld hl,w1ReservedInteraction1		; $45e1
	ld (hl),$81		; $45e4
	inc l			; $45e6
	ld (hl),INTERACID_ESSENCE		; $45e7
	inc l			; $45e9
	ld (hl),$02		; $45ea
	call objectCopyPosition		; $45ec

	; [Glow.relatedObj1] = this
	ld l,Interaction.relatedObj1		; $45ef
	ldh a,(<hActiveObjectType)	; $45f1
	ldi (hl),a		; $45f3
	ldh a,(<hActiveObject)	; $45f4
	ld (hl),a		; $45f6

	; [this.zh] = -$10
	ld h,d			; $45f7
	ld l,Interaction.zh		; $45f8
	ld (hl),-$10		; $45fa

	ld a,(wDungeonIndex)		; $45fc
	dec a			; $45ff

	; Override dungeon 6 past ($0b) with present ($05)
	cp $0b			; $4600
	jr nz,+			; $4602
	ld a,$05		; $4604
+
	; [var03] = index of oam data?
	ld l,Interaction.var03		; $4606
	ld (hl),a		; $4608

	; a *= 3
	ld b,a			; $4609
	add a			; $460a
	add b			; $460b

	ld hl,@essenceOamData		; $460c
	rst_addAToHl			; $460f
	ld e,Interaction.oamTileIndexBase		; $4610
	ld a,(de)		; $4612
	add (hl)		; $4613
	inc hl			; $4614
	ld (de),a		; $4615

	; e = Interaction.oamFlags
	dec e			; $4616
	ldi a,(hl)		; $4617
	ld (de),a		; $4618
	ld a,(hl)		; $4619
	call interactionSetAnimation		; $461a
	jp objectSetVisible81		; $461d


; Each row is sprite data for an essence.
;   b0: Which tile index to start at (in gfx_essences.bin)
;   b1: palette (/ flags)
;   b2: which layout to use (2-tile or 4-tile)
@essenceOamData:
	.db $00 $01 $01
	.db $04 $00 $02
	.db $06 $03 $02
	.db $08 $02 $02
	.db $0a $00 $02
	.db $0c $00 $02
	.db $0e $01 $01
	.db $12 $05 $01


; State 1: waiting for Link to approach.
@state1:
	; Update z position every 4 frames
	ld a,(wFrameCounter)	; $4638
	and $03			; $463b
	ret nz			; $463d
	ld h,d			; $463e
	ld l,Interaction.counter1		; $463f
	inc (hl)		; $4641
	ld a,(hl)		; $4642
	and $0f			; $4643
	ld hl,@essenceFloatOffsets		; $4645
	rst_addAToHl			; $4648
	ld a,(hl)		; $4649
	add $f0			; $464a
	ld e,Interaction.zh		; $464c
	ld (de),a		; $464e

	; Check various conditions for the essence to fall
	ld a,(wLinkInAir)		; $464f
	or a			; $4652
	ret nz			; $4653
	ld a,(wLinkGrabState)		; $4654
	or a			; $4657
	ret nz			; $4658
	ld b,$04		; $4659
	call objectCheckCenteredWithLink		; $465b
	ret nc			; $465e
	ld c,$14		; $465f
	call objectCheckLinkWithinDistance		; $4661
	ret nc			; $4664
	cp $04			; $4665
	ret nz			; $4667

	; Link has approached, essence will fall now.

	call clearAllParentItems		; $4668
	ld a,$81		; $466b
	ld (wDisabledObjects),a		; $466d
	ld (wDisableLinkCollisionsAndMenu),a		; $4670
	ld hl,w1Link.direction		; $4673
	ld (hl),DIR_UP		; $4676

	; Set angle, speed
	call objectGetAngleTowardLink		; $4678
	ld h,d			; $467b
	ld l,Interaction.angle		; $467c
	ld (hl),a		; $467e
	ld l,Interaction.speed		; $467f
	ld (hl),SPEED_80		; $4681

	ld l,Interaction.state		; $4683
	inc (hl)		; $4685

	call darkenRoom		; $4686

	ld a,SND_DROPESSENCE		; $4689
	call playSound		; $468b
	ld a,SNDCTRL_SLOW_FADEOUT		; $468e
	jp playSound		; $4690

@essenceFloatOffsets:
	.db $00 $00 $ff $ff $ff $fe $fe $fe
	.db $fe $fe $fe $ff $ff $ff $ff $00


; State 2: Moving toward Link
@state2:
	call objectGetAngleTowardLink		; $46a3
	ld e,Interaction.angle		; $46a6
	ld (de),a		; $46a8
	call objectApplySpeed		; $46a9
	call objectCheckCollidedWithLink_ignoreZ		; $46ac
	ret nc			; $46af

	ld e,Interaction.collisionRadiusX		; $46b0
	ld a,$06		; $46b2
	ld (de),a		; $46b4
	jp interactionIncState		; $46b5


; State 3: Falling down
@state3:
	ld c,$08		; $46b8
	call objectUpdateSpeedZ_paramC		; $46ba
	jr z,++			; $46bd
	call objectCheckCollidedWithLink_notDeadAndNotGrabbing		; $46bf
	ret nc			; $46c2
++
	ld h,d			; $46c3
	ld l,Interaction.counter1		; $46c4
	ld (hl),30		; $46c6
	jp interactionIncState		; $46c8


; State 4: After delay, begin "essence get" cutscene
@state4:
	call interactionDecCounter1		; $46cb
	ret nz			; $46ce

	; Put Link in a 2-handed item get animation
	ld a,LINK_STATE_04		; $46cf
	ld (wLinkForceState),a		; $46d1
	ld a,$01		; $46d4
	ld (wcc50),a		; $46d6

	call interactionIncState		; $46d9

	; Set this object's position relative to Link
	ld a,(w1Link.yh)		; $46dc
	sub $0e			; $46df
	ld l,Interaction.yh		; $46e1
	ldi (hl),a		; $46e3
	inc l			; $46e4
	ld a,(w1Link.xh)		; $46e5
	ldi (hl),a		; $46e8
	inc l			; $46e9

	; [this.z] = 0
	xor a			; $46ea
	ldi (hl),a		; $46eb
	ld (hl),a		; $46ec

	; Show essence get text
	ld l,Interaction.var03		; $46ed
	ld a,(hl)		; $46ef
	ld hl,@getEssenceTextTable		; $46f0
	rst_addAToHl			; $46f3
	ld b,>TX_0000		; $46f4
	ld c,(hl)		; $46f6
	call showText		; $46f7

	call getThisRoomFlags		; $46fa
	set ROOMFLAG_BIT_ITEM,(hl)		; $46fd

	; Give treasure
	ld e,Interaction.var03		; $46ff
	ld a,(de)		; $4701
	ld c,a			; $4702
	ld a,TREASURE_ESSENCE		; $4703
	jp giveTreasure		; $4705

@getEssenceTextTable:
	.db <TX_000e
	.db <TX_000f
	.db <TX_0010
	.db <TX_0011
	.db <TX_0012
	.db <TX_0013
	.db <TX_0014
	.db <TX_0015


; State 5: waiting for textbox to close
@state5:
	call retIfTextIsActive		; $4710

	call interactionIncState		; $4713
	ld hl,essenceScript_essenceGetCutscene		; $4716
	jp interactionSetScript		; $4719


; State 6: running script (essence get cutscene)
@state6:
	call interactionRunScript		; $471c
	ret nc			; $471f

	call interactionIncState		; $4720
	ld l,Interaction.counter1		; $4723
	ld (hl),30		; $4725


; State 7: After a delay, fade out
@state7:
	call interactionDecCounter1		; $4727
	ret nz			; $472a

	; Warp Link outta there
	ld l,Interaction.var03		; $472b
	ld a,(hl)		; $472d
	add a			; $472e
	ld hl,@essenceWarps		; $472f
	rst_addDoubleIndex			; $4732
	ldi a,(hl)		; $4733
	ld (wWarpDestGroup),a		; $4734
	ldi a,(hl)		; $4737
	ld (wWarpDestIndex),a		; $4738
	ldi a,(hl)		; $473b
	ld (wWarpDestPos),a		; $473c
	ld a,(hl)		; $473f
	ld (wWarpTransition),a		; $4740
	ld a,$83		; $4743
	ld (wWarpTransition2),a		; $4745

	xor a			; $4748
	ld (wActiveMusic),a		; $4749

	jp clearStaticObjects		; $474c


; Each row is warp data for getting an essence.
;   b0: wWarpDestGroup (group)
;   b1: wWarpDestIndex (room)
;   b2: wWarpDestPos
;   b3: wWarpTransition
@essenceWarps:
	.db $80, $8d, $26, TRANSITION_DEST_SET_RESPAWN
	.db $81, $83, $25, TRANSITION_DEST_SET_RESPAWN
	.db $80, $ba, $55, TRANSITION_DEST_SET_RESPAWN
	.db $80, $03, $35, TRANSITION_DEST_X_SHIFTED
	.db $80, $0a, $17, TRANSITION_DEST_SET_RESPAWN
	.db $83, $0f, $16, TRANSITION_DEST_SET_RESPAWN
	.db $82, $90, $45, TRANSITION_DEST_X_SHIFTED
	.db $81, $5c, $15, TRANSITION_DEST_X_SHIFTED


;;
; Pedestal for an essence
; @addr{476f}
_interaction7f_subid01:
	call checkInteractionState		; $476f
	jp nz,objectPreventLinkFromPassing		; $4772

	; Initialization
	ld a,$01		; $4775
	ld (de),a		; $4777
	ld bc,$060a		; $4778
	call objectSetCollideRadii		; $477b

	; Set tile above this one to be solid
	call objectGetTileAtPosition		; $477e
	dec h			; $4781
	ld (hl),$0f		; $4782

	call interactionInitGraphics		; $4784
	jp objectSetVisible83		; $4787


;;
; The glowing thing behind the essence
; @addr{478a}
_interaction7f_subid02:
	call checkInteractionState		; $478a
	jr nz,@state1			; $478d

@state0:
	ld a,$01		; $478f
	ld (de),a		; $4791
	call interactionInitGraphics		; $4792
	jp objectSetVisible82		; $4795

@state1:
	call @copyEssencePosition		; $4798
	call interactionAnimate		; $479b

	; Flicker visibility when animParameter is nonzero
	ld h,d			; $479e
	ld l,Interaction.animParameter		; $479f
	ld a,(hl)		; $47a1
	or a			; $47a2
	ret z			; $47a3
	ld (hl),$00		; $47a4
	ld l,Interaction.visible		; $47a6
	ld a,$80		; $47a8
	xor (hl)		; $47aa
	ld (hl),a		; $47ab
	ret			; $47ac

@copyEssencePosition:
	ld a,Object.enabled		; $47ad
	call objectGetRelatedObject1Var		; $47af
	jp objectTakePosition		; $47b2


; ==============================================================================
; INTERACID_VASU
;
; Variables:
;   var36: Nonzero if TREASURE_RING_BOX is obtained
;   var37: Nonzero if Link has unappraised rings?
;   var38: Nonzero if Link has rings in the ring list?
; ==============================================================================
interactionCode89:
	ld a,(wTextIsActive)		; $47b5
	or a			; $47b8
	jr nz,++		; $47b9

	; Textboxes are always on the bottom in Vasu's shop
	ld a,$02		; $47bb
	ld (wTextboxPosition),a		; $47bd
	ld a,TEXTBOXFLAG_DONTCHECKPOSITION		; $47c0
	ld (wTextboxFlags),a		; $47c2
++
	call @updateState		; $47c5
	ld e,Interaction.subid		; $47c8
	ld a,(de)		; $47ca
	or a			; $47cb
	jp nz,objectSetPriorityRelativeToLink_withTerrainEffects		; $47cc
	jp interactionPushLinkAwayAndUpdateDrawPriority		; $47cf

@updateState:
	ld e,Interaction.state		; $47d2
	ld a,(de)		; $47d4
	rst_jumpTable			; $47d5
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3
	.dw @state4
	.dw @state5


; State 0: Initialization of vasu or snake
@state0:
	ld a,$01		; $47e2
	ld (de),a		; $47e4
	call interactionInitGraphics		; $47e5
	call interactionSetAlwaysUpdateBit		; $47e8
	ld a,>TX_3000		; $47eb
	call interactionSetHighTextIndex		; $47ed
	ld e,Interaction.subid		; $47f0
	ld a,(de)		; $47f2
	or a			; $47f3
	jr z,@@initVasu	; $47f4

@@initSnake:
	ld a,$06		; $47f6
	call objectSetCollideRadius		; $47f8
	call objectGetTileCollisions		; $47fb
	ld (hl),$0f		; $47fe
	ld a,(de)		; $4800
	call interactionSetAnimation		; $4801
	ld e,Interaction.pressedAButton		; $4804
	jp objectAddToAButtonSensitiveObjectList		; $4806

@@initVasu:
	ld a,$04		; $4809
	ld e,Interaction.state		; $480b
	ld (de),a		; $480d
	ld hl,vasuScript		; $480e
	jp interactionSetScript		; $4811


; State 1: Snake waiting for Link to talk?
@state1:
	; Hide snake if Link is within a certain distance
	ld c,$18		; $4814
	call objectCheckLinkWithinDistance		; $4816
	ld e,Interaction.subid		; $4819
	ld a,(de)		; $481b
	jp nc,interactionSetAnimation		; $481c

	call interactionAnimate		; $481f
	ld h,d			; $4822
	ld l,Interaction.pressedAButton		; $4823
	ld a,(hl)		; $4825
	or a			; $4826
	ret z			; $4827

	; Linked talked to snake
	xor a			; $4828
	ld (hl),a		; $4829
	inc a			; $482a
	ld (wMenuDisabled),a		; $482b
	ld (wDisabledObjects),a		; $482e

	ld e,l			; $4831
	call objectRemoveFromAButtonSensitiveObjectList		; $4832

	ld h,d			; $4835
	ld l,Interaction.state		; $4836
	ld a,$02		; $4838
	ldd (hl),a		; $483a
	dec l			; $483b
	ld a,(hl)		; $483c
	inc a			; $483d
	jp interactionSetAnimation		; $483e


; State 2: Just talked to snake
@state2:
	call @checkRingBoxAndRingsObtained		; $4841
	call interactionAnimate		; $4844
	ld e,Interaction.subid		; $4847
	ld a,(de)		; $4849
	and $04			; $484a
	ld b,a			; $484c
	ld c,$00		; $484d
	ld e,Interaction.var36		; $484f
	ld a,(de)		; $4851
	or a			; $4852
	jr z,@loadPrelinkedScript	; $4853

	ld a,GLOBALFLAG_FINISHEDGAME		; $4855
	call checkGlobalFlag		; $4857
	jr nz,@loadLinkedScript	; $485a

	ld hl,wFileIsLinkedGame		; $485c
	ldi a,(hl)		; $485f
	or (hl)			; $4860
	jr nz,@loadLinkedScript	; $4861

@loadPrelinkedScript:
	ld c,$02		; $4863
@loadLinkedScript:
	ld a,b			; $4865
	add c			; $4866
	ld hl,@scriptTable		; $4867
	rst_addAToHl			; $486a
	ldi a,(hl)		; $486b
	ld h,(hl)		; $486c
	ld l,a			; $486d

@setScriptAndGotoState4:
	call interactionSetScript		; $486e
	ld e,Interaction.state		; $4871
	ld a,$04		; $4873
	ld (de),a		; $4875
	ret			; $4876

@scriptTable:
	.dw blueSnakeScript_linked
	.dw blueSnakeScript_preLinked
	.dw redSnakeScript_linked
	.dw redSnakeScript_preLinked


; State 3: Cleaning up after a script?
@state3:
	call interactionAnimate		; $487f
	ld e,Interaction.animParameter		; $4882
	ld a,(de)		; $4884
	or a			; $4885
	ret z			; $4886

	xor a			; $4887
	ld (wMenuDisabled),a		; $4888
	ld e,Interaction.state		; $488b
	ld a,$01		; $488d
	ld (de),a		; $488f
	ld e,Interaction.subid		; $4890

	; For snakes only, reset animation, do stuff with A button?
	ld a,(de)		; $4892
	or a			; $4893
	ret z			; $4894
	call interactionSetAnimation		; $4895
	ld e,Interaction.pressedAButton		; $4898
	jp objectAddToAButtonSensitiveObjectList		; $489a


; State 4: Running script for Vasu or snake
@state4:
	call @checkRingBoxAndRingsObtained		; $489d
	call interactionAnimate		; $48a0
	call interactionRunScript		; $48a3
	ret nc			; $48a6

	; Script finished
	xor a			; $48a7
	ld (wMenuDisabled),a		; $48a8
	ld (wDisabledObjects),a		; $48ab

	; If this is a snake, set the animation, revert to state 3?
	ld e,Interaction.subid		; $48ae
	ld a,(de)		; $48b0
	or a			; $48b1
	ret z			; $48b2

	add $02			; $48b3
	call interactionSetAnimation		; $48b5

	ld e,Interaction.state		; $48b8
	ld a,$03		; $48ba
	ld (de),a		; $48bc
	ret			; $48bd


; State 5: Linking with blue snake?
@state5:
	call interactionAnimate		; $48be
	ld e,Interaction.state2		; $48c1
	ld a,(de)		; $48c3
	rst_jumpTable			; $48c4
	.dw @state5Substate0
	.dw @state5Substate1
	.dw @state5Substate2
	.dw @state5Substate3
	.dw @state5Substate4

@state5Substate0:
	call retIfTextIsActive		; $48cf
	call interactionIncState2		; $48d2
	xor a			; $48d5
	ld l,Interaction.counter1		; $48d6
	ld (hl),a		; $48d8
	ld l,Interaction.counter2		; $48d9
	ld (hl),$02		; $48db
	ld a,$04		; $48dd
	jp interactionSetAnimation		; $48df

@state5Substate1:
	call interactionDecCounter1		; $48e2
	jr nz,@label_0a_036	; $48e5
	inc l			; $48e7
	dec (hl)		; $48e8
	jr nz,@label_0a_036	; $48e9
	xor a			; $48eb
	ld ($ff00+R_SB),a	; $48ec
	ld hl,blueSnakeExitScript_cableNotConnected		; $48ee
	ld b,$80		; $48f1
	jr @setBlueSnakeExitScript		; $48f3

@label_0a_036:
	ldh a,(<hSerialInterruptBehaviour)	; $48f5
	or a			; $48f7
	jp z,serialFunc_0c73		; $48f8

	and $01			; $48fb
	add $01			; $48fd
	ldh (<hFFBE),a	; $48ff
	call interactionIncState2		; $4901

	ld l,Interaction.counter1		; $4904
	ld (hl),180		; $4906
	ld bc,TX_3030		; $4908
	jp showTextNonExitable		; $490b

@state5Substate2:
	call serialFunc_0c8d		; $490e
	ldh a,(<hSerialInterruptBehaviour)	; $4911
	or a			; $4913
	ret nz			; $4914

	ld a,($ff00+R_SVBK)	; $4915
	push af			; $4917
	ld a,:w4RingFortuneStuff		; $4918
	ld ($ff00+R_SVBK),a	; $491a
	ldh a,(<hFFBD)	; $491c
	ld b,a			; $491e
	ld a,($cbc2)		; $491f
	ld e,a			; $4922
	ld a,(w4RingFortuneStuff)		; $4923
	ld c,a			; $4926

	pop af			; $4927
	ld ($ff00+R_SVBK),a	; $4928

	ld a,b			; $492a
	or e			; $492b
	jr nz,@blueSnakeErrorCondition	; $492c

	; Put 'c' into var3a (ring to get from fortune)
	ld e,Interaction.var3a		; $492e
	ld a,c			; $4930
	ld (de),a		; $4931
	call interactionDecCounter1		; $4932
	ret nz			; $4935
	ld hl,blueSnakeScript_successfulFortune		; $4936
	jr @setBlueSnakeExitScript		; $4939

@blueSnakeErrorCondition:
	ld hl,blueSnakeScript_doNotRemoveCable		; $493b
	ld a,e			; $493e
	cp $8f			; $493f
	jr z,@setBlueSnakeExitScript	; $4941
	ld hl,blueSnakeExitScript_noValidFile		; $4943
	cp $85			; $4946
	jr z,@setBlueSnakeExitScript	; $4948
	ld hl,blueSnakeExitScript_linkFailed		; $494a

@setBlueSnakeExitScript:
	xor a			; $494d
	ld (wDisabledObjects),a		; $494e
	call @setScriptAndGotoState4		; $4951
	ld a,$02		; $4954
	jp interactionSetAnimation		; $4956

@state5Substate3:
	call retIfTextIsActive		; $4959

	; Open linking menu
	ld a,$08		; $495c
	call openMenu		; $495e
	jp interactionIncState2		; $4961

@state5Substate4:
	ld a,($ff00+R_SVBK)	; $4964
	push af			; $4966
	ld a,:w4RingFortuneStuff		; $4967
	ld ($ff00+R_SVBK),a	; $4969

	ldh a,(<hFFBD)	; $496b
	ld b,a			; $496d
	ld a,($cbc2)		; $496e
	ld e,a			; $4971

	pop af			; $4972
	ld ($ff00+R_SVBK),a	; $4973

	ld a,b			; $4975
	or e			; $4976
	jr nz,@blueSnakeErrorCondition	; $4977

	ld hl,blueSnakeScript_successfulRingTransfer		; $4979
	jr @setBlueSnakeExitScript		; $497c


; Populates var36, var37, var38 as described in the variable list.
@checkRingBoxAndRingsObtained:
	ld a,TREASURE_RING_BOX		; $497e
	call checkTreasureObtained		; $4980
	ld a,$00		; $4983
	rla			; $4985
	ld e,Interaction.var36		; $4986
	ld (de),a		; $4988

	ld a,(wNumUnappraisedRingsBcd)		; $4989
	inc e			; $498c
	ld (de),a		; $498d
	ld hl,wRingsObtained		; $498e
	ld b,$08		; $4991
	xor a			; $4993
@@nextRing:
	or (hl)			; $4994
	inc l			; $4995
	dec b			; $4996
	jr nz,@@nextRing	; $4997
	inc e			; $4999
	ld (de),a		; $499a
	ret			; $499b


; ==============================================================================
; INTERACID_BUBBLE
;
; Variables:
;   var30: Value to add to angle
;   var31: Number of times to add [var30] to angle before switching direction
; ==============================================================================
interactionCode91:
	ld e,Interaction.subid		; $499c
	ld a,(de)		; $499e
	or a			; $499f
	ld e,Interaction.state		; $49a0
	ld a,(de)		; $49a2
	jp nz,@subid01		; $49a3

@subid00:
	or a			; $49a6
	jr z,@@state0		; $49a7

@@state1:
	call @checkDelete		; $49a9
	jp c,interactionDelete		; $49ac

	call objectApplySpeed		; $49af
	ld e,Interaction.yh		; $49b2
	ld a,(de)		; $49b4
	cp $f0			; $49b5
	jp nc,interactionDelete		; $49b7

	call interactionDecCounter1		; $49ba
	ret nz			; $49bd

	ld (hl),$04		; $49be
	ld l,Interaction.var31		; $49c0
	dec (hl)		; $49c2
	jr nz,++		; $49c3

	ld (hl),$08		; $49c5
	ld l,Interaction.var30		; $49c7
	ld a,(hl)		; $49c9
	cpl			; $49ca
	inc a			; $49cb
	ld (hl),a		; $49cc
++
	ld e,Interaction.angle		; $49cd
	ld a,(de)		; $49cf
	ld l,Interaction.var30		; $49d0
	add (hl)		; $49d2
	and $1f			; $49d3
	ld (de),a		; $49d5
	ret			; $49d6

@@state0:
	call @checkDelete		; $49d7
	jp c,interactionDelete		; $49da

	call interactionInitGraphics		; $49dd
	call interactionIncState		; $49e0
	ld l,Interaction.speed		; $49e3
	ld (hl),SPEED_80		; $49e5

	ld l,Interaction.counter1		; $49e7
	ld a,$04		; $49e9
	ldi (hl),a		; $49eb
	ld (hl),180 ; [counter2] = 180

	ld l,Interaction.var31		; $49ee
	inc a			; $49f0
	ldd (hl),a		; $49f1
	call getRandomNumber		; $49f2
	and $01			; $49f5
	jr nz,+			; $49f7
	dec a			; $49f9
+
	ld (hl),a		; $49fa
	ld a,(wAreaFlags)		; $49fb
	and AREAFLAG_SIDESCROLL			; $49fe
	jp nz,objectSetVisible83		; $4a00

@randomNumberFrom0To4:
	call getRandomNumber_noPreserveVars		; $4a03
	and $07			; $4a06
	cp $05			; $4a08
	jr nc,@randomNumberFrom0To4	; $4a0a

	; Set random initial angle
	sub $02			; $4a0c
	and $1f			; $4a0e
	ld e,Interaction.angle		; $4a10
	ld (de),a		; $4a12
	jp objectSetVisible81		; $4a13

@subid01:
	or a			; $4a16
	jr z,@@state0		; $4a17

@@state1:
	ld a,Object.collisionType		; $4a19
	call objectGetRelatedObject1Var		; $4a1b
	bit 7,(hl)		; $4a1e
	jp z,interactionDelete		; $4a20
	call objectTakePosition		; $4a23
	call interactionDecCounter1		; $4a26
	ret nz			; $4a29
	ld (hl),90		; $4a2a
	ld b,INTERACID_BUBBLE		; $4a2c
	jp objectCreateInteractionWithSubid00		; $4a2e

@@state0:
	call interactionIncState		; $4a31
	ld l,Interaction.counter1		; $4a34
	ld (hl),30		; $4a36
	ret			; $4a38

;;
; @param[out]	cflag	c if bubble should be deleted (no longer in water)
; @addr{4a39}
@checkDelete:
	ld a,(wAreaFlags)		; $4a39
	and AREAFLAG_SIDESCROLL			; $4a3c
	jp nz,@@sidescrolling		; $4a3e

@@topDown:
	call interactionDecCounter2		; $4a41
	ld a,(hl)		; $4a44
	cp 60			; $4a45
	ret nc			; $4a47
	or a			; $4a48
	scf			; $4a49
	ret z			; $4a4a

	; In last 60 frames, flicker
	ld l,Interaction.visible		; $4a4b
	ld a,(hl)		; $4a4d
	xor $80			; $4a4e
	ld (hl),a		; $4a50
	ret			; $4a51

@@sidescrolling:
	; Check if it's still in water
	call objectGetTileAtPosition		; $4a52
	ld hl,hazardCollisionTable		; $4a55
	call lookupCollisionTable		; $4a58
	ccf			; $4a5b
	ret			; $4a5c

; ==============================================================================
; INTERACID_COMPANION_SPAWNER
; ==============================================================================
interactionCode67:
	ld e,Interaction.subid		; $4a5d
	ld a,(de)		; $4a5f
	cp $06			; $4a60
	jr z,@label_0a_045	; $4a62
	ld a,(de)		; $4a64
	rlca			; $4a65
	jr c,@fluteCall	; $4a66
	ld a,(w1Companion.enabled)		; $4a68
	or a			; $4a6b
	jp nz,@deleteSelf		; $4a6c

@label_0a_045:
	ld a,(de)		; $4a6f
	rst_jumpTable			; $4a70
	.dw @subid00
	.dw @subid01
	.dw @subid02
	.dw @subid03
	.dw @subid04
	.dw @subid05

@fluteCall:
	ld a,(w1Companion.enabled)		; $4a7d
	or a			; $4a80
	jr z,@label_0a_047	; $4a81

	; If there's already something in the companion slot, continue if it's the
	; minecart or anything past moosh (maple, raft).
	; But there's a check later that will prevent the companion from spawning if this
	; slot is in use...
	ld a,(w1Companion.id)		; $4a83
	cp SPECIALOBJECTID_MOOSH+1			; $4a86
	jr nc,@label_0a_047	; $4a88
	cp SPECIALOBJECTID_MINECART			; $4a8a
	jp nz,@deleteSelf		; $4a8c

@label_0a_047:
	ld a,(wAreaFlags)		; $4a8f
	and (AREAFLAG_PAST | AREAFLAG_OUTDOORS)			; $4a92
	cp AREAFLAG_OUTDOORS			; $4a94
	jp nz,@deleteSelf		; $4a96

	; In the past or indoors; "Your song just echoes..."
	ld bc,TX_510f		; $4a99
	ld a,(wFluteIcon)		; $4a9c
	or a			; $4a9f
	jp z,@showTextAndDelete		; $4aa0

	; If in the present, check if companion is callable in this room
	ld a,(wActiveRoom)		; $4aa3
	ld hl,companionCallableRooms		; $4aa6
	call checkFlag		; $4aa9
	jp z,@fluteSongFellFlat		; $4aac

	; Don't call companion if the slot is in use already
	ld a,(w1Companion.enabled)		; $4aaf
	or a			; $4ab2
	jp nz,@deleteSelf		; $4ab3

	; [var3e/var3f] = Link's position
	ld e,Interaction.var3e		; $4ab6
	ld hl,w1Link.yh		; $4ab8
	ldi a,(hl)		; $4abb
	and $f0			; $4abc
	ld (de),a		; $4abe
	inc l			; $4abf
	inc e			; $4ac0
	ld a,(hl)		; $4ac1
	swap a			; $4ac2
	and $0f			; $4ac4
	ld (de),a		; $4ac6

	; Try various things to determine where companion should enter from?

	; Try from top at Link's x position
	ld hl,wRoomCollisions		; $4ac7
	rst_addAToHl			; $4aca
	call @checkVerticalCompanionSpawnPosition		; $4acb
	ld b,-$08		; $4ace
	ld l,c			; $4ad0
	ld h,$10		; $4ad1
	ld a,DIR_DOWN		; $4ad3
	jr z,@setCompanionDestination	; $4ad5

	; Try from bottom at Link's x
	ld e,Interaction.var3f		; $4ad7
	ld a,(de)		; $4ad9
	ld hl,wRoomCollisions+$60		; $4ada
	rst_addAToHl			; $4add
	call @checkVerticalCompanionSpawnPosition		; $4ade
	ld b,SMALL_ROOM_HEIGHT*$10+8		; $4ae1
	ld l,c			; $4ae3
	ld h,SMALL_ROOM_HEIGHT*$10-$10		; $4ae4
	ld a,DIR_UP		; $4ae6
	jr z,@setCompanionDestination	; $4ae8

	; Try from right at Link's y
	ld e,Interaction.var3e		; $4aea
	ld a,(de)		; $4aec
	ld hl,wRoomCollisions+$08		; $4aed
	rst_addAToHl			; $4af0
	call @checkHorizontalCompanionSpawnPosition		; $4af1
	ld c,SMALL_ROOM_WIDTH*$10+8		; $4af4
	ld h,b			; $4af6
	ld l,SMALL_ROOM_WIDTH*$10-$10		; $4af7
	ld a,DIR_LEFT		; $4af9
	jr z,@setCompanionDestination	; $4afb

	; Try from left at Link's y
	ld e,Interaction.var3e		; $4afd
	ld a,(de)		; $4aff
	ld hl,wRoomCollisions		; $4b00
	rst_addAToHl			; $4b03
	call @checkHorizontalCompanionSpawnPosition		; $4b04
	ld c,-$08		; $4b07
	ld h,b			; $4b09
	ld l,$10		; $4b0a
	ld a,DIR_RIGHT		; $4b0c
	jr z,@setCompanionDestination	; $4b0e

	; Try from top at range of x positions
	ld hl,wRoomCollisions+$03		; $4b10
	call @checkCompanionSpawnColumnRange		; $4b13
	ld b,-$08		; $4b16
	ld l,c			; $4b18
	ld h,$10		; $4b19
	ld a,DIR_DOWN		; $4b1b
	jr nz,@setCompanionDestination	; $4b1d

	; Try from bottom at range of x positions
	ld hl,wRoomCollisions+$63		; $4b1f
	call @checkCompanionSpawnColumnRange		; $4b22
	ld b,SMALL_ROOM_HEIGHT*$10+8		; $4b25
	ld l,c			; $4b27
	ld h,SMALL_ROOM_HEIGHT*$10-$10		; $4b28
	ld a,DIR_UP		; $4b2a
	jr nz,@setCompanionDestination	; $4b2c

	; Try from right at range of y positions
	ld hl,wRoomCollisions+$28		; $4b2e
	call @checkCompanionSpawnRowRange		; $4b31
	ld c,SMALL_ROOM_WIDTH*$10+8		; $4b34
	ld h,b			; $4b36
	ld l,SMALL_ROOM_WIDTH*$10-$10		; $4b37
	ld a,DIR_LEFT		; $4b39
	jr nz,@setCompanionDestination	; $4b3b

	; Try from left at range of y positions
	ld hl,wRoomCollisions+$20		; $4b3d
	call @checkCompanionSpawnRowRange		; $4b40
	ld c,$f8		; $4b43
	ld h,b			; $4b45
	ld l,$10		; $4b46
	ld a,DIR_RIGHT		; $4b48
	jr z,@fluteSongFellFlat	; $4b4a


; @param	a	Direction companion should move in
; @param	bc	Initial Y/X position
; @param	hl	Y/X destination
@setCompanionDestination:
	push de			; $4b4c
	push hl			; $4b4d
	pop de			; $4b4e
	ld hl,wLastAnimalMountPointY		; $4b4f
	ld (hl),d		; $4b52
	inc l			; $4b53
	ld (hl),e		; $4b54
	pop de			; $4b55

	ld hl,w1Companion.direction		; $4b56
	ldi (hl),a		; $4b59
	swap a			; $4b5a
	rrca			; $4b5c
	ldi (hl),a		; $4b5d

	inc l			; $4b5e
	ld (hl),b		; $4b5f
	ld l,SpecialObject.xh		; $4b60
	ld (hl),c		; $4b62

	ld l,SpecialObject.enabled		; $4b63
	inc (hl)		; $4b65
	inc l			; $4b66
	ld a,(wAnimalCompanion)		; $4b67
	ldi (hl),a ; [SpecialObject.id]

	; State $0c = entering screen from flute call
	ld l,SpecialObject.state		; $4b6b
	ld a,$0c		; $4b6d
	ld (hl),a		; $4b6f
	jr @deleteSelf		; $4b70


@fluteSongFellFlat:
	ld bc,TX_510c		; $4b72

@showTextAndDelete:
	ld a,(wTextIsActive)		; $4b75
	or a			; $4b78
	call z,showText		; $4b79

@deleteSelf:
	jp interactionDelete		; $4b7c


; Moosh being attacked by ghosts
@subid00:
	ld hl,wMooshState		; $4b7f
	ld a,(wEssencesObtained)		; $4b82
	bit 1,a			; $4b85
	jr z,@deleteSelf	; $4b87
	ld a,(wPastRoomFlags+$79)		; $4b89
	bit 6,a			; $4b8c
	jr z,@deleteSelf	; $4b8e
	ld a,TREASURE_CHEVAL_ROPE		; $4b90
	call checkTreasureObtained		; $4b92
	jr nc,@loadCompanionPresetIfHasntLeft	; $4b95
	jr @deleteSelf		; $4b97


; Moosh saying goodbye after getting cheval rope
@subid01:
	ld hl,wMooshState		; $4b99
	ld a,$40		; $4b9c
	and (hl)		; $4b9e
	jr nz,@deleteSelf	; $4b9f
	ld a,TREASURE_CHEVAL_ROPE		; $4ba1
	call checkTreasureObtained		; $4ba3
	jr c,@loadCompanionPresetIfHasntLeft	; $4ba6

@deleteSelf2:
	jr @deleteSelf		; $4ba8


; Dimitri being attacked by hungry tokays
@subid03:
	ld hl,wDimitriState		; $4baa
	ld a,(wEssencesObtained)		; $4bad
	bit 2,a			; $4bb0
	jr z,@deleteSelf	; $4bb2
	jr @loadCompanionPresetIfHasntLeft		; $4bb4


; Ricky looking for gloves
@subid02:
	ld a,GLOBALFLAG_GAVE_ROPE_TO_RAFTON		; $4bb6
	call checkGlobalFlag		; $4bb8
	jr z,@deleteSelf	; $4bbb
	ld hl,wRickyState		; $4bbd
	jr @loadCompanionPresetIfHasntLeft		; $4bc0


; Companion lost in forest
@subid04:
	ld a,GLOBALFLAG_COMPANION_LOST_IN_FOREST		; $4bc2
	call checkGlobalFlag		; $4bc4
	jr z,@deleteSelf	; $4bc7
	jr @label_0a_052		; $4bc9


; Cutscene outside forest where you get the flute
@subid05:
	ld a,GLOBALFLAG_SAVED_COMPANION_FROM_FOREST		; $4bcb
	call checkGlobalFlag		; $4bcd
	jr z,@deleteSelf	; $4bd0
@label_0a_052:
	ld a,GLOBALFLAG_GOT_FLUTE		; $4bd2
	call checkGlobalFlag		; $4bd4
	jr nz,@deleteSelf	; $4bd7
	jr @loadCompanionPreset		; $4bd9


@loadCompanionPresetIfHasntLeft:
	; This bit of the companion's state is set if he's left after his sidequest
	ld a,(hl)		; $4bdb
	and $40			; $4bdc
	jr nz,@deleteSelf2	; $4bde

; Load a companion's ID and position from a table of presets based on subid.
@loadCompanionPreset:
	ld e,Interaction.subid		; $4be0
	ld a,(de)		; $4be2
	add a			; $4be3
	ld hl,@presetCompanionData		; $4be4
	rst_addDoubleIndex			; $4be7

	ld bc,w1Companion.enabled		; $4be8
	ld a,$01		; $4beb
	ld (bc),a		; $4bed

	; Get companion, either from the table, or from wAnimalCompanion
	inc c			; $4bee
	ldi a,(hl)		; $4bef
	or a			; $4bf0
	jr nz,+			; $4bf1
	ld a,(wAnimalCompanion)		; $4bf3
+
	ld (bc),a		; $4bf6

	; Set Y/X
	ld c,SpecialObject.yh		; $4bf7
	ldi a,(hl)		; $4bf9
	ld (bc),a		; $4bfa
	ld (wLastAnimalMountPointY),a		; $4bfb
	ld c,SpecialObject.xh		; $4bfe
	ldi a,(hl)		; $4c00
	ld (bc),a		; $4c01
	ld (wLastAnimalMountPointX),a		; $4c02

	xor a			; $4c05
	ld (wRememberedCompanionId),a		; $4c06
	jr @deleteSelf2		; $4c09

;;
; Check if the first 2 tiles near the edge of the screen are walkable for a companion.
;
; @param	hl	Address in wRoomCollisions to start at
; @param[out]	bc	Position to spawn at
; @param[out]	zflag	z if the companion can spawn from there
; @addr{4c0b}
@checkVerticalCompanionSpawnPosition:
	ld b,$10		; $4c0b
	jr ++			; $4c0d

;;
; @param	hl	Address in wRoomCollisions to start at
; @param[out]	bc	Position to spawn at
; @param[out]	zflag	z if the companion can spawn from there
; @addr{4c0b}
@checkHorizontalCompanionSpawnPosition:
	ld b,$01		; $4c0f
++
	ld a,(hl)		; $4c11
	or a			; $4c12
	ret nz			; $4c13
	ld a,l			; $4c14
	add b			; $4c15
	ld l,a			; $4c16
	ld a,(hl)		; $4c17
	or a			; $4c18
	ld a,l			; $4c19
	ret nz			; $4c1a
	call convertShortToLongPosition		; $4c1b
	xor a			; $4c1e
	ret			; $4c1f

;;
; Checks the given column and up to the following 3 after for if the companion can spawn
; there.
;
; @param	hl	Starting position to check (also checks 3 rows/columns after)
; @param[out]	bc	Position to spawn at
; @param[out]	zflag	nz if valid position to spawn from found
; @addr{4c20}
@checkCompanionSpawnColumnRange:
	push de			; $4c20
	ld b,$01		; $4c21
	ld e,$10		; $4c23
	jr ++			; $4c25

;;
; @param	hl	Starting position to check (also checks 3 rows/columns after)
; @param[out]	bc	Position to spawn at
; @param[out]	zflag	nz if valid position to spawn from found
; @addr{4c27}
@checkCompanionSpawnRowRange:
	push de			; $4c27
	ld b,$10		; $4c28
	ld e,$01		; $4c2a
++
	ld c,$04		; $4c2c

@@nextRowOrColumn:
	ld a,(hl)		; $4c2e
	or a			; $4c2f
	jr z,@@tryThisRowOrColumn	; $4c30

@@resumeSearch:
	ld a,l			; $4c32
	add b			; $4c33
	ld l,a			; $4c34
	dec c			; $4c35
	jr nz,@@nextRowOrColumn	; $4c36

	pop de			; $4c38
	ret			; $4c39

@@tryThisRowOrColumn:
	ld a,l			; $4c3a
	add e			; $4c3b
	ld l,a			; $4c3c
	ld a,(hl)		; $4c3d
	or a			; $4c3e
	ld a,l			; $4c3f
	jr z,@@foundRowOrColumn	; $4c40
	sub e			; $4c42
	ld l,a			; $4c43
	jr @@resumeSearch		; $4c44

@@foundRowOrColumn:
	call convertShortToLongPosition		; $4c46
	or d			; $4c49
	pop de			; $4c4a
	ret			; $4c4b


; Data format:
;   b0: Companion ID (or $00 to use wAnimalCompanion)
;   b1: Y-position to spawn at
;   b2: X-position to spawn at
;   b3: Unused
@presetCompanionData:
	.db SPECIALOBJECTID_MOOSH,   $28, $58, $00 ; $00 == [subid]
	.db SPECIALOBJECTID_MOOSH,   $48, $38, $00 ; $01
	.db SPECIALOBJECTID_RICKY,   $40, $50, $00 ; $02
	.db SPECIALOBJECTID_DIMITRI, $48, $30, $00 ; $03
	.db $00,                     $58, $50, $00 ; $04
	.db $00,                     $48, $68, $00 ; $05


.include "build/data/companionCallableRooms.s"


; ==============================================================================
; INTERACID_ROSA
; ==============================================================================
interactionCode68:
	ld e,Interaction.subid		; $4c84
	ld a,(de)		; $4c86
	rst_jumpTable			; $4c87
	.dw @subid00
	.dw @subid01

@subid00:
	call checkInteractionState		; $4c8c
	jr nz,@@state1	; $4c8f

@@state0:
	call checkIsLinkedGame		; $4c91
	jp z,interactionDelete		; $4c94

	ld a,(wEssencesObtained)		; $4c97
	bit 2,a			; $4c9a
	jp nz,interactionDelete		; $4c9c

	call @initGraphicsAndLoadScript		; $4c9f
	call objectSetVisiblec2		; $4ca2
	call getThisRoomFlags		; $4ca5
	bit 6,a			; $4ca8
	jr nz,@@alreadyGaveShovel		; $4caa

	; Spawn shovel object
	call getFreeInteractionSlot		; $4cac
	ret nz			; $4caf
	ld (hl),INTERACID_MISCELLANEOUS		; $4cb0
	inc l			; $4cb2
	ld (hl),$09		; $4cb3
	ld l,Interaction.relatedObj1+1		; $4cb5
	ld a,d			; $4cb7
	ld (hl),a		; $4cb8
	ret			; $4cb9

@@alreadyGaveShovel:
	ld hl,rosa_subid00Script_alreadyGaveShovel		; $4cba
	jp interactionSetScript		; $4cbd

@@state1:
	call interactionRunScript		; $4cc0
	ld a,TREASURE_SHOVEL		; $4cc3
	call checkTreasureObtained		; $4cc5
	jp c,npcFaceLinkAndAnimate		; $4cc8
	jp interactionAnimateAsNpc		; $4ccb


@subid01:
	call checkInteractionState		; $4cce
	jr nz,@@state1	; $4cd1

@@state0:
	call @loadScriptFromTableAndInitGraphics		; $4cd3
	ld l,Interaction.var37		; $4cd6
	ld (hl),$04		; $4cd8
	call interactionRunScript		; $4cda
@@state1:
	call interactionRunScript		; $4cdd
	jp c,interactionDelete		; $4ce0
	jp npcFaceLinkAndAnimate		; $4ce3


; Unused
@initGraphicsAndIncState:
	call interactionInitGraphics		; $4ce6
	call objectMarkSolidPosition		; $4ce9
	jp interactionIncState		; $4cec

@initGraphicsAndLoadScript:
	call interactionInitGraphics		; $4cef
	call objectMarkSolidPosition		; $4cf2
	jr @loadScriptAndIncState		; $4cf5


@loadScriptFromTableAndInitGraphics:
	call interactionInitGraphics		; $4cf7
	call objectMarkSolidPosition		; $4cfa
	jr @loadScriptFromTableAndIncState		; $4cfd

@loadScriptAndIncState:
	call @getScript		; $4cff
	call interactionSetScript		; $4d02
	jp interactionIncState		; $4d05

@loadScriptFromTableAndIncState:
	call @getScript		; $4d08
	inc e			; $4d0b
	ld a,(de)		; $4d0c
	rst_addDoubleIndex			; $4d0d
	ldi a,(hl)		; $4d0e
	ld h,(hl)		; $4d0f
	ld l,a			; $4d10
	call interactionSetScript		; $4d11
	jp interactionIncState		; $4d14

@getScript:
	ld a,>TX_1c00		; $4d17
	call interactionSetHighTextIndex		; $4d19
	ld e,Interaction.subid		; $4d1c
	ld a,(de)		; $4d1e
	ld hl,@scriptTable		; $4d1f
	rst_addDoubleIndex			; $4d22
	ldi a,(hl)		; $4d23
	ld h,(hl)		; $4d24
	ld l,a			; $4d25
	ret			; $4d26

@scriptTable:
	.dw rosa_subid00Script
	.dw @scriptTable2

@scriptTable2:
	.dw rosa_subid01Script


; ==============================================================================
; INTERACID_RAFTON
;
; Variables:
;   var38: "behaviour" (what he does based on the stage in the game)
; ==============================================================================
interactionCode69:
	ld e,Interaction.state		; $4d2d
	ld a,(de)		; $4d2f
	rst_jumpTable			; $4d30
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $4d35
	ld (de),a		; $4d37

	; Bit 7 of room flags set when Rafton isn't in this room?
	call getThisRoomFlags		; $4d38
	bit 7,a			; $4d3b
	jp nz,interactionDelete		; $4d3d

	call interactionInitGraphics		; $4d40
	call objectSetVisiblec2		; $4d43
	ld a,>TX_2700		; $4d46
	call interactionSetHighTextIndex		; $4d48

	ld e,Interaction.subid		; $4d4b
	ld a,(de)		; $4d4d
	rst_jumpTable			; $4d4e
	.dw @initSubid00
	.dw @initSubid01

@initSubid00:
	ld a,GLOBALFLAG_RAFTON_CHANGED_ROOMS		; $4d53
	call checkGlobalFlag		; $4d55
	jp nz,interactionDelete		; $4d58
	ld c,$04		; $4d5b
	ld a,TREASURE_ISLAND_CHART		; $4d5d
	call checkTreasureObtained		; $4d5f
	jr c,@setBehaviour	; $4d62

	dec c			; $4d64
	ld a,GLOBALFLAG_GAVE_ROPE_TO_RAFTON		; $4d65
	call checkGlobalFlag		; $4d67
	jr nz,@setBehaviour	; $4d6a

	dec c			; $4d6c
	ld a,TREASURE_CHEVAL_ROPE		; $4d6d
	call checkTreasureObtained		; $4d6f
	jr c,@setBehaviour	; $4d72

	dec c			; $4d74
	ld a,(wEssencesObtained)		; $4d75
	bit 1,a			; $4d78
	jr nz,@setBehaviour	; $4d7a
	dec c			; $4d7c

@setBehaviour:
	ld h,d			; $4d7d
	ld l,Interaction.var38		; $4d7e
	ld (hl),c		; $4d80
	jr @loadScript		; $4d81


@initSubid01:
	ld a,GLOBALFLAG_RAFTON_CHANGED_ROOMS		; $4d83
	call checkGlobalFlag		; $4d85
	jp z,interactionDelete		; $4d88
	jr @loadScript		; $4d8b


@state1:
	ld e,Interaction.subid		; $4d8d
	ld a,(de)		; $4d8f
	rst_jumpTable			; $4d90
	.dw @runSubid00
	.dw @runSubid01

@runSubid00:
	call interactionRunScript		; $4d95
	jp c,interactionDelete		; $4d98

	ld e,Interaction.var38		; $4d9b
	ld a,(de)		; $4d9d
	cp $04			; $4d9e
	jp z,interactionAnimateBasedOnSpeed		; $4da0
	jp interactionAnimateAsNpc		; $4da3

@runSubid01:
	call interactionAnimateAsNpc		; $4da6
	jp interactionRunScript		; $4da9

@loadScript:
	ld e,Interaction.subid		; $4dac
	ld a,(de)		; $4dae
	ld hl,@scriptTable		; $4daf
	rst_addDoubleIndex			; $4db2
	ldi a,(hl)		; $4db3
	ld h,(hl)		; $4db4
	ld l,a			; $4db5
	jp interactionSetScript		; $4db6

@scriptTable:
	.dw rafton_subid00Script
	.dw rafton_subid01Script


; ==============================================================================
; INTERACID_CHEVAL
; ==============================================================================
interactionCode6a:
	ld e,Interaction.state		; $4dbd
	ld a,(de)		; $4dbf
	rst_jumpTable			; $4dc0
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $4dc5
	ld (de),a		; $4dc7
	call interactionInitGraphics		; $4dc8
	call objectSetVisiblec2		; $4dcb
	ld a,>TX_2700		; $4dce
	call interactionSetHighTextIndex		; $4dd0

	ld e,Interaction.subid		; $4dd3
	ld a,(de)		; $4dd5
	rst_jumpTable			; $4dd6
	.dw @loadScript

@state1:
	ld e,Interaction.subid		; $4dd9
	ld a,(de)		; $4ddb
	rst_jumpTable			; $4ddc
	.dw @runSubid00

@runSubid00:
	call interactionRunScript		; $4ddf
	jp interactionAnimateAsNpc		; $4de2

@loadScript:
	ld e,Interaction.subid		; $4de5
	ld a,(de)		; $4de7
	ld hl,@scriptTable		; $4de8
	rst_addDoubleIndex			; $4deb
	ldi a,(hl)		; $4dec
	ld h,(hl)		; $4ded
	ld l,a			; $4dee
	jp interactionSetScript		; $4def

@scriptTable:
	.dw cheval_subid00Script


; ==============================================================================
; INTERACID_MISCELLANEOUS
; ==============================================================================
interactionCode6b:
	ld e,Interaction.subid		; $4df4
	ld a,(de)		; $4df6
	rst_jumpTable			; $4df7
	.dw _interaction6b_subid00
	.dw _interaction6b_subid01
	.dw _interaction6b_subid02
	.dw _interaction6b_subid03
	.dw _interaction6b_subid04
	.dw _interaction6b_subid05
	.dw _interaction6b_subid06
	.dw _interaction6b_subid07
	.dw _interaction6b_subid08
	.dw _interaction6b_subid09
	.dw _interaction6b_subid0a
	.dw _interaction6b_subid0b
	.dw _interaction6b_subid0c
	.dw _interaction6b_subid0d
	.dw _interaction6b_subid0e
	.dw _interaction6b_subid0f
	.dw _interaction6b_subid10
	.dw _interaction6b_subid11
	.dw _interaction6b_subid12
	.dw _interaction6b_subid13
	.dw _interaction6b_subid14
	.dw _interaction6b_subid15
	.dw _interaction6b_subid16


; Handles showing Impa's "Help" text when Link's about to screen transition
_interaction6b_subid00:
	call checkInteractionState		; $4e26
	jr nz,@state1	; $4e29

@state0:
	ld a,$01		; $4e2b
	ld (de),a		; $4e2d
	call getThisRoomFlags		; $4e2e
	bit 6,a			; $4e31
	jp nz,interactionDelete		; $4e33
@state1:
	call checkInteractionState2		; $4e36
	jr nz,@substate1	; $4e39

@substate0:
	call _interaction6b_checkLinkPressedUpAtScreenEdge		; $4e3b
	ret z			; $4e3e

	ld a,$01		; $4e3f
	ld (wMenuDisabled),a		; $4e41
	ld (wDisabledObjects),a		; $4e44
	ld e,Interaction.counter1		; $4e47
	ld a,30		; $4e49
	ld (de),a		; $4e4b
	ld bc,TX_0100		; $4e4c
	call showText		; $4e4f
	jp interactionIncState2		; $4e52

@substate1:
	call @decCounter1IfTextNotActive		; $4e55
	ret nz			; $4e58

	xor a			; $4e59
	ld (wDisabledObjects),a		; $4e5a
	push de			; $4e5d

	ld hl,@simulatedInput		; $4e5e
	ld a,:@simulatedInput		; $4e61
	call setSimulatedInputAddress		; $4e63

	pop de			; $4e66
	call getThisRoomFlags		; $4e67
	set 6,(hl)		; $4e6a

	jp interactionDelete		; $4e6c

@decCounter1IfTextNotActive:
	ld a,(wTextIsActive)		; $4e6f
	or a			; $4e72
	ret nz			; $4e73
	jp interactionDecCounter1		; $4e74

@simulatedInput:
	dwb 8, BTN_UP
	.dw $ffff


; Spawns nayru, ralph, animals before she's possessed
_interaction6b_subid01:
	ld e,Interaction.state		; $4e7c
	ld a,(de)		; $4e7e
	rst_jumpTable			; $4e7f
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $4e84
	ld (de),a		; $4e86
	ld a,GLOBALFLAG_INTRO_DONE		; $4e87
	call checkGlobalFlag		; $4e89
	jr nz,@delete	; $4e8c

	ld hl,objectData.nayruAndAnimalsInIntro		; $4e8e
	call parseGivenObjectData		; $4e91
	ld a,INTERACID_NAYRU		; $4e94
	ld (wInteractionIDToLoadExtraGfx),a		; $4e96

	push de			; $4e99
	ld a,UNCMP_GFXH_IMPA_FAINTED		; $4e9a
	call loadUncompressedGfxHeader		; $4e9c
	pop de			; $4e9f

@delete:
	jp interactionDelete		; $4ea0

@state1:
	; Never executed (deletes self before running state 1)
	call interactionRunScript		; $4ea3
	jp c,interactionDelete		; $4ea6
	ret			; $4ea9


; Script for cutscene with Ralph outside Ambi's palace, before getting mystery seeds
_interaction6b_subid02:
	call checkInteractionState		; $4eaa
	jr nz,@state1	; $4ead

@state0:
	ld a,TREASURE_MYSTERY_SEEDS		; $4eaf
	call checkTreasureObtained		; $4eb1
	jp c,interactionDelete		; $4eb4

@loadScript:
	jp _interaction6b_loadScript		; $4eb7

@state1:
	call interactionRunScript		; $4eba
	jp c,interactionDelete		; $4ebd
	ret			; $4ec0


; Seasons troupe member with guitar / tambourine?
_interaction6b_subid03:
_interaction6b_subid12:
	call checkInteractionState		; $4ec1
	jp nz,interactionAnimate		; $4ec4

@state0:
	call _interaction6b_initGraphicsAndIncState		; $4ec7
	jp objectSetVisible82		; $4eca


; Script for cutscene where moblins attack maku sapling
_interaction6b_subid04:
	call checkInteractionState		; $4ecd
	jr nz,@state1	; $4ed0

@state0:
	xor a			; $4ed2
	ld ($ccd4),a		; $4ed3
	call _interaction6b_loadScript		; $4ed6
@state1:
	call interactionRunScript		; $4ed9
	jp c,interactionDelete		; $4edc
	ret			; $4edf


; Cutscene in intro where lightning strikes a guy
_interaction6b_subid05:
	ld e,Interaction.state		; $4ee0
	ld a,(de)		; $4ee2
	rst_jumpTable			; $4ee3
	.dw _interaction6b_subid02@loadScript
	.dw @state1

@state1:
	call checkInteractionState2		; $4ee8
	jr nz,@substate1	; $4eeb

@substate0:
	call interactionRunScript		; $4eed
	ret nc			; $4ef0

	call interactionIncState2		; $4ef1
	ld l,Interaction.counter1		; $4ef4
	ld (hl),$01		; $4ef6
	inc l			; $4ef8
	ld l,Interaction.counter2		; $4ef9
	ld (hl),$00		; $4efb

@substate1:
	call interactionDecCounter1		; $4efd
	ret nz			; $4f00
	ld (hl),20		; $4f01
	inc l			; $4f03
	ld a,(hl)		; $4f04
	cp $04			; $4f05
	jp nz,++		; $4f07

	ld a,$03		; $4f0a
	ld (wTmpcfc0.introCutscene.cfd1),a		; $4f0c
	jp interactionDelete		; $4f0f
++
	inc (hl)		; $4f12
	ld hl,@lightningPositions		; $4f13
	rst_addDoubleIndex			; $4f16
	ld b,(hl)		; $4f17
	inc hl			; $4f18
	ld c,(hl)		; $4f19
	call getFreePartSlot		; $4f1a
	ret nz			; $4f1d
	ld (hl),PARTID_LIGHTNING		; $4f1e
	inc l			; $4f20
	inc (hl)		; $4f21
	inc l			; $4f22
	inc (hl)		; $4f23
	ld l,Part.yh		; $4f24
	ld (hl),b		; $4f26
	ld l,Part.xh		; $4f27
	ld (hl),c		; $4f29
	ret			; $4f2a

@lightningPositions:
	.db $28 $28
	.db $58 $38
	.db $38 $68
	.db $48 $98


; Manages cutscene after beating d3
_interaction6b_subid06:
	call checkInteractionState		; $4f33
	jr nz,@state1	; $4f36

@state0:
	ld a,(wEssencesObtained)		; $4f38
	bit 2,a			; $4f3b
	jr z,@delete	; $4f3d

	call getThisRoomFlags		; $4f3f
	and $40			; $4f42
	jp nz,@delete		; $4f44

	ld a,$01		; $4f47
	ld (wDisabledObjects),a		; $4f49
	ld (wMenuDisabled),a		; $4f4c
	call interactionIncState		; $4f4f
	ld l,Interaction.counter1		; $4f52
	ld (hl),90		; $4f54
	ret			; $4f56

@delete:
	jp interactionDelete		; $4f57

@state1:
	ld e,Interaction.state2		; $4f5a
	ld a,(de)		; $4f5c
	rst_jumpTable			; $4f5d
	.dw @substate0
	.dw @substate1
	.dw @substate2

@substate0:
	call interactionDecCounter1		; $4f64
	ret nz			; $4f67

	xor a			; $4f68
	ld hl,wGenericCutscene.cbb3		; $4f69
	ld (hl),a		; $4f6c
	dec a			; $4f6d
	ld hl,wGenericCutscene.cbba		; $4f6e
	ld (hl),a		; $4f71
	ld a,SND_LIGHTNING		; $4f72
	call playSound		; $4f74
	jp interactionIncState2		; $4f77

@substate1:
	ld hl,wGenericCutscene.cbb3		; $4f7a
	ld b,$01		; $4f7d
	call flashScreen		; $4f7f
	ret z			; $4f82
	call interactionIncState2		; $4f83
	jp fadeoutToWhite		; $4f86

@substate2:
	ld a,(wPaletteThread_mode)		; $4f89
	or a			; $4f8c
	ret nz			; $4f8d

	push de			; $4f8e

	; Load ambi's palace room
	ld bc,$0116		; $4f8f
	call disableLcdAndLoadRoom		; $4f92
	call resetCamera		; $4f95

	ld hl,objectData.ambiAndNayruInPostD3Cutscene		; $4f98
	call parseGivenObjectData		; $4f9b

	ld a,$02		; $4f9e
	call loadGfxRegisterStateIndex		; $4fa0
	pop de			; $4fa3
	ld a,MUS_DISASTER		; $4fa4
	call playSound		; $4fa6
	jp fadeinFromWhite		; $4fa9


; A seed satchel that slowly falls toward Link. Unused?
_interaction6b_subid07:
	call checkInteractionState		; $4fac
	jr nz,@state1	; $4faf

@state0:
	call _interaction6b_initGraphicsAndIncState		; $4fb1
	ld bc,$0000		; $4fb4
	ld hl,w1Link.yh		; $4fb7
	call objectTakePositionWithOffset		; $4fba
	ld h,d			; $4fbd
	ld l,Interaction.zh		; $4fbe
	ld (hl),$a8		; $4fc0

@state1:
	ld h,d			; $4fc2
	ld l,Interaction.zh		; $4fc3
	ldd a,(hl)		; $4fc5
	cp $f4			; $4fc6
	jp nc,interactionDelete		; $4fc8

	ld bc,$0080		; $4fcb
	ld a,c			; $4fce
	add (hl)		; $4fcf
	ldi (hl),a		; $4fd0
	ld a,b			; $4fd1
	adc (hl)		; $4fd2
	ld (hl),a		; $4fd3
	jp objectSetPriorityRelativeToLink_withTerrainEffects		; $4fd4


; Part of the cutscene where tokays steal your stuff?
_interaction6b_subid08:
	call checkInteractionState		; $4fd7
	jr nz,@state1	; $4fda

@state0:
	call getThisRoomFlags		; $4fdc
	bit 6,a			; $4fdf
	jp nz,interactionDelete		; $4fe1
	jp interactionIncState		; $4fe4

@state1:
	ld a,(wTmpcfc0.genericCutscene.cfd1)		; $4fe7
	or a			; $4fea
	jp nz,interactionDelete		; $4feb

	ld h,d			; $4fee
	ld l,Interaction.counter1		; $4fef
	ld a,(hl)		; $4ff1
	or a			; $4ff2
	jp z,playWaveSoundAtRandomIntervals		; $4ff3
	dec (hl)		; $4ff6
	ret			; $4ff7


; Shovel that Rosa gives to you in linked game
_interaction6b_subid09:
	call checkInteractionState		; $4ff8
	jr nz,@state1	; $4ffb

@state0:
	call _interaction6b_initGraphicsAndIncState		; $4ffd
	ld bc,$3848		; $5000
	call interactionSetPosition		; $5003
	jp objectSetVisible80		; $5006

@state1:
	; If [rosa.var3e] == 0, return; if $ff, delete self.
	ld a,Object.enabled		; $5009
	call objectGetRelatedObject1Var		; $500b
	ld l,Interaction.var3e		; $500e
	ld a,(hl)		; $5010
	ld c,a			; $5011
	or a			; $5012
	ret z			; $5013
	inc a			; $5014
	jp z,interactionDelete		; $5015

	; If rosa's direction is nonzero, change visibility
	ld l,Interaction.direction		; $5018
	ld a,(hl)		; $501a
	or a			; $501b
	call nz,objectSetVisible83		; $501c

	; Copy rosa's position, with x-offset [rosa.var3e]
	ld b,$00		; $501f
	jp objectTakePositionWithOffset		; $5021


; Flippers, cheval rope, and bomb treasures
_interaction6b_subid0a:
_interaction6b_subid0b:
_interaction6b_subid0c:
	call checkInteractionState		; $5024
	jr nz,@state1	; $5027

@state0:
	call getThisRoomFlags		; $5029
	bit ROOMFLAG_BIT_ITEM,a			; $502c
	jp nz,interactionDelete		; $502e
	ld e,Interaction.subid		; $5031
	ld a,(de)		; $5033
	sub $0a			; $5034
	inc e			; $5036
	ld (de),a		; $5037
	call _interaction6b_initGraphicsAndLoadScript		; $5038

@state1:
	call interactionRunScript		; $503b
	jr nc,++		; $503e
	xor a			; $5040
	ld (wDisabledObjects),a		; $5041
	ld (wMenuDisabled),a		; $5044
	jp interactionDelete		; $5047
++
	call checkInteractionState2		; $504a
	jp z,interactionAnimateAsNpc		; $504d
	ret			; $5050


; Blocks that move over when pulling lever to get flippers
_interaction6b_subid0d:
	call checkInteractionState		; $5051
	jr nz,@state1	; $5054

@state0:
	call _interaction6b_initGraphicsAndIncState		; $5056
	ld a,PALH_a3		; $5059
	call loadPaletteHeader		; $505b

	ld a,$06		; $505e
	call objectSetCollideRadius		; $5060

	ld l,Interaction.xh		; $5063
	ld a,(hl)		; $5065
	cp $c0			; $5066
	jr nz,+			; $5068
	ld l,Interaction.var03		; $506a
	ld (hl),$01		; $506c
+
	ld l,Interaction.var3d		; $506e
	ld (hl),a		; $5070

@state1:
	ld a,(w1Link.state)		; $5071
	cp $01			; $5074
	ret nz			; $5076

	ld a,(wLever1PullDistance)		; $5077
	or a			; $507a
	jr z,@updateXAndDraw	; $507b

	and $7c			; $507d
	rrca			; $507f
	rrca			; $5080
	ld b,a			; $5081
	ld e,Interaction.var03		; $5082
	ld a,(de)		; $5084
	or a			; $5085
	ld a,b			; $5086
	jr nz,@updateXAndDraw	; $5087

	; For the one on the left, invert direction
	cpl			; $5089
	inc a			; $508a
	cp $fe			; $508b
	call nc,@checkLinkSquished		; $508d

@updateXAndDraw:
	ld h,d			; $5090
	ld l,Interaction.var3d		; $5091
	add (hl)		; $5093
	ld l,Interaction.xh		; $5094
	ld (hl),a		; $5096
	jp interactionAnimateAsNpc		; $5097

;;
; @addr{509a}
@checkLinkSquished:
	push af			; $509a
	ld a,(wLinkInAir)		; $509b
	or a			; $509e
	jr nz,@ret	; $509f

	ld a,$08		; $50a1
	ld bc,$38b8		; $50a3
	ld hl,w1Link.yh		; $50a6
	call checkObjectIsCloseToPosition		; $50a9
	jr nc,@ret	; $50ac

	xor a			; $50ae
	ld (wcc50),a		; $50af
	ld a,LINK_STATE_SQUISHED		; $50b2
	ld (wLinkForceState),a		; $50b4
@ret:
	pop af			; $50b7
	ret			; $50b8


; Stone statue of Link that appears unconditionally
_interaction6b_subid0e:
	call checkInteractionState		; $50b9
	jr nz,@state1	; $50bc

@state0: ; Also called by subid $15's state 0
	ld a,(wAreaFlags)		; $50be
	and AREAFLAG_PAST			; $50c1
	ld a,PALH_c7		; $50c3
	jr nz,+			; $50c5
	dec a			; $50c7
+
	call loadPaletteHeader		; $50c8
	call _interaction6b_initGraphicsAndIncState		; $50cb
	ld bc,$080a		; $50ce
	call objectSetCollideRadii		; $50d1

	; Check for mermaid statue tile to change appearance if necessary
	call objectGetShortPosition		; $50d4
	ld c,a			; $50d7
	ld b,>wRoomLayout		; $50d8
	ld a,(bc)		; $50da
	cp $f9			; $50db
	ld a,$04		; $50dd
	jr nz,+			; $50df
	inc a			; $50e1
+
	call interactionSetAnimation		; $50e2

@state1: ; Also used as subid $15's state 1
	call interactionAnimateAsNpc		; $50e5
	ld h,d			; $50e8

	; No terrain effects
	ld l,Interaction.visible		; $50e9
	res 6,(hl)		; $50eb
	ret			; $50ed


; Switch that opens path to Nuun Highlands
_interaction6b_subid0f:
	ld e,Interaction.state		; $50ee
	ld a,(de)		; $50f0
	rst_jumpTable			; $50f1
	.dw @state0
	.dw @state1
	.dw @state2

@state0:
	ld a,$01		; $50f8
	ld (de),a		; $50fa

	call getThisRoomFlags		; $50fb
	and $40			; $50fe
	jp nz,interactionDelete		; $5100

	call getFreePartSlot		; $5103
	ret nz			; $5106
	ld (hl),PARTID_SWITCH		; $5107
	inc l			; $5109
	ld (hl),$01		; $510a
	jp objectCopyPosition		; $510c

@state1:
	ld a,(wSwitchState)		; $510f
	or a			; $5112
	ret z			; $5113

	; Switch hit; start cutscene
	ld a,$81		; $5114
	ld (wMenuDisabled),a		; $5116
	ld (wDisabledObjects),a		; $5119
	ld (wDisableScreenTransitions),a		; $511c

	call getThisRoomFlags		; $511f
	set 6,(hl)		; $5122
	call interactionIncState		; $5124
	ld hl,interaction6b_bridgeToNuunSimpleScript		; $5127
	jp interactionSetSimpleScript		; $512a

@state2:
	ld e,Interaction.counter1		; $512d
	ld a,(de)		; $512f
	or a			; $5130
	jr z,++			; $5131
	dec a			; $5133
	ld (de),a		; $5134
	ret			; $5135
++
	ret nz			; $5136
	call interactionRunSimpleScript		; $5137
	ret nc			; $513a

	xor a			; $513b
	ld (wMenuDisabled),a		; $513c
	ld (wDisabledObjects),a		; $513f
	ld (wDisableScreenTransitions),a		; $5142
	jp interactionDelete		; $5145


; Unfinished stone statue of Link in credits cutscene
_interaction6b_subid10:
	call checkInteractionState		; $5148
	jr nz,@state1	; $514b

@state0:
	ld a,PALH_c8		; $514d
	call loadPaletteHeader		; $514f
	call _interaction6b_initGraphicsAndLoadScript		; $5152
	jp objectSetVisiblec2		; $5155

@state1:
	ld e,Interaction.state2		; $5158
	ld a,(de)		; $515a
	rst_jumpTable			; $515b
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4
	.dw @substate5
	.dw @substate6
	.dw @substate7

@substate0:
	call interactionRunScript		; $516c
	ld a,(wTmpcfc0.genericCutscene.state)		; $516f
	cp $02			; $5172
	ret nz			; $5174
	call interactionIncState2		; $5175
	ld l,Interaction.counter1		; $5178
	ld (hl),$20		; $517a
	ret			; $517c

@substate1:
	call interactionDecCounter1		; $517d
	jr nz,++		; $5180
	ld a,$03		; $5182
	ld (wTmpcfc0.genericCutscene.state),a		; $5184
	jp interactionIncState2		; $5187
++
	ld a,(hl)		; $518a
	and $07			; $518b
	ret nz			; $518d
	ld l,Interaction.zh		; $518e
	dec (hl)		; $5190
	ret			; $5191

@substate2:
	call interactionRunScript		; $5192
	ret nc			; $5195
	jp interactionIncState2		; $5196

@substate3:
	call interactionAnimateBasedOnSpeed		; $5199
	call objectApplySpeed		; $519c
	ld a,(wTmpcfc0.genericCutscene.state)		; $519f
	cp $06			; $51a2
	ret nz			; $51a4
	call interactionIncState2		; $51a5
	ld bc,$4084		; $51a8
	jp interactionSetPosition		; $51ab

@substate4:
	ld a,(wTmpcfc0.genericCutscene.state)		; $51ae
	cp $07			; $51b1
	ret nz			; $51b3
	jp interactionIncState2		; $51b4

@substate5:
	ld c,$01		; $51b7
	call objectUpdateSpeedZ_paramC		; $51b9
	ret nz			; $51bc

	call interactionIncState2		; $51bd
	ld l,Interaction.counter1		; $51c0
	ld (hl),30		; $51c2
	call objectSetVisible82		; $51c4
	ld a,$05		; $51c7
	jp interactionSetAnimation		; $51c9

@substate6:
	call interactionDecCounter1		; $51cc
	jr nz,++		; $51cf
	xor a			; $51d1
	ld (wGfxRegs1.SCY),a		; $51d2
	jp interactionIncState2		; $51d5
++
	ld a,(hl)		; $51d8
	and $01			; $51d9
	jr nz,+			; $51db
	ld a,$ff		; $51dd
+
	ld (wGfxRegs1.SCY),a		; $51df

@substate7:
	ret			; $51e2


; Triggers cutscene after beating Jabu-Jabu
_interaction6b_subid11:
	ld a,(wEssencesObtained)		; $51e3
	bit 6,a			; $51e6
	jr z,@delete	; $51e8

	call getThisRoomFlags		; $51ea
	and $40			; $51ed
	jr nz,@delete	; $51ef

	ld a,$01		; $51f1
	ld (wDisabledObjects),a		; $51f3
	ld (wMenuDisabled),a		; $51f6
	ld a,CUTSCENE_BLACK_TOWER_COMPLETE		; $51f9
	ld (wCutsceneTrigger),a		; $51fb
@delete:
	jp interactionDelete		; $51fe


; Goron bomb statue (left/right)
_interaction6b_subid13:
_interaction6b_subid14:
	call checkInteractionState		; $5201
	jr nz,@state1	; $5204

@state0:
	call _interaction6b_initGraphicsAndIncState		; $5206

	; Make this position solid
	call objectGetShortPosition		; $5209
	ld c,a			; $520c
	ld b,>wRoomLayout		; $520d
	ld a,$00		; $520f
	ld (bc),a		; $5211
	ld b,>wRoomCollisions		; $5212
	ld a,$0f		; $5214
	ld (bc),a		; $5216
@state1:
	jp interactionPushLinkAwayAndUpdateDrawPriority		; $5217


; Stone statue of Link, as seen in-game
_interaction6b_subid15:
	call checkInteractionState		; $521a
	jp nz,_interaction6b_subid0e@state1		; $521d

@state0:
	ld a,GLOBALFLAG_FINISHEDGAME		; $5220
	call checkGlobalFlag		; $5222
	jp z,interactionDelete		; $5225
	call objectGetShortPosition		; $5228
	ld h,>wRoomCollisions		; $522b
	ld l,a			; $522d
	ld (hl),$0f		; $522e
	jp _interaction6b_subid0e@state0		; $5230


; A flame that appears for [counter1] frames.
_interaction6b_subid16:
	call checkInteractionState		; $5233
	jr nz,@state1	; $5236

@state0:
	call _interaction6b_initGraphicsAndIncState		; $5238
	call objectSetVisible81		; $523b
	ld a,SND_LIGHTTORCH		; $523e
	jp playSound		; $5240

@state1:
	call interactionDecCounter1		; $5243
	jp z,interactionDelete		; $5246
	jp interactionAnimate		; $5249


;;
; @addr{524c}
_interaction6b_initGraphicsAndIncState:
	call interactionInitGraphics		; $524c
	jp interactionIncState		; $524f

;;
; @addr{5252}
_interaction6b_initGraphicsAndLoadScript:
	call interactionInitGraphics		; $5252

;;
; @addr{5255}
_interaction6b_loadScript:
	ld e,Interaction.subid		; $5255
	ld a,(de)		; $5257
	ld hl,_interaction6b_scriptTable		; $5258
	rst_addDoubleIndex			; $525b
	ldi a,(hl)		; $525c
	ld h,(hl)		; $525d
	ld l,a			; $525e
	call interactionSetScript		; $525f
	jp interactionIncState		; $5262

;;
; @param[out]	zflag	nz if Link pressed up at screen edge
; @addr{5265}
_interaction6b_checkLinkPressedUpAtScreenEdge:
	ld a,(wScrollMode)		; $5265
	cp $01			; $5268
	jr nz,+			; $526a

	ld hl,w1Link.yh		; $526c
	ld a,(hl)		; $526f
	cp $07			; $5270
	jr c,++			; $5272
+
	xor a			; $5274
	ret			; $5275
++
	ld a,(wKeysPressed)		; $5276
	and BTN_UP			; $5279
	ret			; $527b

_interaction6b_scriptTable:
	.dw interaction6b_stubScript
	.dw interaction6b_stubScript
	.dw interaction6b_subid02Script
	.dw interaction6b_stubScript
	.dw interaction6b_subid04Script
	.dw interaction6b_subid05Script
	.dw interaction6b_stubScript
	.dw interaction6b_stubScript
	.dw interaction6b_stubScript
	.dw interaction6b_stubScript
	.dw interaction6b_subid0aScript
	.dw interaction6b_subid0aScript
	.dw interaction6b_subid0aScript
	.dw interaction6b_stubScript
	.dw interaction6b_stubScript
	.dw interaction6b_stubScript
	.dw interaction6b_subid10Script


; ==============================================================================
; INTERACID_FAIRY_HIDING_MINIGAME
; ==============================================================================
interactionCode6c:
	ld e,Interaction.subid		; $529e
	ld a,(de)		; $52a0
	rst_jumpTable			; $52a1
	.dw _fairyHidingMinigame_subid00
	.dw _fairyHidingMinigame_subid01
	.dw _fairyHidingMinigame_subid02


; Begins fairy-hiding minigame
_fairyHidingMinigame_subid00:
	ld e,Interaction.state		; $52a8
	ld a,(de)		; $52aa
	rst_jumpTable			; $52ab
	.dw @state0
	.dw @state1
	.dw @state2

@state0:
	; Delete self if game shouldn't happen right now
	ld a,TREASURE_ESSENCE		; $52b2
	call checkTreasureObtained		; $52b4
	jp nc,interactionDelete		; $52b7

	ld a,GLOBALFLAG_WON_FAIRY_HIDING_GAME		; $52ba
	call checkGlobalFlag		; $52bc
	jp nz,interactionDelete		; $52bf

	ld hl,wTmpcfc0.fairyHideAndSeek.active		; $52c2
	ldi a,(hl)		; $52c5
	or a			; $52c6
	jp z,interactionIncState		; $52c7

	; Minigame already started; spawn in the fairies Link's found.
	ld a,(hl)		; $52ca
	sub $07			; $52cb
	jr nz,@spawn3Fairies	; $52cd

	; Minigame just starting
	ld a,CUTSCENE_FAIRIES_HIDE		; $52cf
	ld (wCutsceneTrigger),a		; $52d1
	ld a,$80		; $52d4
	ld (wMenuDisabled),a		; $52d6
	ld a,DISABLE_COMPANION | DISABLE_LINK		; $52d9
	ld (wDisabledObjects),a		; $52db
	xor a			; $52de
	ld (w1Link.direction),a		; $52df

@spawn3Fairies:
	jp _fairyHidingMinigame_spawn3FairiesAndDelete		; $52e2

@state1:
	call _fairyHidingMinigame_checkBeginCutscene		; $52e5
	ret nc			; $52e8
	ld a,(wScreenTransitionDirection)		; $52e9
	ld (w1Link.direction),a		; $52ec
	ld a,$01		; $52ef
	ld (wTmpcfc0.fairyHideAndSeek.active),a		; $52f1
	ld hl,fairyHidingMinigame_subid00Script		; $52f4
	jp interactionSetScript		; $52f7

@state2:
	call interactionRunScript		; $52fa
	ret nc			; $52fd
	ld a,CUTSCENE_FAIRIES_HIDE		; $52fe
	ld (wCutsceneTrigger),a		; $5300
	jp interactionDelete		; $5303


; Hiding spot for fairy
_fairyHidingMinigame_subid01:
	ld e,Interaction.state		; $5306
	ld a,(de)		; $5308
	rst_jumpTable			; $5309
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3

@state0:
	call _fairyHidingMinigame_checkMinigameActive		; $5312
	jp nc,interactionDelete		; $5315

	; [var38] = original tile index
	call objectGetTileAtPosition		; $5318
	ld e,Interaction.var38		; $531b
	ld (de),a		; $531d

	ld e,l			; $531e
	ld hl,@table		; $531f
	call lookupKey		; $5322
	ld e,Interaction.var03		; $5325
	ld (de),a		; $5327

	; Delete if already found this fairy
	sub $03			; $5328
	ld hl,wTmpcfc0.fairyHideAndSeek.foundFairiesBitset		; $532a
	call checkFlag		; $532d
	jp nz,interactionDelete		; $5330

	xor a			; $5333
	ld (wTmpcfc0.fairyHideAndSeek.cfd2),a		; $5334
	ld e,Interaction.counter1		; $5337
	ld a,$0c		; $5339
	ld (de),a		; $533b
	jp interactionIncState		; $533c


; b0: tile position (lookup key)
; b1: value for var03 of fairy to spawn when found (subid is $00)
@table:
	.db $25 $03
	.db $54 $04
	.db $32 $05
	.db $00

@state1:
	; Check if tile changed
	call objectGetTileAtPosition		; $5346
	ld b,a			; $5349
	ld e,Interaction.var38		; $534a
	ld a,(de)		; $534c
	cp b			; $534d
	ret z			; $534e

	call interactionDecCounter1		; $534f
	ret nz			; $5352
	call _fairyHidingMinigame_checkBeginCutscene		; $5353
	ret nc			; $5356
	ld a,$01		; $5357
	ld (wDisableScreenTransitions),a		; $5359

; Tile changed; fairy is revealed
@state2:
	call getFreeInteractionSlot		; $535c
	ret nz			; $535f
	ld (hl),INTERACID_FOREST_FAIRY		; $5360
	ld l,Interaction.var03		; $5362
	ld e,l			; $5364
	ld a,(de)		; $5365
	ld (hl),a		; $5366
	call objectCreatePuff		; $5367
	call interactionIncState		; $536a
	ld hl,fairyHidingMinigame_subid01Script		; $536d
	jp interactionSetScript		; $5370

@state3:
	call interactionRunScript		; $5373
	ret nc			; $5376

	ld e,Interaction.var03		; $5377
	ld a,(de)		; $5379
	sub $03			; $537a
	ld hl,wTmpcfc0.fairyHideAndSeek.foundFairiesBitset		; $537c
	call setFlag		; $537f

	; If found all fairies, warp out
	ld a,(wTmpcfc0.fairyHideAndSeek.foundFairiesBitset)		; $5382
	cp $07			; $5385
	jr z,@warpOut	; $5387

	xor a			; $5389
	ld (wMenuDisabled),a		; $538a
	ld (wDisabledObjects),a		; $538d
	ld (wDisableScreenTransitions),a		; $5390
	jr @delete		; $5393

@warpOut:
	ld hl,@warpDestination		; $5395
	call setWarpDestVariables		; $5398
@delete:
	jp interactionDelete		; $539b

@warpDestination:
	.db $80 $82 $00 $64 $03


; Checks for Link leaving the hide-and-seek area
_fairyHidingMinigame_subid02:
	ld e,Interaction.state		; $53a3
	ld a,(de)		; $53a5
	or a			; $53a6
	jr z,@state0	; $53a7

@state1:
	call interactionRunScript		; $53a9
	ret nc			; $53ac

	; Clear hide-and-seek-related variables
	ld hl,wTmpcfc0.fairyHideAndSeek.active		; $53ad
	ld b,$10		; $53b0
	call clearMemory		; $53b2
	jp interactionDelete		; $53b5

@state0:
	call _fairyHidingMinigame_checkMinigameActive		; $53b8
	jp nc,interactionDelete		; $53bb
	call interactionIncState		; $53be
	ld hl,fairyHidingMinigame_subid02Script		; $53c1
	jp interactionSetScript		; $53c4

;;
; Spawns the 3 fairies; they should delete themselves if they're not found yet?
; @addr{53c7}
_fairyHidingMinigame_spawn3FairiesAndDelete:
	ld b,$03		; $53c7

@spawnFairy:
	call getFreeInteractionSlot		; $53c9
	ret nz			; $53cc
	ld (hl),INTERACID_FOREST_FAIRY		; $53cd
	inc l			; $53cf
	inc (hl)   ; [subid] = $01
	inc l			; $53d1
	dec b			; $53d2
	ld (hl),b  ; [var03] = 0,1,2
	jr nz,@spawnFairy	; $53d4
	jp interactionDelete		; $53d6

;;
; @param[out]	cflag	c if Link is vulnerable (ready to begin cutscene?)
; @addr{53d9}
_fairyHidingMinigame_checkBeginCutscene:
	call checkLinkVulnerable		; $53d9
	ret nc			; $53dc

	ld a,$80		; $53dd
	ld (wMenuDisabled),a		; $53df

	ld a,DISABLE_COMPANION | DISABLE_LINK		; $53e2
	ld (wDisabledObjects),a		; $53e4

	call dropLinkHeldItem		; $53e7
	call clearAllParentItems		; $53ea
	call interactionIncState		; $53ed
	scf			; $53f0
	ret			; $53f1

;;
; @param[out]	cflag	c if minigame is active
; @addr{53f2}
_fairyHidingMinigame_checkMinigameActive:
	ld a,GLOBALFLAG_WON_FAIRY_HIDING_GAME		; $53f2
	call checkGlobalFlag		; $53f4
	ret nz			; $53f7
	ld a,(wTmpcfc0.fairyHideAndSeek.active)		; $53f8
	rrca			; $53fb
	ret			; $53fc


; ==============================================================================
; INTERACID_POSSESSED_NAYRU
; ==============================================================================
interactionCode6d:
	ld e,Interaction.subid		; $53fd
	ld a,(de)		; $53ff
	ld e,Interaction.state		; $5400
	rst_jumpTable			; $5402
	.dw _possessedNayru_subid00
	.dw _possessedNayru_ghost
	.dw _possessedNayru_ghost


_possessedNayru_subid00:
	ld a,(de)		; $5409
	rst_jumpTable			; $540a
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3

@state0:
	ld a,GLOBALFLAG_BEAT_POSSESSED_NAYRU		; $5413
	call checkGlobalFlag		; $5415
	jp nz,interactionDelete		; $5418

	ld a,PALH_85		; $541b
	call loadPaletteHeader		; $541d

	ld a,GLOBALFLAG_BEGAN_POSSESSED_NAYRU_FIGHT		; $5420
	call checkGlobalFlag		; $5422
	jr nz,@state2	; $5425

	; Spawn "ghost" veran
	call getFreeInteractionSlot		; $5427
	ret nz			; $542a
	ld (hl),INTERACID_POSSESSED_NAYRU		; $542b
	inc l			; $542d
	ld (hl),$02		; $542e
	ld l,Interaction.relatedObj1		; $5430
	ld (hl),Interaction.start		; $5432
	inc l			; $5434
	ld (hl),d		; $5435

	call objectCopyPosition		; $5436
	call interactionInitGraphics		; $5439

	ld a,LINK_STATE_FORCE_MOVEMENT		; $543c
	ld (wLinkForceState),a		; $543e
	ld a,$0e		; $5441
	ld (wLinkStateParameter),a		; $5443

	; Set Link's direction, angle
	ld hl,w1Link.direction		; $5446
	ld a,(wScreenTransitionDirection)		; $5449
	ldi (hl),a		; $544c
	swap a			; $544d
	rrca			; $544f
	ld (hl),a		; $5450

	ld a,$01		; $5451
	ld (wDisabledObjects),a		; $5453
	ld (wMenuDisabled),a		; $5456
	call interactionIncState		; $5459
	call objectSetVisible82		; $545c
	ld hl,possessedNayru_beginFightScript		; $545f
	jp interactionSetScript		; $5462

@state1:
	call interactionRunScript		; $5465
	ret nc			; $5468
	call interactionIncState		; $5469

@state2:
	call getFreeEnemySlot		; $546c
	ret nz			; $546f
	ld (hl),ENEMYID_VERAN_POSSESSION_BOSS		; $5470
	call objectCopyPosition		; $5472
	ld h,d			; $5475
	ld l,Interaction.state		; $5476
	ld (hl),$03		; $5478
	ret			; $547a

@state3:
	ld a,GLOBALFLAG_BEGAN_POSSESSED_NAYRU_FIGHT		; $547b
	call setGlobalFlag		; $547d
	xor a			; $5480
	ld (wDisabledObjects),a		; $5481
	ld (wMenuDisabled),a		; $5484
	inc a			; $5487
	ld (wLoadedTreeGfxIndex),a		; $5488
	jp interactionDelete		; $548b


_possessedNayru_ghost:
	ld a,(de)		; $548e
	rst_jumpTable			; $548f
	.dw @state0
	.dw @state1
	.dw @state2

@state0:
	call interactionInitGraphics		; $5496
	call interactionIncState		; $5499
	ld l,Interaction.zh		; $549c
	ld (hl),-$04		; $549e
	ret			; $54a0

@state1:
	ld a,Object.var37		; $54a1
	call objectGetRelatedObject1Var		; $54a3
	ld a,(hl)		; $54a6
	or a			; $54a7
	ret z			; $54a8

	inc (hl)		; $54a9
	call interactionIncState		; $54aa
	ld l,Interaction.speed		; $54ad
	ld (hl),SPEED_80		; $54af
	call objectSetVisible81		; $54b1
	ld hl,possessedNayru_veranGhostScript		; $54b4
	jp interactionSetScript		; $54b7

@state2:
	call interactionRunScript		; $54ba
	jp nc,interactionAnimate		; $54bd

	ld a,Object.var37		; $54c0
	call objectGetRelatedObject1Var		; $54c2
	ld (hl),$00		; $54c5
	jp interactionDelete		; $54c7


; ==============================================================================
; INTERACID_NAYRU_SAVED_CUTSCENE
; ==============================================================================
interactionCode6e:
	ld e,Interaction.subid		; $54ca
	ld a,(de)		; $54cc
	ld e,Interaction.state		; $54cd
	rst_jumpTable			; $54cf
	.dw _interaction6e_subid00
	.dw _interaction6e_subid01
	.dw _interaction6e_subid02
	.dw _interaction6e_subid03
	.dw _interaction6e_subid04


; Nayru waking up after being freed from possession
_interaction6e_subid00:
	ld a,(de)		; $54da
	rst_jumpTable			; $54db
	.dw @state0
	.dw @state1
	.dw @state2

@state0:
	call interactionInitGraphics		; $54e2
	call interactionIncState		; $54e5

	ld l,Interaction.yh		; $54e8
	ld (hl),$58		; $54ea
	ld l,Interaction.xh		; $54ec
	ld (hl),$78		; $54ee
	ld l,Interaction.speed		; $54f0
	ld (hl),SPEED_40		; $54f2

	ld l,Interaction.oamFlagsBackup		; $54f4
	ld a,$01		; $54f6
	ldi (hl),a		; $54f8
	ld (hl),a		; $54f9
	ld (wLoadedTreeGfxIndex),a		; $54fa

	ld hl,w1Link.direction		; $54fd
	ld (hl),DIR_UP		; $5500
	ld l,<w1Link.yh		; $5502
	ld (hl),$64		; $5504
	ld l,<w1Link.xh		; $5506
	ld (hl),$78		; $5508

	ld hl,wTmpcfc0.genericCutscene.cfd0		; $550a
	ld b,$10		; $550d
	call clearMemory		; $550f
	call setCameraFocusedObjectToLink		; $5512
	call resetCamera		; $5515
	ldh a,(<hActiveObject)	; $5518
	ld d,a			; $551a
	call fadeinFromWhite		; $551b
	ld a,$0a		; $551e
	call interactionSetAnimation		; $5520
	call objectSetVisible82		; $5523
	ld hl,interaction6e_subid00Script		; $5526
	jp interactionSetScript		; $5529

@state1:
	call interactionRunScript		; $552c
	jp nc,interactionAnimate		; $552f
	call interactionIncState		; $5532
	ld a,$04		; $5535
	jp fadeoutToWhiteWithDelay		; $5537

@state2:
	ld a,(wPaletteThread_mode)		; $553a
	or a			; $553d
	ret nz			; $553e
	ld a,GLOBALFLAG_BEAT_POSSESSED_NAYRU		; $553f
	call setGlobalFlag		; $5541
	ld a,CUTSCENE_NAYRU_WARP_TO_MAKU_TREE		; $5544
	ld (wCutsceneTrigger),a		; $5546
	jp interactionDelete		; $5549


; Queen Ambi
_interaction6e_subid01:
	ld a,(de)		; $554c
	rst_jumpTable			; $554d
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3
	.dw @state4

@state0:
	call interactionInitGraphics		; $5558
	call interactionIncState		; $555b
	ld l,Interaction.speed		; $555e
	ld (hl),SPEED_100		; $5560
	ld l,Interaction.oamFlagsBackup		; $5562
	ld a,$01		; $5564
	ldi (hl),a		; $5566
	ld (hl),a		; $5567
	call objectSetVisiblec2		; $5568
	ld hl,interaction6e_subid01Script_part1		; $556b
	jp interactionSetScript		; $556e

@state1:
	ld c,$30		; $5571
	call objectUpdateSpeedZ_paramC		; $5573
	ret nz			; $5576

	call interactionRunScript		; $5577
	jr nc,@animate		; $557a

	call interactionIncState		; $557c
	ld l,Interaction.counter1		; $557f
	ld (hl),244		; $5581

	; Use "direction" variable temporarily as "animation"
	ld l,Interaction.direction		; $5583
	ld (hl),$05		; $5585
@animate
	jp interactionAnimate		; $5587


; Veran circling Ambi (she's turning left and right)
@state2:
	call interactionDecCounter1		; $558a
	jr z,++			; $558d

	ld a,(hl)		; $558f
	cp $c1			; $5590
	jr nc,@animate		; $5592
	and $1f			; $5594
	ret nz			; $5596

	ld l,Interaction.direction		; $5597
	ld a,(hl)		; $5599
	xor $02			; $559a
	ld (hl),a		; $559c
	jr @setAnimation		; $559d
++
	ld l,e			; $559f
	inc (hl)		; $55a0
	ld a,$06		; $55a1

@setAnimation:
	jp interactionSetAnimation		; $55a3


; Veran in process of possessing Ambi
@state3:
	ld a,(wTmpcfc0.genericCutscene.cfd0)		; $55a6
	cp $07			; $55a9
	jr z,++			; $55ab

	; Shake X position
	ld a,(wFrameCounter)		; $55ad
	rrca			; $55b0
	ret c			; $55b1
	ld e,Interaction.xh		; $55b2
	ld a,(de)		; $55b4
	inc a			; $55b5
	and $01			; $55b6
	add $78			; $55b8
	ld (de),a		; $55ba
	ret			; $55bb
++
	call interactionIncState		; $55bc
	ld l,Interaction.xh		; $55bf
	ld (hl),$78		; $55c1
	ld l,Interaction.oamFlags		; $55c3
	ld a,$06		; $55c5
	ldd (hl),a		; $55c7
	ld (hl),a		; $55c8
	ld hl,interaction6e_subid01Script_part2		; $55c9
	call interactionSetScript		; $55cc

	ld a,SND_LIGHTNING		; $55cf
	call playSound		; $55d1
	ld a,MUS_DISASTER		; $55d4
	call playSound		; $55d6
	ld a,$04		; $55d9
	jp fadeinFromWhiteWithDelay		; $55db


; Now finished being possessed
@state4:
	ld a,(wPaletteThread_mode)		; $55de
	or a			; $55e1
	jr nz,++		; $55e2
	ld c,$30		; $55e4
	call objectUpdateSpeedZ_paramC		; $55e6
	ret nz			; $55e9
	call interactionRunScript		; $55ea
++
	jp interactionAnimate		; $55ed


; Ghost Veran
_interaction6e_subid02:
	ld a,(de)		; $55f0
	rst_jumpTable			; $55f1
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3

@state0:
	call interactionInitGraphics		; $55fa
	call interactionIncState		; $55fd

	ld l,Interaction.speed		; $5600
	ld (hl),SPEED_200		; $5602

	ld l,Interaction.angle		; $5604
	ld (hl),$0e		; $5606

	ld l,Interaction.counter1		; $5608
	ld (hl),$48		; $560a

	ld bc,TX_560c		; $560c
	call showText		; $560f

	ld a,SNDCTRL_STOPMUSIC		; $5612
	call playSound		; $5614

	jp objectSetVisible81		; $5617


; Starting to move toward Ambi
@state1:
	ld e,Interaction.counter1		; $561a
	ld a,(de)		; $561c
	cp $48			; $561d
	ld a,SND_BEAM		; $561f
	call z,playSound		; $5621
	call interactionDecCounter1		; $5624
	jr nz,@applySpeedAndAnimate	; $5627

	ld (hl),$ac		; $5629

	ld l,Interaction.state		; $562b
	inc (hl)		; $562d
	ld l,Interaction.angle		; $562e
	ld (hl),$16		; $5630

	; Link moves up, while facing down
	ld hl,w1Link.direction		; $5632
	ld (hl),DIR_DOWN		; $5635
	inc l			; $5637
	ld (hl),ANGLE_UP		; $5638
	ld a,LINK_STATE_FORCE_MOVEMENT		; $563a
	ld (wLinkForceState),a		; $563c
	ld a,$04		; $563f
	ld (wLinkStateParameter),a		; $5641

	ld a,SND_CIRCLING		; $5644
	call playSound		; $5646


; Circling around Ambi
@state2:
	call interactionDecCounter1		; $5649
	jr z,@beginPossessingAmbi	; $564c

	ld a,(hl)		; $564e
	push af			; $564f
	cp $56			; $5650
	ld a,SND_CIRCLING		; $5652
	call z,playSound		; $5654

	pop af			; $5657
	rrca			; $5658
	ld e,Interaction.angle		; $5659
	jr nc,++		; $565b
	ld a,(de)		; $565d
	dec a			; $565e
	and $1f			; $565f
	ld (de),a		; $5661
++
	ld a,$10		; $5662
	ld bc,$7e78		; $5664
	call objectSetPositionInCircleArc		; $5667
	jp interactionAnimate		; $566a

@beginPossessingAmbi:
	ld (hl),$50		; $566d

	ld l,e			; $566f
	inc (hl) ; [state]++

	ld l,Interaction.speed		; $5671
	ld (hl),SPEED_20		; $5673
	ld l,Interaction.angle		; $5675
	ld (hl),ANGLE_DOWN		; $5677

	ld a,SND_BOSS_DAMAGE		; $5679
	call playSound		; $567b


; Moving into Ambi
@state3:
	call interactionDecCounter1		; $567e
	jr nz,++		; $5681
	ld a,$07		; $5683
	ld (wTmpcfc0.genericCutscene.cfd0),a		; $5685
	ld a,$04		; $5688
	jp interactionDelete		; $568a
++
	ld l,Interaction.visible		; $568d
	ld a,(hl)		; $568f
	xor $80			; $5690
	ld (hl),a		; $5692

@applySpeedAndAnimate:
	call objectApplySpeed		; $5693
	jp interactionAnimate		; $5696


; Ralph
_interaction6e_subid03:
	ld a,(de)		; $5699
	or a			; $569a
	jr z,_interaction6e_initRalph	; $569b

_interaction6e_runScriptAndAnimate:
	call interactionRunScript		; $569d
	jp interactionAnimate		; $56a0

_interaction6e_initRalph:
	call interactionInitGraphics		; $56a3
	call interactionIncState		; $56a6
	ld l,Interaction.speed		; $56a9
	ld (hl),SPEED_200		; $56ab
	call objectSetVisible82		; $56ad
	ld hl,interaction6e_subid03Script		; $56b0
	jp interactionSetScript		; $56b3


; Guards that run into the room
_interaction6e_subid04:
	ld a,(de)		; $56b6
	or a			; $56b7
	jr nz,_interaction6e_runScriptAndAnimate	; $56b8

	call interactionInitGraphics		; $56ba
	call interactionIncState		; $56bd

	ld l,Interaction.speed		; $56c0
	ld (hl),SPEED_180		; $56c2

	ld l,Interaction.yh		; $56c4
	ld (hl),$b0		; $56c6
	ld l,Interaction.xh		; $56c8
	ld (hl),$78		; $56ca
	call objectSetVisible82		; $56cc

	ld e,Interaction.var03		; $56cf
	ld a,(de)		; $56d1
	ld hl,@scriptTable		; $56d2
	rst_addDoubleIndex			; $56d5
	ldi a,(hl)		; $56d6
	ld h,(hl)		; $56d7
	ld l,a			; $56d8
	jp interactionSetScript		; $56d9

@scriptTable:
	.dw interaction6e_guard0Script
	.dw interaction6e_guard1Script
	.dw interaction6e_guard2Script
	.dw interaction6e_guard3Script
	.dw interaction6e_guard4Script
	.dw interaction6e_guard5Script


; ==============================================================================
; INTERACID_WILD_TOKAY_CONTROLLER
;
; Variables:
;   var03: Set to $ff when the game is lost?
;   var38: ?
;   var39: ?
;   var3b: ?
;   var3e/3f: Link's B/A button items, saved
; ==============================================================================
interactionCode70:
	ld e,Interaction.state		; $56e8
	ld a,(de)		; $56ea
	rst_jumpTable			; $56eb
	.dw @state0
	.dw @state1

@state0:
	xor a			; $56f0
	ld hl,wTmpcfc0.wildTokay.cfde		; $56f1
	ldi (hl),a		; $56f4
	ld (hl),a		; $56f5
	call interactionIncState		; $56f6
	ld a,(wWildTokayGameLevel)		; $56f9
	ld b,a			; $56fc
	ld a,(wTmpcfc0.wildTokay.inPresent)		; $56fd
	or a			; $5700
	jr z,+			; $5701
	ld b,$02		; $5703
+
	ld a,b			; $5705
	ld (wTmpcfc0.wildTokay.cfdc),a		; $5706
	ld bc,@var3bValues		; $5709
	call addAToBc		; $570c
	ld a,(bc)		; $570f
	ld e,Interaction.var3b		; $5710
	ld (de),a		; $5712
	jp @getRandomVar39Value		; $5713

@var3bValues:
	.db $05 $05 $05 $06 $07

@state1:
	ld e,Interaction.state2		; $571b
	ld a,(de)		; $571d
	rst_jumpTable			; $571e
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4
	.dw @substate5
	.dw @substate6

@substate0:
	ld a,(wPaletteThread_mode)		; $572d
	or a			; $5730
	ret nz			; $5731

	; Save Link's equipped items
	ld hl,wInventoryB		; $5732
	ld e,Interaction.var3e		; $5735
	ldi a,(hl)		; $5737
	ld (de),a		; $5738
	ldd a,(hl)		; $5739
	inc e			; $573a
	ld (de),a		; $573b

	ld (hl),ITEMID_NONE		; $573c
	inc l			; $573e
	ld (hl),ITEMID_BRACELET		; $573f

	; Replace tiles to start game
	ld b,$06		; $5741
	ld hl,@tilesToReplaceOnStart		; $5743
@@nextTile:
	ldi a,(hl)		; $5746
	ld c,(hl)		; $5747
	inc hl			; $5748
	push bc			; $5749
	push hl			; $574a
	call setTile		; $574b
	pop hl			; $574e
	pop bc			; $574f
	dec b			; $5750
	jr nz,@@nextTile	; $5751

	call interactionIncState2		; $5753
	ld l,Interaction.counter1		; $5756
	ld (hl),30		; $5758

	ld hl,w1Link.yh		; $575a
	ld (hl),$48		; $575d
	ld l,<w1Link.xh		; $575f
	ld (hl),$50		; $5761
	xor a			; $5763
	ld l,<w1Link.direction		; $5764
	ld (hl),a		; $5766

	dec a			; $5767
	ld (wStatusBarNeedsRefresh),a		; $5768
	ret			; $576b

; b0: new tile value
; b1: tile position
@tilesToReplaceOnStart:
	.db $ef $01
	.db $ef $08
	.db $ef $71
	.db $ef $78
	.db $7a $74
	.db $7a $75

@substate1:
	call interactionDecCounter1		; $5778
	ret nz			; $577b
	call interactionIncState2		; $577c
	ld l,Interaction.counter1		; $577f
	ld (hl),10		; $5781
	ld a,MUS_MINIGAME		; $5783
	call playSound		; $5785
	jp fadeinFromWhite		; $5788

@substate2:
	call interactionDecCounter1IfPaletteNotFading		; $578b
	ret nz			; $578e
	call interactionIncState2		; $578f
	xor a			; $5792
	ld (wDisabledObjects),a		; $5793
	ld bc,TX_0a16		; $5796
	jp showText		; $5799


; Starting the game
@substate3:
	ld a,(wTextIsActive)		; $579c
	or a			; $579f
	ret nz			; $57a0

	call interactionIncState2		; $57a1
	ld l,Interaction.counter1		; $57a4
	ld (hl),60		; $57a6
	call getFreeInteractionSlot		; $57a8
	ret nz			; $57ab
	ld (hl),INTERACID_TOKAY_MEAT		; $57ac
	ld a,SND_WHISTLE		; $57ae
	jp playSound		; $57b0


; Playing the game
@substate4:
	ld a,(wTmpcfc0.wildTokay.cfde)		; $57b3
	or a			; $57b6
	jp z,@checkSpawnNextTokay		; $57b7

	ld hl,wDisabledObjects		; $57ba
	ld (hl),DISABLE_LINK		; $57bd
	inc a			; $57bf
	jr z,@@lostGame	; $57c0

@@wonGame:
	ld a,SND_CRANEGAME		; $57c2
	call playSound		; $57c4
	jr ++			; $57c7

@@lostGame:
	dec a			; $57c9
	ld e,Interaction.var03		; $57ca
	ld (de),a		; $57cc
	ld a,SND_ERROR		; $57cd
	call playSound		; $57cf
++
	call interactionIncState2		; $57d2
	ld l,Interaction.counter1		; $57d5
	ld (hl),30		; $57d7
	ret			; $57d9


; Showing text after finishing game
@substate5:
	call interactionDecCounter1		; $57da
	ret nz			; $57dd

	ld (hl),60		; $57de
	call interactionIncState2		; $57e0

	ld a,(wTmpcfc0.wildTokay.inPresent)		; $57e3
	or a			; $57e6
	ret nz			; $57e7

	ld h,d			; $57e8
	ld l,Interaction.counter1		; $57e9
	ld (hl),20		; $57eb
	ld bc,TX_0a18		; $57ed
	ld l,Interaction.var03		; $57f0
	ld a,(hl)		; $57f2
	add c			; $57f3
	ld c,a			; $57f4
	jp showText		; $57f5

@substate6:
	ld a,(wTmpcfc0.wildTokay.inPresent)		; $57f8
	or a			; $57fb
	jr z,+			; $57fc

	call interactionDecCounter1		; $57fe
	ret nz			; $5801
	jr ++			; $5802
+
	call interactionDecCounter1IfTextNotActive		; $5804
	ret nz			; $5807
++
	; Restore inventory
	ld hl,wInventoryB		; $5808
	ld e,Interaction.var3e		; $580b
	ld a,(de)		; $580d
	inc e			; $580e
	ldi (hl),a		; $580f
	ld a,(de)		; $5810
	ld (hl),a		; $5811

	call getThisRoomFlags		; $5812
	set 6,(hl)		; $5815
	ld a,$ff		; $5817
	ld (wActiveMusic),a		; $5819

	ld hl,@@pastWarpDest		; $581c
	ld a,(wTmpcfc0.wildTokay.inPresent)		; $581f
	or a			; $5822
	jr z,+			; $5823
	ld hl,@@presentWarpDest		; $5825
+
	jp setWarpDestVariables		; $5828

@@pastWarpDest:
	.db $82 $de $00 $57 $03

@@presentWarpDest:
	.db $82 $e5 $00 $57 $03


@checkSpawnNextTokay:
	call interactionDecCounter1		; $5835
	ret nz			; $5838

	ld (hl),60		; $5839
	ld l,Interaction.var3b		; $583b
	ld a,(hl)		; $583d
	or a			; $583e
	ret z			; $583f

	ld l,Interaction.var39		; $5840
	ld a,(hl)		; $5842
	add a			; $5843
	ld bc,@data_5898		; $5844
	call addDoubleIndexToBc		; $5847

	ld l,Interaction.var38		; $584a
	ld a,(hl)		; $584c
	cp $04			; $584d
	jr z,@decVar3b	; $584f

	inc (hl)		; $5851
	call addAToBc		; $5852
	ld a,(bc)		; $5855
	or a			; $5856
	ret z			; $5857
	ld c,a			; $5858
	ld l,Interaction.var3b		; $5859
	ld a,(hl)		; $585b
	dec a			; $585c
	jr nz,@loadTokay	; $585d

	ld l,Interaction.var39		; $585f
	ld a,(hl)		; $5861
	ld b,$03		; $5862
	cp $01			; $5864
	jr z,++			; $5866
	cp $06			; $5868
	jr z,++			; $586a
	inc b			; $586c
++
	ld l,Interaction.var38		; $586d
	ld a,(hl)		; $586f
	cp b			; $5870
	jr nz,@loadTokay	; $5871

	ld hl,wTmpcfc0.wildTokay.cfdf		; $5873
	ld (hl),b		; $5876

@loadTokay:
	ld b,c			; $5877
	call getWildTokayObjectDataIndex		; $5878
	jp parseGivenObjectData		; $587b

@decVar3b:
	ld (hl),$00		; $587e
	ld l,Interaction.var3b		; $5880
	dec (hl)		; $5882

;;
; @addr{5883}
@getRandomVar39Value:
	ld hl,wTmpcfc0.wildTokay.cfdc		; $5883
	ld a,(hl)		; $5886
	swap a			; $5887
	ld hl,@table		; $5889
	rst_addAToHl			; $588c
	call getRandomNumber		; $588d
	and $0f			; $5890
	rst_addAToHl			; $5892
	ld a,(hl)		; $5893
	ld e,Interaction.var39		; $5894
	ld (de),a		; $5896
	ret			; $5897


; Each row corresponds to a value for var39; each column corresponds to a value for var38?
@data_5898:
	.db $01 $00 $00 $02
	.db $02 $00 $01 $00
	.db $02 $01 $00 $01
	.db $01 $00 $02 $02
	.db $01 $01 $02 $02
	.db $02 $02 $01 $01
	.db $02 $03 $01 $00
	.db $01 $03 $02 $02

; Each row is a set of possible values for a particular value of wTmpcfc0.wildTokay.cfdc?
@table:
	.db $00 $00 $00 $01 $01 $01 $02 $02 $02 $03 $03 $03 $04 $04 $05 $05
	.db $00 $00 $01 $01 $01 $02 $02 $02 $03 $03 $03 $04 $04 $04 $05 $06
	.db $00 $01 $01 $02 $02 $03 $03 $04 $04 $04 $05 $05 $06 $06 $06 $07
	.db $01 $02 $03 $03 $04 $04 $04 $05 $05 $05 $05 $00 $00 $06 $07 $07
	.db $03 $04 $04 $04 $05 $05 $05 $05 $05 $02 $01 $00 $06 $07 $07 $07


; ==============================================================================
; INTERACID_COMPANION_SCRIPTS
; ==============================================================================
interactionCode71:
	ld a,(wLinkDeathTrigger)		; $5908
	or a			; $590b
	jr z,++			; $590c
	xor a			; $590e
	ld (wDisabledObjects),a		; $590f
	jp interactionDelete		; $5912
++
	ld e,Interaction.subid		; $5915
	ld a,(de)		; $5917
	rst_jumpTable			; $5918
	.dw _companionScript_subid00
	.dw _companionScript_subid01
	.dw _companionScript_subid02
	.dw _companionScript_subid03
	.dw _companionScript_subid04
	.dw _companionScript_subid05
	.dw _companionScript_subid06
	.dw _companionScript_subid07
	.dw _companionScript_subid08
	.dw _companionScript_subid09
	.dw _companionScript_subid0a
	.dw _companionScript_subid0b
	.dw _companionScript_subid0c
	.dw _companionScript_subid0d


_companionScript_subid00:
	ld e,Interaction.state		; $5935
	ld a,(de)		; $5937
	rst_jumpTable			; $5938
	.dw @state0
	.dw _companionScript_subid00_state1

@state0:
	ld a,$01		; $593d
	ld (de),a		; $593f
	ld a,(wEssencesObtained)		; $5940
	bit 1,a			; $5943
	jp z,_companionScript_deleteSelf		; $5945

	ld a,(wPastRoomFlags+$79)		; $5948
	bit 6,a			; $594b
	jp z,_companionScript_deleteSelf		; $594d

	ld a,(wMooshState)		; $5950
	and $60			; $5953
	jp nz,_companionScript_deleteSelf		; $5955

	ld a,$01		; $5958
	ld (wDisableScreenTransitions),a		; $595a
	ld (wDiggingUpEnemiesForbidden),a		; $595d
	ld hl,companionScript_subid00Script		; $5960
	jp interactionSetScript		; $5963


_companionScript_subid01:
	ld e,Interaction.state		; $5966
	ld a,(de)		; $5968
	rst_jumpTable			; $5969
	.dw _companionScript_genericState0
	.dw _companionScript_restrictHigherX

_companionScript_subid02:
	ld e,Interaction.state		; $596e
	ld a,(de)		; $5970
	rst_jumpTable			; $5971
	.dw _companionScript_genericState0
	.dw _companionScript_restrictLowerY

_companionScript_subid04:
	ld e,Interaction.state		; $5976
	ld a,(de)		; $5978
	rst_jumpTable			; $5979
	.dw _companionScript_genericState0
	.dw _companionScript_restrictHigherY

_companionScript_subid05:
	ld e,Interaction.state		; $597e
	ld a,(de)		; $5980
	rst_jumpTable			; $5981
	.dw _companionScript_genericState0
	.dw _companionScript_restrictLowerX


; Delete self if game is completed; otherwise, stay in state 0 until Link mounts the
; companion.
_companionScript_genericState0:
	ld a,(wFileIsCompleted)		; $5986
	or a			; $5989
	jp nz,_companionScript_deleteSelf		; $598a
	ld a,(wLinkObjectIndex)		; $598d
	rrca			; $5990
	ret nc			; $5991

	ld a,$01		; $5992
	ld (de),a		; $5994

	ld a,(w1Companion.id)		; $5995
	sub SPECIALOBJECTID_RICKY			; $5998
	ld e,Interaction.var30		; $599a
	ld (de),a		; $599c
	add <wRickyState			; $599d
	ld l,a			; $599f
	ld h,>wRickyState		; $59a0
	bit 7,(hl)		; $59a2
	jp nz,_companionScript_deleteSelf		; $59a4
	ret			; $59a7

_companionScript_restrictHigherX:
	call _companionScript_cpXToCompanion		; $59a8
	ret c			; $59ab
	inc a			; $59ac
	jr ++		; $59ad

_companionScript_restrictLowerX:
	call _companionScript_cpXToCompanion		; $59af
	ret nc			; $59b2
	jr ++		; $59b3

_companionScript_restrictLowerY:
	call _companionScript_cpYToCompanion		; $59b5
	ret nc			; $59b8
	jr ++		; $59b9

_companionScript_restrictHigherY:
	call _companionScript_cpYToCompanion		; $59bb
	ret c			; $59be
	inc a			; $59bf
	jr ++		; $59c0

++
	ld c,a			; $59c2
	ld a,(wLinkObjectIndex)		; $59c3
	rrca			; $59c6
	ret nc			; $59c7

	ld a,c			; $59c8
	ld (hl),a		; $59c9

	ld l,SpecialObject.speed		; $59ca
	ld (hl),SPEED_0		; $59cc

	ld e,Interaction.var30		; $59ce
	ld a,(de)		; $59d0
	ld hl,_companionScript_companionBarrierText		; $59d1
	rst_addDoubleIndex			; $59d4
	ldi a,(hl)		; $59d5
	ld b,(hl)		; $59d6
	ld c,a			; $59d7
	jp showText		; $59d8

_companionScript_cpYToCompanion:
	ld e,Interaction.yh		; $59db
	ld a,(de)		; $59dd
	ld hl,w1Companion.yh		; $59de
	cp (hl)			; $59e1
	ret			; $59e2

_companionScript_cpXToCompanion:
	ld e,Interaction.xh		; $59e3
	ld a,(de)		; $59e5
	ld hl,w1Companion.xh		; $59e6
	cp (hl)			; $59e9
	ret			; $59ea

; Text to show when you try to pass the "barriers" imposed.
_companionScript_companionBarrierText:
	.dw TX_2007 ; Ricky
	.dw TX_2105 ; Dimitri
	.dw TX_2209 ; Moosh


; Companion barrier to Symmetry City, until the tuni nut is restored
_companionScript_subid0d:
	ld a,GLOBALFLAG_TUNI_NUT_PLACED		; $59f1
	call checkGlobalFlag		; $59f3
	jp nz,_companionScript_deleteSelf		; $59f6

	ld a,(wScrollMode)		; $59f9
	and (SCROLLMODE_08 | SCROLLMODE_04 | SCROLLMODE_02)	; $59fc
	ret nz			; $59fe
	ld hl,w1Companion.enabled		; $59ff
	ldi a,(hl)		; $5a02
	or a			; $5a03
	ret z			; $5a04

	ldi a,(hl)		; $5a05
	cp SPECIALOBJECTID_FIRST_COMPANION			; $5a06
	ret c			; $5a08
	cp SPECIALOBJECTID_LAST_COMPANION+1			; $5a09
	ret nc			; $5a0b

	; Check if the companion is roughly at this object's position
	ld l,SpecialObject.xh		; $5a0c
	ld e,Interaction.xh		; $5a0e
	ld a,(de)		; $5a10
	sub (hl)		; $5a11
	add $05			; $5a12
	cp $0b			; $5a14
	ret nc			; $5a16
	ld l,SpecialObject.yh		; $5a17
	ld e,Interaction.yh		; $5a19
	ld a,(de)		; $5a1b
	cp (hl)			; $5a1c
	ret c			; $5a1d

	; If so, prevent companion from moving any further up
	inc a			; $5a1e
	ld (hl),a		; $5a1f
	ld l,SpecialObject.speed		; $5a20
	ld (hl),$00		; $5a22
	ld l,SpecialObject.state		; $5a24
	ldi a,(hl)		; $5a26

	; If it's Dimitri being held, make Link drop him
	cp $02			; $5a27
	jr nz,+			; $5a29
	ld (hl),$03		; $5a2b
	call dropLinkHeldItem		; $5a2d
+
	ld a,(wAnimalCompanion)		; $5a30
	sub SPECIALOBJECTID_FIRST_COMPANION			; $5a33
	ld hl,@textIndices		; $5a35
	rst_addDoubleIndex			; $5a38
	ldi a,(hl)		; $5a39
	ld b,(hl)		; $5a3a
	ld c,a			; $5a3b
	jp showText		; $5a3c

; Text to show as the excuse why they can't go into Symmetry City
@textIndices:
	.dw TX_200a
	.dw TX_2109
	.dw TX_220a


; Ricky script when he loses his gloves
_companionScript_subid03:
	ld e,Interaction.state		; $5a45
	ld a,(de)		; $5a47
	rst_jumpTable			; $5a48
	.dw @state0
	.dw _companionScript_runScript

@state0:
	ld a,$01		; $5a4d
	ld (de),a		; $5a4f
	ld hl,wRickyState		; $5a50
	ld a,(hl)		; $5a53
	and $20			; $5a54
	jr nz,_companionScript_deleteSelf	; $5a56
	ld hl,companionScript_subid03Script		; $5a58
	jp interactionSetScript		; $5a5b


; Dimitri script where he's harrassed by tokays
_companionScript_subid07:
	ld e,Interaction.state		; $5a5e
	ld a,(de)		; $5a60
	rst_jumpTable			; $5a61
	.dw @state0
	.dw _companionScript_runScript

@state0:
	ld a,(wDimitriState)		; $5a66
	and $20			; $5a69
	jr nz,_companionScript_deleteSelf	; $5a6b
	ld a,$01		; $5a6d
	ld (de),a		; $5a6f
	ld hl,companionScript_subid07Script		; $5a70
	jp interactionSetScript		; $5a73


; Dimitri script where he leaves Link after bringing him to the mainland
_companionScript_subid06:
	ld e,Interaction.state		; $5a76
	ld a,(de)		; $5a78
	rst_jumpTable			; $5a79
	.dw @state0
	.dw _companionScript_runScript

@state0:
	; Delete self if dimitri isn't here or the event has happened already
	ld a,(wDimitriState)		; $5a7e
	and $40			; $5a81
	jr nz,_companionScript_deleteSelf	; $5a83
	ld hl,w1Companion.id		; $5a85
	ld a,(hl)		; $5a88
	cp SPECIALOBJECTID_DIMITRI			; $5a89
	jr nz,_companionScript_deleteSelf	; $5a8b

	; Return if Dimitri's still in the water
	ld l,SpecialObject.var38		; $5a8d
	ld a,(hl)		; $5a8f
	or a			; $5a90
	ret nz			; $5a91

	ld a,$01		; $5a92
	ld (de),a		; $5a94
	ld (wDisableScreenTransitions),a		; $5a95

	; Manipulate Dimitri's state to force a dismount
	ld l,SpecialObject.var03		; $5a98
	ld (hl),$02		; $5a9a
	inc l			; $5a9c
	ld (hl),$0a		; $5a9d

	ld hl,companionScript_subid06Script		; $5a9f
	jp interactionSetScript		; $5aa2

_companionScript_deleteSelf:
	jp interactionDelete		; $5aa5


; A fairy appears to tell you about the animal companion in the forest
_companionScript_subid08:
	ld e,Interaction.state		; $5aa8
	ld a,(de)		; $5aaa
	rst_jumpTable			; $5aab
	.dw @state0
	.dw @state1
	.dw _companionScript_runScript

@state0:
	; Clear $10 bytes starting at $cfd0
	ld hl,wTmpcfc0.fairyHideAndSeek.active		; $5ab2
	ld b,$10		; $5ab5
	call clearMemory		; $5ab7

	ld a,GLOBALFLAG_CAN_BUY_FLUTE		; $5aba
	call unsetGlobalFlag		; $5abc

	ld l,<wAnimalCompanion		; $5abf
	ld a,(hl)		; $5ac1
	or a			; $5ac2
	jr nz,+			; $5ac3
	ld a,SPECIALOBJECTID_MOOSH		; $5ac5
	ld (hl),a		; $5ac7
+
	sub SPECIALOBJECTID_FIRST_COMPANION			; $5ac8
	add <TX_1123			; $5aca
	ld (wTextSubstitutions),a		; $5acc

	ld a,(wScreenTransitionDirection)		; $5acf
	cp DIR_LEFT			; $5ad2
	jr nz,_companionScript_deleteSelf	; $5ad4

	ld a,GLOBALFLAG_TALKED_TO_HEAD_CARPENTER		; $5ad6
	call checkGlobalFlag		; $5ad8
	jr z,_companionScript_deleteSelf	; $5adb

	call getThisRoomFlags		; $5add
	bit 6,a			; $5ae0
	jr nz,_companionScript_deleteSelf	; $5ae2
	jp interactionIncState		; $5ae4

@state1:
	; Wait for Link to trigger the fairy
	ld a,(w1Link.xh)		; $5ae7
	cp $50			; $5aea
	ret nc			; $5aec

	ld a,$81		; $5aed
	ld (wMenuDisabled),a		; $5aef
	ld (wDisabledObjects),a		; $5af2
	call putLinkOnGround		; $5af5

	ldbc INTERACID_FOREST_FAIRY, $03		; $5af8
	call objectCreateInteraction		; $5afb
	ld l,Interaction.var03		; $5afe
	ld (hl),$0f		; $5b00
	ld hl,companionScript_subid08Script		; $5b02
	call interactionSetScript		; $5b05
	jp interactionIncState		; $5b08


; Companion script where they're found in the fairy forest
_companionScript_subid09:
	ld e,Interaction.state		; $5b0b
	ld a,(de)		; $5b0d
	rst_jumpTable			; $5b0e
	.dw @state0
	.dw _companionScript_runScript

@state0:
	ld a,$01		; $5b13
	ld (de),a		; $5b15

	xor a			; $5b16
	ld (wTmpcfc0.fairyHideAndSeek.cfd2),a		; $5b17

	; Check whether the event is applicable right now
	ld a,GLOBALFLAG_TALKED_TO_HEAD_CARPENTER		; $5b1a
	call checkGlobalFlag		; $5b1c
	jr z,_companionScript_deleteSelf	; $5b1f

	ld a,GLOBALFLAG_GOT_FLUTE		; $5b21
	call checkGlobalFlag		; $5b23
	jp nz,_companionScript_deleteSelf		; $5b26

	; Put companion index (0-2) in var39
	ld hl,wAnimalCompanion		; $5b29
	ld a,(hl)		; $5b2c
	sub SPECIALOBJECTID_FIRST_COMPANION			; $5b2d
	ld e,Interaction.var39		; $5b2f
	ld (de),a		; $5b31

	ld c,a			; $5b32
	ld hl,@animationWhenNoticingLink		; $5b33
	rst_addAToHl			; $5b36
	ld a,(hl)		; $5b37
	ld e,Interaction.var38		; $5b38
	ld (de),a		; $5b3a

	ld a,c			; $5b3b
	add a			; $5b3c
	ld hl,@data1		; $5b3d
	rst_addDoubleIndex			; $5b40
	ldi a,(hl)		; $5b41
	ld (wTextSubstitutions),a		; $5b42
	call checkIsLinkedGame		; $5b45
	jr z,+			; $5b48
	ldi a,(hl)		; $5b4a
+
	ldi a,(hl)		; $5b4b
	ld (wTextSubstitutions+1),a		; $5b4c
	ld hl,companionScript_subid09Script		; $5b4f
	jp interactionSetScript		; $5b52


; b0: first text to show
; b1: text to show after that (unlinked)
; b2: text to show after that (linked)
@data1:
	.db <TX_1133, <TX_1134, <TX_1135, $00
	.db <TX_113a, <TX_113b, <TX_113c, $00
	.db <TX_1141, <TX_1142, <TX_1143, $00

@animationWhenNoticingLink:
	.db $00 ; Ricky
	.db $1e ; Dimitri
	.db $03 ; Moosh


; Script just outside the forest, where you get the flute
_companionScript_subid0a:
	ld e,Interaction.state		; $5b64
	ld a,(de)		; $5b66
	rst_jumpTable			; $5b67
	.dw @state0
	.dw _companionScript_runScript
	.dw _companionScript_subid0a_state2
	.dw _companionScript_subid0a_state3

@state0:
	ld a,GLOBALFLAG_SAVED_COMPANION_FROM_FOREST		; $5b70
	call checkGlobalFlag		; $5b72
	jp z,_companionScript_delete		; $5b75

	ld a,GLOBALFLAG_GOT_FLUTE		; $5b78
	call checkGlobalFlag		; $5b7a
	jp nz,_companionScript_delete		; $5b7d

	ld a,$01		; $5b80
	ld (de),a ; [state] = 1
	ld (wMenuDisabled),a		; $5b83
	ld (wDisabledObjects),a		; $5b86
	ld (wTmpcfc0.fairyHideAndSeek.cfd2),a		; $5b89

	ld a,DIR_UP		; $5b8c
	ld (w1Link.direction),a		; $5b8e

	; Put companion index (0-2) in var39
	ld hl,wAnimalCompanion		; $5b91
	ld a,(hl)		; $5b94
	sub SPECIALOBJECTID_FIRST_COMPANION			; $5b95
	ld e,Interaction.var39		; $5b97
	ld (de),a		; $5b99

	; Determine text to show for this companion
	add a			; $5b9a
	ld hl,@textIndices		; $5b9b
	rst_addDoubleIndex			; $5b9e
	ldi a,(hl)		; $5b9f
	ld (wTextSubstitutions+1),a		; $5ba0
	call checkIsLinkedGame		; $5ba3
	jr z,+			; $5ba6
	ldi a,(hl)		; $5ba8
+
	ldi a,(hl)		; $5ba9
	ld (wTextSubstitutions),a		; $5baa

	; Spawn in the fairies
	ld bc,$1103		; $5bad
@nextFairy:
	push bc			; $5bb0
	ldbc INTERACID_FOREST_FAIRY, $04		; $5bb1
	call objectCreateInteraction		; $5bb4
	pop bc			; $5bb7
	ld l,Interaction.var03		; $5bb8
	ld (hl),b		; $5bba
	inc b			; $5bbb
	dec c			; $5bbc
	jr nz,@nextFairy	; $5bbd

	ld hl,companionScript_subid0aScript		; $5bbf
	jp interactionSetScript		; $5bc2


; b0: Second text to show (after giving you the flute)
; b1: First text to show (unlinked)
; b2: First text to show (linked)
@textIndices:
	.db <TX_1139, <TX_1136, <TX_1137, $00 ; Ricky
	.db <TX_1140, <TX_113d, <TX_113e, $00 ; Dimitri
	.db <TX_1147, <TX_1144, <TX_1145, $00 ; Moosh


; Script in first screen of forest, where fairy leads you to the companion
_companionScript_subid0b:
	ld e,Interaction.state		; $5bd1
	ld a,(de)		; $5bd3
	rst_jumpTable			; $5bd4
	.dw @state0
	.dw _companionScript_runScript

@state0:
	ld a,(wScreenTransitionDirection)		; $5bd9
	cp DIR_DOWN			; $5bdc
	jr nz,_companionScript_delete	; $5bde
	ld a,GLOBALFLAG_COMPANION_LOST_IN_FOREST		; $5be0
	call checkGlobalFlag		; $5be2
	jr z,_companionScript_delete	; $5be5

	ld a,GLOBALFLAG_GOT_FLUTE		; $5be7
	call checkGlobalFlag		; $5be9
	jr nz,_companionScript_delete	; $5bec

	ldbc INTERACID_FOREST_FAIRY, $03		; $5bee
	call objectCreateInteraction		; $5bf1
	ld l,Interaction.var03		; $5bf4
	ld (hl),$14		; $5bf6

	ld a,$81		; $5bf8
	ld (wMenuDisabled),a		; $5bfa
	ld (wDisabledObjects),a		; $5bfd

	xor a			; $5c00
	ld (wTmpcfc0.fairyHideAndSeek.cfd2),a		; $5c01

	ld hl,companionScript_subid0bScript		; $5c04
	call interactionSetScript		; $5c07
	jp interactionIncState		; $5c0a


; Sets bit 6 of wDimitriState so he disappears from Tokay Island
_companionScript_subid0c:
	ld a,(wDimitriState)		; $5c0d
	bit 5,a			; $5c10
	jr z,_companionScript_delete	; $5c12
	or $40			; $5c14
	ld (wDimitriState),a		; $5c16
	jr _companionScript_delete		; $5c19

;;
; @addr{5c1b}
_companionScript_subid00_state1:
	; If var3a is nonzero, make Moosh shake in fear
	ld e,Interaction.var3a		; $5c1b
	ld a,(de)		; $5c1d
	or a			; $5c1e
	jr z,_companionScript_runScript		; $5c1f

	dec a			; $5c21
	ld (de),a		; $5c22
	and $03			; $5c23
	jr nz,_companionScript_runScript		; $5c25
	ld a,(w1Companion.xh)		; $5c27
	xor $02			; $5c2a
	ld (w1Companion.xh),a		; $5c2c

_companionScript_runScript:
	call interactionRunScript		; $5c2f
	ret nc			; $5c32
	call setStatusBarNeedsRefreshBit1		; $5c33
_companionScript_delete:
	jp interactionDelete		; $5c36


; This is the part which gives Link the flute.
_companionScript_subid0a_state2:
	ld a,TREASURE_FLUTE		; $5c39
	call checkTreasureObtained		; $5c3b
	ld c,<TX_0038		; $5c3e
	jr nc,+			; $5c40
	ld c,<TX_0069		; $5c42
+
	ld e,Interaction.var39 ; Companion index
	ld a,(de)		; $5c46
	add c			; $5c47
	ld c,a			; $5c48
	ld b,>TX_0038		; $5c49
	call showText		; $5c4b

	ld a,$01		; $5c4e
	ld (wMenuDisabled),a		; $5c50
	call interactionIncState		; $5c53

	; Set wFluteIcon
	ld e,Interaction.var39		; $5c56
	ld a,(de)		; $5c58
	ld c,a			; $5c59
	inc a			; $5c5a
	ld (de),a		; $5c5b
	ld hl,wFluteIcon		; $5c5c
	ld (hl),a		; $5c5f

	; Set bit 7 of wRickyState / wDimitriState / wMooshState
	add <wCompanionStates - 1			; $5c60
	ld l,a			; $5c62
	set 7,(hl)		; $5c63

	; Give flute
	ld a,TREASURE_FLUTE		; $5c65
	call giveTreasure		; $5c67
	ld hl,wStatusBarNeedsRefresh		; $5c6a
	set 0,(hl)		; $5c6d

	; Turn this object into the flute graphic?
	ld e,Interaction.subid		; $5c6f
	xor a			; $5c71
	ld (de),a		; $5c72
	call interactionInitGraphics		; $5c73
	ld e,Interaction.subid		; $5c76
	ld a,$0a		; $5c78
	ld (de),a		; $5c7a

	; Set this object's palette
	ld e,Interaction.var39		; $5c7b
	ld a,(de)		; $5c7d
	ld c,a			; $5c7e
	and $01			; $5c7f
	add a			; $5c81
	xor c			; $5c82
	ld e,Interaction.oamFlags		; $5c83
	ld (de),a		; $5c85

	; Set this object's position
	ld hl,w1Link		; $5c86
	ld bc,$f200		; $5c89
	call objectTakePositionWithOffset		; $5c8c

	; Make Link hold it over his head
	ld hl,wLinkForceState		; $5c8f
	ld a,LINK_STATE_04		; $5c92
	ldi (hl),a		; $5c94
	ld (hl),$01 ; [wcc50] = $01
	call objectSetVisible80		; $5c97
	jp interactionRunScript		; $5c9a


_companionScript_subid0a_state3:
	call retIfTextIsActive		; $5c9d

	; ??
	ld a,(wLinkObjectIndex)		; $5ca0
	and $0f			; $5ca3
	add a			; $5ca5
	swap a			; $5ca6
	ld (wDisabledObjects),a		; $5ca8

	; Make flute disappear, wait for script to end
	call objectSetInvisible		; $5cab
	call interactionRunScript		; $5cae
	ret nc			; $5cb1

	; Clean up, delete self
	xor a			; $5cb2
	ld (wDisabledObjects),a		; $5cb3
	ld (wMenuDisabled),a		; $5cb6
	jp _companionScript_delete		; $5cb9


; ==============================================================================
; INTERACID_KING_MOBLIN_DEFEATED
; ==============================================================================
interactionCode72:
	ld e,Interaction.subid		; $5cbc
	ld a,(de)		; $5cbe
	ld e,Interaction.state		; $5cbf
	rst_jumpTable			; $5cc1
	.dw @subid0
	.dw @subid1
	.dw @subid2


; Subid 0: King moblin / "parent" for other subids
@subid0:
	ld a,(de)		; $5cc8
	or a			; $5cc9
	jr z,@subid0State0	; $5cca

@subid0State1:
	call interactionRunScript		; $5ccc
	jp nc,interactionAnimate		; $5ccf
	call getFreeInteractionSlot		; $5cd2
	ret nz			; $5cd5

	; Spawn instance of this object with subid 2
	ld (hl),INTERACID_KING_MOBLIN_DEFEATED		; $5cd6
	inc l			; $5cd8
	ld (hl),$02		; $5cd9
	ld l,Interaction.yh		; $5cdb
	ld (hl),$68		; $5cdd
	jp interactionDelete		; $5cdf

@subid0State0:
	call getThisRoomFlags		; $5ce2
	bit 6,a			; $5ce5
	jp nz,interactionDelete		; $5ce7

	ld a,GLOBALFLAG_MOBLINS_KEEP_DESTROYED		; $5cea
	call checkGlobalFlag		; $5cec
	jp z,interactionDelete		; $5cef

	call setDeathRespawnPoint		; $5cf2
	ld a,$80		; $5cf5
	ld (wDisabledObjects),a		; $5cf7
	ld (wMenuDisabled),a		; $5cfa

	call @spawnSubservientMoblin		; $5cfd
	ld (hl),$38		; $5d00
	call @spawnSubservientMoblin		; $5d02
	ld (hl),$78		; $5d05

	ld hl,$cfd0		; $5d07
	ld b,$04		; $5d0a
	call clearMemory		; $5d0c

	ld a,$02		; $5d0f
	call fadeinFromWhiteWithDelay		; $5d11
	ld hl,kingMoblinDefeated_kingScript		; $5d14

@setScriptAndInitStuff:
	call interactionSetScript		; $5d17
	call interactionInitGraphics		; $5d1a
	call interactionIncState		; $5d1d

	ld l,Interaction.speed		; $5d20
	ld (hl),SPEED_180		; $5d22
	ld l,Interaction.angle		; $5d24
	ld (hl),ANGLE_DOWN		; $5d26
	jp objectSetVisible82		; $5d28


; Spawn an instance of subid 1, the normal moblins
@spawnSubservientMoblin:
	call getFreeInteractionSlot		; $5d2b
	ret nz			; $5d2e
	ld (hl),INTERACID_KING_MOBLIN_DEFEATED		; $5d2f
	inc l			; $5d31
	inc (hl)		; $5d32
	ld l,Interaction.yh		; $5d33
	ld (hl),$68		; $5d35
	ld l,Interaction.xh		; $5d37
	ret			; $5d39


; Subid 1: Normal moblin following him
@subid1:
	ld a,(de)		; $5d3a
	or a			; $5d3b
	jr z,@subid1State0	; $5d3c

@runScriptAndAnimate:
	call interactionRunScript		; $5d3e
	jp nc,interactionAnimate		; $5d41
	jp interactionDelete		; $5d44

@subid1State0:
	ld hl,kingMoblinDefeated_helperMoblinScript		; $5d47
	jr @setScriptAndInitStuff		; $5d4a


; Subid 2: Gorons who approach after he leaves (var03 = index)
@subid2:
	ld a,(de)		; $5d4c
	or a			; $5d4d
	jr nz,@runScriptAndAnimate	; $5d4e

	call interactionInitGraphics		; $5d50
	call interactionIncState		; $5d53
	ld l,Interaction.speed		; $5d56
	ld (hl),SPEED_80		; $5d58

	; Load script
	ld e,Interaction.var03		; $5d5a
	ld a,(de)		; $5d5c
	ld hl,@scriptTable		; $5d5d
	rst_addDoubleIndex			; $5d60
	ldi a,(hl)		; $5d61
	ld h,(hl)		; $5d62
	ld l,a			; $5d63
	call interactionSetScript		; $5d64

	call objectSetVisible82		; $5d67

	; Load data from table
	ld e,Interaction.var03		; $5d6a
	ld a,(de)		; $5d6c
	add a			; $5d6d
	ld hl,@goronData		; $5d6e
	rst_addDoubleIndex			; $5d71
	ld e,Interaction.yh		; $5d72
	ldi a,(hl)		; $5d74
	ld (de),a		; $5d75
	ld e,Interaction.xh		; $5d76
	ldi a,(hl)		; $5d78
	ld (de),a		; $5d79
	ld e,Interaction.angle		; $5d7a
	ldi a,(hl)		; $5d7c
	ld (de),a		; $5d7d
	ld a,(hl)		; $5d7e
	call interactionSetAnimation		; $5d7f

	; If [var03] == 0, spawn the other gorons
	ld e,Interaction.var03		; $5d82
	ld a,(de)		; $5d84
	or a			; $5d85
	ret nz			; $5d86

	ld b,$01		; $5d87
	call @spawnGoronInstance		; $5d89
	inc b			; $5d8c
	call @spawnGoronInstance		; $5d8d
	inc b			; $5d90

@spawnGoronInstance:
	call getFreeInteractionSlot		; $5d91
	ret nz			; $5d94
	ld (hl),INTERACID_KING_MOBLIN_DEFEATED		; $5d95
	inc l			; $5d97
	ld (hl),$02		; $5d98
	inc l			; $5d9a
	ld (hl),b		; $5d9b
	ret			; $5d9c

@scriptTable:
	.dw kingMoblinDefeated_goron0
	.dw kingMoblinDefeated_goron1
	.dw kingMoblinDefeated_goron2
	.dw kingMoblinDefeated_goron3

; b0: Y
; b1: X
; b2: angle
; b3: animation
@goronData:
	.db $88 $38 $00 $04 ; $00 == [var03]
	.db $58 $a8 $18 $07 ; $01
	.db $88 $90 $00 $04 ; $02
	.db $88 $58 $00 $04 ; $03


; ==============================================================================
; INTERACID_GHINI_HARASSING_MOOSH
; ==============================================================================
interactionCode73:
	ld h,d			; $5db5
	ld l,Interaction.subid		; $5db6
	ldi a,(hl)		; $5db8
	or a			; $5db9
	jr nz,@checkState	; $5dba

	inc l			; $5dbc
	ld a,(hl)		; $5dbd
	or a			; $5dbe
	jr z,@checkState	; $5dbf

	ld a,(wScrollMode)		; $5dc1
	and $0e			; $5dc4
	ret nz			; $5dc6

@checkState:
	ld e,Interaction.state		; $5dc7
	ld a,(de)		; $5dc9
	rst_jumpTable			; $5dca
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $5dcf
	ld (de),a		; $5dd1

	; Delete self if they shouldn't be here right now
	ld a,(wEssencesObtained)		; $5dd2
	bit 1,a			; $5dd5
	jr z,@delete		; $5dd7

	ld a,(wPastRoomFlags+$79)		; $5dd9
	bit 6,a			; $5ddc
	jr z,@delete		; $5dde

	ld a,(wMooshState)		; $5de0
	and $60			; $5de3
	jr nz,@delete		; $5de5

	call interactionInitGraphics		; $5de7
	call interactionSetAlwaysUpdateBit		; $5dea
	ld l,Interaction.zh		; $5ded
	ld (hl),-2		; $5def

	; Load script
	ld e,Interaction.subid		; $5df1
	ld a,(de)		; $5df3
	ld hl,@scriptTable		; $5df4
	rst_addDoubleIndex			; $5df7
	ldi a,(hl)		; $5df8
	ld h,(hl)		; $5df9
	ld l,a			; $5dfa
	call interactionSetScript		; $5dfb
	jp objectSetVisiblec0		; $5dfe

@state1:
	call interactionAnimate		; $5e01
	ld e,Interaction.speed		; $5e04
	ld a,(de)		; $5e06
	or a			; $5e07
	jr z,++			; $5e08

	; While the ghini is moving, make them "rotate" in position.
	call objectApplySpeed		; $5e0a
	ld e,Interaction.angle		; $5e0d
	ld a,(de)		; $5e0f
	dec a			; $5e10
	and $1f			; $5e11
	ld (de),a		; $5e13
	cp $18			; $5e14
	jr nz,++		; $5e16

	xor a			; $5e18
	ld e,Interaction.speed		; $5e19
	ld (de),a		; $5e1b
++
	call interactionRunScript		; $5e1c
	ret nc			; $5e1f
@delete:
	jp interactionDelete		; $5e20

@scriptTable:
	.dw ghiniHarassingMoosh_subid00Script
	.dw ghiniHarassingMoosh_subid01Script
	.dw ghiniHarassingMoosh_subid02Script


; ==============================================================================
; INTERACID_RICKYS_GLOVE_SPAWNER
; ==============================================================================
interactionCode74:
	; Delete self if already returned gloves, haven't talked to Ricky, or already got
	; gloves
	ld a,(wRickyState)		; $5e29
	bit 5,a			; $5e2c
	jr nz,@delete	; $5e2e
	and $01			; $5e30
	jr z,@delete	; $5e32
	ld a,TREASURE_RICKY_GLOVES		; $5e34
	call checkTreasureObtained		; $5e36
	jr c,@delete	; $5e39

	ldbc INTERACID_TREASURE, TREASURE_RICKY_GLOVES		; $5e3b
	call objectCreateInteraction		; $5e3e
	ret nz			; $5e41
@delete:
	jp interactionDelete		; $5e42


; ==============================================================================
; INTERACID_INTRO_SPRITE
; ==============================================================================
interactionCode75:
	ld e,Interaction.state		; $5e45
	ld a,(de)		; $5e47
	rst_jumpTable			; $5e48
	.dw @state0
	.dw @state1

@state0:
	call interactionIncState		; $5e4d
	call interactionInitGraphics		; $5e50
	call objectSetVisible82		; $5e53
	ld e,Interaction.subid		; $5e56
	ld a,(de)		; $5e58
	rst_jumpTable			; $5e59
	.dw @subid0Init
	.dw @subid1Init
	.dw @subid2Init
	.dw @subid3Init
	.dw @subid4Init
	.dw @subid5Init
	.dw @subid6Init

@subid0Init:
@subid5Init:
	ret			; $5e68

@subid1Init:
	ld h,d			; $5e69
	ld l,Interaction.counter1		; $5e6a
	ld (hl),$05		; $5e6c

@initSpeedToScrollLeft:
	ld l,Interaction.angle		; $5e6e
	ld (hl),ANGLE_LEFT		; $5e70
	ld l,Interaction.speed		; $5e72
	ld (hl),SPEED_20		; $5e74
	ld bc,$7080		; $5e76
	jp interactionSetPosition		; $5e79

@subid2Init:
	call objectSetVisible83		; $5e7c
	ld h,d			; $5e7f
	jr @initSpeedToScrollLeft		; $5e80

@subid3Init:
	ld bc,$4c6c		; $5e82
	call interactionSetPosition		; $5e85
	ld l,Interaction.angle		; $5e88
	ld (hl),$19		; $5e8a
	ld l,Interaction.speed		; $5e8c
	ld (hl),SPEED_40		; $5e8e
	ret			; $5e90

@subid4Init:
	ld bc,$1838		; $5e91
	jp interactionSetPosition		; $5e94

@subid6Init:
	ld h,d			; $5e97
	ld l,Interaction.angle		; $5e98
	ld (hl),$1a		; $5e9a
	ld l,Interaction.speed		; $5e9c
	ld (hl),SPEED_60		; $5e9e
	ret			; $5ea0

@state1:
	ld e,Interaction.subid		; $5ea1
	ld a,(de)		; $5ea3
	rst_jumpTable			; $5ea4
	.dw @runSubid0
	.dw @runSubid1
	.dw @runSubid2
	.dw @runSubid3
	.dw interactionAnimate
	.dw @runSubid5
	.dw @runSubid6

@runSubid0:
@runSubid5:
	ld a,(wIntro.cbba)		; $5eb3
	or a			; $5eb6
	jp z,interactionAnimate		; $5eb7
	jp interactionDelete		; $5eba

@runSubid1:
	call checkInteractionState2		; $5ebd
	jr nz,@updateSpeed	; $5ec0

	call interactionAnimate		; $5ec2
	ld h,d			; $5ec5
	ld l,Interaction.animParameter		; $5ec6
	ld a,(hl)		; $5ec8
	or a			; $5ec9
	jr z,@updateSpeed	; $5eca

	ld (hl),$00		; $5ecc
	ld l,Interaction.counter1		; $5ece
	dec (hl)		; $5ed0
	jr nz,@updateSpeed	; $5ed1

	ld l,Interaction.state2		; $5ed3
	inc (hl)		; $5ed5
	ld a,$04		; $5ed6
	call interactionSetAnimation		; $5ed8

@updateSpeed:
@runSubid2:
	ld hl,wIntro.cbb6		; $5edb
	ld a,(hl)		; $5ede
	or a			; $5edf
	ret z			; $5ee0
	jp objectApplySpeed		; $5ee1

@runSubid3:
	call interactionAnimate		; $5ee4
	ld a,(wIntro.frameCounter)		; $5ee7
	and $03			; $5eea
	ret nz			; $5eec
	jp objectApplySpeed		; $5eed

@runSubid6:
	ld a,(wTmpcbba)		; $5ef0
	or a			; $5ef3
	jp nz,interactionDelete		; $5ef4
	ld a,(wPaletteThread_mode)		; $5ef7
	or a			; $5efa
	ret nz			; $5efb
	call interactionAnimate		; $5efc
	jp objectApplySpeed		; $5eff


; ==============================================================================
; INTERACID_MAKU_GATE_OPENING
; ==============================================================================
interactionCode76:
	ld e,Interaction.subid		; $5f02
	ld a,(de)		; $5f04
	rst_jumpTable			; $5f05
	.dw @subid0
	.dw @subid1

@subid0:
@subid1:
	ld e,Interaction.state		; $5f0a
	ld a,(de)		; $5f0c
	rst_jumpTable			; $5f0d
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3

@state0:
	ld h,d			; $5f16
	ld l,Interaction.state		; $5f17
	inc (hl)		; $5f19
	ld l,Interaction.counter1		; $5f1a
	ld (hl),30		; $5f1c
	ld l,Interaction.subid		; $5f1e
	ld a,(hl)		; $5f20
	or a			; $5f21
	ld hl,@frame0And1_subid0		; $5f22
	jr z,+			; $5f25
	ld hl,@frame0And1_subid1		; $5f27
+
	call @loadInterleavedTiles		; $5f2a
	ld bc,@frame0_poof		; $5f2d
	call @loadPoofs		; $5f30

@shakeScreen:
	ld a,$06		; $5f33
	call setScreenShakeCounter		; $5f35
	ld a,SND_DOORCLOSE		; $5f38
	jp playSound		; $5f3a

@state1:
	call interactionDecCounter1		; $5f3d
	ret nz			; $5f40
	ld hl,@frame0And1_subid0		; $5f41
	call @loadTiles		; $5f44
	ld bc,@frame1_poof		; $5f47
	call @loadPoofs		; $5f4a
	call @shakeScreen		; $5f4d
	ld h,d			; $5f50
	ld l,Interaction.state		; $5f51
	inc (hl)		; $5f53
	ld l,Interaction.counter1		; $5f54
	ld (hl),30		; $5f56
	ret			; $5f58

@state2:
	call interactionDecCounter1		; $5f59
	ret nz			; $5f5c
	ld hl,@frame2And3		; $5f5d
	call @loadInterleavedTiles		; $5f60
	ld bc,@frame2_poof		; $5f63
	call @loadPoofs		; $5f66
	call @shakeScreen		; $5f69

	ld h,d			; $5f6c
	ld l,Interaction.state		; $5f6d
	inc (hl)		; $5f6f
	ld l,Interaction.counter1		; $5f70
	ld (hl),30		; $5f72
	ret			; $5f74

@state3:
	call interactionDecCounter1		; $5f75
	ret nz			; $5f78
	ld hl,@frame2And3		; $5f79
	call @loadTiles		; $5f7c
	ld bc,@frame3_poof		; $5f7f
	call @loadPoofs		; $5f82
	call @shakeScreen		; $5f85
	call getThisRoomFlags		; $5f88
	set 7,(hl)		; $5f8b
	jp interactionDelete		; $5f8d

@frame0And1_subid0:
	.db $02
	.db $74 $f9 $8e $03
	.db $75 $f9 $8e $01

@frame0And1_subid1:
	.db $02
	.db $74 $f9 $8c $03
	.db $75 $f9 $8c $01

@frame2And3:
	.db $02
	.db $73 $f9 $8c $03
	.db $76 $f9 $8c $01

@frame0_poof:
	.db $04
	.db $74 $48
	.db $74 $58
	.db $7c $48
	.db $7c $58

@frame1_poof:
	.db $04
	.db $74 $40
	.db $74 $60
	.db $7c $40
	.db $7c $60

@frame2_poof:
	.db $04
	.db $74 $38
	.db $74 $68
	.db $7c $38
	.db $7c $68

@frame3_poof:
	.db $04
	.db $74 $30
	.db $74 $70
	.db $7c $30
	.db $7c $70

;;
; @param	hl	Pointer to data
; @addr{5fcf}
@loadInterleavedTiles:
	ldi a,(hl)		; $5fcf
	ld b,a			; $5fd0
@@next:
	ldi a,(hl)		; $5fd1
	ldh (<hFF8C),a	; $5fd2
	ldi a,(hl)		; $5fd4
	ldh (<hFF8F),a	; $5fd5
	ldi a,(hl)		; $5fd7
	ldh (<hFF8E),a	; $5fd8
	ldi a,(hl)		; $5fda
	push hl			; $5fdb
	push bc			; $5fdc
	call setInterleavedTile		; $5fdd
	pop bc			; $5fe0
	pop hl			; $5fe1
	dec b			; $5fe2
	jr nz,@@next	; $5fe3
	ret			; $5fe5

;;
; @param	hl	Pointer to data
; @addr{5fe6}
@loadTiles:
	ldi a,(hl)		; $5fe6
	ld b,a			; $5fe7
@@next:
	ldi a,(hl)		; $5fe8
	ld c,a			; $5fe9
	ld a,(hl)		; $5fea
	push hl			; $5feb
	push bc			; $5fec
	call setTile		; $5fed
	pop bc			; $5ff0
	pop hl			; $5ff1
	inc hl			; $5ff2
	inc hl			; $5ff3
	inc hl			; $5ff4
	dec b			; $5ff5
	jr nz,@@next	; $5ff6
	ret			; $5ff8

;;
; @param	hl	Pointer to poof position data
; @addr{5ff9}
@loadPoofs:
	ld a,(bc)		; $5ff9
	inc bc			; $5ffa
@@next:
	ldh (<hFF8B),a	; $5ffb
	call getFreeInteractionSlot		; $5ffd
	ret nz			; $6000
	ld (hl),INTERACID_PUFF		; $6001
	ld l,Interaction.yh		; $6003
	ld a,(bc)		; $6005
	ld (hl),a		; $6006
	inc bc			; $6007
	ld l,Interaction.xh		; $6008
	ld a,(bc)		; $600a
	ld (hl),a		; $600b
	inc bc			; $600c
	ldh a,(<hFF8B)	; $600d
	dec a			; $600f
	jr nz,@@next	; $6010
	ld a,SND_KILLENEMY		; $6012
	jp playSound		; $6014


; ==============================================================================
; INTERACID_SMALL_KEY_ON_ENEMY
; ==============================================================================
interactionCode77:
	ld e,Interaction.state		; $6017
	ld a,(de)		; $6019
	rst_jumpTable			; $601a
	.dw @state0
	.dw @state1
	.dw @state2

@state0:
	call getThisRoomFlags		; $6021
	and ROOMFLAG_ITEM			; $6024
	jp nz,interactionDelete		; $6026

	ld e,Interaction.subid		; $6029
	ld a,(de)		; $602b
	ld b,a			; $602c
	ldhl FIRST_ENEMY_INDEX, Enemy.id		; $602d
@nextEnemy:
	ld a,(hl)		; $6030
	cp b			; $6031
	jr z,@foundMatch	; $6032
	inc h			; $6034
	ld a,h			; $6035
	cp LAST_ENEMY_INDEX+1			; $6036

	; BUG: Original game does "jp c", meaning this only works if the enemy in
	; question is in the first enemy slot.
.ifdef ENABLE_BUGFIXES
	jp nc,interactionDelete
.else
	jp c,interactionDelete		; $6038
.endif
	jr @nextEnemy		; $603b

; Found the enemy to attach the key to
@foundMatch:
	dec l			; $603d
	ld a,l			; $603e
	ld e,Interaction.relatedObj2		; $603f
	ld (de),a		; $6041
	ld a,h			; $6042
	inc e			; $6043
	ld (de),a		; $6044
	call interactionInitGraphics		; $6045
	call objectSetVisible80		; $6048
	call interactionIncState		; $604b

@takeRelatedObj2Position:
	ld a,Object.y		; $604e
	call objectGetRelatedObject2Var		; $6050
	jp objectTakePosition		; $6053

@state1: ; Copies the position of relatedObj2
	ld a,Object.enabled		; $6056
	call objectGetRelatedObject2Var		; $6058
	ld a,(hl)		; $605b
	or a			; $605c
	jp z,interactionIncState		; $605d

	call @takeRelatedObj2Position		; $6060
	ld a,Object.visible		; $6063
	call objectGetRelatedObject2Var		; $6065
	ld b,$01		; $6068
	jp objectFlickerVisibility		; $606a

@state2: ; relatedObj2 is gone, fall to the ground and create a key
	call objectSetVisible		; $606d
	ld c,$20		; $6070
	call objectUpdateSpeedZ_paramC		; $6072
	ret nz			; $6075
	ldbc TREASURE_SMALL_KEY,$00		; $6076
	call createTreasure		; $6079
	call objectCopyPosition		; $607c
	jp interactionDelete		; $607f


; ==============================================================================
; INTERACID_STONE_PANEL
; ==============================================================================
interactionCode7b:
	ld e,Interaction.state		; $6082
	ld a,(de)		; $6084
	rst_jumpTable			; $6085
	.dw @state0
	.dw @state1
	.dw @state2
	.dw objectPreventLinkFromPassing

@state0:
	ld bc,$0e08		; $608e
	call objectSetCollideRadii		; $6091
	call interactionInitGraphics		; $6094
	call objectSetVisible83		; $6097
	ld a,PALH_7e		; $609a
	call loadPaletteHeader		; $609c
	call getThisRoomFlags		; $609f
	and $40			; $60a2
	jr nz,@initializeOpenedState	; $60a4

	; Closed
	ld hl,wRoomCollisions+$66		; $60a6
	ld a,$0f		; $60a9
	ldi (hl),a		; $60ab
	ldi (hl),a		; $60ac
	ld (hl),a		; $60ad
	jp interactionIncState		; $60ae

@initializeOpenedState:
	ld e,Interaction.state		; $60b1
	ld a,$03		; $60b3
	ld (de),a		; $60b5

	; Move position 10 left or right
	ld e,Interaction.subid		; $60b6
	ld a,(de)		; $60b8
	or a			; $60b9
	ld b,$10		; $60ba
	jr nz,+			; $60bc
	ld b,$f0		; $60be
+
	ld e,Interaction.xh		; $60c0
	ld a,(de)		; $60c2
	add b			; $60c3
	ld (de),a		; $60c4

	ld e,Interaction.state		; $60c5
	ld a,$03		; $60c7
	ld (de),a		; $60c9

@updateSolidityUponOpening:
	ld hl,wRoomCollisions+$66		; $60ca
	xor a			; $60cd
	ldi (hl),a		; $60ce
	ldi (hl),a		; $60cf
	ld (hl),a		; $60d0
	ld l,$46		; $60d1
	ld (hl),$02		; $60d3
	ld l,$56		; $60d5
	ld (hl),$0a		; $60d7
	ld l,$66		; $60d9
	ld (hl),$08		; $60db
	ld l,$48		; $60dd
	ld (hl),$01		; $60df
	ld l,$58		; $60e1
	ld (hl),$05		; $60e3
	ld l,$68		; $60e5
	ld (hl),$04		; $60e7
	ret			; $60e9

; Wait for bit 7 of wActiveTriggers to open the panel.
@state1:
	call objectPreventLinkFromPassing		; $60ea
	ld a,(wActiveTriggers)		; $60ed
	bit 7,a			; $60f0
	ret z			; $60f2

	ld a,$81		; $60f3
	ld (wDisabledObjects),a		; $60f5
	ld (wMenuDisabled),a		; $60f8
	ld e,Interaction.counter1		; $60fb
	ld a,60		; $60fd
	ld (de),a		; $60ff
	ld a,SNDCTRL_STOPMUSIC		; $6100
	call playSound		; $6102
	jp interactionIncState		; $6105

@state2:
	call objectPreventLinkFromPassing		; $6108
	ld e,Interaction.state2		; $610b
	ld a,(de)		; $610d
	rst_jumpTable			; $610e
	.dw @substate0
	.dw @substate1
	.dw @substate2

@substate0: ; Delay before opening
	call interactionDecCounter1		; $6115
	ret nz			; $6118

	ld (hl),$80		; $6119
	ld e,Interaction.subid		; $611b
	ld a,(de)		; $611d
	or a			; $611e
	ld a,ANGLE_LEFT		; $611f
	jr z,+			; $6121
	ld a,ANGLE_RIGHT		; $6123
+
	ld e,Interaction.angle		; $6125
	ld (de),a		; $6127
	ld e,Interaction.speed		; $6128
	ld a,SPEED_20		; $612a
	ld (de),a		; $612c

	ld a,SND_OPENING		; $612d
	call playSound		; $612f
	jp interactionIncState2		; $6132

@substate1: ; Currently opening
	ld a,(wFrameCounter)		; $6135
	rrca			; $6138
	ret nc			; $6139
	call objectApplySpeed		; $613a
	call interactionDecCounter1		; $613d
	ret nz			; $6140
	ld (hl),30		; $6141
	jp interactionIncState2		; $6143

@substate2: ; Done opening
	call interactionDecCounter1		; $6146
	ret nz			; $6149

	xor a			; $614a
	ld (wDisabledObjects),a		; $614b
	ld (wMenuDisabled),a		; $614e
	ld hl,wActiveTriggers		; $6151
	res 7,(hl)		; $6154
	call getThisRoomFlags		; $6156
	set 6,(hl)		; $6159

	call @updateSolidityUponOpening		; $615b
	ld a,(wActiveMusic)		; $615e
	call playSound		; $6161
	jp interactionIncState		; $6164


; ==============================================================================
; INTERACID_SCREEN_DISTORTION
; ==============================================================================
interactionCode7c:
	call checkInteractionState		; $6167
	jr z,@state0		; $616a

@state1:
	ld a,$01		; $616c
	jp loadBigBufferScrollValues		; $616e

@state0:
	call interactionSetAlwaysUpdateBit		; $6171
	call interactionIncState		; $6174
	ld a,$10		; $6177
	ld (wGfxRegs2.LYC),a		; $6179
	ld a,$02		; $617c
	ldh (<hNextLcdInterruptBehaviour),a	; $617e
	ld a,SND_WARP_START		; $6180
	call playSound		; $6182
	ld a,$ff		; $6185
	jp initWaveScrollValues		; $6187


; ==============================================================================
; INTERACID_DECORATION
; ==============================================================================
interactionCode80:
	call checkInteractionState		; $618a
	jr z,@state0		; $618d

@state1:
	ld e,Interaction.subid		; $618f
	ld a,(de)		; $6191
	rst_jumpTable			; $6192
	.dw interactionAnimate
	.dw interactionAnimate
	.dw interactionAnimate
	.dw interactionAnimate
	.dw interactionAnimate
	.dw interactionAnimate
	.dw interactionAnimate
	.dw @deleteIfGotRoomItem
	.dw @deleteIfGotRoomItem
	.dw interactionAnimate
	.dw interactionAnimate

@state0:
	call interactionInitGraphics		; $61a9
	call interactionIncState		; $61ac
	call objectSetVisible83		; $61af
	ld e,Interaction.subid		; $61b2
	ld a,(de)		; $61b4
	rst_jumpTable			; $61b5
	.dw @stub
	.dw @deleteIfMoblinsKeepDestroyed
	.dw @stub
	.dw @stub
	.dw @deleteIfRoomFlagBit7Unset
	.dw @stub
	.dw @deleteIfRoomFlagBit7Unset
	.dw @deleteIfGotRoomItem
	.dw @deleteIfGotRoomItem
	.dw @stub
	.dw @subid0a

@stub:
	ret			; $61cc

; Subid $01 (moblin's keep flag)
@deleteIfMoblinsKeepDestroyed:
	ld a,GLOBALFLAG_MOBLINS_KEEP_DESTROYED		; $61cd
	call checkGlobalFlag		; $61cf
	ret z			; $61d2
	jp interactionDelete		; $61d3

; Subid $04, $06 (scent seedling & tokay eyeball)
@deleteIfRoomFlagBit7Unset:
	call getThisRoomFlags		; $61d6
	bit 7,a			; $61d9
	ret nz			; $61db
	jp interactionDelete		; $61dc

@deleteIfGotRoomItem:
	call getThisRoomFlags		; $61df
	bit ROOMFLAG_BIT_ITEM,a			; $61e2
	ret z			; $61e4
	jp interactionDelete		; $61e5

; Fountain "stream": decide which palette to used based on whether this is the "ruined"
; symmetry city or not
@subid0a:
	call objectSetVisible80		; $61e8
	call @isSymmetryCityRoom		; $61eb
	jr c,@isSymmetryCity	; $61ee

@normalPalette:
	ld a,PALH_7d		; $61f0
	jp loadPaletteHeader		; $61f2

@isSymmetryCity:
	ld a,(wActiveGroup)		; $61f5
	or a			; $61f8
	jr nz,@ruinedSymmetryPalette	; $61f9
	call getThisRoomFlags		; $61fb
	and $01			; $61fe
	jr nz,@normalPalette	; $6200

@ruinedSymmetryPalette:
	ld a,PALH_7c		; $6202
	jp loadPaletteHeader		; $6204

@isSymmetryCityRoom:
	ld a,(wActiveRoom)		; $6207
	ld e,a			; $620a
	ld hl,@symmetryCityRooms		; $620b
	jp lookupKey		; $620e

@symmetryCityRooms:
	.db $12 $00
	.db $13 $00
	.db $14 $00
	.db $00


; ==============================================================================
; INTERACID_TOKAY_SHOP_ITEM
;
; Variables:
;   var38: If nonzero, item can be bought with seeds
;   var39: Number of seeds Link has of the type needed to buy this item
;   var3a: Set if Link has the shovel
;   var3c: The treasure ID of this item (feather/bracelet only)
;   var3d: Set if Link has the shield
; ==============================================================================
interactionCode81:
	ld e,Interaction.state		; $6218
	ld a,(de)		; $621a
	rst_jumpTable			; $621b
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $6220
	ld (de),a		; $6222
	ld a,>TX_0a00		; $6223
	call interactionSetHighTextIndex		; $6225
	call interactionSetAlwaysUpdateBit		; $6228
	ld a,$06		; $622b
	call objectSetCollideRadius		; $622d

	ld l,Interaction.subid		; $6230
	ldi a,(hl)		; $6232
	ld (hl),a ; [var03] = [subid]
	cp $04			; $6234
	jr nz,@initializeItem	; $6236

	; This is the shield; only appears if all other items retrieved. Also, adjust
	; level appropriately.
	ld a,GLOBALFLAG_BOUGHT_BRACELET_FROM_TOKAY		; $6238
	call checkGlobalFlag		; $623a
	jp z,interactionDelete		; $623d

	ld a,(wShieldLevel)		; $6240
	or a			; $6243
	jr z,@initializeItem	; $6244

	; [subid] = [var03] = [wShieldLevel] + [subid] - 1
	ld e,Interaction.subid		; $6246
	ld c,a			; $6248
	dec c			; $6249
	ld a,(de)		; $624a
	add c			; $624b
	ld (de),a		; $624c
	inc e			; $624d
	ld (de),a		; $624e

@initializeItem:
	call @checkTransformItem		; $624f
	jp nz,interactionDelete		; $6252

	ld hl,tokayShopItemScript		; $6255
	call interactionSetScript		; $6258
	ld e,Interaction.pressedAButton		; $625b
	call objectAddToAButtonSensitiveObjectList		; $625d
	call interactionSetAlwaysUpdateBit		; $6260
	jp objectSetVisible82		; $6263

@initialShopTreasures:
	.db TREASURE_FEATHER, TREASURE_BRACELET

@seedsNeededToBuyItems:
	.db TREASURE_MYSTERY_SEEDS, TREASURE_SCENT_SEEDS, $00, $00,
	.db TREASURE_SCENT_SEEDS, TREASURE_SCENT_SEEDS, TREASURE_SCENT_SEEDS

	; TODO: what is this data? ($626f)
	.db $28 $76 $6c $76 $b4 $76 $c4 $76

@state1:
	call interactionAnimateAsNpc		; $6277
	call @checkTransformItem		; $627a
	call nz,objectSetInvisible		; $627d
	call interactionRunScript		; $6280
	ret nc			; $6283
	xor a			; $6284
	ld (wDisabledObjects),a		; $6285
	jp interactionDelete		; $6288

;;
; This checks whether to replace the feather/bracelet with the shovel, changing the subid
; accordingly and initializing the graphics after doing so.
;
; @param[out]	zflag	nz if item should be deleted?
; @addr{628b}
@checkTransformItem:
	ld h,d			; $628b
	ld l,Interaction.var38		; $628c
	xor a			; $628e
	ldi (hl),a		; $628f
	ldi (hl),a		; $6290
	ldi (hl),a		; $6291
	ldi (hl),a		; $6292

	ld e,Interaction.var03		; $6293
	ld a,(de)		; $6295
	ld c,a			; $6296
	ld a,TREASURE_SEED_SATCHEL		; $6297
	call checkTreasureObtained		; $6299
	jr nc,@checkReplaceWithShovel	; $629c

	; Seed satchel obtained; set var38/var39 based on whether Link can buy the item?

	ld a,c			; $629e
	ld hl,@seedsNeededToBuyItems		; $629f
	rst_addAToHl			; $62a2
	ld a,(hl)		; $62a3
	call checkTreasureObtained		; $62a4
	jr nc,@checkReplaceWithShovel	; $62a7

	inc a			; $62a9
	ld e,Interaction.var39		; $62aa
	ld (de),a		; $62ac
	cp $10			; $62ad
	jr c,@checkReplaceWithShovel	; $62af

	ld e,Interaction.var38		; $62b1
	ld (de),a		; $62b3

@checkReplaceWithShovel:
	ld a,TREASURE_SHOVEL		; $62b4
	call checkTreasureObtained		; $62b6
	jr nc,++		; $62b9
	ld e,Interaction.var3a		; $62bb
	ld a,$01		; $62bd
	ld (de),a		; $62bf
++
	ld a,TREASURE_SHIELD		; $62c0
	call checkTreasureObtained		; $62c2
	jr nc,++		; $62c5
	ld e,Interaction.var3d		; $62c7
	ld a,$01		; $62c9
	ld (de),a		; $62cb
++
	ld a,c			; $62cc
	cp $04			; $62cd
	jr nc,@setSubidAndInitGraphics	; $62cf

	; The item is the feather or the bracelet.

	; If we've bought the item, it should be deleted.
	ld a,c			; $62d1
	ld hl,@boughtItemGlobalflags		; $62d2
	rst_addAToHl			; $62d5
	ld a,(hl)		; $62d6
	call checkGlobalFlag		; $62d7
	ret nz			; $62da

	; Otherwise, if Link has the item, it should be replaced with the shovel.
	ld a,c			; $62db
	ld hl,@initialShopTreasures		; $62dc
	rst_addAToHl			; $62df
	ld a,(hl)		; $62e0
	ld e,Interaction.var3c		; $62e1
	ld (de),a		; $62e3

	call checkTreasureObtained		; $62e4
	jr nc,@setSubidAndInitGraphics	; $62e7

	; Increment subid by 2, making it a shovel
	inc c			; $62e9
	inc c			; $62ea

@setSubidAndInitGraphics:
	ld e,Interaction.subid		; $62eb
	ld a,c			; $62ed
	ld (de),a		; $62ee
	call interactionInitGraphics		; $62ef
	xor a			; $62f2
	ret			; $62f3

@boughtItemGlobalflags:
	.db GLOBALFLAG_BOUGHT_FEATHER_FROM_TOKAY, GLOBALFLAG_BOUGHT_BRACELET_FROM_TOKAY


; ==============================================================================
; INTERACID_SARCOPHAGUS
; ==============================================================================
interactionCode82:
	ld e,Interaction.state		; $62f6
	ld a,(de)		; $62f8
	rst_jumpTable			; $62f9
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3

@state0:
	call interactionInitGraphics		; $6302
	ld e,Interaction.subid		; $6305
	ld a,(de)		; $6307
	bit 7,a			; $6308
	jp nz,@break		; $630a

	or a			; $630d
	jr z,++			; $630e
	call getThisRoomFlags		; $6310
	bit 6,a			; $6313
	jp nz,interactionDelete		; $6315
++
	call interactionIncState		; $6318

	ld l,Interaction.collisionRadiusY		; $631b
	ld (hl),$10		; $631d
	ld l,Interaction.collisionRadiusX		; $631f
	ld (hl),$08		; $6321

	call objectMakeTileSolid		; $6323
	ld h,>wRoomLayout		; $6326
	ld (hl),$00		; $6328
	ld a,l			; $632a
	sub $10			; $632b
	ld l,a			; $632d
	ld (hl),$00		; $632e
	ld h,>wRoomCollisions		; $6330
	ld (hl),$0f		; $6332
	jp objectSetVisible83		; $6334

; Waiting for Link to grab
@state1:
	ld a,(wBraceletLevel)		; $6337
	cp $02			; $633a
	ret c			; $633c
	jp objectAddToGrabbableObjectBuffer		; $633d

; Link currently grabbing
@state2:
	inc e			; $6340
	ld a,(de)		; $6341
	rst_jumpTable			; $6342
	.dw @substate0_justGrabbed
	.dw @substate1_holding
	.dw @substate2_justReleased
	.dw @break

@substate0_justGrabbed:
	call interactionIncState2		; $634b
	ld l,Interaction.subid		; $634e
	ld a,(hl)		; $6350
	or a			; $6351
	jr z,++			; $6352

	dec a			; $6354
	ld a,SND_SOLVEPUZZLE		; $6355
	call z,playSound		; $6357
	call getThisRoomFlags		; $635a
	set 6,(hl)		; $635d
++
	call objectGetShortPosition		; $635f
	push af			; $6362
	call getTileIndexFromRoomLayoutBuffer		; $6363
	call setTile		; $6366
	pop af			; $6369
	sub $10			; $636a
	call getTileIndexFromRoomLayoutBuffer		; $636c
	call setTile		; $636f
	xor a			; $6372
	ld (wLinkGrabState2),a		; $6373
	jp objectSetVisiblec1		; $6376

@substate1_holding:
	ret			; $6379

@substate2_justReleased:
	ld h,d			; $637a
	ld l,Interaction.enabled		; $637b
	res 1,(hl)		; $637d

	; Wait for it to hit the ground
	ld l,Interaction.zh		; $637f
	bit 7,(hl)		; $6381
	ret nz			; $6383

@break:
	ld h,d			; $6384
	ld l,Interaction.state		; $6385
	ld (hl),$03		; $6387
	ld l,Interaction.counter1		; $6389
	ld (hl),$02		; $638b

	ld l,Interaction.oamFlagsBackup		; $638d
	ld a,$0c		; $638f
	ldi (hl),a		; $6391
	ldi (hl),a		; $6392
	ld (hl),$40 ; [oamTileIndexBase] = $40

	call objectSetVisible83		; $6395
	xor a			; $6398
	jp interactionSetAnimation		; $6399

; Being destroyed
@state3:
	call interactionDecCounter1		; $639c
	ld a,SND_KILLENEMY		; $639f
	call z,playSound		; $63a1
	ld e,Interaction.animParameter		; $63a4
	ld a,(de)		; $63a6
	inc a			; $63a7
	jp nz,interactionAnimate		; $63a8
	jp interactionDelete		; $63ab


; ==============================================================================
; INTERACID_BOMB_UPGRADE_FAIRY
; ==============================================================================
interactionCode83:
	ld e,Interaction.subid		; $63ae
	ld a,(de)		; $63b0
	ld e,Interaction.state		; $63b1
	rst_jumpTable			; $63b3
	.dw _bombUpgradeFairy_subid00
	.dw _bombUpgradeFairy_subid01
	.dw _bombUpgradeFairy_subid02

_bombUpgradeFairy_subid00:
	ld a,(de)		; $63ba
	rst_jumpTable			; $63bb
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3

@state0:
	ld a,GLOBALFLAG_GOT_BOMB_UPGRADE_FROM_FAIRY		; $63c4
	call checkGlobalFlag		; $63c6
	jp nz,interactionDelete		; $63c9

	call getThisRoomFlags		; $63cc
	bit 0,a			; $63cf
	jp z,interactionDelete		; $63d1

	call interactionInitGraphics		; $63d4
	call interactionSetAlwaysUpdateBit		; $63d7
	call interactionIncState		; $63da

	ld l,Interaction.collisionRadiusY		; $63dd
	inc (hl)		; $63df
	inc l			; $63e0
	ld (hl),$12		; $63e1

	ld hl,wTextNumberSubstitution		; $63e3
	ld a,(wMaxBombs)		; $63e6
	cp $10			; $63e9
	ld a,$30		; $63eb
	jr z,+			; $63ed
	ld a,$50		; $63ef
+
	ldi (hl),a		; $63f1
	xor a			; $63f2
	ld (hl),a		; $63f3
	ld (wTmpcfc0.bombUpgradeCutscene.state),a		; $63f4
	ld ($cfd0),a		; $63f7
	ret			; $63fa

@state1:
	; Bombs are hardcoded to set this variable to $01 when it falls into water on this
	; screen. Hold execution until that happens.
	ld a,(wTmpcfc0.bombUpgradeCutscene.state)		; $63fb
	dec a			; $63fe
	ret nz			; $63ff

	ld a,(w1Link.zh)		; $6400
	or a			; $6403
	ret nz			; $6404

	; Check that Link's in position
	ldh a,(<hEnemyTargetY)	; $6405
	sub $41			; $6407
	cp $06			; $6409
	ret nc			; $640b
	ldh a,(<hEnemyTargetX)	; $640c
	sub $58			; $640e
	cp $21			; $6410
	ret nc			; $6412

	call checkLinkVulnerable		; $6413
	ret nc			; $6416

	ldbc INTERACID_PUFF, $02		; $6417
	call objectCreateInteraction		; $641a
	ret nz			; $641d
	ld e,Interaction.relatedObj2		; $641e
	ld a,Interaction.start		; $6420
	ld (de),a		; $6422
	inc e			; $6423
	ld a,h			; $6424
	ld (de),a		; $6425

	call clearAllParentItems		; $6426
	call dropLinkHeldItem		; $6429

	xor a			; $642c
	ld (w1Link.direction),a		; $642d
	ld (wTmpcfc0.bombUpgradeCutscene.state),a		; $6430

	ld a,$80		; $6433
	ld (wDisabledObjects),a		; $6435
	ld (wMenuDisabled),a		; $6438
	call setLinkForceStateToState08		; $643b
	jp interactionIncState		; $643e

@state2:
	; Wait for signal to spawn in silver and gold bombs?
	ld a,Object.animParameter		; $6441
	call objectGetRelatedObject2Var		; $6443
	bit 7,(hl)		; $6446
	ret z			; $6448

	call interactionIncState		; $6449
	ld l,Interaction.yh		; $644c
	ld (hl),$28		; $644e

	ldbc INTERACID_SPARKLE, $0e		; $6450
	call objectCreateInteraction		; $6453

	call objectSetVisible81		; $6456
	ld hl,bombUpgradeFairyScript		; $6459
	call interactionSetScript		; $645c

	ld b,$00		; $645f
	call @spawnSubid2Instance		; $6461

	ld b,$01		; $6464

@spawnSubid2Instance:
	call getFreeInteractionSlot		; $6466
	ret nz			; $6469
	ld (hl),INTERACID_BOMB_UPGRADE_FAIRY		; $646a
	inc l			; $646c
	ld (hl),$02		; $646d
	inc l			; $646f
	ld (hl),b		; $6470
	ret			; $6471

@state3:
	call interactionAnimate		; $6472
	ld a,(wTextIsActive)		; $6475
	or a			; $6478
	ret nz			; $6479
	ld a,(wPaletteThread_mode)		; $647a
	or a			; $647d
	ret nz			; $647e
	call interactionRunScript		; $647f
	ret nc			; $6482

	xor a			; $6483
	ld (wDisabledObjects),a		; $6484
	ld (wMenuDisabled),a		; $6487
	inc a			; $648a
	ld (wTmpcfc0.bombUpgradeCutscene.state),a		; $648b

	call objectCreatePuff		; $648e
	jp interactionDelete		; $6491


; Bombs that surround Link (depending on his answer)
_bombUpgradeFairy_subid01:
	ld a,(de)		; $6494
	rst_jumpTable			; $6495
	.dw @state0
	.dw @state1
	.dw @state2

@state0:
	call interactionInitGraphics		; $649c
	call interactionIncState		; $649f

	ld l,Interaction.var03		; $64a2
	ld a,(hl)		; $64a4
	add a			; $64a5
	add (hl)		; $64a6

	ld hl,@bombPositions		; $64a7
	rst_addAToHl			; $64aa
	ld e,Interaction.yh		; $64ab
	ldh a,(<hEnemyTargetY)	; $64ad
	add (hl)		; $64af
	ld (de),a		; $64b0
	ld e,Interaction.xh		; $64b1
	inc hl			; $64b3
	ldh a,(<hEnemyTargetX)	; $64b4
	add (hl)		; $64b6
	ld (de),a		; $64b7

	ld e,Interaction.counter1		; $64b8
	inc hl			; $64ba
	ld a,(hl)		; $64bb
	ld (de),a		; $64bc
	ret			; $64bd

@bombPositions:
	.db $00 $f0 $01
	.db $10 $00 $0f
	.db $00 $10 $1e
	.db $f0 $00 $2d

@state1:
	call interactionDecCounter1		; $64ca
	ret nz			; $64cd
	ld l,e			; $64ce
	inc (hl)		; $64cf
	call objectCreatePuff		; $64d0
	jp objectSetVisible82		; $64d3

@state2:
	ld a,($cfd0)		; $64d6
	inc a			; $64d9
	jp z,interactionDelete		; $64da

	; Flash the bomb between blue and red palettes
	call interactionDecCounter1		; $64dd
	ld a,(hl)		; $64e0
	and $03			; $64e1
	ret nz			; $64e3

	ld l,Interaction.oamFlagsBackup		; $64e4
	ld a,(hl)		; $64e6
	xor $01			; $64e7
	ldi (hl),a		; $64e9
	ld (hl),a		; $64ea
	ret			; $64eb


; Gold/silver bombs
_bombUpgradeFairy_subid02:
	ld a,(de)		; $64ec
	rst_jumpTable			; $64ed
	.dw @state0
	.dw @state1
	.dw @state2

@state0:
	call interactionInitGraphics		; $64f4
	ld a,PALH_80		; $64f7
	call loadPaletteHeader		; $64f9
	call interactionIncState		; $64fc

	ld e,Interaction.var03		; $64ff
	ld a,(de)		; $6501
	or a			; $6502
	ld b,$5a		; $6503
	jr z,++			; $6505
	ld l,Interaction.oamFlagsBackup		; $6507
	ld a,$06		; $6509
	ldi (hl),a		; $650b
	ld (hl),a		; $650c
	ld b,$76		; $650d
++
	ld l,Interaction.yh		; $650f
	ld (hl),$3c		; $6511
	ld l,Interaction.xh		; $6513
	ld (hl),b		; $6515

	ldbc INTERACID_PUFF, $02		; $6516
	call objectCreateInteraction		; $6519
	ret nz			; $651c
	ld e,Interaction.relatedObj2		; $651d
	ld a,Interaction.start		; $651f
	ld (de),a		; $6521
	inc e			; $6522
	ld a,h			; $6523
	ld (de),a		; $6524
	ret			; $6525

@state1:
	; Wait for the puff to finish, then make self visible
	ld a,Object.animParameter		; $6526
	call objectGetRelatedObject1Var		; $6528
	bit 7,(hl)		; $652b
	ret nz			; $652d
	call interactionIncState		; $652e
	jp objectSetVisible82		; $6531

@state2:
	ld a,($cfd0)		; $6534
	or a			; $6537
	ret z			; $6538
	call objectCreatePuff		; $6539
	jp interactionDelete		; $653c


; ==============================================================================
; INTERACID_SPARKLE
; ==============================================================================
interactionCode84:
	call checkInteractionState		; $653f
	jr nz,@state1	; $6542

	call interactionInitGraphics		; $6544
	call interactionSetAlwaysUpdateBit		; $6547
	ld l,Interaction.state		; $654a
	inc (hl)		; $654c
	ld e,Interaction.subid		; $654d
	ld a,(de)		; $654f
	rst_jumpTable			; $6550
	.dw @initSubid00
	.dw @initSubid01
	.dw @initSubid02
	.dw @initSubid03
	.dw @highDrawPriority
	.dw @highDrawPriority
	.dw @highDrawPriority
	.dw @initSubid07
	.dw @highDrawPriority
	.dw @initSubid09
	.dw @initSubid0a
	.dw @initSubid0b
	.dw @initSubid0c
	.dw @highDrawPriority
	.dw @highDrawPriority
	.dw @highDrawPriority

@initSubid0a:
	ld h,d			; $6571
	ld l,Interaction.speed		; $6572
	ld a,(hl)		; $6574
	or a			; $6575
	jr nz,@initSubid00	; $6576
	ld (hl),$78		; $6578

@initSubid00:
@initSubid01:
@initSubid09:
	inc e			; $657a
	ld a,(de)		; $657b
	or a			; $657c
	jp nz,objectSetVisible81		; $657d

@initSubid02:
@initSubid03:
@initSubid07:
@lowDrawPriority:
	jp objectSetVisible82		; $6580

@highDrawPriority:
	jp objectSetVisible80		; $6583

@initSubid0b:
	ld h,d			; $6586
	ld l,Interaction.speedY		; $6587
	ld (hl),<(-$40)		; $6589
	inc l			; $658b
	ld (hl),>(-$40)		; $658c
	jp objectSetVisible81		; $658e

@initSubid0c:
	ld a,Object.id		; $6591
	call objectGetRelatedObject1Var		; $6593
	ld e,Interaction.var38		; $6596
	ld a,(hl)		; $6598
	ld (de),a		; $6599
	jr @lowDrawPriority		; $659a


@state1:
	ld e,Interaction.subid		; $659c
	ld a,(de)		; $659e
	rst_jumpTable			; $659f
	.dw @runSubid00
	.dw @runSubid01
	.dw @runSubid02
	.dw @runSubid03
	.dw @runSubid04
	.dw @runSubid05
	.dw @runSubid06
	.dw @runSubid07
	.dw @runSubid08
	.dw @runSubid09
	.dw @runSubid0a
	.dw @runSubid0b
	.dw @runSubid0c
	.dw @runSubid0d
	.dw @runSubid0e
	.dw @runSubid0f

@runSubid02:
@runSubid03:
@runSubid0b:
	call objectApplyComponentSpeed		; $65c0

@runSubid00:
@runSubid01:
@runSubid09:
	ld e,Interaction.animParameter		; $65c3
	ld a,(de)		; $65c5
	cp $ff			; $65c6
	jp z,interactionDelete		; $65c8
	jp interactionAnimate		; $65cb


@runSubid04:
@animateAndFlickerAndDeleteWhenCounter1Zero:
	call interactionDecCounter1		; $65ce
	jp z,interactionDelete		; $65d1

@runSubid08:
@animateAndFlicker:
	call interactionAnimate		; $65d4
	ld a,(wFrameCounter)		; $65d7
@flicker:
	rrca			; $65da
	jp c,objectSetInvisible		; $65db
	jp objectSetVisible		; $65de


@runSubid05:
	ld a,Object.yh		; $65e1
	call objectGetRelatedObject1Var		; $65e3
	ld bc,$0800		; $65e6
	call objectTakePositionWithOffset		; $65e9
	jr @animateAndFlickerAndDeleteWhenCounter1Zero		; $65ec


@runSubid07:
@runSubid0f:
	ld a,Object.yh		; $65ee
	call objectGetRelatedObject1Var		; $65f0
	call objectTakePosition		; $65f3

@runSubid0e:
	ld a,(wTmpcfc0.bombUpgradeCutscene.state)		; $65f6
	bit 0,a			; $65f9
	jp nz,interactionDelete		; $65fb
	jr @animateAndFlicker		; $65fe


@runSubid06:
	ld a,(wTmpcbb9)		; $6600
	cp $07			; $6603
	jp z,interactionDelete		; $6605

@animateFlickerAndTakeRelatedObj1Position:
	call interactionAnimate		; $6608
	ld a,Object.yh		; $660b
	call objectGetRelatedObject1Var		; $660d
	call objectTakePosition		; $6610
	ld a,(wIntro.frameCounter)		; $6613
	jr @flicker		; $6616


@runSubid0a:
	call objectApplySpeed		; $6618
	call objectCheckWithinScreenBoundary		; $661b
	jp c,interactionAnimate		; $661e
	jp interactionDelete		; $6621


@runSubid0c:
	ld a,Object.id		; $6624
	call objectGetRelatedObject1Var		; $6626
	ld e,Interaction.var38		; $6629
	ld a,(de)		; $662b
	cp (hl)			; $662c
	jp nz,interactionDelete		; $662d

	call objectTakePosition		; $6630
	ld a,($cfc0)		; $6633
	bit 0,a			; $6636
	jp nz,interactionDelete		; $6638
	jr @animateAndFlicker		; $663b


@runSubid0d:
	ld a,(wTmpcbb9)		; $663d
	cp $06			; $6640
	jp z,interactionDelete		; $6642
	jr @animateFlickerAndTakeRelatedObj1Position		; $6645


; ==============================================================================
; INTERACID_MAKU_FLOWER
; ==============================================================================
interactionCode86:
	ld e,Interaction.subid		; $6647
	ld a,(de)		; $6649
	rst_jumpTable			; $664a
	.dw @subid0
	.dw @subid1

; Present maku tree flower
@subid0:
	call checkInteractionState		; $664f
	jr nz,@subid0State1	; $6652

@subid0State0:
	call interactionInitGraphics		; $6654
	call objectSetVisible82		; $6657
	call interactionSetAlwaysUpdateBit		; $665a
	call interactionIncState		; $665d

@subid0State1:
	; Watch var3b of relatedObject1 to set the flower's animation
	ld a,Object.var3b		; $6660
	call objectGetRelatedObject2Var		; $6662
	ld a,(hl)		; $6665
	ld bc,@anims		; $6666
	call addAToBc		; $6669
	ld a,(bc)		; $666c
	cp $01			; $666d
	jr z,@setAnimA	; $666f
	ld b,a			; $6671
	ld l,Interaction.subid		; $6672
	ld a,(hl)		; $6674
	cp $04			; $6675
	jr nz,@setAnimB	; $6677
	ld b,$03		; $6679
@setAnimB:
	ld a,b			; $667b
@setAnimA:
	jp interactionSetAnimation		; $667c

@anims:
	.db $00 $00 $00 $00 $01


@subid1:
	call checkInteractionState	; $6684
	jr nz,@subid1State1	; $6687

@subid1State0:
	call interactionInitGraphics		; $6689
	call objectSetVisible82		; $668c
	call interactionSetAlwaysUpdateBit		; $668f
	call interactionIncState		; $6692
	ld l,Interaction.zh		; $6695
	ld (hl),$d4		; $6697
@subid1State1:
	ld h,d			; $6699
	ld l,Interaction.zh		; $669a
	inc (hl)		; $669c
	jp z,interactionDelete		; $669d
	ret			; $66a0


; ==============================================================================
; INTERACID_MAKU_TREE
;
; Variables:
;   var3b: Animation
;   var3d: 0 for present maku tree, 1 for past?
;   var3e: "Script mode"; mainly determines animation (see makuTree_subid00Script_body)
;   var3f: Text index to show for (sometimes shows the one after it as well)
; ==============================================================================
interactionCode87:
	ld e,Interaction.subid		; $66a1
	ld a,(de)		; $66a3
	rst_jumpTable			; $66a4
	.dw @subid00
	.dw @subid01
	.dw @subid02
	.dw @subid03
	.dw @subid04
	.dw @subid05
	.dw @subid06

@subid00:
	call checkInteractionState		; $66b3
	jr nz,@runScriptAndAnimate	; $66b6

	xor a			; $66b8
	ld e,Interaction.var3d		; $66b9
	ld (de),a		; $66bb
	call @initSubid00		; $66bc
	call @initializeMakuTree		; $66bf
	jr @runScriptAndAnimate		; $66c2

@subid01:
@subid02:
	call checkInteractionState		; $66c4
	jr nz,@runScriptAndAnimate	; $66c7

	call @initializeMakuTree		; $66c9
	call interactionRunScript		; $66cc
	ld e,Interaction.subid		; $66cf
	ld a,(de)		; $66d1
	dec a			; $66d2
	jr nz,@runScriptAndAnimate	; $66d3

	; Subid 1 only: make Link move right/up to approach the maku tree, starting the
	; "maku tree disappearance" cutscene

	ld a,PALH_8f		; $66d5
	call loadPaletteHeader		; $66d7

	ld hl,@simulatedInput		; $66da
	ld a,:@simulatedInput		; $66dd
	push de			; $66df
	call setSimulatedInputAddress		; $66e0
	pop de			; $66e3

	xor a			; $66e4
	ld (w1Link.direction),a		; $66e5
	jr @runScriptAndAnimate		; $66e8

@simulatedInput:
	dwb 60 $00
	dwb 48 BTN_RIGHT
	dwb  4 $00
	dwb 14 BTN_UP
	dwb 60 $00
	.dw $ffff

@runScriptAndAnimate:
	call interactionRunScript		; $66fb
	jp interactionAnimate		; $66fe

@subid03:
	call checkInteractionState		; $6701
	jr nz,@runScriptAndAnimate	; $6704

	ld b,$01		; $6706
	ld a,(wTmpcfc0.genericCutscene.cfd0)		; $6708
	cp $03			; $670b
	jr z,+			; $670d
	call interactionLoadExtraGraphics		; $670f
	ld b,$00		; $6712
+
	ld a,b			; $6714
	call interactionSetAnimation		; $6715
	call interactionInitGraphics		; $6718
	call @loadScript		; $671b
	jp @setVisibleAndSpawnFlower		; $671e

@subid04:
@subid05:
	call checkInteractionState		; $6721
	jr nz,@runScriptAndAnimate	; $6724
	call @initializeMakuTree		; $6726
	jr @runScriptAndAnimate		; $6729

@subid06:
	call checkInteractionState		; $672b
	jr nz,@runScriptAndAnimate	; $672e

	ld a,GLOBALFLAG_SAW_TWINROVA_BEFORE_ENDGAME		; $6730
	call checkGlobalFlag		; $6732
	jp nz,@initializeMakuTree		; $6735
	ld hl,w1Link.direction		; $6738
	ld (hl),$00		; $673b
	call setLinkForceStateToState08		; $673d
	call @initGraphicsAndIncState		; $6740
	call @setVisibleAndSpawnFlower		; $6743

	ld b,$00		; $6746
	ld hl,makuTree_subid06Script_part1		; $6748
	ld a,GLOBALFLAG_GOT_MAKU_SEED		; $674b
	push hl			; $674d
	call checkGlobalFlag		; $674e
	pop hl			; $6751
	jr z,+			; $6752
	ld b,$04		; $6754
	ld hl,makuTree_subid06Script_part2		; $6756
+
	call interactionSetScript		; $6759
	ld a,>TX_0500		; $675c
	call interactionSetHighTextIndex		; $675e
	ld a,b			; $6761
	call interactionSetAnimation		; $6762
	jp @runScriptAndAnimate		; $6765

@initSubid00:
	ld a,(wMakuTreeState)		; $6768
	rst_jumpTable			; $676b
	.dw @state00
	.dw @state01
	.dw @state02
	.dw @state03
	.dw @state04
	.dw @state05
	.dw @state06
	.dw @state07
	.dw @state08
	.dw @state09
	.dw @state0a
	.dw @state0b
	.dw @state0c
	.dw @state0d
	.dw @state0e
	.dw @state0f
	.dw @state10

@state00:
	ld a,GLOBALFLAG_0c		; $678e
	call checkGlobalFlag		; $6790
	jr nz,@ret	; $6793
	ld a,$01		; $6795
	jr @runSubidCode		; $6797

@state02:
	ld a,$02		; $6799
	jr @runSubidCode		; $679b

@state03:
	ldbc $02, <TX_0500		; $679d
	jr @runSubid0ScriptMode		; $67a0

@state04:
	ldbc $00, <TX_0503		; $67a2
	jr @runSubid0ScriptMode		; $67a5

@state05:
	ldbc $00, <TX_0505		; $67a7
	jr @runSubid0ScriptMode		; $67aa

@state06:
	ldbc $00, <TX_0507		; $67ac
	jr @runSubid0ScriptMode		; $67af

@state07:
	ldbc $04, <TX_0509		; $67b1
	jr @runSubid0ScriptMode		; $67b4

@state08:
	ldbc $04, <TX_050b		; $67b6
	jr @runSubid0ScriptMode		; $67b9

@state09:
	ldbc $02, <TX_050d		; $67bb
	jr @runSubid0ScriptMode		; $67be

@state0a:
	ldbc $00, <TX_0510		; $67c0
	jr @runSubid0ScriptMode		; $67c3

@state0b:
	ldbc $05, <TX_0512		; $67c5
	jr @runSubid0ScriptMode		; $67c8

@state0c:
	ldbc $04, <TX_0514		; $67ca
	jr @runSubid0ScriptMode		; $67cd

@state0d:
	ldbc $00, <TX_0516		; $67cf
	jr @runSubid0ScriptMode		; $67d2

@state0e:
	ld a,$06		; $67d4
	jr @runSubidCode		; $67d6

@state0f:
	ldbc $00, <TX_0518		; $67d8
	jr @runSubid0ScriptMode		; $67db

@state10:
	call checkIsLinkedGame		; $67dd
	jr z,++			; $67e0
	ldbc $00, <TX_051a		; $67e2
	jr @runSubid0ScriptMode		; $67e5
++
	ldbc $01, <TX_051c		; $67e7
	jr @runSubid0ScriptMode		; $67ea

@state01:
	pop af			; $67ec
	jp interactionDelete		; $67ed

@runSubidCode:
	ld e,Interaction.subid		; $67f0
	ld (de),a		; $67f2
	pop af			; $67f3
	jp interactionCode87		; $67f4

@runSubid0ScriptMode:
	ld h,d			; $67f7
	ld l,Interaction.var3e		; $67f8
	ld (hl),b		; $67fa
	inc l			; $67fb
	ld (hl),c		; $67fc
@ret:
	ret			; $67fd


@initializeMakuTree:
	call @initGraphicsAndLoadScript		; $67fe

@setVisibleAndSpawnFlower:
	call objectSetVisible83		; $6801
	call interactionSetAlwaysUpdateBit		; $6804
	jp @spawnMakuFlower		; $6807

@initGraphicsAndIncState:
	call @initGraphics		; $680a
	jp interactionIncState		; $680d

@initGraphicsAndLoadScript:
	call @initGraphics		; $6810
	jr @loadScript		; $6813

@initGraphics:
	call interactionLoadExtraGraphics		; $6815
	jp interactionInitGraphics		; $6818

@loadScript:
	ld a,>TX_0500		; $681b
	call interactionSetHighTextIndex		; $681d
	ld e,Interaction.subid		; $6820
	ld a,(de)		; $6822
	ld hl,@scriptTable		; $6823
	rst_addDoubleIndex			; $6826
	ldi a,(hl)		; $6827
	ld h,(hl)		; $6828
	ld l,a			; $6829
	call interactionSetScript		; $682a
	jp interactionIncState		; $682d

@spawnMakuFlower:
	call getFreeInteractionSlot		; $6830
	ret nz			; $6833
	ld (hl),INTERACID_MAKU_FLOWER		; $6834
	ld l,Interaction.relatedObj2		; $6836
	ld a,Interaction.start		; $6838
	ldi (hl),a		; $683a
	ld (hl),d		; $683b
	ld e,Interaction.relatedObj1		; $683c
	ld a,Interaction.start		; $683e
	ld (de),a		; $6840
	inc e			; $6841
	ld a,h			; $6842
	ld (de),a		; $6843
	jp objectCopyPosition		; $6844

@scriptTable:
	.dw makuTree_subid00Script
	.dw makuTree_subid01Script
	.dw makuTree_subid02Script
	.dw makuTree_subid03Script
	.dw makuTree_subid04Script
	.dw makuTree_subid05Script
	.dw makuTree_subid06Script_part3


; ==============================================================================
; INTERACID_MAKU_SPROUT
;
; Variables:
;   var3b: Animation
;   var3d: 0 for present maku tree, 1 for past?
;   var3e: "Script mode"; mainly determines animation (see makuSprout_subid00Script_body)
;   var3f: Text index to show for (sometimes shows the one after it as well)
; ==============================================================================
interactionCode88:
	ld e,Interaction.subid		; $6855
	ld a,(de)		; $6857
	rst_jumpTable			; $6858
	.dw @subid0
	.dw @subid1
	.dw @subid2

@subid0:
	call checkInteractionState		; $685f
	jr nz,@subid0State1	; $6862

	ld a,$01		; $6864
	ld e,Interaction.var3d		; $6866
	ld (de),a		; $6868

	call @initSubid0		; $6869
	call @initializeMakuSprout		; $686c

@subid0State1:
	call interactionAnimateAsNpc		; $686f
	ld e,Interaction.visible		; $6872
	ld a,(de)		; $6874
	and $8f			; $6875
	ld (de),a		; $6877
	jp interactionRunScript		; $6878

@subid1:
	call checkInteractionState		; $687b
	jr nz,@subid1State1	; $687e
	call @initializeMakuSprout		; $6880
	call interactionRunScript		; $6883

@subid1State1:
	jr @subid0State1		; $6886

@subid2:
	call checkInteractionState		; $6888
	jr nz,@subid2State1	; $688b

	call @initializeMakuSprout		; $688d
	ld a,$01		; $6890
	jp interactionSetAnimation		; $6892

@subid2State1:
	call checkInteractionState2		; $6895
	jp nz,interactionAnimate		; $6898

	ld a,(wTmpcfc0.genericCutscene.state)		; $689b
	cp $06			; $689e
	ret nz			; $68a0

	call interactionIncState2		; $68a1
	jp objectSetVisible82		; $68a4


@initSubid0:
	ld a,(wMakuTreeState)		; $68a7
	rst_jumpTable			; $68aa
	.dw @state00
	.dw @state01
	.dw @state02
	.dw @state03
	.dw @state04
	.dw @state05
	.dw @state06
	.dw @state07
	.dw @state08
	.dw @state09
	.dw @state0a
	.dw @state0b
	.dw @state0c
	.dw @state0d
	.dw @state0e
	.dw @state0f
	.dw @state10

@state01:
@state02:
	ld a,$01		; $68cd
	jr @runSubidCode	; $68cf

@state03:
@state04:
@state05:
	ldbc $01, <TX_0570		; $68d1
	jr @runSubid0ScriptMode		; $68d4

@state06:
	ldbc $00, <TX_0576		; $68d6
	jr @runSubid0ScriptMode		; $68d9

@state07:
	ldbc $00, <TX_0578		; $68db
	jr @runSubid0ScriptMode		; $68de

@state08:
	ldbc $02, <TX_057a		; $68e0
	jr @runSubid0ScriptMode		; $68e3

@state09:
	ldbc $01, <TX_057c		; $68e5
	jr @runSubid0ScriptMode		; $68e8

@state0a:
	ldbc $01, <TX_057e		; $68ea
	jr @runSubid0ScriptMode		; $68ed

@state0b:
	ldbc $00, <TX_0580		; $68ef
	jr @runSubid0ScriptMode		; $68f2

@state0c:
	ldbc $00, <TX_0582		; $68f4
	jr @runSubid0ScriptMode		; $68f7

@state0d:
	ldbc $01, <TX_0584		; $68f9
	jr @runSubid0ScriptMode		; $68fc

@state0e:
	ldbc $01, <TX_0586		; $68fe
	jr @runSubid0ScriptMode		; $6901

@state0f:
	ldbc $02, <TX_0588		; $6903
	jr @runSubid0ScriptMode		; $6906

@state10:
	call checkIsLinkedGame		; $6908
	jr z,++			; $690b

	ldbc $00, <TX_058a		; $690d
	jr @runSubid0ScriptMode		; $6910
++
	ldbc $01, <TX_058c		; $6912
	jr @runSubid0ScriptMode		; $6915

@runSubidCode:
	ld e,Interaction.subid		; $6917
	ld (de),a		; $6919
	pop af			; $691a
	jp interactionCode88		; $691b

@runSubid0ScriptMode:
	ld h,d			; $691e
	ld l,Interaction.var3e		; $691f
	ld (hl),b		; $6921
	inc l			; $6922
	ld (hl),c		; $6923

@state00:
	ret			; $6924


@initializeMakuSprout:
	call @loadScriptAndInitGraphics		; $6925
	jp interactionSetAlwaysUpdateBit		; $6928


@initGraphics: ; unused
	call interactionInitGraphics		; $692b
	jp interactionIncState		; $692e


@loadScriptAndInitGraphics:
	call interactionInitGraphics		; $6931
	ld a,>TX_0500		; $6934
	call interactionSetHighTextIndex		; $6936
	ld e,Interaction.subid		; $6939
	ld a,(de)		; $693b
	ld hl,@scriptTable		; $693c
	rst_addDoubleIndex			; $693f
	ldi a,(hl)		; $6940
	ld h,(hl)		; $6941
	ld l,a			; $6942
	call interactionSetScript		; $6943
	jp interactionIncState		; $6946

@scriptTable:
	.dw makuSprout_subid00Script
	.dw makuSprout_subid01Script
	.dw stubScript


; ==============================================================================
; INTERACID_REMOTE_MAKU_CUTSCENE
;
; Variables:
;   var3e: Doesn't do anything
;   var3f: Text to show
; ==============================================================================
interactionCode8a:
	ld e,Interaction.subid		; $694f
	ld a,(de)		; $6951
	rst_jumpTable			; $6952
	.dw @subid0
	.dw @subid1

@subid0:
@subid1:
	call checkInteractionState		; $6957
	jr nz,@state1	; $695a

@state0:
	call returnIfScrollMode01Unset		; $695c
	ld e,Interaction.subid		; $695f
	ld a,(de)		; $6961
	ld e,Interaction.var3d		; $6962
	ld (de),a		; $6964
	call @checkConditionsAndSetText		; $6965
	call getThisRoomFlags		; $6968
	and $40			; $696b
	jp nz,interactionDelete		; $696d

	call @loadScript		; $6970

@state1:
	call interactionRunScript		; $6973
	jp c,interactionDelete		; $6976
	ret			; $6979

@checkConditionsAndSetText:
	ld e,Interaction.var03		; $697a
	ld a,(de)		; $697c
	rst_jumpTable			; $697d
	.dw @val00
	.dw @val01
	.dw @val02
	.dw @val03
	.dw @val04
	.dw @val05
	.dw @val06
	.dw @val07
	.dw @val08
	.dw @val09
	.dw @val0a
	.dw @val0b

@val00:
	xor a			; $6996
	call @checkEssenceObtained		; $6997
	jp z,@deleteSelfAndReturn		; $699a
	ldbc $00, <TX_05b0		; $699d
	jp @setTextForScript		; $69a0

@val01:
	ldbc $00, <TX_05b1		; $69a3
	jp @setTextForScript		; $69a6

@val02:
	ld a,TREASURE_HARP		; $69a9
	call checkTreasureObtained		; $69ab
	jp nc,@deleteSelfAndReturn		; $69ae
	ldbc $00, <TX_05b2		; $69b1
	jp @setTextForScript		; $69b4

@val03:
	ld a,$01		; $69b7
	call @checkEssenceObtained		; $69b9
	jp z,@deleteSelfAndReturn		; $69bc
	ldbc $00, <TX_05b3		; $69bf
	jp @setTextForScript		; $69c2

@val04:
	ld a,$02		; $69c5
	call @checkEssenceObtained		; $69c7
	jp z,@deleteSelfAndReturn		; $69ca

	ld hl,wPastRoomFlags+$76		; $69cd
	set 0,(hl)		; $69d0
	call checkIsLinkedGame		; $69d2
	ld a,GLOBALFLAG_CAN_BUY_FLUTE		; $69d5
	call z,setGlobalFlag		; $69d7
	ldbc $00, <TX_05b4		; $69da
	jp @setTextForScript		; $69dd

@val05:
	ld a,$03		; $69e0
	call @checkEssenceObtained		; $69e2
	jp z,@deleteSelfAndReturn		; $69e5
	ldbc $00, <TX_05b5		; $69e8
	jp @setTextForScript		; $69eb

@val06:
	ld a,GLOBALFLAG_MOBLINS_KEEP_DESTROYED		; $69ee
	call checkGlobalFlag		; $69f0
	jp z,@deleteSelfAndReturn		; $69f3
	ldbc $00, <TX_05b6		; $69f6
	jp @setTextForScript		; $69f9

@val07:
	ld a,$04		; $69fc
	call @checkEssenceObtained		; $69fe
	jp z,@deleteSelfAndReturn		; $6a01
	ldbc $00, <TX_05b7		; $6a04
	jp @setTextForScript		; $6a07

@val08:
	ld a,$05		; $6a0a
	call @checkEssenceObtained		; $6a0c
	jp z,@deleteSelfAndReturn		; $6a0f
	ldbc $00, <TX_05b8		; $6a12
	jp @setTextForScript		; $6a15

@val09:
	ld a,$06		; $6a18
	call @checkEssenceObtained		; $6a1a
	jp z,@deleteSelfAndReturn		; $6a1d
	ldbc $00, <TX_05b9		; $6a20
	jp @setTextForScript		; $6a23

@val0a:
	ld a,$07		; $6a26
	call @checkEssenceObtained		; $6a28
	jp z,@deleteSelfAndReturn		; $6a2b
	ldbc $00, <TX_05ba		; $6a2e
	jp @setTextForScript		; $6a31

@val0b:
	ldbc $00, <TX_05bb		; $6a34
	jp @setTextForScript		; $6a37


@deleteSelfAndReturn:
	pop af			; $6a3a
	jp interactionDelete		; $6a3b

@setTextForScript:
	ld h,d			; $6a3e
	ld l,Interaction.var3e		; $6a3f
	ld (hl),b		; $6a41
	inc l			; $6a42
	ld (hl),c		; $6a43
	ret			; $6a44

;;
; @param	a	Essence number
; @addr{6a45}
@checkEssenceObtained:
	ld hl,wEssencesObtained		; $6a45
	jp checkFlag		; $6a48


@initGraphicsAndIncState: ; Unused
	call interactionInitGraphics		; $6a4b
	jp interactionIncState		; $6a4e

@initGraphicsAndLoadScript: ; Unused
	call interactionInitGraphics		; $6a51

@loadScript:
	ld a,>TX_0500		; $6a54
	call interactionSetHighTextIndex		; $6a56
	ld e,Interaction.subid		; $6a59
	ld a,(de)		; $6a5b
	ld hl,@scriptTable		; $6a5c
	rst_addDoubleIndex			; $6a5f
	ldi a,(hl)		; $6a60
	ld h,(hl)		; $6a61
	ld l,a			; $6a62
	call interactionSetScript		; $6a63
	jp interactionIncState		; $6a66

@scriptTable:
	.dw remoteMakuCutsceneScript
	.dw remoteMakuCutsceneScript


; ==============================================================================
; INTERACID_GORON_ELDER
;
; Variables:
;   var3f: If zero, elder should face Link when he's close?
; ==============================================================================
interactionCode8b:
	ld e,Interaction.subid		; $6a6d
	ld a,(de)		; $6a6f
	rst_jumpTable			; $6a70
	.dw @subid0
	.dw @subid1
	.dw @subid2

@subid0:
@subid1:
	call checkInteractionState		; $6a77
	jr nz,++			; $6a7a
	call @loadScriptAndInitGraphics		; $6a7c
++
	call interactionRunScript		; $6a7f
	jp c,interactionDelete		; $6a82
	ld e,Interaction.var3f		; $6a85
	ld a,(de)		; $6a87
	or a			; $6a88
	jp z,npcFaceLinkAndAnimate		; $6a89
	jp interactionAnimateAsNpc		; $6a8c

@subid2:
	ld a,GLOBALFLAG_FINISHEDGAME		; $6a8f
	call checkGlobalFlag		; $6a91
	jp z,interactionDelete		; $6a94
	jpab interactionBank1.shootingGalleryNpc		; $6a97


@initGraphics: ; unused
	call interactionInitGraphics		; $6a9f
	jp interactionIncState		; $6aa2


@loadScriptAndInitGraphics:
	call interactionInitGraphics		; $6aa5
	ld e,Interaction.subid		; $6aa8
	ld a,(de)		; $6aaa
	ld hl,@scriptTable		; $6aab
	rst_addDoubleIndex			; $6aae
	ldi a,(hl)		; $6aaf
	ld h,(hl)		; $6ab0
	ld l,a			; $6ab1
	call interactionSetScript		; $6ab2
	jp interactionIncState		; $6ab5

@scriptTable:
	.dw goronElderScript_subid00
	.dw goronElderScript_subid01


; ==============================================================================
; INTERACID_TOKAY_MEAT
; ==============================================================================
interactionCode8c:
	ld e,Interaction.state		; $6abc
	ld a,(de)		; $6abe
	rst_jumpTable			; $6abf
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3

@state0:
	call interactionInitGraphics		; $6ac8
	call interactionIncState		; $6acb
	ld l,Interaction.counter1		; $6ace
	ld (hl),30		; $6ad0
	ld a,$08		; $6ad2
	call objectSetCollideRadius		; $6ad4

	ld bc,$3850		; $6ad7
	call interactionSetPosition		; $6ada
	ld l,Interaction.zh		; $6add
	ld (hl),-$40		; $6adf
	ld bc,$0000		; $6ae1
	jp objectSetSpeedZ		; $6ae4


@state1:
	call objectAddToGrabbableObjectBuffer		; $6ae7
	ld e,Interaction.state2		; $6aea
	ld a,(de)		; $6aec
	rst_jumpTable			; $6aed
	.dw @@substate0
	.dw @@substate1
	.dw @@substate2

@@substate0: ; Starts falling
	ld h,d			; $6af4
	ld l,Interaction.counter1		; $6af5
	ld a,(hl)		; $6af7
	or a			; $6af8
	jp nz,interactionDecCounter1		; $6af9
	call interactionIncState2		; $6afc
	call objectSetVisiblec1		; $6aff
	ld a,SND_FALLINHOLE		; $6b02
	jp playSound		; $6b04

@@substate1: ; Wait for it to land
	ld c,$28		; $6b07
	call objectUpdateSpeedZ_paramC		; $6b09
	ret nz			; $6b0c
	call interactionIncState2		; $6b0d
	ld a,SND_BOMB_LAND		; $6b10
	jp playSound		; $6b12

@@substate2: ; Sitting on the ground
	jp objectSetPriorityRelativeToLink_withTerrainEffects		; $6b15


; State 2 = grabbed by power bracelet state
@state2:
	inc e			; $6b18
	ld a,(de)		; $6b19
	rst_jumpTable			; $6b1a
	.dw @justGrabbed
	.dw @beingHeld
	.dw @released

@justGrabbed:
	ld a,d			; $6b21
	ld (wTmpcfc0.wildTokay.activeMeatObject),a		; $6b22
	ld a,e			; $6b25
	ld (wTmpcfc0.wildTokay.activeMeatObject+1),a		; $6b26

	call getFreeInteractionSlot		; $6b29
	ret nz			; $6b2c
	ld (hl),INTERACID_TOKAY_MEAT		; $6b2d
	jp interactionIncState2		; $6b2f

@beingHeld:
	ret			; $6b32

@released:
	ld e,Interaction.zh		; $6b33
	ld a,(de)		; $6b35
	rlca			; $6b36
	ret c			; $6b37

	call dropLinkHeldItem		; $6b38
	call interactionIncState		; $6b3b
	ld l,Interaction.counter1		; $6b3e
	ld (hl),20		; $6b40
	jp objectSetVisible83		; $6b42


@state3: ; Disappearing after being dropped on the ground
	call interactionDecCounter1		; $6b45
	jr nz,+			; $6b48
	jp interactionDelete		; $6b4a
+
	ld a,(wFrameCounter)		; $6b4d
	and $01			; $6b50
	jp z,objectSetInvisible		; $6b52
	jp objectSetPriorityRelativeToLink		; $6b55


; ==============================================================================
; INTERACID_CLOAKED_TWINROVA
; ==============================================================================
interactionCode8d:
	ld e,Interaction.state		; $6b58
	ld a,(de)		; $6b5a
	rst_jumpTable			; $6b5b
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $6b60
	ld (de),a		; $6b62
	call interactionInitGraphics		; $6b63
	call objectSetVisiblec2		; $6b66
	ld a,>TX_2800		; $6b69
	call interactionSetHighTextIndex		; $6b6b

	ld e,Interaction.subid		; $6b6e
	ld a,(de)		; $6b70
	rst_jumpTable			; $6b71
	.dw @initSubid0
	.dw @initSubid1
	.dw @initSubid2

@initSubid0:
	ld a,$03		; $6b78
	call interactionSetAnimation		; $6b7a
	ld bc,$4088		; $6b7d
	call interactionSetPosition		; $6b80

@initSubid2:
	call @loadScript		; $6b83
	jp objectSetInvisible		; $6b86

@initSubid1:
	ld bc,$4050		; $6b89
	call interactionSetPosition		; $6b8c
	ld l,Interaction.counter1		; $6b8f
	ld (hl),30		; $6b91
	jp objectSetInvisible		; $6b93


@state1:
	ld e,Interaction.subid		; $6b96
	ld a,(de)		; $6b98
	rst_jumpTable			; $6b99
	.dw @runSubid0
	.dw @runSubid1
	.dw @runSubid0

@runSubid0:
@runSubid2:
	call interactionRunScript		; $6ba0
	jp nc,interactionAnimate		; $6ba3

	call objectCreatePuff		; $6ba6

	; Subid 2 only: when done the script, create the "real" twinrova objects
	ld e,Interaction.subid		; $6ba9
	ld a,(de)		; $6bab
	or a			; $6bac
	jr z,++			; $6bad
	ldbc INTERACID_TWINROVA, $02		; $6baf
	call objectCreateInteraction		; $6bb2
++
	jp interactionDelete		; $6bb5


; Cutscene after d7; black tower is complete
@runSubid1:
	call interactionAnimate		; $6bb8
	ld e,Interaction.state2		; $6bbb
	ld a,(de)		; $6bbd
	rst_jumpTable			; $6bbe
	.dw @subid1Substate0
	.dw @subid1Substate1
	.dw @subid1Substate2
	.dw @subid1Substate3

@subid1Substate0:
	call interactionDecCounter1		; $6bc7
	ret nz			; $6bca
	ld (hl),20		; $6bcb
	ld a,MUS_DISASTER		; $6bcd
	call playSound		; $6bcf
	call objectSetVisible		; $6bd2
	call fadeinFromBlack		; $6bd5
	ld a,$06		; $6bd8
	ld (wDirtyFadeSprPalettes),a		; $6bda
	ld (wFadeSprPaletteSources),a		; $6bdd
	ld a,$03		; $6be0
	ld (wDirtyFadeBgPalettes),a		; $6be2
	ld (wFadeBgPaletteSources),a		; $6be5
	jp interactionIncState2		; $6be8

@subid1Substate1:
	call interactionDecCounter1IfPaletteNotFading		; $6beb
	ret nz			; $6bee
	ld (hl),20		; $6bef
	call interactionIncState2		; $6bf1
	ld bc,TX_2808		; $6bf4
	jp showText		; $6bf7

@subid1Substate2:
	call interactionDecCounter1IfTextNotActive		; $6bfa
	ret nz			; $6bfd
	ld a,SND_LIGHTNING		; $6bfe
	call playSound		; $6c00
	ld hl,wGenericCutscene.cbb3		; $6c03
	ld (hl),$00		; $6c06
	ld hl,wGenericCutscene.cbba		; $6c08
	ld (hl),$ff		; $6c0b
	jp interactionIncState2		; $6c0d

@subid1Substate3:
	ld hl,wGenericCutscene.cbb3		; $6c10
	ld b,$02		; $6c13
	call flashScreen		; $6c15
	ret z			; $6c18
	ld a,$02		; $6c19
	ld (wGenericCutscene.cbb8),a		; $6c1b
	ld a,CUTSCENE_BLACK_TOWER_EXPLANATION		; $6c1e
	ld (wCutsceneTrigger),a		; $6c20
	jp interactionDelete		; $6c23


@loadScript:
	ld e,Interaction.subid		; $6c26
	ld a,(de)		; $6c28
	ld hl,@scriptTable		; $6c29
	rst_addDoubleIndex			; $6c2c
	ldi a,(hl)		; $6c2d
	ld h,(hl)		; $6c2e
	ld l,a			; $6c2f
	jp interactionSetScript		; $6c30

@scriptTable:
	.dw cloakedTwinrova_subid00Script
	.dw stubScript
	.dw cloakedTwinrova_subid02Script


; ==============================================================================
; INTERACID_OCTOGON_SPLASH
; ==============================================================================
interactionCode8e:
	ld e,Interaction.state		; $6c39
	ld a,(de)		; $6c3b
	or a			; $6c3c
	jr z,@state0	; $6c3d

@state1:
	ld e,Interaction.animParameter		; $6c3f
	ld a,(de)		; $6c41
	inc a			; $6c42
	jp nz,interactionAnimate		; $6c43
	jp interactionDelete		; $6c46

@state0:
	call interactionInitGraphics		; $6c49
	call interactionIncState		; $6c4c
	ld l,Interaction.direction		; $6c4f
	ld a,(hl)		; $6c51
	rrca			; $6c52
	rrca			; $6c53
	call interactionSetAnimation		; $6c54
	jp objectSetVisible81		; $6c57


; ==============================================================================
; INTERACID_TOKAY_CUTSCENE_EMBER_SEED
; ==============================================================================
interactionCode8f:
	ld e,Interaction.state		; $6c5a
	ld a,(de)		; $6c5c
	rst_jumpTable			; $6c5d
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3

@state0:
	ld a,$01		; $6c66
	ld (de),a		; $6c68
	ld bc,-$100		; $6c69
	call objectSetSpeedZ		; $6c6c
	call interactionInitGraphics		; $6c6f
	call interactionSetAlwaysUpdateBit		; $6c72
	jp objectSetVisible80		; $6c75

@state1:
	ld c,$10		; $6c78
	call objectUpdateSpeedZ_paramC		; $6c7a
	ret nz			; $6c7d

	call objectSetInvisible		; $6c7e
	ld a,(wTextIsActive)		; $6c81
	or a			; $6c84
	ret z			; $6c85

	ld l,Interaction.state		; $6c86
	inc (hl)		; $6c88
	ret			; $6c89

@state2:
	call retIfTextIsActive		; $6c8a
	call interactionIncState		; $6c8d

	ld l,Interaction.oamFlagsBackup		; $6c90
	ld a,$0a		; $6c92
	ldi (hl),a		; $6c94
	ldi (hl),a		; $6c95
	ld (hl),$06 ; [oamTileIndexBase] = $06

	ld l,Interaction.counter1		; $6c98
	ld (hl),58		; $6c9a
	ld a,$0b		; $6c9c
	call interactionSetAnimation		; $6c9e
	jp objectSetVisible		; $6ca1

@state3:
	call interactionAnimate		; $6ca4
	call interactionDecCounter1		; $6ca7
	ret nz			; $6caa
	jp interactionDelete		; $6cab


; ==============================================================================
; INTERACID_MISC_PUZZLES
; ==============================================================================
interactionCode90:
	ld e,Interaction.subid		; $6cae
	ld a,(de)		; $6cb0
	rst_jumpTable			; $6cb1
	.dw _miscPuzzles_subid00
	.dw _miscPuzzles_subid01
	.dw _miscPuzzles_subid02
	.dw _miscPuzzles_subid03
	.dw _miscPuzzles_subid04
	.dw _miscPuzzles_subid05
	.dw _miscPuzzles_subid06
	.dw _miscPuzzles_subid07
	.dw _miscPuzzles_subid08
	.dw _miscPuzzles_subid09
	.dw _miscPuzzles_subid0a
	.dw _miscPuzzles_subid0b
	.dw _miscPuzzles_subid0c
	.dw _miscPuzzles_subid0d
	.dw _miscPuzzles_subid0e
	.dw _miscPuzzles_subid0f
	.dw _miscPuzzles_subid10
	.dw _miscPuzzles_subid11
	.dw _miscPuzzles_subid12
	.dw _miscPuzzles_subid13
	.dw _miscPuzzles_subid14
	.dw _miscPuzzles_subid15
	.dw _miscPuzzles_subid16
	.dw _miscPuzzles_subid17
	.dw _miscPuzzles_subid18
	.dw _miscPuzzles_subid19
	.dw _miscPuzzles_subid1a
	.dw _miscPuzzles_subid1b
	.dw _miscPuzzles_subid1c
	.dw _miscPuzzles_subid1d
	.dw _miscPuzzles_subid1e
	.dw _miscPuzzles_subid1f
	.dw _miscPuzzles_subid20
	.dw _miscPuzzles_subid21


; Boss key puzzle in D6
_miscPuzzles_subid00:
	ld e,Interaction.state		; $6cf6
	ld a,(de)		; $6cf8
	rst_jumpTable			; $6cf9
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3

; State 0: initialization
@state0:
	call interactionIncState		; $6d02

; State 1: waiting for a lever to be pulled
@state1:
	; Return if a lever has not been pulled?
	ld hl,wLever1PullDistance		; $6d05
	bit 7,(hl)		; $6d08
	jr nz,+			; $6d0a
	inc l			; $6d0c
	bit 7,(hl)		; $6d0d
	ret z			; $6d0f
+
	; Check if the chest has already been opened
	call getThisRoomFlags		; $6d10
	and ROOMFLAG_ITEM			; $6d13
	jr nz,@alreadyOpened	; $6d15

	; Go to state 2 (or possibly 3, if this gets called again)
	call interactionIncState		; $6d17

	; Check whether this is the first time pulling the lever
	ld l,Interaction.counter2		; $6d1a
	ld a,(hl)		; $6d1c
	or a			; $6d1d
	jr nz,@checkRng		; $6d1e

	; This was the first time pulling the lever; always unsuccessful
	ld (hl),$01		; $6d20
	jr @error		; $6d22

@checkRng:
	; Get a number between 0 and 3.
	call getRandomNumber		; $6d24
	and $03			; $6d27

	; If the number is 0, the chest will appear; go to state 3.
	jp z,interactionIncState		; $6d29

	; If the number is 1-3, make the snakes appear.
@error:
	ld a,SND_ERROR		; $6d2c
	call playSound		; $6d2e

	ld a,(wActiveTilePos)		; $6d31
	ld (wWarpDestPos),a		; $6d34

	ld hl,wTmpcec0		; $6d37
	ld b,$20		; $6d3a
	call clearMemory		; $6d3c

	callab bank2.generateRandomBuffer		; $6d3f

	; Spawn the snakes?
	ld hl,objectData.objectData78db		; $6d47
	jp parseGivenObjectData		; $6d4a

; State 2: lever has been pulled unsuccessfully. Wait for snakes to be killed before
; returning to state 1.
@state2:
	ld a,(wNumEnemies)		; $6d4d
	or a			; $6d50
	ret nz			; $6d51

	; Go back to state 1
	ld a,$01		; $6d52
	ld e,Interaction.state		; $6d54
	ld (de),a		; $6d56
	ret			; $6d57

; State 3: lever has been pulled successfully. Make the chest and delete self.
@state3:
	ld a,$01		; $6d58
	ld (wActiveTriggers),a		; $6d5a
	jpab interactionBank1.spawnChestAndDeleteSelf		; $6d5d

@alreadyOpened:
	ld a,$01		; $6d65
	ld (wActiveTriggers),a		; $6d67
	jp interactionDelete		; $6d6a



; Underwater switch hook puzzle in past d6
_miscPuzzles_subid01:
	call interactionDeleteAndRetIfEnabled02		; $6d6d
	call _miscPuzzles_deleteSelfAndRetIfItemFlagSet		; $6d70

	ld hl,@diamondPositions		; $6d73
	call _miscPuzzles_verifyTilesAtPositions		; $6d76
	ret nz			; $6d79
	jpab interactionBank1.spawnChestAndDeleteSelf		; $6d7a

@diamondPositions:
	.db TILEINDEX_SWITCH_DIAMOND
	.db $16 $17 $18
	.db $26 $27 $28
	.db $00



; Spot to put a rolling colored block on in present d6
_miscPuzzles_subid02:
	call interactionDeleteAndRetIfEnabled02		; $6d8a

	; Check that the tile at this position matches the cube color
	call objectGetTileAtPosition		; $6d8d
	sub TILEINDEX_RED_TOGGLE_FLOOR			; $6d90
	ld b,a			; $6d92
	ld a,(wRotatingCubePos)		; $6d93
	cp l			; $6d96
	ret nz			; $6d97
	ld a,(wRotatingCubeColor)		; $6d98
	and $03			; $6d9b
	cp b			; $6d9d
	ret nz			; $6d9e

	; They match.
	ld c,l			; $6d9f
	ld a,TILEINDEX_STANDARD_FLOOR		; $6da0
	call setTile		; $6da2
	ld b,>wRoomCollisions		; $6da5
	ld a,$0f		; $6da7
	ld (bc),a		; $6da9
	ld a,SND_SOLVEPUZZLE		; $6daa
	call playSound		; $6dac
	jp interactionDelete		; $6daf



; Chest from solving colored cube puzzle in d6 (related to subid $02)
_miscPuzzles_subid03:
	call interactionDeleteAndRetIfEnabled02		; $6db2
	call _miscPuzzles_deleteSelfAndRetIfItemFlagSet		; $6db5

	ld hl,@wantedFloorTiles		; $6db8
	call _miscPuzzles_verifyTilesAtPositions		; $6dbb
	ret nz			; $6dbe
	jpab interactionBank1.spawnChestAndDeleteSelf		; $6dbf

@wantedFloorTiles:
	.db TILEINDEX_STANDARD_FLOOR
	.db $37 $65 $69
	.db $00

;;
; @param	hl	Pointer to data. First byte is a tile index; then an arbitrary
;			number of positions in the room where that tile should be; $ff to
;			give a new tile index; $00 to stop.
; @param[out]	zflag	z if all tiles matched as expected.
; @addr{6dcc}
_miscPuzzles_verifyTilesAtPositions:
	ld b,>wRoomLayout		; $6dcc
@newTileIndex:
	ldi a,(hl)		; $6dce
	or a			; $6dcf
	ret z			; $6dd0
	ld e,a			; $6dd1
@nextTile:
	ldi a,(hl)		; $6dd2
	ld c,a			; $6dd3
	or a			; $6dd4
	ret z			; $6dd5
	inc a			; $6dd6
	jr z,@newTileIndex		; $6dd7
	ld a,(bc)		; $6dd9
	cp e			; $6dda
	ret nz			; $6ddb
	jr @nextTile		; $6ddc



; Floor changer in present D6, triggered by orb
_miscPuzzles_subid04:
	call checkInteractionState		; $6dde
	jr z,@state0	; $6de1

@state1:
	; Check for change in state
	ld a,(wToggleBlocksState)		; $6de3
	ld b,a			; $6de6
	ld e,Interaction.counter2		; $6de7
	ld a,(de)		; $6de9
	cp b			; $6dea
	ret z			; $6deb

	ld a,b			; $6dec
	ld (de),a		; $6ded
	ld a,$ff		; $6dee
	ld (wDisabledObjects),a		; $6df0
	ld (wMenuDisabled),a		; $6df3

	ld e,Interaction.counter1		; $6df6
	ld a,(de)		; $6df8
	inc a			; $6df9
	and $01			; $6dfa
	ld b,a			; $6dfc
	ld (de),a		; $6dfd

	ld c,$05		; $6dfe
	call @spawnSubid		; $6e00
	ld c,$06		; $6e03
	call @spawnSubid		; $6e05
	callab bank16.loadD6ChangingFloorPatternToBigBuffer		; $6e08
	ret			; $6e10

@spawnSubid:
	call getFreeInteractionSlot		; $6e11
	ret nz			; $6e14
	ld (hl),INTERACID_MISC_PUZZLES		; $6e15
	inc l			; $6e17
	ld (hl),c		; $6e18
	inc l			; $6e19
	ld (hl),b		; $6e1a
	ret			; $6e1b

@state0:
	ld a,(wToggleBlocksState)		; $6e1c
	ld e,Interaction.counter2		; $6e1f
	ld (de),a		; $6e21
	jp interactionIncState		; $6e22


; Helpers for floor changer (subid $04)
_miscPuzzles_subid05:
_miscPuzzles_subid06:
	ld e,Interaction.state2		; $6e25
	ld a,(de)		; $6e27
	or a			; $6e28
	jr nz,@substate1	; $6e29

@substate0:
	ld e,Interaction.subid		; $6e2b
	ld a,(de)		; $6e2d
	sub $05			; $6e2e
	add a			; $6e30
	ld hl,@data		; $6e31
	rst_addDoubleIndex			; $6e34
	ld b,$04		; $6e35
	ld e,Interaction.var30		; $6e37
	call copyMemory		; $6e39
	jp interactionIncState2		; $6e3c

; Values for var30-var33
; var30: Start position
; var31: Value to add to position (Y) (alternates direction each column)
; var32: Value to add to position (X)
; var33: Offset in wBigBuffer to read from
@data:
	.db $91 $f0 $01 $00 ; subid 5
	.db $1d $10 $ff $80 ; subid 6

@substate1:
	ld e,Interaction.var33		; $6e47
	ld a,(de)		; $6e49
	ld l,a			; $6e4a
	ld h,>wBigBuffer		; $6e4b

@nextTile:
	ldi a,(hl)		; $6e4d
	or a			; $6e4e
	jr z,@deleteSelf	; $6e4f
	cp $ff			; $6e51
	jr nz,@setTile	; $6e53

	ld e,Interaction.var32		; $6e55
	ld a,(de)		; $6e57
	ld b,a			; $6e58
	ld e,Interaction.var30		; $6e59
	ld a,(de)		; $6e5b
	add b			; $6e5c
	ld (de),a		; $6e5d
	ld e,Interaction.var31		; $6e5e
	ld a,(de)		; $6e60
	cpl			; $6e61
	inc a			; $6e62
	ld (de),a		; $6e63
	call @nextRow		; $6e64
	jr @nextTile		; $6e67

@setTile:
	ldh (<hFF8B),a	; $6e69
	ld e,Interaction.var33		; $6e6b
	ld a,l			; $6e6d
	ld (de),a		; $6e6e
	call @nextRow		; $6e6f
	ldh a,(<hFF8B)	; $6e72
	jp setTile		; $6e74

; [var30] += [var31]
@nextRow:
	ld e,Interaction.var31		; $6e77
	ld a,(de)		; $6e79
	ld b,a			; $6e7a
	ld e,Interaction.var30		; $6e7b
	ld a,(de)		; $6e7d
	ld c,a			; $6e7e
	add b			; $6e7f
	ld (de),a		; $6e80
	ret			; $6e81

@deleteSelf:
	xor a			; $6e82
	ld (wDisabledObjects),a		; $6e83
	ld (wMenuDisabled),a		; $6e86
	jp interactionDelete		; $6e89



; Wall retraction event after lighting torches in past d6
_miscPuzzles_subid07:
	call checkInteractionState		; $6e8c
	jr z,@state0	; $6e8f

@state1:
	call checkLinkVulnerable		; $6e91
	ret nc			; $6e94

	; Check if the number of lit torches has changed.
	call @checkLitTorches		; $6e95
	ld e,Interaction.counter1		; $6e98
	ld a,(de)		; $6e9a
	cp b			; $6e9b
	ret z			; $6e9c

	; It's changed.
	ld a,b			; $6e9d
	ld (de),a		; $6e9e

	ld e,Interaction.state2		; $6e9f
	ld a,(de)		; $6ea1
	ld hl,@torchLightOrder		; $6ea2
	rst_addAToHl			; $6ea5
	ld a,(hl)		; $6ea6
	cp b			; $6ea7
	jr nz,@litWrongTorch	; $6ea8

	ld a,(de)		; $6eaa
	cp $03			; $6eab
	jp c,interactionIncState2		; $6ead

	; Lit all torches
	ld a, $ff ~ (DISABLE_ITEMS | DISABLE_ALL_BUT_INTERACTIONS)
	ld (wDisabledObjects),a		; $6eb2
	ld (wMenuDisabled),a		; $6eb5

	ld a,CUTSCENE_WALL_RETRACTION		; $7eb8
	ld (wCutsceneTrigger),a		; $6eba

	; Set bit 6 in the present version of this room
	call getThisRoomFlags		; $6ebd
	ld l,<ROOM_525		; $6ec0
	set 6,(hl)		; $6ec2
	jp interactionDelete		; $6ec4

@litWrongTorch:
	xor a			; $6ec7
	ld (de),a		; $6ec8
	ld e,Interaction.counter1		; $6ec9
	ld (de),a		; $6ecb
	ld a,SND_ERROR		; $6ecc
	call playSound		; $6ece
	ld a,TILEINDEX_UNLIT_TORCH		; $6ed1
	ld c,$31		; $6ed3
	call setTile		; $6ed5
	ld a,TILEINDEX_UNLIT_TORCH		; $6ed8
	ld c,$33		; $6eda
	call setTile		; $6edc
	ld a,TILEINDEX_UNLIT_TORCH		; $6edf
	ld c,$35		; $6ee1
	call setTile		; $6ee3
	ld a,TILEINDEX_UNLIT_TORCH		; $6ee6
	ld c,$53		; $6ee8
	call setTile		; $6eea
	jr @makeTorchesLightable		; $6eed

@torchLightOrder:
	.db $01 $03 $07 $0f

@state0:
	call getThisRoomFlags		; $6ef3
	and ROOMFLAG_80			; $6ef6
	jp nz,interactionDelete		; $6ef8

	call interactionIncState		; $6efb
	call @checkLitTorches		; $6efe
	ld a,b			; $6f01
	ld e,Interaction.counter1		; $6f02
	ld (de),a		; $6f04

@makeTorchesLightable:
	call @makeTorchesUnlightable		; $6f05
	ld hl,objectData.objectData_makeTorchesLightableForD6Room		; $6f08
	jp parseGivenObjectData		; $6f0b

;;
; @addr{6f0e}
@makeTorchesUnlightable:
	ldhl FIRST_PART_INDEX, Part.id		; $6f0e
--
	ld a,(hl)		; $6f11
	cp PARTID_06			; $6f12
	call z,@deletePartObject		; $6f14
	inc h			; $6f17
	ld a,h			; $6f18
	cp LAST_PART_INDEX+1			; $6f19
	jr c,--			; $6f1b
	ret			; $6f1d

@deletePartObject:
	push hl			; $6f1e
	dec l			; $6f1f
	ld b,$40		; $6f20
	call clearMemory		; $6f22
	pop hl			; $6f25
	ret			; $6f26

;;
; @param[out]	b	Bitset of lit torches (in bits 0-3)
; @addr{6f27}
@checkLitTorches:
	ld a,TILEINDEX_LIT_TORCH		; $6f27
	ld b,$00		; $6f29
	ld hl,wRoomLayout+$31		; $6f2b
	cp (hl)			; $6f2e
	jr nz,+			; $6f2f
	set 0,b			; $6f31
+
	ld l,$33		; $6f33
	cp (hl)			; $6f35
	jr nz,+			; $6f36
	set 1,b			; $6f38
+
	ld l,$53		; $6f3a
	cp (hl)			; $6f3c
	jr nz,+			; $6f3d
	set 2,b			; $6f3f
+
	ld l,$35		; $6f41
	cp (hl)			; $6f43
	ret nz			; $6f44
	set 3,b			; $6f45
	ret			; $6f47



; Checks to set the "bombable wall open" bit in d6 (north)
_miscPuzzles_subid08:
	call interactionDeleteAndRetIfEnabled02		; $6f48
	call getThisRoomFlags		; $6f4b
	bit ROOMFLAG_BIT_KEYDOOR_UP,(hl)		; $6f4e
	ret z			; $6f50
	ld l,<ROOM_519		; $6f51
	set ROOMFLAG_BIT_KEYDOOR_UP,(hl)		; $6f53
	jp interactionDelete		; $6f55



; Checks to set the "bombable wall open" bit in d6 (east)
_miscPuzzles_subid09:
	call interactionDeleteAndRetIfEnabled02		; $6f58
	call getThisRoomFlags		; $6f5b
	bit ROOMFLAG_BIT_KEYDOOR_RIGHT,(hl)		; $6f5e
	ret z			; $6f60
	ld l,<ROOM_526		; $6f61
	set ROOMFLAG_BIT_KEYDOOR_RIGHT,(hl)		; $6f63
	jp interactionDelete		; $6f65



; Jabu-jabu water level controller script, in the room with the 3 buttons
_miscPuzzles_subid0a:
	ld e,Interaction.state		; $6f68
	ld a,(de)		; $6f6a
	rst_jumpTable			; $6f6b
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3

@state0:
	ld a,(wActiveTriggers)		; $6f74
	ld e,Interaction.var30		; $6f77
	ld (de),a		; $6f79

	ld a,(wJabuWaterLevel)		; $6f7a
	and $f0			; $6f7d
	ld (wSwitchState),a		; $6f7f
	jp interactionIncState		; $6f82

@state1:
	; Check if a button was pressed
	ld a,(wActiveTriggers)		; $6f85
	ld b,a			; $6f88
	ld e,Interaction.var30		; $6f89
	ld a,(de)		; $6f8b
	xor b			; $6f8c
	ld c,a			; $6f8d
	ld a,b			; $6f8e
	ld (de),a		; $6f8f

	bit 7,c			; $6f90
	jr nz,@drainWater	; $6f92

	; Ret if none pressed
	and c			; $6f94
	ret z			; $6f95
	ld a,(wSwitchState)		; $6f96
	and c			; $6f99
	ret nz			; $6f9a

	ld a,c			; $6f9b
	ld hl,wSwitchState		; $6f9c
	or (hl)			; $6f9f
	ld (hl),a		; $6fa0
	and $f0			; $6fa1
	ld b,a			; $6fa3
	ld hl,wJabuWaterLevel		; $6fa4
	ld a,(hl)		; $6fa7
	and $03			; $6fa8
	inc a			; $6faa
	or b			; $6fab
	ld (hl),a		; $6fac
	ld a,<TX_1209		; $6fad
	jr @beginCutscene		; $6faf

@drainWater:
	ld a,(wJabuWaterLevel)		; $6fb1
	and $07			; $6fb4
	ret z			; $6fb6
	xor a			; $6fb7
	ld (wJabuWaterLevel),a		; $6fb8
	ld (wSwitchState),a		; $6fbb
	ld a,<TX_1208		; $6fbe

@beginCutscene:
	ld e,Interaction.var31		; $6fc0
	ld (de),a		; $6fc2

	ld a,DISABLE_ALL_BUT_INTERACTIONS | DISABLE_LINK		; $6fc3
	ld (wDisabledObjects),a		; $6fc5
	ld (wMenuDisabled),a		; $6fc8

	ld e,Interaction.counter1		; $6fcb
	ld a,60		; $6fcd
	ld (de),a		; $6fcf

	ld a,SNDCTRL_STOPMUSIC		; $6fd0
	call playSound		; $6fd2
	jp interactionIncState		; $6fd5

@state2:
	call interactionDecCounter1		; $6fd8
	ret nz			; $6fdb

	ld a,$f0		; $6fdc
	ld (hl),a		; $6fde
	call setScreenShakeCounter		; $6fdf
	ld a,SND_FLOODGATES		; $6fe2
	call playSound		; $6fe4
	jp interactionIncState		; $6fe7

@state3:
	call interactionDecCounter1		; $6fea
	ret nz			; $6fed

	ld l,Interaction.state		; $6fee
	ld (hl),$01		; $6ff0
	xor a			; $6ff2
	ld (wDisabledObjects),a		; $6ff3
	ld (wMenuDisabled),a		; $6ff6

	ld b,>TX_1200		; $6ff9
	ld l,Interaction.var31		; $6ffb
	ld c,(hl)		; $6ffd
	call showText		; $6ffe

	ld a,SNDCTRL_STOPSFX		; $7001
	call playSound		; $7003
	ld a,(wActiveMusic)		; $7006
	jp playSound		; $7009



; Ladder spawner in d7 miniboss room
_miscPuzzles_subid0b:
	ld e,Interaction.state		; $700c
	ld a,(de)		; $700e
	rst_jumpTable			; $700f
	.dw _miscPuzzles_deleteSelfOrIncStateIfRoomFlag7Set
	.dw @state1
	.dw @state2

@state1:
	ld a,(wNumEnemies)		; $7016
	or a			; $7019
	ret nz			; $701a

	call getThisRoomFlags		; $701b
	set ROOMFLAG_BIT_80,(hl)		; $701e
	ld l,<ROOM_54d		; $7020
	set ROOMFLAG_BIT_80,(hl)		; $7022
	ld e,Interaction.counter1		; $7024
	ld a,$08		; $7026
	ld (de),a		; $7028
	jp interactionIncState		; $7029

@state2:
	call interactionDecCounter1		; $702c
	ret nz			; $702f

	; Add the next ladder tile
	ld (hl),$08		; $7030
	call objectGetTileAtPosition		; $7032
	ld c,l			; $7035
	ld a,c			; $7036
	ldh (<hFF92),a	; $7037

	ld a,TILEINDEX_SS_LADDER		; $7039
	call setTile		; $703b

	ld b,INTERACID_PUFF		; $703e
	call objectCreateInteractionWithSubid00		; $7040

	ld e,Interaction.yh		; $7043
	ld a,(de)		; $7045
	add $10			; $7046
	ld (de),a		; $7048

	ldh a,(<hFF92)	; $7049
	cp $90			; $704b
	ret c			; $704d

	; Restore the entrance on the left side
	ld c,$80		; $704e
	ld a,TILEINDEX_SS_52		; $7050
	call setTile		; $7052
	ld c,$90		; $7055
	ld a,TILEINDEX_SS_EMPTY		; $7057
	call setTile		; $7059

	ld a,SND_SOLVEPUZZLE		; $705c
	call playSound		; $705e
	xor a			; $7061
	ld (wDisableLinkCollisionsAndMenu),a		; $7062
	jp interactionDelete		; $7065



; Switch hook puzzle early in d7 for a small key
_miscPuzzles_subid0c:
	call interactionDeleteAndRetIfEnabled02		; $7068
	call _miscPuzzles_deleteSelfAndRetIfItemFlagSet		; $706b

	ld hl,_miscPuzzles_subid0c_wantedTiles		; $706e
	call _miscPuzzles_verifyTilesAtPositions		; $7071
	ret nz			; $7074

;;
; @addr{7075}
_miscPuzzles_dropSmallKeyHere:
	ldbc TREASURE_SMALL_KEY, $01		; $7075
	call createTreasure		; $7078
	ret nz			; $707b
	call objectCopyPosition		; $707c
	jp interactionDelete		; $707f

_miscPuzzles_subid0c_wantedTiles:
	.db TILEINDEX_SWITCH_DIAMOND
	.db $36 $3a $76 $7a
	.db $00



; Staircase spawner after moving first set of stone panels in d8
_miscPuzzles_subid0d:
	ld e,Interaction.state		; $7088
	ld a,(de)		; $708a
	rst_jumpTable			; $708b
	.dw @state0
	.dw @state1
	.dw @state2

@state0:
	call getThisRoomFlags		; $7092
	and ROOMFLAG_40			; $7095
	jp nz,interactionDelete		; $7097

	ld a,(wNumTorchesLit)		; $709a
	cp $01			; $709d
	ret nz			; $709f
	ld hl,wActiveTriggers		; $70a0
	ld a,(hl)		; $70a3
	cp $07			; $70a4
	ret nz			; $70a6

	ld e,Interaction.counter1		; $70a7
	ld a,30		; $70a9
	ld (de),a		; $70ab
	ld a,$08		; $70ac
	call setScreenShakeCounter		; $70ae
	ld a,SND_DOORCLOSE		; $70b1
	call playSound		; $70b3
	jp interactionIncState		; $70b6

@state1:
	call interactionDecCounter1		; $70b9
	ret nz			; $70bc

	ld hl,wActiveTriggers		; $70bd
	ld a,(hl)		; $70c0
	cp $07			; $70c1
	jr z,++			; $70c3
	ld e,Interaction.state		; $70c5
	xor a			; $70c7
	ld (de),a		; $70c8
	ret			; $70c9
++
	set 7,(hl)		; $70ca
	jp interactionIncState		; $70cc

@state2:
	; Wait for bit 7 of wActiveTriggers to be unset by another object?
	ld a,(wActiveTriggers)		; $70cf
	bit 7,a			; $70d2
	ret nz			; $70d4

	ld a,SND_SOLVEPUZZLE		; $70d5
	call playSound		; $70d7
	ld b,INTERACID_PUFF		; $70da
	call objectCreateInteractionWithSubid00		; $70dc

	call objectGetTileAtPosition		; $70df
	ld c,l			; $70e2
	ld a,TILEINDEX_NORTH_STAIRS		; $70e3
	call setTile		; $70e5
	jp interactionDelete		; $70e8



; Staircase spawner after putting in slates in d8
_miscPuzzles_subid0e:
	call checkInteractionState		; $70eb
	jp nz,@state1		; $70ee

@state0:
	call getThisRoomFlags		; $70f1
	bit ROOMFLAG_BIT_40,(hl)		; $70f4
	jp nz,interactionDelete		; $70f6

	; Wait for all slates to be put in
	ld a,(hl)		; $70f9
	and ROOMFLAG_01|ROOMFLAG_02|ROOMFLAG_04|ROOMFLAG_08
	cp  ROOMFLAG_01|ROOMFLAG_02|ROOMFLAG_04|ROOMFLAG_08
	ret nz			; $70fe

	ld hl,wActiveTriggers		; $70ff
	set 7,(hl)		; $7102
	jp interactionIncState		; $7104

@state1:
	; Wait for another object to unset bit 7 of wActiveTriggers?
	ld a,(wActiveTriggers)		; $7107
	bit 7,a			; $710a
	ret nz			; $710c

	ld a,SND_SOLVEPUZZLE		; $710d
	call playSound		; $710f
	ld b,INTERACID_PUFF		; $7112
	call objectCreateInteractionWithSubid00		; $7114

	call objectGetTileAtPosition		; $7117
	ld c,l			; $711a
	ld a,TILEINDEX_NORTH_STAIRS		; $711b
	call setTile		; $711d
	jp interactionDelete		; $7120



; Octogon boss initialization (in the room just before the boss)
_miscPuzzles_subid0f:
	ld hl,wTmpcfc0.octogonBoss.loadedExtraGfx		; $7123
	xor a			; $7126
	ldi (hl),a		; $7127
	ldi (hl),a ; [var03] = 0
	dec a			; $7129
	ldi (hl),a ; [direction] = $ff
	ld (hl),$28 ; [health]
	inc l			; $712d
	ld (hl),$28 ; [y]
	inc l			; $7130
	ld (hl),$78 ; [x]
	inc l			; $7133
	ld (hl),a ; [var30] = $ff
	jp interactionDelete		; $7135



; Something at the top of Talus Peaks?
_miscPuzzles_subid10:
	ld hl,wTmpcfc0.patchMinigame.fixingSword		; $7138
	ld b,$08		; $713b
	call clearMemory		; $713d
	jp interactionDelete		; $7140



; D5 keyhole opening
_miscPuzzles_subid11:
	call checkInteractionState		; $7143
	jp nz,interactionRunScript		; $7146

	call returnIfScrollMode01Unset		; $7149
	call getThisRoomFlags		; $714c
	and ROOMFLAG_80			; $714f
	jp nz,interactionDelete		; $7151

	push de			; $7154
	call reloadTileMap		; $7155
	pop de			; $7158
	ld hl,miscPuzzles_crownDungeonOpeningScript		; $7159

;;
; @addr{715c}
_miscPuzzles_setScriptAndIncState:
	call interactionSetScript		; $715c
	call interactionSetAlwaysUpdateBit		; $715f
	jp interactionIncState		; $7162



; D6 present/past keyhole opening
_miscPuzzles_subid12:
	call checkInteractionState		; $7165
	jp nz,interactionRunScript		; $7168

	call getThisRoomFlags		; $716b
	and ROOMFLAG_80			; $716e
	jp nz,interactionDelete		; $7170
	ld hl,miscPuzzles_mermaidsCaveDungeonOpeningScript		; $7173
	jr _miscPuzzles_setScriptAndIncState		; $7176



; Eyeglass library keyhole opening
_miscPuzzles_subid13:
	call checkInteractionState		; $7178
	jp nz,interactionRunScript		; $717b

	call getThisRoomFlags		; $717e
	and ROOMFLAG_80			; $7181
	jp nz,interactionDelete		; $7183
	ld hl,miscPuzzles_eyeglassLibraryOpeningScript		; $7186
	jr _miscPuzzles_setScriptAndIncState		; $7189



; Spot to put a rolling colored block on in Hero's Cave
_miscPuzzles_subid14:
	call checkInteractionState		; $718b
	jp z,_miscPuzzles_deleteSelfOrIncStateIfRoomFlag7Set		; $718e

	; Check that the tile at this position matches the cube color
	call objectGetTileAtPosition		; $7191
	sub TILEINDEX_RED_TOGGLE_FLOOR			; $7194
	cp $03			; $7196
	ret nc			; $7198
	ld b,a			; $7199
	ld a,(wRotatingCubePos)		; $719a
	cp l			; $719d
	ret nz			; $719e
	ld a,(wRotatingCubeColor)		; $719f
	and $03			; $71a2
	cp b			; $71a4
	ret nz			; $71a5

	; They match.
	ld c,l			; $71a6
	ld hl,wActiveTriggers		; $71a7
	ld a,b			; $71aa
	call setFlag		; $71ab

	ld a,$a3		; $71ae
	call setTile		; $71b0

	ld b,>wRoomCollisions		; $71b3
	ld a,$0f		; $71b5
	ld (bc),a		; $71b7
	ld a,SND_CLINK		; $71b8
	jp playSound		; $71ba



; Stairs from solving colored cube puzzle in Hero's Cave (related to subid $14)
_miscPuzzles_subid15:
	call checkInteractionState		; $71bd
	jp z,_miscPuzzles_deleteSelfOrIncStateIfRoomFlag7Set		; $71c0

	ld a,(wActiveTriggers)		; $71c3
	cp $07			; $71c6
	ret nz			; $71c8

	ld a,SND_SOLVEPUZZLE		; $71c9
	call playSound		; $71cb
	ld a,TILEINDEX_INDOOR_DOWNSTAIRCASE		; $71ce
	ld c,$15		; $71d0
	call setTile		; $71d2
	call getThisRoomFlags		; $71d5
	set ROOMFLAG_BIT_80,(hl)		; $71d8
	jp interactionDelete		; $71da



; Warps Link out of Hero's Cave upon opening the chest
_miscPuzzles_subid16:
	ld e,Interaction.state		; $71dd
	ld a,(de)		; $71df
	rst_jumpTable			; $71e0
	.dw _miscPuzzles_deleteSelfOrIncStateIfItemFlagSet
	.dw @state1
	.dw @state2

@state1:
	call getThisRoomFlags		; $71e7
	and ROOMFLAG_ITEM			; $71ea
	ret z			; $71ec
	call interactionIncState		; $71ed

@state2:
	ld a,DISABLE_ALL_BUT_INTERACTIONS | DISABLE_LINK		; $71f0
	ld (wDisabledObjects),a		; $71f2
	ld (wDisableLinkCollisionsAndMenu),a		; $71f5
	call retIfTextIsActive		; $71f8
	ld hl,@warpDestData		; $71fb
	call setWarpDestVariables		; $71fe
	jp interactionDelete		; $7201

@warpDestData:
	.db $80 $48 $01 $28 $03



; Enables portal in Hero's Cave first room if its other end is active
_miscPuzzles_subid17:
	call getThisRoomFlags		; $7209
	push hl			; $720c
	ld l,<ROOM_4c9		; $720d
	bit ROOMFLAG_BIT_ITEM,(hl)		; $720f
	pop hl			; $7211
	jr z,+			; $7212
	set ROOMFLAG_BIT_ITEM,(hl)		; $7214
+
	jp interactionDelete		; $7216



; Drops a key in hero's cave block-pushing puzzle
_miscPuzzles_subid18:
	call checkInteractionState		; $7219
	jp z,_miscPuzzles_deleteSelfOrIncStateIfItemFlagSet		; $721c

	ld hl,wRoomLayout+$95		; $721f
	ld a,(hl)		; $7222
	cp TILEINDEX_PUSHABLE_STATUE			; $7223
	ret nz			; $7225
	ld l,$5d		; $7226
	ld a,(hl)		; $7228
	cp TILEINDEX_PUSHABLE_STATUE			; $7229
	ret nz			; $722b
	jp _miscPuzzles_dropSmallKeyHere		; $722c



; Bridge controller in d5 room after the miniboss
_miscPuzzles_subid19:
	ld e,Interaction.state		; $722f
	ld a,(de)		; $7231
	rst_jumpTable			; $7232
	.dw interactionIncState
	.dw @state1
	.dw @state2
	.dw @state3
	.dw @state4

; Trigger off, waiting for it to be pressed
@state1:
	ld a,(wActiveTriggers)		; $723d
	rrca			; $7240
	ret nc			; $7241
	ld e,Interaction.counter1		; $7242
	ld a,$08		; $7244
	ld (de),a		; $7246
	jp interactionIncState		; $7247

; Trigger enabled, in the process of extending the bridge
@state2:
	ld a,(wActiveTriggers)		; $724a
	rrca			; $724d
	jr nc,@@releasedTrigger	; $724e
	call interactionDecCounter1		; $7250
	ret nz			; $7253
	ld (hl),$08		; $7254
	ld hl,wRoomLayout+$55		; $7256
--
	ld c,l			; $7259
	ldi a,(hl)		; $725a
	cp TILEINDEX_BLANK_HOLE			; $725b
	jr nz,++		; $725d
	ld a,TILEINDEX_HORIZONTAL_BRIDGE		; $725f
	call setTileInAllBuffers		; $7261
	ld a,SND_DOORCLOSE		; $7264
	jp playSound		; $7266
++
	ld a,l			; $7269
	cp $5a			; $726a
	jr c,--			; $726c
	jp interactionIncState		; $726e

@@releasedTrigger:
	call interactionIncState		; $7271
	inc (hl)		; $7274
	ret			; $7275

; Bridge fully extended, waiting for trigger to be released
@state3:
	ld a,(wActiveTriggers)		; $7276
	rrca			; $7279
	ret c			; $727a
	jp interactionIncState		; $727b

; Trigger released, in the process of retracting the bridge
@state4:
	ld a,(wActiveTriggers)		; $727e
	rrca			; $7281
	jr c,@@pressedTrigger	; $7282
	call interactionDecCounter1		; $7284
	ret nz			; $7287

	ld (hl),$08		; $7288

	ld hl,wRoomLayout+$59		; $728a
--
	ld c,l			; $728d
	ldd a,(hl)		; $728e
	cp TILEINDEX_BLANK_HOLE			; $728f
	jr z,++			; $7291

	cp TILEINDEX_SWITCH_DIAMOND			; $7293
	call z,@createDebris		; $7295

	ld a,TILEINDEX_BLANK_HOLE		; $7298
	call setTileInAllBuffers		; $729a
	ld a,SND_DOORCLOSE		; $729d
	jp playSound		; $729f
++
	ld a,l			; $72a2
	cp $55			; $72a3
	jr nc,--		; $72a5

@@pressedTrigger:
	ld e,Interaction.state		; $72a7
	ld a,$01		; $72a9
	ld (de),a		; $72ab
	ret			; $72ac

@createDebris:
	push hl			; $72ad
	push bc			; $72ae
	ld b,INTERACID_ROCKDEBRIS		; $72af
	call objectCreateInteractionWithSubid00		; $72b1
	pop bc			; $72b4
	pop hl			; $72b5
	ret			; $72b6



; Checks solution to pushblock puzzle in Hero's Cave
_miscPuzzles_subid1a:
	call interactionDeleteAndRetIfEnabled02		; $72b7
	call _miscPuzzles_deleteSelfAndRetIfItemFlagSet		; $72ba

	ld hl,@wantedTiles		; $72bd
	call _miscPuzzles_verifyTilesAtPositions		; $72c0
	ret nz			; $72c3
	jpab interactionBank1.spawnChestAndDeleteSelf		; $72c4

@wantedTiles:
	.db TILEINDEX_RED_PUSHABLE_BLOCK    $4a $4b $4c $ff
	.db TILEINDEX_YELLOW_PUSHABLE_BLOCK $5a $5c $ff
	.db TILEINDEX_BLUE_PUSHABLE_BLOCK   $6a $6c $00



; Subids $1b-$1d: Spawn gasha seeds at the top of the maku tree at specific times.
; b = essence that must be obtained; c = position to spawn it at.
_miscPuzzles_subid1b:
	ldbc $08, $53		; $72d9
	jr ++			; $72dc

_miscPuzzles_subid1c:
	ldbc $40, $34		; $72de
	jr ++			; $72e1

_miscPuzzles_subid1d:
	ldbc $20, $34		; $72e3
++
	push bc			; $72e6
	ld a,TREASURE_ESSENCE		; $72e7
	call checkTreasureObtained		; $72e9
	pop bc			; $72ec
	jr nc,@delete		; $72ed
	and b			; $72ef
	jr z,@delete		; $72f0

	call objectSetShortPosition		; $72f2
	call getThisRoomFlags		; $72f5
	and ROOMFLAG_ITEM			; $72f8
	jr nz,@delete		; $72fa

	ld bc,TREASURE_GASHA_SEED_SUBID_07		; $72fc
	call createTreasure		; $72ff
	call z,objectCopyPosition		; $7302
@delete:
	jp interactionDelete		; $7305



; Play "puzzle solved" sound after navigating eyeball puzzle in final dungeon
_miscPuzzles_subid1e:
	call returnIfScrollMode01Unset		; $7308
	ld a,(wScreenTransitionDirection)		; $730b
	or a			; $730e
	jp nz,interactionDelete		; $730f
	ld a,SND_SOLVEPUZZLE		; $7312
	call playSound		; $7314
	jp interactionDelete		; $7317



; Checks if Link gets stuck in the d5 boss key puzzle, resets the room if so
_miscPuzzles_subid1f:
	ld e,Interaction.state		; $731a
	ld a,(de)		; $731c
	rst_jumpTable			; $731d
	.dw interactionIncState
	.dw @state1
	.dw @state2

@state1:
	call interactionDecCounter1		; $7324
	ret nz			; $7327

	ld (hl),30		; $7328

	; Get Link's short position in 'e'
	ld hl,w1Link.yh		; $732a
	ldi a,(hl)		; $732d
	and $f0			; $732e
	ld b,a			; $7330
	inc l			; $7331
	ld a,(hl)		; $7332
	and $f0			; $7333
	swap a			; $7335
	or b			; $7337
	ld e,a			; $7338

	push de			; $7339
	ld hl,@offsetsToCheck		; $733a
	ld d,$08		; $733d

@checkNextOffset:
	ldi a,(hl)		; $733f
	add e			; $7340
	ld c,a			; $7341
	ld b,>wRoomCollisions		; $7342
	ld a,(bc)		; $7344
	or a			; $7345
	jr z,@doneCheckingIfTrapped	; $7346

	; For odd-indexed offsets only (one tile away from Link), check if we're near the
	; screen edge? If so, skip the next check?
	bit 0,d			; $7348
	jr nz,++			; $734a

	ld b,>wRoomLayout		; $734c
	ld a,(bc)		; $734e
	or a			; $734f
	jr nz,++			; $7350
	inc hl			; $7352
	dec d			; $7353
++
	dec d			; $7354
	jr nz,@checkNextOffset	; $7355

@doneCheckingIfTrapped:
	ld a,d			; $7357
	pop de			; $7358
	or a			; $7359
	ret nz			; $735a

	; Link is trapped; warp him out
	call checkLinkVulnerable		; $735b
	ret nc			; $735e
	ld a,DISABLE_LINK		; $735f
	ld (wMenuDisabled),a		; $7361
	ld (wDisabledObjects),a		; $7364
	ld a,SND_ERROR		; $7367
	call playSound		; $7369

	ld e,Interaction.counter1		; $736c
	ld a,60		; $736e
	ld (de),a		; $7370
	jp interactionIncState		; $7371

; Checks if there are solid walls / holes at all of these positions relative to Link
@offsetsToCheck:
	.db $f0 $e0 $01 $02 $10 $20 $ff $fe

@state2:
	call interactionDecCounter1	; $737c
	ret nz			; $737f
	xor a			; $7380
	ld (wMenuDisabled),a		; $7381
	ld (wDisabledObjects),a		; $7384
	ld hl,@warpDest		; $7387
	jp setWarpDestVariables		; $738a

@warpDest:
	.db $84 $9b $00 $12 $03



; Money in sidescrolling room in Hero's Cave
_miscPuzzles_subid20:
	call getThisRoomFlags		; $7392
	and ROOMFLAG_ITEM			; $7395
	jr nz,@delete	; $7397

	ld bc,TREASURE_RUPEES_SUBID_16		; $7399
	call createTreasure		; $739c
	jp nz,@delete		; $739f
	call objectCopyPosition		; $73a2
@delete:
	jp interactionDelete		; $73a5



; Creates explosions while screen is fading out; used in some cutscene?
_miscPuzzles_subid21:
	call checkInteractionState		; $73a8
	jr z,@state0	; $73ab

	ld a,(wPaletteThread_mode)		; $73ad
	or a			; $73b0
	jp z,interactionDelete		; $73b1

	ld a,(wFrameCounter)		; $73b4
	ld b,a			; $73b7
	and $1f			; $73b8
	ret nz			; $73ba

	ld a,b			; $73bb
	and $70			; $73bc
	swap a			; $73be
	ld hl,@explosionPositions		; $73c0
	rst_addDoubleIndex			; $73c3
	ldi a,(hl)		; $73c4
	ld b,a			; $73c5
	ld c,(hl)		; $73c6
	call getFreeInteractionSlot		; $73c7
	ret nz			; $73ca
	ld (hl),INTERACID_EXPLOSION		; $73cb
	jp objectCopyPositionWithOffset		; $73cd

@explosionPositions:
	.db $f4 $0c
	.db $04 $fb
	.db $08 $10
	.db $fe $f4
	.db $0c $08
	.db $fc $04
	.db $06 $f8
	.db $f8 $fe

@state0:
	call interactionIncState		; $73e0
	ld a,$04		; $73e3
	jp fadeoutToWhiteWithDelay		; $73e5

;;
; @addr{73e8}
_miscPuzzles_deleteSelfAndRetIfItemFlagSet:
	call getThisRoomFlags		; $73e8
	and ROOMFLAG_ITEM			; $73eb
	ret z			; $73ed
	pop hl			; $73ee
	jp interactionDelete		; $73ef

;;
; @addr{73f2}
_miscPuzzles_deleteSelfOrIncStateIfItemFlagSet:
	call getThisRoomFlags		; $73f2
	and ROOMFLAG_ITEM			; $73f5
	jp nz,interactionDelete		; $73f7
	jp interactionIncState		; $73fa

;;
; @addr{73fd}
_miscPuzzles_deleteSelfOrIncStateIfRoomFlag7Set:
	call getThisRoomFlags		; $73fd
	and ROOMFLAG_80			; $7400
	jp nz,interactionDelete		; $7402
	jp interactionIncState		; $7405

;;
; Unused
; @addr{7408}
_miscPuzzles_deleteSelfOrIncStateIfRoomFlag6Set:
	call getThisRoomFlags		; $7408
	and ROOMFLAG_40			; $740b
	jp nz,interactionDelete		; $740d
	jp interactionIncState		; $7410



; ==============================================================================
; INTERACID_FALLING_ROCK
; ==============================================================================
interactionCode92:
	ld e,Interaction.subid		; $7413
	ld a,(de)		; $7415
	rst_jumpTable			; $7416
	.dw _fallingRock_subid00
	.dw _fallingRock_subid01
	.dw _fallingRock_subid02
	.dw _fallingRock_subid03
	.dw _fallingRock_subid04
	.dw _fallingRock_subid05
	.dw _fallingRock_subid06


; Spawner of falling rocks; stops when $cfdf is nonzero. Used when freeing goron elder.
_fallingRock_subid00:
	call checkInteractionState		; $7425
	jr nz,@state1	; $7428

@state0:
	call interactionIncState		; $742a
	ld l,Interaction.counter2		; $742d
	ld (hl),$01		; $742f
@state1:
	ld a,(wTmpcfc0.goronCutscenes.elder_stopFallingRockSpawner)		; $7431
	or a			; $7434
	jp nz,interactionDelete		; $7435

	call interactionDecCounter2		; $7438
	ret nz			; $743b

	ld l,Interaction.counter2		; $743c
	ld (hl),20		; $743e
	call getFreeInteractionSlot		; $7440
	ret nz			; $7443
	ld (hl),INTERACID_FALLING_ROCK		; $7444
	inc l			; $7446
	ld (hl),$01		; $7447
	inc l			; $7449
	ld e,Interaction.var03		; $744a
	ld a,(de)		; $744c
	ld (hl),a		; $744d
	ret			; $744e


; Instance of falling rock spawned by subid $00
_fallingRock_subid01:
	call checkInteractionState		; $744f
	jr nz,@state1		; $7452
	call _fallingRock_initGraphicsAndIncState		; $7454
	call _fallingRock_chooseRandomPosition		; $7457

@state1:
	ld c,$10		; $745a
	call objectUpdateSpeedZ_paramC		; $745c
	jr nz,@ret	; $745f

	; Rock has hit the ground
	call objectReplaceWithAnimationIfOnHazard		; $7461
	jp c,interactionDelete		; $7464

	ld a,SND_BREAK_ROCK		; $7467
	call playSound		; $7469
	call @spawnDebris		; $746c
	ld a,$04		; $746f
	call setScreenShakeCounter		; $7471
	jp interactionDelete		; $7474
@ret:
	ret			; $7477

@spawnDebris:
	call getRandomNumber		; $7478
	and $03			; $747b
	ld c,a			; $747d
	ld b,$00		; $747e
@next:
	push bc			; $7480
	ldbc INTERACID_FALLING_ROCK, $02		; $7481
	call objectCreateInteraction		; $7484
	pop bc			; $7487
	ret nz			; $7488
	ld l,Interaction.counter1		; $7489
	ld (hl),c		; $748b
	ld l,Interaction.angle		; $748c
	ld (hl),b		; $748e
	inc b			; $748f
	ld a,b			; $7490
	cp $04			; $7491
	jr nz,@next	; $7493
	ret			; $7495


; Used by gorons when freeing elder?
_fallingRock_subid02:
	call checkInteractionState		; $7496
	jr nz,@state1	; $7499

@state0:
	call _fallingRock_initGraphicsAndIncState		; $749b
	call interactionSetAlwaysUpdateBit		; $749e
	ld l,Interaction.var03		; $74a1
	ld a,(hl)		; $74a3
	or a			; $74a4
	jr nz,++		; $74a5

	ld l,Interaction.counter1		; $74a7
	ld a,(hl)		; $74a9
	jr @loadAngle		; $74aa
++
	ld l,Interaction.counter1		; $74ac
	ld a,(hl)		; $74ae
	add $04			; $74af
@loadAngle:
	add a			; $74b1
	add a			; $74b2
	ld l,Interaction.angle		; $74b3
	add (hl)		; $74b5
	ld bc,@angles		; $74b6
	call addAToBc		; $74b9
	ld a,(bc)		; $74bc
	ld (hl),a		; $74bd
	ld l,Interaction.var03		; $74be
	ld a,(hl)		; $74c0
	or a			; $74c1
	jr nz,@lowSpeed		; $74c2

	ld l,Interaction.speed		; $74c4
	ld (hl),SPEED_180		; $74c6
	ld l,Interaction.speedZ		; $74c8
	ld a,$18		; $74ca
	ldi (hl),a		; $74cc
	ld (hl),$ff		; $74cd
	ret			; $74cf

@lowSpeed:
	ld l,Interaction.speed		; $74d0
	ld (hl),SPEED_100		; $74d2
	ld l,Interaction.speedZ		; $74d4
	ld a,$1c		; $74d6
	ldi (hl),a		; $74d8
	ld (hl),$ff		; $74d9
	ret			; $74db

; List of angle values.
; A byte is read from offset: ([counter1] + ([var03] != 0 ? 4 : 0)) * 4 + [angle]
; (These 3 variables should be set by whatever spawned this object)
@angles:
	.db $04 $0c $14 $1c $02 $0a $12 $1a
	.db $04 $0c $14 $1c $06 $0e $16 $1e
	.db $1a $14 $0c $06 $16 $1c $04 $0a

@state1:
	ld a,(wTmpcfc0.goronCutscenes.cfde)		; $74f4
	or a			; $74f7
	jp nz,interactionDelete		; $74f8

_fallingRock_updateSpeedAndDeleteWhenLanded:
	ld c,$18		; $74fb
	call objectUpdateSpeedZ_paramC		; $74fd
	jp z,interactionDelete		; $7500
	jp objectApplySpeed		; $7503


; A twinkle? angle is a value from 0-3, indicating a diagonal to move in.
_fallingRock_subid03:
	call checkInteractionState		; $7506
	jr nz,_fallingRock_subid03_state1	; $7509

@state0:
	call _fallingRock_initGraphicsAndIncState		; $750b
	call interactionSetAlwaysUpdateBit		; $750e
_fallingRock_initDiagonalAngle:
	ld l,Interaction.angle		; $7511
	ld a,(hl)		; $7513
	ld bc,@diagonalAngles		; $7514
	call addAToBc		; $7517
	ld a,(bc)		; $751a
	ld (hl),a		; $751b
	ld l,Interaction.speed		; $751c
	ld (hl),SPEED_100		; $751e
	ret			; $7520

@diagonalAngles:
	.db $04 $0c $14 $1c

_fallingRock_subid03_state1:
	ld e,Interaction.animParameter		; $7525
	ld a,(de)		; $7527
	cp $ff			; $7528
	jp z,interactionDelete		; $752a
	call interactionAnimate		; $752d
	jp objectApplySpeed		; $7530


; Blue/Red rock debris, moving straight on a diagonal? (angle from 0-3)
_fallingRock_subid04:
_fallingRock_subid05:
	call checkInteractionState		; $7533
	jr nz,@state1	; $7536

@state0:
	call _fallingRock_initGraphicsAndIncState		; $7538
	call interactionSetAlwaysUpdateBit		; $753b
	ld l,Interaction.counter1		; $753e
	ld (hl),$0c		; $7540
	jr _fallingRock_initDiagonalAngle		; $7542
@state1:
	call interactionDecCounter1		; $7544
	jp z,interactionDelete		; $7547
	call interactionAnimate		; $754a
	jp objectApplySpeed		; $754d


; Debris from pickaxe workers?
_fallingRock_subid06:
	call checkInteractionState		; $7550
	jp nz,_fallingRock_updateSpeedAndDeleteWhenLanded		; $7553

@state0:
	call _fallingRock_initGraphicsAndIncState		; $7556
	call interactionSetAlwaysUpdateBit		; $7559
	ld l,Interaction.var03		; $755c
	ld a,(hl)		; $755e
	or $08			; $755f
	ld l,Interaction.oamFlags		; $7561
	ld (hl),a		; $7563
	ld l,Interaction.counter2		; $7564
	ld a,(hl)		; $7566
	or a			; $7567
	jr z,+			; $7568
	dec a			; $756a
+
	ld b,a			; $756b
	ld l,Interaction.visible		; $756c
	ld a,(hl)		; $756e
	and $bc			; $756f
	or b			; $7571
	ld (hl),a		; $7572

	ld l,Interaction.angle		; $7573
	ld a,(hl)		; $7575
	ld bc,@angles		; $7576
	call addAToBc		; $7579
	ld a,(bc)		; $757c
	ld (hl),a		; $757d
	ld l,Interaction.speed		; $757e
	ld (hl),SPEED_80		; $7580
	ld l,Interaction.speedZ		; $7582
	ld a,$40		; $7584
	ldi (hl),a		; $7586
	ld (hl),$ff		; $7587
	ret			; $7589

@angles:
	.db $08 $18

;;
; @addr{758c}
_fallingRock_initGraphicsAndIncState:
	call interactionInitGraphics	; $758c
	call objectSetVisiblec1		; $758f
	jp interactionIncState		; $7592

;;
; Randomly choose a position from a list of possible positions. var03 determines which
; list it reads from?
; @addr{7595}
_fallingRock_chooseRandomPosition:
	ld e,Interaction.var03		; $7595
	ld a,(de)		; $7597
	or a			; $7598
	ld hl,@positionList1		; $7599
	jr z,++			; $759c
	ld hl,@positionList2		; $759e
	ld e,Interaction.oamFlags		; $75a1
	ld a,$04		; $75a3
	ld (de),a		; $75a5
++
	call getRandomNumber		; $75a6
	and $0f			; $75a9
	rst_addDoubleIndex			; $75ab
	ldi a,(hl)		; $75ac
	ld e,Interaction.yh		; $75ad
	ld (de),a		; $75af
	cpl			; $75b0
	inc a			; $75b1
	sub $08			; $75b2
	ld e,Interaction.zh		; $75b4
	ld (de),a		; $75b6
	ldi a,(hl)		; $75b7
	ld e,Interaction.xh		; $75b8
	ld (de),a		; $75ba
	ret			; $75bb

@positionList1:
	.db $50 $18
	.db $60 $18
	.db $70 $18
	.db $48 $20
	.db $50 $28
	.db $70 $28
	.db $40 $38
	.db $60 $38
	.db $6c $38
	.db $78 $38
	.db $50 $48
	.db $70 $48
	.db $48 $50
	.db $50 $58
	.db $60 $58
	.db $70 $58

@positionList2:
	.db $50 $38
	.db $60 $38
	.db $70 $38
	.db $48 $40
	.db $50 $48
	.db $70 $48
	.db $40 $58
	.db $60 $58
	.db $6c $88
	.db $78 $88
	.db $50 $98
	.db $70 $98
	.db $48 $a0
	.db $50 $a8
	.db $60 $a8
	.db $70 $a8


; ==============================================================================
; INTERACID_TWINROVA
;
; Variables:
;   var3a: Index for "loadAngleAndCounterPreset" function
; ==============================================================================
interactionCode93:
	ld e,Interaction.state		; $75fc
	ld a,(de)		; $75fe
	rst_jumpTable			; $75ff
	.dw @state0
	.dw _twinrova_state1

@state0:
	ld e,Interaction.subid		; $7604
	ld a,(de)		; $7606
	cp $02			; $7607
	jr nc,@subid2AndUp		; $7609

@subid0Or1:
	ld a,(wTmpcfc0.genericCutscene.cfd0)		; $760b
	cp $08			; $760e
	ret nz			; $7610
	call _twinrova_loadGfx		; $7611
	jr ++			; $7614

@subid2AndUp:
	cp $06			; $7616
	call nz,interactionLoadExtraGraphics		; $7618
++
	call interactionIncState		; $761b
	call interactionInitGraphics		; $761e
	call objectSetVisiblec1		; $7621
	ld a,>TX_2800		; $7624
	call interactionSetHighTextIndex		; $7626
	ld e,Interaction.subid		; $7629
	ld a,(de)		; $762b
	rst_jumpTable			; $762c
	.dw _twinrova_initSubid00
	.dw _twinrova_initOtherHalf
	.dw _twinrova_initSubid02
	.dw _twinrova_initOtherHalf
	.dw _twinrova_initSubid04
	.dw _twinrova_initOtherHalf
	.dw _twinrova_initSubid06
	.dw _twinrova_initOtherHalf

;;
; @addr{763d}
_twinrova_loadGfx:
	ld hl,wLoadedObjectGfx+10		; $763d
	ld b,$03		; $7640
	ld a,OBJGFXH_2c		; $7642
--
	ldi (hl),a		; $7644
	inc a			; $7645
	ld (hl),$01		; $7646
	inc l			; $7648
	dec b			; $7649
	jr nz,--		; $764a
	push de			; $764c
	call reloadObjectGfx		; $764d
	pop de			; $7650
	ret			; $7651

_twinrova_initSubid06:
	ld h,d			; $7652
	ld l,Interaction.var3a		; $7653
	ld (hl),$00		; $7655
	call _twinrova_loadScript		; $7657
	ld bc,$4234		; $765a
	jr _twinrova_genericInitialize		; $765d

_twinrova_initSubid02:
	ld h,d			; $765f
	ld l,Interaction.var3a		; $7660
	ld (hl),$04		; $7662
	ld l,Interaction.var38		; $7664
	ld (hl),$02		; $7666
	call objectSetInvisible		; $7668
	ld bc,$3850		; $766b
	jr _twinrova_genericInitialize		; $766e

_twinrova_initSubid04:
	ld h,d			; $7670
	ld l,Interaction.var38		; $7671
	ld (hl),$1e		; $7673

_twinrova_initSubid00:
	ld h,d			; $7675
	ld l,Interaction.var3a		; $7676
	ld (hl),$00		; $7678
	ld bc,$f888		; $767a

_twinrova_genericInitialize:
	call interactionSetPosition		; $767d
	call interactionSetAlwaysUpdateBit		; $7680
	ld l,Interaction.oamFlags		; $7683
	ld (hl),$02		; $7685
	ld l,Interaction.speed		; $7687
	ld (hl),SPEED_200		; $7689
	ld l,Interaction.zh		; $768b
	ld (hl),-$08		; $768d

	; Spawn the other half ([subid]+1)
	call getFreeInteractionSlot		; $768f
	jr nz,++		; $7692
	ld (hl),INTERACID_TWINROVA		; $7694
	inc l			; $7696
	ld e,l			; $7697
	ld a,(de)		; $7698
	inc a			; $7699
	ld (hl),a		; $769a
	ld l,Interaction.relatedObj1		; $769b
	ld (hl),Interaction.start		; $769d
	inc l			; $769f
	ld (hl),d		; $76a0
++
	call _twinrova_loadAngleAndCounterPreset		; $76a1
	call _twinrova_updateDirectionFromAngle		; $76a4
	ld a,SND_BEAM2		; $76a7
	call playSound		; $76a9
	jpab scriptHlp.objectWritePositionTocfd5		; $76ac

;;
; @addr{76b4}
_twinrova_loadAngleAndCounterPreset:
	ld e,Interaction.var3a		; $76b4
	ld a,(de)		; $76b6
	ld b,a			; $76b7

;;
; Loads preset values for angle and counter1 variables for an interaction. The values it
; loads depends on parameter 'b' (the preset index) and 'Interaction.counter2' (the index
; in the preset to use).
;
; Generally used to make an object move around in circular-ish patterns?
;
; @param	b	Preset to use
; @param[out]	b	Zero if end of data reached; nonzero otherwise.
; @addr{76b8}
loadAngleAndCounterPreset:
	ld a,b			; $76b8
	ld hl,_presetInteractionAnglesAndCounters		; $76b9
	rst_addDoubleIndex			; $76bc
	ldi a,(hl)		; $76bd
	ld h,(hl)		; $76be
	ld l,a			; $76bf

	ld e,Interaction.counter2		; $76c0
	ld a,(de)		; $76c2
	rst_addDoubleIndex			; $76c3

	ldi a,(hl)		; $76c4
	ld e,Interaction.angle		; $76c5
	ld (de),a		; $76c7
	ld a,(hl)		; $76c8
	or a			; $76c9
	ld b,a			; $76ca
	ret z			; $76cb

	ld h,d			; $76cc
	ld l,Interaction.counter1		; $76cd
	ldi (hl),a		; $76cf
	inc (hl) ; [counter2]++
	or $01			; $76d1
	ret			; $76d3

;;
; @addr{76d4}
_twinrova_updateDirectionFromAngle:
	ld e,Interaction.angle		; $76d4
	call convertAngleDeToDirection		; $76d6
	and $03			; $76d9
	ld l,Interaction.direction		; $76db
	cp (hl)			; $76dd
	ret z			; $76de
	ld (hl),a		; $76df
	jp interactionSetAnimation		; $76e0


; Initialize odd subids (the half of twinrova that just follows along)
_twinrova_initOtherHalf:
	call interactionSetAlwaysUpdateBit		; $76e3
	ld l,Interaction.oamFlags		; $76e6
	ld (hl),$01		; $76e8

	; Copy position & stuff from other half, inverted if necessary
	ld a,Object.enabled		; $76ea
	call objectGetRelatedObject1Var		; $76ec

;;
; @param	h	Object to copy visiblility, direction, position from
; @addr{76ef}
_twinrova_takeInvertedPositionFromObject:
	ld l,Interaction.visible		; $76ef
	ld e,l			; $76f1
	ld a,(hl)		; $76f2
	ld (de),a		; $76f3

	call objectTakePosition		; $76f4
	ld l,Interaction.xh		; $76f7
	ld b,(hl)		; $76f9
	ld a,$50		; $76fa
	sub b			; $76fc
	add $50			; $76fd
	ld e,Interaction.xh		; $76ff
	ld (de),a		; $7701

	ld l,Interaction.direction		; $7702
	ld a,(hl)		; $7704
	ld b,a			; $7705
	and $01			; $7706
	jr z,++			; $7708

	ld a,b			; $770a
	ld b,$01		; $770b
	cp $03			; $770d
	jr z,++			; $770f
	ld b,$03		; $7711
++
	ld a,b			; $7713
	ld h,d			; $7714
	ld l,Interaction.direction		; $7715
	cp (hl)			; $7717
	ret z			; $7718
	ld (hl),a		; $7719
	jp interactionSetAnimation		; $771a


; This data contains "presets" for an interacton's angle and counter1.
_presetInteractionAnglesAndCounters:
	.dw @data0
	.dw @data1
	.dw @data2
	.dw @data3
	.dw @data4
	.dw @data5

; Data format:
;   b0: Value for Interaction.angle
;   b1: Value for Interaction.counter1 (or $00 for end)

@data0: ; Used by Twinrova
	.db $11 $28
	.db $12 $10
	.db $13 $07
	.db $15 $05
	.db $17 $04
	.db $19 $04
	.db $1a $05
	.db $1d $07
	.db $1f $12
	.db $00 $00

@data1:
@data5:
	.db $03 $06
	.db $04 $06
	.db $06 $06
	.db $07 $06
	.db $08 $04
	.db $09 $06
	.db $0a $06
	.db $0c $04
	.db $0e $04
	.db $0f $04
	.db $10 $04
	.db $11 $04
	.db $13 $06
	.db $14 $0c
	.db $15 $30
	.db $00 $00

@data2: ; Ralph spinning his sword in credits cutscene
	.db $1a $12
	.db $1e $12
	.db $02 $12
	.db $06 $12
	.db $0a $12
	.db $0e $12
	.db $12 $12
	.db $16 $12
	.db $16 $12
	.db $12 $12
	.db $0e $12
	.db $0a $12
	.db $04 $12
	.db $02 $12
	.db $1e $10
	.db $1a $04
	.db $00 $00

@data3: ; INTERACID_RAFTWRECK_CUTSCENE_HELPER
	.db $15 $0c
	.db $16 $0c
	.db $17 $12
	.db $18 $14
	.db $19 $14
	.db $1a $20
	.db $00 $00

@data4: ; Used by Twinrova
	.db $0e $03
	.db $0c $03
	.db $0a $03
	.db $08 $03
	.db $06 $03
	.db $04 $03
	.db $02 $03
	.db $00 $03
	.db $1e $06
	.db $1c $06
	.db $1a $06
	.db $18 $06
	.db $16 $06
	.db $14 $06
	.db $12 $06
	.db $0f $08
	.db $00 $00


_twinrova_state1:
	ld e,Interaction.subid		; $77af
	ld a,(de)		; $77b1
	rst_jumpTable			; $77b2
	.dw @runSubid00
	.dw @runOtherHalf
	.dw @runSubid02
	.dw @runOtherHalf
	.dw @runSubid04
	.dw @runOtherHalf
	.dw @runSubid06
	.dw @runOtherHalf

@runSubid00:
	ld e,Interaction.state2		; $77c3
	ld a,(de)		; $77c5
	rst_jumpTable			; $77c6
	.dw @subid00State0
	.dw @subid00State1
	.dw @subid00State2

@subid00State0:
	callab scriptHlp.objectWritePositionTocfd5		; $77cd
	call interactionAnimate		; $77d5
	call objectApplySpeed		; $77d8
	call interactionDecCounter1		; $77db
	call z,_twinrova_loadAngleAndCounterPreset		; $77de
	jp nz,_twinrova_updateDirectionFromAngle		; $77e1
	call interactionIncState2		; $77e4
	jp _twinrova_loadScript		; $77e7

@subid00State1:
	call interactionAnimate		; $77ea
	call objectOscillateZ		; $77ed
	call interactionRunScript		; $77f0
	ret nc			; $77f3

	ld a,SND_BEAM2		; $77f4
	call playSound		; $77f6
	callab scriptHlp.objectWritePositionTocfd5		; $77f9
	call interactionIncState2		; $7801
	ld l,Interaction.counter2		; $7804
	ld (hl),$00		; $7806
	ld l,Interaction.var3a		; $7808
	inc (hl)		; $780a
	jp _twinrova_loadAngleAndCounterPreset		; $780b

@subid00State2:
	callab scriptHlp.objectWritePositionTocfd5		; $780e
	call interactionAnimate		; $7816
	call objectApplySpeed		; $7819
	call interactionDecCounter1		; $781c
	call z,_twinrova_loadAngleAndCounterPreset		; $781f
	jp nz,_twinrova_updateDirectionFromAngle		; $7822
	ld a,$09		; $7825
	ld (wTmpcfc0.genericCutscene.cfd0),a		; $7827
	jp interactionDelete		; $782a

@runOtherHalf:
	call interactionAnimate		; $782d
	ld a,Object.enabled		; $7830
	call objectGetRelatedObject1Var		; $7832
	ld a,(hl)		; $7835
	or a			; $7836
	jp z,interactionDelete		; $7837
	jp _twinrova_takeInvertedPositionFromObject		; $783a

@runSubid02:
@runSubid04:
	ld e,Interaction.state2		; $783d
	ld a,(de)		; $783f
	rst_jumpTable			; $7840
	.dw @subid02State0
	.dw @subid00State0
	.dw @subid00State1
	.dw @subid00State2

@subid02State0:
	ld h,d			; $7849
	ld l,Interaction.var38		; $784a
	dec (hl)		; $784c
	ret nz			; $784d
	call objectSetVisiblec1		; $784e
	jp interactionIncState2		; $7851

@runSubid06:
	ld e,Interaction.state2		; $7854
	ld a,(de)		; $7856
	rst_jumpTable			; $7857
	.dw @subid00State1
	.dw @subid00State2

;;
; @addr{785c}
_twinrova_loadScript:
	ld e,Interaction.subid		; $785c
	ld a,(de)		; $785e
	ld hl,@scriptTable		; $785f
	rst_addDoubleIndex			; $7862
	ldi a,(hl)		; $7863
	ld h,(hl)		; $7864
	ld l,a			; $7865
	jp interactionSetScript		; $7866

@scriptTable:
	.dw twinrova_subid00Script
	.dw stubScript
	.dw twinrova_subid02Script
	.dw stubScript
	.dw twinrova_subid04Script
	.dw stubScript
	.dw twinrova_subid06Script

;;
; Gets a position stored in $cfd5/$cfd6?
;
; @param[out]	bc	Position
; @addr{7877}
func_0a_7877:
	ld hl,wTmpcfc0.genericCutscene.cfd5		; $7877
	ld b,(hl)		; $787a
	inc l			; $787b
	ld c,(hl)		; $787c
	ret			; $787d


; ==============================================================================
; INTERACID_PATCH
;
; Variables:
;   var38: 0 if Link has the broken tuni nut; 1 otherwise (upstairs script)
;   var39: Set by another object (subid 3) when all beetles are killed
; ==============================================================================
interactionCode94:
	ld e,Interaction.subid		; $787e
	ld a,(de)		; $7880
	ld e,Interaction.state		; $7881
	rst_jumpTable			; $7883
	.dw _patch_subid00
	.dw _patch_subid01
	.dw _patch_subid02
	.dw _patch_subid03
	.dw _patch_subid04
	.dw _patch_subid05
	.dw _patch_subid06
	.dw _patch_subid07


; Patch in the upstairs room
_patch_subid00:
	ld e,Interaction.state		; $7894
	ld a,(de)		; $7896
	rst_jumpTable			; $7897
	.dw @state0
	.dw @state1
	.dw @state2

@state0:
	; If tuni nut's state is 1, set it back to 0 (put it back in Link's inventory if
	; the tuni nut game failed)
	ld hl,wTuniNutState		; $789e
	ld a,(hl)		; $78a1
	dec a			; $78a2
	jr nz,+			; $78a3
	ld (hl),a		; $78a5
+
	; Similarly, revert the trade item back to broken sword if failed the minigame
	ld hl,wTradeItem		; $78a6
	ld a,(hl)		; $78a9
	cp TRADEITEM_DOING_PATCH_GAME			; $78aa
	jr nz,+			; $78ac
	ld (hl),TRADEITEM_BROKEN_SWORD		; $78ae
+
	ld a,(wTmpcfc0.patchMinigame.patchDownstairs)		; $78b0
	dec a			; $78b3
	jp z,interactionDelete		; $78b4

	call interactionInitGraphics		; $78b7
	call interactionSetAlwaysUpdateBit		; $78ba
	call interactionIncState		; $78bd

	ld l,Interaction.speed		; $78c0
	ld (hl),SPEED_100		; $78c2

	call objectSetVisiblec2		; $78c4
	ld a,GLOBALFLAG_PATCH_REPAIRED_EVERYTHING		; $78c7
	call checkGlobalFlag		; $78c9
	ld hl,patch_upstairsRepairedEverythingScript		; $78cc
	jr nz,@setScript	; $78cf

	ld a,<TX_5813		; $78d1
	ld (wTmpcfc0.patchMinigame.itemNameText),a		; $78d3
	ld a,$01		; $78d6
	ld (wTmpcfc0.patchMinigame.fixingSword),a		; $78d8

	ld a,TREASURE_TRADEITEM		; $78db
	call checkTreasureObtained		; $78dd
	jr nc,@notRepairingSword	; $78e0
	cp TRADEITEM_BROKEN_SWORD			; $78e2
	jr nz,@notRepairingSword	; $78e4

	ld a,TREASURE_SWORD		; $78e6
	call checkTreasureObtained		; $78e8
	and $01			; $78eb
	ld (wTmpcfc0.patchMinigame.swordLevel),a		; $78ed
	ld hl,patch_upstairsRepairSwordScript		; $78f0
	jr @setScript		; $78f3

@notRepairingSword:
	ld a,<TX_5812		; $78f5
	ld (wTmpcfc0.patchMinigame.itemNameText),a		; $78f7
	xor a			; $78fa
	ld (wTmpcfc0.patchMinigame.fixingSword),a		; $78fb

	; Set var38 to 1 if Link doesn't have the broken tuni nut
	ld a,TREASURE_TUNI_NUT		; $78fe
	call checkTreasureObtained		; $7900
	ld hl,patch_upstairsRepairTuniNutScript		; $7903
	jr nc,++		; $7906
	or a			; $7908
	jr z,@setScript	; $7909
++
	ld e,Interaction.var38		; $790b
	ld a,$01		; $790d
	ld (de),a		; $790f
@setScript:
	jp interactionSetScript		; $7910

@state1:
	ld c,$20		; $7913
	call objectUpdateSpeedZ_paramC		; $7915
	ret nz			; $7918
	call interactionRunScript		; $7919
	jp nc,npcFaceLinkAndAnimate		; $791c

	; Done the script; now load another script to move downstairs

	call interactionIncState		; $791f
	ld hl,patch_upstairsMoveToStaircaseScript		; $7922
	jp interactionSetScript		; $7925


@state2:
	call interactionRunScript		; $7928
	jp nc,interactionAnimate		; $792b

	; Done moving downstairs; restore control to Link
	xor a			; $792e
	ld (wDisabledObjects),a		; $792f
	ld (wMenuDisabled),a		; $7932
	inc a			; $7935
	ld (wTmpcfc0.patchMinigame.patchDownstairs),a		; $7936
	jp interactionDelete		; $7939


; Patch in his minigame room
_patch_subid01:
	ld a,(de)		; $793c
	rst_jumpTable			; $793d
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3
	.dw @state4
	.dw @state5
	.dw @state6

@state0:
	call interactionInitGraphics		; $794c
	call interactionSetAlwaysUpdateBit		; $794f
	call interactionIncState		; $7952
	call objectSetVisiblec2		; $7955

	ld hl,wTmpcfc0.patchMinigame.patchDownstairs		; $7958
	ldi a,(hl)		; $795b
	or a			; $795c
	jp z,interactionDelete		; $795d

	ldi a,(hl) ; a = [wTmpcfc0.patchMinigame.wonMinigame]
	or a			; $7961
	jp nz,@alreadyWonMinigame		; $7962

	xor a			; $7965
	ldi (hl),a ; [wTmpcfc0.patchMinigame.gameStarted]
	ldi (hl),a ; [wTmpcfc0.patchMinigame.failedGame]
	ld (hl),a  ; [wTmpcfc0.patchMinigame.screenFadedOut]
	inc a			; $7969
	ld (wDiggingUpEnemiesForbidden),a		; $796a
	ld hl,patch_downstairsScript		; $796d
	jp interactionSetScript		; $7970

; Waiting for Link to talk to Patch to start the minigame
@state1:
	ld a,(wPaletteThread_mode)		; $7973
	or a			; $7976
	ret nz			; $7977
	call interactionRunScript		; $7978
	jp nc,npcFaceLinkAndAnimate		; $797b

	; Script ended, meaning the minigame will begin now

	ld a,$01		; $797e
	ld (wTmpcfc0.patchMinigame.gameStarted),a		; $7980

	ld a,SND_WHISTLE		; $7983
	call playSound		; $7985
	ld a,MUS_MINIBOSS		; $7988
	ld (wActiveMusic),a		; $798a
	call playSound		; $798d

	; Spawn subid 3, a "manager" for the beetle enemies.
	ldbc INTERACID_PATCH, $03		; $7990
	call objectCreateInteraction		; $7993
	ret nz			; $7996
	ld l,Interaction.relatedObj1		; $7997
	ld a,Interaction.start		; $7999
	ldi (hl),a		; $799b
	ld (hl),d		; $799c

	; Update the tuni nut or trade item state
	ld a,(wTmpcfc0.patchMinigame.fixingSword)		; $799d
	or a			; $79a0
	ld hl,wTuniNutState		; $79a1
	ld a,$01		; $79a4
	jr z,++			; $79a6
	ld hl,wTradeItem		; $79a8
	ld a,TRADEITEM_DOING_PATCH_GAME		; $79ab
++
	ld (hl),a		; $79ad

	ld a,$06		; $79ae
	call interactionSetAnimation		; $79b0
	call interactionIncState		; $79b3
	ld l,Interaction.var39		; $79b6
	ld (hl),$00		; $79b8
	ld hl,patch_duringMinigameScript		; $79ba
	call interactionSetScript		; $79bd

; The minigame is running; wait for all enemies to be killed?
@state2:
	ld a,(wTmpcfc0.patchMinigame.failedGame)		; $79c0
	or a			; $79c3
	jr z,@gameRunning	; $79c4

	; Failed minigame

	call checkLinkCollisionsEnabled		; $79c6
	ret nc			; $79c9

	ld a,DISABLE_LINK		; $79ca
	ld (wDisabledObjects),a		; $79cc
	ld e,Interaction.state		; $79cf
	ld a,$05		; $79d1
	ld (de),a		; $79d3
	dec a			; $79d4
	jp fadeoutToWhiteWithDelay		; $79d5

@gameRunning:
	; Subid 3 sets var39 to nonzero when all beetles are killed; wait for the signal.
	ld e,Interaction.var39		; $79d8
	ld a,(de)		; $79da
	or a			; $79db
	jr z,@runScriptAndAnimate	; $79dc

	; Link won the game.
	xor a			; $79de
	ld (wTmpcfc0.patchMinigame.gameStarted),a		; $79df
	ld (w1Link.knockbackCounter),a		; $79e2
	call checkLinkVulnerable		; $79e5
	ret nc			; $79e8

	ld a,DISABLE_ALL_BUT_INTERACTIONS		; $79e9
	ld (wDisabledObjects),a		; $79eb
	ld (wMenuDisabled),a		; $79ee

	; Spawn the repaired item
	ld a,(wTmpcfc0.patchMinigame.fixingSword)		; $79f1
	add $06			; $79f4
	ld c,a			; $79f6
	ld b,INTERACID_PATCH		; $79f7
	call objectCreateInteraction		; $79f9
	ret nz			; $79fc
	ld l,Interaction.relatedObj1		; $79fd
	ld a,Interaction.start		; $79ff
	ldi (hl),a		; $7a01
	ld (hl),d		; $7a02

	call interactionIncState		; $7a03
	ld hl,patch_linkWonMinigameScript		; $7a06
	call interactionSetScript		; $7a09
	ld a,SND_SOLVEPUZZLE_2		; $7a0c
	call playSound		; $7a0e
	ld a,(wActiveMusic2)		; $7a11
	ld (wActiveMusic),a		; $7a14
	jp playSound		; $7a17

@runScriptAndAnimate:
	call interactionRunScript		; $7a1a
	jp interactionAnimateAsNpc		; $7a1d

; Just won the game
@state3:
	ld a,(wPaletteThread_mode)		; $7a20
	or a			; $7a23
	jr nz,+			; $7a24
	ld a,(wTextIsActive)		; $7a26
	or a			; $7a29
	jr z,++			; $7a2a
+
	jp interactionAnimate		; $7a2c
++
	call interactionRunScript		; $7a2f
	jr nc,@faceLinkAndAnimate	; $7a32

	ld a,(wTmpcfc0.patchMinigame.fixingSword)		; $7a34
	or a			; $7a37
	ld a,GLOBALFLAG_PATCH_REPAIRED_EVERYTHING		; $7a38
	call nz,setGlobalFlag		; $7a3a

@alreadyWonMinigame:
	ld e,Interaction.state		; $7a3d
	ld a,$04		; $7a3f
	ld (de),a		; $7a41
	ld hl,patch_downstairsAfterBeatingMinigameScript		; $7a42
	jp interactionSetScript		; $7a45

; NPC after winning the game
@state4:
	call interactionRunScript		; $7a48
@faceLinkAndAnimate:
	jp npcFaceLinkAndAnimate		; $7a4b

; Failed the game
@state5:
	ld a,(wPaletteThread_mode)		; $7a4e
	or a			; $7a51
	ret nz			; $7a52

	; Delete all the enemies
	ldhl FIRST_ENEMY_INDEX, Enemy.id		; $7a53
@nextEnemy:
	ld a,(hl)		; $7a56
	cp ENEMYID_HARMLESS_HARDHAT_BEETLE			; $7a57
	jr nz,++		; $7a59
	push hl			; $7a5b
	ld d,h			; $7a5c
	ld e,Enemy.start		; $7a5d
	call objectDelete_de		; $7a5f
	pop hl			; $7a62
++
	inc h			; $7a63
	ld a,h			; $7a64
	cp LAST_ENEMY_INDEX+1			; $7a65
	jr c,@nextEnemy	; $7a67

	ldh a,(<hActiveObject)	; $7a69
	ld d,a			; $7a6b

	; Give back the broken item
	ld a,(wTmpcfc0.patchMinigame.fixingSword)		; $7a6c
	or a			; $7a6f
	ld hl,wTuniNutState		; $7a70
	jr z,+			; $7a73
	ld hl,wTradeItem		; $7a75
	ld a,TRADEITEM_BROKEN_SWORD		; $7a78
+
	ld (hl),a		; $7a7a

	call interactionIncState		; $7a7b
	ld a,(wActiveMusic2)		; $7a7e
	ld (wActiveMusic),a		; $7a81
	call playSound		; $7a84
	ld hl,patch_linkFailedMinigameScript		; $7a87
	jp interactionSetScript		; $7a8a

@state6:
	call interactionRunScript		; $7a8d
	jr nc,@faceLinkAndAnimate	; $7a90
	ld e,Interaction.state		; $7a92
	xor a			; $7a94
	ld (de),a		; $7a95
	jr @faceLinkAndAnimate		; $7a96


; The minecart in Patch's minigame
_patch_subid02:
	ld a,(wActiveTriggers)		; $7a98
	ld (wSwitchState),a		; $7a9b
	ld e,Interaction.state		; $7a9e
	ld a,(de)		; $7aa0
	rst_jumpTable			; $7aa1
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3

@state0:
	; Spawn the object that will toggle the minecart track when the button is down
	call getFreeInteractionSlot		; $7aaa
	ret nz			; $7aad
	ld (hl),INTERACID_SWITCH_TILE_TOGGLER		; $7aae
	inc l			; $7ab0
	ld (hl),$01		; $7ab1
	ld l,Interaction.yh		; $7ab3
	ld (hl),$05		; $7ab5
	ld l,Interaction.xh		; $7ab7
	ld (hl),$0b		; $7ab9

	call interactionInitGraphics		; $7abb
	call interactionIncState		; $7abe
	ld l,Interaction.angle		; $7ac1
	ld (hl),ANGLE_RIGHT		; $7ac3
	ld l,Interaction.speed		; $7ac5
	ld (hl),SPEED_100		; $7ac7
	ld a,$06		; $7ac9
	call objectSetCollideRadius		; $7acb
	jp objectSetVisible82		; $7ace

; Wait for game to start
@state1:
	ld a,(wTmpcfc0.patchMinigame.gameStarted)		; $7ad1
	or a			; $7ad4
	ret z			; $7ad5

	; Spawn the broken item sprite (INTERACID_PATCH subid 4 or 5)
	call getFreeInteractionSlot		; $7ad6
	ret nz			; $7ad9
	ld (hl),INTERACID_PATCH		; $7ada
	inc l			; $7adc
	ld a,(wTmpcfc0.patchMinigame.fixingSword)		; $7add
	add $04			; $7ae0
	ld (hl),a		; $7ae2
	ld l,Interaction.relatedObj1		; $7ae3
	ld a,Interaction.start		; $7ae5
	ldi (hl),a		; $7ae7
	ld (hl),d		; $7ae8
	jp interactionIncState		; $7ae9

; Game is running
@state2:
	ld hl,wTmpcfc0.patchMinigame.gameStarted		; $7aec
	ldi a,(hl)		; $7aef
	or a			; $7af0
	jr z,@incState		; $7af1

	; Check if the game is failed; if so, wait for the screen to fade out.
	ldi a,(hl) ; a = [wTmpcfc0.patchMinigame.failedGame]
	or a			; $7af4
	jr z,@gameStillGoing	; $7af5
	ld a,(hl)  ; a = [wTmpcfc0.patchMinigame.screenFadedOut]
	or a			; $7af8
	ret z			; $7af9

	; Reset position
	ld h,d			; $7afa
	ld l,Interaction.yh		; $7afb
	ld (hl),$08		; $7afd
	ld l,Interaction.xh		; $7aff
	ld (hl),$68		; $7b01
@incState:
	jp interactionIncState		; $7b03

@gameStillGoing:
	call objectApplySpeed		; $7b06
	call interactionAnimate		; $7b09

	; Check if it's reached the center of a new tile
	ld h,d			; $7b0c
	ld l,Interaction.yh		; $7b0d
	ldi a,(hl)		; $7b0f
	and $0f			; $7b10
	cp $08			; $7b12
	ret nz			; $7b14
	inc l			; $7b15
	ld a,(hl)		; $7b16
	and $0f			; $7b17
	cp $08			; $7b19
	ret nz			; $7b1b

	; Determine the new angle to move in
	call objectGetTileAtPosition		; $7b1c
	ld e,a			; $7b1f
	ld a,l			; $7b20
	cp $15			; $7b21
	ld a,$08		; $7b23
	jr z,+			; $7b25
	ld hl,@trackTable		; $7b27
	call lookupKey		; $7b2a
	ret nc			; $7b2d
+
	ld e,Interaction.angle		; $7b2e
	ld (de),a		; $7b30
	bit 3,a			; $7b31
	ld a,$07		; $7b33
	jr z,+			; $7b35
	inc a			; $7b37
+
	jp interactionSetAnimation		; $7b38

@trackTable:
	.db TILEINDEX_TRACK_TR, ANGLE_DOWN
	.db TILEINDEX_TRACK_BR, ANGLE_LEFT
	.db TILEINDEX_TRACK_BL, ANGLE_UP
	.db TILEINDEX_TRACK_TL, ANGLE_RIGHT
	.db $00

; Stop moving until the game starts up again
@state3:
	ld a,(wTmpcfc0.patchMinigame.gameStarted)		; $7b44
	or a			; $7b47
	ret nz			; $7b48
	inc a			; $7b49
	ld (de),a		; $7b4a
	ret			; $7b4b


; Subid 3 = Beetle "manager"; spawns them and check when they're killed.
;
; Variables:
;   counter1: Number of beetles to be killed (starts at 4 or 8)
;   var3a: Set to 1 when another beetle should be spawned
;   var3b: Number of extra beetles spawned so far
_patch_subid03:
	ld e,Interaction.state		; $7b4c
	ld a,(de)		; $7b4e
	rst_jumpTable			; $7b4f
	.dw @state0
	.dw @state1
	.dw @state2

@state0:
	callab interactionBank1.clearFallDownHoleEventBuffer		; $7b56
	call interactionIncState		; $7b5e
	ld l,Interaction.counter1		; $7b61
	ld (hl),60		; $7b63
	ret			; $7b65

@state1:
	call interactionDecCounter1		; $7b66
	ret nz			; $7b69

	; Determine total number of beetles (4 or 8) and write that to counter1
	ld a,(wTmpcfc0.patchMinigame.fixingSword)		; $7b6a
	add a			; $7b6d
	add a			; $7b6e
	add $04			; $7b6f
	ld (hl),a		; $7b71
	call interactionIncState		; $7b72

	ld c,$44		; $7b75
	call @spawnBeetle		; $7b77
	ld c,$4a		; $7b7a
	call @spawnBeetle		; $7b7c
	ld c,$75		; $7b7f
	call @spawnBeetle		; $7b81
	ld c,$78		; $7b84
@spawnBeetle:
	call getFreeInteractionSlot		; $7b86
	ret nz			; $7b89
	ld (hl),INTERACID_PUFF		; $7b8a
	ld l,Interaction.yh		; $7b8c
	call setShortPosition_paramC		; $7b8e
	call getFreeEnemySlot		; $7b91
	ret nz			; $7b94
	ld (hl),ENEMYID_HARMLESS_HARDHAT_BEETLE		; $7b95
	ld l,Enemy.yh		; $7b97
	call setShortPosition_paramC		; $7b99
	xor a			; $7b9c
	ret			; $7b9d

@state2:
	ld a,(wTmpcfc0.patchMinigame.failedGame)		; $7b9e
	or a			; $7ba1
	jr nz,@delete	; $7ba2

	; Check which objects have fallen into holes
	ld hl,wTmpcfc0.fallDownHoleEvent.cfd8+1		; $7ba4
	ld b,$04		; $7ba7
---
	ldi a,(hl)		; $7ba9
	cp ENEMYID_HARMLESS_HARDHAT_BEETLE			; $7baa
	jr nz,@nextFallenObject	; $7bac

	push hl			; $7bae
	call interactionDecCounter1		; $7baf
	jr z,@allBeetlesKilled			; $7bb2
	ld a,(hl)		; $7bb4
	cp $04			; $7bb5
	jr c,++			; $7bb7
	ld l,Interaction.var3a		; $7bb9
	inc (hl)		; $7bbb
++
	pop hl			; $7bbc

@nextFallenObject:
	inc l			; $7bbd
	dec b			; $7bbe
	jr nz,---		; $7bbf

	ld e,Interaction.var3a		; $7bc1
	ld a,(de)		; $7bc3
	or a			; $7bc4
	jr z,++			; $7bc5

	; Killed one of the first 4 beetles; spawn another.
	ld e,Interaction.var3b		; $7bc7
	ld a,(de)		; $7bc9
	ld hl,@extraBeetlePositions		; $7bca
	rst_addAToHl			; $7bcd
	ld c,(hl)		; $7bce
	call @spawnBeetle		; $7bcf
	jr nz,++		; $7bd2
	ld h,d			; $7bd4
	ld l,Interaction.var3a		; $7bd5
	dec (hl)		; $7bd7
	inc l			; $7bd8
	inc (hl)		; $7bd9
++
	jpab interactionBank1.clearFallDownHoleEventBuffer		; $7bda

@allBeetlesKilled:
	; Set parent object's "var39" to indicate that the game's over
	pop hl			; $7be2
	ld a,Object.var39		; $7be3
	call objectGetRelatedObject1Var		; $7be5
	inc (hl)		; $7be8
@delete:
	jp interactionDelete		; $7be9

@extraBeetlePositions:
	.db $4a $57 $75 $78



; Broken tuni nut (4) or sword (5) sprite
_patch_subid04:
_patch_subid05:
	ld e,Interaction.state		; $7bf0
	ld a,(de)		; $7bf2
	rst_jumpTable			; $7bf3
	.dw @state0
	.dw @state1
	.dw @state2

@state0:
	call interactionInitGraphics		; $7bfa
	call interactionIncState		; $7bfd

	ld l,Interaction.yh		; $7c00
	ld (hl),$18		; $7c02
	ld l,Interaction.xh		; $7c04
	ld (hl),$78		; $7c06
	ld bc,$0606		; $7c08
	call objectSetCollideRadii		; $7c0b
	jp objectSetVisible83		; $7c0e

@state1:
	; When a "palette fade" occurs, assume the game's ended (go to state 2)
	ld a,(wPaletteThread_mode)		; $7c11
	or a			; $7c14
	jp nz,interactionIncState		; $7c15

	; Check if relatedObj1 (the minecart) has collided with it
	ld a,Object.start		; $7c18
	call objectGetRelatedObject1Var		; $7c1a
	call checkObjectsCollided		; $7c1d
	ret nc			; $7c20

	; Collision occured; game failed.
	ld a,$01		; $7c21
	ld (wTmpcfc0.patchMinigame.failedGame),a		; $7c23
	ld b,INTERACID_EXPLOSION		; $7c26
	call objectCreateInteractionWithSubid00		; $7c28
	ret nz			; $7c2b
	ld l,Interaction.var03		; $7c2c
	inc (hl)		; $7c2e
	ld l,Interaction.xh		; $7c2f
	ld a,(hl)		; $7c31
	sub $08			; $7c32
	ld (hl),a		; $7c34
	jp interactionIncState		; $7c35

@state2:
	ld a,(wTmpcfc0.patchMinigame.screenFadedOut)		; $7c38
	or a			; $7c3b
	ret z			; $7c3c
	jp interactionDelete		; $7c3d



; Fixed tuni nut (6) or sword (7) sprite
_patch_subid06:
_patch_subid07:
	call checkInteractionState		; $7c40
	jr z,@state0	; $7c43

@state1:
	call interactionDecCounter1		; $7c45
	ret nz			; $7c48
	jp interactionDelete		; $7c49

@state0:
	ld a,(wTmpcfc0.patchMinigame.wonMinigame)		; $7c4c
	or a			; $7c4f
	ret z			; $7c50

	call interactionInitGraphics		; $7c51
	call interactionIncState		; $7c54
	ld l,Interaction.counter1		; $7c57
	ld (hl),60		; $7c59

	; If this is the L3 sword, need to change the palette & animation
	ld l,Interaction.subid		; $7c5b
	ld a,(hl)		; $7c5d
	cp $06			; $7c5e
	jr z,@getPosition	; $7c60
	ld a,(wTmpcfc0.patchMinigame.swordLevel)		; $7c62
	or a			; $7c65
	jr nz,@getPosition	; $7c66

	ld l,Interaction.oamFlagsBackup		; $7c68
	ld a,$04		; $7c6a
	ldi (hl),a		; $7c6c
	ld (hl),a		; $7c6d
	ld a,$0c		; $7c6e
	call interactionSetAnimation		; $7c70

@getPosition:
	; Copy position from relatedObj1 (patch)
	ld a,Object.start		; $7c73
	call objectGetRelatedObject1Var		; $7c75
	ld bc,$f2f8		; $7c78
	call objectTakePositionWithOffset		; $7c7b
	jp objectSetVisible81		; $7c7e



; ==============================================================================
; INTERACID_BALL
; ==============================================================================
interactionCode95:
	ld e,Interaction.state		; $7c81
	ld a,(de)		; $7c83
	rst_jumpTable			; $7c84
	.dw @state0
	.dw @state1

@state0:
	call interactionIncState		; $7c89
	ld l,Interaction.speed		; $7c8c
	ld (hl),SPEED_200		; $7c8e
	call interactionInitGraphics		; $7c90
	jp objectSetVisible80		; $7c93

@state1:
	ld e,Interaction.state2		; $7c96
	ld a,(de)		; $7c98
	rst_jumpTable			; $7c99
	.dw @substate0
	.dw @substate1
	.dw @substate2

@substate0:
	ld a,($cfd3)		; $7ca0
	or a			; $7ca3
	ret z			; $7ca4
	call interactionIncState2		; $7ca5
	ld b,ANGLE_RIGHT		; $7ca8
	dec a			; $7caa
	jr z,+			; $7cab
	ld b,ANGLE_LEFT		; $7cad
+
	ld l,Interaction.angle		; $7caf
	ld (hl),b		; $7cb1
	ld l,Interaction.subid		; $7cb2
	ld (hl),a		; $7cb4
	cp $02			; $7cb5
	jr nz,++		; $7cb7
	ld bc,$5075		; $7cb9
	call interactionHSetPosition		; $7cbc
	ld l,Interaction.zh		; $7cbf
	ld (hl),-$06		; $7cc1
++
	ld bc,-$1c0		; $7cc3
	jp objectSetSpeedZ		; $7cc6

@substate1:
	call objectApplySpeed		; $7cc9
	ld c,$20		; $7ccc
	call objectUpdateSpeedZ_paramC		; $7cce
	ret nz			; $7cd1

	; Ball has landed

	ld e,Interaction.subid		; $7cd2
	ld a,(de)		; $7cd4
	cp $02			; $7cd5
	jr z,@subid2			; $7cd7

	dec a			; $7cd9
	ld bc,$4a3c		; $7cda
	jr z,+			; $7cdd
	ld c,$75		; $7cdf
+
	xor a			; $7ce1
	ld ($cfd3),a		; $7ce2
	ld e,Interaction.state2		; $7ce5
	ld (de),a		; $7ce7
	jp interactionSetPosition		; $7ce8

@subid2:
	; [speedZ] = -[speedZ]/2
	ld l,Interaction.speedZ+1		; $7ceb
	ldd a,(hl)		; $7ced
	srl a			; $7cee
	ld b,a			; $7cf0
	ld a,(hl)		; $7cf1
	rra			; $7cf2
	cpl			; $7cf3
	add $01			; $7cf4
	ldi (hl),a		; $7cf6
	ld a,b			; $7cf7
	cpl			; $7cf8
	adc $00			; $7cf9
	ldd (hl),a		; $7cfb

	; Go to substate 2 (stop doing anything) if the ball's Z speed has gone too low
	ld bc,$ff80		; $7cfc
	ldi a,(hl)		; $7cff
	ld h,(hl)		; $7d00
	ld l,a			; $7d01
	call compareHlToBc		; $7d02
	ret c			; $7d05
	jp interactionIncState2		; $7d06

@substate2:
	ret			; $7d09



; ==============================================================================
; INTERACID_MOBLIN
; ==============================================================================
interactionCode96:
	ld e,Interaction.subid		; $7d0a
	ld a,(de)		; $7d0c
	rst_jumpTable			; $7d0d
	.dw @subid0
	.dw @subid1

@subid0:
@subid1:
	call checkInteractionState		; $7d12
	jr nz,@state1	; $7d15

@state0:
	call @initGraphicsAndLoadScript		; $7d17
@state1:
	call interactionRunScript		; $7d1a
	jp c,interactionDelete		; $7d1d

	ld e,Interaction.var3f		; $7d20
	ld a,(de)		; $7d22
	or a			; $7d23
	jr nz,+			; $7d24
	call interactionAnimate		; $7d26
+
	jp interactionPushLinkAwayAndUpdateDrawPriority		; $7d29

@initGraphics: ; unused
	call interactionInitGraphics		; $7d2c
	jp interactionIncState		; $7d2f

@initGraphicsAndLoadScript:
	call interactionInitGraphics		; $7d32
	ld e,$42		; $7d35
	ld a,(de)		; $7d37
	ld hl,@scriptTable		; $7d38
	rst_addDoubleIndex			; $7d3b
	ldi a,(hl)		; $7d3c
	ld h,(hl)		; $7d3d
	ld l,a			; $7d3e
	call interactionSetScript		; $7d3f
	jp interactionIncState		; $7d42

@scriptTable:
	.dw moblin_subid00Script
	.dw moblin_subid01Script


; ==============================================================================
; INTERACID_97
; ==============================================================================
interactionCode97:
	ld e,Interaction.subid		; $7d49
	ld a,(de)		; $7d4b
	rst_jumpTable			; $7d4c
	.dw _interaction97_subid00
	.dw _interaction97_subid01

_interaction97_subid00:
	call checkInteractionState		; $7d51
	jr z,@state0	; $7d54

@state1:
	call interactionDecCounter1		; $7d56
	jp z,interactionDelete		; $7d59

	inc l			; $7d5c
	dec (hl) ; [counter2]--
	ret nz			; $7d5e
	call getRandomNumber		; $7d5f
	and $03			; $7d62
	ld a,$03		; $7d64
	ld (hl),a		; $7d66

	call getRandomNumber_noPreserveVars		; $7d67
	and $1f			; $7d6a
	sub $10			; $7d6c
	ld c,a			; $7d6e
	call getRandomNumber		; $7d6f
	and $07			; $7d72
	sub $04			; $7d74
	ld b,a			; $7d76
	call getFreeInteractionSlot		; $7d77
	ret nz			; $7d7a
	ld (hl),INTERACID_PUFF		; $7d7b
	jp objectCopyPositionWithOffset		; $7d7d

@state0:
	call interactionIncState		; $7d80
	ld l,Interaction.counter1		; $7d83
	ld (hl),$6a		; $7d85
	inc l			; $7d87
	inc (hl)		; $7d88
	ret			; $7d89


_interaction97_subid01:
	call checkInteractionState		; $7d8a
	jr z,@state0	; $7d8d

@state1:
	call interactionDecCounter1		; $7d8f
	ret nz			; $7d92
	ld (hl),$12		; $7d93
	inc l			; $7d95
	dec (hl)		; $7d96
	jp z,interactionDelete		; $7d97

	call getRandomNumber_noPreserveVars		; $7d9a
	and $03			; $7d9d
	add $0c			; $7d9f
	ld b,a			; $7da1

@spawnBubble:
	add a			; $7da2
	add b			; $7da3
	ld hl,@positions		; $7da4
	rst_addAToHl			; $7da7
	ldi a,(hl)		; $7da8
	ld b,a			; $7da9
	ldi a,(hl)		; $7daa
	ld c,a			; $7dab
	ld e,(hl)		; $7dac
	call getFreePartSlot		; $7dad
	ret nz			; $7db0
	ld (hl),PARTID_16		; $7db1
	inc l			; $7db3
	ld (hl),e		; $7db4
	ld l,Part.yh		; $7db5
	ld (hl),b		; $7db7
	ld l,Part.xh		; $7db8
	ld (hl),c		; $7dba
	ret			; $7dbb

@state0:
	call interactionSetAlwaysUpdateBit		; $7dbc
	call interactionIncState		; $7dbf

	ld l,Interaction.counter1		; $7dc2
	ld (hl),30		; $7dc4
	inc l			; $7dc6
	ld (hl),$04 ; [counter2]

	ld b,$0c		; $7dc9
--
	push bc			; $7dcb
	ld a,b			; $7dcc
	dec b			; $7dcd
	dec a			; $7dce
	call @spawnBubble		; $7dcf
	pop bc			; $7dd2
	dec b			; $7dd3
	jr nz,--		; $7dd4
	ret			; $7dd6

; Data format:
;   b0: Y
;   b1: X
;   b2: Subid for PARTID_16
@positions:
	.db $40 $2f $00
	.db $42 $31 $00
	.db $40 $35 $01
	.db $3e $3a $00
	.db $42 $40 $00
	.db $42 $46 $00
	.db $40 $5d $01
	.db $3e $62 $00
	.db $40 $69 $01
	.db $40 $6c $01
	.db $42 $3f $00
	.db $40 $71 $00
	.db $3e $3c $01
	.db $3a $48 $01
	.db $3c $54 $01
	.db $3e $62 $01


.BANK $0b SLOT 1
.ORG 0


; ==============================================================================
; INTERACID_WOODEN_TUNNEL
; ==============================================================================
interactionCode98:
	ld e,Interaction.state		; $4000
	ld a,(de)		; $4002
	rst_jumpTable			; $4003
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $4008
	ld (de),a		; $400a
	call interactionInitGraphics		; $400b
	ld a,$07		; $400e
	call objectSetCollideRadius		; $4010

	; Set animation (direction of tunnel) based on subid
	ld e,Interaction.subid		; $4013
	ld a,(de)		; $4015
	jr +			; $4016
+
	call interactionSetAnimation		; $4018
	jp objectSetVisible81		; $401b

@state1:
	; Make solid if Link's grabbing something or is on the companion
	ld a,(wLinkGrabState)		; $401e
	or a			; $4021
	jr nz,@makeSolid	; $4022
	ld a,(wLinkObjectIndex)		; $4024
	bit 0,a			; $4027
	jr nz,@makeSolid	; $4029
	ld a,(w1ReservedItemC.enabled)		; $402b
	or a			; $402e
	jr nz,@makeSolid	; $402f

	; Allow Link to pass, but set solidity so he can only pass through the center
	ld e,Interaction.subid		; $4031
	ld a,(de)		; $4033
	cp $02			; $4034
	ld c,SPECIALCOLLISION_VERTICAL_BRIDGE		; $4036
	jr c,@setSolidity	; $4038
	ld c,SPECIALCOLLISION_HORIZONTAL_BRIDGE		; $403a
	jr @setSolidity		; $403c

@makeSolid:
	ld c,$0f		; $403e
@setSolidity:
	call objectGetShortPosition		; $4040
	ld h,>wRoomCollisions		; $4043
	ld l,a			; $4045
	ld (hl),c		; $4046
	ret			; $4047


; ==============================================================================
; INTERACID_EXCLAMATION_MARK
; ==============================================================================
interactionCode9f:
	ld e,Interaction.state		; $4048
	ld a,(de)		; $404a
	rst_jumpTable			; $404b
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $4050
	ld (de),a		; $4052
	ld h,d			; $4053

	; Always update, even when textboxes are up
	ld l,Interaction.enabled		; $4054
	set 7,(hl)		; $4056

	call interactionInitGraphics		; $4058
	jp objectSetVisible80		; $405b

@state1:
	ld h,d			; $405e
	ld l,Interaction.counter1		; $405f
	ld a,(hl)		; $4061
	inc a			; $4062
	jp z,interactionAnimate		; $4063
	dec (hl)		; $4066
	jp nz,interactionAnimate		; $4067
	jp interactionDelete		; $406a

;;
; Called from "objectCreateExclamationMark" in bank 0.
; Creates an "exclamation mark" interaction, complete with sound effect.
;
; @param	a	How long to show the exclamation mark for (0 or $ff for
;                       indefinitely).
; @param	bc	Offset from the object to create the exclamation mark at.
; @param	d	The object to use for the base position of the exclamation mark.
; @addr{406d}
objectCreateExclamationMark_body:
	ldh (<hFF8B),a	; $406d
	call getFreeInteractionSlot		; $406f
	ret nz			; $4072

	ld (hl),INTERACID_EXCLAMATION_MARK		; $4073
	ld l,Interaction.counter1		; $4075
	ldh a,(<hFF8B)	; $4077
	ld (hl),a		; $4079
	call objectCopyPositionWithOffset		; $407a

	push hl			; $407d
	ld a,SND_CLINK		; $407e
	call playSound		; $4080
	pop hl			; $4083
	ret			; $4084

;;
; Create an interaction with id $a0 (INTERACID_FLOATING_IMAGE). Its position will be
; placed at the current object's position + bc.
;
; @param	bc	Offset relative to object to place the interaction at
; @param	hFF8D	Interaction.subid (0 for snore, 1 for music note)
; @param	hFF8B	Interaction.var03 (0 to float left, 1 to float right)
; @addr{4085}
objectCreateFloatingImage:
	call getFreeInteractionSlot		; $4085
	ret nz			; $4088
	ld (hl),INTERACID_FLOATING_IMAGE		; $4089
	inc l			; $408b
	ldh a,(<hFF8D)	; $408c
	ldi (hl),a		; $408e
	ldh a,(<hFF8B)	; $408f
	ld (hl),a		; $4091
	jp objectCopyPositionWithOffset		; $4092


; ==============================================================================
; INTERACID_FLOATING_IMAGE
; ==============================================================================
interactionCodea0:
	ld e,Interaction.state		; $4095
	ld a,(de)		; $4097
	rst_jumpTable			; $4098
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $409d
	ld (de),a		; $409f

	call interactionSetAlwaysUpdateBit		; $40a0
	call interactionInitGraphics		; $40a3

	; Set 'b' to the angle to veer off toward (left or right, depending on var03)
	ld h,d			; $40a6
	ld b,$03		; $40a7
	ld l,Interaction.var03		; $40a9
	ld a,(hl)		; $40ab
	or a			; $40ac
	jr nz,+			; $40ad
	ld b,$1d		; $40af
+
	ld l,Interaction.angle		; $40b1
	ld (hl),b		; $40b3
	ld l,Interaction.speed		; $40b4
	ld (hl),SPEED_60		; $40b6

	; Delete after 70 frames
	ld l,Interaction.counter1		; $40b8
	ld (hl),70		; $40ba

	jp objectSetVisible80		; $40bc

@state1:
	; Check whether it's a snore or a music note (but the behaviour is the same)
	ld e,Interaction.subid		; $40bf
	ld a,(de)		; $40c1
	or a			; $40c2
	jr nz,+			; $40c3
+
	; Delete after 70 frames
	call interactionDecCounter1		; $40c5
	jp z,interactionDelete		; $40c8

	call objectApplySpeed		; $40cb
	ld e,Interaction.var30		; $40ce
	ld (de),a		; $40d0

	; Update x position every 8 frames based on wFrameCounter
	ld a,(wFrameCounter)		; $40d1
	and $07			; $40d4
	ret nz			; $40d6

	push de			; $40d7
	ld h,d			; $40d8
	ld a,(wFrameCounter)		; $40d9
	and $38			; $40dc
	swap a			; $40de
	rlca			; $40e0
	ld de,@xOffsets		; $40e1
	call addAToDe		; $40e4
	ld a,(de)		; $40e7
	ld l,Interaction.var30		; $40e8
	add (hl)		; $40ea
	ld l,Interaction.xh		; $40eb
	ld (hl),a		; $40ed
	pop de			; $40ee
	ret			; $40ef

@xOffsets:
	.db $ff $fe $ff $00
	.db $01 $02 $01 $00


; ==============================================================================
; INTERACID_BIPIN_BLOSSOM_FAMILY_SPAWNER
; ==============================================================================
interactionCodeac:
	ld a,GLOBALFLAG_FINISHEDGAME		; $40f8
	call checkGlobalFlag		; $40fa
	jp nz,interactionDelete		; $40fd

	call _childSetVar38ToNumEssencesObtained		; $4100
	call @checkUpdateState		; $4103
	call _spawnBipinBlossomFamilyObjects		; $4106
	ld hl,wSeedTreeRefilledBitset		; $4109
	res 1,(hl)		; $410c
	jp interactionDelete		; $410e


; Check whether the player has been gone long enough for the child to proceed to the next
; stage of development (uses wSeedTreeRefilledBitset to ensure that Link's been off
; somewhere else for a while).
; Also checks that Link has enough essences for certain stages of development.
@checkUpdateState:
	ld a,(wSeedTreeRefilledBitset)		; $4111
	bit 1,a			; $4114
	ret z			; $4116

	ld hl,wNextChildStage		; $4117
	ld a,(hl)		; $411a
	ld a,(hl)		; $411b
	rst_jumpTable			; $411c
	.dw @gotoNextState
	.dw @need2Essences
	.dw @gotoNextState_2
	.dw @need4Essences
	.dw @need6Essences
	.dw @gotoNextState_2
	.dw @gotoNextState_2
	.dw @need2Essences
	.dw @need4Essences
	.dw @need6Essences

@gotoNextState:
	ld a,(wNextChildStage)		; $4131
	ld (wChildStage),a		; $4134
	cp $04			; $4137
	jp z,_decideInitialChildPersonality		; $4139
	cp $07			; $413c
	jp z,_decideFinalChildPersonality		; $413e
	ret			; $4141

@need2Essences:
	ld e,Interaction.var38		; $4142
	ld a,(de)		; $4144
	cp $02			; $4145
	ret c			; $4147
	jr @gotoNextState		; $4148

@gotoNextState_2:
	jr @gotoNextState		; $414a

@need4Essences:
	ld e,Interaction.var38		; $414c
	ld a,(de)		; $414e
	cp $04			; $414f
	ret c			; $4151
	jr @gotoNextState		; $4152

@need6Essences:
	ld e,Interaction.var38		; $4154
	ld a,(de)		; $4156
	cp $06			; $4157
	ret c			; $4159
	jr @gotoNextState		; $415a

;;
; This is called on file initialization. In a linked game, wChildStatus will be nonzero if
; he was given a name, so he will start at stage 5.
; @addr{415c}
initializeChildOnGameStart:
	ld hl,wChildStatus		; $415c
	ld a,(hl)		; $415f
	or a			; $4160
	ret z			; $4161

	ld a,$05		; $4162
	ld l,<wChildStage		; $4164
	ldi (hl),a		; $4166
	ldi (hl),a		; $4167

;;
; @addr{4168}
_decideInitialChildPersonality:
	ld hl,_initialChildPersonalityTable		; $4168
	jr _label_0b_006		; $416b

;;
; @addr{416d}
_decideFinalChildPersonality:
	; a = [wChildPersonality] * 6
	ld a,(wChildPersonality)		; $416d
	add a			; $4170
	ld b,a			; $4171
	add a			; $4172
	add b			; $4173

	ld hl,_finalChildPersonalityTable		; $4174
	rst_addAToHl			; $4177
_label_0b_006:
	ld a,(wChildStatus)		; $4178
@label_0b_007:
	cp (hl)			; $417b
	jr nc,@label_0b_008	; $417c
	inc hl			; $417e
	inc hl			; $417f
	jr @label_0b_007		; $4180
@label_0b_008:
	inc hl			; $4182
	ld a,(hl)		; $4183
	ld (wChildPersonality),a		; $4184
	ret			; $4187

_initialChildPersonalityTable:
	.db $0b $00 ; status >= 11: Hyperactive
	.db $06 $01 ; status >= 6:  Shy
	.db $00 $02 ; status >= 0:  Curious

_finalChildPersonalityTable:
	; Hyperactive
	.db $1a $02 ; status >= 26: Arborist
	.db $15 $01 ; status >= 21: Warrior
	.db $00 $00 ; status >= 0:  Slacker

	; Shy
	.db $13 $02 ; status >= 19: Arborist
	.db $0f $00 ; status >= 15: Slacker
	.db $00 $03 ; status >= 0:  Singer

	; Curious
	.db $0e $01 ; status >= 14: Warrior
	.db $0a $00 ; status >= 10: Slacker
	.db $00 $03 ; status >= 0:  Singer

;;
; @addr{41a0}
_childSetVar38ToNumEssencesObtained:
	ld a,TREASURE_ESSENCE		; $41a0
	call checkTreasureObtained		; $41a2
	jr c,+			; $41a5
	xor a			; $41a7
+
	ld h,d			; $41a8
	ld l,Interaction.var38		; $41a9
	ld (hl),$00		; $41ab
@nextBit:
	add a			; $41ad
	jr nc,+			; $41ae
	inc (hl)		; $41b0
+
	or a			; $41b1
	jr nz,@nextBit		; $41b2
	ret			; $41b4

;;
; Spawn bipin, blossom, and child objects depending on the stage of the child's
; development, which part of the house this is, and the child's personality.
;
; @addr{41b5}
_spawnBipinBlossomFamilyObjects:
	ld e,Interaction.subid		; $41b5
	ld a,(de)		; $41b7
	or a			; $41b8
	ld hl,@leftHouseInteractions		; $41b9
	jr z,+			; $41bc
	ld hl,@rightHouseInteractions		; $41be
+
	ld a,(wChildStage)		; $41c1
	cp $04			; $41c4
	jr c,++			; $41c6

	rst_addDoubleIndex			; $41c8
	ldi a,(hl)		; $41c9
	ld h,(hl)		; $41ca
	ld l,a			; $41cb
	ld a,(wChildPersonality)		; $41cc
++
	rst_addDoubleIndex			; $41cf
	ldi a,(hl)		; $41d0
	ld b,(hl)		; $41d1
	ld c,a			; $41d2

@loop:
	ld a,(bc)		; $41d3
	or a			; $41d4
	ret z			; $41d5
	call getFreeInteractionSlot		; $41d6
	ret nz			; $41d9

	; id
	ld a,(bc)		; $41da
	ldi (hl),a		; $41db

	; subid
	inc bc			; $41dc
	ld a,(bc)		; $41dd
	ldi (hl),a		; $41de

	; var03
	inc bc			; $41df
	ld a,(bc)		; $41e0
	ldi (hl),a		; $41e1

	; yh
	inc bc			; $41e2
	ld l,Interaction.yh		; $41e3
	ld a,(bc)		; $41e5
	ld (hl),a		; $41e6

	; xh
	inc bc			; $41e7
	ld l,Interaction.xh		; $41e8
	ld a,(bc)		; $41ea
	ld (hl),a		; $41eb
	inc bc			; $41ec
	jr @loop		; $41ed

@leftHouseInteractions:
	.dw @leftStage0
	.dw @leftStage1
	.dw @leftStage2
	.dw @leftStage3
	.dw @@stage4
	.dw @@stage5
	.dw @@stage6
	.dw @@stage7
	.dw @@stage8
	.dw @@stage9

@@stage4:
	.dw @leftStage4_hyperactive
	.dw @leftStage4_shy
	.dw @leftStage4_curious
@@stage5:
	.dw @leftStage5_hyperactive
	.dw @leftStage5_shy
	.dw @leftStage5_curious
@@stage6:
	.dw @leftStage6_hyperactive
	.dw @leftStage6_shy
	.dw @leftStage6_curious
@@stage7:
	.dw @leftStage7_slacker
	.dw @leftStage7_warrior
	.dw @leftStage7_arborist
	.dw @leftStage7_singer
@@stage8:
	.dw @leftStage8_slacker
	.dw @leftStage8_warrior
	.dw @leftStage8_arborist
	.dw @leftStage8_singer
@@stage9:
	.dw @leftStage9_slacker
	.dw @leftStage9_warrior
	.dw @leftStage9_arborist
	.dw @leftStage9_singer

@rightHouseInteractions:
	.dw @rightStage0
	.dw @rightStage1
	.dw @rightStage2
	.dw @rightStage3
	.dw @@stage4
	.dw @@stage5
	.dw @@stage6
	.dw @@stage7
	.dw @@stage8
	.dw @@stage9

@@stage4:
	.dw @rightStage4_hyperactive
	.dw @rightStage4_shy
	.dw @rightStage4_curious
@@stage5:
	.dw @rightStage5_hyperactive
	.dw @rightStage5_shy
	.dw @rightStage5_curious
@@stage6:
	.dw @rightStage6_hyperactive
	.dw @rightStage6_shy
	.dw @rightStage6_curious
@@stage7:
	.dw @rightStage7_slacker
	.dw @rightStage7_warrior
	.dw @rightStage7_arborist
	.dw @rightStage7_singer
@@stage8:
	.dw @rightStage8_slacker
	.dw @rightStage8_warrior
	.dw @rightStage8_arborist
	.dw @rightStage8_singer
@@stage9:
	.dw @rightStage9_slacker
	.dw @rightStage9_warrior
	.dw @rightStage9_arborist
	.dw @rightStage9_singer


; Data format:
;   b0: Interaction ID to spawn (or $00 to stop loading)
;   b1: subid
;   b2: var03
;   b3: Y position
;   b4: X position

@leftStage0:
	.db INTERACID_BIPIN   $00 $00 $48 $48
	.db INTERACID_BLOSSOM $00 $00 $38 $78
@rightStage0:
	.db $00

@leftStage1:
	.db INTERACID_BLOSSOM $01 $00 $18 $48
	.db $00
@rightStage1:
	.db INTERACID_BIPIN   $01 $00 $38 $58
	.db $00

@leftStage2:
	.db INTERACID_BLOSSOM $02 $00 $18 $48
	.db INTERACID_CHILD   $07 $00 $10 $38
	.db $00
@rightStage2:
	.db INTERACID_BIPIN   $02 $00 $38 $58
	.db $00

@leftStage3:
	.db INTERACID_BLOSSOM $03 $00 $38 $78
	.db $00
@rightStage3:
	.db INTERACID_BIPIN   $03 $00 $38 $58
	.db $00

@leftStage4_hyperactive:
	.db INTERACID_BLOSSOM $04 $00 $38 $78
	.db INTERACID_CHILD   $00 $01 $38 $68
	.db $00
@leftStage4_shy:
	.db INTERACID_BLOSSOM $04 $00 $38 $78
	.db INTERACID_CHILD   $01 $02 $38 $18
	.db $00
@leftStage4_curious:
	.db INTERACID_BLOSSOM $04 $00 $38 $78
	.db INTERACID_CHILD   $02 $03 $20 $38
	.db $00

@rightStage4_hyperactive:
@rightStage4_shy:
@rightStage4_curious:
	.db INTERACID_BIPIN   $04 $00 $38 $58
	.db $00

@leftStage5_hyperactive:
	.db INTERACID_BLOSSOM $05 $00 $38 $78
	.db INTERACID_BIPIN   $05 $00 $58 $88
	.db INTERACID_CHILD   $00 $04 $38 $68
	.db $00
@leftStage5_shy:
	.db INTERACID_BLOSSOM $05 $00 $38 $78
	.db INTERACID_BIPIN   $05 $00 $58 $88
	.db INTERACID_CHILD   $01 $05 $38 $18
	.db $00
@leftStage5_curious:
	.db INTERACID_BLOSSOM $05 $00 $38 $78
	.db INTERACID_BIPIN   $05 $00 $58 $88
	.db INTERACID_CHILD   $02 $06 $20 $38
	.db $00

@rightStage5_hyperactive:
@rightStage5_shy:
@rightStage5_curious:
	.db $00

@leftStage6_hyperactive:
@leftStage6_shy:
	.db $00
@leftStage6_curious:
	.db INTERACID_CHILD   $02 $09 $20 $38
	.db $00

@rightStage6_hyperactive:
	.db INTERACID_BLOSSOM $06 $00 $22 $58
	.db INTERACID_BIPIN   $06 $00 $38 $58
	.db INTERACID_CHILD   $00 $07 $38 $48
	.db $00
@rightStage6_shy:
	.db INTERACID_BLOSSOM $06 $01 $22 $58
	.db INTERACID_BIPIN   $06 $00 $38 $58
	.db INTERACID_CHILD   $01 $08 $18 $48
	.db $00
@rightStage6_curious:
	.db INTERACID_BLOSSOM $06 $02 $22 $58
	.db INTERACID_BIPIN   $06 $00 $38 $58
	.db $00

@leftStage7_slacker:
	.db INTERACID_CHILD   $03 $0a $24 $38
	.db $00
@leftStage7_warrior:
	.db INTERACID_CHILD   $04 $0b $48 $40
	.db $00
@leftStage7_arborist:
	.db $00
@leftStage7_singer:
	.db INTERACID_BLOSSOM $07 $03 $58 $88
	.db INTERACID_CHILD   $06 $0d $38 $76
	.db $00

@rightStage7_slacker:
	.db INTERACID_BLOSSOM $07 $00 $22 $58
	.db INTERACID_BIPIN   $07 $00 $38 $58
	.db $00
@rightStage7_warrior:
	.db INTERACID_BLOSSOM $07 $01 $22 $58
	.db INTERACID_BIPIN   $07 $00 $38 $58
	.db $00
@rightStage7_arborist:
	.db INTERACID_BLOSSOM $07 $02 $48 $30
	.db INTERACID_BIPIN   $07 $00 $38 $58
	.db INTERACID_CHILD   $05 $0c $22 $58
	.db $00
@rightStage7_singer:
	.db INTERACID_BIPIN   $07 $00 $38 $58
	.db $00

@leftStage8_slacker:
	.db INTERACID_BLOSSOM $08 $00 $58 $88
	.db INTERACID_CHILD   $03 $0e $44 $78
	.db $00
@leftStage8_warrior:
	.db INTERACID_BLOSSOM $08 $01 $38 $78
	.db $00
@leftStage8_arborist:
	.db INTERACID_BLOSSOM $08 $02 $38 $78
	.db $00
@leftStage8_singer:
	.db INTERACID_CHILD   $06 $11 $14 $26
	.db $00

@rightStage8_slacker:
	.db INTERACID_BIPIN   $08 $00 $38 $58
	.db $00
@rightStage8_warrior:
	.db INTERACID_BIPIN   $08 $00 $38 $58
	.db INTERACID_CHILD   $04 $0f $18 $48
	.db $00
@rightStage8_arborist:
	.db INTERACID_BIPIN   $08 $00 $32 $58
	.db INTERACID_CHILD   $05 $10 $48 $58
	.db $00
@rightStage8_singer:
	.db INTERACID_BIPIN   $08 $00 $38 $58
	.db INTERACID_BLOSSOM $08 $03 $48 $28
	.db $00

@leftStage9_slacker:
	.db INTERACID_BLOSSOM $09 $00 $58 $88
	.db INTERACID_CHILD   $03 $12 $44 $78
	.db $00
@leftStage9_warrior:
	.db INTERACID_BLOSSOM $09 $01 $38 $78
	.db INTERACID_CHILD   $04 $13 $48 $40
	.db $00
@leftStage9_arborist:
	.db INTERACID_BLOSSOM $09 $02 $38 $78
	.db $00
@leftStage9_singer:
	.db INTERACID_BLOSSOM $09 $03 $58 $78
	.db INTERACID_CHILD   $06 $15 $36 $68
	.db $00

@rightStage9_slacker:
	.db INTERACID_BIPIN   $09 $00 $38 $58
	.db $00
@rightStage9_warrior:
	.db INTERACID_BIPIN   $09 $00 $38 $58
	.db $00
@rightStage9_arborist:
	.db INTERACID_BIPIN   $09 $00 $32 $58
	.db INTERACID_CHILD   $05 $14 $48 $58
	.db $00
@rightStage9_singer:
	.db INTERACID_BIPIN   $09 $00 $38 $58
	.db $00


; ==============================================================================
; INTERACID_GASHA_SPOT
; ==============================================================================
.enum 0
	GASHATREASURE_HEART_PIECE	db ; $00
	GASHATREASURE_TIER0_RING	db ; $01
	GASHATREASURE_TIER1_RING	db ; $02
	GASHATREASURE_TIER2_RING	db ; $03
	GASHATREASURE_TIER3_RING	db ; $04
	GASHATREASURE_TIER4_RING	db ; $05
	GASHATREASURE_POTION		db ; $06
	GASHATREASURE_200_RUPEES	db ; $07
	GASHATREASURE_FAIRY		db ; $08
	GASHATREASURE_5_HEARTS		db ; $09
.ende

interactionCodeb6:
	ld e,Interaction.state	; $43f5
	ld a,(de)		; $43f7
	rst_jumpTable			; $43f8
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3
	.dw @state4
	.dw @state5
	.dw @state6
	.dw @state7

; Initialization
@state0:
	ld e,Interaction.subid	; $4409
	ld a,(de)		; $440b
	inc e			; $440c
	ld (de),a		; $440d
	ld hl,wGashaSpotsPlantedBitset		; $440e
	call checkFlag		; $4411
	jr nz,@seedPlanted	; $4414

	ld e,Interaction.var3c		; $4416
	ld a,(de)		; $4418
	or a			; $4419
	jr nz,+			; $441a

	ld a,DISCOVERY_RING		; $441c
	call cpActiveRing		; $441e
	jr nz,+			; $4421

	ld a,SND_COMPASS	; $4423
	ld e,Interaction.var3c		; $4425
	ld (de),a		; $4427
	call playSound		; $4428
+
	call objectGetTileAtPosition	; $442b
	cp TILEINDEX_SOFT_SOIL	; $442e
	ret nz			; $4430
@unearthed:
	call interactionIncState		; $4431
	ld a,$0a		; $4434
	call objectSetCollideRadius		; $4436
	ld e,Interaction.pressedAButton		; $4439
	jp objectAddToAButtonSensitiveObjectList		; $443b

@seedPlanted:
	ld a,(de)		; $443e
	ld hl,wGashaSpotKillCounters		; $443f
	rst_addAToHl			; $4442
	ld a,(hl)		; $4443
	cp 40			; $4444
	jr c,@delete		; $4446

@killedEnoughEnemies:
	call getFreePartSlot		; $4448
	ret nz			; $444b

	ld (hl),PARTID_GASHA_TREE	; $444c
	inc l			; $444e
	ld (hl),$01		; $444f
	ld l,Part.relatedObj1	; $4451
	ld a,Interaction.start	; $4453
	ldi (hl),a		; $4455
	ld (hl),d		; $4456

	; This interaction will now act as the nut.
	; Adjust x,y positions to be in the center of the tree
	ld h,d			; $4457
	ld l,Interaction.var37		; $4458
	ld e,Interaction.yh		; $445a
	ld a,(de)		; $445c
	ldi (hl),a		; $445d
	add $f8			; $445e
	ld (de),a		; $4460
	ld e,Interaction.xh		; $4461
	ld a,(de)		; $4463
	ldi (hl),a		; $4464
	add $08			; $4465
	ld (de),a		; $4467

	ld a,$04		; $4468
	call objectSetCollideRadius		; $446a

	; Set state 3
	ld l,Interaction.state	; $446d
	ld (hl),$03		; $446f

	; Load graphics for the nut
	ld l,Interaction.subid	; $4471
	ld (hl),$0a		; $4473
	call interactionInitGraphics		; $4475
	jp objectSetVisible83		; $4478

; Wait for player to press A button
@state1:
	ld e,Interaction.pressedAButton	; $447b
	ld a,(de)		; $447d
	or a			; $447e
	ret z			; $447f

@pressedAButton:
	xor a			; $4480
	ld (de),a		; $4481
	ld bc,TX_3509		; $4482
	ld a,(wNumGashaSeeds)		; $4485
	or a			; $4488
	jr z,+			; $4489

	; To state 2
	call interactionIncState		; $448b
	ld c,<TX_3500		; $448e
+
	jp showText		; $4490

; After text box has been shown, selected yes or no
@state2:
	ld a,(wSelectedTextOption)		; $4493
	or a			; $4496
	jr z,+			; $4497

	; Back to state 1
	ld a,$01		; $4499
	ld (de),a		; $449b
	ret			; $449c
+
	call objectGetTileAtPosition		; $449d
	ld c,l			; $44a0
	ld a,TILEINDEX_SOFT_SOIL_PLANTED	; $44a1
	call setTile		; $44a3

	ld e,Interaction.var03		; $44a6
	ld a,(de)		; $44a8
	ld hl,wGashaSpotsPlantedBitset		; $44a9
	call setFlag		; $44ac

	ld a,(de)		; $44af
	ld l,<wGashaSpotKillCounters		; $44b0
	rst_addAToHl			; $44b2
	ld (hl),$00		; $44b3

	ld l,<wNumGashaSeeds	; $44b5
	ld a,(hl)		; $44b7
	sub $01			; $44b8
	daa			; $44ba
	ld (hl),a		; $44bb
	ld a,SND_GETSEED	; $44bc
	call playSound		; $44be
@delete:
	jp interactionDelete		; $44c1

; Wait for link to slash the nut, then drop it
@state3:
	ld e,Interaction.var2a		; $44c4
	ld a,(de)		; $44c6
	cp $ff			; $44c7
	ret nz			; $44c9

	ld a,DISABLE_ALL_BUT_INTERACTIONS		; $44ca
	ld (wDisabledObjects),a		; $44cc
	ld (wMenuDisabled),a		; $44cf

	; To state 4
	ld h,d			; $44d2
	ld l,Interaction.state	; $44d3
	ld (hl),$04		; $44d5

	ld a,$06		; $44d7
	call objectSetCollideRadius		; $44d9
	ld bc,-$140		; $44dc
	call objectSetSpeedZ		; $44df

	ld l,Interaction.speed	; $44e2
	ld (hl),SPEED_100		; $44e4

	call objectGetAngleTowardLink		; $44e6
	ld e,Interaction.angle	; $44e9
	ld (de),a		; $44eb
	jp objectSetVisible80		; $44ec

; Wait for the nut to collide with link, show corresponding text
@state4:
	; Dunno why this is necessary
	ld a,(wLinkDeathTrigger)		; $44ef
	or a			; $44f2
	jp nz,interactionDelete		; $44f3

	call objectCheckCollidedWithLink_notDeadAndNotGrabbing		; $44f6
	jr c,+			; $44f9

	; Hasn't collided with link yet
	call objectApplySpeed		; $44fb
	ld c,$20		; $44fe
	jp objectUpdateSpeedZ_paramC		; $4500
+
	; To state 5
	call interactionIncState		; $4503

	ld l,Interaction.visible	; $4506
	res 7,(hl)		; $4508
	ld bc,TX_3501		; $450a
	jp showText		; $450d

@state5:
	; Check if this is the first gasha nut harvested ever
	ld hl,wGashaSpotFlags		; $4510
	bit 0,(hl)		; $4513
	jr nz,+			; $4515
	set 0,(hl)		; $4517
	ld b,GASHATREASURE_TIER3_RING		; $4519
	jr @spawnTreasure		; $451b
+
	; Get a value of 0-4 in 'c', based on the range of wGashaMaturity (0 = best
	; prizes, 4 = worst prizes)
	ld c,$00		; $451d
	ld hl,wGashaMaturity+1		; $451f
	ldd a,(hl)		; $4522
	srl a			; $4523
	jr nz,++		; $4525
	ld a,(hl)		; $4527
	rra			; $4528
	ld hl,@gashaMaturityValues		; $4529
--
	cp (hl)			; $452c
	jr nc,++		; $452d
	inc hl			; $452f
	inc c			; $4530
	jr --			; $4531
++
	; Get the probability distribution to use, based on 'c' (above) and which gasha
	; spot this is (var03)
	ld e,Interaction.var03		; $4533
	ld a,(de)		; $4535
	ld hl,@gashaSpotRanks		; $4536
	rst_addAToHl			; $4539
	ld a,(hl)		; $453a
	rst_addAToHl			; $453b

	; a = c*10
	ld a,c			; $453c
	add a			; $453d
	ld c,a			; $453e
	add a			; $453f
	add a			; $4540
	add c			; $4541

	rst_addAToHl			; $4542
	call getRandomIndexFromProbabilityDistribution		; $4543

	; If it would be a potion, but he has one already, just refill his health
	ld a,b			; $4546
	cp GASHATREASURE_POTION			; $4547
	jr nz,@notPotion	; $4549

	ld a,TREASURE_POTION		; $454b
	call checkTreasureObtained		; $454d
	jr nc,@decGashaMaturity		; $4550

	ld hl,wLinkMaxHealth		; $4552
	ldd a,(hl)		; $4555
	ld (hl),a		; $4556
	jr @decGashaMaturity			; $4557

@notPotion:
	; If it would ba a heart piece, but he got it already, give tier 0 ring instead
	cp GASHATREASURE_HEART_PIECE			; $4559
	jr nz,@decGashaMaturity		; $455b
	ld hl,wGashaSpotFlags		; $455d
	bit 1,(hl)		; $4560
	jr z,+			; $4562
	inc b			; $4564
+
	set 1,(hl)		; $4565

@decGashaMaturity
	; BUG: no bounds checking here; you could underflow wGashaMaturity.
	ld hl,wGashaMaturity		; $4567
	ld a,(hl)		; $456a
	sub 200			; $456b
	ldi (hl),a		; $456d
	ld a,(hl)		; $456e
	sbc $00			; $456f
	ld (hl),a		; $4571

	jr nc,@spawnTreasure	; $4572
	xor a			; $4574
	ldd (hl),a		; $4575
	ld (hl),a		; $4576

@spawnTreasure:
	; This object, which was previously the nut, will now become the item sprite being
	; held over Link's head; set the subid accordingly.
	ld a,b			; $4577
	ld e,Interaction.subid	; $4578
	ld (de),a		; $457a
	ld hl,@gashaTreasures		; $457b
	rst_addDoubleIndex			; $457e
	ldi a,(hl)		; $457f
	ld c,(hl)		; $4580
	cp TREASURE_RING			; $4581
	jr nz,+			; $4583
	call getRandomRingOfGivenTier		; $4585
+
	ld b,a			; $4588
	call giveTreasure		; $4589

	; Set Link's animation
	ld hl,wLinkForceState		; $458c
	ld a,LINK_STATE_04		; $458f
	ldi (hl),a		; $4591
	ld (hl),$01 ; [wcc50]

	; Set position above Link
	ld hl,w1Link.yh		; $4594
	ld bc,$f300		; $4597
	call objectTakePositionWithOffset		; $459a

	call interactionIncState		; $459d
	ld l,Interaction.visible		; $45a0
	set 7,(hl)		; $45a2

	ld e,Interaction.subid		; $45a4
	ld a,(de)		; $45a6
	cp GASHATREASURE_HEART_PIECE			; $45a7
	ld a,SND_GETITEM	; $45a9
	call nz,playSound		; $45ab

	; Load graphics, show text
	call interactionInitGraphics		; $45ae
	ld e,Interaction.subid		; $45b1
	ld a,(de)		; $45b3
	ld hl,@lowTextIndices	; $45b4
	rst_addAToHl			; $45b7
	ld c,(hl)		; $45b8
	ld b,>TX_3500		; $45b9
	jp showText		; $45bb

; Text to show upon getting each respective item
@lowTextIndices:
	.db <TX_3503 <TX_3504 <TX_3504 <TX_3504 <TX_3504 <TX_3504 <TX_3505 <TX_3506
	.db <TX_3508 <TX_3507

; Obtained the item and exited the textbox; wait for link's hearts or rupee
; count to update fully, then make the tree disappear
@state6:
	ld hl,wNumRupees		; $45c8
	ld a,(wDisplayedRupees)		; $45cb
	cp (hl)			; $45ce
	ret nz			; $45cf
	inc l			; $45d0
	ld a,(wDisplayedRupees+1)		; $45d1
	cp (hl)			; $45d4
	ret nz			; $45d5

	ld l,<wLinkHealth		; $45d6
	ld a,(wDisplayedHearts)		; $45d8
	cp (hl)			; $45db
	ret nz			; $45dc

	ld a,SND_FAIRYCUTSCENE	; $45dd
	call playSound		; $45df

	ld e,Interaction.var03		; $45e2
	ld a,(de)		; $45e4
	ld hl,@gfxHeaderToLoadWhenTreeDisappears		; $45e5
	rst_addAToHl			; $45e8
	ld a,(hl)		; $45e9
	push af			; $45ea
	sub GFXH_39			; $45eb
	ld (wLoadedTreeGfxActive),a		; $45ed

	ld a,GFXH_3d		; $45f0
	call loadGfxHeader		; $45f2
	pop af			; $45f5
	cp GFXH_3d			; $45f6
	call nz,loadGfxHeader		; $45f8

	ldh a,(<hActiveObject)	; $45fb
	ld d,a			; $45fd
	ld h,d			; $45fe
	ld l,Interaction.var37		; $45ff
	ld e,Interaction.yh		; $4601
	ldi a,(hl)		; $4603
	ld (de),a ; [yh] = [var37] (original Y position)
	ld e,Interaction.xh		; $4605
	ldi a,(hl)		; $4607
	ld (de),a ; [xh] = [var38] (original X position)

	ld l,Interaction.visible		; $4609
	res 7,(hl)		; $460b

	; Make tiles walkable again
	call objectGetTileCollisions		; $460d
	xor a			; $4610
	ldi (hl),a		; $4611
	ldd (hl),a		; $4612
	ld a,l			; $4613
	sub $10			; $4614
	ld l,a			; $4616
	xor a			; $4617
	ldi (hl),a		; $4618
	ldd (hl),a		; $4619

	; Calculate position in w3VramTiles?
	ld h,a			; $461a
	ld e,l			; $461b
	ld a,l			; $461c
	and $f0			; $461d
	ld l,a			; $461f
	ld a,e			; $4620
	and $0f			; $4621
	sla l			; $4623
	rl h			; $4625
	add l			; $4627
	ld l,a			; $4628
	sla l			; $4629
	rl h			; $462b
	ld bc,w3VramTiles		; $462d
	add hl,bc		; $4630

	; Write calculated position to var3a
	ld e,Interaction.var3a		; $4631
	ld a,l			; $4633
	ld (de),a		; $4634
	inc e			; $4635
	ld a,h			; $4636
	ld (de),a		; $4637

	; Do something with w3VramAttributes ($400 bytes ahead)?
	ld bc,$0400		; $4638
	add hl,bc		; $463b
	ld a,($ff00+R_SVBK)	; $463c
	push af			; $463e
	ld a,:w3VramAttributes		; $463f
	ld ($ff00+R_SVBK),a	; $4641
	ld b,$04		; $4643
---
	ld c,$04		; $4645
	push bc			; $4647
--
	ld a,(hl)		; $4648
	and $f0			; $4649
	or $04			; $464b
	ldi (hl),a		; $464d
	dec c			; $464e
	jr nz,--		; $464f

	ld bc,$001c		; $4651
	add hl,bc		; $4654
	pop bc			; $4655
	dec b			; $4656
	jr nz,---		; $4657

	pop af			; $4659
	ld ($ff00+R_SVBK),a	; $465a
	call interactionIncState		; $465c
	ld l,Interaction.counter1		; $465f
	ld (hl),$08		; $4661

; Shrinking the tree (cycling through each frame of the animation)
@state7:
	ld h,d			; $4663
	ld l,Interaction.counter1	; $4664
	ld a,(hl)		; $4666
	or a			; $4667
	jr z,@counter1Done	; $4668

	dec a			; $466a
	ld (hl),a		; $466b
	ret nz			; $466c

@counter1Done:
	ld a,$08		; $466d
	ldi (hl),a		; $466f
	ld a,(hl)		; $4670
	inc a			; $4671
	ld (hl),a		; $4672
	cp $0a			; $4673
	jr nc,@counter2Done	; $4675

	ld hl,@treeDisappearanceFrames-1		; $4677
	rst_addAToHl			; $467a
	ld a,(hl)		; $467b
	rst_addAToHl			; $467c

	; Retrieve position in w3VramTiles from var3a
	ld e,Interaction.var3a		; $467d
	ld a,(de)		; $467f
	ld c,a			; $4680
	inc e			; $4681
	ld a,(de)		; $4682
	ld d,a			; $4683
	ld e,c			; $4684

	push hl			; $4685
	push de			; $4686
	pop hl			; $4687
	pop de			; $4688

	; Draw the next frame of the tree's disappearance
	ld a,($ff00+R_SVBK)	; $4689
	push af			; $468b
	ld a,:w3VramTiles	; $468c
	ld ($ff00+R_SVBK),a	; $468e
	ld b,$04		; $4690
---
	ld c,$04		; $4692
	push bc			; $4694
--
	ld a,(de)		; $4695
	ldi (hl),a		; $4696
	inc de			; $4697
	dec c			; $4698
	jr nz,--		; $4699

	ld bc,$001c		; $469b
	add hl,bc		; $469e
	pop bc			; $469f
	dec b			; $46a0
	jr nz,---		; $46a1

	pop af			; $46a3
	ld ($ff00+R_SVBK),a	; $46a4
	ld a,UNCMP_GFXH_29	; $46a6
	call loadUncompressedGfxHeader		; $46a8

	ldh a,(<hActiveObject)	; $46ab
	ld d,a			; $46ad
	ld e,Interaction.counter2	; $46ae
	ld a,(de)		; $46b0
	add UNCMP_GFXH_1f			; $46b1
	call loadUncompressedGfxHeader		; $46b3

	call reloadTileMap		; $46b6
	ldh a,(<hActiveObject)	; $46b9
	ld d,a			; $46bb
	ret			; $46bc

@counter2Done:
	xor a			; $46bd
	ld (wDisabledObjects),a		; $46be
	ld (wMenuDisabled),a		; $46c1

	ld e,Interaction.var03		; $46c4
	ld a,(de)		; $46c6
	ld hl,wGashaSpotsPlantedBitset		; $46c7
	call unsetFlag		; $46ca

	; Overwrite the 4 tiles making up the gasha tree in wRoomLayout
	ld a,TILEINDEX_GASHA_TREE_TL	; $46cd
	call findTileInRoom		; $46cf
	ret nz			; $46d2

	ld e,Interaction.var03		; $46d3
	ld a,(de)		; $46d5
	ld bc,@tileReplacements	; $46d6
	call addAToBc		; $46d9
	ld a,(bc)		; $46dc
	ld b,a			; $46dd
	ld a,b			; $46de
	ldi (hl),a		; $46df
	ld (hl),a		; $46e0
	ld a,$0f		; $46e1
	add l			; $46e3
	ld l,a			; $46e4
	ld a,b			; $46e5
	ldi (hl),a		; $46e6
	ld (hl),a		; $46e7
	jp interactionDelete		; $46e8

@tileReplacements:
	.db $3a $1b $1b $3a $3a $bf $3a $bf
	.db $1b $3a $3a $1b $3a $3a $3a $bf


; These are values compared with "wGashaMaturity" which set the ranges for gasha prize
; "levels". A value of 300 or higher will give you the highest level prizes.
@gashaMaturityValues:
	.db 300/2
	.db 200/2
	.db 120/2
	.db  40/2
	.db   0/2


@gashaTreasures:
	.db TREASURE_HEART_PIECE, $01
	.db TREASURE_RING, RING_TIER_0
	.db TREASURE_RING, RING_TIER_1
	.db TREASURE_RING, RING_TIER_2
	.db TREASURE_RING, RING_TIER_3
	.db TREASURE_RING, RING_TIER_4
	.db TREASURE_POTION, $01
	.db TREASURE_RUPEES, RUPEEVAL_200
	.db TREASURE_HEART_REFILL, $18
	.db TREASURE_HEART_REFILL, $14


; Each row defines which type of gasha spot each subid is (rank 0 = best).
@gashaSpotRanks:
	.db @rank1Spot-CADDR ; $00
	.db @rank2Spot-CADDR ; $01
	.db @rank2Spot-CADDR ; $02
	.db @rank1Spot-CADDR ; $03
	.db @rank4Spot-CADDR ; $04
	.db @rank1Spot-CADDR ; $05
	.db @rank1Spot-CADDR ; $06
	.db @rank0Spot-CADDR ; $07
	.db @rank3Spot-CADDR ; $08
	.db @rank2Spot-CADDR ; $09
	.db @rank2Spot-CADDR ; $0a
	.db @rank1Spot-CADDR ; $0b
	.db @rank4Spot-CADDR ; $0c
	.db @rank3Spot-CADDR ; $0d
	.db @rank1Spot-CADDR ; $0e
	.db @rank0Spot-CADDR ; $0f


; Each row corresponds to a certain range for "wGashaMaturity". The first row is the most
; "mature" (occurs later in the game), while the later rows occur earlier in the game.
; Prizes get better as the game goes on.
;
; Each row is a "probability distribution" that adds up to 256. Each byte is a weighting
; for the corresponding treasure (GASHATREASURE_X).

@rank0Spot: ; Best type of spot
	.db $5a $40 $26 $00 $00 $1a $0d $0d $0c $00
	.db $40 $26 $26 $00 $00 $00 $40 $26 $0e $00
	.db $26 $33 $33 $00 $00 $00 $40 $26 $0e $00
	.db $1a $26 $26 $00 $00 $00 $40 $34 $26 $00
	.db $0c $1a $1a $00 $00 $00 $4d $33 $33 $0d
@rank1Spot:
	.db $1a $26 $5a $33 $00 $00 $19 $0d $0d $00
	.db $0d $1a $33 $40 $00 $00 $26 $33 $0d $00
	.db $08 $12 $33 $33 $00 $00 $26 $33 $1a $0d
	.db $05 $0d $1a $3b $00 $00 $26 $33 $26 $1a
	.db $03 $08 $0f $19 $00 $00 $1a $40 $4d $26
@rank2Spot:
	.db $00 $00 $26 $4d $66 $00 $0d $0d $0d $00
	.db $00 $00 $1a $32 $4d $00 $33 $1a $1a $00
	.db $00 $00 $0d $1a $26 $00 $40 $33 $33 $0d
	.db $00 $00 $08 $12 $1a $00 $40 $33 $33 $26
	.db $00 $00 $03 $0d $0d $00 $1a $4b $4b $33
@rank3Spot:
	.db $00 $00 $00 $5a $5a $00 $1a $1a $0c $0c
	.db $00 $00 $00 $33 $33 $00 $33 $33 $1a $1a
	.db $00 $00 $00 $26 $26 $00 $26 $33 $34 $27
	.db $00 $00 $00 $1a $1a $00 $1a $4d $32 $33
	.db $00 $00 $00 $0d $0d $00 $1a $40 $40 $4c
@rank4Spot: ; Worst type of spot
	.db $00 $00 $00 $40 $34 $00 $26 $26 $26 $1a
	.db $00 $00 $00 $26 $26 $00 $26 $33 $34 $27
	.db $00 $00 $00 $1a $26 $00 $26 $33 $34 $33
	.db $00 $00 $00 $12 $1a $00 $21 $33 $40 $40
	.db $00 $00 $00 $0d $0d $00 $0d $40 $4c $4d


; Each entry consists of a 4x4 block of subtiles (8x8 tiles) to draw while the tree is
; disappearing.
@treeDisappearanceFrames:
	.db @frame1-CADDR
	.db @frame1-CADDR
	.db @frame2-CADDR
	.db @frame3-CADDR
	.db @frame4-CADDR
	.db @frame5-CADDR
	.db @frame5-CADDR
	.db @frame6-CADDR
	.db @frame7-CADDR

@frame1:
	.db $20 $21 $22 $23
	.db $24 $25 $26 $27
	.db $28 $29 $2a $2b
	.db $2c $2d $2e $2f
@frame2:
	.db $20 $21 $20 $21
	.db $24 $25 $26 $27
	.db $28 $29 $2a $2b
	.db $20 $2c $2d $2e
@frame3:
	.db $20 $21 $20 $21
	.db $24 $25 $26 $27
	.db $28 $29 $2a $2b
	.db $22 $2c $2d $23
@frame4:
	.db $20 $21 $20 $21
	.db $22 $24 $25 $23
	.db $20 $26 $27 $21
	.db $22 $28 $29 $23
@frame5:
	.db $20 $21 $20 $21
	.db $22 $23 $22 $23
	.db $20 $24 $25 $21
	.db $22 $26 $27 $23
@frame6:
	.db $20 $21 $20 $21
	.db $22 $23 $22 $23
	.db $20 $21 $20 $21
	.db $22 $24 $25 $23
@frame7:
	.db $20 $21 $20 $21
	.db $22 $23 $22 $23
	.db $20 $21 $20 $21
	.db $22 $23 $22 $23


; Each subid loads one of 3 gfx headers while the tree disappears.
@gfxHeaderToLoadWhenTreeDisappears:
	.db GFXH_3d GFXH_3f GFXH_3f GFXH_3d GFXH_3d GFXH_3e GFXH_3d GFXH_3e
	.db GFXH_3f GFXH_3d GFXH_3d GFXH_3f GFXH_3d GFXH_3d GFXH_3d GFXH_3e


; ==============================================================================
; INTERACID_KISS_HEART
; ==============================================================================
interactionCodeb7:
	ld e,Interaction.state		; $48a7
	ld a,(de)		; $48a9
	rst_jumpTable			; $48aa
	.dw @state1
	.dw interactionAnimate

@state1:
	ld a,$01		; $48af
	ld (de),a		; $48b1
	call interactionInitGraphics	; $48b2
	jp objectSetVisible82		; $48b5


; ==============================================================================
; INTERACID_BANANA
; ==============================================================================
interactionCodec0:
	ld e,Interaction.state		; $48b8
	ld a,(de)		; $48ba
	rst_jumpTable			; $48bb
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $48c0
	ld (de),a		; $48c2
	call interactionInitGraphics		; $48c3
	jp objectSetVisible80		; $48c6

@state1:
	call interactionAnimate		; $48c9
	ld a,Object.enabled		; $48cc
	call objectGetRelatedObject1Var		; $48ce
	ld l,SpecialObject.id		; $48d1
	ld a,(hl)		; $48d3
	cp SPECIALOBJECTID_MOOSH_CUTSCENE			; $48d4
	jp nz,interactionDelete		; $48d6

	ld e,Interaction.direction		; $48d9
	ld a,(de)		; $48db
	ld l,SpecialObject.direction		; $48dc
	cp (hl)			; $48de
	ld a,(hl)		; $48df
	jr z,@updatePosition	; $48e0

	; Direction changed

	ld (de),a		; $48e2
	push af			; $48e3
	ld hl,@visibleValues		; $48e4
	rst_addAToHl			; $48e7
	ldi a,(hl)		; $48e8
	ld e,Interaction.visible		; $48e9
	ld (de),a		; $48eb
	pop af			; $48ec
	call interactionSetAnimation		; $48ed

	ld a,Object.enabled		; $48f0
	call objectGetRelatedObject1Var		; $48f2
	ld l,SpecialObject.direction		; $48f5
	ld a,(hl)		; $48f7

@updatePosition:
	push hl			; $48f8
	ld hl,@xOffsets		; $48f9
	rst_addAToHl			; $48fc
	ld b,$00		; $48fd
	ld c,(hl)		; $48ff
	pop hl			; $4900
	jp objectTakePositionWithOffset		; $4901

@visibleValues:
	.db $83 $83 $80 $83

@xOffsets:
	.db $00 $05 $00 $fb



; ==============================================================================
; INTERACID_CREATE_OBJECT_AT_EACH_TILEINDEX
; ==============================================================================
interactionCodec7:
	ld e,Interaction.subid		; $490c
	ld a,(de)		; $490e
	ld c,a			; $490f
	ld hl,wRoomLayout		; $4910
	ld b,LARGE_ROOM_HEIGHT*$10		; $4913
--
	ld a,(hl)		; $4915
	cp c			; $4916
	call z,@createObject		; $4917
	inc l			; $491a
	dec b			; $491b
	jr nz,--		; $491c
	jp interactionDelete		; $491e

@createObject:
	push hl			; $4921
	push bc			; $4922
	ld b,l			; $4923
	ld e,Interaction.xh		; $4924
	ld a,(de)		; $4926
	and $f0			; $4927
	swap a			; $4929
	call @spawnObjectType		; $492b
	jr nz,@ret	; $492e

	ld e,Interaction.yh		; $4930
	ld a,(de)		; $4932
	ldi (hl),a		; $4933
	ld e,Interaction.xh		; $4934
	ld a,(de)		; $4936
	and $0f			; $4937
	ld (hl),a		; $4939

	ld a,l			; $493a
	add Object.yh-Object.subid			; $493b
	ld l,a			; $493d
	ld a,b			; $493e
	and $f0			; $493f
	add $08			; $4941
	ldi (hl),a		; $4943
	inc l			; $4944
	ld a,b			; $4945
	and $0f			; $4946
	swap a			; $4948
	add $08			; $494a
	ld (hl),a		; $494c

@ret:
	pop bc			; $494d
	pop hl			; $494e
	ret			; $494f

;;
; @param	a	0 for enemy; 1 for part; 2 for interaction
; @param[out]	hl	Spawned object
; @addr{4950}
@spawnObjectType:
	or a			; $4950
	jp z,getFreeEnemySlot		; $4951
	dec a			; $4954
	jp z,getFreePartSlot		; $4955
	dec a			; $4958
	jp z,getFreeInteractionSlot		; $4959
	ret			; $495c


; ==============================================================================
; INTERACID_BUSINESS_SCRUB
;
; Variables:
;   var38: Number of rupees to spent (1-byte value, converted with "rupeeValue" methods)
;   var39: Set when Link is close to the scrub (he pops out of his bush)
; ==============================================================================
interactionCodece:
	ld e,Interaction.state		; $495d
	ld a,(de)		; $495f
	rst_jumpTable			; $4960
	.dw @state0
	.dw @state1
	.dw @state2

@state0:
	ld a,$01		; $4967
	ld (de),a		; $4969
	call interactionSetAlwaysUpdateBit		; $496a

	ld e,Interaction.subid		; $496d
	ld a,(de)		; $496f
	bit 7,a			; $4970
	jr nz,@mimicBush	; $4972

	cp $00			; $4974
	jr z,@sellingShield	; $4976
	cp $03			; $4978
	jr z,@sellingShield	; $497a
	cp $06			; $497c
	jr nz,+++		; $497e

@sellingShield:
	ld c,a			; $4980
	ld a,(wShieldLevel)		; $4981
	or a			; $4984
	jr z,+			; $4985
	dec a			; $4987
+
	add c			; $4988
	ld (de),a		; $4989
	ld hl,@itemPrices		; $498a
	rst_addDoubleIndex			; $498d
	ldi a,(hl)		; $498e
	ld b,(hl)		; $498f
	ld hl,wTextNumberSubstitution		; $4990
	ldi (hl),a		; $4993
	ld (hl),b		; $4994
+++
	ld e,Interaction.collisionRadiusY		; $4995
	ld a,$06		; $4997
	ld (de),a		; $4999
	inc e			; $499a
	ld (de),a		; $499b

	call interactionInitGraphics		; $499c
	call objectMakeTileSolid		; $499f
	ld h,>wRoomLayout		; $49a2
	ld (hl),$00		; $49a4
	call objectSetVisible80		; $49a6
	ld e,Interaction.pressedAButton		; $49a9
	call objectAddToAButtonSensitiveObjectList		; $49ab

	call getFreeInteractionSlot		; $49ae
	ld a,INTERACID_BUSINESS_SCRUB		; $49b1
	ldi (hl),a		; $49b3
	ld a,$80		; $49b4
	ldi (hl),a		; $49b6
	ld l,Interaction.relatedObj2		; $49b7
	ld (hl),d		; $49b9
	jp objectCopyPosition		; $49ba

; Subid $80 initialization (the bush above the scrub)
@mimicBush:
	ld a,(wActiveGroup)		; $49bd
	or a			; $49c0
	ld a,TILEINDEX_OVERWORLD_BUSH		; $49c1
	jr z,+			; $49c3
	ld a,TILEINDEX_OVERWORLD_BUSH		; $49c5
+
	call objectMimicBgTile		; $49c7
	ld a,$05		; $49ca
	call interactionSetAnimation		; $49cc
	jp objectSetVisible80		; $49cf

@state1:
	ld a,(wScrollMode)		; $49d2
	and SCROLLMODE_08 | SCROLLMODE_04 | SCROLLMODE_02			; $49d5
	ret nz			; $49d7

	ld e,Interaction.subid		; $49d8
	ld a,(de)		; $49da
	bit 7,a			; $49db
	jr nz,@subid80State1	; $49dd

	call objectSetPriorityRelativeToLink_withTerrainEffects		; $49df
	call interactionAnimate		; $49e2
	ld c,$20		; $49e5
	call objectCheckLinkWithinDistance		; $49e7
	ld e,Interaction.var39		; $49ea
	jr c,@linkIsClose	; $49ec

	; Link not close
	ld a,(de)		; $49ee
	or a			; $49ef
	ret z			; $49f0
	xor a			; $49f1
	ld (de),a		; $49f2
	ld a,$03		; $49f3
	jp interactionSetAnimation		; $49f5

@linkIsClose:
	ld a,(de)		; $49f8
	or a			; $49f9
	jr nz,++		; $49fa
	inc a			; $49fc
	ld (de),a		; $49fd
	ld a,$01		; $49fe
	jp interactionSetAnimation		; $4a00
++
	ld e,Interaction.pressedAButton		; $4a03
	ld a,(de)		; $4a05
	or a			; $4a06
	ret z			; $4a07

	; Link talked to the scrub
	call interactionIncState		; $4a08
	ld a,$02		; $4a0b
	call interactionSetAnimation		; $4a0d
	ld e,Interaction.subid		; $4a10
	ld a,(de)		; $4a12
	ld hl,@offerItemTextIndices		; $4a13
	rst_addAToHl			; $4a16
	ld c,(hl)		; $4a17
	ld b,>TX_4500		; $4a18
	jp showTextNonExitable		; $4a1a

; Subid $80: the bush above the scrub
@subid80State1:
	ld e,Interaction.relatedObj2		; $4a1d
	ld a,(de)		; $4a1f
	ld h,a			; $4a20
	ld l,Interaction.visible		; $4a21
	ld a,(hl)		; $4a23
	ld e,Interaction.visible		; $4a24
	ld (de),a		; $4a26
	ld l,Interaction.yh		; $4a27
	ld b,(hl)		; $4a29
	ld l,Interaction.animParameter		; $4a2a
	ld a,(hl)		; $4a2c
	ld hl,@bushYOffsets		; $4a2d
	rst_addAToHl			; $4a30
	ld e,Interaction.yh		; $4a31
	ldi a,(hl)		; $4a33
	add b			; $4a34
	ld (de),a		; $4a35
	ret			; $4a36

@state2:
	call interactionAnimate		; $4a37
	ld a,(wTextIsActive)		; $4a3a
	and $7f			; $4a3d
	ret nz			; $4a3f

	; Link just finished talking to the scrub
	ld a,(wSelectedTextOption)		; $4a40
	bit 7,a			; $4a43
	jr z,@label_0b_103	; $4a45

	ld e,Interaction.state		; $4a47
	ld a,$01		; $4a49
	ld (de),a		; $4a4b
	xor a			; $4a4c
	ld (wTextIsActive),a		; $4a4d
	ld e,Interaction.pressedAButton		; $4a50
	ld (de),a		; $4a52
	dec a			; $4a53
	ld (wSelectedTextOption),a		; $4a54
	ld a,$04		; $4a57
	jp interactionSetAnimation		; $4a59

@label_0b_103:
	ld a,(wSelectedTextOption)		; $4a5c
	or a			; $4a5f
	jr z,@agreedToBuy	; $4a60

	; Declined to buy
	ld bc,TX_4506		; $4a62
	jr @showText		; $4a65

@agreedToBuy:
	ld e,Interaction.subid		; $4a67
	ld a,(de)		; $4a69
	ld hl,@rupeeValues		; $4a6a
	rst_addAToHl			; $4a6d
	ld a,(hl)		; $4a6e
	ld e,Interaction.var38		; $4a6f
	ld (de),a		; $4a71
	call cpRupeeValue		; $4a72
	jr z,@enoughRupees	; $4a75

	; Not enough rupees
	ld bc,TX_4507		; $4a77
	jr @showText		; $4a7a

@enoughRupees:
	ld e,Interaction.subid		; $4a7c
	ld a,(de)		; $4a7e
	ld hl,@treasuresToSell		; $4a7f
	rst_addDoubleIndex			; $4a82
	ld a,(hl)		; $4a83
	cp TREASURE_BOMBS			; $4a84
	jr z,@giveBombs	; $4a86
	cp TREASURE_EMBER_SEEDS			; $4a88
	jr nz,@giveShield	; $4a8a

@giveEmberSeeds:
	ld a,(wSeedSatchelLevel)		; $4a8c
	ld bc,@maxSatchelCapacities-1		; $4a8f
	call addAToBc		; $4a92
	ld a,(bc)		; $4a95
	ld c,a			; $4a96
	ld a,(wNumEmberSeeds)		; $4a97
	cp c			; $4a9a
	jr nz,@giveTreasure	; $4a9b
	jr @alreadyHaveTreasure		; $4a9d

@giveBombs:
	ld bc,wNumBombs		; $4a9f
	ld a,(bc)		; $4aa2
	inc c			; $4aa3
	ld e,a			; $4aa4
	ld a,(bc)		; $4aa5
	cp e			; $4aa6
	jr nz,@giveTreasure	; $4aa7
	jr @alreadyHaveTreasure		; $4aa9

@giveShield:
	call checkTreasureObtained		; $4aab
	jr nc,@giveTreasure	; $4aae

@alreadyHaveTreasure:
	ld bc,TX_4508		; $4ab0
	jr @showText		; $4ab3

@giveTreasure:
	ldi a,(hl)		; $4ab5
	ld c,(hl)		; $4ab6
	call giveTreasure		; $4ab7
	ld e,Interaction.var38		; $4aba
	ld a,(de)		; $4abc
	call removeRupeeValue		; $4abd
	ld a,SND_GETSEED		; $4ac0
	call playSound		; $4ac2
	ld bc,TX_4505		; $4ac5
@showText:
	jp showText		; $4ac8

@maxSatchelCapacities:
	.db $20 $50 $99

@offerItemTextIndices:
	.db <TX_4509
	.db <TX_4509
	.db <TX_4509
	.db <TX_4509
	.db <TX_4509
	.db <TX_4509
	.db <TX_4509
	.db <TX_4509
	.db <TX_4509

@bushYOffsets:
	.db $00 ; Normally
	.db $f8 ; When Link approaches
	.db $f5 ; When Link is talking to him

; This should match with "@itemPrices" below
@rupeeValues:
	.db RUPEEVAL_50
	.db RUPEEVAL_100
	.db RUPEEVAL_150
	.db RUPEEVAL_30
	.db RUPEEVAL_50
	.db RUPEEVAL_80
	.db RUPEEVAL_10
	.db RUPEEVAL_20
	.db RUPEEVAL_40

@treasuresToSell:
	.db TREASURE_SHIELD      $01
	.db TREASURE_SHIELD      $02
	.db TREASURE_SHIELD      $03
	.db TREASURE_SHIELD      $01
	.db TREASURE_SHIELD      $02
	.db TREASURE_SHIELD      $03
	.db TREASURE_SHIELD      $01
	.db TREASURE_SHIELD      $02
	.db TREASURE_SHIELD      $03
	.db TREASURE_BOMBS       $10
	.db TREASURE_EMBER_SEEDS $10

; This should match with "@rupeeValues" above
@itemPrices:
	.dw $0050
	.dw $0100
	.dw $0150
	.dw $0030
	.dw $0050
	.dw $0080
	.dw $0010
	.dw $0020
	.dw $0040


; ==============================================================================
; INTERACID_cf
; ==============================================================================
interactionCodecf:
	ld e,Interaction.state		; $4b0b
	ld a,(de)		; $4b0d
	rst_jumpTable			; $4b0e
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $4b13
	ld (de),a		; $4b15
	call interactionInitGraphics		; $4b16
	ld e,Interaction.subid		; $4b19
	ld a,(de)		; $4b1b
	ld hl,@positions		; $4b1c
	rst_addDoubleIndex			; $4b1f
	ldi a,(hl)		; $4b20
	ld e,Interaction.yh		; $4b21
	ld (de),a		; $4b23
	inc e			; $4b24
	inc e			; $4b25
	ld a,(hl)		; $4b26
	ld (de),a		; $4b27
	jp objectSetVisible82		; $4b28

@positions:
	.db $18 $5c ; 0 == [subid]
	.db $40 $40 ; 1
	.db $38 $88 ; 2

@state1:
	jp interactionAnimate		; $4b31


; ==============================================================================
; INTERACID_COMPANION_TUTORIAL
; ==============================================================================
interactionCoded0:
	ld e,Interaction.state		; $4b34
	ld a,(de)		; $4b36
	rst_jumpTable			; $4b37
	.dw @state0
	.dw @state1
	.dw @state2

@state0:
	ld a,$01		; $4b3e
	ld (de),a		; $4b40
	ret			; $4b41

@state1:
	ld a,$02		; $4b42
	ld (de),a		; $4b44
	ld a,(w1Companion.enabled)		; $4b45
	or a			; $4b48
	jr z,@deleteIfSubid2Or5	; $4b49

	; Verify that the correct companion is on-screen, otherwise delete self
	ld e,Interaction.subid		; $4b4b
	ld a,(de)		; $4b4d
	srl a			; $4b4e
	add SPECIALOBJECTID_FIRST_COMPANION			; $4b50
	cp SPECIALOBJECTID_LAST_COMPANION+1			; $4b52
	jr c,+			; $4b54
	ld a,SPECIALOBJECTID_MOOSH		; $4b56
+
	ld hl,w1Companion.id		; $4b58
	cp (hl)			; $4b5b
	jr nz,@delete	; $4b5c

	; Delete self if tutorial text was already shown
	ld a,(de)		; $4b5e
	ld hl,@flagNumbers		; $4b5f
	rst_addAToHl			; $4b62
	ld a,(hl)		; $4b63
	ld hl,wCompanionTutorialTextShown		; $4b64
	call checkFlag		; $4b67
	jr nz,@delete	; $4b6a

	; Check whether to dismount? (subid 2 only)
	ld a,(de)		; $4b6c
	cp $02			; $4b6d
	jr nz,++		; $4b6f
	ld a,(wLinkObjectIndex)		; $4b71
	rra			; $4b74
	ld a,(de)		; $4b75
	jr nc,++		; $4b76
	ld (wForceCompanionDismount),a		; $4b78
++
	ld hl,@tutorialTextToShow		; $4b7b
	rst_addDoubleIndex			; $4b7e
	ldi a,(hl)		; $4b7f
	ld c,a			; $4b80
	ld b,(hl)		; $4b81
	ld a,(wLinkObjectIndex)		; $4b82
	bit 0,a			; $4b85
	call nz,showText		; $4b87

@deleteIfSubid2Or5:
	ld e,Interaction.subid		; $4b8a
	ld a,(de)		; $4b8c
	cp $02			; $4b8d
	jr z,@delete	; $4b8f
	cp $05			; $4b91
	ret nz			; $4b93
@delete:
	jp interactionDelete		; $4b94

@state2:
	ld a,(w1Companion.enabled)		; $4b97
	or a			; $4b9a
	ret z			; $4b9b
	ld e,Interaction.subid		; $4b9c
	ld a,(de)		; $4b9e
	rst_jumpTable			; $4b9f
	.dw @subid0
	.dw @subid1
	.dw @subid2
	.dw @subid3
	.dw @subid4
	.dw @subid5

@subid2:
@subid5:
	ld e,Interaction.yh		; $4bac
	ld a,(de)		; $4bae
	ld hl,w1Companion.yh		; $4baf
	cp (hl)			; $4bb2
	ret nc			; $4bb3
	jr @setFlagAndDelete		; $4bb4

@func_4bb6: ; unused
	ld a,(w1Companion.var38)		; $4bb6
	or a			; $4bb9
	ret z			; $4bba

@subid1:
@setFlagAndDeleteWhenCompanionIsAbove:
	call @cpYToCompanion		; $4bbb
	ret c			; $4bbe

@setFlagAndDelete:
	ld e,Interaction.subid		; $4bbf
	ld a,(de)		; $4bc1
	ld hl,@flagNumbers		; $4bc2
	rst_addAToHl			; $4bc5
	ld a,(hl)		; $4bc6
	ld hl,wCompanionTutorialTextShown		; $4bc7
	call setFlag		; $4bca
	jr @delete		; $4bcd

@subid3:
	call @checkLinkInXRange		; $4bcf
	ret nz			; $4bd2
	jr @setFlagAndDeleteWhenCompanionIsAbove		; $4bd3

@subid4:
	ld e,Interaction.xh		; $4bd5
	ld a,(de)		; $4bd7
	ld hl,w1Companion.xh		; $4bd8
	cp (hl)			; $4bdb
	ret nc			; $4bdc
	jr @setFlagAndDelete		; $4bdd

@subid0:
	call @cpYToCompanion		; $4bdf
	jr c,@setFlagAndDelete	; $4be2
	ld e,Interaction.xh		; $4be4
	ld a,(de)		; $4be6
	ld hl,w1Companion.xh		; $4be7
	cp (hl)			; $4bea
	ret c			; $4beb
	jr @setFlagAndDelete		; $4bec

;;
; @addr{4bee}
@cpYToCompanion:
	ld e,Interaction.yh		; $4bee
	ld a,(de)		; $4bf0
	ld hl,w1Companion.yh		; $4bf1
	cp (hl)			; $4bf4
	ret			; $4bf5

;;
; @param[out]	zflag	z if Link is within a certain range of X-positions for certain
;			rooms?
; @addr{4bf6}
@checkLinkInXRange:
	ld a,(wActiveRoom)		; $4bf6
	ld hl,@rooms		; $4bf9
	ld b,$00		; $4bfc
--
	cp (hl)			; $4bfe
	jr z,++			; $4bff
	inc b			; $4c01
	inc hl			; $4c02
	jr --			; $4c03
++
	ld a,b			; $4c05
	ld hl,@xRanges		; $4c06
	rst_addDoubleIndex			; $4c09
	ld a,(w1Link.xh)		; $4c0a
	cp (hl)			; $4c0d
	jr c,++			; $4c0e
	inc hl			; $4c10
	cp (hl)			; $4c11
	jr nc,++		; $4c12
	xor a			; $4c14
	ret			; $4c15
++
	or d			; $4c16
	ret			; $4c17

@rooms:
	.db <ROOM_036
	.db <ROOM_037
	.db <ROOM_027

@xRanges:
	.db $40 $70
	.db $10 $30
	.db $40 $80

@tutorialTextToShow:
	.dw TX_2008
	.dw TX_2009
	.dw TX_0000
	.dw TX_2108
	.dw TX_2207
	.dw TX_2206

@flagNumbers:
	.db $00 $01 $00 $03 $04 $00


; ==============================================================================
; INTERACID_GAME_COMPLETE_DIALOG
; ==============================================================================
interactionCoded1:
	ld e,Interaction.state		; $4c33
	ld a,(de)		; $4c35
	rst_jumpTable			; $4c36
	.dw @state0
	.dw interactionRunScript

@state0:
	ld a,$01		; $4c3b
	ld (de),a		; $4c3d
	ld c,a			; $4c3e
	callab bank1.loadDeathRespawnBufferPreset		; $4c3f
	ld hl,gameCompleteDialogScript		; $4c47
	jp interactionSetScript		; $4c4a


; ==============================================================================
; INTERACID_TITLESCREEN_CLOUDS
; ==============================================================================
interactionCoded2:
	ld e,Interaction.state		; $4c4d
	ld a,(de)		; $4c4f
	rst_jumpTable			; $4c50
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $4c55
	ld (de),a		; $4c57
	call interactionInitGraphics		; $4c58
	ld e,Interaction.subid		; $4c5b
	ld a,(de)		; $4c5d
	ld hl,@positions		; $4c5e
	rst_addDoubleIndex			; $4c61
	ldi a,(hl)		; $4c62
	ld b,(hl)		; $4c63
	ld h,d			; $4c64
	ld l,Interaction.var37		; $4c65
	ld (hl),a		; $4c67
	ld l,Interaction.yh		; $4c68
	ldi (hl),a		; $4c6a
	inc l			; $4c6b
	ld (hl),b		; $4c6c

	ld l,Interaction.angle		; $4c6d
	ld (hl),ANGLE_DOWN		; $4c6f
	ld l,Interaction.speed		; $4c71
	ld (hl),SPEED_20		; $4c73
	ret			; $4c75

@positions:
	.db $bf $7c ; 0 == [subid]
	.db $bf $2a ; 1
	.db $9f $94 ; 2
	.db $a3 $10 ; 3


@state1:
	ld a,(wGfxRegs1.SCY)		; $4c7e
	ld b,a			; $4c81
	ld e,Interaction.var37		; $4c82
	ld a,(de)		; $4c84
	sub b			; $4c85
	inc e			; $4c86
	ld e,Interaction.yh		; $4c87
	ld (de),a		; $4c89

	call checkInteractionState2		; $4c8a
	jr nz,@substate1	; $4c8d

@substate0:
	ld a,(wGfxRegs1.SCY)		; $4c8f
	cp $e0			; $4c92
	ret nz			; $4c94
	call interactionIncState2		; $4c95
	call objectSetVisible82		; $4c98

@substate1:
	ld a,(wGfxRegs1.SCY)		; $4c9b
	cp $88			; $4c9e
	ret z			; $4ca0

;;
; This is used by INTERACID_TITLESCREEN_CLOUDS and INTERACID_INTRO_BIRD.
; @param[out]	a	X position
; @addr{4ca1}
_introObject_applySpeed:
	ld h,d			; $4ca1
	ld l,Interaction.angle		; $4ca2
	ld c,(hl)		; $4ca4
	ld l,Interaction.speed		; $4ca5
	ld b,(hl)		; $4ca7
	call getPositionOffsetForVelocity		; $4ca8
	ret z			; $4cab

	ld e,Interaction.var36		; $4cac
	ld a,(de)		; $4cae
	add (hl)		; $4caf
	ld (de),a		; $4cb0
	inc e			; $4cb1
	inc l			; $4cb2
	ld a,(de)		; $4cb3
	adc (hl)		; $4cb4
	ld (de),a		; $4cb5

	ld e,Interaction.x		; $4cb6
	inc l			; $4cb8
	ld a,(de)		; $4cb9
	add (hl)		; $4cba
	ld (de),a		; $4cbb
	inc e			; $4cbc
	inc l			; $4cbd
	ld a,(de)		; $4cbe
	adc (hl)		; $4cbf
	ld (de),a		; $4cc0
	ret			; $4cc1


; ==============================================================================
; INTERACID_INTRO_BIRD
; ==============================================================================
interactionCoded3:
	ld e,Interaction.state		; $4cc2
	ld a,(de)		; $4cc4
	rst_jumpTable			; $4cc5
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $4cca
	ld (de),a		; $4ccc
	call interactionInitGraphics		; $4ccd

	; counter2: How long the bird should remain (it will respawn if it goes off-screen
	; before counter2 reaches 0)
	ld h,d			; $4cd0
	ld l,Interaction.counter2		; $4cd1
	ld (hl),45		; $4cd3

	; Determine direction to move in based on subid
	ld l,Interaction.subid		; $4cd5
	ld a,(hl)		; $4cd7
	ld b,$00		; $4cd8
	ld c,$1a		; $4cda
	cp $04			; $4cdc
	jr c,+			; $4cde
	inc b			; $4ce0
	ld c,$06		; $4ce1
+
	ld l,Interaction.angle		; $4ce3
	ld (hl),c		; $4ce5
	ld l,Interaction.speed		; $4ce6
	ld (hl),SPEED_140		; $4ce8

	push af			; $4cea
	ld a,b			; $4ceb
	call interactionSetAnimation		; $4cec

	pop af			; $4cef

@initializePositionAndCounter1:
	ld b,a			; $4cf0
	add a			; $4cf1
	add b			; $4cf2
	ld hl,@birdPositionsAndAppearanceDelays		; $4cf3
	rst_addAToHl			; $4cf6
	ldi a,(hl)		; $4cf7
	ld b,(hl)		; $4cf8
	inc l			; $4cf9
	ld c,(hl)		; $4cfa
	ld h,d			; $4cfb
	ld l,Interaction.var37		; $4cfc
	ld (hl),a		; $4cfe
	ld l,Interaction.yh		; $4cff
	ldi (hl),a		; $4d01
	inc l			; $4d02
	ld (hl),b		; $4d03
	ld l,Interaction.counter1		; $4d04
	ld (hl),c		; $4d06
	ret			; $4d07

@state1:
	; Update Y
	ld a,(wGfxRegs1.SCY)		; $4d08
	ld b,a			; $4d0b
	ld e,Interaction.var37		; $4d0c
	ld a,(de)		; $4d0e
	sub b			; $4d0f
	inc e			; $4d10
	ld e,Interaction.yh		; $4d11
	ld (de),a		; $4d13

	ld e,Interaction.state2		; $4d14
	ld a,(de)		; $4d16
	rst_jumpTable			; $4d17
	.dw @substate0
	.dw @substate1
	.dw @substate2

@substate0:
	ld a,(wGfxRegs1.SCY)		; $4d1e
	cp $10			; $4d21
	ret nz			; $4d23
	jp interactionIncState2		; $4d24

@substate1:
	call interactionDecCounter1		; $4d27
	ret nz			; $4d2a
	call interactionIncState2		; $4d2b
	jp objectSetVisible82		; $4d2e

@substate2:
	ld e,Interaction.counter2		; $4d31
	ld a,(de)		; $4d33
	or a			; $4d34
	jr z,+			; $4d35
	dec a			; $4d37
	ld (de),a		; $4d38
+
	call interactionAnimate		; $4d39
	call _introObject_applySpeed		; $4d3c
	cp $b0			; $4d3f
	ret c			; $4d41

	; Bird is off-screen; check whether to "reset" the bird or just delete it.
	ld h,d			; $4d42
	ld l,Interaction.counter2		; $4d43
	ld a,(hl)		; $4d45
	or a			; $4d46
	jp z,interactionDelete		; $4d47

	ld l,Interaction.state2		; $4d4a
	dec (hl)		; $4d4c
	ld l,Interaction.subid		; $4d4d
	ld a,(hl)		; $4d4f
	call @initializePositionAndCounter1		; $4d50

	; Set counter1 (the delay before reappearing) randomly
	call getRandomNumber_noPreserveVars		; $4d53
	and $0f			; $4d56
	ld h,d			; $4d58
	ld l,Interaction.counter1		; $4d59
	ld (hl),a		; $4d5b
	jp objectSetInvisible		; $4d5c


; Data format:
;   b0: Y
;   b1: X
;   b2: counter1 (delay before appearing)
@birdPositionsAndAppearanceDelays:
	.db $4c $18 $01 ; 0 == [subid]
	.db $58 $20 $10 ; 1
	.db $5a $30 $14 ; 2
	.db $50 $28 $16 ; 3
	.db $50 $74 $04 ; 4
	.db $4c $84 $0a ; 5
	.db $5c $8c $12 ; 6
	.db $58 $7c $17 ; 7


; ==============================================================================
; INTERACID_LINK_SHIP
; ==============================================================================
interactionCoded4:
	ld e,Interaction.state		; $4d77
	ld a,(de)		; $4d79
	rst_jumpTable			; $4d7a
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $4d7f
	ld (de),a		; $4d81
	ld h,d			; $4d82
	ld l,Interaction.subid		; $4d83
	ld a,(hl)		; $4d85
	ld b,a			; $4d86
	and $0f			; $4d87
	ld (hl),a		; $4d89

	ld a,b			; $4d8a
	swap a			; $4d8b
	and $0f			; $4d8d
	add a			; $4d8f
	add a			; $4d90
	ld l,Interaction.counter1		; $4d91
	ld (hl),a		; $4d93

	call interactionInitGraphics		; $4d94
	jp objectSetVisible82		; $4d97

@state1:
	ld e,Interaction.subid		; $4d9a
	ld a,(de)		; $4d9c
	cp $02			; $4d9d
	ret z			; $4d9f

	call interactionDecCounter1		; $4da0
	ld e,Interaction.subid		; $4da3
	ld a,(de)		; $4da5
	or a			; $4da6
	jr nz,@seagull	; $4da7

@ship:
	; Update the "bobbing" of the ship using the Z position (every 32 frames)
	ld a,(wFrameCounter)		; $4da9
	ld b,a			; $4dac
	and $1f			; $4dad
	ret nz			; $4daf

	ld a,b			; $4db0
	and $e0			; $4db1
	swap a			; $4db3
	rrca			; $4db5
	ld hl,@zPositions		; $4db6
	rst_addAToHl			; $4db9
	ld e,Interaction.zh		; $4dba
	ld a,(hl)		; $4dbc
	ld (de),a		; $4dbd
	ret			; $4dbe

@zPositions:
	.db $00 $ff $ff $00 $00 $01 $01 $00


@seagull:
	; Similarly update the "bobbing" of the seagull, but more frequently
	ld a,(hl) ; [counter1]
	and $07			; $4dc8
	ret nz			; $4dca

	ld a,(hl)		; $4dcb
	and $38			; $4dcc
	swap a			; $4dce
	rlca			; $4dd0
	ld hl,@zPositions		; $4dd1
	rst_addAToHl			; $4dd4
	ld e,Interaction.zh		; $4dd5
	ld a,(hl)		; $4dd7
	ld (de),a		; $4dd8
	ret			; $4dd9


; ==============================================================================
; INTERACID_FARORE_GIVEITEM
; ==============================================================================
interactionCoded9:
	ld e,Interaction.state		; $4dda
	ld a,(de)		; $4ddc
	rst_jumpTable			; $4ddd
	.dw _interactiond9_state0
	.dw _interactiond9_state1
	.dw _interactiond9_state2

_interactiond9_state0:
	ld a,$01		; $4de4
	ld (wLoadedTreeGfxIndex),a		; $4de6

	; Check if the secret has been told already
	ld e,Interaction.subid		; $4de9
	ld a,(de)		; $4deb
	ld b,a			; $4dec
	add GLOBALFLAG_5a			; $4ded
	call checkGlobalFlag		; $4def
	jr z,@secretNotTold			; $4df2

	ld bc,TX_550c ; "You told me this secret already"
	call showText		; $4df7

	; Bit 1 is a signal for Farore to continue talking
	ld a,$02		; $4dfa
	ld (wTmpcfc0.genericCutscene.state),a		; $4dfc

	jp interactionDelete		; $4dff

@secretNotTold:
	; Decide whether to go to state 1 or 2 based on the secret told.
	ld a,b			; $4e02
	ld hl,@bits		; $4e03
	call checkFlag		; $4e06
	ld a,$02		; $4e09
	jr nz,+			; $4e0b
	dec a			; $4e0d
+
	ld e,Interaction.state		; $4e0e
	ld (de),a		; $4e10
	ret			; $4e11

; If a bit is set for a corresponding secret, it's an upgrade (go to state 2); otherwise,
; it's a new item (go to state 1).
@bits:
	dbrev %10001101 %01000000

;;
; @param[out]	bc	The item ID.
;			If this is an upgrade, 'c' is a value from 0-4 indicating the
;			behaviour (ie. compare with current ring box level, sword level)
; @addr{4e14}
_interactiond9_getItemID:
	ld e,Interaction.subid		; $4e14
	ld a,(de)		; $4e16
	ld hl,@chestContents		; $4e17
	rst_addDoubleIndex			; $4e1a
	ld b,(hl)		; $4e1b
	inc l			; $4e1c
	ld c,(hl)		; $4e1d
	ret			; $4e1e

@chestContents:
	.db  TREASURE_SWORD,           $00 ; upgrade
	dwbe TREASURE_HEART_CONTAINER_SUBID_01
	dwbe TREASURE_BOMBCHUS_SUBID_01
	dwbe TREASURE_RING_SUBID_0c
	.db  TREASURE_SHIELD,          $01 ; upgrade
	.db  TREASURE_BOMB_UPGRADE,    $02 ; upgrade
	dwbe TREASURE_RING_SUBID_0d
	.db  TREASURE_SATCHEL_UPGRADE, $03 ; upgrade
	dwbe TREASURE_BIGGORON_SWORD_SUBID_01
	.db  TREASURE_RING_BOX,        $04 ; upgrade


; State 1: it's a new item, not an upgrade
_interactiond9_state1:
	ld e,Interaction.state2		; $4e33
	ld a,(de)		; $4e35
	rst_jumpTable			; $4e36
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4

@substate0:
	ld a,$01		; $4e41
	ld (de),a		; $4e43
	xor a			; $4e44
	ld ($cca2),a		; $4e45

	call _interactiond9_getItemID		; $4e48
	ld a,b			; $4e4b
	ld (wChestContentsOverride),a		; $4e4c
	ld a,c			; $4e4f
	ld (wChestContentsOverride+1),a		; $4e50

	ld b,INTERACID_FARORE_MAKECHEST		; $4e53
	jp objectCreateInteractionWithSubid00		; $4e55

@substate1:
	ld a,(wTmpcfc0.genericCutscene.state)		; $4e58
	or a			; $4e5b
	ret z			; $4e5c

	ld e,Interaction.counter1		; $4e5d
	ld a,$3c		; $4e5f
	ld (de),a		; $4e61
	jp interactionIncState2		; $4e62

@substate2:
	call interactionDecCounter1		; $4e65
	ret nz			; $4e68

	ld a,GLOBALFLAG_SECRET_CHEST_WAITING		; $4e69
	call setGlobalFlag		; $4e6b

	; Bit 1 of $cfc0 is a signal for Farore to continue talking
	ld a,$02		; $4e6e
	ld ($cfc0),a		; $4e70

	ld bc,TX_5509 ; "Your secrets have called forth power"
	call showText		; $4e76
	jp interactionIncState2		; $4e79

@substate3:
	; Wait for the chest to be opened
	ld a,($cca2)		; $4e7c
	or a			; $4e7f
	ret z			; $4e80

	call _interactiond9_markSecretAsTold		; $4e81
	ld e,Interaction.counter1		; $4e84
	ld a,$1e		; $4e86
	ld (de),a		; $4e88
	jp interactionIncState2		; $4e89

@substate4:
	call interactionDecCounter1		; $4e8c
	ret nz			; $4e8f

	; Remove the chest
	call objectCreatePuff		; $4e90
	call objectGetShortPosition		; $4e93
	ld c,a			; $4e96
	ld a,$ac		; $4e97
	call setTile		; $4e99
	jp interactionDelete		; $4e9c


; State 2: it's an upgrade; it doesn't go in a chest.
_interactiond9_state2:
	ld e,Interaction.state2		; $4e9f
	ld a,(de)		; $4ea1
	rst_jumpTable			; $4ea2
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4
	.dw @substate5
	.dw @substate6
	.dw @substate7
	.dw @substate8

@substate0:
	call interactionIncState2		; $4eb5
	ld l,Interaction.counter1		; $4eb8
	ld (hl),30		; $4eba
	ld hl,w1Link		; $4ebc
	jp objectTakePosition		; $4ebf

@substate1:
	call interactionDecCounter1		; $4ec2
	ret nz			; $4ec5
	ld (hl),60		; $4ec6

	call getFreeInteractionSlot		; $4ec8
	ret nz			; $4ecb
	ld (hl),INTERACID_SPARKLE		; $4ecc
	ld l,Interaction.yh		; $4ece
	ld (hl),$28		; $4ed0
	ld l,Interaction.xh		; $4ed2
	ld (hl),$58		; $4ed4
	jp interactionIncState2		; $4ed6

@substate2:
	call interactionDecCounter1		; $4ed9
	ret nz			; $4edc
	ld (hl),20		; $4edd

	ld a,(w1Link.yh)		; $4edf
	ld b,a			; $4ee2
	ld a,(w1Link.xh)		; $4ee3
	ld c,a			; $4ee6
	ld a,$78		; $4ee7
	call createEnergySwirlGoingIn		; $4ee9
	jp interactionIncState2		; $4eec

@substate3:
@substate4:
	call interactionDecCounter1		; $4eef
	ret nz			; $4ef2
	ld (hl),$14		; $4ef3
	call fadeinFromWhite		; $4ef5

@playFadeOutSoundAndIncState:
	ld a,SND_FADEOUT		; $4ef8
	call playSound		; $4efa
	jp interactionIncState2		; $4efd

@substate5:
	call interactionDecCounter1		; $4f00
	ret nz			; $4f03
	ld a,$02		; $4f04
	call fadeinFromWhiteWithDelay		; $4f06
	jr @playFadeOutSoundAndIncState		; $4f09

@substate6:
	ld a,(wPaletteThread_mode)		; $4f0b
	or a			; $4f0e
	ret nz			; $4f0f
	call _interactiond9_getItemID		; $4f10
	ld a,c			; $4f13
	rst_jumpTable			; $4f14
	.dw @swordUpgrade
	.dw @shieldUpgrade
	.dw @bombUpgrade
	.dw @satchelUpgrade
	.dw @ringBoxUpgrade

@ringBoxUpgrade:
	ld a,(wRingBoxLevel)		; $4f1f
	and $03			; $4f22
	ld hl,@ringBoxSubids		; $4f24
	rst_addAToHl			; $4f27
	ld c,(hl)		; $4f28
	ld b,TREASURE_RING_BOX		; $4f29
	jr @createTreasureAndIncState2		; $4f2b

@ringBoxSubids:
	.db $03 $03 $04 $04

@swordShieldSubids:
	.db $03 $01
	.db $03 $01
	.db $05 $02
	.db $05 $02

@swordUpgrade:
	ld a,(wSwordLevel)		; $4f39
	jr ++			; $4f3c

@shieldUpgrade:
	ld a,(wShieldLevel)		; $4f3e
++
	ld hl,@swordShieldSubids		; $4f41
	rst_addDoubleIndex			; $4f44
	inc hl			; $4f45
	ld a,(hl)		; $4f46
	jr @label_0b_135		; $4f47

@bombUpgrade:
	ldbc TREASURE_BOMB_UPGRADE, $00		; $4f49
	call @createTreasureAndIncState2		; $4f4c
	ld hl,wMaxBombs		; $4f4f
	ld a,(hl)		; $4f52
	add $20			; $4f53
	ldd (hl),a		; $4f55
	ld (hl),a		; $4f56
	jp setStatusBarNeedsRefreshBit1		; $4f57

@satchelUpgrade:
	ld a,(wSeedSatchelLevel)		; $4f5a
	ldbc TREASURE_SEED_SATCHEL, $04		; $4f5d
	jr @createTreasureAndIncState2		; $4f60

@label_0b_135:
	and $03			; $4f62
	ld c,a			; $4f64

@createTreasureAndIncState2:
	call @createTreasure		; $4f65
	ld e,Interaction.counter1		; $4f68
	ld a,30		; $4f6a
	ld (de),a		; $4f6c
	jp interactionIncState2		; $4f6d

@substate7:
	call retIfTextIsActive		; $4f70
	call interactionDecCounter1		; $4f73
	ret nz			; $4f76

	ld e,Interaction.subid		; $4f77
	ld a,(de)		; $4f79
	cp $07			; $4f7a
	jr z,@fillSatchel	; $4f7c
	or a			; $4f7e
	jr nz,@cleanup	; $4f7f

	; The sword upgrade acts differently? Maybe due to Link doing a spin slash?
	ld a,(wSwordLevel)		; $4f81
	add $02			; $4f84
	ld c,a			; $4f86
	ld b,TREASURE_SWORD		; $4f87
	call @createTreasure		; $4f89
	call interactionIncState2		; $4f8c
	ld l,Interaction.counter1		; $4f8f
	ld (hl),$5a		; $4f91
	ret			; $4f93

@fillSatchel:
	call refillSeedSatchel		; $4f94

@cleanup:
	; Bit 1 of $cfc0 is a signal for Farore to continue talking
	ld a,$02		; $4f97
	ld ($cfc0),a		; $4f99

	ld bc,TX_5509		; $4f9c
	call showText		; $4f9f
	call _interactiond9_markSecretAsTold		; $4fa2
	jp interactionDelete		; $4fa5

@substate8:
	call interactionDecCounter1		; $4fa8
	ret nz			; $4fab
	jr @cleanup		; $4fac

;;
; @param	bc	The treasure to create
@createTreasure:
	call createTreasure		; $4fae
	ret nz			; $4fb1
	jp objectCopyPosition		; $4fb2

;;
; @addr{4fb5}
_interactiond9_markSecretAsTold:
	ld e,Interaction.subid		; $4fb5
	ld a,(de)		; $4fb7
	add GLOBALFLAG_5a			; $4fb8
	call setGlobalFlag		; $4fba
	ld a,GLOBALFLAG_SECRET_CHEST_WAITING		; $4fbd
	jp unsetGlobalFlag		; $4fbf



; ==============================================================================
; INTERACID_ZELDA_APPROACH_TRIGGER
; ==============================================================================
interactionCodeda:
	ld e,Interaction.state		; $4fc2
	ld a,(de)		; $4fc4
	rst_jumpTable			; $4fc5
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $4fca
	ld (de),a		; $4fcc
	call getThisRoomFlags		; $4fcd
	and ROOMFLAG_80			; $4fd0
	jp nz,interactionDelete		; $4fd2
	ld a,PALH_ac		; $4fd5
	jp loadPaletteHeader		; $4fd7

@state1:
	call checkLinkVulnerable		; $4fda
	ret nc			; $4fdd
	ld a,(wScrollMode)		; $4fde
	and SCROLLMODE_08 | SCROLLMODE_04 | SCROLLMODE_02			; $4fe1
	ret nz			; $4fe3

	ld hl,w1Link.yh		; $4fe4
	ld e,Interaction.yh		; $4fe7
	ld a,(de)		; $4fe9
	cp (hl)			; $4fea
	ret c			; $4feb

	ld l,<w1Link.xh		; $4fec
	ld e,Interaction.xh		; $4fee
	ld a,(de)		; $4ff0
	sub (hl)		; $4ff1
	jr nc,+			; $4ff2
	cpl			; $4ff4
	inc a			; $4ff5
+
	cp $09			; $4ff6
	ret nc			; $4ff8

	; Link has approached, start the cutscene
	ld a,CUTSCENE_WARP_TO_TWINROVA_FIGHT		; $4ff9
	ld (wCutsceneTrigger),a		; $4ffb
	ld (wMenuDisabled),a		; $4ffe

	; Make the flames invisible
	ldhl FIRST_DYNAMIC_INTERACTION_INDEX, Interaction.enabled		; $5001
--
	ld l,Interaction.enabled		; $5004
	ldi a,(hl)		; $5006
	or a			; $5007
	jr z,++			; $5008
	ldi a,(hl)		; $500a
	cp INTERACID_TWINROVA_FLAME			; $500b
	jr nz,++		; $500d
	ld l,Interaction.visible		; $500f
	res 7,(hl)		; $5011
++
	inc h			; $5013
	ld a,h			; $5014
	cp LAST_INTERACTION_INDEX+1			; $5015
	jr c,--			; $5017
	jp interactionDelete		; $5019


; ==============================================================================
; INTERACID_EXPLOSION_WITH_DEBRIS
; ==============================================================================
interactionCode99:
	ld e,Interaction.state		; $501c
	ld a,(de)		; $501e
	rst_jumpTable			; $501f
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $5024
	ld (de),a		; $5026
	call interactionInitGraphics		; $5027
	call objectSetVisible81		; $502a
	ld e,Interaction.subid		; $502d
	ld a,(de)		; $502f
	rst_jumpTable			; $5030
	.dw @initSubid00
	.dw @initSubid01
	.dw @initSubid02

@initSubid00:
	inc e			; $5037
	ld a,(de) ; [var03]
	or a			; $5039
	ret z			; $503a

	call getRandomNumber_noPreserveVars		; $503b
	and $03			; $503e
	ld hl,@subid0Positions		; $5040
	rst_addDoubleIndex			; $5043
	call getRandomNumber		; $5044
	and $07			; $5047
	sub $03			; $5049
	add (hl)		; $504b
	ld b,a			; $504c
	inc hl			; $504d
	call getRandomNumber		; $504e
	and $07			; $5051
	sub $03			; $5053
	add (hl)		; $5055
	ld c,a			; $5056
	jp interactionSetPosition		; $5057

@initSubid02:
	ld e,Interaction.var38		; $505a
	ld a,(de)		; $505c
	res 6,a			; $505d
	ld e,Interaction.visible		; $505f
	ld (de),a		; $5061

@initSubid01:
	; Determine angle based on var03 with a small random element
	call getRandomNumber_noPreserveVars		; $5062
	and $03			; $5065
	add $02			; $5067
	ld c,a			; $5069
	ld h,d			; $506a
	ld l,Interaction.var03		; $506b
	ld a,(hl)		; $506d
	add a			; $506e
	add a			; $506f
	add a			; $5070
	add c			; $5071
	and $1f			; $5072
	ld l,Interaction.angle		; $5074
	ld (hl),a		; $5076

	; Set speed randomly
	call getRandomNumber		; $5077
	and $03			; $507a
	ld bc,@subid1And2Speeds		; $507c
	call addAToBc		; $507f
	ld a,(bc)		; $5082
	ld l,Interaction.speed		; $5083
	ld (hl),a		; $5085
	ld l,Interaction.speedZ		; $5086
	ld (hl),<(-$180)		; $5088
	inc l			; $508a
	ld (hl),>(-$180)		; $508b
	ret			; $508d

@state1:
	ld e,Interaction.subid		; $508e
	ld a,(de)		; $5090
	rst_jumpTable			; $5091
	.dw @runSubid0
	.dw @runSubid1Or2
	.dw @runSubid1Or2

@runSubid0:
	call interactionAnimate		; $5098
	ld e,Interaction.animParameter		; $509b
	ld a,(de)		; $509d
	or a			; $509e
	ret z			; $509f
	inc a			; $50a0
	jp z,interactionDelete		; $50a1

	xor a			; $50a4
	ld (de),a		; $50a5
	ldh (<hFF8B),a	; $50a6
	ldh (<hFF8D),a	; $50a8
	ldh (<hFF8C),a	; $50aa

	; Spawn 4 pieces of debris
	ld b,$04		; $50ac
--
	call getFreeInteractionSlot		; $50ae
	ret nz			; $50b1
	ld (hl),INTERACID_EXPLOSION_WITH_DEBRIS		; $50b2
	inc l			; $50b4
	inc (hl)		; $50b5
	inc l			; $50b6
	ld (hl),b		; $50b7
	call objectCopyPosition		; $50b8
	dec b			; $50bb
	jr nz,--		; $50bc
	ret			; $50be

@subid1And2Speeds:
	.db SPEED_180
	.db SPEED_1c0
	.db SPEED_200
	.db SPEED_240

@runSubid1Or2:
	call objectApplySpeed		; $50c3
	ld c,$28		; $50c6
	call objectUpdateSpeedZ_paramC		; $50c8
	jp z,interactionDelete		; $50cb
	ret			; $50ce

; One of these positions is picked at random
@subid0Positions:
	.db $48 $48
	.db $48 $58
	.db $58 $48
	.db $58 $58


; ==============================================================================
; INTERACID_CARPENTER
;
; Variables:
;   var3f: Nonzero if the carpenter has returned to the boss
; ==============================================================================
interactionCode9a:
	ld e,Interaction.state		; $50d7
	ld a,(de)		; $50d9
	rst_jumpTable			; $50da
	.dw @state0
	.dw @state1
	.dw @state2

@state0:
	ld e,Interaction.subid		; $50e1
	ld a,(de)		; $50e3
	cp $09			; $50e4
	jr z,@initialize	; $50e6

	ld a,GLOBALFLAG_SYMMETRY_BRIDGE_BUILT		; $50e8
	call checkGlobalFlag		; $50ea
	jp nz,@delete		; $50ed

	; Carpenters don't appear in linked game until Zelda's saved
	call checkIsLinkedGame		; $50f0
	jr z,++			; $50f3
	ld a,GLOBALFLAG_GOT_RING_FROM_ZELDA		; $50f5
	call checkGlobalFlag		; $50f7
	jr z,@delete	; $50fa
++
	ld e,Interaction.subid		; $50fc
	ld a,(de)		; $50fe
	inc a			; $50ff
	jr z,@runSubidFF	; $5100

@initialize:
	call interactionIncState		; $5102
	call interactionInitGraphics		; $5105
	call objectSetVisiblec2		; $5108
	ld a,>TX_2300		; $510b
	call interactionSetHighTextIndex		; $510d
	ld e,Interaction.subid		; $5110
	ld a,(de)		; $5112
	and $0f			; $5113
	rst_jumpTable			; $5115
	.dw @initSubid00
	.dw @initSubid01
	.dw @initSubid02
	.dw @initSubid03
	.dw @initSubid04
	.dw $0000
	.dw $0000
	.dw $0000
	.dw $0000
	.dw @initSubid09


; Checks if you leave the area without finding all the carpenters
@runSubidFF:
	ld a,(wTmpcfc0.carpenterSearch.cfd0)		; $512a
	or a			; $512d
	ret z			; $512e
	ld a,(wScrollMode)		; $512f
	and SCROLLMODE_08 | SCROLLMODE_04 | SCROLLMODE_02			; $5132
	ret nz			; $5134

	ld e,Interaction.var3f		; $5135
	ld a,(de)		; $5137
	or a			; $5138
	jr z,++			; $5139
	dec a			; $513b
	ld (de),a		; $513c
	ld (wDisallowMountingCompanion),a		; $513d
++
	ld e,Interaction.state2		; $5140
	ld a,(de)		; $5142
	dec a			; $5143
	jr z,@@substate1	; $5144

@@substate0:
	ld a,(wLinkObjectIndex)		; $5146
	ld h,a			; $5149
	ld l,SpecialObject.xh		; $514a
	ld a,$10		; $514c
	cp (hl)			; $514e
	ret c			; $514f
	ld a,$01 ; [state2] = $01
	ld (de),a		; $5152
	ld bc,TX_2307		; $5153
	jp showText		; $5156

@@substate1:
	call retIfTextIsActive		; $5159
	ld a,(wSelectedTextOption)		; $515c
	dec a			; $515f
	jr z,++			; $5160
	ld hl,wTmpcfc0.carpenterSearch.cfd0		; $5162
	ld b,$10		; $5165
	call clearMemory		; $5167
@delete:
	jp interactionDelete		; $516a

++
	call resetLinkInvincibility		; $516d
	ld a,-60		; $5170
	ld (w1Link.invincibilityCounter),a		; $5172
	ld a,$78		; $5175
	ld (wDisallowMountingCompanion),a		; $5177
	ld e,Interaction.var3f		; $517a
	ld (de),a		; $517c
	ld a,ANGLE_RIGHT		; $517d
	ld (w1Link.angle),a		; $517f
	ld e,Interaction.state2		; $5182
	xor a			; $5184
	ld (de),a		; $5185
	ld a,(wLinkObjectIndex)		; $5186
	ld h,a			; $5189
	ld l,SpecialObject.xh		; $518a
	ld (hl),$12		; $518c
	rrca			; $518e
	ret nc			; $518f

	ld l,SpecialObject.id		; $5190
	ld a,(hl)		; $5192
	ld l,SpecialObject.state		; $5193
	cp SPECIALOBJECTID_RICKY			; $5195
	jr nz,++		; $5197

	; Do something with Ricky's state?
	ldi a,(hl)		; $5199
	cp $05			; $519a
	ret nz			; $519c
	ld a,$03		; $519d
	ld (hl),a		; $519f
	ret			; $51a0
++
	cp SPECIALOBJECTID_DIMITRI			; $51a1
	ret nz			; $51a3

	; Do something with Dimitri's state?
	ld a,(hl)		; $51a4
	cp $08			; $51a5
	ret nz			; $51a7
	ld (hl),$0d		; $51a8
	ret			; $51aa

@initSubid01:
	xor a			; $51ab
	ld e,Interaction.oamFlags		; $51ac
	ld (de),a		; $51ae
	call objectMakeTileSolid		; $51af
	ld h,>wRoomLayout		; $51b2
	ld (hl),$00		; $51b4
	jr @checkDoBridgeBuildingCutscene		; $51b6

@initSubid02:
@initSubid03:
@initSubid04:
	ld a,(wActiveRoom)		; $51b8
	cp <ROOM_025			; $51bb
	jr z,@@inBridgeRoom	; $51bd

	ld a,(de)		; $51bf
	swap a			; $51c0
	and $0f			; $51c2
	ld hl,wAnimalCompanion		; $51c4
	cp (hl)			; $51c7
	jr nz,@delete	; $51c8
	ld a,(de)		; $51ca
	and $0f			; $51cb
	ld hl,wTmpcfc0.carpenterSearch.carpentersFound		; $51cd
	call checkFlag		; $51d0
	jr nz,@delete2	; $51d3
	jr @checkDoBridgeBuildingCutscene		; $51d5

@@inBridgeRoom:
	ld a,(de)		; $51d7
	and $0f			; $51d8
	ld hl,wTmpcfc0.carpenterSearch.carpentersFound		; $51da
	call checkFlag		; $51dd
	ld e,Interaction.var3f		; $51e0
	ld (de),a		; $51e2
	jr z,@delete2	; $51e3

	; Check if all 3 have been found
	ld a,(hl)		; $51e5
	cp $1c			; $51e6
	jr nz,@checkDoBridgeBuildingCutscene	; $51e8

	ld e,Interaction.subid		; $51ea
	ld a,(de)		; $51ec
	add $04			; $51ed
	ld (de),a		; $51ef
	jr @checkDoBridgeBuildingCutscene		; $51f0

@initSubid00:
	ld a,$03		; $51f2
	ld e,Interaction.oamFlags		; $51f4
	ld (de),a		; $51f6
	ld a,(wTmpcfc0.carpenterSearch.carpentersFound)		; $51f7
	cp $1c			; $51fa
	jr nz,@checkDoBridgeBuildingCutscene	; $51fc
	ld e,Interaction.subid		; $51fe
	ld a,$05		; $5200
	ld (de),a		; $5202
	ld a,$58		; $5203
	ld e,Interaction.xh		; $5205
	ld (de),a		; $5207

@checkDoBridgeBuildingCutscene:
	ld a,GLOBALFLAG_SYMMETRY_BRIDGE_BUILT		; $5208
	call checkGlobalFlag		; $520a
	jr nz,@delete2	; $520d

@initSubid09:
	call objectMarkSolidPosition		; $520f
	ld e,Interaction.subid		; $5212
	ld a,(de)		; $5214
	and $0f			; $5215
	ld hl,@animationsForBridgeBuildCutsceneStart		; $5217
	rst_addAToHl			; $521a
	ld a,(hl)		; $521b
	call interactionSetAnimation		; $521c
	ld a,$06		; $521f
	call objectSetCollideRadius		; $5221
	call interactionSetAlwaysUpdateBit		; $5224
	jp @loadScript		; $5227


@state1:
	ld e,Interaction.subid		; $522a
	ld a,(de)		; $522c
	and $0f			; $522d
	rst_jumpTable			; $522f
	.dw @runSubid
	.dw @runSubid01
	.dw @runSubid
	.dw @runSubid
	.dw @runSubid
	.dw @runSubid
	.dw @runSubid
	.dw @runSubid
	.dw @runSubid
	.dw @runSubid

@runSubid:
	call interactionAnimateAsNpc		; $5244
	ld c,$40		; $5247
	call objectUpdateSpeedZ_paramC		; $5249
	call interactionRunScript		; $524c
	ret nc			; $524f
@delete2:
	jp interactionDelete		; $5250

@runSubid01:
	ld a,(wTmpcfc0.carpenterSearch.cfd0)		; $5253
	cp $0b			; $5256
	ret nz			; $5258
	ld a,$3a		; $5259
	ld c,$55		; $525b
	call setTile		; $525d
	jr @delete2		; $5260

; State 2: carpender jumping away until he goes off-screen
@state2:
	call interactionAnimate		; $5262
	ld h,d			; $5265
	ld l,Interaction.angle		; $5266
	ld (hl),ANGLE_LEFT		; $5268
	ld l,Interaction.speed		; $526a
	ld (hl),SPEED_100		; $526c
	call objectApplySpeed		; $526e
	call objectCheckWithinScreenBoundary		; $5271
	jr nc,@@leftScreen	; $5274

	ld c,$10		; $5276
	call objectUpdateSpeedZ_paramC		; $5278
	ret nz			; $527b
	ld bc,-$200		; $527c
	call objectSetSpeedZ		; $527f
	ld a,SND_JUMP		; $5282
	jp playSound		; $5284

@@leftScreen:
	; If that was the last carpenter, warp Link to the bridge screen
	ld e,Interaction.subid		; $5287
	ld a,(de)		; $5289
	and $0f			; $528a
	ld hl,wTmpcfc0.carpenterSearch.carpentersFound		; $528c
	call setFlag		; $528f
	ld a,(hl)		; $5292
	cp $1c			; $5293
	ld hl,@warpDest		; $5295
	jp z,setWarpDestVariables		; $5298
	xor a			; $529b
	ld (wMenuDisabled),a		; $529c
	ld (wDisabledObjects),a		; $529f
	jr @delete2		; $52a2

@warpDest:
	.db $80 $25 $00 $48 $03


@loadScript:
	ld e,Interaction.subid		; $52a9
	ld a,(de)		; $52ab
	and $0f			; $52ac
	ld hl,@scriptTable		; $52ae
	rst_addDoubleIndex			; $52b1
	ldi a,(hl)		; $52b2
	ld h,(hl)		; $52b3
	ld l,a			; $52b4
	jp interactionSetScript		; $52b5

@scriptTable:
	.dw carpenter_subid00Script
	.dw carpenter_subid00Script
	.dw carpenter_subid02Script
	.dw carpenter_subid03Script
	.dw carpenter_subid04Script
	.dw carpenter_subid05Script
	.dw carpenter_subid06Script
	.dw carpenter_subid07Script
	.dw carpenter_subid08Script
	.dw carpenter_subid09Script

; Animations for each subid
@animationsForBridgeBuildCutsceneStart:
	.db $04 $06 $02 $02 $02 $05 $03 $02
	.db $02 $00


; ==============================================================================
; INTERACID_RAFTWRECK_CUTSCENE
; ==============================================================================
interactionCode9b:
	ld e,Interaction.state		; $52d6
	ld a,(de)		; $52d8
	rst_jumpTable			; $52d9
	.dw @state0
	.dw @state1

@state0:
	call getThisRoomFlags		; $52de
	bit ROOMFLAG_BIT_40,a			; $52e1
	jp nz,interactionDelete		; $52e3

	ld a,$01		; $52e6
	ld (wDisabledObjects),a		; $52e8
	ld (wMenuDisabled),a		; $52eb
	ld a,(wLinkObjectIndex)		; $52ee
	ld h,a			; $52f1
	ld l,SpecialObject.xh		; $52f2
	ld c,(hl)		; $52f4
	ld b,$76		; $52f5
	call interactionSetPosition		; $52f7
	call setLinkForceStateToState08		; $52fa
	ld (wTmpcfc0.genericCutscene.cfd0),a		; $52fd
	jp interactionIncState		; $5300

@state1:
	call @updateSubstate		; $5303
	ld a,(wLinkObjectIndex)		; $5306
	ld h,a			; $5309
	ld l,SpecialObject.yh		; $530a
	jp objectCopyPosition		; $530c

@updateSubstate:
	ld e,Interaction.state2		; $530f
	ld a,(de)		; $5311
	cp $02			; $5312
	call nc,interactionRunScript		; $5314
	ld e,Interaction.state2		; $5317
	ld a,(de)		; $5319
	rst_jumpTable			; $531a
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4
	.dw @substate5
	.dw @substate6
	.dw @substate7
	.dw @substate8

@substate0:
	ld a,(wScrollMode)		; $532d
	and SCROLLMODE_01			; $5330
	ret z			; $5332

	; Initialize Link's speed/direction to move to the center of the screen
	call interactionIncState2		; $5333
	ld l,Interaction.speed		; $5336
	ld (hl),SPEED_80		; $5338
	ld l,Interaction.xh		; $533a
	ld a,(hl)		; $533c
	sub $50			; $533d
	ld c,DIR_LEFT		; $533f
	ld b,ANGLE_LEFT		; $5341
	jr nc,++		; $5343
	ld c,DIR_RIGHT		; $5345
	ld b,ANGLE_RIGHT		; $5347
	cpl			; $5349
	inc a			; $534a
++
	ld l,Interaction.angle		; $534b
	ld (hl),b		; $534d
	ld l,Interaction.counter1		; $534e
	add a			; $5350
	ld (hl),a		; $5351
	ld a,c			; $5352
	jp setLinkDirection		; $5353

@substate1:
	ld h,d			; $5356
	ld l,Interaction.counter1		; $5357
	ld a,(hl)		; $5359
	or a			; $535a
	jr z,++			; $535b
	dec (hl)		; $535d
	jp objectApplySpeed		; $535e
++
	; Begin the script
	call interactionIncState2		; $5361
	ld hl,raftwreckCutsceneScript		; $5364
	jp interactionSetScript		; $5367

@substate2:
	ld a,(wTmpcfc0.genericCutscene.state)		; $536a
	cp $01			; $536d
	ret nz			; $536f

@initScreenFlashing:
	ld hl,wGenericCutscene.cbb3		; $5370
	ld (hl),$00		; $5373
	ld hl,wGenericCutscene.cbba		; $5375
	ld (hl),$ff		; $5378
	jp interactionIncState2		; $537a

@substate3:
@substate5:
	ld hl,wGenericCutscene.cbb3		; $537d
	ld b,$01		; $5380
	call flashScreen		; $5382
	ret z			; $5385

	call interactionIncState2		; $5386
	ldi a,(hl)		; $5389
	cp $03			; $538a
	ld a,$5a		; $538c
	jr z,+			; $538e
	ld a,$78		; $5390
+
	ld (hl),a		; $5392
	ld a,$f1		; $5393
	ld (wPaletteThread_parameter),a		; $5395
	jp darkenRoom		; $5398

@substate4:
	call interactionDecCounter1		; $539b
	ret nz			; $539e
	jr @initScreenFlashing		; $539f

@substate6:
	call interactionDecCounter1		; $53a1
	ret nz			; $53a4
	ld a,$02		; $53a5
	ld (wTmpcfc0.genericCutscene.state),a		; $53a7
	jp interactionIncState2		; $53aa

@substate7:
	ld a,(wTmpcfc0.genericCutscene.state)		; $53ad
	cp $03			; $53b0
	jr nz,++		; $53b2

	call interactionIncState2		; $53b4
	ld l,Interaction.counter1		; $53b7
	ld (hl),20		; $53b9
	ret			; $53bb
++
	ld e,Interaction.var38		; $53bc
	ld a,(de)		; $53be
	or a			; $53bf
	ret z			; $53c0
	jp @oscillateY		; $53c1

@substate8:
	call interactionDecCounter1		; $53c4
	ret nz			; $53c7
	ld a,SNDCTRL_FAST_FADEOUT		; $53c8
	call playSound		; $53ca
	call getThisRoomFlags		; $53cd
	set ROOMFLAG_BIT_40,(hl)		; $53d0
	ld hl,w1Companion.enabled		; $53d2
	res 1,(hl)		; $53d5
	ld a,>w1Link		; $53d7
	ld (wLinkObjectIndex),a		; $53d9
	ld hl,@tokayWarpDest		; $53dc
	jp setWarpDestVariables		; $53df

@tokayWarpDest:
	.db $81 $aa $00 $42 $03

@oscillateY:
	ld a,(wFrameCounter)		; $53e7
	and $07			; $53ea
	ret nz			; $53ec
	ld a,(wFrameCounter)		; $53ed
	and $38			; $53f0
	swap a			; $53f2
	rlca			; $53f4
	ld hl,@yOscillation		; $53f5
	rst_addAToHl			; $53f8
	ld e,Interaction.yh		; $53f9
	ld a,(de)		; $53fb
	add (hl)		; $53fc
	ld (de),a		; $53fd
	ret			; $53fe

@yOscillation:
	.db $ff $fe $ff $00 $01 $02 $01 $00


; ==============================================================================
; INTERACID_KING_ZORA
; ==============================================================================
interactionCode9c:
	ld e,Interaction.subid		; $5407
	ld a,(de)		; $5409
	ld e,Interaction.state		; $540a
	rst_jumpTable			; $540c
	.dw @subid0
	.dw @subid1
	.dw @subid2


; Present King Zora
@subid0:
	ld a,(de)		; $5413
	or a			; $5414
	jr z,@subid0State0	; $5416

@state1:
	call interactionRunScript		; $5417
	jp interactionAnimate		; $541a

@subid0State0:
	ld a,GLOBALFLAG_KING_ZORA_CURED		; $541d
	call checkGlobalFlag		; $541f
	jp z,interactionDelete		; $5422
	call @choosePresentKingZoraScript		; $5425

@setScriptAndInit:
	call interactionSetScript		; $5428
	ld e,Interaction.pressedAButton		; $542b
	call objectAddToAButtonSensitiveObjectList		; $542d
	call interactionInitGraphics		; $5430
	call interactionSetAlwaysUpdateBit		; $5433
	call interactionIncState		; $5436
	ld a,$0a		; $5439
	call objectSetCollideRadius		; $543b
	jp objectSetVisible82		; $543e


; Past King Zora
@subid1:
	ld a,(de)		; $5441
	or a			; $5442
	jr nz,@state1	; $5443

	call @choosePastKingZoraScript		; $5445
	jr @setScriptAndInit		; $5448


; Potion sprite
@subid2:
	ld a,(de)		; $544a
	or a			; $544b
	jr z,@subid2State0	; $544c

@subid2State1:
	call interactionDecCounter1		; $544e
	ret nz			; $5451
	jp interactionDelete		; $5452

@subid2State0:
	call interactionInitGraphics		; $5455
	call interactionIncState		; $5458
	ld l,Interaction.counter1		; $545b
	ld (hl),$24		; $545d
	jp objectSetVisible81		; $545f


@choosePresentKingZoraScript:
	ld a,GLOBALFLAG_WATER_POLLUTION_FIXED		; $5462
	call checkGlobalFlag		; $5464
	jr z,@@pollutionNotFixed	; $5467

	ld a,TREASURE_ESSENCE		; $5469
	call checkTreasureObtained		; $546b
	bit 6,a			; $546e
	jr z,@@justCleanedWater	; $5470

	ld a,GLOBALFLAG_FINISHEDGAME		; $5472
	call checkGlobalFlag		; $5474
	ld hl,kingZoraScript_present_afterD7		; $5477
	ret z			; $547a

	ld a,TREASURE_SWORD		; $547b
	call checkTreasureObtained		; $547d
	and $01			; $5480
	ld e,Interaction.var03		; $5482
	ld (de),a		; $5484
	ld hl,kingZoraScript_present_postGame		; $5485
	ret			; $5488

@@pollutionNotFixed:
	ld a,TREASURE_LIBRARY_KEY		; $5489
	call checkTreasureObtained		; $548b
	ld hl,kingZoraScript_present_acceptedTask		; $548e
	ret c			; $5491

	call getThisRoomFlags		; $5492
	bit 6,(hl)		; $5495
	ld hl,kingZoraScript_present_firstTime		; $5497
	ret z			; $549a
	ld hl,kingZoraScript_present_giveKey		; $549b
	ret			; $549e

@@justCleanedWater:
	ld a,GLOBALFLAG_GOT_PERMISSION_TO_ENTER_JABU		; $549f
	call checkGlobalFlag		; $54a1
	ld hl,kingZoraScript_present_justCleanedWater		; $54a4
	ret z			; $54a7
	ld hl,kingZoraScript_present_cleanedWater		; $54a8
	ret			; $54ab

@choosePastKingZoraScript:
	ld a,GLOBALFLAG_KING_ZORA_CURED		; $54ac
	call checkGlobalFlag		; $54ae
	jr z,@@notCured	; $54b1

	ld a,GLOBALFLAG_WATER_POLLUTION_FIXED		; $54b3
	call checkGlobalFlag		; $54b5
	ld hl,kingZoraScript_past_justCured		; $54b8
	ret z			; $54bb

	ld a,TREASURE_ESSENCE		; $54bc
	call checkTreasureObtained		; $54be
	bit 6,a			; $54c1
	ld hl,kingZoraScript_past_cleanedWater		; $54c3
	ret z			; $54c6
	ld hl,kingZoraScript_past_afterD7		; $54c7
	ret			; $54ca

@@notCured:
	ld a,TREASURE_POTION		; $54cb
	call checkTreasureObtained		; $54cd
	ld hl,kingZoraScript_past_dontHavePotion		; $54d0
	ret nc			; $54d3
	ld hl,kingZoraScript_past_havePotion		; $54d4
	ret			; $54d7


; ==============================================================================
; INTERACID_TOKKEY
; ==============================================================================
interactionCode9d:
	ld e,Interaction.state		; $54d8
	ld a,(de)		; $54da
	rst_jumpTable			; $54db
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3
	.dw @state4

@state0:
	call interactionInitGraphics		; $54e6
	ld a,>TX_2c00		; $54e9
	call interactionSetHighTextIndex		; $54eb
	ld hl,tokkeyScript		; $54ee
	call interactionSetScript		; $54f1
	call objectSetVisible82		; $54f4
	jp interactionIncState		; $54f7


@state1:
	; Check that Link's talked to the guy once
	ld a,(wTmpcfc0.genericCutscene.state)		; $54fa
	bit 0,a			; $54fd
	jr z,@runScript	; $54ff

	ld a,(wLinkPlayingInstrument)		; $5501
	cp $01			; $5504
	jr nz,@runScript	; $5506

	call checkLinkCollisionsEnabled		; $5508
	ret nc			; $550b

	ld a,(wActiveTilePos)		; $550c
	cp $32			; $550f
	jr z,++			; $5511
	ld bc,TX_2c05		; $5513
	jp showText		; $5516
++
	ld a,60		; $5519
	ld bc,$f810		; $551b
	call objectCreateExclamationMark		; $551e
	ld hl,tokkeyScript_justHeardTune		; $5521
	call interactionSetScript		; $5524
	jp interactionIncState		; $5527

@runScript:
	ld c,$20		; $552a
	call objectUpdateSpeedZ_paramC		; $552c
	call interactionRunScript		; $552f
	jp c,interactionDelete		; $5532
	jp npcFaceLinkAndAnimate		; $5535


@state2:
	call @checkCreateMusicNote		; $5538
	call interactionAnimate		; $553b

@state4:
	call interactionRunScript		; $553e
	ld c,$20		; $5541
	jp objectUpdateSpeedZ_paramC		; $5543

@state3:
	call @checkCreateMusicNote		; $5546
	call interactionRunScript		; $5549
	call interactionAnimate		; $554c
	call interactionAnimate		; $554f
	ld c,$60		; $5552
	call objectUpdateSpeedZ_paramC		; $5554
	ret nz			; $5557
	ld bc,-$200		; $5558
	jp objectSetSpeedZ		; $555b


@checkCreateMusicNote:
	ld a,(wTmpcfc0.genericCutscene.state)		; $555e
	bit 1,a			; $5561
	ret z			; $5563
	ld a,(wFrameCounter)		; $5564
	and $0f			; $5567
	ret nz			; $5569
	call getRandomNumber		; $556a
	and $01			; $556d
	ld bc,$f808		; $556f
	jp objectCreateFloatingMusicNote		; $5572


; ==============================================================================
; INTERACID_WATER_PUSHBLOCK
; ==============================================================================
interactionCode9e:
	ld e,Interaction.subid		; $5575
	ld a,(de)		; $5577
	rst_jumpTable			; $5578
	.dw @subid0
	.dw @subid1

@subid0:
	ld e,Interaction.state		; $557d
	ld a,(de)		; $557f
	rst_jumpTable			; $5580
	.dw @subid0State0
	.dw @state1
	.dw @state2
	.dw @subid0State3
	.dw objectPreventLinkFromPassing

@subid0State0:
	call getThisRoomFlags		; $558b
	and $01			; $558e
	jp nz,interactionDelete		; $5590

@initialize:
	call interactionInitGraphics		; $5593
	call objectMarkSolidPosition		; $5596
	ld a,$06		; $5599
	call objectSetCollideRadius		; $559b

	ld l,Interaction.speed		; $559e
	ld (hl),SPEED_80		; $55a0
	ld l,Interaction.counter1		; $55a2
	ld (hl),30		; $55a4

	call objectSetVisible82		; $55a6
	jp interactionIncState		; $55a9


; Check if Link is pushing against the block
@state1:
	call objectPreventLinkFromPassing		; $55ac
	jr nc,@@notPushing	; $55af
	call objectCheckLinkPushingAgainstCenter		; $55b1
	jr nc,@@notPushing	; $55b4

	; Link is pushing against in
	ld a,$01		; $55b6
	ld (wForceLinkPushAnimation),a		; $55b8
	call interactionDecCounter1		; $55bb
	ret nz			; $55be
	jr @@pushedLongEnough			; $55bf

@@notPushing:
	ld e,Interaction.counter1		; $55c1
	ld a,30		; $55c3
	ld (de),a		; $55c5
	ret			; $55c6

@@pushedLongEnough:
	ld c,$28		; $55c7
	call objectCheckLinkWithinDistance		; $55c9
	ld b,a			; $55cc
	ld e,Interaction.subid		; $55cd
	ld a,(de)		; $55cf
	or a			; $55d0
	ld c,$02		; $55d1
	jr z,+			; $55d3
	ld c,$06		; $55d5
+
	ld a,b			; $55d7
	cp c			; $55d8
	ret nz			; $55d9
	ld e,Interaction.direction		; $55da
	xor $04			; $55dc
	ld (de),a		; $55de

	ld h,d			; $55df
	ld l,Interaction.direction		; $55e0
	ld a,(hl)		; $55e2
	add a			; $55e3
	add a			; $55e4
	ld l,Interaction.angle		; $55e5
	ld (hl),a		; $55e7

	ld l,Interaction.counter1		; $55e8
	ld (hl),$40		; $55ea

	ld a,DISABLE_ALL_BUT_INTERACTIONS | DISABLE_LINK		; $55ec
	ld (wDisabledObjects),a		; $55ee
	ld (wMenuDisabled),a		; $55f1
	ld a,SNDCTRL_STOPMUSIC		; $55f4
	call playSound		; $55f6
	ld a,SND_MOVEBLOCK		; $55f9
	call playSound		; $55fb
	jp interactionIncState		; $55fe


; Link has pushed the block; waiting for it to move to the other side
@state2:
	call objectApplySpeed		; $5601
	call objectPreventLinkFromPassing		; $5604
	call interactionDecCounter1		; $5607
	ret nz			; $560a
	ld (hl),70		; $560b
	jp interactionIncState		; $560d


; Pushed block from right to left
@subid0State3:
	ld e,Interaction.state2		; $5610
	ld a,(de)		; $5612
	rst_jumpTable			; $5613
	.dw @subid0Substate0
	.dw @subid0Substate1
	.dw @subid0Substate2
	.dw @subid0Substate3
	.dw @subid0Substate4
	.dw @subid0Substate5
	.dw @subid0Substate6
	.dw @subid0Substate7
	.dw @subid0Substate8
	.dw @subid0Substate9
	.dw @substateA
	.dw @substateB

@subid0Substate0:
	call interactionDecCounter1		; $562c
	ret nz			; $562f
	ld (hl),$08		; $5630
	ld a,SND_FLOODGATES		; $5632
	call playSound		; $5634
	ld a,$63		; $5637
	call @setInterleavedHoleGroundTile		; $5639
	ld a,$65		; $563c
	call @setInterleavedHoleGroundTile		; $563e
	jp interactionIncState2		; $5641

@subid0Substate1:
	ldbc $63,$65		; $5644
@setGroundTilesWhenCounterIsZero:
	call interactionDecCounter1		; $5647
	ret nz			; $564a
	ld (hl),$08		; $564b
	ld a,b			; $564d
	call @setGroundTile		; $564e
	ld a,c			; $5651
	call @setPuddleTile		; $5652
	jp interactionIncState2		; $5655

@subid0Substate2:
	ldbc $62,$66		; $5658
@setHoleTilesWhenCounterIsZero:
	call interactionDecCounter1		; $565b
	ret nz			; $565e
	ld (hl),$08		; $565f
	ld a,b			; $5661
	call @setInterleavedHoleGroundTile		; $5662
	ld a,c			; $5665
	call @setInterleavedHoleGroundTile		; $5666
	jp interactionIncState2		; $5669

@subid0Substate3:
	ldbc $62,$66		; $566c
	jr @setGroundTilesWhenCounterIsZero		; $566f

@subid0Substate4:
	ldbc $61,$67		; $5671
	jr @setHoleTilesWhenCounterIsZero		; $5674

@subid0Substate5:
	ldbc $61,$67		; $5676
	jr @setGroundTilesWhenCounterIsZero		; $5679

@subid0Substate6:
	call interactionDecCounter1		; $567b
	ret nz			; $567e
	ld (hl),$08		; $567f
	ld a,$60		; $5681
	call @setInterleavedPuddleHoleTile		; $5683
	ld a,$68		; $5686
	call @setInterleavedHoleGroundTile		; $5688
	jp interactionIncState2		; $568b

@subid0Substate7:
	call interactionDecCounter1		; $568e
	ret nz			; $5691
	ld (hl),$08		; $5692
	ld a,$60		; $5694
	call @setHoleTile		; $5696
	ld a,$68		; $5699
	call @setPuddleTile		; $569b
	jp interactionIncState2		; $569e

@subid0Substate8:
	call interactionDecCounter1		; $56a1
	ret nz			; $56a4
	ld (hl),$08		; $56a5
	ld a,$69		; $56a7
	call @setInterleavedPuddleHoleTile		; $56a9
	jp interactionIncState2		; $56ac

@subid0Substate9:
	call interactionDecCounter1		; $56af
	ret nz			; $56b2
	ld (hl),90		; $56b3
	ld c,$69		; $56b5

@setWaterTileAndIncState2:
	ld a,TILEINDEX_WATER		; $56b7
	call setTile		; $56b9
	jp interactionIncState2		; $56bc

@substateA:
	call interactionDecCounter1		; $56bf
	ret nz			; $56c2
	ld (hl),$48		; $56c3
	ld a,SNDCTRL_STOPSFX		; $56c5
	call playSound		; $56c7
	ld a,SND_SOLVEPUZZLE		; $56ca
	call playSound		; $56cc
	jp interactionIncState2		; $56cf

@substateB:
	call interactionDecCounter1		; $56d2
	ret nz			; $56d5
	ld a,(wActiveMusic)		; $56d6
	call playSound		; $56d9
	xor a			; $56dc
	ld (wDisabledObjects),a		; $56dd
	ld (wMenuDisabled),a		; $56e0
	call @swapRoomLayouts		; $56e3
	jp interactionIncState		; $56e6

;;
; @param	a	Position
; @addr{56e9}
@setHoleTile:
	ld c,a			; $56e9
	ld a,TILEINDEX_HOLE		; $56ea
	jp setTile		; $56ec

;;
; @param	a	Position
; @addr{56ef}
@setInterleavedPuddleHoleTile:
	ld hl,@@data		; $56ef
	jr @setInterleavedTile			; $56f2

@@data:
	.db $f3 $f9 $03

;;
; @param	a	Position
; @addr{56ef}
@setInterleavedHolePuddleTile:
	ld hl,@@data		; $56f7
	jr @setInterleavedTile			; $56fa

@@data:
	.db $f3 $f9 $01

;;
; @param	a	Position
; @addr{56ff}
@setGroundTile:
	push bc			; $56ff
	ld c,a			; $5700
	ld a,$1b		; $5701
	call setTile		; $5703
	pop bc			; $5706
	ret			; $5707

;;
; @param	a	Position
; @addr{5708}
@setPuddleTile:
	push bc			; $5708
	ld c,a			; $5709
	ld a,TILEINDEX_PUDDLE		; $570a
	call setTile		; $570c
	pop bc			; $570f
	ret			; $5710

;;
; @param	a	Position
; @addr{5711}
@setInterleavedHoleGroundTile:
	ld hl,@@data		; $5711
	jr @setInterleavedTile			; $5714

@@data:
	.db $1b $f9 $03

@setInterleavedGroundHoleTile:
	ld hl,@@data		; $5719
	jr @setInterleavedTile			; $571b

@@data:
	.db $1b $f9 $01

;;
; @param	a	Position
; @param	hl	Interleaved tile data
; @addr{5721}
@setInterleavedTile:
	ldh (<hFF8C),a	; $5721
	ldi a,(hl)		; $5723
	ldh (<hFF8F),a	; $5724
	ldi a,(hl)		; $5726
	ldh (<hFF8E),a	; $5727
	ldi a,(hl)		; $5729
	jp setInterleavedTile		; $572a

@subid1:
	ld e,Interaction.state		; $572d
	ld a,(de)		; $572f
	rst_jumpTable			; $5730
	.dw @subid1State0
	.dw @state1
	.dw @state2
	.dw @subid1State3
	.dw objectPreventLinkFromPassing

@subid1State0:
	call getThisRoomFlags		; $573b
	and $01			; $573e
	jp z,interactionDelete		; $5740
	jp @initialize		; $5743

; Pushed block from left to right
@subid1State3:
	ld e,Interaction.state2		; $5746
	ld a,(de)		; $5748
	rst_jumpTable			; $5749
	.dw @subid1Substate0
	.dw @subid1Substate1
	.dw @subid1Substate2
	.dw @subid1Substate3
	.dw @subid1Substate4
	.dw @subid1Substate5
	.dw @subid1Substate6
	.dw @subid1Substate7
	.dw @subid1Substate8
	.dw @subid1Substate9
	.dw @substateA
	.dw @substateB

@subid1Substate0:
	call interactionDecCounter1		; $5762
	ret nz			; $5765
	ld (hl),$08		; $5766
	ld a,SND_FLOODGATES		; $5768
	call playSound		; $576a
	ld a,$63		; $576d
	call @setInterleavedGroundHoleTile		; $576f
	ld a,$65		; $5772
	call @setInterleavedGroundHoleTile		; $5774
	jp interactionIncState2		; $5777

@subid1Substate1:
	ldbc $65,$63		; $577a
	jp @setGroundTilesWhenCounterIsZero		; $577d

@subid1Substate2:
	ldbc $66,$62		; $5780
@setHoleTilesWhenCounterZero_2:
	call interactionDecCounter1		; $5783
	ret nz			; $5786
	ld (hl),$08		; $5787
	ld a,b			; $5789
	call @setInterleavedGroundHoleTile		; $578a
	ld a,c			; $578d
	call @setInterleavedGroundHoleTile		; $578e
	jp interactionIncState2		; $5791

@subid1Substate3:
	ldbc $66,$62		; $5794
	jp @setGroundTilesWhenCounterIsZero		; $5797

@subid1Substate4:
	ldbc $61,$67		; $579a
	jp @setHoleTilesWhenCounterZero_2		; $579d

@subid1Substate5:
	ldbc $67,$61		; $57a0
	jp @setGroundTilesWhenCounterIsZero		; $57a3

@subid1Substate6:
	call interactionDecCounter1		; $57a6
	ret nz			; $57a9
	ld (hl),$08		; $57aa
	ld a,$60		; $57ac
	call @setInterleavedHolePuddleTile		; $57ae
	ld a,$68		; $57b1
	call @setInterleavedGroundHoleTile		; $57b3
	jp interactionIncState2		; $57b6

@subid1Substate7:
	call interactionDecCounter1		; $57b9
	ret nz			; $57bc
	ld (hl),$08		; $57bd
	ld a,$68		; $57bf
	call @setGroundTile		; $57c1
	ld c,$60		; $57c4
	jp @setWaterTileAndIncState2		; $57c6

@subid1Substate8:
	call interactionDecCounter1		; $57c9
	ret nz			; $57cc
	ld (hl),$08		; $57cd
	ld a,$69		; $57cf
	call @setInterleavedHolePuddleTile		; $57d1
	jp interactionIncState2		; $57d4

@subid1Substate9:
	call interactionDecCounter1		; $57d7
	ret nz			; $57da
	ld (hl),$5a		; $57db
	ld a,$69		; $57dd
	call @setHoleTile		; $57df
	jp interactionIncState2		; $57e2

;;
; Swap the room layouts in all rooms affected by the flooding.
; @addr{57e5}
@swapRoomLayouts:
	call getThisRoomFlags		; $57e5
	ld l,<ROOM_140		; $57e8
	call @@xor		; $57ea
	call @@xor		; $57ed
	call @@xor		; $57f0
	ld l,<ROOM_150		; $57f3
	call @@xor		; $57f5
	call @@xor		; $57f8
	call @@xor		; $57fb
	dec h			; $57fe
	ld l,<ROOM_040		; $57ff
	call @@xor		; $5801
	call @@xor		; $5804
	call @@xor		; $5807
	ld l,<ROOM_050		; $580a
	call @@xor		; $580c
	call @@xor		; $580f

@@xor:
	ld a,(hl)		; $5812
	xor $01			; $5813
	ldi (hl),a		; $5815
	ret			; $5816


; ==============================================================================
; INTERACID_MOVING_SIDESCROLL_PLATFORM
; ==============================================================================
interactionCodea1:
	call _sidescrollPlatform_checkLinkOnPlatform		; $5817
	call @updateSubid		; $581a
	jp _sidescrollingPlatformCommon		; $581d

@updateSubid:
	ld e,Interaction.state		; $5820
	ld a,(de)		; $5822
	sub $08			; $5823
	jr c,@state0To7		; $5825
	rst_jumpTable			; $5827
	.dw @state8
	.dw @state9
	.dw @stateA
	.dw @stateB
	.dw _movingPlatform_stateC

@state0To7:
	ld hl,bank0e.movingSidescrollPlatformScriptTable		; $5832
	call objectLoadMovementScript		; $5835
	call interactionInitGraphics		; $5838
	ld e,Interaction.direction		; $583b
	ld a,(de)		; $583d
	ld hl,@collisionRadii		; $583e
	rst_addDoubleIndex			; $5841
	ld e,Interaction.collisionRadiusY		; $5842
	ldi a,(hl)		; $5844
	ld (de),a		; $5845
	inc e			; $5846
	ld a,(hl)		; $5847
	ld (de),a		; $5848
	ld e,Interaction.direction		; $5849
	ld a,(de)		; $584b
	call interactionSetAnimation		; $584c
	jp objectSetVisible82		; $584f

@collisionRadii:
	.db $09 $0f
	.db $09 $17
	.db $19 $07
	.db $19 $0f
	.db $09 $07

@state8:
	ld e,Interaction.var32		; $585c
	ld a,(de)		; $585e
	ld h,d			; $585f
	ld l,Interaction.yh		; $5860
	cp (hl)			; $5862
	jr nc,+			; $5863
	jp objectApplySpeed		; $5865
+
	ld a,(de)		; $5868
	ld (hl),a		; $5869
	jp _sidescrollPlatformFunc_5bfc		; $586a

@state9:
	ld e,Interaction.xh		; $586d
	ld a,(de)		; $586f
	ld h,d			; $5870
	ld l,Interaction.var33		; $5871
	cp (hl)			; $5873
	jr nc,++		; $5874
	ld l,Interaction.speed		; $5876
	ld b,(hl)		; $5878
	ld c,ANGLE_RIGHT		; $5879
	ld a,(wLinkRidingObject)		; $587b
	cp d			; $587e
	call z,updateLinkPositionGivenVelocity		; $587f
	jp objectApplySpeed		; $5882
++
	ld a,(hl)		; $5885
	ld (de),a		; $5886
	jp _sidescrollPlatformFunc_5bfc		; $5887

@stateA:
	ld e,Interaction.yh		; $588a
	ld a,(de)		; $588c
	ld h,d			; $588d
	ld l,Interaction.var32		; $588e
	cp (hl)			; $5890
	jr nc,++		; $5891
	ld l,Interaction.speed		; $5893
	ld b,(hl)		; $5895
	ld c,ANGLE_DOWN		; $5896
	ld a,(wLinkRidingObject)		; $5898
	cp d			; $589b
	call z,updateLinkPositionGivenVelocity		; $589c
	jp objectApplySpeed		; $589f
++
	ld a,(hl)		; $58a2
	ld (de),a		; $58a3
	jp _sidescrollPlatformFunc_5bfc		; $58a4

@stateB:
	ld e,Interaction.var33		; $58a7
	ld a,(de)		; $58a9
	ld h,d			; $58aa
	ld l,Interaction.xh		; $58ab
	cp (hl)			; $58ad
	jr nc,++		; $58ae
	ld l,Interaction.speed		; $58b0
	ld b,(hl)		; $58b2
	ld c,ANGLE_LEFT		; $58b3
	ld a,(wLinkRidingObject)		; $58b5
	cp d			; $58b8
	call z,updateLinkPositionGivenVelocity		; $58b9
	jp objectApplySpeed		; $58bc
++
	ld a,(de)		; $58bf
	ld (hl),a		; $58c0
	jp _sidescrollPlatformFunc_5bfc		; $58c1


_movingPlatform_stateC:
	call interactionDecCounter1		; $58c4
	ret nz			; $58c7
	jp _sidescrollPlatformFunc_5bfc		; $58c8


; ==============================================================================
; INTERACID_MOVING_SIDESCROLL_CONVEYOR
; ==============================================================================
interactionCodea2:
	call interactionAnimate		; $58cb
	call _sidescrollPlatform_checkLinkOnPlatform		; $58ce
	call nz,_sidescrollPlatform_updateLinkKnockbackForConveyor		; $58d1
	call @updateState		; $58d4
	jp _sidescrollingPlatformCommon		; $58d7

@updateState:
	ld e,Interaction.state		; $58da
	ld a,(de)		; $58dc
	sub $08			; $58dd
	jr c,@state0To7		; $58df
	rst_jumpTable			; $58e1
	.dw @state8
	.dw @state9
	.dw @stateA
	.dw @stateB
	.dw _movingPlatform_stateC

@state0To7:
	ld hl,bank0e.movingSidescrollConveyorScriptTable		; $58ec
	call objectLoadMovementScript		; $58ef
	call interactionInitGraphics		; $58f2
	ld h,d			; $58f5
	ld l,Interaction.collisionRadiusY		; $58f6
	ld (hl),$08		; $58f8
	inc l			; $58fa
	ld (hl),$0c		; $58fb
	ld e,Interaction.direction		; $58fd
	ld a,(de)		; $58ff
	call interactionSetAnimation		; $5900
	jp objectSetVisible82		; $5903

@state8:
	ld e,Interaction.var32		; $5906
	ld a,(de)		; $5908
	ld h,d			; $5909
	ld l,Interaction.yh		; $590a
	cp (hl)			; $590c
	jr c,@applySpeed	; $590d
	ld a,(de)		; $590f
	ld (hl),a		; $5910
	jp _sidescrollPlatformFunc_5bfc		; $5911

@state9:
	ld e,Interaction.xh		; $5914
	ld a,(de)		; $5916
	ld h,d			; $5917
	ld l,Interaction.var33		; $5918
	cp (hl)			; $591a
	jr c,@applySpeed	; $591b
	ld a,(hl)		; $591d
	ld (de),a		; $591e
	jp _sidescrollPlatformFunc_5bfc		; $591f

@stateA:
	ld e,Interaction.yh		; $5922
	ld a,(de)		; $5924
	ld h,d			; $5925
	ld l,Interaction.var32		; $5926
	cp (hl)			; $5928
	jr nc,++		; $5929
	ld l,Interaction.speed		; $592b
	ld b,(hl)		; $592d
	ld c,ANGLE_DOWN		; $592e
	ld a,(wLinkRidingObject)		; $5930
	cp d			; $5933
	call z,updateLinkPositionGivenVelocity		; $5934
	jr @applySpeed		; $5937
++
	ld a,(hl)		; $5939
	ld (de),a		; $593a
	jp _sidescrollPlatformFunc_5bfc		; $593b

@stateB:
	ld e,Interaction.var33		; $593e
	ld a,(de)		; $5940
	ld h,d			; $5941
	ld l,Interaction.xh		; $5942
	cp (hl)			; $5944
	jr c,@applySpeed	; $5945
	ld a,(de)		; $5947
	ld (hl),a		; $5948
	jp _sidescrollPlatformFunc_5bfc		; $5949

@applySpeed:
	call objectApplySpeed		; $594c
	ld a,(wLinkRidingObject)		; $594f
	cp d			; $5952
	ret nz			; $5953

	ld e,Interaction.angle		; $5954
	ld a,(de)		; $5956
	rrca			; $5957
	rrca			; $5958
	ld b,a			; $5959
	ld e,Interaction.direction		; $595a
	ld a,(de)		; $595c
	add b			; $595d
	ld hl,@directions		; $595e
	rst_addDoubleIndex			; $5961
	ldi a,(hl)		; $5962
	ld c,a			; $5963
	ld b,(hl)		; $5964
	jp updateLinkPositionGivenVelocity		; $5965

@directions:
	.db ANGLE_RIGHT, SPEED_080
	.db ANGLE_LEFT,  SPEED_080
	.db ANGLE_RIGHT, SPEED_100
	.db ANGLE_LEFT,  SPEED_060
	.db ANGLE_RIGHT, SPEED_080
	.db ANGLE_LEFT,  SPEED_080
	.db ANGLE_RIGHT, SPEED_060
	.db ANGLE_LEFT,  SPEED_100


; ==============================================================================
; INTERACID_DISAPPEARING_SIDESCROLL_PLATFORM
; ==============================================================================
interactionCodea3:
	ld e,Interaction.state		; $5978
	ld a,(de)		; $597a
	cp $03			; $597b
	jr z,++			; $597d

	; Only do this if the platform isn't invisible
	call _sidescrollPlatform_checkLinkOnPlatform		; $597f
	call _sidescrollingPlatformCommon		; $5982
++
	ld e,Interaction.state		; $5985
	ld a,(de)		; $5987
	rst_jumpTable			; $5988
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3
	.dw @state4

@state0:
	ld e,Interaction.subid		; $5993
	ld a,(de)		; $5995
	ld hl,@subidData		; $5996
	rst_addDoubleIndex			; $5999

	ld e,Interaction.state		; $599a
	ldi a,(hl)		; $599c
	ld (de),a		; $599d
	ld e,Interaction.counter1		; $599e
	ld a,(hl)		; $59a0
	ld (de),a		; $59a1

	ld e,Interaction.collisionRadiusY		; $59a2
	ld a,$08		; $59a4
	ld (de),a		; $59a6
	inc e			; $59a7
	ld (de),a		; $59a8
	call interactionInitGraphics		; $59a9
	ld e,Interaction.subid		; $59ac
	ld a,(de)		; $59ae
	cp $02			; $59af
	jp z,objectSetVisible83		; $59b1
	ret			; $59b4

@subidData:
	.db $04,  60
	.db $03, 120
	.db $01,  60

@state1:
	call _sidescrollPlatform_decCounter1		; $59bb
	ret nz			; $59be
	ld (hl),30		; $59bf
	ld l,e			; $59c1
	inc (hl)		; $59c2
	xor a			; $59c3
	ret			; $59c4

@state2:
	call _sidescrollPlatform_decCounter1		; $59c5
	jr nz,@flickerVisibility		; $59c8
	ld (hl),150		; $59ca
	ld l,e			; $59cc
	inc (hl)		; $59cd
	jp objectSetInvisible		; $59ce

@flickerVisibility
	ld e,Interaction.visible		; $59d1
	ld a,(de)		; $59d3
	xor $80			; $59d4
	ld (de),a		; $59d6
	ret			; $59d7

@state3:
	call @state1		; $59d8
	ret nz			; $59db
	ld a,SND_MYSTERY_SEED		; $59dc
	jp playSound		; $59de

@state4:
	call _sidescrollPlatform_decCounter1		; $59e1
	jr nz,@flickerVisibility	; $59e4
	ld (hl),120		; $59e6
	ld l,e			; $59e8
	ld (hl),$01		; $59e9
	jp objectSetVisible83		; $59eb


; ==============================================================================
; INTERACID_CIRCULAR_SIDESCROLL_PLATFORM
; ==============================================================================
interactionCodea4:
	call _sidescrollPlatform_checkLinkOnPlatform		; $59ee
	call @updateState		; $59f1
	jp _sidescrollingPlatformCommon		; $59f4

@updateState:
	ld e,Interaction.state		; $59f7
	ld a,(de)		; $59f9
	rst_jumpTable			; $59fa
	.dw @state0
	.dw @state1

@state0:
	call interactionInitGraphics		; $59ff
	ld h,d			; $5a02
	ld l,Interaction.state		; $5a03
	inc (hl)		; $5a05

	ld l,Interaction.collisionRadiusY		; $5a06
	ld a,$08		; $5a08
	ldi (hl),a		; $5a0a
	ld (hl),a		; $5a0b

	ld l,Interaction.speed		; $5a0c
	ld (hl),SPEED_c0		; $5a0e
	ld l,Interaction.counter1		; $5a10
	ld (hl),$07		; $5a12

	ld e,Interaction.subid		; $5a14
	ld a,(de)		; $5a16
	ld hl,@angles		; $5a17
	rst_addAToHl			; $5a1a
	ld e,Interaction.angle		; $5a1b
	ld a,(hl)		; $5a1d
	ld (de),a		; $5a1e

	ld bc,$5678		; $5a1f
	ld a,$35		; $5a22
	call objectSetPositionInCircleArc		; $5a24

	ld e,Interaction.angle		; $5a27
	ld a,(de)		; $5a29
	add $08			; $5a2a
	and $1f			; $5a2c
	ld (de),a		; $5a2e
	call @func_5a67		; $5a2f
	jp objectSetVisible82		; $5a32

@angles:
	.db ANGLE_UP, ANGLE_RIGHT, ANGLE_DOWN

@state1:
	call interactionDecCounter1		; $5a38
	jr nz,++		; $5a3b
	ld (hl),$0e		; $5a3d
	ld l,Interaction.angle		; $5a3f
	ld a,(hl)		; $5a41
	inc a			; $5a42
	and $1f			; $5a43
	ld (hl),a		; $5a45
++
	call objectApplySpeed		; $5a46

	ld e,Interaction.var34		; $5a49
	ld a,(de)		; $5a4b
	or a			; $5a4c
	jr z,@func_5a67	; $5a4d

	ld h,d			; $5a4f
	ld l,Interaction.var36		; $5a50
	ld e,Interaction.yh		; $5a52
	ld a,(de)		; $5a54
	sub (hl)		; $5a55
	ld b,a			; $5a56

	inc l			; $5a57
	ld e,Interaction.xh		; $5a58
	ld a,(de)		; $5a5a
	sub (hl)		; $5a5b
	ld c,a			; $5a5c
	ld hl,w1Link.yh		; $5a5d
	ld a,(hl)		; $5a60
	add b			; $5a61
	ldi (hl),a		; $5a62
	inc l			; $5a63
	ld a,(hl)		; $5a64
	add c			; $5a65
	ld (hl),a		; $5a66

@func_5a67:
	ld h,d			; $5a67
	ld l,Interaction.var36		; $5a68
	ld e,Interaction.yh		; $5a6a
	ld a,(de)		; $5a6c
	ldi (hl),a		; $5a6d
	ld e,Interaction.xh		; $5a6e
	ld a,(de)		; $5a70
	ld (hl),a		; $5a71
	ret			; $5a72

;;
; Used by:
; * INTERACID_MOVING_SIDESCROLL_PLATFORM
; * INTERACID_MOVING_SIDESCROLL_CONVEYOR
; * INTERACID_DISAPPEARING_SIDESCROLL_PLATFORM
; * INTERACID_CIRCULAR_SIDESCROLL_PLATFORM
; @addr{5a73}
_sidescrollingPlatformCommon:
	ld a,(w1Link.state)		; $5a73
	cp LINK_STATE_NORMAL			; $5a76
	ret nz			; $5a78
	call objectCheckCollidedWithLink		; $5a79
	ret nc			; $5a7c

	; Platform has collided with Link.

	call _sidescrollPlatform_checkLinkIsClose		; $5a7d
	jr c,@label_0b_183	; $5a80
	call _sidescrollPlatform_getTileCollisionBehindLink		; $5a82
	jp z,_sidescrollPlatform_pushLinkAwayHorizontal		; $5a85

	call _sidescrollPlatform_checkLinkSquished		; $5a88
	ret c			; $5a8b

	ld e,Interaction.yh		; $5a8c
	ld a,(de)		; $5a8e
	ld b,a			; $5a8f
	ld a,(w1Link.yh)		; $5a90
	cp b			; $5a93
	ld c,ANGLE_UP		; $5a94
	jr nc,@moveLinkAtAngle	; $5a96
	ld c,ANGLE_DOWN		; $5a98
	jr @moveLinkAtAngle		; $5a9a

@label_0b_183:
	call _sidescrollPlatformFunc_5b51		; $5a9c
	ld a,(hl)		; $5a9f
	or a			; $5aa0
	jp z,_sidescrollPlatform_pushLinkAwayVertical		; $5aa1

	call _sidescrollPlatform_checkLinkSquished		; $5aa4
	ret c			; $5aa7
	ld a,(wLinkRidingObject)		; $5aa8
	cp d			; $5aab
	jr nz,@label_0b_184	; $5aac
	ldh a,(<hFF8B)	; $5aae
	cp $03			; $5ab0
	jr z,@label_0b_184	; $5ab2

	push af			; $5ab4
	call _sidescrollPlatform_pushLinkAwayVertical		; $5ab5
	pop af			; $5ab8
	rrca			; $5ab9
	jr ++			; $5aba

@label_0b_184:
	ld e,Interaction.xh		; $5abc
	ld a,(de)		; $5abe
	ld b,a			; $5abf
	ld a,(w1Link.xh)		; $5ac0
	cp b			; $5ac3
++
	ld c,ANGLE_RIGHT		; $5ac4
	jr nc,@moveLinkAtAngle	; $5ac6
	ld c,ANGLE_LEFT		; $5ac8

;;
; @param	c	Angle
; @addr{5aca}
@moveLinkAtAngle:
	ld b,SPEED_80		; $5aca
	jp updateLinkPositionGivenVelocity		; $5acc

;;
; @param[out]	cflag	c if Link got squished
; @addr{5acf}
_sidescrollPlatform_checkLinkSquished:
	ld h,d			; $5acf
	ld l,Interaction.collisionRadiusY		; $5ad0
	ld a,(hl)		; $5ad2
	ld b,a			; $5ad3
	add a			; $5ad4
	inc a			; $5ad5
	ld c,a			; $5ad6
	ld l,Interaction.yh		; $5ad7
	ld a,(w1Link.yh)		; $5ad9
	sub (hl)		; $5adc
	add b			; $5add
	cp c			; $5ade
	ret nc			; $5adf

	ld l,Interaction.collisionRadiusX		; $5ae0
	ld a,(hl)		; $5ae2
	add $02			; $5ae3
	ld b,a			; $5ae5
	add a			; $5ae6
	inc a			; $5ae7
	ld c,a			; $5ae8
	ld l,Interaction.xh		; $5ae9
	ld a,(w1Link.xh)		; $5aeb
	sub (hl)		; $5aee
	add b			; $5aef
	cp c			; $5af0
	ret nc			; $5af1

	xor a			; $5af2
	ld l,Interaction.angle		; $5af3
	bit 3,(hl)		; $5af5
	jr nz,+			; $5af7
	inc a			; $5af9
+
	ld (wcc50),a		; $5afa
	ld a,LINK_STATE_SQUISHED		; $5afd
	ld (wLinkForceState),a		; $5aff
	scf			; $5b02
	ret			; $5b03

;;
; @param[out]	cflag	c if Link's close enough to the platform?
; @addr{5b04}
_sidescrollPlatform_checkLinkIsClose:
	ld a,(wLinkInAir)		; $5b04
	or a			; $5b07
	ld b,$05		; $5b08
	jr z,+			; $5b0a
	dec b			; $5b0c
+
	ld h,d			; $5b0d
	ld l,Interaction.collisionRadiusX		; $5b0e
	ld a,(hl)		; $5b10
	add b			; $5b11

	ld b,a			; $5b12
	add a			; $5b13
	inc a			; $5b14
	ld c,a			; $5b15
	ld l,Interaction.xh		; $5b16
	ld a,(w1Link.xh)		; $5b18
	sub (hl)		; $5b1b
	add b			; $5b1c
	cp c			; $5b1d
	ret nc			; $5b1e

	ld l,Interaction.collisionRadiusY		; $5b1f
	ld a,(hl)		; $5b21
	sub $02			; $5b22
	ld b,a			; $5b24
	add a			; $5b25
	inc a			; $5b26
	ld c,a			; $5b27
	ld l,Interaction.yh		; $5b28
	ld a,(w1Link.yh)		; $5b2a
	sub (hl)		; $5b2d
	add b			; $5b2e
	cp c			; $5b2f
	ccf			; $5b30
	ret			; $5b31

;;
; @param[out]	a	Collision value
; @param[out]	zflag	nz if a valid collision value is returned
; @addr{5b32}
_sidescrollPlatform_getTileCollisionBehindLink:
	ld l,Interaction.xh		; $5b32
	ld a,(w1Link.xh)		; $5b34
	cp (hl)			; $5b37
	ld b,-$05		; $5b38
	jr c,+			; $5b3a
	ld b,$04		; $5b3c
+
	add b			; $5b3e
	ld c,a			; $5b3f
	ld a,(w1Link.yh)		; $5b40
	sub $04			; $5b43
	ld b,a			; $5b45
	call getTileCollisionsAtPosition		; $5b46
	ret nz			; $5b49
	ld a,b			; $5b4a
	add $08			; $5b4b
	ld b,a			; $5b4d
	jp getTileCollisionsAtPosition		; $5b4e

;;
; @param[out]	hl
; @addr{5b51}
_sidescrollPlatformFunc_5b51:
	ld h,d			; $5b51
	ld l,Interaction.yh		; $5b52
	ld a,(w1Link.yh)		; $5b54
	cp (hl)			; $5b57
	ld b,-$06		; $5b58
	jr c,+			; $5b5a
	ld b,$09		; $5b5c
+
	add b			; $5b5e
	ld b,a			; $5b5f
	ld a,(w1Link.xh)		; $5b60
	sub $03			; $5b63
	ld c,a			; $5b65
	call getTileCollisionsAtPosition		; $5b66
	ld hl,hFF8B		; $5b69
	ld (hl),$00		; $5b6c
	jr z,+			; $5b6e
	set 1,(hl)		; $5b70
+
	ld a,c			; $5b72
	add $05			; $5b73
	ld c,a			; $5b75
	call getTileCollisionsAtPosition		; $5b76
	ld hl,hFF8B		; $5b79
	ret z			; $5b7c
	inc (hl)		; $5b7d
	ret			; $5b7e

;;
; Checks if Link's on the platform, updates wLinkRidingObject if so.
;
; @param[out]	zflag	nz if Link is standing on the platform
; @addr{5b7f}
_sidescrollPlatform_checkLinkOnPlatform:
	call objectCheckCollidedWithLink		; $5b7f
	jr nc,@notOnPlatform	; $5b82

	ld h,d			; $5b84
	ld l,Interaction.yh		; $5b85
	ld a,(hl)		; $5b87
	ld l,Interaction.collisionRadiusY		; $5b88
	sub (hl)		; $5b8a
	sub $02			; $5b8b
	ld b,a			; $5b8d
	ld a,(w1Link.yh)		; $5b8e
	cp b			; $5b91
	jr nc,@notOnPlatform	; $5b92

	call _sidescrollPlatform_checkLinkIsClose		; $5b94
	jr nc,@notOnPlatform	; $5b97

	ld e,Interaction.var34		; $5b99
	ld a,(de)		; $5b9b
	or a			; $5b9c
	jr nz,@onPlatform		; $5b9d
	ld a,$01		; $5b9f
	ld (de),a		; $5ba1
	call _sidescrollPlatform_updateLinkSubpixels		; $5ba2

@onPlatform:
	ld a,d			; $5ba5
	ld (wLinkRidingObject),a		; $5ba6
	xor a			; $5ba9
	ret			; $5baa

@notOnPlatform:
	ld e,Interaction.var34		; $5bab
	ld a,(de)		; $5bad
	or a			; $5bae
	ret z			; $5baf
	ld a,$00		; $5bb0
	ld (de),a		; $5bb2
	ret			; $5bb3

;;
; @addr{5bb4}
_sidescrollPlatform_updateLinkKnockbackForConveyor:
	ld e,Interaction.angle		; $5bb4
	ld a,(de)		; $5bb6
	bit 3,a			; $5bb7
	ret z			; $5bb9

	ld hl,w1Link.knockbackAngle		; $5bba
	ld e,Interaction.direction		; $5bbd
	ld a,(de)		; $5bbf
	swap a			; $5bc0
	add $08			; $5bc2
	ld (hl),a		; $5bc4
	ld l,<w1Link.invincibilityCounter		; $5bc5
	ld (hl),$fc		; $5bc7
	ld l,<w1Link.knockbackCounter		; $5bc9
	ld (hl),$0c		; $5bcb
	ret			; $5bcd

;;
; @param[out]	hl	counter1
; @addr{5bce}
_sidescrollPlatform_decCounter1:
	ld h,d			; $5bce
	ld l,Interaction.counter1		; $5bcf
	ld a,(hl)		; $5bd1
	or a			; $5bd2
	ret z			; $5bd3
	dec (hl)		; $5bd4
	ret			; $5bd5

;;
; @addr{5bd6}
_sidescrollPlatform_pushLinkAwayVertical:
	ld hl,w1Link.collisionRadiusY		; $5bd6
	ld e,Interaction.collisionRadiusY		; $5bd9
	ld a,(de)		; $5bdb
	add (hl)		; $5bdc
	ld b,a			; $5bdd
	ld l,<w1Link.yh		; $5bde
	ld e,Interaction.yh		; $5be0
	jr +++			; $5be2

;;
; @addr{5be4}
_sidescrollPlatform_pushLinkAwayHorizontal:
	ld hl,w1Link.collisionRadiusX		; $5be4
	ld e,Interaction.collisionRadiusX		; $5be7
	ld a,(de)		; $5be9
	add (hl)		; $5bea
	ld b,a			; $5beb
	ld l,<w1Link.xh		; $5bec
	ld e,Interaction.xh		; $5bee
+++
	ld a,(de)		; $5bf0
	cp (hl)			; $5bf1
	jr c,++			; $5bf2
	ld a,b			; $5bf4
	cpl			; $5bf5
	inc a			; $5bf6
	ld b,a			; $5bf7
++
	ld a,(de)		; $5bf8
	add b			; $5bf9
	ld (hl),a		; $5bfa
	ret			; $5bfb

;;
; @addr{5bfc}
_sidescrollPlatformFunc_5bfc:
	call objectRunMovementScript		; $5bfc
	ld a,(wLinkRidingObject)		; $5bff
	cp d			; $5c02
	ret nz			; $5c03

;;
; @addr{5c04}
_sidescrollPlatform_updateLinkSubpixels:
	ld e,Interaction.y		; $5c04
	ld a,(de)		; $5c06
	ld (w1Link.y),a		; $5c07
	ld e,Interaction.x		; $5c0a
	ld a,(de)		; $5c0c
	ld (w1Link.x),a		; $5c0d
	ret			; $5c10

interactionCodea5:
	ld e,$44		; $5c11
	ld a,(de)		; $5c13
	rst_jumpTable			; $5c14
.dw $5c27
.dw $5c5e
.dw $5c69
.dw $5c83
.dw $5ca2
.dw $5cba
.dw $5cd0
.dw $5cde
.dw $5cf5
	ld a,$01		; $5c27
	ld (wMenuDisabled),a		; $5c29
	ld hl,$d02d		; $5c2c
	ld a,(hl)		; $5c2f
	or a			; $5c30
	ret nz			; $5c31
	ld a,$01		; $5c32
	ld (de),a		; $5c34
	call objectTakePosition		; $5c35
	ld bc,$3850		; $5c38
	call objectGetRelativeAngle		; $5c3b
	and $1c			; $5c3e
	ld e,$49		; $5c40
	ld (de),a		; $5c42
	ld bc,$ff00		; $5c43
	call objectSetSpeedZ		; $5c46
	ld l,$50		; $5c49
	ld (hl),$28		; $5c4b
	call interactionInitGraphics		; $5c4d
	call interactionSetAlwaysUpdateBit		; $5c50
	ld a,($d01a)		; $5c53
	ld e,$5a		; $5c56
	ld (de),a		; $5c58
	ld a,SND_GAINHEART		; $5c59
	jp playSound		; $5c5b
	ld c,$20		; $5c5e
	call objectUpdateSpeedZ_paramC		; $5c60
	jp nz,objectApplySpeed		; $5c63
	jp interactionIncState		; $5c66
	call $5d0e		; $5c69
	ret nz			; $5c6c
	ld a,$ff		; $5c6d
	ld ($d109),a		; $5c6f
	call interactionIncState		; $5c72
	call objectSetInvisible		; $5c75
	ld a,SND_GETSEED		; $5c78
	call playSound		; $5c7a
	ld bc,$070e		; $5c7d
	jp showText		; $5c80
	call retIfTextIsActive		; $5c83
	ld hl,w1Link.xh		; $5c86
	ldd a,(hl)		; $5c89
	ld b,$f0		; $5c8a
	cp $58			; $5c8c
	jr nc,_label_0b_196	; $5c8e
	ld b,$10		; $5c90
_label_0b_196:
	add b			; $5c92
	ld e,$4d		; $5c93
	ld (de),a		; $5c95
	dec l			; $5c96
	ld a,(hl)		; $5c97
	ld e,$4b		; $5c98
	ld (de),a		; $5c9a
	xor a			; $5c9b
	ld ($d109),a		; $5c9c
	jp interactionIncState		; $5c9f
	call $5d0e		; $5ca2
	ret nz			; $5ca5
	ld hl,$d109		; $5ca6
	ld a,$ff		; $5ca9
	ldd (hl),a		; $5cab
	ld a,(hl)		; $5cac
	xor $02			; $5cad
	dec h			; $5caf
	ld (hl),a		; $5cb0
	call interactionIncState		; $5cb1
	ld bc,$070f		; $5cb4
	jp showText		; $5cb7
	call retIfTextIsActive		; $5cba
	ld a,($d108)		; $5cbd
	xor $02			; $5cc0
	set 7,a			; $5cc2
	ld ($d108),a		; $5cc4
	call interactionIncState		; $5cc7
	ld bc,$0710		; $5cca
	jp showText		; $5ccd
	call retIfTextIsActive		; $5cd0
	ld a,($d108)		; $5cd3
	res 7,a			; $5cd6
	ld ($d108),a		; $5cd8
	jp interactionIncState		; $5cdb
	ld bc,$4109		; $5cde
	call createTreasure		; $5ce1
	ret nz			; $5ce4
	ld e,$46		; $5ce5
	ld a,$02		; $5ce7
	ld (de),a		; $5ce9
	push de			; $5cea
	ld de,w1Link.yh		; $5ceb
	call objectCopyPosition_rawAddress		; $5cee
	pop de			; $5cf1
	jp interactionIncState		; $5cf2
	ld e,$46		; $5cf5
	ld a,(de)		; $5cf7
	or a			; $5cf8
	jr z,_label_0b_197	; $5cf9
	dec a			; $5cfb
	ld (de),a		; $5cfc
	ret			; $5cfd
_label_0b_197:
	call retIfTextIsActive		; $5cfe
	ld a,$01		; $5d01
	ld (wDisabledObjects),a		; $5d03
	ld a,$02		; $5d06
	ld ($d105),a		; $5d08
	jp interactionDelete		; $5d0b
	ld hl,$d10b		; $5d0e
	ldi a,(hl)		; $5d11
	ld b,a			; $5d12
	inc l			; $5d13
	ld c,(hl)		; $5d14
	ld a,(wMapleState)		; $5d15
	and $20			; $5d18
	jr z,_label_0b_198	; $5d1a
	ld e,$4b		; $5d1c
	ld a,(de)		; $5d1e
	cp b			; $5d1f
	jr nz,_label_0b_198	; $5d20
	ld e,$4d		; $5d22
	ld a,(de)		; $5d24
	cp c			; $5d25
	ret z			; $5d26
_label_0b_198:
	call objectGetRelativeAngle		; $5d27
	xor $10			; $5d2a
	ld ($d109),a		; $5d2c
	or d			; $5d2f
	ret			; $5d30

interactionCodea6:
	ld e,$44		; $5d31
	ld a,(de)		; $5d33
	rst_jumpTable			; $5d34
.dw $5d39
.dw $5d60
	call interactionIncState		; $5d39
	ld a,PALH_ab		; $5d3c
	call loadPaletteHeader		; $5d3e
	call interactionInitGraphics		; $5d41
	ld hl,w1Link.yh		; $5d44
	ld b,(hl)		; $5d47
	ld l,$0d		; $5d48
	ld c,(hl)		; $5d4a
	call interactionSetPosition		; $5d4b
	ld l,$4f		; $5d4e
	ld (hl),$8b		; $5d50
	ld a,(wFrameCounter)		; $5d52
	cpl			; $5d55
	inc a			; $5d56
	ld e,$78		; $5d57
	ld (de),a		; $5d59
	call objectSetVisible82		; $5d5a
	call $5dbd		; $5d5d
	ld h,d			; $5d60
	ld l,$4f		; $5d61
	ldd a,(hl)		; $5d63
	cp $f3			; $5d64
	jr c,_label_0b_199	; $5d66
	ld a,$01		; $5d68
	ld ($cfc0),a		; $5d6a
	jp interactionDelete		; $5d6d
_label_0b_199:
	ld bc,$0080		; $5d70
	ld a,c			; $5d73
	add (hl)		; $5d74
	ldi (hl),a		; $5d75
	ld a,b			; $5d76
	adc (hl)		; $5d77
	ld (hl),a		; $5d78
	ld a,(wFrameCounter)		; $5d79
	ld l,$78		; $5d7c
	add (hl)		; $5d7e
	and $3f			; $5d7f
	ld a,SND_MAGIC_POWDER		; $5d81
	call z,playSound		; $5d83
	ret			; $5d86
	ld bc,$840b		; $5d87
	call objectCreateInteraction		; $5d8a
	ret nz			; $5d8d
	ld l,$46		; $5d8e
	ld (hl),$c2		; $5d90
	call objectCopyPosition		; $5d92
	call getRandomNumber		; $5d95
	and $07			; $5d98
	add a			; $5d9a
	ld bc,$5dad		; $5d9b
	call addAToBc		; $5d9e
	ld a,(bc)		; $5da1
	ld l,$4b		; $5da2
	add (hl)		; $5da4
	ld (hl),a		; $5da5
	inc bc			; $5da6
	ld a,(bc)		; $5da7
	ld l,$4d		; $5da8
	add (hl)		; $5daa
	ld (hl),a		; $5dab
	ret			; $5dac
	stop			; $5dad
	ld (bc),a		; $5dae
	stop			; $5daf
	cp $08			; $5db0
	dec b			; $5db2
	ld ($0cfb),sp		; $5db3
	ld ($f80c),sp		; $5db6
	ld b,$0b		; $5db9
	ld b,$f5		; $5dbb
	ld bc,$840f		; $5dbd
	call objectCreateInteraction		; $5dc0
	ret nz			; $5dc3
	ld l,$56		; $5dc4
	ld a,$40		; $5dc6
	ldi (hl),a		; $5dc8
	ld (hl),d		; $5dc9
	ret			; $5dca

interactionCodea7:
	ld e,$44		; $5dcb
	ld a,(de)		; $5dcd
	rst_jumpTable			; $5dce
.dw $5dd3
.dw $5e10
	ld a,$01		; $5dd3
	ld (de),a		; $5dd5
	call interactionInitGraphics		; $5dd6
	call objectSetVisible82		; $5dd9
	ld e,$42		; $5ddc
	ld a,(de)		; $5dde
	cp $02			; $5ddf
	ret nz			; $5de1
	ld a,(wChildStage)		; $5de2
	cp $04			; $5de5
	ret c			; $5de7
	ld a,$04		; $5de8
	call interactionSetAnimation		; $5dea
	call getFreeInteractionSlot		; $5ded
	ret nz			; $5df0
	ld (hl),$35		; $5df1
	inc l			; $5df3
	ld a,(wChildStage)		; $5df4
	ld b,$00		; $5df7
	cp $07			; $5df9
	jr c,_label_0b_200	; $5dfb
	ld b,$03		; $5dfd
_label_0b_200:
	ld a,(wChildPersonality)		; $5dff
	add b			; $5e02
	ldi (hl),a		; $5e03
	add $16			; $5e04
	ld (hl),a		; $5e06
	ld l,$4b		; $5e07
	ld (hl),$38		; $5e09
	inc l			; $5e0b
	inc l			; $5e0c
	ld (hl),$28		; $5e0d
	ret			; $5e0f
	ld e,$45		; $5e10
	ld a,(de)		; $5e12
	rst_jumpTable			; $5e13
.dw $5e1a
.dw $5e2c
.dw $5e3a
	ld a,($cfc0)		; $5e1a
	or a			; $5e1d
	jr z,_label_0b_201	; $5e1e
	call interactionIncState2		; $5e20
	ld bc,$ff00		; $5e23
	call objectSetSpeedZ		; $5e26
_label_0b_201:
	jp interactionAnimate		; $5e29
	ld c,$20		; $5e2c
	call objectUpdateSpeedZ_paramC		; $5e2e
	ret nz			; $5e31
	call interactionIncState2		; $5e32
	ld l,$46		; $5e35
	ld (hl),$0a		; $5e37
	ret			; $5e39
	call interactionDecCounter1		; $5e3a
	ret nz			; $5e3d
	ld a,$03		; $5e3e
	jp interactionSetAnimation		; $5e40

interactionCodea8:
	ld e,$42		; $5e43
	ld a,(de)		; $5e45
	and $0f			; $5e46
	rst_jumpTable			; $5e48
.dw $5e53
.dw $5e53
.dw $5e53
.dw $5e53
.dw $5e6d
	ld a,(de)		; $5e53
	and $0f			; $5e54
	add $0f			; $5e56
	ld b,a			; $5e58
	ld a,(de)		; $5e59
	swap a			; $5e5a
	and $0f			; $5e5c
	ld hl,$d100		; $5e5e
	ld (hl),$01		; $5e61
	inc l			; $5e63
	ld (hl),b		; $5e64
	inc l			; $5e65
	ld (hl),a		; $5e66
	call objectCopyPosition		; $5e67
	jp interactionDelete		; $5e6a
	ld hl,$d000		; $5e6d
	ld (hl),$03		; $5e70
	call objectCopyPosition		; $5e72
	call $5e7b		; $5e75
	jp interactionDelete		; $5e78
	ld e,$42		; $5e7b
	ld a,(de)		; $5e7d
	swap a			; $5e7e
	and $0f			; $5e80
	ld b,a			; $5e82
	rst_jumpTable			; $5e83
.dw $5ec7
.dw $5ec2
.dw $5e92
.dw $5e92
.dw $5e92
.dw $5e9b
.dw $5ebd
	ld a,b			; $5e92
	ld hl,$d001		; $5e93
	ld (hl),$08		; $5e96
	inc l			; $5e98
	ld (hl),a		; $5e99
	ret			; $5e9a
	ld a,d			; $5e9b
	ld (wLinkObjectIndex),a		; $5e9c
	ld hl,wActiveRing		; $5e9f
	ld (hl),$3d		; $5ea2
	xor a			; $5ea4
	ld l,$88		; $5ea5
	ldi (hl),a		; $5ea7
	ld (hl),a		; $5ea8
	ld hl,$5eea		; $5ea9
	ld a,$0b		; $5eac
_label_0b_202:
	push de			; $5eae
	call setSimulatedInputAddress		; $5eaf
	pop de			; $5eb2
	xor a			; $5eb3
	ld (wDisabledObjects),a		; $5eb4
	ld hl,$d001		; $5eb7
	ld (hl),$00		; $5eba
	ret			; $5ebc
	ld a,$09		; $5ebd
	jp $5e93		; $5ebf
	ld a,$0a		; $5ec2
	jp $5e93		; $5ec4
	ld hl,w1Link.direction		; $5ec7
	ld (hl),$02		; $5eca
	ld a,h			; $5ecc
	ld (wLinkObjectIndex),a		; $5ecd
	ld hl,wInventoryB		; $5ed0
	ld (hl),$05		; $5ed3
	inc l			; $5ed5
	ld (hl),$00		; $5ed6
	ld hl,$5f2b		; $5ed8
	ld a,$0b		; $5edb
	jr _label_0b_202		; $5edd
	inc a			; $5edf
	nop			; $5ee0
	nop			; $5ee1
	jr nz,_label_0b_203	; $5ee2
_label_0b_203:
	add b			; $5ee4
	jr nc,_label_0b_204	; $5ee5
_label_0b_204:
	nop			; $5ee7
	rst $38			; $5ee8
	rst $38			; $5ee9
	ld a,h			; $5eea
	nop			; $5eeb
	nop			; $5eec
	ld bc,$2000		; $5eed
	ld l,$00		; $5ef0
	nop			; $5ef2
	ld bc,$8000		; $5ef3
	ld l,$00		; $5ef6
	nop			; $5ef8
	ld bc,$1000		; $5ef9
	ld l,$00		; $5efc
	nop			; $5efe
	ld bc,$4000		; $5eff
	ld l,$00		; $5f02
	nop			; $5f04
	ld bc,$2000		; $5f05
	ld l,$00		; $5f08
	nop			; $5f0a
	ld bc,$8000		; $5f0b
	ld l,b			; $5f0e
	nop			; $5f0f
	nop			; $5f10
	ld bc,$4000		; $5f11
	jr c,_label_0b_205	; $5f14
_label_0b_205:
	nop			; $5f16
	ld bc,$1000		; $5f17
	ret nc			; $5f1a
	ld bc,$0100		; $5f1b
	nop			; $5f1e
	jr nz,-$60		; $5f1f
	nop			; $5f21
	nop			; $5f22
	ld bc,$0100		; $5f23
	jr nc,_label_0b_206	; $5f26
_label_0b_206:
	nop			; $5f28
	rst $38			; $5f29
	rst $38			; $5f2a
	inc a			; $5f2b
	nop			; $5f2c
	nop			; $5f2d
	ld bc,$2000		; $5f2e
	ldd a,(hl)		; $5f31
	nop			; $5f32
	ld (bc),a		; $5f33
	inc a			; $5f34
	nop			; $5f35
	nop			; $5f36
	ld bc,$1200		; $5f37
	inc d			; $5f3a
	nop			; $5f3b
	nop			; $5f3c
	ld bc,$8000		; $5f3d
	ld a,b			; $5f40
	nop			; $5f41
	ld (bc),a		; $5f42
	ldd (hl),a		; $5f43
	nop			; $5f44
	nop			; $5f45
	ld bc,$1000		; $5f46
	ld e,$00		; $5f49
	nop			; $5f4b
	rst $38			; $5f4c
	rst $38			; $5f4d

interactionCodea9:
	ld e,$44		; $5f4e
	ld a,(de)		; $5f50
	rst_jumpTable			; $5f51
.dw $5f58
.dw interactionAnimate
.dw $5fa3
	ld a,$01		; $5f58
	ld (de),a		; $5f5a
	ld e,$42		; $5f5b
	ld a,(de)		; $5f5d
	cp $06			; $5f5e
	call nc,interactionIncState		; $5f60
	call interactionInitGraphics		; $5f63
	call interactionSetAlwaysUpdateBit		; $5f66
	ld l,$42		; $5f69
	ld a,(hl)		; $5f6b
	ld b,a			; $5f6c
	cp $03			; $5f6d
	jr c,_label_0b_207	; $5f6f
	call getThisRoomFlags		; $5f71
	and $80			; $5f74
	jp nz,interactionDelete		; $5f76
	ld a,(de)		; $5f79
_label_0b_207:
	and $03			; $5f7a
	add a			; $5f7c
	add a			; $5f7d
	add a			; $5f7e
	ld l,$60		; $5f7f
	add (hl)		; $5f81
	ld (hl),a		; $5f82
	ld a,b			; $5f83
	ld hl,$5f91		; $5f84
	rst_addDoubleIndex			; $5f87
	ldi a,(hl)		; $5f88
	ld c,(hl)		; $5f89
	ld b,a			; $5f8a
	call interactionSetPosition		; $5f8b
	jp objectSetVisiblec2		; $5f8e
	ld b,b			; $5f91
	xor b			; $5f92
	ld b,b			; $5f93
	ld c,b			; $5f94
	stop			; $5f95
	ld a,b			; $5f96
	ld d,b			; $5f97
	xor b			; $5f98
	ld d,b			; $5f99
	ld c,b			; $5f9a
	jr nz,_label_0b_208	; $5f9b
	ld d,b			; $5f9d
	xor b			; $5f9e
	ld d,b			; $5f9f
	ld c,b			; $5fa0
	jr nz,_label_0b_209	; $5fa1
	call interactionAnimate		; $5fa3
	ld a,(wFrameCounter)		; $5fa6
	rrca			; $5fa9
	jp c,objectSetVisible		; $5faa
	jp objectSetInvisible		; $5fad

interactionCodeaa:
	ld e,$44		; $5fb0
	ld a,(de)		; $5fb2
	rst_jumpTable			; $5fb3
.dw $5fb8
.dw $5fd5
	ld a,$01		; $5fb8
	ld (de),a		; $5fba
	call interactionInitGraphics		; $5fbb
	call objectSetVisible82		; $5fbe
	ld e,$42		; $5fc1
	ld a,(de)		; $5fc3
	rst_jumpTable			; $5fc4
.dw $5fcb
.dw $5fcb
.dw $5fcc
	ret			; $5fcb
	call interactionSetAlwaysUpdateBit		; $5fcc
	ld bc,$4830		; $5fcf
	jp interactionSetPosition		; $5fd2
	ld e,$42		; $5fd5
	ld a,(de)		; $5fd7
	rst_jumpTable			; $5fd8
.dw $5fdf
.dw interactionAnimate
.dw interactionAnimate
	call $5fec		; $5fdf
	ld e,$4f		; $5fe2
	ld a,(de)		; $5fe4
	or a			; $5fe5
	jp nz,objectSetVisiblec2		; $5fe6
	jp objectSetVisible82		; $5fe9
	ld e,$45		; $5fec
	ld a,(de)		; $5fee
	rst_jumpTable			; $5fef
.dw $5ffa
.dw $6012
.dw $6026
.dw $603b
.dw interactionAnimate
	call interactionAnimate		; $5ffa
	ld a,($cfc0)		; $5ffd
	cp $04			; $6000
	ret nz			; $6002
	call interactionIncState2		; $6003
	ld l,$46		; $6006
	ld (hl),$78		; $6008
	ld a,$05		; $600a
	call interactionSetAnimation		; $600c
	jp $6061		; $600f
	call interactionDecCounter1		; $6012
_label_0b_208:
	jp nz,$605a		; $6015
	call interactionIncState2		; $6018
_label_0b_209:
	xor a			; $601b
	ld l,$4f		; $601c
	ld (hl),a		; $601e
	ld l,$46		; $601f
	ld (hl),$1e		; $6021
	jp interactionAnimate		; $6023
	call interactionDecCounter1		; $6026
	jr nz,_label_0b_210	; $6029
	call interactionIncState2		; $602b
	ld l,$46		; $602e
	ld (hl),$3c		; $6030
	ld bc,$3d09		; $6032
	call showText		; $6035
_label_0b_210:
	jp interactionAnimate		; $6038
	call interactionDecCounter1IfTextNotActive		; $603b
	jr nz,_label_0b_211	; $603e
	call interactionIncState2		; $6040
	ld hl,$cfc0		; $6043
	ld (hl),$05		; $6046
_label_0b_211:
	jp interactionAnimate		; $6048
	ld e,$42		; $604b
	ld a,(de)		; $604d
	ld hl,@scriptTable		; $604e
	rst_addDoubleIndex			; $6051
	ldi a,(hl)		; $6052
	ld h,(hl)		; $6053
	ld l,a			; $6054
	jp interactionSetScript		; $6055

; @addr{6058}
@scriptTable:
	.dw script7bdd

	ld c,$20		; $605a
	call objectUpdateSpeedZ_paramC		; $605c
	ret nz			; $605f
	ld h,d			; $6060
	ld bc,$ff00		; $6061
	jp objectSetSpeedZ		; $6064

interactionCodeab:
	ld e,$42		; $6067
	ld a,(de)		; $6069
	rst_jumpTable			; $606a
.dw $60a3
.dw $60a3
.dw $60a3
.dw $60a3
.dw $60a3
.dw $60a3
.dw $60a3
.dw $60a3
.dw $60a3
.dw $60a3
.dw $6110
.dw $6110
.dw $60e4
.dw $60e4
.dw $61f8
.dw $60a3
.dw $6186
.dw $6186
.dw $6186
.dw $6228
.dw $6228
.dw $6228
.dw $6228
.dw $6228
.dw $6228
.dw $6228
.dw $6228
.dw $6228
	call checkInteractionState		; $60a3
	jr z,_label_0b_212	; $60a6
	call $6267		; $60a8
	ld e,$42		; $60ab
	ld a,(de)		; $60ad
	add a			; $60ae
	add a			; $60af
	add b			; $60b0
	ld hl,_data_0b_6281		; $60b1
	rst_addAToHl			; $60b4
	ld e,$72		; $60b5
	ld a,(hl)		; $60b7
	ld (de),a		; $60b8
	call interactionRunScript		; $60b9
	jp npcFaceLinkAndAnimate		; $60bc
_label_0b_212:
	call $6267		; $60bf
	ld a,b			; $60c2
	or a			; $60c3
	ld e,$42		; $60c4
	ld a,(de)		; $60c6
	jr nz,_label_0b_213	; $60c7
	cp $06			; $60c9
	jp nc,interactionDelete		; $60cb
_label_0b_213:
	ld hl,genericNpcScript		; $60ce
_label_0b_214:
	call interactionSetScript		; $60d1
	call interactionInitGraphics		; $60d4
	call interactionSetAlwaysUpdateBit		; $60d7
	call interactionIncState		; $60da
	ld l,$73		; $60dd
	ld (hl),$34		; $60df
	jp objectSetVisiblec2		; $60e1
	call checkInteractionState		; $60e4
	jr z,_label_0b_217	; $60e7
	ld c,$20		; $60e9
	call objectUpdateSpeedZ_paramC		; $60eb
	ret nz			; $60ee
	call interactionRunScript		; $60ef
	jr nc,_label_0b_216	; $60f2
	ld hl,$cfc0		; $60f4
_label_0b_215:
	set 7,(hl)		; $60f7
_label_0b_216:
	jp interactionAnimate		; $60f9
_label_0b_217:
	ld e,$50		; $60fc
	ld a,$3c		; $60fe
	ld (de),a		; $6100
_label_0b_218:
	ld e,$42		; $6101
_label_0b_219:
	ld a,(de)		; $6103
	cp $0c			; $6104
	ld hl,script7bf2		; $6106
	jr z,_label_0b_214	; $6109
	ld hl,script7c0a		; $610b
	jr _label_0b_214		; $610e
	ld e,$44		; $6110
	ld a,(de)		; $6112
	rst_jumpTable			; $6113
.dw $611c
.dw $612d
.dw $6138
.dw $616e
	call $60d4		; $611c
	ld l,$46		; $611f
	ld (hl),$1e		; $6121
	ld l,$42		; $6123
	ldi a,(hl)		; $6125
	sub $0a			; $6126
	swap a			; $6128
	rrca			; $612a
	ld (hl),a		; $612b
	ret			; $612c
	call interactionDecCounter1		; $612d
	ret nz			; $6130
	ld (hl),$78		; $6131
	inc l			; $6133
	inc (hl)		; $6134
	jp interactionIncState		; $6135
	call interactionDecCounter1		; $6138
	jr nz,_label_0b_220	; $613b
	ld (hl),$5a		; $613d
	ld a,$02		; $613f
	call interactionSetAnimation		; $6141
	jp interactionIncState		; $6144
_label_0b_220:
	inc l			; $6147
	dec (hl)		; $6148
	ret nz			; $6149
	ld (hl),$14		; $614a
	ld l,$78		; $614c
	ld a,(hl)		; $614e
	inc a			; $614f
	and $07			; $6150
	ld (hl),a		; $6152
	ld l,$43		; $6153
	add (hl)		; $6155
	ld hl,$615e		; $6156
	rst_addAToHl			; $6159
	ld a,(hl)		; $615a
	jp interactionSetAnimation		; $615b
	nop			; $615e
	inc bc			; $615f
	ld bc,$0002		; $6160
	ld bc,$0203		; $6163
	inc bc			; $6166
	ld bc,$0003		; $6167
	inc bc			; $616a
	ld (bc),a		; $616b
	nop			; $616c
	ld bc,$cccd		; $616d
	inc hl			; $6170
	jr nz,_label_0b_221	; $6171
	ld hl,$cfc0		; $6173
	set 7,(hl)		; $6176
_label_0b_221:
	ld c,$20		; $6178
	call objectUpdateSpeedZ_paramC		; $617a
	ret nz			; $617d
	ld l,$54		; $617e
	ld a,$80		; $6180
	ldi (hl),a		; $6182
	ld (hl),$fe		; $6183
	ret			; $6185
	ld e,$44		; $6186
	ld a,(de)		; $6188
	rst_jumpTable			; $6189
.dw $6190
.dw $61e6
.dw $61ef
	call interactionInitGraphics		; $6190
	call objectSetVisible82		; $6193
	call interactionIncState		; $6196
	ld e,$42		; $6199
	ld a,(de)		; $619b
	sub $10			; $619c
	ld b,a			; $619e
	ld hl,scriptTable61e0		; $619f
	rst_addDoubleIndex			; $61a2
	ldi a,(hl)		; $61a3
	ld h,(hl)		; $61a4
	ld l,a			; $61a5
	call interactionSetScript		; $61a6
	ld a,b			; $61a9
	rst_jumpTable			; $61aa
.dw $61b1
.dw $61c9
.dw $61d1
	call getThisRoomFlags		; $61b1
	and $20			; $61b4
	jp nz,interactionDelete		; $61b6
	ld a,(wEssencesObtained)		; $61b9
	bit 6,a			; $61bc
	jp z,interactionDelete		; $61be
	ld a,$03		; $61c1
	call interactionSetAnimation		; $61c3
	jp interactionIncState		; $61c6
	call checkIsLinkedGame		; $61c9
	jp nz,interactionDelete		; $61cc
	jr _label_0b_222		; $61cf
	call checkIsLinkedGame		; $61d1
	jp z,interactionDelete		; $61d4
_label_0b_222:
	call getThisRoomFlags		; $61d7
	and $40			; $61da
	jp nz,interactionDelete		; $61dc
	ret			; $61df

; @addr{61e0}
scriptTable61e0:
	.dw script7c29
	.dw script7c4e
	.dw script7c4e

	call interactionRunScript		; $61e6
	jp c,interactionDelete		; $61e9
	jp npcFaceLinkAndAnimate		; $61ec
	call interactionRunScript		; $61ef
	jp c,interactionDelete		; $61f2
	jp interactionAnimate		; $61f5
	call checkInteractionState		; $61f8
	jr z,_label_0b_223	; $61fb
	call interactionRunScript		; $61fd
	jp interactionAnimateAsNpc		; $6200
_label_0b_223:
	call interactionInitGraphics		; $6203
	call interactionIncState		; $6206
	ld l,$73		; $6209
	ld (hl),$34		; $620b
	ld a,GLOBALFLAG_WATER_POLLUTION_FIXED		; $620d
	call checkGlobalFlag		; $620f
	ld a,$33		; $6212
	jr z,_label_0b_224	; $6214
	ld a,$34		; $6216
_label_0b_224:
	ld e,$72		; $6218
	ld (de),a		; $621a
	xor a			; $621b
	call interactionSetAnimation		; $621c
	call objectSetVisiblec2		; $621f
	ld hl,script7c21		; $6222
	jp interactionSetScript		; $6225
	call checkInteractionState		; $6228
	jr z,_label_0b_225	; $622b
	call interactionRunScript		; $622d
	jp npcFaceLinkAndAnimate		; $6230
_label_0b_225:
	call $60d4		; $6233
	ld a,GLOBALFLAG_WATER_POLLUTION_FIXED		; $6236
	call checkGlobalFlag		; $6238
	ld b,$00		; $623b
	jr z,_label_0b_226	; $623d
	inc b			; $623f
_label_0b_226:
	ld e,$42		; $6240
	ld a,(de)		; $6242
	sub $13			; $6243
	add a			; $6245
	add b			; $6246
	ld hl,$6255		; $6247
	rst_addAToHl			; $624a
	ld e,$72		; $624b
	ld a,(hl)		; $624d
	ld (de),a		; $624e
	ld hl,genericNpcScript		; $624f
	jp interactionSetScript		; $6252
	ld b,a			; $6255
	ld c,b			; $6256
	ld c,c			; $6257
	ld c,d			; $6258
	ld c,e			; $6259
	ld c,h			; $625a
	ld b,(hl)		; $625b
	ld b,(hl)		; $625c
	ld b,b			; $625d
	ld b,c			; $625e
	ld b,d			; $625f
	ld b,e			; $6260
	ld b,h			; $6261
	ld b,l			; $6262
	ld c,l			; $6263
	ld c,l			; $6264
	ld c,(hl)		; $6265
	ld c,(hl)		; $6266
	ld a,GLOBALFLAG_KING_ZORA_CURED		; $6267
	call checkGlobalFlag		; $6269
	ld b,$00		; $626c
	ret z			; $626e
	ld a,GLOBALFLAG_WATER_POLLUTION_FIXED		; $626f
	call checkGlobalFlag		; $6271
	ld b,$01		; $6274
	ret z			; $6276
	ld a,(wEssencesObtained)		; $6277
	bit 6,a			; $627a
	ld b,$02		; $627c
	ret nc			; $627e
	inc b			; $627f
	ret			; $6280

_data_0b_6281:
	.db $10 $11 $12 $12 $13 $14 $14 $14
	.db $15 $16 $16 $16 $17 $18 $19 $19
	.db $1a $1b $1b $1b $20 $21 $22 $23
	.db $24 $24 $24 $24 $25 $25 $26 $26
	.db $27 $27 $27 $27 $28 $28 $29 $29

interactionCodead:
	ld e,$44		; $62a9
	ld a,(de)		; $62ab
	rst_jumpTable			; $62ac
.dw $62b1
.dw $6381
	ld a,$01		; $62b1
	ld (de),a		; $62b3
	call interactionInitGraphics		; $62b4
	call objectSetVisiblec2		; $62b7
	ld e,$42		; $62ba
	ld a,(de)		; $62bc
	rst_jumpTable			; $62bd
.dw $6360
.dw $637e
.dw $637e
.dw $62f6
.dw $62d4
.dw $637b
.dw $637e
.dw $6304
.dw $632c
.dw $637e
.dw $6346
	call checkIsLinkedGame		; $62d4
	jp z,interactionDeleteAndUnmarkSolidPosition		; $62d7
	ld a,TREASURE_MAKU_SEED		; $62da
	call checkTreasureObtained		; $62dc
	jp nc,interactionDeleteAndUnmarkSolidPosition		; $62df
	ld a,GLOBALFLAG_PRE_BLACK_TOWER_CUTSCENE_DONE		; $62e2
	call checkGlobalFlag		; $62e4
	jp nz,interactionDeleteAndUnmarkSolidPosition		; $62e7
	ld h,d			; $62ea
	ld l,$50		; $62eb
	ld (hl),$28		; $62ed
	ld l,$49		; $62ef
	ld (hl),$08		; $62f1
	jp $637e		; $62f3
	ld bc,$4820		; $62f6
	call interactionSetPosition		; $62f9
	ld a,$01		; $62fc
	call interactionSetAnimation		; $62fe
	jp $637e		; $6301
	ld a,GLOBALFLAG_GOT_RING_FROM_ZELDA		; $6304
	call checkGlobalFlag		; $6306
	jp z,interactionDeleteAndUnmarkSolidPosition		; $6309
	ld a,TREASURE_MAKU_SEED		; $630c
	call checkTreasureObtained		; $630e
	jp c,interactionDeleteAndUnmarkSolidPosition		; $6311
	ld a,GLOBALFLAG_SAVED_NAYRU		; $6314
	call checkGlobalFlag		; $6316
	ld a,$06		; $6319
	jr nz,_label_0b_229	; $631b
	ld a,$05		; $631d
_label_0b_229:
	ld e,$72		; $631f
	ld (de),a		; $6321
	inc e			; $6322
	ld a,$06		; $6323
	ld (de),a		; $6325
	ld hl,genericNpcScript		; $6326
	jp interactionSetScript		; $6329
	call checkIsLinkedGame		; $632c
	jp z,interactionDeleteAndUnmarkSolidPosition		; $632f
	ld a,GLOBALFLAG_PRE_BLACK_TOWER_CUTSCENE_DONE		; $6332
	call checkGlobalFlag		; $6334
	jp z,interactionDeleteAndUnmarkSolidPosition		; $6337
	ld a,GLOBALFLAG_FLAME_OF_DESPAIR_LIT		; $633a
	call checkGlobalFlag		; $633c
	jp nz,interactionDeleteAndUnmarkSolidPosition		; $633f
	ld a,$0b		; $6342
	jr _label_0b_229		; $6344
	call checkIsLinkedGame		; $6346
	jp z,interactionDeleteAndUnmarkSolidPosition		; $6349
	ld a,TREASURE_MAKU_SEED		; $634c
	call checkTreasureObtained		; $634e
	jp nc,interactionDeleteAndUnmarkSolidPosition		; $6351
	ld a,GLOBALFLAG_PRE_BLACK_TOWER_CUTSCENE_DONE		; $6354
	call checkGlobalFlag		; $6356
	jp nz,interactionDeleteAndUnmarkSolidPosition		; $6359
	ld a,$0a		; $635c
	jr _label_0b_229		; $635e
	call getThisRoomFlags		; $6360
	bit 7,a			; $6363
	jr z,_label_0b_230	; $6365
	ld a,$01		; $6367
	ld (wDisableScreenTransitions),a		; $6369
	ld a,(wActiveMusic)		; $636c
	or a			; $636f
	jr z,_label_0b_230	; $6370
	xor a			; $6372
	ld (wActiveMusic),a		; $6373
	ld a,MUS_ZELDA_SAVED		; $6376
	call playSound		; $6378
_label_0b_230:
	call interactionLoadExtraGraphics		; $637b
	call $63ba		; $637e
	ld e,$42		; $6381
	ld a,(de)		; $6383
	rst_jumpTable			; $6384
.dw $639b
.dw $639b
.dw $63a1
.dw $639b
.dw $63ab
.dw $639b
.dw $639b
.dw $63b4
.dw $63b4
.dw $639b
.dw $63b4
	call interactionAnimate		; $639b
	jp interactionRunScript		; $639e
	ld e,$79		; $63a1
	ld a,(de)		; $63a3
	or a			; $63a4
	call z,interactionAnimate		; $63a5
	jp interactionRunScript		; $63a8
	call interactionRunScript		; $63ab
	jp nc,interactionAnimateBasedOnSpeed		; $63ae
	jp interactionDeleteAndUnmarkSolidPosition		; $63b1
	call interactionRunScript		; $63b4
	jp npcFaceLinkAndAnimate		; $63b7
	ld e,$42		; $63ba
	ld a,(de)		; $63bc
	ld hl,@scriptTable		; $63bd
	rst_addDoubleIndex			; $63c0
	ldi a,(hl)		; $63c1
	ld h,(hl)		; $63c2
	ld l,a			; $63c3
	jp interactionSetScript		; $63c4

; @addr{63c7}
@scriptTable:
	.dw script7c86
	.dw script7c9b
	.dw script7c9f
	.dw script7ca3
	.dw script7ca7
	.dw script7ce2
	.dw script7ce6
	.dw stubScript
	.dw stubScript
	.dw script7d17
	.dw stubScript

interactionCodeae:
	ld e,$44		; $63dd
	ld a,(de)		; $63df
	rst_jumpTable			; $63e0
.dw $63e5
.dw $6434
	ld a,$01		; $63e5
	ld (de),a		; $63e7
	ld e,$43		; $63e8
	ld a,(de)		; $63ea
	or a			; $63eb
	jr nz,_label_0b_231	; $63ec
	ld h,d			; $63ee
	ld l,$42		; $63ef
	ld a,(hl)		; $63f1
	ld hl,$65c1		; $63f2
	rst_addDoubleIndex			; $63f5
	ldi a,(hl)		; $63f6
	ld h,(hl)		; $63f7
	ld l,a			; $63f8
	call $6559		; $63f9
	ld e,$42		; $63fc
	ld a,(de)		; $63fe
	ld hl,$65b1		; $63ff
	rst_addDoubleIndex			; $6402
	ldi a,(hl)		; $6403
	ld e,$72		; $6404
	ld (de),a		; $6406
	ldi a,(hl)		; $6407
	ld e,$47		; $6408
	ld (de),a		; $640a
	ret			; $640b
_label_0b_231:
	call interactionInitGraphics		; $640c
	ld h,d			; $640f
	ld l,$70		; $6410
	ld (hl),$14		; $6412
	ld l,$50		; $6414
	ld (hl),$50		; $6416
	ld l,$47		; $6418
	ld a,(hl)		; $641a
	call interactionSetAnimation		; $641b
	ld h,d			; $641e
	ld l,$42		; $641f
	ld a,(hl)		; $6421
	or a			; $6422
	ld bc,$f018		; $6423
	jr z,_label_0b_232	; $6426
	ld bc,$0008		; $6428
_label_0b_232:
	ld l,$4d		; $642b
	ld (hl),b		; $642d
	ld l,$49		; $642e
	ld (hl),c		; $6430
	jp objectSetVisible82		; $6431
	ld a,$01		; $6434
	ld (de),a		; $6436
	ld e,$43		; $6437
	ld a,(de)		; $6439
	or a			; $643a
	jp nz,$657b		; $643b
	ld a,(wPaletteThread_mode)		; $643e
	or a			; $6441
	ret nz			; $6442
	ld e,$45		; $6443
	ld a,(de)		; $6445
	rst_jumpTable			; $6446
.dw $644d
.dw $646c
.dw $652b
	ld h,d			; $644d
	ld l,$70		; $644e
	call decHlRef16WithCap		; $6450
	ret nz			; $6453
	call $6537		; $6454
	ld e,$70		; $6457
	ld a,(de)		; $6459
	rlca			; $645a
	ret nc			; $645b
	ld b,$01		; $645c
	rlca			; $645e
	jr nc,_label_0b_233	; $645f
	ld b,$02		; $6461
_label_0b_233:
	ld h,d			; $6463
	ld l,$46		; $6464
	ld (hl),$b4		; $6466
	ld l,$45		; $6468
	ld (hl),b		; $646a
	ret			; $646b
	ld e,$73		; $646c
	ld a,(de)		; $646e
	rst_jumpTable			; $646f
.dw $6478
.dw $6481
.dw $64cf
.dw $64db
	call interactionDecCounter1		; $6478
	ret nz			; $647b
	ld h,d			; $647c
	ld l,$73		; $647d
	inc (hl)		; $647f
	ret			; $6480
	ld a,(wFrameCounter)		; $6481
	and $03			; $6484
	ret nz			; $6486
	ld h,d			; $6487
	ld l,$46		; $6488
	ld a,(hl)		; $648a
	cp $10			; $648b
	jr nz,_label_0b_234	; $648d
	ld l,$73		; $648f
	inc (hl)		; $6491
	ld l,$58		; $6492
	ld a,(hl)		; $6494
	sub $03			; $6495
	ldi (hl),a		; $6497
	ld a,(hl)		; $6498
	sbc $00			; $6499
	ld (hl),a		; $649b
	call $6554		; $649c
	ld h,d			; $649f
	ld l,$46		; $64a0
	ld (hl),$1e		; $64a2
	ret			; $64a4
_label_0b_234:
	ld a,($ff00+R_SVBK)	; $64a5
	push af			; $64a7
	ld l,$46		; $64a8
	ld a,(hl)		; $64aa
	ld b,a			; $64ab
	ld a,$04		; $64ac
	ld ($ff00+R_SVBK),a	; $64ae
	ld a,b			; $64b0
	ld hl,$d000		; $64b1
	rst_addDoubleIndex			; $64b4
	ld b,$30		; $64b5
_label_0b_235:
	xor a			; $64b7
	ldi (hl),a		; $64b8
	ld (hl),a		; $64b9
	ld a,$1f		; $64ba
	rst_addAToHl			; $64bc
	dec b			; $64bd
	jr nz,_label_0b_235	; $64be
	push de			; $64c0
	ld a,UNCMP_GFXH_09		; $64c1
	call loadUncompressedGfxHeader		; $64c3
	pop de			; $64c6
	pop af			; $64c7
	ld ($ff00+R_SVBK),a	; $64c8
	ld h,d			; $64ca
	ld l,$46		; $64cb
	inc (hl)		; $64cd
	ret			; $64ce
	call interactionDecCounter1		; $64cf
	ret nz			; $64d2
	ld l,$73		; $64d3
	inc (hl)		; $64d5
	ld l,$46		; $64d6
	ld (hl),$10		; $64d8
	ret			; $64da
	ld a,(wFrameCounter)		; $64db
	and $03			; $64de
	ret nz			; $64e0
	call interactionDecCounter1		; $64e1
	jr nz,_label_0b_236	; $64e4
	xor a			; $64e6
	ld l,$45		; $64e7
	ld (hl),a		; $64e9
	ld l,$73		; $64ea
	ld (hl),a		; $64ec
	jp $6457		; $64ed
_label_0b_236:
	push de			; $64f0
	ld a,($ff00+R_SVBK)	; $64f1
	push af			; $64f3
	ld a,(hl)		; $64f4
	ld b,a			; $64f5
	ld a,b			; $64f6
	ld hl,$d000		; $64f7
	rst_addDoubleIndex			; $64fa
	ld a,b			; $64fb
	ld de,$d800		; $64fc
	call addDoubleIndexToDe		; $64ff
	ld b,$30		; $6502
_label_0b_237:
	push bc			; $6504
	ld a,$03		; $6505
	ld ($ff00+R_SVBK),a	; $6507
	ld a,(de)		; $6509
	ld b,a			; $650a
	inc de			; $650b
	ld a,(de)		; $650c
	ld c,a			; $650d
	ld a,$04		; $650e
	ld ($ff00+R_SVBK),a	; $6510
	ld (hl),b		; $6512
	inc hl			; $6513
	ld (hl),c		; $6514
	ld a,$1f		; $6515
	ld c,a			; $6517
	rst_addAToHl			; $6518
	ld a,c			; $6519
	call addAToDe		; $651a
	pop bc			; $651d
	dec b			; $651e
	jr nz,_label_0b_237	; $651f
	ld a,UNCMP_GFXH_09		; $6521
	call loadUncompressedGfxHeader		; $6523
	pop af			; $6526
	ld ($ff00+R_SVBK),a	; $6527
	pop de			; $6529
	ret			; $652a
	call interactionDecCounter1		; $652b
	ret nz			; $652e
	ld hl,$cfdf		; $652f
	ld (hl),$ff		; $6532
	jp interactionDelete		; $6534
	call getFreeInteractionSlot		; $6537
	jr nz,_label_0b_238	; $653a
	ld (hl),$ae		; $653c
	inc l			; $653e
	ld e,$72		; $653f
	ld a,(de)		; $6541
	ldi (hl),a		; $6542
	ld (hl),$01		; $6543
	ld l,$46		; $6545
	ld e,l			; $6547
	ld a,(de)		; $6548
	inc e			; $6549
	ldi (hl),a		; $654a
	ld a,(de)		; $654b
	ld (hl),a		; $654c
	call objectCopyPosition		; $654d
_label_0b_238:
	ld h,d			; $6550
	ld l,$47		; $6551
	inc (hl)		; $6553
	ld l,$58		; $6554
	ldi a,(hl)		; $6556
	ld h,(hl)		; $6557
	ld l,a			; $6558
	ldi a,(hl)		; $6559
	ld e,$70		; $655a
	ld (de),a		; $655c
	inc e			; $655d
	ldi a,(hl)		; $655e
	ld (de),a		; $655f
	ldi a,(hl)		; $6560
	ld e,$46		; $6561
	ld (de),a		; $6563
	ldi a,(hl)		; $6564
	ld e,$4b		; $6565
	ld (de),a		; $6567
	ld e,$58		; $6568
	ld a,l			; $656a
	ld (de),a		; $656b
	inc e			; $656c
	ld a,h			; $656d
	ld (de),a		; $656e
	ld e,$71		; $656f
	ld a,(de)		; $6571
	or a			; $6572
	ret nz			; $6573
	dec e			; $6574
	ld a,(de)		; $6575
	or a			; $6576
	ret nz			; $6577
	jp $6537		; $6578
	ld a,(wPaletteThread_mode)		; $657b
	or a			; $657e
	ret nz			; $657f
	ld e,$45		; $6580
	ld a,(de)		; $6582
	rst_jumpTable			; $6583
.dw $6588
.dw $65a5
	ld h,d			; $6588
	ld l,$70		; $6589
	dec (hl)		; $658b
	jr nz,_label_0b_240	; $658c
	call interactionIncState2		; $658e
	ld b,$a0		; $6591
	ld l,$42		; $6593
	ld a,(hl)		; $6595
	or a			; $6596
	jr z,_label_0b_239	; $6597
	ld b,$50		; $6599
_label_0b_239:
	ld l,$4d		; $659b
	ld (hl),b		; $659d
	ret			; $659e
_label_0b_240:
	call objectApplySpeed		; $659f
	jp objectApplySpeed		; $65a2
	ld e,$46		; $65a5
	ld a,(de)		; $65a7
	inc a			; $65a8
	ret z			; $65a9
	call interactionDecCounter1		; $65aa
	jp z,interactionDelete		; $65ad
	ret			; $65b0
	nop			; $65b1
	nop			; $65b2
	ld bc,$0004		; $65b3
	dec bc			; $65b6
	ld bc,$0013		; $65b7
	nop			; $65ba
	ld bc,$0004		; $65bb
	dec bc			; $65be
	ld bc,$d113		; $65bf
	ld h,l			; $65c2
	ld ($ff00+c),a		; $65c3
	ld h,l			; $65c4
	nop			; $65c5
	ld h,(hl)		; $65c6
	ldi (hl),a		; $65c7
	ld h,(hl)		; $65c8
	pop de			; $65c9
	ld h,l			; $65ca
	ld ($ff00+c),a		; $65cb
	ld h,l			; $65cc
	nop			; $65cd
	ld h,(hl)		; $65ce
	ldi (hl),a		; $65cf
	ld h,(hl)		; $65d0
	jr nz,_label_0b_241	; $65d1
_label_0b_241:
	rst $38			; $65d3
	ld hl,sp+$30		; $65d4
	nop			; $65d6
	ld a,($ff00+R_NR23)	; $65d7
	jr nz,_label_0b_242	; $65d9
_label_0b_242:
	ld a,($ff00+$38)	; $65db
	jr nz,_label_0b_243	; $65dd
_label_0b_243:
	ld a,($ff00+$50)	; $65df
	rst $38			; $65e1
	jr nz,_label_0b_244	; $65e2
_label_0b_244:
	rst $38			; $65e4
	ld hl,sp+$20		; $65e5
	nop			; $65e7
	ld hl,sp+$18		; $65e8
	stop			; $65ea
	nop			; $65eb
	add sp,$38		; $65ec
	stop			; $65ee
	nop			; $65ef
	ret c			; $65f0
	ld e,b			; $65f1
	add b			; $65f2
	nop			; $65f3
	nop			; $65f4
	rst $38			; $65f5
	stop			; $65f6
	nop			; $65f7
	nop			; $65f8
	rst $38			; $65f9
	jr z,_label_0b_245	; $65fa
_label_0b_245:
	nop			; $65fc
	rst $38			; $65fd
	ld d,b			; $65fe
	rst $38			; $65ff
	jr nz,_label_0b_246	; $6600
_label_0b_246:
	cp $f8			; $6602
	stop			; $6604
	nop			; $6605
	add sp,$18		; $6606
	ld a,(bc)		; $6608
	nop			; $6609
	ret c			; $660a
	jr c,_label_0b_247	; $660b
	nop			; $660d
	ret z			; $660e
	ld e,b			; $660f
	add b			; $6610
	nop			; $6611
	nop			; $6612
	rst $38			; $6613
	ld hl,sp+$00		; $6614
	nop			; $6616
_label_0b_247:
	rst $38			; $6617
	jr _label_0b_248		; $6618
_label_0b_248:
	nop			; $661a
	rst $38			; $661b
	jr c,_label_0b_249	; $661c
_label_0b_249:
	nop			; $661e
	rst $38			; $661f
	ld e,b			; $6620
	rst $38			; $6621
	jr nz,_label_0b_250	; $6622
_label_0b_250:
	ld hl,sp-$08		; $6624
	jr nz,_label_0b_251	; $6626
_label_0b_251:
	ret c			; $6628
	jr _label_0b_252		; $6629
_label_0b_252:
	nop			; $662b
	ret c			; $662c
	jr c,_label_0b_253	; $662d
_label_0b_253:
	nop			; $662f
	ret c			; $6630
	ld e,b			; $6631
	add b			; $6632
	nop			; $6633
	nop			; $6634
	rst $38			; $6635
	ld hl,sp+$00		; $6636
	nop			; $6638
	rst $38			; $6639
	jr _label_0b_254		; $663a
_label_0b_254:
	nop			; $663c
	rst $38			; $663d
	jr c,_label_0b_255	; $663e
_label_0b_255:
	nop			; $6640
	rst $38			; $6641
	ld e,b			; $6642
	rst $38			; $6643

interactionCodeaf:
	ld e,$44		; $6644
	ld a,(de)		; $6646
	rst_jumpTable			; $6647
.dw $664c
.dw $6661
	ld a,$01		; $664c
	ld (de),a		; $664e
	ld e,$42		; $664f
	ld a,(de)		; $6651
	or a			; $6652
	jr nz,_label_0b_256	; $6653
	ld hl,$66bc		; $6655
	jp $669e		; $6658
_label_0b_256:
	ld h,d			; $665b
	ld l,$50		; $665c
	ld (hl),$14		; $665e
	ret			; $6660
	ld e,$42		; $6661
	ld a,(de)		; $6663
	or a			; $6664
	jr nz,_label_0b_258	; $6665
	ld a,(wPaletteThread_mode)		; $6667
	or a			; $666a
	ret nz			; $666b
	ld h,d			; $666c
	ld l,$70		; $666d
	call decHlRef16WithCap		; $666f
	ret nz			; $6672
	call $6683		; $6673
	ld e,$70		; $6676
	ld a,(de)		; $6678
	inc a			; $6679
	ret nz			; $667a
	ld hl,$cfdf		; $667b
	ld (hl),$ff		; $667e
	jp interactionDelete		; $6680
	call getFreeInteractionSlot		; $6683
	jr nz,_label_0b_257	; $6686
	ld (hl),$af		; $6688
	inc l			; $668a
	ld (hl),$01		; $668b
	inc l			; $668d
	ld e,$46		; $668e
	ld a,(de)		; $6690
	ld (hl),a		; $6691
	call objectCopyPosition		; $6692
_label_0b_257:
	ld h,d			; $6695
	ld l,$46		; $6696
	inc (hl)		; $6698
	ld a,(hl)		; $6699
	ld hl,$66bc		; $669a
	rst_addDoubleIndex			; $669d
	ldi a,(hl)		; $669e
	ld e,$70		; $669f
	ld (de),a		; $66a1
	inc e			; $66a2
	ldi a,(hl)		; $66a3
	ld (de),a		; $66a4
	ret			; $66a5
_label_0b_258:
	ld a,(wPaletteThread_mode)		; $66a6
	or a			; $66a9
	ret nz			; $66aa
	call objectApplySpeed		; $66ab
	ld h,d			; $66ae
	ld l,$4b		; $66af
	ldi a,(hl)		; $66b1
	ld b,a			; $66b2
	or a			; $66b3
	jp z,interactionDelete		; $66b4
	inc l			; $66b7
	ld c,(hl)		; $66b8
	jp interactionFunc_3e6d		; $66b9
	jr nz,_label_0b_259	; $66bc
_label_0b_259:
	ld ($ff00+R_P1),a	; $66be
	jr nz,_label_0b_260	; $66c0
	stop			; $66c2
_label_0b_260:
	ld bc,$00f0		; $66c3
	ld h,b			; $66c6
	ld bc,$00f0		; $66c7
	jr nz,_label_0b_261	; $66ca
	ld (hl),b		; $66cc
_label_0b_261:
	ld bc,$0150		; $66cd
	ld h,b			; $66d0
	ld bc,$0140		; $66d1
	ld b,b			; $66d4
	ld bc,$0160		; $66d5
	stop			; $66d8
	ld bc,$0160		; $66d9
	and b			; $66dc
	.db $01 $ff		; $66dd

interactionCodeb0:
	ld e,$44		; $66df
	ld a,(de)		; $66e1
	rst_jumpTable			; $66e2
.dw $66e7
.dw $6724
	ld a,$01		; $66e7
	ld (de),a		; $66e9
	call interactionInitGraphics		; $66ea
	call objectSetVisiblec2		; $66ed
	ld a,$28		; $66f0
	call interactionSetHighTextIndex		; $66f2
	ld e,$42		; $66f5
	ld a,(de)		; $66f7
	rst_jumpTable			; $66f8
.dw $6701
.dw $6708
.dw $6713
.dw $6717
	ld a,$01		; $6701
	call $670a		; $6703
	jr _label_0b_264		; $6706
	ld a,$02		; $6708
	ld e,$5c		; $670a
	ld (de),a		; $670c
	ld e,$42		; $670d
	ld a,(de)		; $670f
	jp interactionSetAnimation		; $6710
	ld a,$01		; $6713
	jr _label_0b_262		; $6715
	ld a,$01		; $6717
	call interactionSetAnimation		; $6719
	ld a,$02		; $671c
_label_0b_262:
	ld e,$5c		; $671e
	ld (de),a		; $6720
	jp interactionSetAlwaysUpdateBit		; $6721
	ld e,$42		; $6724
	ld a,(de)		; $6726
	rst_jumpTable			; $6727
.dw $6730
.dw interactionAnimate
.dw interactionAnimate
.dw interactionAnimate
	call checkInteractionState2		; $6730
	jr nz,_label_0b_263	; $6733
	call interactionAnimate		; $6735
	call interactionRunScript		; $6738
	ret nc			; $673b
	ld a,SND_LIGHTNING		; $673c
	call playSound		; $673e
	xor a			; $6741
	ld (wTmpcbb3),a		; $6742
	dec a			; $6745
	ld (wTmpcbba),a		; $6746
	jp interactionIncState2		; $6749
_label_0b_263:
	ld hl,wTmpcbb3		; $674c
	ld b,$02		; $674f
	call flashScreen		; $6751
	ret z			; $6754
	ld a,$02		; $6755
	ld ($cbb8),a		; $6757
	ld a,$08		; $675a
	ld (wCutsceneTrigger),a		; $675c
	ret			; $675f
_label_0b_264:
	ld e,$42		; $6760
	ld a,(de)		; $6762
	ld hl,@scriptTable		; $6763
	rst_addDoubleIndex			; $6766
	ldi a,(hl)		; $6767
	ld h,(hl)		; $6768
	ld l,a			; $6769
	jp interactionSetScript		; $676a

@scriptTable:
	.dw script7d34
	.dw stubScript


interactionCodeb1:
	ld hl,$7b60		; $6771
	ld e,$3f		; $6774
	jp interBankCall		; $6776

interactionCodeb2:
	call checkInteractionState		; $6779
	jr z,_label_0b_267	; $677c
	ld a,(wFrameCounter)		; $677e
	and $0f			; $6781
	ld a,SND_RUMBLE		; $6783
	call z,playSound		; $6785
	ld a,(wScreenShakeCounterY)		; $6788
	or a			; $678b
	jr nz,_label_0b_266	; $678c
	ld a,(wScreenShakeCounterX)		; $678e
_label_0b_265:
	or a			; $6791
	call z,$67c0		; $6792
_label_0b_266:
	call interactionDecCounter1		; $6795
	ret nz			; $6798
	call $67e1		; $6799
	ld c,$0f		; $679c
	call getRandomNumber		; $679e
	and c			; $67a1
	srl c			; $67a2
	inc c			; $67a4
	sub c			; $67a5
	ld c,a			; $67a6
	call getFreePartSlot		; $67a7
	ret nz			; $67aa
	ld (hl),$11		; $67ab
	inc l			; $67ad
	ld (hl),$01		; $67ae
	ld b,$00		; $67b0
	jp objectCopyPositionWithOffset		; $67b2
_label_0b_267:
	inc a			; $67b5
	ld (de),a		; $67b6
	ld (wScreenShakeMagnitude),a		; $67b7
	ld hl,miniScript67ee		; $67ba
	jp interactionSetMiniScript		; $67bd
_label_0b_268:
	call interactionGetMiniScript		; $67c0
	ldi a,(hl)		; $67c3
	cp $ff			; $67c4
	jr nz,_label_0b_269	; $67c6
	ld hl,miniScript67ee		; $67c8
	call interactionSetMiniScript		; $67cb
	jr _label_0b_268		; $67ce
_label_0b_269:
	ld (wScreenShakeCounterY),a		; $67d0
	ldi a,(hl)		; $67d3
	ld (wScreenShakeCounterX),a		; $67d4
	ld e,$70		; $67d7
	ldi a,(hl)		; $67d9
	ld (de),a		; $67da
	inc e			; $67db
	ldi a,(hl)		; $67dc
	ld (de),a		; $67dd
	call interactionSetMiniScript		; $67de
	call getRandomNumber_noPreserveVars		; $67e1
	ld h,d			; $67e4
	ld l,$70		; $67e5
	and (hl)		; $67e7
	inc l			; $67e8
	add (hl)		; $67e9
	ld l,$46		; $67ea
	ld (hl),a		; $67ec
	ret			; $67ed

; @addr{67ee}
miniScript67ee:
	.db $00 $1e $00 $ff $1e $00 $00 $ff
	.db $b4 $b4 $0f $08 $3c $3c $1f $10
	.db $1e $00 $00 $ff $00 $78 $00 $ff
	.db $0f $0f $00 $ff $ff

interactionCodeb3:
	ld e,$44		; $680b
	ld a,(de)		; $680d
	rst_jumpTable			; $680e
.dw $6819
.dw $684d
.dw $6863
.dw $686f
.dw $689e
	call getThisRoomFlags		; $6819
	bit 5,(hl)		; $681c
	jp nz,interactionDelete		; $681e
	xor a			; $6821
	ld ($cfc0),a		; $6822
	call getFreeInteractionSlot		; $6825
	ret nz			; $6828
	ld (hl),INTERACID_TREASURE		; $6829
	inc l			; $682b
	ld (hl),TREASURE_HARP		; $682c
	ld l,$4b		; $682e
	ld (hl),$38		; $6830
	ld l,$4d		; $6832
	ld (hl),$58		; $6834
	ld b,h			; $6836
	call getFreeInteractionSlot		; $6837
	jr nz,_label_0b_270	; $683a
	ld (hl),$84		; $683c
	inc l			; $683e
	ld (hl),$0c		; $683f
	ld l,$56		; $6841
	ld a,$40		; $6843
	ldi (hl),a		; $6845
	ld (hl),b		; $6846
_label_0b_270:
	call interactionSetAlwaysUpdateBit		; $6847
	jp interactionIncState		; $684a
	call getThisRoomFlags		; $684d
	bit 5,(hl)		; $6850
	ret z			; $6852
	ld a,SNDCTRL_STOPMUSIC		; $6853
	call playSound		; $6855
	ld a,$80		; $6858
	ld (wDisabledObjects),a		; $685a
	ld (wMenuDisabled),a		; $685d
	call interactionIncState		; $6860
	ld a,(wTextIsActive)		; $6863
	or a			; $6866
	ret z			; $6867
	xor a			; $6868
	ld (w1Link.direction),a		; $6869
	jp interactionIncState		; $686c
	ld a,(wTextIsActive)		; $686f
	or a			; $6872
	ret nz			; $6873
	ld hl,$cfc0		; $6874
	set 0,(hl)		; $6877
	call interactionIncState		; $6879
	ld l,$46		; $687c
	ld (hl),$28		; $687e
	ld a,$02		; $6880
	call fadeoutToBlackWithDelay		; $6882
	ld a,$ff		; $6885
	ld (wDirtyFadeBgPalettes),a		; $6887
	ld (wFadeBgPaletteSources),a		; $688a
	ld a,$01		; $688d
	ld (wDirtyFadeSprPalettes),a		; $688f
	ld a,$fe		; $6892
	ld (wFadeSprPaletteSources),a		; $6894
	call hideStatusBar		; $6897
	ldh a,(<hActiveObject)	; $689a
	ld d,a			; $689c
	ret			; $689d
	ld a,(wPaletteThread_mode)		; $689e
	or a			; $68a1
	ret nz			; $68a2
	call interactionDecCounter1		; $68a3
	ret nz			; $68a6
	inc (hl)		; $68a7
	call getFreeInteractionSlot		; $68a8
	ret nz			; $68ab
	ld (hl),$36		; $68ac
	inc l			; $68ae
	ld (hl),$07		; $68af
	call objectCopyPosition		; $68b1
	jp interactionDelete		; $68b4

interactionCodeb4:
	ld e,$44		; $68b7
	ld a,(de)		; $68b9
	rst_jumpTable			; $68ba
.dw $68c5
.dw $68f9
.dw $6938
.dw $6951
.dw $6996
	ld a,$01		; $68c5
	ld (de),a		; $68c7
	ld a,$06		; $68c8
	call objectSetCollideRadius		; $68ca
	call interactionInitGraphics		; $68cd
	call interactionSetAlwaysUpdateBit		; $68d0
	ld a,$12		; $68d3
	call interactionSetHighTextIndex		; $68d5
	ld e,$71		; $68d8
	call objectAddToAButtonSensitiveObjectList		; $68da
	ld e,$42		; $68dd
	ld a,(de)		; $68df
	or a			; $68e0
	ret nz			; $68e1
	ld hl,$cfd0		; $68e2
	ld b,$10		; $68e5
	call z,clearMemory		; $68e7
	call getThisRoomFlags		; $68ea
	bit 6,a			; $68ed
	ret nz			; $68ef
	call interactionIncState		; $68f0
	ld hl,script7d38		; $68f3
	jp interactionSetScript		; $68f6
	inc e			; $68f9
	ld a,(de)		; $68fa
	or a			; $68fb
	call z,$69e0		; $68fc
	call objectSetPriorityRelativeToLink_withTerrainEffects		; $68ff
	ld e,$71		; $6902
	ld a,(de)		; $6904
	or a			; $6905
	ret z			; $6906
_label_0b_271:
	ld a,$01		; $6907
	call interactionSetAnimation		; $6909
	call $69ce		; $690c
	ld a,c			; $690f
	ld ($cfd0),a		; $6910
	ld hl,$6932		; $6913
	rst_addAToHl			; $6916
	ld c,(hl)		; $6917
	ld b,$12		; $6918
	call showText		; $691a
	ld a,$81		; $691d
	ld (wMenuDisabled),a		; $691f
	ld (wDisabledObjects),a		; $6922
	ld h,d			; $6925
	ld l,$43		; $6926
	ld a,$d3		; $6928
_label_0b_272:
	ldi (hl),a		; $692a
	ld a,$03		; $692b
	ldi (hl),a		; $692d
	inc l			; $692e
	ld (hl),$02		; $692f
	ret			; $6931
	dec bc			; $6932
	inc c			; $6933
	dec c			; $6934
	ld c,$0f		; $6935
	stop			; $6937
	inc e			; $6938
	ld a,(de)		; $6939
	or a			; $693a
	call z,$69e0		; $693b
	call interactionRunScript		; $693e
	ret nc			; $6941
	call objectSetPriorityRelativeToLink_withTerrainEffects		; $6942
	ld a,SND_SOLVEPUZZLE		; $6945
	call playSound		; $6947
	ld a,TREASURE_BOOK_OF_SEALS		; $694a
	call loseTreasure		; $694c
	jr _label_0b_271		; $694f
	call retIfTextIsActive		; $6951
	call $6964		; $6954
	ld a,(wDisabledObjects)		; $6957
	or a			; $695a
	ret nz			; $695b
	ld e,$43		; $695c
	ld a,$f4		; $695e
	ld (de),a		; $6960
	jp $69ce		; $6961
	ld a,$81		; $6964
	ld (wDisabledObjects),a		; $6966
	call interactionDecCounter1		; $6969
	ret nz			; $696c
	ld (hl),$02		; $696d
	ld l,$58		; $696f
	ldi a,(hl)		; $6971
	ld h,(hl)		; $6972
	ld l,a			; $6973
	ldi a,(hl)		; $6974
	or a			; $6975
	jr z,_label_0b_273	; $6976
	ld c,a			; $6978
	ld e,$43		; $6979
	ld a,(de)		; $697b
	push hl			; $697c
	call setTile		; $697d
	pop hl			; $6980
	ret z			; $6981
	ld e,$58		; $6982
	ld a,l			; $6984
	ld (de),a		; $6985
	inc e			; $6986
	ld a,h			; $6987
	ld (de),a		; $6988
	ret			; $6989
_label_0b_273:
	ld (wDisabledObjects),a		; $698a
	ld (wMenuDisabled),a		; $698d
	ld e,$71		; $6990
	ld (de),a		; $6992
	jp interactionIncState		; $6993
	call objectSetPriorityRelativeToLink_withTerrainEffects		; $6996
	ld e,$71		; $6999
	ld a,(de)		; $699b
	or a			; $699c
	jr z,_label_0b_274	; $699d
	xor a			; $699f
	ld (de),a		; $69a0
	ld e,$42		; $69a1
	ld a,(de)		; $69a3
	ld hl,$6932		; $69a4
	rst_addAToHl			; $69a7
	ld c,(hl)		; $69a8
	ld b,$12		; $69a9
	jp showText		; $69ab
_label_0b_274:
	ld hl,$cfd0		; $69ae
	ld e,$42		; $69b1
	ld a,(de)		; $69b3
	cp (hl)			; $69b4
	ret z			; $69b5
	call retIfTextIsActive		; $69b6
	call $6964		; $69b9
	ld a,(wDisabledObjects)		; $69bc
	or a			; $69bf
	ret nz			; $69c0
	call interactionSetAnimation		; $69c1
	ld e,$44		; $69c4
	ld a,$01		; $69c6
	ld (de),a		; $69c8
	ld e,$71		; $69c9
	xor a			; $69cb
	ld (de),a		; $69cc
	ret			; $69cd
	ld e,$42		; $69ce
	ld a,(de)		; $69d0
	ld c,a			; $69d1
	ld hl,_data_0b_6a05		; $69d2
	rst_addAToHl			; $69d5
	ld a,(hl)		; $69d6
	rst_addAToHl			; $69d7
	ld e,$58		; $69d8
	ld a,l			; $69da
	ld (de),a		; $69db
	inc e			; $69dc
	ld a,h			; $69dd
	ld (de),a		; $69de
	ret			; $69df
	call returnIfScrollMode01Unset		; $69e0
	ld a,$01		; $69e3
	ld (de),a		; $69e5
	ld e,$42		; $69e6
	ld a,(de)		; $69e8
	or a			; $69e9
	ret nz			; $69ea
	ld bc,$6a3a		; $69eb
	ld e,$05		; $69ee
_label_0b_275:
	call getFreeInteractionSlot		; $69f0
	ret nz			; $69f3
	ld (hl),$b4		; $69f4
	inc l			; $69f6
	ld (hl),e		; $69f7
	ld l,$4b		; $69f8
	ld a,(bc)		; $69fa
	ldi (hl),a		; $69fb
	inc l			; $69fc
	inc bc			; $69fd
	ld a,(bc)		; $69fe
	ld (hl),a		; $69ff
	inc bc			; $6a00
	dec e			; $6a01
	jr nz,_label_0b_275	; $6a02
	ret			; $6a04

_data_0b_6a05:
	.db $06 $0c $12 $17 $1e $26 $99 $9a
	.db $9b $8b $7b $7c $00 $6d $5d $5c
	.db $4c $3c $3d $00 $2c $2b $1b $1a
	.db $19 $00 $28 $27 $26 $25 $15 $14
	.db $13 $00 $22 $23 $33 $43 $42 $41
	.db $51 $61 $00 $72 $82 $83 $84 $74
	.db $75 $65 $66 $67 $00 $84 $18 $14
	.db $18 $14 $78 $14 $d8 $84 $d8

interactionCodeb5:
	ld e,$44		; $6a44
	ld a,(de)		; $6a46
	rst_jumpTable			; $6a47
.dw $6a4c
.dw $6a6b
	ld a,$01		; $6a4c
	ld (de),a		; $6a4e
	call getThisRoomFlags		; $6a4f
	bit 6,a			; $6a52
	jp nz,interactionDelete		; $6a54
	set 6,(hl)		; $6a57
	call setDeathRespawnPoint		; $6a59
	xor a			; $6a5c
	ld (wTextIsActive),a		; $6a5d
	ld a,$78		; $6a60
	ld e,$46		; $6a62
	ld (de),a		; $6a64
	ld bc,$5878		; $6a65
	jp createEnergySwirlGoingIn		; $6a68
	ld e,$45		; $6a6b
	ld a,(de)		; $6a6d
	rst_jumpTable			; $6a6e
.dw $6a75
.dw $6a8b
.dw $6aad
	call interactionDecCounter1		; $6a75
	ret nz			; $6a78
	call interactionIncState2		; $6a79
	ld l,$46		; $6a7c
	ld (hl),$08		; $6a7e
	ld hl,wTmpcbb3		; $6a80
	ld (hl),$00		; $6a83
	ld hl,wTmpcbba		; $6a85
	ld (hl),$ff		; $6a88
	ret			; $6a8a
	ld e,$46		; $6a8b
	ld a,(de)		; $6a8d
	or a			; $6a8e
	jr nz,_label_0b_277	; $6a8f
	call setLinkForceStateToState08		; $6a91
	ld hl,$d01a		; $6a94
	set 7,(hl)		; $6a97
_label_0b_277:
	call interactionDecCounter1		; $6a99
	ld hl,wTmpcbb3		; $6a9c
	ld b,$01		; $6a9f
	call flashScreen		; $6aa1
	ret z			; $6aa4
	call interactionIncState2		; $6aa5
	ld a,$03		; $6aa8
	jp fadeinFromWhiteWithDelay		; $6aaa
	ld a,(wPaletteThread_mode)		; $6aad
	or a			; $6ab0
	ret nz			; $6ab1
	xor a			; $6ab2
	ld (wDisabledObjects),a		; $6ab3
	ld (wMenuDisabled),a		; $6ab6
	ld (wUseSimulatedInput),a		; $6ab9
	jp interactionDelete		; $6abc

interactionCodeb8:
	ld e,$42		; $6abf
	ld a,(de)		; $6ac1
	rst_jumpTable			; $6ac2
.dw $6ac9
.dw $6b0a
.dw $6b88
	call checkInteractionState		; $6ac9
	jr z,_label_0b_280	; $6acc
	ld e,$78		; $6ace
	ld a,(de)		; $6ad0
	or a			; $6ad1
	jr nz,_label_0b_278	; $6ad2
	call $6c33		; $6ad4
	jr nc,_label_0b_279	; $6ad7
	xor a			; $6ad9
	ld (w1Link.direction),a		; $6ada
_label_0b_278:
	call interactionRunScript		; $6add
	jp c,$6c4f		; $6ae0
_label_0b_279:
	jp interactionAnimate		; $6ae3
_label_0b_280:
	call getThisRoomFlags		; $6ae6
	bit 6,(hl)		; $6ae9
	jp nz,interactionDelete		; $6aeb
	ld a,MUS_GREAT_MOBLIN		; $6aee
	call playSound		; $6af0
	ld hl,script7d4a		; $6af3
_label_0b_281:
	call interactionSetScript		; $6af6
	call interactionInitGraphics		; $6af9
	call interactionIncState		; $6afc
	ld l,$50		; $6aff
	ld (hl),$50		; $6b01
	xor a			; $6b03
	ld ($cfd0),a		; $6b04
	jp objectSetVisiblec2		; $6b07
	ld e,$44		; $6b0a
	ld a,(de)		; $6b0c
	rst_jumpTable			; $6b0d
.dw $6b14
.dw $6b31
.dw $6b5b
	ld a,($cae7)		; $6b14
	bit 6,a			; $6b17
	jp nz,interactionDelete		; $6b19
	call getThisRoomFlags		; $6b1c
	bit 6,(hl)		; $6b1f
	ld hl,script7d57		; $6b21
	jr z,_label_0b_281	; $6b24
	ld a,(wActiveMusic)		; $6b26
	or a			; $6b29
	ld a,MUS_MINIBOSS		; $6b2a
	call nz,playSound		; $6b2c
	jr _label_0b_283		; $6b2f
	ld e,$78		; $6b31
	ld a,(de)		; $6b33
	or a			; $6b34
	jr nz,_label_0b_282	; $6b35
	ld a,(w1Link.yh)		; $6b37
	cp $9b			; $6b3a
	jp nc,interactionAnimate		; $6b3c
	call $6c33		; $6b3f
	jp nc,interactionAnimate		; $6b42
_label_0b_282:
	call interactionRunScript		; $6b45
	jp nc,interactionAnimate		; $6b48
	call objectSetInvisible		; $6b4b
	call $6c52		; $6b4e
_label_0b_283:
	ld h,d			; $6b51
	ld l,$44		; $6b52
	ld (hl),$02		; $6b54
	ld l,$46		; $6b56
	ld (hl),$08		; $6b58
	ret			; $6b5a
	call interactionDecCounter1		; $6b5b
	ret nz			; $6b5e
	ld hl,w1Link.yh		; $6b5f
	ldi a,(hl)		; $6b62
	cp $10			; $6b63
	jr nc,_label_0b_284	; $6b65
	inc l			; $6b67
	ld a,(hl)		; $6b68
	cp $a0			; $6b69
	jr nc,_label_0b_285	; $6b6b
_label_0b_284:
	call getFreePartSlot		; $6b6d
	jr nz,_label_0b_285	; $6b70
	ld (hl),$2c		; $6b72
	inc l			; $6b74
	inc (hl)		; $6b75
_label_0b_285:
	call getRandomNumber_noPreserveVars		; $6b76
	and $03			; $6b79
	ld hl,$6b84		; $6b7b
	rst_addAToHl			; $6b7e
	ld e,$46		; $6b7f
	ld a,(hl)		; $6b81
	ld (de),a		; $6b82
	ret			; $6b83
	ld a,b			; $6b84
	and b			; $6b85
	ret z			; $6b86
	ld a,($ff00+R_NR34)	; $6b87
	ld b,h			; $6b89
	ld a,(de)		; $6b8a
	rst_jumpTable			; $6b8b
.dw $6b94
.dw $6bb6
.dw $6c0c
.dw $6c25
	call getThisRoomFlags		; $6b94
	bit 6,(hl)		; $6b97
	jp nz,interactionDelete		; $6b99
	ld bc,$ad03		; $6b9c
	call objectCreateInteraction		; $6b9f
	ret nz			; $6ba2
	ld e,$56		; $6ba3
	ld a,$40		; $6ba5
	ld (de),a		; $6ba7
	inc e			; $6ba8
	ld a,h			; $6ba9
	ld (de),a		; $6baa
	ld hl,$7d6a		; $6bab
	call $6af6		; $6bae
	ld l,$46		; $6bb1
	ld (hl),$08		; $6bb3
	ret			; $6bb5
	ld hl,w1Link.yh		; $6bb6
	ldi a,(hl)		; $6bb9
	cp $40			; $6bba
	jr nc,_label_0b_286	; $6bbc
	inc l			; $6bbe
	ld a,(hl)		; $6bbf
	cp $58			; $6bc0
	jr nc,_label_0b_286	; $6bc2
	call $6c33		; $6bc4
	jr nc,_label_0b_286	; $6bc7
	ld a,$01		; $6bc9
	ld (wDisabledObjects),a		; $6bcb
	ld ($cfd0),a		; $6bce
	ld a,$03		; $6bd1
	ld (w1Link.direction),a		; $6bd3
	jp interactionIncState		; $6bd6
_label_0b_286:
	ld h,d			; $6bd9
	ld l,$47		; $6bda
	ld a,(hl)		; $6bdc
	or a			; $6bdd
	jr z,_label_0b_287	; $6bde
	dec (hl)		; $6be0
	jr nz,_label_0b_287	; $6be1
	ld e,$48		; $6be3
	xor a			; $6be5
	ld (de),a		; $6be6
	call interactionSetAnimation		; $6be7
_label_0b_287:
	call interactionDecCounter1		; $6bea
	jr nz,_label_0b_289	; $6bed
	call getFreePartSlot		; $6bef
	jr nz,_label_0b_288	; $6bf2
	ld (hl),$2c		; $6bf4
	call objectCopyPosition		; $6bf6
	ld e,$48		; $6bf9
	ld a,$01		; $6bfb
	ld (de),a		; $6bfd
	call interactionSetAnimation		; $6bfe
	ld e,$47		; $6c01
	ld a,$18		; $6c03
	ld (de),a		; $6c05
_label_0b_288:
	call $6b76		; $6c06
_label_0b_289:
	jp interactionAnimate		; $6c09
	call interactionIncState		; $6c0c
	ld l,$46		; $6c0f
	xor a			; $6c11
	ldi (hl),a		; $6c12
	ld (hl),a		; $6c13
	ld e,$48		; $6c14
	ld a,(de)		; $6c16
	dec a			; $6c17
	call z,interactionSetAnimation		; $6c18
	ld a,$80		; $6c1b
	ld (wDisabledObjects),a		; $6c1d
	ld a,SNDCTRL_STOPMUSIC		; $6c20
	call playSound		; $6c22
	call interactionRunScript		; $6c25
	jr nc,_label_0b_289	; $6c28
	ld a,$05		; $6c2a
	call objectGetRelatedObject1Var		; $6c2c
	inc (hl)		; $6c2f
	jp interactionDelete		; $6c30
	ld a,(wLinkInAir)		; $6c33
	or a			; $6c36
	ret nz			; $6c37
	call checkLinkVulnerable		; $6c38
	ret nc			; $6c3b
	ld a,$80		; $6c3c
	ld (wDisabledObjects),a		; $6c3e
	ld (wMenuDisabled),a		; $6c41
	ld e,$78		; $6c44
	ld (de),a		; $6c46
	call clearAllParentItems		; $6c47
	call dropLinkHeldItem		; $6c4a
	scf			; $6c4d
	ret			; $6c4e
	call interactionDelete		; $6c4f
	xor a			; $6c52
	ld (wDisabledObjects),a		; $6c53
	ld (wMenuDisabled),a		; $6c56
	ret			; $6c59

interactionCodeb9:
	ld e,$44		; $6c5a
	ld a,(de)		; $6c5c
	rst_jumpTable			; $6c5d
.dw $6c62
.dw $6d17
	ld a,$01		; $6c62
	ld (de),a		; $6c64
	call interactionInitGraphics		; $6c65
	call objectSetVisiblec2		; $6c68
	call objectSetInvisible		; $6c6b
	ld e,$42		; $6c6e
	ld a,(de)		; $6c70
	ld b,a			; $6c71
	ld hl,_data_0b_6ce9		; $6c72
	rst_addAToHl			; $6c75
	ld a,(hl)		; $6c76
	ld e,$46		; $6c77
	ld (de),a		; $6c79
	ld a,b			; $6c7a
	ld hl,$6cf1		; $6c7b
	rst_addDoubleIndex			; $6c7e
	ld b,(hl)		; $6c7f
	inc hl			; $6c80
	ld a,(hl)		; $6c81
	ld c,a			; $6c82
	ld e,$76		; $6c83
	ld (de),a		; $6c85
	call objectGetRelativeAngle		; $6c86
	ld e,$49		; $6c89
	ld (de),a		; $6c8b
	ld e,$50		; $6c8c
	ld a,$28		; $6c8e
	ld (de),a		; $6c90
	ld e,$42		; $6c91
	ld a,(de)		; $6c93
	rst_jumpTable			; $6c94
.dw $6ca5
.dw $6cb2
.dw $6cb2
.dw $6cbf
.dw $6cca
.dw $6cca
.dw $6cca
.dw $6ce3
	ld e,$49		; $6ca5
	ld a,$04		; $6ca7
	ld (de),a		; $6ca9
	ld h,d			; $6caa
	ld l,$46		; $6cab
	ld (hl),$e0		; $6cad
	inc hl			; $6caf
	ld (hl),$01		; $6cb0
	ld e,$42		; $6cb2
	ld a,(de)		; $6cb4
	ld hl,$6d01		; $6cb5
	rst_addDoubleIndex			; $6cb8
	ld c,(hl)		; $6cb9
	inc hl			; $6cba
	ld b,(hl)		; $6cbb
	jp objectSetSpeedZ		; $6cbc
	call $6cb2		; $6cbf
	ld e,$50		; $6cc2
	ld a,$3c		; $6cc4
	ld (de),a		; $6cc6
	jp $6cd2		; $6cc7
	call $6cb2		; $6cca
	ld e,$50		; $6ccd
	ld a,$0a		; $6ccf
	ld (de),a		; $6cd1
	ld e,$42		; $6cd2
	ld a,(de)		; $6cd4
	sub $03			; $6cd5
	ld hl,$6d0f		; $6cd7
	rst_addDoubleIndex			; $6cda
	ld e,$4f		; $6cdb
	ldi a,(hl)		; $6cdd
	ld (de),a		; $6cde
	dec e			; $6cdf
	ld a,(hl)		; $6ce0
	ld (de),a		; $6ce1
	ret			; $6ce2
	ld hl,script7d7b		; $6ce3
	jp interactionSetScript		; $6ce6

; @addr{6ce9}
_data_0b_6ce9:
	.db $e6 $5a $78 $be $c8 $d2 $dc $fa
	.db $58 $38 $48 $40 $4c $60 $48 $78
	.db $1a $2c $10 $38 $0a $44 $18 $a0
	.db $40 $ff $e0 $fe $00 $ff $c0 $ff
	.db $36 $00 $36 $00 $36 $00 $e8 $ff
	.db $c8 $ff $c8 $ff $c8 $ff

	ld e,$45		; $6d17
	ld a,(de)		; $6d19
	rst_jumpTable			; $6d1a
.dw $6d21
.dw $6d2b
.dw $6d7c
	call interactionDecCounter1		; $6d21
	ret nz			; $6d24
	call objectSetVisible		; $6d25
	jp interactionIncState2		; $6d28
	call interactionAnimate		; $6d2b
	call objectApplySpeed		; $6d2e
	ld h,d			; $6d31
	ld l,$4d		; $6d32
	ld a,(hl)		; $6d34
	ld l,$76		; $6d35
	cp (hl)			; $6d37
	jr nz,_label_0b_292	; $6d38
	call interactionIncState2		; $6d3a
	ld l,$4f		; $6d3d
	ld (hl),$00		; $6d3f
	ld l,$42		; $6d41
	ld a,(hl)		; $6d43
	add a			; $6d44
	inc a			; $6d45
	jp interactionSetAnimation		; $6d46
_label_0b_292:
	ld e,$42		; $6d49
	ld a,(de)		; $6d4b
	rst_jumpTable			; $6d4c
.dw $6d5d
.dw $6d5d
.dw $6d5d
.dw $6d68
.dw $6d78
.dw $6d78
.dw $6d78
.dw $6d77
	ld c,$20		; $6d5d
	call objectUpdateSpeedZ_paramC		; $6d5f
	ret nz			; $6d62
	ld e,$42		; $6d63
	jp $6cb2		; $6d65
	ld c,$10		; $6d68
_label_0b_293:
	ld e,$77		; $6d6a
	ld a,(de)		; $6d6c
	or a			; $6d6d
	ret nz			; $6d6e
	call objectUpdateSpeedZ_paramC		; $6d6f
	ret nz			; $6d72
	ld h,d			; $6d73
	ld l,$77		; $6d74
	inc (hl)		; $6d76
	ret			; $6d77
	ld c,$01		; $6d78
	jr _label_0b_293		; $6d7a
	ld e,$42		; $6d7c
	ld a,(de)		; $6d7e
	or a			; $6d7f
	jr nz,_label_0b_294	; $6d80
	ld b,a			; $6d82
	ld h,d			; $6d83
	ld l,$46		; $6d84
	call decHlRef16WithCap		; $6d86
	jr nz,_label_0b_295	; $6d89
	ld hl,$cfdf		; $6d8b
	ld (hl),$01		; $6d8e
	ret			; $6d90
_label_0b_294:
	cp $07			; $6d91
	jr nz,_label_0b_295	; $6d93
	call interactionRunScript		; $6d95
	ld e,$47		; $6d98
	ld a,(de)		; $6d9a
	or a			; $6d9b
	ret z			; $6d9c
_label_0b_295:
	jp interactionAnimate		; $6d9d

interactionCodeba:
	call checkInteractionState		; $6da0
	jr nz,_label_0b_296	; $6da3
	call interactionInitGraphics		; $6da5
	call interactionSetAlwaysUpdateBit		; $6da8
	call interactionIncState		; $6dab
	ld bc,$0e06		; $6dae
	call objectSetCollideRadii		; $6db1
	ld hl,script7d8b		; $6db4
	call interactionSetScript		; $6db7
	jp objectSetVisible82		; $6dba
_label_0b_296:
	call interactionAnimateAsNpc		; $6dbd
	jp interactionRunScript		; $6dc0

interactionCodebb:
	ld e,$44		; $6dc3
	ld a,(de)		; $6dc5
	rst_jumpTable			; $6dc6
.dw $6dcb
.dw $6dda
	call interactionIncState	; $6dda
	call interactionInitGraphics		; $6dce
	ld hl,script7d90		; $6dd1
	call interactionSetScript		; $6dd4
	jp objectSetVisible82		; $6dd7
	ld a,$1a		; $6dda
	call objectGetRelatedObject1Var		; $6ddc
	ld a,(hl)		; $6ddf
	xor $80			; $6de0
	ld e,l			; $6de2
	ld (de),a		; $6de3
	call interactionRunScript		; $6de4
	ret nc			; $6de7
	jp interactionDelete		; $6de8

interactionCodebc:
	ld e,$44		; $6deb
	ld a,(de)		; $6ded
	rst_jumpTable			; $6dee
.dw $6df3
.dw $6e4f
	ld e,$42		; $6df3
	ld a,(de)		; $6df5
	rst_jumpTable			; $6df6
.dw $6dff
.dw $6dff
.dw $6e0f
.dw $6e23
	call $6e33		; $6dff
	ld l,$4f		; $6e02
	ld (hl),$fb		; $6e04
	ld l,$42		; $6e06
	ld a,(hl)		; $6e08
	call $6fd7		; $6e09
	jp $6e4f		; $6e0c
	call $6e33		; $6e0f
	ld l,$4f		; $6e12
	ld (hl),$f0		; $6e14
	ld a,$02		; $6e16
	call $6fd7		; $6e18
	ld a,$04		; $6e1b
	call interactionSetAnimation		; $6e1d
	jp $6e4f		; $6e20
	call $6e33		; $6e23
	ld a,$02		; $6e26
	call $6fd7		; $6e28
	ld a,$01		; $6e2b
	call interactionSetAnimation		; $6e2d
	jp $6e4f		; $6e30
	call interactionInitGraphics		; $6e33
	call objectSetVisiblec0		; $6e36
	call interactionSetAlwaysUpdateBit		; $6e39
	call $6f2f		; $6e3c
	call interactionIncState		; $6e3f
	ld l,$50		; $6e42
	ld (hl),$50		; $6e44
	ld l,$4f		; $6e46
	ld (hl),$f8		; $6e48
	ld l,$48		; $6e4a
	ld (hl),$ff		; $6e4c
	ret			; $6e4e
	ld e,$42		; $6e4f
	ld a,(de)		; $6e51
	rst_jumpTable			; $6e52
.dw $6e5b
.dw $6e5b
.dw $6f11
.dw $6f11
	ld e,$45		; $6e5b
	ld a,(de)		; $6e5d
	rst_jumpTable			; $6e5e
.dw $6e69
.dw $6e9b
.dw $6ebc
.dw $6edb
.dw $6f0e
	call $6f5f		; $6e69
	call $6f91		; $6e6c
	call $6f7b		; $6e6f
	call c,$6fa3		; $6e72
	jp nc,$6f2c		; $6e75
	ld h,d			; $6e78
	ld l,$45		; $6e79
	ld (hl),$01		; $6e7b
	ld l,$47		; $6e7d
	ld (hl),$28		; $6e7f
	ld l,$42		; $6e81
	ld a,(hl)		; $6e83
	or a			; $6e84
	jr nz,_label_0b_297	; $6e85
	ld a,$00		; $6e87
	jr _label_0b_299		; $6e89
_label_0b_297:
	cp $01			; $6e8b
	jr nz,_label_0b_298	; $6e8d
	ld a,$01		; $6e8f
	jr _label_0b_299		; $6e91
_label_0b_298:
	ld a,$02		; $6e93
_label_0b_299:
	call interactionSetAnimation		; $6e95
	jp $6f2c		; $6e98
	call $6f3f		; $6e9b
	call $6f2c		; $6e9e
	call interactionDecCounter2		; $6ea1
	ret nz			; $6ea4
	ld l,$45		; $6ea5
	inc (hl)		; $6ea7
	ld l,$47		; $6ea8
	ld (hl),$28		; $6eaa
	ld hl,$cfc6		; $6eac
	inc (hl)		; $6eaf
	ld a,(hl)		; $6eb0
	cp $02			; $6eb1
	ret nz			; $6eb3
	ld (hl),$00		; $6eb4
	ld hl,$cfc0		; $6eb6
	set 0,(hl)		; $6eb9
	ret			; $6ebb
	call $6f3f		; $6ebc
	call $6f2c		; $6ebf
	ld a,($cfc0)		; $6ec2
	bit 0,a			; $6ec5
	ret nz			; $6ec7
	call interactionDecCounter2		; $6ec8
	ret nz			; $6ecb
	ld l,$45		; $6ecc
	inc (hl)		; $6ece
	ld l,$48		; $6ecf
	ld (hl),$ff		; $6ed1
	ld l,$42		; $6ed3
	ld a,(hl)		; $6ed5
	add $04			; $6ed6
	jp $6fd7		; $6ed8
_label_0b_300:
	call $6f5f		; $6edb
	call $6f7b		; $6ede
	call c,$6fa3		; $6ee1
	jr c,_label_0b_301	; $6ee4
	call $6f5f		; $6ee6
	ld e,$42		; $6ee9
	ld a,(de)		; $6eeb
	cp $02			; $6eec
	call nz,$6f91		; $6eee
	call $6f7b		; $6ef1
	call c,$6fa3		; $6ef4
	jr nc,_label_0b_304	; $6ef7
_label_0b_301:
	ld e,$42		; $6ef9
	ld a,(de)		; $6efb
	cp $02			; $6efc
	jr c,_label_0b_302	; $6efe
	call $6eac		; $6f00
	jp interactionDelete		; $6f03
_label_0b_302:
	call $6eac		; $6f06
	ld h,d			; $6f09
	ld l,$45		; $6f0a
	inc (hl)		; $6f0c
	ret			; $6f0d
	jp $6f2c		; $6f0e
	call checkInteractionState2		; $6f11
	jr nz,_label_0b_303	; $6f14
	call $6f3f		; $6f16
	call $6f2c		; $6f19
	ld a,($cfc0)		; $6f1c
	bit 0,a			; $6f1f
	ret z			; $6f21
	call interactionIncState2		; $6f22
	ld l,$48		; $6f25
	ld (hl),$ff		; $6f27
	ret			; $6f29
_label_0b_303:
	jr _label_0b_300		; $6f2a
_label_0b_304:
	jp interactionAnimate		; $6f2c
	ld e,$42		; $6f2f
	ld a,(de)		; $6f31
	ld hl,$6f3b		; $6f32
	rst_addAToHl			; $6f35
	ld a,(hl)		; $6f36
	ld e,$5c		; $6f37
	ld (de),a		; $6f39
	ret			; $6f3a
	ld (bc),a		; $6f3b
	ld bc,$0100		; $6f3c
	ld a,(wFrameCounter)		; $6f3f
	and $07			; $6f42
	ret nz			; $6f44
	ld a,(wFrameCounter)		; $6f45
	and $38			; $6f48
	swap a			; $6f4a
	rlca			; $6f4c
	ld hl,$6f57		; $6f4d
	rst_addAToHl			; $6f50
	ld e,$4f		; $6f51
	ld a,(de)		; $6f53
	add (hl)		; $6f54
	ld (de),a		; $6f55
	ret			; $6f56
	rst $38			; $6f57
	cp $ff			; $6f58
	nop			; $6f5a
	ld bc,$0102		; $6f5b
	nop			; $6f5e
	ld h,d			; $6f5f
	ld l,$7c		; $6f60
	ld a,(hl)		; $6f62
	add a			; $6f63
	ld b,a			; $6f64
	ld e,$7f		; $6f65
	ld a,(de)		; $6f67
	ld l,a			; $6f68
	ld e,$7e		; $6f69
	ld a,(de)		; $6f6b
	ld h,a			; $6f6c
	ld a,b			; $6f6d
	rst_addAToHl			; $6f6e
	ld b,(hl)		; $6f6f
	inc hl			; $6f70
	ld c,(hl)		; $6f71
	call objectGetRelativeAngle		; $6f72
	ld e,$49		; $6f75
	ld (de),a		; $6f77
	jp objectApplySpeed		; $6f78
	call $6fc4		; $6f7b
	ld l,$4b		; $6f7e
	ld a,(bc)		; $6f80
	sub (hl)		; $6f81
	add $01			; $6f82
	cp $05			; $6f84
	ret nc			; $6f86
	inc bc			; $6f87
	ld l,$4d		; $6f88
	ld a,(bc)		; $6f8a
	sub (hl)		; $6f8b
	add $01			; $6f8c
_label_0b_305:
	cp $05			; $6f8e
	ret			; $6f90
	ld h,d			; $6f91
	ld l,$49		; $6f92
	ld a,(hl)		; $6f94
	swap a			; $6f95
	and $01			; $6f97
	xor $01			; $6f99
	ld l,$48		; $6f9b
	cp (hl)			; $6f9d
	ret z			; $6f9e
	ld (hl),a		; $6f9f
	jp interactionSetAnimation		; $6fa0
	call $6fb3		; $6fa3
	ld h,d			; $6fa6
	ld l,$7d		; $6fa7
	ld a,(hl)		; $6fa9
	ld l,$7c		; $6faa
	inc (hl)		; $6fac
	cp (hl)			; $6fad
	ret nc			; $6fae
	ld (hl),$00		; $6faf
	scf			; $6fb1
	ret			; $6fb2
	call $6fc4		; $6fb3
_label_0b_306:
	ld l,$4a		; $6fb6
	xor a			; $6fb8
	ldi (hl),a		; $6fb9
	ld a,(bc)		; $6fba
	ld (hl),a		; $6fbb
	inc bc			; $6fbc
	ld l,$4c		; $6fbd
	xor a			; $6fbf
	ldi (hl),a		; $6fc0
	ld a,(bc)		; $6fc1
	ld (hl),a		; $6fc2
	ret			; $6fc3
	ld h,d			; $6fc4
	ld l,$7c		; $6fc5
	ld a,(hl)		; $6fc7
_label_0b_307:
	add a			; $6fc8
	push af			; $6fc9
	ld e,$7f		; $6fca
	ld a,(de)		; $6fcc
	ld c,a			; $6fcd
	ld e,$7e		; $6fce
	ld a,(de)		; $6fd0
	ld b,a			; $6fd1
	pop af			; $6fd2
	call addAToBc		; $6fd3
	ret			; $6fd6
	add a			; $6fd7
	ld hl,$6fe9		; $6fd8
	rst_addDoubleIndex			; $6fdb
	ld e,$7f		; $6fdc
	ldi a,(hl)		; $6fde
	ld (de),a		; $6fdf
	ld e,$7e		; $6fe0
	ldi a,(hl)		; $6fe2
	ld (de),a		; $6fe3
	ld e,$7d		; $6fe4
	ldi a,(hl)		; $6fe6
	ld (de),a		; $6fe7
	ret			; $6fe8
	add hl,hl		; $6fe9
	ld (hl),b		; $6fea
	dec bc			; $6feb
	nop			; $6fec
	ld b,c			; $6fed
	ld (hl),b		; $6fee
	dec bc			; $6fef
	nop			; $6ff0
	ld bc,$0970		; $6ff1
	nop			; $6ff4
	dec d			; $6ff5
	ld (hl),b		; $6ff6
	add hl,bc		; $6ff7
	nop			; $6ff8
	ld e,c			; $6ff9
	ld (hl),b		; $6ffa
	inc b			; $6ffb
	nop			; $6ffc
	ld h,e			; $6ffd
	ld (hl),b		; $6ffe
	inc b			; $6fff
	nop			; $7000
	ld d,h			; $7001
	jr _label_0b_308		; $7002
	ld c,$60		; $7004
	ld ($0c68),sp		; $7006
	ld (hl),d		; $7009
	jr _label_0b_309		; $700a
	jr z,_label_0b_305	; $700c
	ld c,b			; $700e
	adc b			; $700f
	ld l,b			; $7010
	sub b			; $7011
	add b			; $7012
	and b			; $7013
	and b			; $7014
	ld d,h			; $7015
	adc b			; $7016
	ld e,b			; $7017
	sub d			; $7018
	ld h,b			; $7019
	sbc b			; $701a
	ld l,b			; $701b
	sub h			; $701c
	ld (hl),d		; $701d
	adc b			; $701e
	ld a,b			; $701f
	ld a,b			; $7020
	add b			; $7021
	ld e,b			; $7022
	adc b			; $7023
	jr c,_label_0b_306	; $7024
	jr nz,_label_0b_307	; $7026
	nop			; $7028
	ld bc,$2940		; $7029
	jr $39			; $702c
	stop			; $702e
	ld b,l			; $702f
	inc c			; $7030
	ld d,c			; $7031
	stop			; $7032
	ld h,c			; $7033
	jr $71			; $7034
	jr z,$77		; $7036
	jr c,_label_0b_312	; $7038
	ld c,b			; $703a
	ld (hl),a		; $703b
	ld e,b			; $703c
	ld (hl),c		; $703d
	ld l,b			; $703e
	ld h,c			; $703f
	ld a,b			; $7040
	ld bc,$2960		; $7041
	adc b			; $7044
	add hl,sp		; $7045
	sub b			; $7046
	ld b,l			; $7047
	sub h			; $7048
	ld d,c			; $7049
	sub b			; $704a
	ld h,c			; $704b
	adc b			; $704c
	ld (hl),c		; $704d
	ld a,b			; $704e
	ld (hl),a		; $704f
	ld l,b			; $7050
	ld a,c			; $7051
	ld e,b			; $7052
	ld (hl),a		; $7053
	ld c,b			; $7054
	ld (hl),c		; $7055
	jr c,_label_0b_313	; $7056
	jr z,$5d		; $7058
	sub b			; $705a
	ld c,l			; $705b
_label_0b_308:
	sbc b			; $705c
	add hl,sp		; $705d
	sub b			; $705e
	dec l			; $705f
	ld a,b			; $7060
	add hl,hl		; $7061
	ld h,b			; $7062
	ld e,l			; $7063
	stop			; $7064
	ld c,l			; $7065
	ld ($1039),sp		; $7066
	dec l			; $7069
	jr z,_label_0b_311	; $706a
	ld b,b			; $706c

interactionCodebd:
	ld e,$44		; $706d
	ld a,(de)		; $706f
	rst_jumpTable			; $7070
.dw interactionIncState
.dw $7077
.dw $7098
	ld a,(w1ReservedInteraction1.enabled)		; $7077
	or a			; $707a
	ret z			; $707b

	ld a,(w1ReservedInteraction1.pressedAButton)		; $707c
	ldh (<hFF8B),a	; $707f
	call findTileInRoom		; $7081
_label_0b_309:
	jr nz,_label_0b_311	; $7084
	call $709e		; $7086
_label_0b_310:
	ldh a,(<hFF8B)	; $7089
	call backwardsSearch		; $708b
	jr nz,_label_0b_311	; $708e
	call $709e		; $7090
	jr _label_0b_310		; $7093
_label_0b_311:
	jp interactionIncState		; $7095
	ld e,$44		; $7098
	ld a,$01		; $709a
	ld (de),a		; $709c
	ret			; $709d
	push hl			; $709e
	ldh a,(<hFF8B)	; $709f
	cp $da			; $70a1
	jr z,_label_0b_314	; $70a3
	ld a,l			; $70a5
	ldh (<hFF8D),a	; $70a6
	ld h,d			; $70a8
	ld l,$4b		; $70a9
	call setShortPosition		; $70ab
	ld l,$49		; $70ae
	ld a,($cca6)		; $70b0
_label_0b_312:
	and $1f			; $70b3
	ld (hl),a		; $70b5
	call interactionCheckAdjacentTileIsSolid		; $70b6
_label_0b_313:
	jr nz,_label_0b_314	; $70b9
	call getFreeInteractionSlot		; $70bb
	jr nz,_label_0b_314	; $70be
	ld (hl),$14		; $70c0
	ld l,$49		; $70c2
	ld e,l			; $70c4
	ld a,(de)		; $70c5
	ld (hl),a		; $70c6
	ld bc,$fe00		; $70c7
	call objectCopyPositionWithOffset		; $70ca
	ld l,$70		; $70cd
	ldh a,(<hFF8D)	; $70cf
	ld (hl),a		; $70d1
_label_0b_314:
	pop hl			; $70d2
	dec l			; $70d3
	ret			; $70d4

interactionCodebe:
	ld e,$44		; $70d5
	ld a,(de)		; $70d7
	rst_jumpTable			; $70d8
.dw $70df
.dw $70ef
.dw $7122
	call getThisRoomFlags		; $70df
	and $80			; $70e2
	jp nz,interactionDelete		; $70e4
	ld a,$02		; $70e7
	call objectSetCollideRadius		; $70e9
	jp interactionIncState		; $70ec
	call objectCheckCollidedWithLink_notDeadAndNotGrabbing		; $70ef
	ret nc			; $70f2
	call objectGetTileAtPosition		; $70f3
	ld a,(wActiveTilePos)		; $70f6
	cp l			; $70f9
	ret nz			; $70fa
	ld a,(wLinkInAir)		; $70fb
	or a			; $70fe
	ret nz			; $70ff
	call checkLinkVulnerable		; $7100
	ret nc			; $7103
	ld a,$81		; $7104
	ld (wDisabledObjects),a		; $7106
	ld (wMenuDisabled),a		; $7109
	ld e,$46		; $710c
	ld a,$2d		; $710e
	ld (de),a		; $7110
	call objectGetTileAtPosition		; $7111
	ld c,l			; $7114
	ld a,$9e		; $7115
	call setTile		; $7117
	ld a,SND_OPENCHEST		; $711a
	call playSound		; $711c
	jp interactionIncState		; $711f
	call interactionDecCounter1		; $7122
	ret nz			; $7125
	ld a,$1c		; $7126
	ld (wCutsceneTrigger),a		; $7128
	ld a,(wActiveRoom)		; $712b
	ld (wTmpcbbb),a		; $712e
	ld a,(wActiveTilePos)		; $7131
	ld (wTmpcbbc),a		; $7134
	ld e,$42		; $7137
	ld a,(de)		; $7139
	ld (wTmpcbbd),a		; $713a
	call fadeoutToWhite		; $713d
	jp interactionDelete		; $7140

interactionCodebf:
	ld e,$44		; $7143
	ld a,(de)		; $7145
	rst_jumpTable			; $7146
.dw $714d
.dw $71ba
.dw $71a8
	call interactionInitGraphics		; $714d
	call objectSetVisible82		; $7150
	call interactionIncState		; $7153
	ld a,$2d		; $7156
	call interactionSetHighTextIndex		; $7158
	ld e,$42		; $715b
	ld a,(de)		; $715d
	rst_jumpTable			; $715e
.dw $7181
.dw $7181
.dw $7181
.dw $7181
.dw $7181
.dw $7181
.dw $7181
.dw $7181
.dw $7181
.dw $7181
.dw $7181
.dw $7181
.dw $7179
	ld a,GLOBALFLAG_TUNI_NUT_PLACED		; $7179
	call checkGlobalFlag		; $717b
	jp z,interactionDelete		; $717e
	ld e,$42		; $7181
	ld a,(de)		; $7183
	ld hl,@scriptTable		; $7184
	rst_addDoubleIndex			; $7187
	ldi a,(hl)		; $7188
	ld h,(hl)		; $7189
	ld l,a			; $718a
	jp interactionSetScript		; $718b

@scriptTable:
	.dw script7da1
	.dw script7da1
	.dw script7da3
	.dw script7da3
	.dw script7da5
	.dw script7da5
	.dw script7da7
	.dw script7da7
	.dw script7dab
	.dw script7dab
	.dw script7db1
	.dw script7db7
	.dw script7dbf

	ld hl,$cfc0		; $71a8
	bit 0,(hl)		; $71ab
	jr z,_label_0b_315	; $71ad
	ld hl,script7daf		; $71af
	call interactionSetScript		; $71b2
	ld e,$44		; $71b5
	ld a,$01		; $71b7
	ld (de),a		; $71b9
_label_0b_315:
	call interactionRunScript		; $71ba
	jp npcFaceLinkAndAnimate		; $71bd

interactionCodec1:
	ld e,$44		; $71c0
	ld a,(de)		; $71c2
	rst_jumpTable			; $71c3
.dw $71c8
.dw $71e5
	ld a,$01		; $71c8
	ld (de),a		; $71ca
	call interactionInitGraphics		; $71cb
	ld h,d			; $71ce
	ld l,$46		; $71cf
	ld (hl),$86		; $71d1
	inc l			; $71d3
	ld (hl),$01		; $71d4
	ld l,$76		; $71d6
	ld (hl),$06		; $71d8
	ld l,$49		; $71da
	ld (hl),$15		; $71dc
	ld l,$50		; $71de
	ld (hl),$78		; $71e0
	jp objectSetVisible82		; $71e2
	ld e,$45		; $71e5
	ld a,(de)		; $71e7
	rst_jumpTable			; $71e8
.dw $71ef
.dw $71fd
.dw $7209
	ld h,d			; $71ef
	ld l,$46		; $71f0
	call decHlRef16WithCap		; $71f2
	ret nz			; $71f5
	ld l,$46		; $71f6
	ld (hl),$28		; $71f8
	jp interactionIncState2		; $71fa
	call $721a		; $71fd
	jr nz,_label_0b_316	; $7200
	ld l,$60		; $7202
	ld (hl),$01		; $7204
	jp interactionIncState2		; $7206
	call interactionAnimate		; $7209
	call $722f		; $720c
	call objectApplySpeed		; $720f
	ld e,$61		; $7212
	ld a,(de)		; $7214
	inc a			; $7215
	jp z,interactionDelete		; $7216
	ret			; $7219
	call $722f		; $721a
	call objectApplySpeed		; $721d
	jp interactionDecCounter1		; $7220
_label_0b_316:
	ret			; $7223
	ld a,(wFrameCounter)		; $7224
	and $01			; $7227
	jp z,objectSetInvisible		; $7229
	jp objectSetVisible		; $722c
	ld h,d			; $722f
	ld l,$76		; $7230
	dec (hl)		; $7232
	ret nz			; $7233
	ld (hl),$06		; $7234
	ld bc,$8409		; $7236
	jp objectCreateInteraction		; $7239

interactionCodec2:
	ld e,$42		; $723c
	ld a,(de)		; $723e
	rst_jumpTable			; $723f
.dw $7246
.dw $72a0
.dw $7310
	ld e,$44		; $7246
	ld a,(de)		; $7248
	rst_jumpTable			; $7249
.dw $7250
.dw $7269
.dw interactionAnimate
	call interactionInitGraphics
	call objectSetVisible82		; $7253
	ld a,(wPirateShipAngle)		; $7256
	and $03			; $7259
	ld e,$48		; $725b
	ld (de),a		; $725d
	call interactionSetAnimation		; $725e
	ld a,$06		; $7261
	call objectSetCollideRadius		; $7263
	jp interactionIncState		; $7266
	ld hl,wPirateShipRoom		; $7269
	ld a,(wActiveRoom)		; $726c
	cp (hl)			; $726f
	jp nz,interactionDelete		; $7270
	inc l			; $7273
	ldi a,(hl)		; $7274
	ld e,$4b		; $7275
	ld (de),a		; $7277
	ldi a,(hl)		; $7278
	ld e,$4d		; $7279
	ld (de),a		; $727b
	ld e,$48		; $727c
	ld a,(de)		; $727e
	cp (hl)			; $727f
	ld a,(hl)		; $7280
	ld (de),a		; $7281
	call nz,interactionSetAnimation		; $7282
	call objectCheckCollidedWithLink_notDead		; $7285
	jr nc,_label_0b_317	; $7288
	call checkLinkVulnerable		; $728a
	jr nc,_label_0b_317	; $728d
	ld hl,$729b		; $728f
	call setWarpDestVariables		; $7292
	jp interactionIncState		; $7295
_label_0b_317:
	jp interactionAnimate		; $7298
	add l			; $729b
	ld hl,sp+$01		; $729c
	ld d,(hl)		; $729e
	inc bc			; $729f
	ld e,$44		; $72a0
	ld a,(de)		; $72a2
	rst_jumpTable			; $72a3
.dw $72aa
.dw $72df
.dw $72f1
	call checkIsLinkedGame		; $72aa
	jp nz,interactionDelete		; $72ad
	ld a,GLOBALFLAG_PIRATES_GONE		; $72b0
	call checkGlobalFlag		; $72b2
	jp z,interactionDelete		; $72b5
	call getThisRoomFlags		; $72b8
	and $40			; $72bb
	jp nz,interactionDelete		; $72bd
	call interactionInitGraphics		; $72c0
	ld a,$03		; $72c3
	call interactionSetAnimation		; $72c5
	xor a			; $72c8
	ld (w1Link.direction),a		; $72c9
	call objectSetVisible82		; $72cc
	ld e,$46		; $72cf
	ld a,$3c		; $72d1
	ld (de),a		; $72d3
	ld a,$81		; $72d4
	ld (wDisabledObjects),a		; $72d6
	ld (wMenuDisabled),a		; $72d9
	jp interactionIncState		; $72dc
	call interactionAnimate		; $72df
	call interactionDecCounter1		; $72e2
	ret nz			; $72e5
	ld (hl),$80		; $72e6
	ld bc,$360c		; $72e8
	call showText		; $72eb
	jp interactionIncState		; $72ee
	ld c,$18		; $72f1
_label_0b_318:
	ld b,$28		; $72f3
	ld e,$49		; $72f5
	call objectApplyGivenSpeed		; $72f7
	call interactionAnimate		; $72fa
	call interactionDecCounter1		; $72fd
	ret nz			; $7300
	call getThisRoomFlags		; $7301
	set 6,(hl)		; $7304
	xor a			; $7306
	ld (wDisabledObjects),a		; $7307
	ld (wMenuDisabled),a		; $730a
	jp interactionDelete		; $730d
	ld e,$44		; $7310
	ld a,(de)		; $7312
	rst_jumpTable			; $7313
.dw $731a
.dw $72df
.dw $733f
	call checkIsLinkedGame		; $731a
	jp z,interactionDelete		; $731d
	ld a,GLOBALFLAG_PIRATES_GONE		; $7320
	call checkGlobalFlag		; $7322
	jp z,interactionDelete		; $7325
	call getThisRoomFlags		; $7328
	and $40			; $732b
	jp nz,interactionDelete		; $732d
	call interactionInitGraphics		; $7330
	xor a			; $7333
	call interactionSetAnimation		; $7334
	ld a,$01		; $7337
	ld (w1Link.direction),a		; $7339
	jp $72cc		; $733c
	ld c,$00		; $733f
	jr _label_0b_318		; $7341

interactionCodec3:
	call checkInteractionState		; $7343
	jr z,_label_0b_319	; $7346
	call objectPreventLinkFromPassing		; $7348
	call interactionRunScript		; $734b
	jp interactionAnimate		; $734e
_label_0b_319:
	call interactionInitGraphics		; $7351
	call objectSetVisible82		; $7354
	call checkIsLinkedGame		; $7357
	jr nz,_label_0b_320	; $735a
	ld hl,wAreaFlags		; $735c
	set 7,(hl)		; $735f
_label_0b_320:
	ld hl,script7dc1		; $7361
	call interactionSetScript		; $7364
	jp interactionIncState		; $7367

interactionCodec4:
	ld e,$44		; $736a
	ld a,(de)		; $736c
	rst_jumpTable			; $736d
.dw $7378
.dw $73c1
.dw $73dd
.dw $7400
.dw $7439
	ld e,$42		; $7378
	ld a,(de)		; $737a
	rst_jumpTable			; $737b
.dw $7386
.dw $7386
.dw $7386
.dw $7386
.dw $739a
	ld a,(de)		; $7386
	ld hl,@scriptTable		; $7387
	rst_addDoubleIndex			; $738a
	ldi a,(hl)		; $738b
	ld h,(hl)		; $738c
	ld l,a			; $738d
	call interactionSetScript		; $738e
	call interactionInitGraphics		; $7391
	call objectSetVisiblec2		; $7394
	jp interactionIncState		; $7397

	call getThisRoomFlags		; $739a
	and $80			; $739d
	jp nz,interactionDelete		; $739f
	call $7440		; $73a2
	ld e,$44		; $73a5
	ld a,$03		; $73a7
	ld (de),a		; $73a9
	ld e,$42		; $73aa
	ld a,(de)		; $73ac
	ld hl,@scriptTable		; $73ad
	rst_addDoubleIndex			; $73b0
	ldi a,(hl)		; $73b1
	ld h,(hl)		; $73b2
	ld l,a			; $73b3
	jp interactionSetScript		; $73b4

@scriptTable:
	.dw script7dc5
	.dw script7dc8
	.dw script7dcb
	.dw script7dce
	.dw script7dd1

	ld a,($cfc0)		; $73c1
	bit 0,a			; $73c4
	jp nz,$73cf		; $73c6
	call interactionRunScript		; $73c9
	jp npcFaceLinkAndAnimate		; $73cc
	ld a,$02		; $73cf
	call interactionSetAnimation		; $73d1
	ld bc,$fe00		; $73d4
	call objectSetSpeedZ		; $73d7
	jp interactionIncState		; $73da
	ld c,$28		; $73dd
	call objectUpdateSpeedZ_paramC		; $73df
	ret nz			; $73e2
	ld hl,$cfc0		; $73e3
	set 1,(hl)		; $73e6
	jp interactionAnimate		; $73e8
	ld a,(wLinkDeathTrigger)		; $73eb
	or a			; $73ee
	ret nz			; $73ef
	ld a,(wLinkPushingDirection)		; $73f0
	or a			; $73f3
	ret nz			; $73f4
	ld a,(wGameKeysPressed)		; $73f5
	and $03			; $73f8
	ret nz			; $73fa
	ld b,$05		; $73fb
	jp objectCheckCenteredWithLink		; $73fd
	call objectCheckCollidedWithLink_notDead		; $7400
	call nc,$7440		; $7403
	call $73eb		; $7406
	call nc,$7440		; $7409
	ld h,d			; $740c
	ld l,$7f		; $740d
	dec (hl)		; $740f
	jr nz,_label_0b_322	; $7410
	ld a,TREASURE_TOKAY_EYEBALL		; $7412
	call checkTreasureObtained		; $7414
	jr c,_label_0b_321	; $7417
	ld bc,$360d		; $7419
	call showText		; $741c
	jr _label_0b_323		; $741f
_label_0b_321:
	call checkLinkCollisionsEnabled		; $7421
	jr nc,_label_0b_323	; $7424
	ld a,$81		; $7426
	ld (wDisabledObjects),a		; $7428
	ld (wMenuDisabled),a		; $742b
	ld a,SNDCTRL_STOPMUSIC		; $742e
	call playSound		; $7430
	ld hl,script7ddd		; $7433
	call interactionSetScript		; $7436
_label_0b_322:
	call interactionRunScript		; $7439
	ret nc			; $743c
	jp interactionDelete		; $743d
_label_0b_323:
	ld e,$7f		; $7440
	ld a,$0a		; $7442
	ld (de),a		; $7444
	ret			; $7445

interactionCodec5:
	ld e,$44		; $7446
	ld a,(de)		; $7448
	rst_jumpTable			; $7449
.dw $7458
.dw $7469
.dw $7485
.dw $74a9
.dw $7485
.dw $74a9
.dw $74ba
	call setLinkForceStateToState08		; $7458
	ld hl,w1Link.yh		; $745b
	call objectTakePosition		; $745e
	ld e,$46		; $7461
	ld a,$04		; $7463
	ld (de),a		; $7465
	jp interactionIncState		; $7466
	call interactionDecCounter1		; $7469
	ret nz			; $746c
	ld (hl),$34		; $746d
	ld a,$1e		; $746f
	ld (wcc50),a		; $7471
	call interactionIncState		; $7474
	ld e,$42		; $7477
	ld a,(de)		; $7479
	ld hl,@sounds		; $747a
	rst_addAToHl			; $747d
	ld a,(hl)		; $747e
	jp playSound		; $747f

@sounds:
.ifdef ROM_AGES
	.db SND_ECHO
	.db SND_CURRENT
	.db SND_AGES
.endif

	ld a,(wFrameCounter)		; $7485
	and $1f			; $7488
	jr nz,_label_0b_324	; $748a
	xor a			; $748c
	ld bc,$f8f8		; $748d
	call objectCreateFloatingMusicNote		; $7490
_label_0b_324:
	push de			; $7493
	ld de,$d000		; $7494
	ld hl,specialObjectAnimate		; $7497
	ld e,$00		; $749a
	call interBankCall		; $749c
	pop de			; $749f
	call interactionDecCounter1		; $74a0
	ret nz			; $74a3
	ld (hl),$34		; $74a4
	jp interactionIncState		; $74a6
	ld a,(wFrameCounter)		; $74a9
	and $1f			; $74ac
	jr nz,_label_0b_324	; $74ae
	ld a,$01		; $74b0
	ld bc,$f808		; $74b2
	call objectCreateFloatingMusicNote		; $74b5
	jr _label_0b_324		; $74b8
	ld hl,$cfc0		; $74ba
	set 7,(hl)		; $74bd
	ld a,$10		; $74bf
	ld (wcc50),a		; $74c1
	jp interactionDelete		; $74c4

interactionCodec6:
	ld e,$44		; $74c7
	ld a,(de)		; $74c9
	rst_jumpTable			; $74ca
.dw $74d1
.dw $7527
.dw $7536
	call getThisRoomFlags		; $74d1
	and $40			; $74d4
	jr z,_label_0b_325	; $74d6
	ld hl,$cf47		; $74d8
	ld (hl),$44		; $74db
	jp interactionDelete		; $74dd
_label_0b_325:
	ld a,TREASURE_MAKU_SEED		; $74e0
	call checkTreasureObtained		; $74e2
	jr nc,_label_0b_326	; $74e5
	call clearAllItemsAndPutLinkOnGround		; $74e7
	call resetLinkInvincibility		; $74ea
	ld a,$0b		; $74ed
	ld (wLinkForceState),a		; $74ef
	ld a,$70		; $74f2
	ld (wLinkStateParameter),a		; $74f4
	ld e,$46		; $74f7
	ld (de),a		; $74f9
	ld hl,w1Link.direction		; $74fa
	ld (hl),$01		; $74fd
	inc l			; $74ff
	ld (hl),$08		; $7500
	ld a,$81		; $7502
	ld (wDisabledObjects),a		; $7504
	ld (wMenuDisabled),a		; $7507
	call interactionIncState		; $750a
	ld a,PALH_ab		; $750d
	call loadPaletteHeader		; $750f
	jp restartSound		; $7512
_label_0b_326:
	ld a,$44		; $7515
	ld hl,$cf44		; $7517
	ld (hl),a		; $751a
	ld l,$47		; $751b
	ld (hl),a		; $751d
	ld l,$4a		; $751e
	ld (hl),a		; $7520
	ld (wDisableWarps),a		; $7521
	jp interactionDelete		; $7524
	call interactionDecCounter1		; $7527
	ret nz			; $752a
	ld (hl),$1e		; $752b
	xor a			; $752d
	ld hl,w1Link.direction		; $752e
	ldi (hl),a		; $7531
	ld (hl),a		; $7532
	jp interactionIncState		; $7533
	call interactionDecCounter1		; $7536
	ret nz			; $7539
	ld b,$d7		; $753a
	call objectCreateInteractionWithSubid00		; $753c
	jp interactionDelete		; $753f

interactionCodec8:
	ld e,$44		; $7542
	ld a,(de)		; $7544
	rst_jumpTable			; $7545
.dw $7550
.dw $758f
.dw $75b1
.dw $7590
.dw $75be
	ld a,$01		; $7550
	ld (de),a		; $7552
	call interactionInitGraphics		; $7553
	call interactionSetAlwaysUpdateBit		; $7556
	call objectSetVisiblec0		; $7559
	ld a,$1e		; $755c
	call interactionSetHighTextIndex		; $755e
	ld a,$06		; $7561
	call objectSetCollideRadius		; $7563
	ldbc TREASURE_EMBER_SEEDS, 00		; $7566
_label_0b_327:
	ld a,b			; $7569
	call checkTreasureObtained		; $756a
	ld a,$00		; $756d
	rla			; $756f
	add c			; $7570
	ld c,a			; $7571
	inc b			; $7572
	ld a,b			; $7573
	cp $25			; $7574
	jr nz,_label_0b_327	; $7576
	ld a,c			; $7578
	cp $03			; $7579
	jr c,_label_0b_328	; $757b
	ld e,$7e		; $757d
	ld (de),a		; $757f
_label_0b_328:
	call getFreePartSlot		; $7580
	ret nz			; $7583
	ld (hl),$44		; $7584
	call objectCopyPosition		; $7586
	ld l,$d6		; $7589
	ld a,$40		; $758b
	ldi (hl),a		; $758d
	ld (hl),d		; $758e
	ret			; $758f
	ld e,$46		; $7590
	ld a,(de)		; $7592
	or a			; $7593
	jp nz,interactionDecCounter1		; $7594
	ld c,$10		; $7597
	call objectUpdateSpeedZ_paramC		; $7599
	ret nz			; $759c
	ld e,$71		; $759d
	call objectAddToAButtonSensitiveObjectList		; $759f
	ld hl,script7dfd		; $75a2
	call interactionSetScript		; $75a5
	ld a,$04		; $75a8
	ld e,$44		; $75aa
	ld (de),a		; $75ac
	ld a,$01		; $75ad
	jr _label_0b_329		; $75af
	ld a,$03		; $75b1
	ld (de),a		; $75b3
	ld a,$0f		; $75b4
	ld e,$46		; $75b6
	ld (de),a		; $75b8
	ld a,$02		; $75b9
_label_0b_329:
	jp interactionSetAnimation		; $75bb
	ld a,TREASURE_SEED_SATCHEL		; $75be
	call checkTreasureObtained		; $75c0
	ld e,$7d		; $75c3
	dec a			; $75c5
	ld (de),a		; $75c6
	call interactionRunScript		; $75c7
	call interactionAnimateAsNpc		; $75ca
	ld e,$61		; $75cd
	ld a,(de)		; $75cf
	rrca			; $75d0
	jr nc,_label_0b_330	; $75d1
	ld bc,$fe00		; $75d3
	call objectSetSpeedZ		; $75d6
	ld bc,$e800		; $75d9
	call objectCreateSparkle		; $75dc
	ld l,$49		; $75df
	ld (hl),$10		; $75e1
	ld bc,$f008		; $75e3
	call objectCreateSparkle		; $75e6
	ld l,$49		; $75e9
	ld (hl),$10		; $75eb
	ld bc,$f0f8		; $75ed
	call objectCreateSparkle		; $75f0
	ld l,$49		; $75f3
	ld (hl),$10		; $75f5
_label_0b_330:
	ld c,$20		; $75f7
	call objectUpdateSpeedZ_paramC		; $75f9
	ret nz			; $75fc
	ld e,$61		; $75fd
	ld a,(de)		; $75ff
	rlca			; $7600
	ret nc			; $7601
	xor a			; $7602
	ld e,$7f		; $7603
	ld (de),a		; $7605
	ld a,$01		; $7606
	jr _label_0b_329		; $7608

interactionCodec9:
	call $7610		; $760a
	jp $761e		; $760d
	ld e,$44		; $7610
	ld a,(de)		; $7612
	rst_jumpTable			; $7613
.dw $7626
.dw $7646
.dw $7697
.dw $76b1
.dw $76c9
	ld e,$7d		; $761e
	ld a,(de)		; $7620
	or a			; $7621
	ret z			; $7622
	jp interactionAnimate		; $7623
	ld a,$01		; $7626
	ld (de),a		; $7628
	call interactionInitGraphics		; $7629
	ld h,d			; $762c
	ld l,$66		; $762d
	ld (hl),$06		; $762f
	inc l			; $7631
	ld (hl),$06		; $7632
	ld l,$50		; $7634
	ld (hl),$19		; $7636
	call $76f0		; $7638
	ld e,$71		; $763b
	call objectAddToAButtonSensitiveObjectList		; $763d
	call objectSetVisible80		; $7640
	jp $7710		; $7643
	call $76e9		; $7646
	call $76f6		; $7649
	ld hl,w1Link.yh		; $764c
	ld c,$69		; $764f
	ld b,(hl)		; $7651
	ld a,$69		; $7652
	ld l,a			; $7654
	ld a,c			; $7655
	cp b			; $7656
	ret nc			; $7657
	ld a,(wLinkGrabState)		; $7658
	or a			; $765b
	ret z			; $765c
	ld e,$7c		; $765d
	ld a,$02		; $765f
	ld (de),a		; $7661
	ld a,$80		; $7662
	ld (wDisabledObjects),a		; $7664
	ld a,l			; $7667
	ld hl,w1Link.yh		; $7668
	ld (hl),a		; $766b
	jp $771b		; $766c
	xor a			; $766f
	ld (de),a		; $7670
	ld e,$7d		; $7671
	ld (de),a		; $7673
	ld e,$7c		; $7674
	ld a,$01		; $7676
	ld (de),a		; $7678
	ld a,(wLinkGrabState)		; $7679
	or a			; $767c
	jr z,_label_0b_331	; $767d
	ld a,($d019)		; $767f
	ld h,a			; $7682
	ld e,$7a		; $7683
	ld (de),a		; $7685
	ld hl,$7ecd		; $7686
	jp $768f		; $7689
_label_0b_331:
	ld hl,script7ecd		; $768c
	ld e,$44		; $768f
	ld a,$04		; $7691
	ld (de),a		; $7693
	jp interactionSetScript		; $7694
	call $76e9		; $7697
	call objectApplySpeed		; $769a
	ld e,$4d		; $769d
	ld a,(de)		; $769f
	sub $0c			; $76a0
	ld hl,w1Link.xh		; $76a2
	cp (hl)			; $76a5
	ret nc			; $76a6
	ld e,$7d		; $76a7
	xor a			; $76a9
	ld (de),a		; $76aa
	ld hl,$7ecd		; $76ab
	jp $768f		; $76ae
	call $76e9		; $76b1
	call objectApplySpeed		; $76b4
	ld e,$4d		; $76b7
	ld a,(de)		; $76b9
	cp $78			; $76ba
	ret c			; $76bc
	xor a			; $76bd
	ld (wDisabledObjects),a		; $76be
	ld e,$44		; $76c1
	ld a,$01		; $76c3
	ld (de),a		; $76c5
	jp $7710		; $76c6
	call interactionRunScript		; $76c9
	ret nc			; $76cc
	ld e,$7c		; $76cd
	ld a,(de)		; $76cf
	cp $02			; $76d0
	jr z,_label_0b_332	; $76d2
	ld h,d			; $76d4
	ld l,$44		; $76d5
	ld (hl),$01		; $76d7
	ld l,$7c		; $76d9
	ld (hl),$00		; $76db
	ld l,$7d		; $76dd
	ld (hl),$01		; $76df
	xor a			; $76e1
	ld (wDisabledObjects),a		; $76e2
	ret			; $76e5
_label_0b_332:
	jp $7739		; $76e6
	ld c,$20		; $76e9
	call objectUpdateSpeedZ_paramC		; $76eb
	ret nz			; $76ee
	ld h,d			; $76ef
	ld bc,$ff40		; $76f0
	jp objectSetSpeedZ		; $76f3
	call objectApplySpeed		; $76f6
	ld e,$4d		; $76f9
	ld a,(de)		; $76fb
	sub $68			; $76fc
	cp $20			; $76fe
	ret c			; $7700
	ld e,$49		; $7701
	ld a,(de)		; $7703
	xor $10			; $7704
	ld (de),a		; $7706
	ld e,$7e		; $7707
	ld a,(de)		; $7709
	xor $01			; $770a
	ld (de),a		; $770c
	jp interactionSetAnimation		; $770d
	ld h,d			; $7710
	ld l,$7c		; $7711
	ld (hl),$00		; $7713
	ld l,$50		; $7715
	ld (hl),$14		; $7717
	jr _label_0b_333		; $7719
	ld h,d			; $771b
	ld l,$44		; $771c
	ld (hl),$02		; $771e
	ld l,$50		; $7720
	ld (hl),$50		; $7722
_label_0b_333:
	ld l,$7d		; $7724
	ld (hl),$01		; $7726
	ld l,$49		; $7728
	ld (hl),$18		; $772a
	xor a			; $772c
	ld l,$4e		; $772d
	ldi (hl),a		; $772f
	ld (hl),a		; $7730
	ld l,$7e		; $7731
	ld a,$00		; $7733
	ld (hl),a		; $7735
	jp interactionSetAnimation		; $7736
	ld h,d			; $7739
	ld l,$44		; $773a
	ld (hl),$03		; $773c
	ld l,$50		; $773e
	ld (hl),$50		; $7740
	ld l,$7d		; $7742
	ld (hl),$01		; $7744
	ld l,$49		; $7746
	ld (hl),$08		; $7748
	xor a			; $774a
	ld l,$4e		; $774b
	ldi (hl),a		; $774d
	ld (hl),a		; $774e
	ld l,$7e		; $774f
	ld a,$01		; $7751
	ld (hl),a		; $7753
	jp interactionSetAnimation		; $7754

interactionCodeca:
	ld e,$42		; $7757
	ld a,(de)		; $7759
	rst_jumpTable			; $775a
.dw $775f
.dw $7779
	call checkInteractionState		; $775f
	jr nz,_label_0b_334	; $7762
	call $7787		; $7764
	ld a,(wScreenTransitionDirection)		; $7767
	or a			; $776a
	jr nz,_label_0b_334	; $776b
	ld ($cfd5),a		; $776d
_label_0b_334:
	call interactionRunScript		; $7770
	jp c,interactionDelete		; $7773
	jp interactionAnimateAsNpc		; $7776
	call checkInteractionState		; $7779
	jr nz,_label_0b_334	; $777c
	jp $7787		; $777e
	call interactionInitGraphics		; $7781
	jp interactionIncState		; $7784
	call interactionInitGraphics		; $7787
	ld e,$42		; $778a
	ld a,(de)		; $778c
	ld hl,@scriptTable		; $778d
	rst_addDoubleIndex			; $7790
	ldi a,(hl)		; $7791
	ld h,(hl)		; $7792
	ld l,a			; $7793
	call interactionSetScript		; $7794
	jp interactionIncState		; $7797

@scriptTable:
	.dw script7ed1
	.dw script7ed5

interactionCodecb:
	call checkInteractionState		; $779e
	jr nz,_label_0b_335	; $77a1
	call $77be		; $77a3
	ld h,d			; $77a6
	ld l,$5c		; $77a7
	ld (hl),$02		; $77a9
	ld l,$7f		; $77ab
	ld (hl),$01		; $77ad
	ld hl,linkedGameNpcScript		; $77af
	call interactionSetScript		; $77b2
_label_0b_335:
	call interactionRunScript		; $77b5
	jp c,interactionDeleteAndUnmarkSolidPosition		; $77b8
	jp interactionAnimateAsNpc		; $77bb
	call interactionInitGraphics		; $77be
	call objectMarkSolidPosition		; $77c1
	jp interactionIncState		; $77c4
	call interactionInitGraphics		; $77c7
	call objectMarkSolidPosition		; $77ca
	ld a,$4d		; $77cd
	call interactionSetHighTextIndex		; $77cf
	ld e,$42		; $77d2
	ld a,(de)		; $77d4
	ld hl,@scriptTable		; $77d5
	rst_addDoubleIndex			; $77d8
	ldi a,(hl)		; $77d9
	ld h,(hl)		; $77da
	ld l,a			; $77db
	call interactionSetScript		; $77dc
	jp interactionIncState		; $77df

@scriptTable:
	.dw linkedGameNpcScript

interactionCodecc:
	ld e,$42		; $77e4
	ld a,(de)		; $77e6
	rst_jumpTable			; $77e7
.dw $77ea

	call checkInteractionState		; $77ea
	jr nz,_label_0b_336	; $77ed
	call $7804		; $77ef
	call interactionSetAlwaysUpdateBit		; $77f2
_label_0b_336:
	call interactionRunScript		; $77f5
	jp c,interactionDelete		; $77f8
	jp interactionAnimateAsNpc		; $77fb
	call interactionInitGraphics		; $77fe
	jp interactionIncState		; $7801
	call interactionInitGraphics		; $7804
	ld e,$42		; $7807
	ld a,(de)		; $7809
	ld hl,@scriptTable		; $780a
	rst_addDoubleIndex			; $780d
	ldi a,(hl)		; $780e
	ld h,(hl)		; $780f
	ld l,a			; $7810
	call interactionSetScript		; $7811
	jp interactionIncState		; $7814

@scriptTable:
	.dw script7f2c

interactionCodecd:
	call checkInteractionState		; $7819
	jr nz,_label_0b_337	; $781c
	call $7837		; $781e
	ld l,$7f		; $7821
	ld (hl),$03		; $7823
	ld hl,linkedGameNpcScript		; $7825
	call interactionSetScript		; $7828
	call interactionRunScript		; $782b
_label_0b_337:
	call interactionRunScript		; $782e
	jp c,interactionDeleteAndUnmarkSolidPosition		; $7831
	jp interactionAnimateAsNpc		; $7834
	call interactionInitGraphics		; $7837
	call objectMarkSolidPosition		; $783a
	jp interactionIncState		; $783d
	call interactionInitGraphics		; $7840
	call objectMarkSolidPosition		; $7843
	ld e,$42		; $7846
	ld a,(de)		; $7848
	ld hl,@scriptTable		; $7849
	rst_addDoubleIndex			; $784c
	ldi a,(hl)		; $784d
	ld h,(hl)		; $784e
	ld l,a			; $784f
	call interactionSetScript		; $7850
	jp interactionIncState		; $7853

@scriptTable:
	; Apparently this is empty

interactionCoded5:
	ld e,$42		; $7856
	ld a,(de)		; $7858
	rst_jumpTable			; $7859
.dw $785e
.dw $78a5
	call checkInteractionState		; $785e
	jr nz,_label_0b_338	; $7861
	call $7963		; $7863
	call interactionSetAlwaysUpdateBit		; $7866
	ld l,$4f		; $7869
	ld (hl),$f0		; $786b
	ld l,$7f		; $786d
	ld (hl),$06		; $786f
	call interactionRunScript		; $7871
_label_0b_338:
	call returnIfScrollMode01Unset		; $7874
	call interactionRunScript		; $7877
	jp c,interactionDeleteAndUnmarkSolidPosition		; $787a
	ld e,$7e		; $787d
	ld a,(de)		; $787f
	or a			; $7880
	ret nz			; $7881
	call interactionAnimateAsNpc		; $7882
	ld a,(wFrameCounter)		; $7885
	and $07			; $7888
	ret nz			; $788a
	ld a,(wFrameCounter)		; $788b
	and $38			; $788e
	swap a			; $7890
	rlca			; $7892
	ld hl,$789d		; $7893
	rst_addAToHl			; $7896
	ld e,$4f		; $7897
	ld a,(de)		; $7899
	add (hl)		; $789a
	ld (de),a		; $789b
	ret			; $789c
	rst $38			; $789d
	cp $ff			; $789e
	nop			; $78a0
	ld bc,$0102		; $78a1
	nop			; $78a4
	call checkInteractionState		; $78a5
	jr nz,_label_0b_340	; $78a8
	ld a,SND_POP		; $78aa
	call playSound		; $78ac
	call $7963		; $78af
	call objectSetVisiblec1		; $78b2
	call interactionSetAlwaysUpdateBit		; $78b5
	ld l,$4f		; $78b8
	ld (hl),$f0		; $78ba
	ld l,$46		; $78bc
	ld a,$b4		; $78be
	ldi (hl),a		; $78c0
	ld (hl),$02		; $78c1
	ld bc,$8404		; $78c3
	call objectCreateInteraction		; $78c6
	ld l,$46		; $78c9
	ld (hl),$78		; $78cb
	ld b,$00		; $78cd
_label_0b_339:
	push bc			; $78cf
	ld bc,$840a		; $78d0
	call objectCreateInteraction		; $78d3
	pop bc			; $78d6
	ld l,$49		; $78d7
	ld (hl),b		; $78d9
	ld a,b			; $78da
	add $04			; $78db
	ld b,a			; $78dd
	bit 5,a			; $78de
	jr z,_label_0b_339	; $78e0
	ret			; $78e2
_label_0b_340:
	call interactionAnimate		; $78e3
	ld e,$45		; $78e6
	ld a,(de)		; $78e8
	rst_jumpTable			; $78e9
.dw $78f2
.dw $7909
.dw $793a
.dw $794d
	call interactionDecCounter1		; $78f2
	ret nz			; $78f5
	ld (hl),$40		; $78f6
	ld l,$49		; $78f8
	ld (hl),$08		; $78fa
	ld l,$50		; $78fc
	ld (hl),$78		; $78fe
	ld bc,$4109		; $7900
	call showText		; $7903
	jp interactionIncState2		; $7906
	call retIfTextIsActive		; $7909
	call objectApplySpeed		; $790c
	call interactionDecCounter2		; $790f
	jr nz,_label_0b_341	; $7912
	ld (hl),$02		; $7914
	ld l,$49		; $7916
	ld a,(hl)		; $7918
	inc a			; $7919
	and $1f			; $791a
	ld (hl),a		; $791c
	call interactionDecCounter1		; $791d
	jp z,interactionIncState2		; $7920
_label_0b_341:
	ld a,(wFrameCounter)		; $7923
	and $07			; $7926
	ret nz			; $7928
	ld bc,$8402		; $7929
	call objectCreateInteraction		; $792c
	ld a,(wFrameCounter)		; $792f
	and $1f			; $7932
	ld a,SND_MAGIC_POWDER		; $7934
	call z,playSound		; $7936
	ret			; $7939
	call $7923		; $793a
	ld h,d			; $793d
	ld l,$4f		; $793e
	ld a,(hl)		; $7940
	sub $02			; $7941
	ld (hl),a		; $7943
	cp $b0			; $7944
	ret nc			; $7946
	call fadeoutToWhite		; $7947
	jp interactionIncState2		; $794a
	ld a,(wPaletteThread_mode)		; $794d
	or a			; $7950
	ret nz			; $7951
	ld a,$1e		; $7952
	ld (wCutsceneTrigger),a		; $7954
	jp interactionDelete		; $7957
	call interactionInitGraphics		; $795a
	call objectMarkSolidPosition		; $795d
	jp interactionIncState		; $7960
	call interactionInitGraphics		; $7963
	call objectMarkSolidPosition		; $7966
	ld e,$42		; $7969
	ld a,(de)		; $796b
	ld hl,$7979		; $796c
	rst_addDoubleIndex			; $796f
	ldi a,(hl)		; $7970
	ld h,(hl)		; $7971
	ld l,a			; $7972
	call interactionSetScript		; $7973
	jp interactionIncState		; $7976

@scriptTable:
	.dw script7f30

interactionCoded6:
	call checkInteractionState		; $797b
	jr nz,_label_0b_342	; $797e
	call $79b9		; $7980
	call interactionSetAlwaysUpdateBit		; $7983
	ld l,$7f		; $7986
	ld (hl),$07		; $7988
	ld hl,linkedGameNpcScript		; $798a
	call interactionSetScript		; $798d
	call interactionRunScript		; $7990
_label_0b_342:
	call interactionRunScript		; $7993
	jp c,interactionDeleteAndUnmarkSolidPosition		; $7996
	call interactionAnimateAsNpc		; $7999
	ld c,$20		; $799c
	call objectCheckLinkWithinDistance		; $799e
	ld h,d			; $79a1
	ld l,$7e		; $79a2
	jr c,_label_0b_343	; $79a4
	ld a,(hl)		; $79a6
	or a			; $79a7
	ret z			; $79a8
	xor a			; $79a9
	ld (hl),a		; $79aa
	ld a,$03		; $79ab
	jp interactionSetAnimation		; $79ad
_label_0b_343:
	ld a,(hl)		; $79b0
	or a			; $79b1
	ret nz			; $79b2
	inc (hl)		; $79b3
	ld a,$01		; $79b4
	jp interactionSetAnimation		; $79b6
	call interactionInitGraphics		; $79b9
	call objectMarkSolidPosition		; $79bc
	jp interactionIncState		; $79bf

interactionCoded7:
	ld e,$42		; $79c2
	ld a,(de)		; $79c4
	rst_jumpTable			; $79c5
.dw $79d8
.dw $7bac
.dw $7bac
.dw $7bac
.dw $7bac
.dw $7bac
.dw $7bac
.dw $7bac
.dw $7bac
	ld e,$44		; $79d8
	ld a,(de)		; $79da
	rst_jumpTable			; $79db
.dw $79e6
.dw $7a18
.dw $7a2a
.dw $7a50
.dw $7b10
	ld a,$01		; $79e6
	ld (de),a		; $79e8
	call interactionInitGraphics		; $79e9
	ld a,(w1Link.yh)		; $79ec
	sub $0e			; $79ef
	ld e,$4b		; $79f1
	ld (de),a		; $79f3
	ld a,(w1Link.xh)		; $79f4
	ld e,$4d		; $79f7
	ld (de),a		; $79f9
_label_0b_344:
	call setLinkForceStateToState08		; $79fa
	ld a,SNDCTRL_STOPSFX		; $79fd
	call playSound		; $79ff
	ld a,SND_DROPESSENCE		; $7a02
	call playSound		; $7a04
	ld bc,$8404		; $7a07
	call objectCreateInteraction		; $7a0a
	ret nz			; $7a0d
	ld l,$46		; $7a0e
	ld e,l			; $7a10
	ld a,$78		; $7a11
	ld (hl),a		; $7a13
	ld (de),a		; $7a14
	jp objectSetVisible82		; $7a15
	ld a,$0f		; $7a18
	ld (wcc50),a		; $7a1a
	call interactionDecCounter1		; $7a1d
	ret nz			; $7a20
	ld (hl),$40		; $7a21
	ld l,$50		; $7a23
	ld (hl),$14		; $7a25
	jp interactionIncState		; $7a27
	call objectApplySpeed		; $7a2a
	call $7c0f		; $7a2d
	call interactionDecCounter1		; $7a30
	ret nz			; $7a33
	ld (hl),$78		; $7a34
	ld a,$10		; $7a36
	ld (wcc50),a		; $7a38
	ld l,$4b		; $7a3b
	ld (hl),$58		; $7a3d
	ld l,$4d		; $7a3f
	ld (hl),$78		; $7a41
	ld a,SND_POP		; $7a43
	call playSound		; $7a45
	ld a,$03		; $7a48
	call fadeinFromWhiteWithDelay		; $7a4a
	jp interactionIncState		; $7a4d
	call $7c0f		; $7a50
	call $7c46		; $7a53
	ld e,$45		; $7a56
	ld a,(de)		; $7a58
	rst_jumpTable			; $7a59
.dw $7a6e
.dw $7a7a
.dw $7ab9
.dw $7acc
.dw $7ad9
.dw $7acc
.dw $7ad9
.dw $7acc
.dw $7aed
.dw $7afe
	call interactionDecCounter1		; $7a6e
	ret nz			; $7a71
	ld (hl),$14		; $7a72
	inc l			; $7a74
	ld (hl),$08		; $7a75
	jp interactionIncState2		; $7a77
	call interactionDecCounter1		; $7a7a
	ret nz			; $7a7d
	ld (hl),$14		; $7a7e
	inc l			; $7a80
	dec (hl)		; $7a81
	ld b,(hl)		; $7a82
	call getFreeInteractionSlot		; $7a83
	ret nz			; $7a86
	ld (hl),$d7		; $7a87
	call objectCopyPosition		; $7a89
	ld a,b			; $7a8c
	ld bc,$7aa9		; $7a8d
	call addDoubleIndexToBc		; $7a90
	ld a,(bc)		; $7a93
	ld l,$42		; $7a94
	ld (hl),a		; $7a96
	ld l,$49		; $7a97
	inc bc			; $7a99
	ld a,(bc)		; $7a9a
	ld (hl),a		; $7a9b
	ld e,$47		; $7a9c
	ld a,(de)		; $7a9e
	or a			; $7a9f
	ret nz			; $7aa0
	call interactionIncState2		; $7aa1
	ld l,$46		; $7aa4
	ld (hl),$78		; $7aa6
	ret			; $7aa8
	ld ($071a),sp		; $7aa9
	ld d,$06		; $7aac
	ld (de),a		; $7aae
	dec b			; $7aaf
	ld c,$04		; $7ab0
	ld a,(bc)		; $7ab2
	inc bc			; $7ab3
	ld b,$02		; $7ab4
	ld (bc),a		; $7ab6
	ld bc,$cd1e		; $7ab7
	call z,$c023		; $7aba
	ld (hl),$3c		; $7abd
	ld a,$01		; $7abf
	ld ($cfc0),a		; $7ac1
	ld a,$20		; $7ac4
	ld ($cfc1),a		; $7ac6
	jp interactionIncState2		; $7ac9
	ld a,(wFrameCounter)		; $7acc
	and $03			; $7acf
	jr nz,_label_0b_346	; $7ad1
	ld hl,$cfc1		; $7ad3
	dec (hl)		; $7ad6
	jr _label_0b_346		; $7ad7
	ld a,(wFrameCounter)		; $7ad9
	and $03			; $7adc
	jr nz,_label_0b_346	; $7ade
	ld hl,$cfc1		; $7ae0
	inc (hl)		; $7ae3
_label_0b_346:
	call interactionDecCounter1		; $7ae4
	ret nz			; $7ae7
	ld (hl),$3c		; $7ae8
	jp interactionIncState2		; $7aea
	ld hl,$cfc1		; $7aed
	inc (hl)		; $7af0
	ld a,SND_FADEOUT		; $7af1
	call playSound		; $7af3
	ld a,$04		; $7af6
	call fadeoutToWhiteWithDelay		; $7af8
	jp interactionIncState2		; $7afb
	ld hl,$cfc1		; $7afe
	inc (hl)		; $7b01
	ld a,(wPaletteThread_mode)		; $7b02
	or a			; $7b05
	ret nz			; $7b06
	call interactionIncState		; $7b07
	inc l			; $7b0a
	ld (hl),$00		; $7b0b
	jp objectSetInvisible		; $7b0d
	ld e,$45		; $7b10
	ld a,(de)		; $7b12
	rst_jumpTable			; $7b13
.dw $7b1e
.dw $7b5b
.dw $7b69
.dw $7b76
.dw $7b9f
	ld hl,@data		; $7b1e
@label_0b_347:
	ldi a,(hl)		; $7b21
	or a			; $7b22
	jr z,@label_0b_348	; $7b23
	ld c,(hl)		; $7b25
	inc hl			; $7b26
	push hl			; $7b27
	call setTile		; $7b28
	pop hl			; $7b2b
	jr @label_0b_347		; $7b2c
@label_0b_348:
	ld e,$46		; $7b2e
	ld a,$1e		; $7b30
	ld (de),a		; $7b32
	jp interactionIncState2		; $7b33

; @addr{7b36}
@data:
	.db $a3 $33 $a3 $34 $a3 $35 $b7 $43
	.db $b7 $44 $b7 $45 $88 $53 $88 $54
	.db $88 $55 $a3 $39 $a3 $3a $a3 $3b
	.db $b7 $49 $b7 $4a $b7 $4b $88 $59
	.db $88 $5a $88 $5b $00

	call interactionDecCounter1		; $7b5b
	ret nz			; $7b5e
	ld (hl),$78		; $7b5f
	ld a,$08		; $7b61
	call fadeinFromWhiteWithDelay		; $7b63
	jp interactionIncState2		; $7b66
	ld a,(wPaletteThread_mode)		; $7b69
	or a			; $7b6c
	ret nz			; $7b6d
	ld a,SND_SOLVEPUZZLE_2		; $7b6e
	call playSound		; $7b70
	jp interactionIncState2		; $7b73
	call interactionDecCounter1		; $7b76
	ret nz			; $7b79
	call getThisRoomFlags		; $7b7a
	set 6,(hl)		; $7b7d
	ld hl,$cf47		; $7b7f
	ld (hl),$44		; $7b82
	call checkIsLinkedGame		; $7b84
	jr z,_label_0b_349	; $7b87
	call fadeoutToBlack		; $7b89
	jp interactionIncState2		; $7b8c
_label_0b_349:
	xor a			; $7b8f
	ld (wMenuDisabled),a		; $7b90
	ld (wDisabledObjects),a		; $7b93
	ld a,(wActiveMusic)		; $7b96
	call playSound		; $7b99
	jp interactionDelete		; $7b9c
	ld a,(wPaletteThread_mode)		; $7b9f
	or a			; $7ba2
	ret nz			; $7ba3
	ld a,$11		; $7ba4
	ld (wCutsceneTrigger),a		; $7ba6
	jp interactionDelete		; $7ba9
	ld e,$44		; $7bac
	ld a,(de)		; $7bae
	rst_jumpTable			; $7baf
.dw $7bb8
.dw $7bd7
.dw $7be1
.dw $7be9
	ld a,$01		; $7bb8
	ld (de),a		; $7bba
	ld h,d			; $7bbb
	ld l,$46		; $7bbc
	ld (hl),$10		; $7bbe
	ld l,$50		; $7bc0
	ld (hl),$50		; $7bc2
	ld a,SND_POOF		; $7bc4
	call playSound		; $7bc6
	call objectCenterOnTile		; $7bc9
	ld l,$4e		; $7bcc
	xor a			; $7bce
	ldi (hl),a		; $7bcf
	ld (hl),a		; $7bd0
	call interactionInitGraphics		; $7bd1
	jp objectSetVisible80		; $7bd4
	call objectApplySpeed		; $7bd7
	call interactionDecCounter1		; $7bda
	ret nz			; $7bdd
	jp interactionIncState		; $7bde
	ld a,($cfc0)		; $7be1
	or a			; $7be4
	ret z			; $7be5
	jp interactionIncState		; $7be6
	call objectCheckWithinScreenBoundary		; $7be9
	jp nc,interactionDelete		; $7bec
	ld a,(wFrameCounter)		; $7bef
	rrca			; $7bf2
	ret c			; $7bf3
	ld h,d			; $7bf4
	ld l,$49		; $7bf5
	inc (hl)		; $7bf7
	ld a,(hl)		; $7bf8
	and $1f			; $7bf9
	ld (hl),a		; $7bfb
	ld e,l			; $7bfc
	or a			; $7bfd
	call z,$7c0a		; $7bfe
	ld bc,$5878		; $7c01
	ld a,($cfc1)		; $7c04
	jp objectSetPositionInCircleArc		; $7c07
	ld a,SND_CIRCLING		; $7c0a
	jp playSound		; $7c0c
	ld a,(wFrameCounter)		; $7c0f
	and $07			; $7c12
	ret nz			; $7c14
	ld bc,$8403		; $7c15
	call objectCreateInteraction		; $7c18
	ret nz			; $7c1b
	ld a,(wFrameCounter)		; $7c1c
	and $38			; $7c1f
	swap a			; $7c21
	rlca			; $7c23
	ld bc,$7c36		; $7c24
	call addDoubleIndexToBc		; $7c27
	ld l,$4b		; $7c2a
	ld a,(bc)		; $7c2c
	add (hl)		; $7c2d
	ld (hl),a		; $7c2e
	inc bc			; $7c2f
	ld l,$4d		; $7c30
	ld a,(bc)		; $7c32
	add (hl)		; $7c33
	ld (hl),a		; $7c34
	ret			; $7c35
	stop			; $7c36
	ld (bc),a		; $7c37
	stop			; $7c38
	cp $08			; $7c39
	dec b			; $7c3b
	ld ($0cfb),sp		; $7c3c
	ld ($f80c),sp		; $7c3f
	ld b,$0b		; $7c42
	ld b,$f5		; $7c44
	ld a,(wFrameCounter)		; $7c46
	and $07			; $7c49
	ret nz			; $7c4b
	ld a,(wFrameCounter)		; $7c4c
	and $38			; $7c4f
	swap a			; $7c51
	rlca			; $7c53
	ld hl,$7c5d		; $7c54
	rst_addAToHl			; $7c57
	ld e,$4f		; $7c58
	ld a,(hl)		; $7c5a
	ld (de),a		; $7c5b
	ret			; $7c5c
	rst $38			; $7c5d
	cp $ff			; $7c5e
	nop			; $7c60
	ld bc,$0102		; $7c61
	nop			; $7c64

interactionCoded8:
	ld e,$44		; $7c65
	ld a,(de)		; $7c67
	rst_jumpTable			; $7c68
.dw $7c73
.dw $7c89
.dw $7ce6
.dw $7d07
.dw $7d1a
	ld e,$42		; $7c73
	ld a,(de)		; $7c75
	ld hl,$7c81		; $7c76
	rst_addAToHl			; $7c79
	ld a,(hl)		; $7c7a
	ld e,$47		; $7c7b
	ld (de),a		; $7c7d
	jp interactionIncState		; $7c7e
	inc b			; $7c81
	ld b,$06		; $7c82
	ld b,$06		; $7c84
	ld b,$06		; $7c86
	ld b,$fa		; $7c88
	xor e			; $7c8a
	call z,$7fcb		; $7c8b
	ret z			; $7c8e
	call interactionIncState		; $7c8f
	ld l,$46		; $7c92
	ld (hl),$1e		; $7c94
	ld a,SND_SOLVEPUZZLE		; $7c96
	call playSound		; $7c98
	call $7cd9		; $7c9b
	ld b,$06		; $7c9e
	ld a,$c3		; $7ca0
	call findTileInRoom		; $7ca2
	jr z,_label_0b_350	; $7ca5
	ld a,$c6		; $7ca7
	call findTileInRoom		; $7ca9
	jr z,_label_0b_350	; $7cac
	ld b,$fa		; $7cae
	ld a,$c9		; $7cb0
	call findTileInRoom		; $7cb2
	jr z,_label_0b_350	; $7cb5
	ld a,$cc		; $7cb7
	call findTileInRoom		; $7cb9
_label_0b_350:
	ld a,b			; $7cbc
	ldh (<hFF8D),a	; $7cbd
	call $7cce		; $7cbf
_label_0b_351:
	inc l			; $7cc2
	ld a,(hl)		; $7cc3
	sub $c3			; $7cc4
	cp $0c			; $7cc6
	ret nc			; $7cc8
	call $7cce		; $7cc9
	jr _label_0b_351		; $7ccc
	ldh a,(<hFF8D)	; $7cce
	ld b,(hl)		; $7cd0
	add b			; $7cd1
	ld c,l			; $7cd2
	push hl			; $7cd3
	call setTile		; $7cd4
	pop hl			; $7cd7
	ret			; $7cd8
	ld e,$42		; $7cd9
	ld a,(de)		; $7cdb
	ld hl,miniScriptTable7d4a		; $7cdc
	rst_addDoubleIndex			; $7cdf
	ldi a,(hl)		; $7ce0
	ld h,(hl)		; $7ce1
	ld l,a			; $7ce2
	jp interactionSetMiniScript		; $7ce3
	call interactionDecCounter1		; $7ce6
	ret nz			; $7ce9
	inc l			; $7cea
	ldd a,(hl)		; $7ceb
	ld (hl),a		; $7cec
	call interactionGetMiniScript		; $7ced
	ldi a,(hl)		; $7cf0
	or a			; $7cf1
	jp z,interactionIncState		; $7cf2
_label_0b_352:
	ld c,a			; $7cf5
	ld a,$01		; $7cf6
	push hl			; $7cf8
	call setTileInAllBuffers		; $7cf9
	pop hl			; $7cfc
	ldi a,(hl)		; $7cfd
	or a			; $7cfe
	jr nz,_label_0b_352	; $7cff
	call interactionSetMiniScript		; $7d01
	jp $7d45		; $7d04
	ld a,(wLever1PullDistance)		; $7d07
	or a			; $7d0a
	ret nz			; $7d0b
	call interactionIncState		; $7d0c
	call $7cd9		; $7d0f
	call $7c9e		; $7d12
	ld a,SND_DOORCLOSE		; $7d15
	jp playSound		; $7d17
	call interactionDecCounter1		; $7d1a
	ret nz			; $7d1d
	inc l			; $7d1e
	ldd a,(hl)		; $7d1f
	ld (hl),a		; $7d20
	call interactionGetMiniScript		; $7d21
	ldi a,(hl)		; $7d24
	or a			; $7d25
	jr nz,_label_0b_353	; $7d26
	ld e,$44		; $7d28
	ld a,$01		; $7d2a
	ld (de),a		; $7d2c
	ret			; $7d2d
_label_0b_353:
	ld c,a			; $7d2e
	call getRandomNumber		; $7d2f
	and $03			; $7d32
	add $61			; $7d34
	push hl			; $7d36
	call setTileInAllBuffers		; $7d37
	pop hl			; $7d3a
	ldi a,(hl)		; $7d3b
	or a			; $7d3c
	jr nz,_label_0b_353	; $7d3d
	call interactionSetMiniScript		; $7d3f
	jp $7d45		; $7d42
	ld a,SND_RUMBLE2		; $7d45
	jp playSound		; $7d47

; @addr{7d4a}
miniScriptTable7d4a:
	.dw miniScript7d56
	.dw miniScript7da9
	.dw miniScript7dff
	.dw miniScript7e3a
	.dw miniScript7e7c
	.dw miniScript7ef0

; @addr{7d56}
miniScript7d56:
	.db $2a $00 $2b $00 $29 $00 $3b $00
	.db $39 $00 $4b $00 $4a $00 $49 $00
	.db $5b $00 $5a $00 $59 $00 $6b $00
	.db $6a $00 $7b $00 $8b $00 $7a $00
	.db $8a $00 $9a $00 $69 $00 $99 $00
	.db $89 $00 $79 $00 $98 $00 $88 $00
	.db $97 $00 $78 $00 $96 $00 $88 $00
	.db $87 $00 $95 $00 $86 $00 $85 $00
	.db $77 $00 $76 $00 $75 $00 $66 $00
	.db $65 $00 $56 $00 $55 $00 $45 $00
	.db $35 $00 $00

; @addr{7da9}
miniScript7da9:
	.db $77 $78 $79 $00 $7a $69 $68 $67
	.db $66 $76 $00 $6a $65 $75 $00 $64
	.db $74 $00 $84 $85 $00 $94 $95 $00
	.db $83 $93 $00 $82 $92 $00 $81 $91
	.db $00 $71 $72 $00 $61 $62 $00 $51
	.db $52 $00 $41 $42 $00 $31 $32 $00
	.db $21 $22 $00 $11 $12 $00 $13 $23
	.db $00 $14 $24 $00 $34 $00 $44 $00
	.db $35 $45 $00 $36 $00 $46 $00 $47
	.db $26 $00 $16 $27 $48 $00 $28 $38
	.db $49 $00 $29 $39 $00 $00

; @addr{7dff}
miniScript7dff:
	.db $37 $38 $39 $00 $47 $48 $49 $00
	.db $58 $59 $00 $68 $00 $67 $00 $77
	.db $00 $87 $00 $96 $00 $85 $00 $75
	.db $00 $55 $64 $00 $56 $00 $73 $45
	.db $00 $83 $35 $00 $25 $00 $92 $15
	.db $00 $81 $00 $71 $00 $61 $00 $51
	.db $00 $42 $00 $33 $00 $13 $22 $00
	.db $21 $00 $00

; @addr{7e3a}
miniScript7e3a:
	.db $24 $25 $26 $00 $34 $35 $36 $00
	.db $44 $45 $46 $00 $54 $55 $00 $64
	.db $65 $00 $73 $74 $75 $00 $83 $00
	.db $81 $82 $00 $91 $92 $00 $93 $00
	.db $94 $00 $95 $00 $96 $00 $86 $00
	.db $77 $87 $97 $00 $78 $88 $00 $79
	.db $89 $99 $00 $7a $8a $9a $00 $6a
	.db $00 $5a $00 $59 $00 $58 $00 $48
	.db $00 $00

; @addr{7e7c}
miniScript7e7c:
	.db $24 $25 $26 $00 $34 $35 $17 $27
	.db $00 $36 $37 $00 $44 $45 $46 $47
	.db $00 $18 $28 $38 $48 $00 $57 $58
	.db $39 $49 $00 $55 $56 $19 $29 $00
	.db $54 $59 $00 $68 $69 $4a $5a $00
	.db $67 $3a $6a $00 $65 $66 $1a $2a
	.db $00 $64 $6b $7a $7b $00 $78 $79
	.db $4b $5b $00 $76 $77 $2b $3b $00
	.db $74 $75 $1b $00 $8a $8b $5c $6c
	.db $00 $88 $89 $3c $4c $00 $86 $87
	.db $1c $2c $00 $84 $85 $5d $6d $00
	.db $73 $83 $4d $00 $1d $2d $3d $00
	.db $71 $72 $82 $00 $81 $97 $99 $9b
	.db $00 $91 $92 $93 $95 $00 $94 $96
	.db $98 $9a $00 $00

; @addr{7ef0}
miniScript7ef0:
	.db $26 $28 $27 $00 $25 $00 $35 $00
	.db $34 $00 $44 $54 $43 $00 $42 $64
	.db $00 $52 $74 $00 $84 $00 $93 $94
	.db $95 $00 $92 $96 $00 $82 $91 $97
	.db $00 $81 $87 $00 $77 $88 $00 $78
	.db $89 $00 $8a $00 $7a $8b $00 $6a
	.db $7b $8c $00 $5a $8d $9c $00 $5b
	.db $9d $00 $5c $00 $4c $5d $6c $00
	.db $6d $00 $3c $00 $3d $00 $2b $2d
	.db $00 $1b $1d $00 $00


interactionCodedb:
	ld e,$44		; $7f3d
	ld a,(de)		; $7f3f
	rst_jumpTable			; $7f40
.dw $7f47
.dw $7f60
.dw $7f9a
	ld e,$42		; $7f47
	ld a,(de)		; $7f49
	ld bc,bitTable		; $7f4a
	add c			; $7f4d
	ld c,a			; $7f4e
	call getThisRoomFlags		; $7f4f
	ld a,(bc)		; $7f52
	and (hl)		; $7f53
	jp nz,interactionDelete		; $7f54
	ld hl,script7f5a		; $7f57
	call interactionSetScript		; $7f5a
	jp interactionIncState		; $7f5d
	call objectCheckCollidedWithLink_notDead		; $7f60
	call nc,$7f7e		; $7f63
	call objectCheckLinkPushingAgainstCenter		; $7f66
	call nc,$7f7e		; $7f69
	ld h,d			; $7f6c
	ld l,$7f		; $7f6d
	dec (hl)		; $7f6f
	jr nz,_label_0b_360	; $7f70
	ld a,(wNumSlates)		; $7f72
	or a			; $7f75
	jr nz,_label_0b_359	; $7f76
	ld bc,$5111		; $7f78
	call showText		; $7f7b
_label_0b_358:
	ld e,$7f		; $7f7e
	ld a,$0a		; $7f80
	ld (de),a		; $7f82
	ret			; $7f83
_label_0b_359:
	call checkLinkVulnerable		; $7f84
	jr nc,_label_0b_358	; $7f87
	ld a,$81		; $7f89
	ld (wDisabledObjects),a		; $7f8b
	ld (wMenuDisabled),a		; $7f8e
	ld hl,script7f5d		; $7f91
	call interactionSetScript		; $7f94
	call interactionIncState		; $7f97
_label_0b_360:
	call interactionRunScript		; $7f9a
	ret nc			; $7f9d
	jp interactionDelete		; $7f9e


.ifdef BUILD_VANILLA

; Garbage function here (partial repeat of the above function)

;;
; @addr{7fa1}
func_7fa1:
	call $258f		; $7fa1
	ret nc			; $7fa4
	jp $3b5c		; $7fa5

.endif

.BANK $0c SLOT 1
.ORG 0

	.include "code/scripting.s"
	.include "scripts/ages/scripts.s"


.BANK $0d SLOT 1
.ORG 0

 m_section_free Enemy_Code_Bank0d NAMESPACE bank0d

	.include "code/enemyCommon.s"

; ==============================================================================
; ENEMYID_RIVER_ZORA
; ==============================================================================
enemyCode08:
	jr z,@normalStatus	; $44f0
	sub ENEMYSTATUS_NO_HEALTH			; $44f2
	ret c			; $44f4
	jp z,enemyDie		; $44f5

@normalStatus:
	ld e,Enemy.state		; $44f8
	ld a,(de)		; $44fa
	rst_jumpTable			; $44fb
	.dw @state_uninitialized
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_08
	.dw @state_09
	.dw @state_0a
	.dw @state_0b

@state_uninitialized:
	ld a,$09		; $4514
	ld (de),a		; $4516
	ret			; $4517

@state_stub:
	ret			; $4518


; Waiting under the water until time to resurface
@state_08:
	call _ecom_decCounter1		; $4519
	ret nz			; $451c
	ld l,e			; $451d
	inc (hl)		; $451e
	ret			; $451f


; Resurfacing in a random position
@state_09:
	call getRandomNumber_noPreserveVars		; $4520
	cp (SCREEN_WIDTH<<4)-8			; $4523
	ret nc			; $4525

	ld c,a			; $4526
	ldh a,(<hCameraX)	; $4527
	add c			; $4529
	ld c,a			; $452a

	ldh a,(<hCameraY)	; $452b
	ld b,a			; $452d
	ldh a,(<hRng2)	; $452e
	res 7,a			; $4530
	add b			; $4532
	ld b,a			; $4533

	call checkTileAtPositionIsWater		; $4534
	ret nc			; $4537

	; Tile is water; spawn here.
	ld c,l			; $4538
	call objectSetShortPosition		; $4539
	ld l,Enemy.counter1		; $453c
	ld (hl),48		; $453e

	ld l,Enemy.state		; $4540
	inc (hl) ; [state] = $0a

	xor a			; $4543
	call enemySetAnimation		; $4544
	jp objectSetVisible83		; $4547


; In the process of surfacing.
@state_0a:
	call _ecom_decCounter1		; $454a
	jr nz,@animate	; $454d

	; Surfaced; enable collisions & set animation.
	ld l,e			; $454f
	inc (hl)		; $4550
	ld l,Enemy.collisionType		; $4551
	set 7,(hl)		; $4553
	ld a,$01		; $4555
	jp enemySetAnimation		; $4557


; Above water, waiting until time to fire projectile.
@state_0b:
	ld h,d			; $455a
	ld l,Enemy.animParameter		; $455b
	ld a,(hl)		; $455d
	inc a			; $455e
	jr z,@disappear	; $455f

	dec a			; $4561
	jr z,@animate	; $4562

	; Make projectile
	ld (hl),$00		; $4564
	ld b,PARTID_ZORA_FIRE		; $4566
	call _ecom_spawnProjectile		; $4568
	jr nz,@animate	; $456b
	ld l,Part.subid		; $456d
	inc (hl)		; $456f

@animate:
	jp enemyAnimate		; $4570

@disappear:
	ld a,$08		; $4573
	ld (de),a ; [state] = 8

	ld l,Enemy.collisionType		; $4576
	res 7,(hl)		; $4578

	call getRandomNumber_noPreserveVars		; $457a
	and $1f			; $457d
	add $18			; $457f
	ld e,Enemy.counter1		; $4581
	ld (de),a		; $4583

	ld b,INTERACID_SPLASH		; $4584
	call objectCreateInteractionWithSubid00		; $4586
	jp objectSetInvisible		; $4589


; ==============================================================================
; ENEMYID_OCTOROK
;
; Variables:
;   counter1: How many frames to wait after various actions.
;   var30: How many frames to walk for.
;   var32: Should be 1, 3, or 7. Lower values make the octorok move and shoot more often.
; ==============================================================================
enemyCode09:
	call _ecom_checkHazards		; $458c
	jr z,@normalStatus	; $458f

	sub ENEMYSTATUS_NO_HEALTH			; $4591
	ret c			; $4593
	jr z,@dead	; $4594

	; Check ENEMYSTATUS_KNOCKBACK
	dec a			; $4596
	jp nz,_ecom_updateKnockbackAndCheckHazards		; $4597
	ret			; $459a

@dead:
	ld e,Enemy.subid		; $459b
	ld a,(de)		; $459d
	cp $04			; $459e
	jr nz,++		; $45a0
	ld hl,wKilledGoldenEnemies		; $45a2
	set 0,(hl)		; $45a5
++
	jp enemyDie		; $45a7

@normalStatus:
	call _ecom_checkScentSeedActive		; $45aa
	ld e,Enemy.state		; $45ad
	ld a,(de)		; $45af
	rst_jumpTable			; $45b0
	.dw _octorok_state_uninitialized
	.dw _octorok_state_stub
	.dw _octorok_state_stub
	.dw _octorok_state_latchedBySwitchHook
	.dw _octorok_state_followingScentSeed
	.dw _ecom_blownByGaleSeedState
	.dw _octorok_state_stub
	.dw _octorok_state_stub
	.dw _octorok_state_08
	.dw _octorok_state_09
	.dw _octorok_state_0a
	.dw _octorok_state_0b


_octorok_state_uninitialized:
	; Delete self if it's a golden enemy that's been defeated
	ld e,Enemy.subid		; $45c9
	ld a,(de)		; $45cb
	cp $04			; $45cc
	jr nz,++		; $45ce
	ld hl,wKilledGoldenEnemies		; $45d0
	bit 0,(hl)		; $45d3
	jp nz,enemyDelete		; $45d5
++
	; If bit 1 of subid is set, octorok is faster
	rrca			; $45d8
	ld a,SPEED_80		; $45d9
	jr nc,+			; $45db
	ld a,SPEED_c0		; $45dd
+
	call _ecom_setSpeedAndState8AndVisible		; $45df
	ld (hl),$0a ; [state] = $0a

	; Enable moving toward scent seeds
	ld l,Enemy.var3f		; $45e4
	set 4,(hl)		; $45e6

	; Determine range of possible counter1 values, read into 'e' and 'var32'.
	ld e,Enemy.subid		; $45e8
	ld a,(de)		; $45ea
	ld hl,@counter1Ranges		; $45eb
	rst_addAToHl			; $45ee
	ld e,Enemy.var32		; $45ef
	ld a,(hl)		; $45f1
	ld (de),a		; $45f2

	; Decide random counter1, angle, and var30.
	ld e,a			; $45f3
	ldbc $18,$03		; $45f4
	call _ecom_randomBitwiseAndBCE		; $45f7
	ld a,e			; $45fa
	ld hl,_octorok_counter1Values		; $45fb
	rst_addAToHl			; $45fe
	ld e,Enemy.counter1		; $45ff
	ld a,(hl)		; $4601
	ld (de),a		; $4602

	; Random initial angle
	ld e,Enemy.angle		; $4603
	ld a,b			; $4605
	ld (de),a		; $4606

	ld a,c			; $4607
	ld hl,_octorok_walkCounterValues		; $4608
	rst_addAToHl			; $460b
	ld e,Enemy.var30		; $460c
	ld a,(hl)		; $460e
	ld (de),a		; $460f
	jp _ecom_updateAnimationFromAngle		; $4610


; For each subid, each byte determines the maximum index of the value that can be read
; from "_octorok_counter1Values" below. Effectively, lower values attack more often.
@counter1Ranges:
	.db $07 $07 $03 $03 $01


_octorok_state_followingScentSeed:
	ld a,(wScentSeedActive)	; $4618
	or a			; $461b
	jr nz,++		; $461c
	ld a,$08		; $461e
	ld (de),a ; [state] = 8
	ret			; $4621
++
	; Set angle toward scent seed (must be cardinal direction)
	call _ecom_updateAngleToScentSeed		; $4622
	ld e,Enemy.angle		; $4625
	ld a,(de)		; $4627
	add $04			; $4628
	and $18			; $462a
	ld (de),a		; $462c

	call _ecom_updateAnimationFromAngle		; $462d
	call _ecom_applyVelocityForTopDownEnemy		; $4630
	jp enemyAnimate		; $4633


_octorok_state_latchedBySwitchHook:
	inc e			; $4636
	ld a,(de)		; $4637
	rst_jumpTable			; $4638
	.dw _ecom_incState2
	.dw @substate1
	.dw @substate2
	.dw _ecom_fallToGroundAndSetState8

@substate1:
@substate2:
	ret			; $4641

_octorok_state_stub:
	ret			; $4642


; State 8: Octorok decides what to do next after previous action
_octorok_state_08:
	; Decide whether to move or shoot based on [var32] & [random number]. If var32 is
	; low, this means it will shoot more often.
	call getRandomNumber_noPreserveVars		; $4643
	ld h,d			; $4646
	ld l,Enemy.var32		; $4647
	and (hl)		; $4649
	ld l,Enemy.state		; $464a
	jr nz,@standStill	; $464c

	; Shoot a projectile after [counter1] frames
	ld (hl),$0b ; [state] = $0b
	ld l,Enemy.counter1		; $4650
	ld (hl),$10		; $4652

	; Blue and golden octoroks change direction to face Link before shooting
	ld l,Enemy.subid		; $4654
	ld a,(hl)		; $4656
	cp $02			; $4657
	ret c			; $4659
	call _ecom_updateCardinalAngleTowardTarget		; $465a
	jp _ecom_updateAnimationFromAngle		; $465d

@standStill:
	inc (hl) ; [state] = $09
	ld bc,_octorok_counter1Values		; $4661
	call addAToBc		; $4664
	ld l,Enemy.counter1		; $4667
	ld a,(bc)		; $4669
	ld (hl),a		; $466a
	ret			; $466b


; A random value for counter1 is chosen from here when the octorok changes direction?
; Red octoroks read the whole range, blue octoroks only the first 4, golden ones only the
; first 2.
; Effectively, blue & golden octoroks move more often.
_octorok_counter1Values:
	.db 30 45 60 75 45 60 75 90


; State 9: Standing still for [counter1] frames.
_octorok_state_09:
	call _ecom_decCounter1		; $4674
	ret nz			; $4677

	ld l,e			; $4678
	inc (hl) ; [state] = $0a (Walking)

	ld e,$03		; $467a
	ld bc,$0318		; $467c
	call _ecom_randomBitwiseAndBCE		; $467f

	; Randomly set how many frames to walk
	ld a,e			; $4682
	ld hl,_octorok_walkCounterValues		; $4683
	rst_addAToHl			; $4686
	ld a,(hl)		; $4687
	ld e,Enemy.var30		; $4688
	ld (de),a		; $468a

	; Set random angle
	ld e,Enemy.angle		; $468b
	ld a,c			; $468d
	ld (de),a		; $468e

	; 1 in 4 chance of changing direction toward Link (overriding previous angle)
	ld a,b			; $468f
	or a			; $4690
	call z,_ecom_updateCardinalAngleTowardTarget		; $4691
	jp _ecom_updateAnimationFromAngle		; $4694


; Values for var30 (how many frames to walk).
_octorok_walkCounterValues:
	.db $19 $21 $29 $31


; State $0a: Octorok is walking for [var30] frames.
_octorok_state_0a:
	ld h,d			; $469b
	ld l,Enemy.var30		; $469c
	dec (hl)		; $469e
	jr nz,++		; $469f

	ld l,e			; $46a1
	ld (hl),$08 ; [state] = $08
	ret			; $46a4
++
	call _ecom_applyVelocityForTopDownEnemyNoHoles		; $46a5
	jr nz,++		; $46a8

	; Stopped moving, set new angle
	call _ecom_setRandomCardinalAngle		; $46aa
	call _ecom_updateAnimationFromAngle		; $46ad
++
	jp enemyAnimate		; $46b0


; State $0b: Waiting [counter1] frames, then shooting a projectile
_octorok_state_0b:
	call _ecom_decCounter1		; $46b3
	ret nz			; $46b6

	ld (hl),$20 ; [counter1] = $20 (wait this many frames after shooting)
	ld l,e			; $46b9
	ld (hl),$09 ; [state] = $09

	ld b,PARTID_OCTOROK_PROJECTILE		; $46bc
	call _ecom_spawnProjectile		; $46be
	ret nz			; $46c1
	ld a,SND_THROW		; $46c2
	jp playSound		; $46c4


; ==============================================================================
; ENEMYID_BOOMERANG_MOBLIN
; ==============================================================================
enemyCode0a:
	call _ecom_checkHazards		; $46c7
	jr z,@normalStatus	; $46ca

	sub ENEMYSTATUS_NO_HEALTH			; $46cc
	ret c			; $46ce
	jr z,@dead	; $46cf
	dec a			; $46d1
	jp nz,_ecom_updateKnockbackAndCheckHazards		; $46d2
	ret			; $46d5

@dead:
	ld e,Enemy.relatedObj2+1		; $46d6
	ld a,(de)		; $46d8
	or a			; $46d9
	jr z,++			; $46da
	ld h,a			; $46dc
	ld l,Part.relatedObj1+1		; $46dd
	ld (hl),$ff		; $46df
++
	jp enemyDie		; $46e1

@normalStatus:
	call _ecom_checkScentSeedActive		; $46e4
	ld e,Enemy.state		; $46e7
	ld a,(de)		; $46e9
	rst_jumpTable			; $46ea
	.dw @state_uninitialized
	.dw @state_stub
	.dw @state_stub
	.dw @state_switchHook
	.dw @state_scentSeed
	.dw _ecom_blownByGaleSeedState
	.dw @state_stub
	.dw @state_stub
	.dw @state_8
	.dw @state_9
	.dw @state_a


@state_uninitialized:
	ld a,SPEED_80		; $4701
	call _ecom_setSpeedAndState8AndVisible		; $4703
	ld l,Enemy.var3f		; $4706
	set 4,(hl)		; $4708
	jp @gotoState8WithRandomAngleAndCounter		; $470a


@state_scentSeed:
	ld a,(wScentSeedActive)		; $470d
	or a			; $4710
	jp z,@gotoState8WithRandomAngleAndCounter		; $4711

	call _ecom_updateAngleToScentSeed		; $4714
	ld e,Enemy.angle		; $4717
	ld a,(de)		; $4719
	add $04			; $471a
	and $18			; $471c
	ld (de),a		; $471e

	call _ecom_updateAnimationFromAngle		; $471f
	call _ecom_applyVelocityForSideviewEnemy		; $4722
	jp enemyAnimate		; $4725


@state_switchHook:
	inc e			; $4728
	ld a,(de)		; $4729
	rst_jumpTable			; $472a
	.dw _ecom_incState2
	.dw @@substate1
	.dw @@substate2
	.dw @@substate3

@@substate1:
@@substate2:
	ret			; $4733

@@substate3:
	ld b,$0a		; $4734
	jp _ecom_fallToGroundAndSetState		; $4736

@state_stub:
	ret			; $4739


; Moving until counter1 reaches 0
@state_8:
	call _ecom_decCounter1		; $473a
	jr z,++		; $473d
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $473f
	jr nz,@animate	; $4742
++
	ld e,Enemy.state		; $4744
	ld a,$09		; $4746
	ld (de),a		; $4748
@animate:
	jp enemyAnimate		; $4749


; Shoot a boomerang if Link is in that general direction; otherwise go back to state 8.
@state_9:
	call @gotoState8WithRandomAngleAndCounter		; $474c
	call objectGetAngleTowardEnemyTarget		; $474f
	add $04			; $4752
	and $18			; $4754
	swap a			; $4756
	rlca			; $4758
	ld h,d			; $4759
	ld l,Enemy.direction		; $475a
	cp (hl)			; $475c
	ret nz			; $475d

	; Spawn projectile
	ld b,PARTID_MOBLIN_BOOMERANG		; $475e
	call _ecom_spawnProjectile		; $4760
	ret nz			; $4763
	ld h,d			; $4764
	ld l,Enemy.state		; $4765
	ld (hl),$0a		; $4767
	ret			; $4769


; Waiting for boomerang to return
@state_a:
	ld e,Enemy.relatedObj2+1		; $476a
	ld a,(de)		; $476c
	or a			; $476d
	jr nz,@animate	; $476e

@gotoState8WithRandomAngleAndCounter:
	call getRandomNumber_noPreserveVars		; $4770
	and $03			; $4773
	ld hl,@counterVals		; $4775
	rst_addAToHl			; $4778
	ld e,Enemy.counter1		; $4779
	ld a,(hl)		; $477b
	ld (de),a		; $477c
	ld e,Enemy.state		; $477d
	ld a,$08		; $477f
	ld (de),a		; $4781
	call _ecom_setRandomCardinalAngle		; $4782
	jp _ecom_updateAnimationFromAngle		; $4785

@counterVals:
	.db $30 $40 $50 $60


; ==============================================================================
; ENEMYID_LEEVER
; ==============================================================================
enemyCode0b:
	call _ecom_checkHazards		; $478c
	jr z,@normalStatus	; $478f
	sub $03			; $4791
	ret c			; $4793
	jr z,@dead	; $4794
	dec a			; $4796
	jp nz,_ecom_updateKnockbackAndCheckHazards		; $4797
	ret			; $479a

@dead:
	ld e,Enemy.subid		; $479b
	ld a,(de)		; $479d
	cp $02			; $479e
	jr nz,@die	; $47a0

	; This is a respawning leever (subid 2), so spawn a new one
	ld b,ENEMYID_LEEVER		; $47a2
	call _ecom_spawnEnemyWithSubid01		; $47a4
	ret nz			; $47a7

	inc (hl) ; [child.subid] = 2

	; Set Y/X
	ld e,Enemy.var30		; $47a9
	ld l,Enemy.yh		; $47ab
	ld a,(de)		; $47ad
	ldi (hl),a		; $47ae
	inc e			; $47af
	inc l			; $47b0
	ld a,(de)		; $47b1
	ld (hl),a		; $47b2
@die:
	jp enemyDie		; $47b3

@normalStatus:
	call _ecom_getSubidAndCpStateTo08		; $47b6
	jr nc,@normalState	; $47b9
	rst_jumpTable			; $47bb
	.dw @state_uninitialized
	.dw @state_stub
	.dw @state_stub
	.dw @state_switchHook
	.dw @state_stub
	.dw _ecom_blownByGaleSeedState
	.dw @state_stub
	.dw @state_stub


@normalState:
	ld a,b			; $47cc
	rst_jumpTable			; $47cd
	.dw @normalState_subid00
	.dw @normalState_subid01
	.dw @normalState_subid02


@state_uninitialized:
	call @setRandomCounter1		; $47d4
	jp _ecom_setSpeedAndState8		; $47d7


@state_switchHook:
	inc e			; $47da
	ld a,(de)		; $47db
	rst_jumpTable			; $47dc
	.dw _ecom_incState2
	.dw @@substate1
	.dw @@substate2
	.dw @@substate3

@@substate1:
@@substate2:
	ret			; $47e5

@@substate3:
	ld e,Enemy.subid		; $47e6
	ld a,(de)		; $47e8
	ld hl,@@destStates		; $47e9
	rst_addAToHl			; $47ec
	ld b,(hl)		; $47ed
	jp _ecom_fallToGroundAndSetState		; $47ee

@@destStates:
	.db $0a $0a $0a


@state_stub:
	ret			; $47f4


@normalState_subid00:
	ld a,(de)		; $47f5
	sub $08			; $47f6
	rst_jumpTable			; $47f8
	.dw @state8
	.dw @state9
	.dw @subid00_stateA
	.dw @stateB


; Underground until counter1 reaches 0.
@state8:
	call _ecom_decCounter1		; $4801
	ret nz			; $4804
	inc (hl)		; $4805

	call @chooseSpawnPosition		; $4806
	ret nz			; $4809
	call objectSetShortPosition		; $480a
	ld l,Enemy.state		; $480d
	inc (hl) ; [state] = 9
	xor a			; $4810
	call enemySetAnimation		; $4811
	jp objectSetVisiblec2		; $4814


; Emerging from the ground.
@state9:
	ld h,d			; $4817
	ld l,Enemy.animParameter		; $4818
	ld a,(hl)		; $481a
	dec a			; $481b
	jr nz,@animate		; $481c

	; [animParameter] == 1; fully emerged.
	ld l,e			; $481e
	inc (hl)		; $481f
	ld l,Enemy.collisionType		; $4820
	set 7,(hl)		; $4822

	ld l,Enemy.speed		; $4824
	ld (hl),SPEED_80		; $4826
	call _ecom_updateCardinalAngleTowardTarget		; $4828
	call @setRandomHighCounter1		; $482b
@animate:
	jp enemyAnimate		; $482e


; Chasing Link.
@subid00_stateA:
	call _ecom_decCounter1		; $4831
	jp nz,@updatePosition		; $4834

@backIntoGround:
	call _ecom_incState
	ld l,Enemy.collisionType		; $483a
	res 7,(hl)		; $483c
	ld l,Enemy.speed		; $483e
	ld (hl),SPEED_20		; $4840
	ld a,$02		; $4842
	jp enemySetAnimation		; $4844


; Sinking back into the ground.
@stateB:
	ld h,d			; $4847
	ld l,Enemy.animParameter		; $4848
	ld a,(hl)		; $484a
	dec a			; $484b
	jr nz,@animate	; $484c

	; [animParameter] == 1: Fully disappeared.
	ld l,e			; $484e
	ld (hl),$08		; $484f
	call @setRandomCounter1		; $4851
	jp objectSetInvisible		; $4854


@normalState_subid01:
	ld a,(de)		; $4857
	sub $08			; $4858
	rst_jumpTable			; $485a
	.dw @state8
	.dw @state9
	.dw @subid01_stateA
	.dw @stateB


; Chasing Link.
; (Same as subid 0's state A, except this sometimes "snaps" its angle back to Link
; immediately, making it more responsive?)
@subid01_stateA:
	call _ecom_decCounter1		; $4863
	jp z,@backIntoGround		; $4866
	call getRandomNumber_noPreserveVars		; $4869
	cp $14			; $486c
	jp nc,@updatePosition		; $486e
	call _ecom_updateCardinalAngleTowardTarget		; $4871
	jp @updatePosition		; $4874


; Respawning leever
@normalState_subid02:
	ld a,(de)		; $4877
	sub $08			; $4878
	rst_jumpTable			; $487a
	.dw @subid02_state8
	.dw @subid02_state9
	.dw @subid02_stateA
	.dw @subid02_stateB
	.dw @subid02_stateC

@subid02_state8:
	ld h,d			; $4885
	ld l,e			; $4886
	inc (hl) ; [state] = 9

	ld l,Enemy.counter1		; $4888
	ld a,(hl)		; $488a
	and $30			; $488b
	add $60			; $488d
	ld (hl),a		; $488f

	; Save initial position to var30/var31 so it can be restored when respawning.
	ld e,Enemy.yh		; $4890
	ld l,Enemy.var30		; $4892
	ld a,(de)		; $4894
	ldi (hl),a		; $4895
	ld e,Enemy.xh		; $4896
	ld a,(de)		; $4898
	ld (hl),a		; $4899
	ret			; $489a

; In ground, waiting until time to spawn.
@subid02_state9:
	call _ecom_decCounter1		; $489b
	ret nz			; $489e
	inc l			; $489f
	ld (hl),$06 ; [counter2] = 6
	ld l,e			; $48a2
	inc (hl) ; [state] = $0a
	xor a			; $48a4
	call enemySetAnimation		; $48a5
	jp objectSetVisiblec2		; $48a8


; Emerging from ground.
@subid02_stateA:
	ld e,Enemy.animParameter		; $48ab
	ld a,(de)		; $48ad
	dec a			; $48ae
	jr nz,@animate2	; $48af

	; [animParameter] == 1; fully emerged.

	ld h,d			; $48b1
	ld l,Enemy.state		; $48b2
	inc (hl) ; [state] = $0b

	ld l,Enemy.collisionType		; $48b5
	set 7,(hl)		; $48b7

	ld l,Enemy.speed		; $48b9
	ld (hl),SPEED_a0		; $48bb
	call _ecom_updateCardinalAngleTowardTarget		; $48bd
	call @setRandomHighCounter1		; $48c0
	jr @animate2		; $48c3


; Chasing Link. Unlike other leever types, if this hits a wall, it doesn't sink back into
; the ground until its timer is up.
@subid02_stateB:
	call _ecom_decCounter1		; $48c5
	jp z,@backIntoGround		; $48c8
	call @nudgeTowardsLink		; $48cb
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $48ce
@animate2:
	jp enemyAnimate		; $48d1


; Sinking back into ground.
@subid02_stateC:
	ld e,Enemy.animParameter		; $48d4
	ld a,(de)		; $48d6
	dec a			; $48d7
	jr nz,@animate2	; $48d8

	; [animParameter] == 1; fully disappeared.

	ld e,Enemy.state		; $48da
	ld a,$09		; $48dc
	ld (de),a		; $48de
	call @setRandomCounter1		; $48df
	jp objectSetInvisible		; $48e2


;;
; Updates position, checks for collision with wall (or hole).
; @addr{48e5}
@updatePosition:
	ld a,$01 ; Set to $01 to treat holes as walls
	call _ecom_getTopDownAdjacentWallsBitset		; $48e7
	jp nz,@backIntoGround		; $48ea
	call objectApplySpeed		; $48ed
	jp enemyAnimate		; $48f0

;;
; @param	b	Subid. if 0, it spawns relative to Link's position & direction;
;			otherwise it spawns in a completely random position.
; @param[out]	c	Position
; @param[out]	zflag	z if a valid position was returned
; @addr{48f3}
@chooseSpawnPosition:
	ld a,b			; $48f3
	or a			; $48f4
	jr nz,@@chooseRandomSpot	; $48f5

	; Spawn in relative to Link's position.

	ld de,w1Link.yh		; $48f7
	call getShortPositionFromDE		; $48fa
	ld c,a			; $48fd
	ld e,<w1Link.direction		; $48fe
	ld a,(de)		; $4900
	rlca			; $4901
	rlca			; $4902
	ld hl,@@linkRelativeOffsets		; $4903
	rst_addAToHl			; $4906
	ld a,(wFrameCounter)		; $4907
	and $03			; $490a
	rst_addAToHl			; $490c
	ldh a,(<hActiveObject)	; $490d
	ld d,a			; $490f
	ld a,c			; $4910
	add (hl)		; $4911
	ld c,a			; $4912

	; We have a candidate position; check for validity. NOTE: Assumes small room.
	and $f0			; $4913
	cp SMALL_ROOM_HEIGHT<<4			; $4915
	jr nc,@@invalid		; $4917
	ld a,c			; $4919
	and $0f			; $491a
	cp SMALL_ROOM_WIDTH			; $491c
	jr nc,@@invalid		; $491e

	ld b,>wRoomCollisions		; $4920
	ld a,(bc)		; $4922
	or a			; $4923
	ret			; $4924

@@invalid:
	or d			; $4925
	ret			; $4926

; Each of Link's directions has 4 candidates, one is chosen randomly.
@@linkRelativeOffsets:
	.db $d0 $c0 $b0 $b0 ; DIR_UP
	.db $03 $04 $05 $05 ; DIR_RIGHT
	.db $30 $40 $50 $50 ; DIR_DOWN
	.db $fd $fc $fb $fb ; DIR_LEFT

@@chooseRandomSpot:
	call getRandomNumber_noPreserveVars		; $4937
	and $77			; $493a
	ld c,a			; $493c
	ld b,>wRoomCollisions		; $493d
	ld a,(bc)		; $493f
	or a			; $4940
	ret			; $4941


@setRandomCounter1:
	call getRandomNumber_noPreserveVars		; $4942
	and $03			; $4945
	ld hl,@counter1Vals		; $4947
	rst_addAToHl			; $494a
	ld e,Enemy.counter1		; $494b
	ld a,(hl)		; $494d
	ld (de),a		; $494e
	ret			; $494f

@counter1Vals:
	.db $10 $30 $50 $70

@setRandomHighCounter1:
	call getRandomNumber_noPreserveVars		; $4954
	ld e,Enemy.counter1		; $4957
	and $38			; $4959
	add $70			; $495b
	ld (de),a		; $495d
	ret			; $495e

@nudgeTowardsLink:
	call _ecom_decCounter2		; $495f
	ret nz			; $4962
	ld (hl),$06		; $4963
	call objectGetAngleTowardEnemyTarget		; $4965
	jp objectNudgeAngleTowards		; $4968


; ==============================================================================
; ENEMYID_ARROW_MOBLIN
; ENEMYID_MASKED_MOBLIN
; ENEMYID_ARROW_SHROUDED_STALFOS
;
; These enemies and ENEMYID_ARROW_DARKNUT share some code.
; ==============================================================================
enemyCode0c:
enemyCode20:
enemyCode22:
	call _ecom_checkHazards		; $496b
	jr z,@normalStatus	; $496e

	sub ENEMYSTATUS_NO_HEALTH			; $4970
	ret c			; $4972
	jr z,@dead	; $4973
	dec a			; $4975
	jp nz,_ecom_updateKnockbackAndCheckHazards		; $4976
	ret			; $4979
@dead:
	ld e,Enemy.subid		; $497a
	ld a,(de)		; $497c
	cp $02			; $497d
	jr nz,++		; $497f
	ld hl,wKilledGoldenEnemies		; $4981
	set 1,(hl)		; $4984
++
	jp enemyDie		; $4986

@normalStatus:
	call _ecom_checkScentSeedActive		; $4989
	ld e,Enemy.state		; $498c
	ld a,(de)		; $498e
	rst_jumpTable			; $498f
	.dw _moblin_state_uninitialized
	.dw _moblin_state_stub
	.dw _moblin_state_stub
	.dw _moblin_state_switchHook
	.dw _moblin_state_scentSeed
	.dw _ecom_blownByGaleSeedState
	.dw _moblin_state_stub
	.dw _moblin_state_stub
	.dw _moblin_state_8
	.dw _moblin_state_9


_moblin_state_uninitialized:
	; Enable chasing scent seeds
	ld h,d			; $49a4
	ld l,Enemy.var3f		; $49a5
	set 4,(hl)		; $49a7

	ld l,Enemy.subid		; $49a9
	bit 1,(hl)		; $49ab
	jr z,++			; $49ad
	ld a,(wKilledGoldenEnemies)		; $49af
	bit 1,a			; $49b2
	jp nz,enemyDelete		; $49b4
++
	jp _arrowDarknut_state_uninitialized		; $49b7


_moblin_state_scentSeed:
	ld a,(wScentSeedActive)		; $49ba
	or a			; $49bd
	jp z,_arrowDarknut_setState8WithRandomAngleAndCounter		; $49be

	call _ecom_updateAngleToScentSeed		; $49c1
	ld e,Enemy.angle		; $49c4
	ld a,(de)		; $49c6
	add $04			; $49c7
	and $18			; $49c9
	ld (de),a		; $49cb
	call _ecom_updateAnimationFromAngle		; $49cc
	call _ecom_applyVelocityForSideviewEnemy		; $49cf
	jp enemyAnimate		; $49d2


; Also used by darknuts
_moblin_state_switchHook:
	inc e			; $49d5
	ld a,(de)		; $49d6
	rst_jumpTable			; $49d7
	.dw _ecom_incState2
	.dw @substate1
	.dw @substate2
	.dw _ecom_fallToGroundAndSetState8

@substate1:
@substate2:
	ret			; $49e0


_moblin_state_stub:
	ret			; $49e1


; Also darknut state 8 (moving in some direction)
_moblin_state_8:
	call _ecom_decCounter1		; $49e2
	jr z,+			; $49e5
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $49e7
	jr nz,++		; $49ea
+
	call _ecom_incState		; $49ec
	ld l,Enemy.counter1		; $49ef
	ld (hl),$08		; $49f1
++
	jp enemyAnimate		; $49f3


; Standing until counter1 reaches 0 and a new direction is decided on.
_moblin_state_9:
	call _ecom_decCounter1		; $49f6
	ret nz			; $49f9
	call _ecom_setRandomCardinalAngle		; $49fa
	call _arrowDarknut_setState8WithRandomAngleAndCounter		; $49fd
	jr _arrowDarknut_fireArrowEveryOtherTime		; $4a00


; ==============================================================================
; ENEMYID_ARROW_DARKNUT
; ==============================================================================
enemyCode21:
	call _ecom_checkHazards		; $4a02
	jr z,@normalStatus	; $4a05
	sub ENEMYSTATUS_NO_HEALTH			; $4a07
	ret c			; $4a09
	jp z,enemyDie		; $4a0a
	dec a			; $4a0d
	jp nz,_ecom_updateKnockbackAndCheckHazards		; $4a0e
	ret			; $4a11

@normalStatus:
	ld e,Enemy.state		; $4a12
	ld a,(de)		; $4a14
	rst_jumpTable			; $4a15
	.dw _arrowDarknut_state_uninitialized
	.dw _moblin_state_stub
	.dw _moblin_state_stub
	.dw _moblin_state_switchHook
	.dw _moblin_state_stub
	.dw _moblin_state_stub
	.dw _moblin_state_stub
	.dw _moblin_state_stub
	.dw _moblin_state_8
	.dw _arrowDarknut_state_9


; Also used by moblins
_arrowDarknut_state_uninitialized:
	ld e,Enemy.speed		; $4a2a
	ld a,SPEED_80		; $4a2c
	ld (de),a		; $4a2e
	call _ecom_setRandomCardinalAngle		; $4a2f
	call _arrowDarknut_setState8WithRandomAngleAndCounter		; $4a32
	jp objectSetVisiblec2		; $4a35


_arrowDarknut_state_9:
	call _ecom_decCounter1		; $4a38
	ret nz			; $4a3b
	call _arrowDarknut_chooseAngle		; $4a3c
	call _arrowDarknut_setState8WithRandomAngleAndCounter		; $4a3f

; This is also used by moblin's state 9.
; Every other time they move, if they're facing Link, fire an arrow.
_arrowDarknut_fireArrowEveryOtherTime:
	ld h,d			; $4a42
	ld l,Enemy.var30		; $4a43
	inc (hl)		; $4a45
	bit 0,(hl)		; $4a46
	ret z			; $4a48
	call objectGetAngleTowardEnemyTarget		; $4a49
	add $04			; $4a4c
	and $18			; $4a4e
	ld h,d			; $4a50
	ld l,Enemy.angle		; $4a51
	cp (hl)			; $4a53
	ret nz			; $4a54
	ld b,PARTID_ENEMY_ARROW		; $4a55
	jp _ecom_spawnProjectile		; $4a57


;;
; Sets random angle and counter, and goes to state 8.
; @addr{4a5a}
_arrowDarknut_setState8WithRandomAngleAndCounter:
	call getRandomNumber_noPreserveVars		; $4a5a
	and $3f			; $4a5d
	add $30			; $4a5f
	ld h,d			; $4a61
	ld l,Enemy.counter1		; $4a62
	ld (hl),a		; $4a64
	ld l,Enemy.state		; $4a65
	ld (hl),$08		; $4a67
	jp _ecom_updateAnimationFromAngle		; $4a69

;;
; 1-in-4 chance of turning to face Link directly, otherwise turns in a random direction.
; @addr{4a6c}
_arrowDarknut_chooseAngle:
	call getRandomNumber_noPreserveVars		; $4a6c
	and $03			; $4a6f
	jp z,_ecom_updateCardinalAngleTowardTarget		; $4a71
	jp _ecom_setRandomCardinalAngle		; $4a74


; ==============================================================================
; ENEMYID_LYNEL
;
; Variables:
;   var30: Determines probability that the Lynel turns toward Link whenever it turns (less
;          bits set = more likely).
; ==============================================================================
enemyCode0d:
	call _ecom_checkHazards		; $4a77
	jr z,@normalStatus	; $4a7a
	sub ENEMYSTATUS_NO_HEALTH			; $4a7c
	ret c			; $4a7e
	jr z,@dead		; $4a7f
	dec a			; $4a81
	jp nz,_ecom_updateKnockbackAndCheckHazards		; $4a82
	ret			; $4a85

@dead:
	ld e,Enemy.subid		; $4a86
	ld a,(de)		; $4a88
	cp $02			; $4a89
	jr nz,++		; $4a8b
	ld hl,wKilledGoldenEnemies		; $4a8d
	set 3,(hl)		; $4a90
++
	jp enemyDie		; $4a92

@normalStatus:
	call _ecom_checkScentSeedActive		; $4a95
	jr z,++			; $4a98
	ld e,Enemy.speed		; $4a9a
	ld a,SPEED_100		; $4a9c
	ld (de),a		; $4a9e
++
	ld e,Enemy.state		; $4a9f
	ld a,(de)		; $4aa1
	rst_jumpTable			; $4aa2
	.dw @state_uninitialized
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_scentSeed
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_08
	.dw @state_09
	.dw @state_0a


@state_uninitialized:
	ld e,Enemy.subid		; $4ab9
	ld a,(de)		; $4abb
	cp $02			; $4abc
	jr nz,++		; $4abe
	ld hl,wKilledGoldenEnemies		; $4ac0
	bit 3,(hl)		; $4ac3
	jp nz,enemyDelete		; $4ac5
++
	ld e,Enemy.subid		; $4ac8
	ld a,(de)		; $4aca
	ld hl,@var30Vals		; $4acb
	rst_addAToHl			; $4ace
	ld e,Enemy.var30		; $4acf
	ld a,(hl)		; $4ad1
	ld (de),a		; $4ad2

	call objectSetVisiblec2		; $4ad3
	call getRandomNumber_noPreserveVars		; $4ad6
	and $30			; $4ad9
	ld c,a			; $4adb
	ld h,d			; $4adc

	; Enable scent seed effect
	ld l,Enemy.var3f		; $4add
	set 4,(hl)		; $4adf

	ld l,Enemy.state		; $4ae1
	jp @changeDirection		; $4ae3

@var30Vals:
	.db $07 $03 $01


@state_scentSeed:
	ld a,(wScentSeedActive)		; $4ae9
	or a			; $4aec
	jp z,@gotoState8		; $4aed
	call _ecom_updateAngleToScentSeed		; $4af0
	ld e,Enemy.angle		; $4af3
	ld a,(de)		; $4af5
	add $04			; $4af6
	and $18			; $4af8
	ld (de),a		; $4afa
	ld b,$04		; $4afb
	call @updateAnimationFromAngle		; $4afd
	call _ecom_applyVelocityForSideviewEnemy		; $4b00
	jp enemyAnimate		; $4b03

@state_stub:
	ret			; $4b06


; Choose whether to walk around some more, or fire a projectile.
@state_08:
	ld e,Enemy.var30		; $4b07
	ld a,(de)		; $4b09
	ld b,a			; $4b0a
	ld c,$30		; $4b0b
	call _ecom_randomBitwiseAndBCE		; $4b0d
	or b			; $4b10
	ld h,d			; $4b11
	ld l,Enemy.state		; $4b12
	jr z,@prepareProjectile	; $4b14

@changeDirection:
	ld (hl),$09 ; [state] = $09
	ld l,Enemy.counter1		; $4b18
	ld a,$30		; $4b1a
	add c			; $4b1c
	ld (hl),a		; $4b1d
	jr @updateAngleAndSpeed		; $4b1e

@prepareProjectile:
	ld (hl),$0a ; [state] = $0a
	ld l,Enemy.counter1		; $4b22
	ld (hl),$08		; $4b24
	call _ecom_updateCardinalAngleTowardTarget		; $4b26
	jp _ecom_updateAnimationFromAngle		; $4b29


; Moving until counter1 reaches 0, then return to state 8
@state_09:
	call _ecom_decCounter1		; $4b2c
	jr z,@gotoState8	; $4b2f
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $4b31
	jr z,@updateAngleAndSpeed	; $4b34
@animate:
	jp enemyAnimate		; $4b36


; Standing for a moment before firing projectile
@state_0a:
	call _ecom_decCounter1		; $4b39
	jr nz,@animate	; $4b3c
	ld b,PARTID_LYNEL_BEAM		; $4b3e
	call _ecom_spawnProjectile		; $4b40
	jr nz,@gotoState8	; $4b43

	call getRandomNumber_noPreserveVars		; $4b45
	and $30			; $4b48
	add $30			; $4b4a
	ld e,Enemy.counter1		; $4b4c
	ld (de),a		; $4b4e

	ld h,d			; $4b4f
	ld l,Enemy.speed		; $4b50
	ld (hl),SPEED_80		; $4b52

	ld l,Enemy.state		; $4b54
	ld (hl),$09		; $4b56
	jr @animate		; $4b58

@gotoState8:
	ld e,Enemy.state		; $4b5a
	ld a,$08		; $4b5c
	ld (de),a		; $4b5e
	jr @animate		; $4b5f

;;
; The lynel turns, and if Link is in its sights, it charges.
; @addr{4b61}
@updateAngleAndSpeed:
	call @chooseNewAngle		; $4b61
	ld b,$0e		; $4b64
	call objectCheckCenteredWithLink		; $4b66
	jr nc,++		; $4b69

	call objectGetAngleTowardEnemyTarget		; $4b6b
	add $04			; $4b6e
	and $18			; $4b70
	ld h,d			; $4b72
	ld l,Enemy.angle		; $4b73
	cp (hl)			; $4b75
	ld a,SPEED_100		; $4b76
	ld b,$04		; $4b78
	jr z,+++			; $4b7a
++
	ld a,SPEED_80		; $4b7c
	ld b,$00		; $4b7e
+++
	ld l,Enemy.speed		; $4b80
	ld (hl),a		; $4b82

;;
; @param	b	0 if walking, 4 if running (value to add to animation)
; @addr{4b83}
@updateAnimationFromAngle:
	ld h,d			; $4b83
	ld l,Enemy.angle		; $4b84
	ldd a,(hl)		; $4b86
	swap a			; $4b87
	rlca			; $4b89
	add b			; $4b8a
	cp (hl)			; $4b8b
	ret z			; $4b8c
	ld (hl),a		; $4b8d
	jp enemySetAnimation		; $4b8e

;;
; Chooses a new angle; var30 sets the probability that it will turn to face Link instead
; of just a random direction.
; @addr{4b91}
@chooseNewAngle:
	call getRandomNumber_noPreserveVars		; $4b91
	ld h,d			; $4b94
	ld l,Enemy.var30		; $4b95
	and (hl)		; $4b97
	jp nz,_ecom_setRandomCardinalAngle		; $4b98
	jp _ecom_updateCardinalAngleTowardTarget		; $4b9b


; ==============================================================================
; ENEMYID_BLADE_TRAP
;
; Variables for normal traps:
;   var30: Speed
;
; Variables for circular traps:
;   var30: Center Y for circular traps
;   var31: Center X for circular traps
;   var32: Radius of circle for circular traps
; ==============================================================================
enemyCode0e:
	dec a			; $4b9e
	ret z			; $4b9f
	dec a			; $4ba0
	ret z			; $4ba1
	call enemyAnimate		; $4ba2
	call _ecom_getSubidAndCpStateTo08		; $4ba5
	jr nc,@normalState	; $4ba8
	rst_jumpTable			; $4baa
	.dw @state_uninitialized
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub

@normalState:
	ld a,b			; $4bbb
	rst_jumpTable			; $4bbc
	.dw _bladeTrap_subid00
	.dw _bladeTrap_subid01
	.dw _bladeTrap_subid02
	.dw _bladeTrap_subid03
	.dw _bladeTrap_subid04
	.dw _bladeTrap_subid05


@state_uninitialized:
	ld a,b			; $4bc9
	sub $03			; $4bca
	cp $02			; $4bcc
	call c,_bladeTrap_initCircular		; $4bce

	; Set different animation and var3e value for the spinning trap
	ld e,Enemy.subid		; $4bd1
	ld a,(de)		; $4bd3
	or a			; $4bd4
	ld a,$08		; $4bd5
	jr nz,++		; $4bd7

	ld a,$01		; $4bd9
	call enemySetAnimation		; $4bdb
	ld a,$01		; $4bde
++
	ld e,Enemy.var3e		; $4be0
	ld (de),a		; $4be2
	jp _ecom_setSpeedAndState8AndVisible		; $4be3

@state_stub:
	ret			; $4be6


; Red, spinning trap
_bladeTrap_subid00:
	ld a,(de)		; $4be7
	sub $08			; $4be8
	rst_jumpTable			; $4bea
	.dw @state8
	.dw @state9
	.dw @stateA
	.dw @stateB


; Initialization
@state8:
	ld h,d			; $4bf3
	ld l,e			; $4bf4
	inc (hl)		; $4bf5
	ld l,Enemy.speed		; $4bf6
	ld (hl),SPEED_c0		; $4bf8
	ld a,$01		; $4bfa
	jp enemySetAnimation		; $4bfc


; Waiting for Link to walk into range
@state9:
	ld b,$0e		; $4bff
	call _bladeTrap_checkLinkAligned		; $4c01
	ret nc			; $4c04
	call _bladeTrap_checkObstructionsToTarget		; $4c05
	ret nz			; $4c08

	ld h,d			; $4c09
	ld l,Enemy.state		; $4c0a
	ld (hl),$0a		; $4c0c

	ld l,Enemy.counter1		; $4c0e
	ld (hl),$18		; $4c10

	ld a,SND_MOVEBLOCK		; $4c12
	call playSound		; $4c14

	ld a,$02		; $4c17
	jp enemySetAnimation		; $4c19


; Moving toward Link (half-speed, just starting up)
@stateA:
	ld e,Enemy.counter1		; $4c1c
	ld a,(de)		; $4c1e
	rrca			; $4c1f
	call c,_ecom_applyVelocityForTopDownEnemyNoHoles		; $4c20
	call _ecom_decCounter1		; $4c23
	jr nz,@animate		; $4c26

	ld l,Enemy.state		; $4c28
	ld (hl),$0b		; $4c2a
@animate:
	jp enemyAnimate		; $4c2c


; Moving toward Link
@stateB:
	call _ecom_applyVelocityForTopDownEnemyNoHoles		; $4c2f
	jr nz,@animate	; $4c32

	; Hit wall
	ld e,Enemy.state		; $4c34
	ld a,$09		; $4c36
	ld (de),a		; $4c38
	ld a,$01		; $4c39
	jp enemySetAnimation		; $4c3b


; Blue, gold blade traps (reach exactly to the center of a large room, no further)
_bladeTrap_subid01:
_bladeTrap_subid02:
	ld a,(de)		; $4c3e
	sub $08			; $4c3f
	rst_jumpTable			; $4c41
	.dw @state8
	.dw @state9
	.dw @stateA
	.dw @stateB
	.dw @stateC


; Initialization
@state8:
	ld h,d			; $4c4c
	ld l,e			; $4c4d
	inc (hl) ; [state] = 9

	ld l,Enemy.subid		; $4c4f
	ld a,(hl)		; $4c51
	dec a			; $4c52
	ld a,SPEED_180		; $4c53
	jr z,+		; $4c55
	ld a,SPEED_300		; $4c57
+
	ld l,Enemy.var30		; $4c59
	ld (hl),a		; $4c5b


; Waiting for Link to walk into range
@state9:
	ld b,$0d		; $4c5c
	call _bladeTrap_checkLinkAligned		; $4c5e
	ret nc			; $4c61
	call _bladeTrap_checkObstructionsToTarget		; $4c62
	ret nz			; $4c65

	ld a,$01		; $4c66
	call _ecom_getTopDownAdjacentWallsBitset		; $4c68
	ret nz			; $4c6b

	call _ecom_incState		; $4c6c

	ld e,Enemy.var30		; $4c6f
	ld l,Enemy.speed		; $4c71
	ld a,(de)		; $4c73
	ld (hl),a		; $4c74
	ld a,SND_UNKNOWN5		; $4c75
	jp playSound		; $4c77


; Moving
@stateA:
	call _ecom_applyVelocityForTopDownEnemyNoHoles		; $4c7a
	ld h,d			; $4c7d
	jr z,@beginRetracting	; $4c7e

	; Blade trap spans about half the size of a large room (which is different in
	ld l,Enemy.angle		; $4c80
	bit 3,(hl)		; $4c82
	ld b,(LARGE_ROOM_HEIGHT/2)<<4 + 8		; $4c84
	ld l,Enemy.yh		; $4c86
	jr z,++			; $4c88

	ld b,(LARGE_ROOM_WIDTH/2)<<4 + 8		; $4c8a
	ld l,Enemy.xh		; $4c8c
++
	ld a,(hl)		; $4c8e
	sub b			; $4c8f
	add $07			; $4c90
	cp $0f			; $4c92
	ret nc			; $4c94

@beginRetracting:
	ld l,Enemy.angle		; $4c95
	ld a,(hl)		; $4c97
	xor $10			; $4c98
	ld (hl),a		; $4c9a

	ld l,Enemy.speed		; $4c9b
	ld (hl),SPEED_c0		; $4c9d

	ld l,Enemy.state		; $4c9f
	inc (hl)		; $4ca1
	ld a,SND_CLINK		; $4ca2
	jp playSound		; $4ca4


; Retracting
@stateB:
	call _ecom_applyVelocityForTopDownEnemyNoHoles		; $4ca7
	ret nz			; $4caa
	call _ecom_incState		; $4cab
	ld l,Enemy.counter1		; $4cae
	ld (hl),$10		; $4cb0
	ret			; $4cb2


; Cooldown of 16 frames
@stateC:
	call _ecom_decCounter1		; $4cb3
	ret nz			; $4cb6
	ld l,Enemy.state		; $4cb7
	ld (hl),$09		; $4cb9
	ret			; $4cbb


; Circular blade traps (clockwise & counterclockwise, respectively)
_bladeTrap_subid03:
_bladeTrap_subid04:
	ld a,(de)		; $4cbc
	sub $08			; $4cbd
	rst_jumpTable			; $4cbf
	.dw @state8

@state8:
	ld a,(wFrameCounter)		; $4cc2
	and $01			; $4cc5
	call z,bladeTrap_updateAngle		; $4cc7

	; Update position
	ld h,d			; $4cca
	ld l,Enemy.var30		; $4ccb
	ldi a,(hl)		; $4ccd
	ld b,a			; $4cce
	ldi a,(hl)		; $4ccf
	ld c,a			; $4cd0
	ld a,(hl)		; $4cd1
	ld e,Enemy.angle		; $4cd2
	jp objectSetPositionInCircleArc		; $4cd4


; Unlimited range green blade
_bladeTrap_subid05:
	ld a,(de)		; $4cd7
	sub $08			; $4cd8
	rst_jumpTable			; $4cda
	.dw @state8
	.dw @state9
	.dw @stateA
	.dw @stateB
	.dw @stateC


; Initialization
@state8:
	ld h,d			; $4ce5
	ld l,e			; $4ce6
	inc (hl)		; $4ce7
	ld l,Enemy.var30		; $4ce8
	ld (hl),SPEED_200		; $4cea


; Waiting for Link to walk into range
@state9:
	ld b,$0e		; $4cec
	call _bladeTrap_checkLinkAligned		; $4cee
	ret nc			; $4cf1
	call _bladeTrap_checkObstructionsToTarget		; $4cf2
	ret nz			; $4cf5

	ld a,$01		; $4cf6
	call _ecom_getTopDownAdjacentWallsBitset		; $4cf8
	ret nz			; $4cfb

	ld h,d			; $4cfc
	ld e,Enemy.var30		; $4cfd
	ld l,Enemy.speed		; $4cff
	ld a,(de)		; $4d01
	ld (hl),a		; $4d02

	ld l,Enemy.state		; $4d03
	inc (hl)		; $4d05
	ld a,SND_UNKNOWN5		; $4d06
	jp playSound		; $4d08


; Moving toward Link
@stateA:
	call _ecom_applyVelocityForTopDownEnemyNoHoles		; $4d0b
	ret nz			; $4d0e

	call _ecom_incState		; $4d0f
	ld l,Enemy.angle		; $4d12
	ld a,(hl)		; $4d14
	xor $10			; $4d15
	ld (hl),a		; $4d17
	ld l,Enemy.speed		; $4d18
	ld (hl),SPEED_100		; $4d1a
	ld a,SND_CLINK		; $4d1c
	jp playSound		; $4d1e


; Retracting
@stateB:
	call _ecom_applyVelocityForTopDownEnemyNoHoles		; $4d21
	ret nz			; $4d24
	call _ecom_incState		; $4d25
	ld l,Enemy.counter1		; $4d28
	ld (hl),$10		; $4d2a
	ret			; $4d2c


; Cooldown of 16 frames
@stateC:
	call _ecom_decCounter1		; $4d2d
	ret nz			; $4d30
	ld l,Enemy.state		; $4d31
	ld (hl),$09		; $4d33
	ret			; $4d35

;;
; Only for subids 3-4 (circular traps)
; @addr{4d36}
bladeTrap_updateAngle:
	ld e,Enemy.subid		; $4d36
	ld a,(de)		; $4d38
	cp $03			; $4d39
	ld e,Enemy.angle		; $4d3b
	jp nz,_bladeTrap_decAngle		; $4d3d
	jp _bladeTrap_incAngle		; $4d40

;;
; @addr{4d43}
_bladeTrap_initCircular:
	call getRandomNumber_noPreserveVars		; $4d43
	and $1f			; $4d46
	ld e,Enemy.angle		; $4d48
	ld (de),a		; $4d4a

	ld e,Enemy.yh		; $4d4b
	ld a,(de)		; $4d4d
	ld c,a			; $4d4e
	and $f0			; $4d4f
	add $08			; $4d51
	ld e,Enemy.var30		; $4d53
	ld (de),a		; $4d55
	ld b,a			; $4d56

	ld a,c			; $4d57
	and $0f			; $4d58
	swap a			; $4d5a
	add $08			; $4d5c
	ld e,Enemy.var31		; $4d5e
	ld (de),a		; $4d60
	ld c,a			; $4d61

	ld e,Enemy.xh		; $4d62
	ld a,(de)		; $4d64
	ld e,Enemy.var32		; $4d65
	ld (de),a		; $4d67

	ld e,Enemy.angle		; $4d68
	jp objectSetPositionInCircleArc		; $4d6a


; Position offset to add when checking each successive tile between the trap and the
; target for solidity
_bladeTrap_directionOffsets:
	.db $f0 $00
	.db $00 $10
	.db $10 $00
	.db $00 $f0

;;
; @param[out]	zflag	z if there are no obstructions (solid tiles) between trap and
;			target
; @addr{4d75}
_bladeTrap_checkObstructionsToTarget:
	ld h,d			; $4d75
	ld l,Enemy.yh		; $4d76
	ld b,(hl)		; $4d78
	ld l,Enemy.xh		; $4d79
	ld c,(hl)		; $4d7b
	ldh a,(<hEnemyTargetX)	; $4d7c
	sub c			; $4d7e
	add $04			; $4d7f
	cp $09			; $4d81
	jr nc,++		; $4d83

	ldh a,(<hEnemyTargetY)	; $4d85
	sub b			; $4d87
	add $04			; $4d88
	cp $09			; $4d8a
	ret c			; $4d8c
++
	ld l,Enemy.angle		; $4d8d
	call @getNumTilesToTarget		; $4d8f

	; Get direction offset in hl
	ld a,(hl)		; $4d92
	rrca			; $4d93
	rrca			; $4d94
	ld hl,_bladeTrap_directionOffsets		; $4d95
	rst_addAToHl			; $4d98
	ldi a,(hl)		; $4d99
	ld l,(hl)		; $4d9a
	ld h,a			; $4d9b

	; Check each tile between the trap and the target for solidity
	push de			; $4d9c
	ld d,>wRoomCollisions		; $4d9d
--
	call @checkNextTileSolid		; $4d9f
	jr nz,++		; $4da2
	ldh a,(<hFF8B)	; $4da4
	dec a			; $4da6
	ldh (<hFF8B),a	; $4da7
	jr nz,--		; $4da9
++
	pop de			; $4dab
	ret			; $4dac

;;
; @param	bc	Tile we're at right now
; @param	d	>wRoomCollisions
; @param	hl	Value to add to bc each time (direction offset)
; @param[out]	zflag	nz if tile is solid
; @addr{4dad}
@checkNextTileSolid:
	ld a,b			; $4dad
	add h			; $4dae
	ld b,a			; $4daf
	and $f0			; $4db0
	ld e,a			; $4db2
	ld a,c			; $4db3
	add l			; $4db4
	ld c,a			; $4db5
	and $f0			; $4db6
	swap a			; $4db8
	or e			; $4dba
	ld e,a			; $4dbb
	ld a,(de)		; $4dbc
	or a			; $4dbd
	ret			; $4dbe

;;
; @param	bc	Enemy position
; @param	hl	Enemy angle
; @param[out]	hFF8B	Number of tiles between enemy and target
; @addr{4dbf}
@getNumTilesToTarget:
	ld e,b			; $4dbf
	ldh a,(<hEnemyTargetY)	; $4dc0
	bit 3,(hl)		; $4dc2
	jr z,+			; $4dc4
	ld e,c			; $4dc6
	ldh a,(<hEnemyTargetX)	; $4dc7
+
	sub e			; $4dc9
	jr nc,+			; $4dca
	cpl			; $4dcc
	inc a			; $4dcd
+
	swap a			; $4dce
	and $0f			; $4dd0
	jr nz,+			; $4dd2
	inc a			; $4dd4
+
	ldh (<hFF8B),a	; $4dd5
	ret			; $4dd7

;;
; Determines if Link is aligned close enough on the X or Y axis to be attacked; if so,
; this sets the blade's angle accordingly.
;
; @param	b	How close Link must be (on the orthogonal axis relative to the
;			attack) before the trap can attack
; @param[out]	cflag	c if Link is in range
; @addr{4dd8}
_bladeTrap_checkLinkAligned:
	ld c,b			; $4dd8
	sla c			; $4dd9
	inc c			; $4ddb
	ld e,$00		; $4ddc
	ld h,d			; $4dde
	ld l,Enemy.xh		; $4ddf
	ldh a,(<hEnemyTargetX)	; $4de1
	sub (hl)		; $4de3
	add b			; $4de4
	cp c			; $4de5
	ld l,Enemy.yh		; $4de6
	ldh a,(<hEnemyTargetY)	; $4de8
	jr c,@inRange		; $4dea

	ld e,$18		; $4dec
	sub (hl)		; $4dee
	add b			; $4def
	cp c			; $4df0
	ld l,Enemy.xh		; $4df1
	ldh a,(<hEnemyTargetX)	; $4df3
	ret nc			; $4df5

@inRange:
	cp (hl)			; $4df6
	ld a,e			; $4df7
	jr c,+			; $4df8
	xor $10			; $4dfa
+
	ld l,Enemy.angle		; $4dfc
	ld (hl),a		; $4dfe
	scf			; $4dff
	ret			; $4e00

;;
; @addr{4e01}
_bladeTrap_incAngle:
	ld a,(de)		; $4e01
	inc a			; $4e02
	jr ++			; $4e03

;;
; @addr{4e05}
_bladeTrap_decAngle:
	ld a,(de)		; $4e05
	dec a			; $4e06
++
	and $1f			; $4e07
	ld (de),a		; $4e09
	ret			; $4e0a


; ==============================================================================
; ENEMYID_ROPE
;
; Variables:
;   counter2: Cooldown until rope can charge at Link again
;   var30: Hazards are checked iff bit 7 is set.
; ==============================================================================
enemyCode10:
	call _rope_checkHazardsIfApplicable		; $4e0b
	or a			; $4e0e
	jr z,@normalStatus	; $4e0f

	sub $03			; $4e11
	ret c			; $4e13
	jp z,enemyDie		; $4e14
	dec a			; $4e17
	jp nz,_ecom_updateKnockbackAndCheckHazards		; $4e18
	ret			; $4e1b

@normalStatus:
	call _ecom_checkScentSeedActive		; $4e1c
	jr z,++		; $4e1f
	ld e,Enemy.speed		; $4e21
	ld a,SPEED_140		; $4e23
	ld (de),a		; $4e25
++
	call _ecom_getSubidAndCpStateTo08		; $4e26
	jr nc,@normalState	; $4e29
	rst_jumpTable			; $4e2b
	.dw @state_uninitialized
	.dw @state_stub
	.dw @state_stub
	.dw @state_switchHook
	.dw @state_scentSeed
	.dw _ecom_blownByGaleSeedState
	.dw @state_stub
	.dw @state_stub


@normalState:
	ld a,b			; $4e3c
	rst_jumpTable			; $4e3d
	.dw _rope_subid00
	.dw _rope_subid01
	.dw _rope_subid02
	.dw _rope_subid03


@state_uninitialized:
	ld e,Enemy.direction		; $4e46
	ld a,$ff		; $4e48
	ld (de),a		; $4e4a

	; Subid 1: make speed lower?
	dec b			; $4e4b
	ld a,SPEED_60		; $4e4c
	jp z,_ecom_setSpeedAndState8		; $4e4e

	; Enable scent seed effect
	ld h,d			; $4e51
	ld l,Enemy.var3f		; $4e52
	set 4,(hl)		; $4e54

	jp _ecom_setSpeedAndState8AndVisible		; $4e56


@state_switchHook:
	inc e			; $4e59
	ld a,(de)		; $4e5a
	rst_jumpTable			; $4e5b
	.dw _ecom_incState2
	.dw @@substate1
	.dw @@substate2
	.dw @@substate3

@@substate1:
@@substate2:
	ret			; $4e64


@@substate3:
	ld e,Enemy.subid		; $4e65
	ld a,(de)		; $4e67
	ld hl,@defaultStates		; $4e68
	rst_addAToHl			; $4e6b
	ld b,(hl)		; $4e6c
	jp _ecom_fallToGroundAndSetState		; $4e6d


@state_scentSeed:
	ld a,(wScentSeedActive)		; $4e70
	or a			; $4e73
	jr nz,++		; $4e74

	ld e,Enemy.subid		; $4e76
	ld a,(de)		; $4e78
	ld hl,@defaultStates		; $4e79
	rst_addAToHl			; $4e7c
	ld e,Enemy.state		; $4e7d
	ld a,(hl)		; $4e7f
	ld (de),a		; $4e80
	ld e,Enemy.speed		; $4e81
	ld a,SPEED_60		; $4e83
	ld (de),a		; $4e85
	ret			; $4e86
++
	call _ecom_updateAngleToScentSeed		; $4e87
	ld e,Enemy.angle		; $4e8a
	ld a,(de)		; $4e8c
	add $04			; $4e8d
	and $18			; $4e8f
	ld (de),a		; $4e91
	call _rope_updateAnimationFromAngle		; $4e92
	call _ecom_applyVelocityForSideviewEnemy		; $4e95
	jp _rope_animate		; $4e98


@defaultStates: ; Default states for each subid
	.db $09 $0b $0a $0a


@state_stub:
	ret			; $4e9f


; Normal rope.
_rope_subid00:
	ld a,(de)		; $4ea0
	sub $08			; $4ea1
	rst_jumpTable			; $4ea3
	.dw @state8
	.dw _rope_state_moveAround
	.dw _rope_state_chargeLink


; Initialization
@state8:
	ld h,d			; $4eaa
	ld l,e			; $4eab
	inc (hl) ; [state] = 9

	ld l,Enemy.collisionType		; $4ead
	set 7,(hl)		; $4eaf
	ld l,Enemy.var30		; $4eb1
	set 7,(hl)		; $4eb3


; Moving around, checking whether to charge Link
_rope_state_moveAround:
	ld b,$0a		; $4eb5
	call objectCheckCenteredWithLink		; $4eb7
	jr nc,++	; $4eba

	ld e,Enemy.counter2		; $4ebc
	ld a,(de)		; $4ebe
	or a			; $4ebf
	jr nz,++	; $4ec0

	; Charge at Link
	call _ecom_updateCardinalAngleTowardTarget		; $4ec2
	call _ecom_incState		; $4ec5
	ld l,Enemy.speed		; $4ec8
	ld (hl),SPEED_140		; $4eca
	jp _rope_updateAnimationFromAngle		; $4ecc

++
	call _ecom_decCounter2		; $4ecf
	dec l			; $4ed2
	dec (hl) ; [counter1]--
	call nz,_ecom_applyVelocityForSideviewEnemyNoHoles		; $4ed4
	jp z,_rope_changeDirection		; $4ed7

_rope_callEnemyAnimate:
	jp enemyAnimate		; $4eda


; Charging Link
_rope_state_chargeLink:
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $4edd
	jp nz,_rope_animate		; $4ee0

	ld h,d			; $4ee3
	ld l,Enemy.state		; $4ee4
	dec (hl)		; $4ee6

	ld l,Enemy.speed		; $4ee7
	ld (hl),SPEED_60		; $4ee9
	ld l,Enemy.counter2		; $4eeb
	ld (hl),$40		; $4eed
	jp _rope_changeDirection		; $4eef


; Rope that falls from the sky.
_rope_subid01:
	ld a,(de)		; $4ef2
	sub $08			; $4ef3
	rst_jumpTable			; $4ef5
	.dw @state8
	.dw @state9
	.dw @stateA
	.dw _rope_state_moveAround
	.dw _rope_state_chargeLink


; Initialization
@state8:
	ld a,$09		; $4f00
	ld (de),a		; $4f02
	call getRandomNumber_noPreserveVars		; $4f03
	ld e,Enemy.counter1		; $4f06
	and $38			; $4f08
	inc a			; $4f0a
	ld (de),a		; $4f0b
	ret			; $4f0c


; Wait a random amount of time before dropping from the sky
@state9:
	call _ecom_decCounter1		; $4f0d
	ret nz			; $4f10

	ld l,e			; $4f11
	inc (hl) ; [state]++

	ld l,Enemy.collisionType		; $4f13
	set 7,(hl)		; $4f15
	ld l,Enemy.var30		; $4f17
	set 7,(hl)		; $4f19

	ld l,Enemy.speedZ+1		; $4f1b
	inc (hl)		; $4f1d

	ld a,SND_FALLINHOLE		; $4f1e
	call playSound		; $4f20
	call objectSetVisiblec1		; $4f23

	ld c,$08		; $4f26
	jp _ecom_setZAboveScreen		; $4f28


; Currently falling from the sky
@stateA:
	ld c,$0e		; $4f2b
	call objectUpdateSpeedZ_paramC		; $4f2d
	ret nz			; $4f30

	ld l,Enemy.speedZ		; $4f31
	ldi (hl),a		; $4f33
	ld (hl),a		; $4f34

	ld l,Enemy.state		; $4f35
	inc (hl)		; $4f37

	; Enable scent seeds
	ld l,Enemy.var3f		; $4f38
	set 4,(hl)		; $4f3a

	call objectSetVisiblec2		; $4f3c
	ld a,SND_BOMB_LAND		; $4f3f
	call playSound		; $4f41

	call _rope_changeDirection		; $4f44
	jr _rope_callEnemyAnimate		; $4f47


; Immediately charges Link upon spawning
_rope_subid02:
	ld a,(de)		; $4f49
	sub $08			; $4f4a
	rst_jumpTable			; $4f4c
	.dw @state8
	.dw @state9
	.dw _rope_state_moveAround
	.dw _rope_state_chargeLink


; Initialization
@state8:
	ld h,d			; $4f55
	ld l,e			; $4f56
	inc (hl) ; [state] = 9

	ld l,Enemy.speed		; $4f58
	ld (hl),SPEED_140		; $4f5a
	ld l,Enemy.counter1		; $4f5c
	ld (hl),$08		; $4f5e
	call _ecom_updateCardinalAngleTowardTarget		; $4f60
	jp _rope_updateAnimationFromAngle		; $4f63


; Waiting just before charging Link
@state9:
	call _ecom_decCounter1		; $4f66
	jr nz,++		; $4f69

	ld l,e			; $4f6b
	ld (hl),$0b ; [state] = "charge at Link" state

	ld l,Enemy.collisionType		; $4f6e
	set 7,(hl)		; $4f70
	ld l,Enemy.var30		; $4f72
	set 7,(hl)		; $4f74
++
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $4f76
	jp enemyAnimate		; $4f79


; Falls and bounces toward Link when it spawns
_rope_subid03:
	ld a,(de)		; $4f7c
	sub $08			; $4f7d
	rst_jumpTable			; $4f7f
	.dw @state8
	.dw @state9
	.dw _rope_state_moveAround
	.dw _rope_state_chargeLink


; Initialization
@state8:
	ld h,d			; $4f88
	ld l,e			; $4f89
	inc (hl) ; [state] = 9

	ld l,Enemy.speedZ		; $4f8b
	ld a,$fe		; $4f8d
	ldi (hl),a		; $4f8f
	ld (hl),$fe		; $4f90

	ld l,Enemy.speed		; $4f92
	ld (hl),SPEED_c0		; $4f94

	ld l,Enemy.angle		; $4f96
	ld a,(w1Link.direction)		; $4f98
	swap a			; $4f9b
	rrca			; $4f9d
	ld (hl),a		; $4f9e

	jp _rope_updateAnimationFromAngle		; $4f9f


; "Bouncing" toward Link
@state9:
	ld c,$0e		; $4fa2
	call objectUpdateSpeedZAndBounce		; $4fa4
	jr c,@doneBouncing	; $4fa7

	ld a,SND_BOMB_LAND		; $4fa9
	call z,playSound		; $4fab

	; Enable collisions if speedZ is positive?
	ld e,Enemy.speedZ+1		; $4fae
	ld a,(de)		; $4fb0
	or a			; $4fb1
	jr nz,++		; $4fb2
	ld h,d			; $4fb4
	ld l,Enemy.collisionType		; $4fb5
	set 7,(hl)		; $4fb7
	ld l,Enemy.var30		; $4fb9
	set 7,(hl)		; $4fbb
++
	jp _ecom_applyVelocityForSideviewEnemyNoHoles		; $4fbd

@doneBouncing:
	call _ecom_incState		; $4fc0
	ld l,Enemy.speed		; $4fc3
	ld (hl),SPEED_60		; $4fc5

;;
; Chooses random new angle, random value for counter1.
; @addr{4fc7}
_rope_changeDirection:
	ldbc $18,$70		; $4fc7
	call _ecom_randomBitwiseAndBCE		; $4fca
	ld e,Enemy.angle		; $4fcd
	ld a,b			; $4fcf
	ld (de),a		; $4fd0
	ld e,Enemy.counter1		; $4fd1
	ld a,c			; $4fd3
	add $70			; $4fd4
	ld (de),a		; $4fd6

;;
; @addr{4fd7}
_rope_updateAnimationFromAngle:
	ld h,d			; $4fd7
	ld l,Enemy.angle		; $4fd8
	ld a,(hl)		; $4fda
	and $0f			; $4fdb
	ret z			; $4fdd

	ldd a,(hl)		; $4fde
	and $10			; $4fdf
	swap a			; $4fe1
	xor $01			; $4fe3
	cp (hl)			; $4fe5
	ret z			; $4fe6

	ld (hl),a		; $4fe7
	jp enemySetAnimation		; $4fe8

;;
; @addr{4feb}
_rope_animate:
	ld h,d			; $4feb
	ld l,Enemy.animCounter		; $4fec
	ld a,(hl)		; $4fee
	sub $03			; $4fef
	jr nc,+			; $4ff1
	xor a			; $4ff3
+
	inc a			; $4ff4
	ld (hl),a		; $4ff5
	jp enemyAnimate		; $4ff6

;;
; @addr{4ff9}
_rope_checkHazardsIfApplicable:
	ld h,d			; $4ff9
	ld l,Enemy.var30		; $4ffa
	bit 7,(hl)		; $4ffc
	ret z			; $4ffe
	jp _ecom_checkHazards		; $4fff


; ==============================================================================
; ENEMYID_GIBDO
; ==============================================================================
enemyCode12:
	; a = ENEMY_STATUS
	call _ecom_checkHazards		; $5002

	; a = ENEMY_STATUS
	jr z,@normalStatus	; $5005

	sub ENEMYSTATUS_NO_HEALTH			; $5007
	ret c			; $5009
	jp z,enemyDie		; $500a

	; If just hit by ember seed, go to state $0a (turn into stalfos)
	ld e,Enemy.var2a		; $500d
	ld a,(de)		; $500f
	cp $80|ITEMCOLLISION_EMBER_SEED			; $5010
	ret nz			; $5012

	ld h,d			; $5013
	ld l,Enemy.state		; $5014
	ld a,$0a		; $5016
	cp (hl)			; $5018
	ret z			; $5019

	ld (hl),a		; $501a
	ld l,Enemy.counter1		; $501b
	ld (hl),30		; $501d
	ld l,Enemy.stunCounter		; $501f
	ld (hl),$00		; $5021
	ret			; $5023

@normalStatus:
	ld e,Enemy.state		; $5024
	ld a,(de)		; $5026
	rst_jumpTable			; $5027
	.dw @uninitialized
	.dw @state_stub
	.dw @state_stub
	.dw @state_switchHook
	.dw @state_stub
	.dw _ecom_blownByGaleSeedState
	.dw @state_stub
	.dw @state_stub
	.dw @state8
	.dw @state9
	.dw @stateA


@uninitialized:
	ld a,SPEED_80		; $503e
	jp _ecom_setSpeedAndState8AndVisible		; $5040


@state_switchHook:
	inc e			; $5043
	ld a,(de)		; $5044
	rst_jumpTable			; $5045
	.dw _ecom_incState2
	.dw @@substate1
	.dw @@substate2
	.dw _ecom_fallToGroundAndSetState8

@@substate1:
@@substate2:
	ret			; $504e

@state_stub:
	ret			; $504f


; Choosing a direction & duration to walk
@state8:
	ld a,$09		; $5050
	ld (de),a		; $5052

	; Choose random angle & counter1
	ldbc $18,$7f		; $5053
	call _ecom_randomBitwiseAndBCE		; $5056
	ld e,Enemy.angle		; $5059
	ld a,b			; $505b
	ld (de),a		; $505c
	ld e,Enemy.counter1		; $505d
	ld a,$40		; $505f
	add c			; $5061
	ld (de),a		; $5062
	jr @animate		; $5063


; Walking in some direction for [counter1] frames
@state9:
	call _ecom_decCounter1		; $5065
	jr z,@gotoState8	; $5068
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $506a
	jr z,@gotoState8	; $506d
@animate:
	jp enemyAnimate		; $506f


; Burning; turns into stalfos
@stateA:
	call _ecom_decCounter1		; $5072
	ret nz			; $5075
	ldbc ENEMYID_STALFOS,$02		; $5076
	jp enemyReplaceWithID		; $5079


@gotoState8:
	ld e,Enemy.state		; $507c
	ld a,$08		; $507e
	ld (de),a		; $5080
	jr @animate		; $5081


; ==============================================================================
; ENEMYID_SPARK
; ==============================================================================
enemyCode13:
	call _ecom_checkHazards		; $5083
	jr z,@normalStatus	; $5086

	sub ENEMYSTATUS_NO_HEALTH			; $5088
	ret c			; $508a
	ld e,Enemy.var2a		; $508b
	ld a,(de)		; $508d
	res 7,a			; $508e
	sub ITEMCOLLISION_BOOMERANG			; $5090
	cp $01			; $5092
	jr nc,@normalStatus	; $5094

	; Collision with boomerang occurred. Go to state 9.
	ld e,Enemy.state		; $5096
	ld a,(de)		; $5098
	cp $09			; $5099
	jr nc,@normalStatus	; $509b
	ld a,$09		; $509d
	ld (de),a		; $509f

@normalStatus:
	ld e,Enemy.state		; $50a0
	ld a,(de)		; $50a2
	rst_jumpTable			; $50a3
	.dw _spark_state_uninitialized
	.dw _spark_state_stub
	.dw _spark_state_stub
	.dw _spark_state_stub
	.dw _spark_state_stub
	.dw _spark_state_stub
	.dw _spark_state_stub
	.dw _spark_state_stub
	.dw _spark_state8
	.dw _spark_state9
	.dw _spark_stateA


_spark_state_uninitialized:
	call _spark_getWallAngle		; $50ba
	ld e,Enemy.angle		; $50bd
	ld (de),a		; $50bf
	ld a,SPEED_100		; $50c0
	call _ecom_setSpeedAndState8		; $50c2
	jp objectSetVisible82		; $50c5


_spark_state_stub:
	ret			; $50c8


; Standard movement state.
_spark_state8:
	call _spark_updateAngle		; $50c9
	call objectApplySpeed		; $50cc
	jp enemyAnimate		; $50cf


; Just hit by a boomerang. (Also whisp's state 9.)
_spark_state9:
	ldbc INTERACID_PUFF,$02		; $50d2
	call objectCreateInteraction		; $50d5
	ret nz			; $50d8

	ld e,Enemy.relatedObj2		; $50d9
	ld a,Interaction.start		; $50db
	ld (de),a		; $50dd
	inc e			; $50de
	ld a,h			; $50df
	ld (de),a		; $50e0

	call _ecom_incState		; $50e1
	jp objectSetInvisible		; $50e4


; Will delete self and create fairy when the "puff" is gone. (Also whisp's state A.)
_spark_stateA:
	ld a,Object.animParameter		; $50e7
	call objectGetRelatedObject2Var		; $50e9
	ld a,(hl)		; $50ec
	inc a			; $50ed
	ret nz			; $50ee

	ld e,Enemy.id		; $50ef
	ld a,(de)		; $50f1
	cp ENEMYID_SPARK			; $50f2
	ld b,PARTID_ITEM_DROP		; $50f4
	call z,_ecom_spawnProjectile		; $50f6
	jp enemyDelete		; $50f9


; ==============================================================================
; ENEMYID_WHISP
; ==============================================================================
enemyCode19:
	jr z,@normalStatus	; $50fc
	sub ENEMYSTATUS_NO_HEALTH			; $50fe
	ret c			; $5100

	ld e,Enemy.var2a		; $5101
	ld a,(de)		; $5103
	res 7,a			; $5104
	sub ITEMCOLLISION_BOOMERANG			; $5106
	cp $01			; $5108
	jr nc,@normalStatus	; $510a

	; Hit with boomerang
	ld e,Enemy.state		; $510c
	ld a,(de)		; $510e
	cp $09			; $510f
	jr nc,@normalStatus	; $5111
	ld a,$09		; $5113
	ld (de),a		; $5115

@normalStatus:
	ld e,Enemy.state		; $5116
	ld a,(de)		; $5118
	rst_jumpTable			; $5119
	.dw _whisp_state_uninitialized
	.dw _spark_state_stub
	.dw _spark_state_stub
	.dw _spark_state_stub
	.dw _spark_state_stub
	.dw _ecom_blownByGaleSeedState
	.dw _spark_state_stub
	.dw _spark_state_stub
	.dw _whisp_state8
	.dw _spark_state9
	.dw _spark_stateA


_whisp_state_uninitialized:
	call getRandomNumber_noPreserveVars		; $5130
	and $18			; $5133
	add $04			; $5135
	ld e,Enemy.angle		; $5137
	ld (de),a		; $5139

	ld a,SPEED_c0		; $513a
	call _ecom_setSpeedAndState8		; $513c

	jp objectSetVisible82		; $513f


_whisp_state8:
	call _ecom_bounceOffWalls		; $5142
	call objectApplySpeed		; $5145
	jp enemyAnimate		; $5148


;;
; Updates the spark's moving angle by checking for walls, updating angle appropriately.
; Sparks move by hugging walls.
; @addr{514b}
_spark_updateAngle:
	ld a,$01		; $514b
	ldh (<hFF8A),a

	; Confirm that we're still up against a wall
	ld e,Enemy.angle		; $514f
	ld a,(de)		; $5151
	sub $08			; $5152
	and $18			; $5154
	call _spark_checkWallInDirection		; $5156
	jr c,++		; $5159

	; The wall has gone missing, but don't update angle until we're centered by
	; 8 pixels.
	call _spark_getTileOffset		; $515b
	ret nz			; $515e

	ld e,Enemy.angle		; $515f
	ld a,(de)		; $5161
	sub $08			; $5162
	and $18			; $5164
	ld (de),a		; $5166
	ret			; $5167
++
	; We're still hugging a wall, but check if we're running into one now.
	ld e,Enemy.angle		; $5168
	ld a,(de)		; $516a
	call _spark_checkWallInDirection		; $516b
	ret nc			; $516e

	ld e,Enemy.angle		; $516f
	ld a,(de)		; $5171
	add $08			; $5172
	and $18			; $5174
	ld (de),a		; $5176
	ret			; $5177


;;
; @param[out]	a	Angle relative to enemy where wall is (only valid if cflag is set)
; @param[out]	cflag	c if there is a wall in any direction, nc otherwise
; @addr{5178}
_spark_getWallAngle:
	xor a			; $5178
	call _spark_checkWallInDirection		; $5179
	ld a,$08		; $517c
	ret c			; $517e
	call _spark_checkWallInDirection		; $517f
	ld a,$10		; $5182
	ret c			; $5184
	call _spark_checkWallInDirection		; $5185
	ld a,$18		; $5188
	ret c			; $518a
	xor a			; $518b
	ret			; $518c

;;
; @param[out]	a	A value from 0-7, indicating the offset within a quarter-tile the
;			whisp is at. When this is 0, it needs to check for a direction
;			change?
; @addr{518d}
_spark_getTileOffset:
	ld e,Enemy.angle		; $518d
	ld a,(de)		; $518f
	bit 3,a			; $5190
	jr nz,++		; $5192
	ld e,Enemy.yh		; $5194
	ld a,(de)		; $5196
	and $07			; $5197
	ret			; $5199
++
	ld e,Enemy.xh		; $519a
	ld a,(de)		; $519c
	and $07			; $519d
	ret			; $519f

;;
; @param	a	Angle to check
; @param[out]	cflag	c if there's a solid wall in that direction
; @addr{51a0}
_spark_checkWallInDirection:
	and $18			; $51a0
	rrca			; $51a2
	ld hl,@offsetTable		; $51a3
	rst_addAToHl			; $51a6
	ld e,Enemy.yh		; $51a7
	ld a,(de)		; $51a9
	add (hl)		; $51aa
	ld b,a			; $51ab

	inc hl			; $51ac
	ld e,Enemy.xh		; $51ad
	ld a,(de)		; $51af
	add (hl)		; $51b0
	ld c,a			; $51b1

	push hl			; $51b2
	push bc			; $51b3
	call checkTileCollisionAt_disallowHoles		; $51b4
	pop bc			; $51b7
	pop hl			; $51b8
	ret c			; $51b9

	inc hl			; $51ba
	ldi a,(hl)		; $51bb
	add b			; $51bc
	ld b,a			; $51bd
	ld a,(hl)		; $51be
	add c			; $51bf
	ld c,a			; $51c0
	jp checkTileCollisionAt_disallowHoles		; $51c1


; Each direction lists two position offsets to check for collisions at.
@offsetTable:
	.db $f7 $fc $00 $07 ; DIR_UP
	.db $fc $08 $07 $00 ; DIR_RIGHT
	.db $08 $fc $00 $07 ; DIR_DOWN
	.db $fc $f7 $07 $00 ; DIR_LEFT


; ==============================================================================
; ENEMYID_SPIKED_BEETLE
;
; Variables:
;   var30: $00 normally, $01 when flipped over.
; ==============================================================================
enemyCode14:
	call _ecom_checkHazards		; $51d4
	jr z,@normalStatus	; $51d7

	sub ENEMYSTATUS_NO_HEALTH			; $51d9
	ret c			; $51db
	jp z,enemyDie		; $51dc

	dec a			; $51df
	jr nz,@knockback	; $51e0

	; Just hit by something

	; If bit 0 of var30 is set, ...?
	ld h,d			; $51e2
	ld l,Enemy.var30		; $51e3
	bit 0,(hl)		; $51e5
	jr z,++			; $51e7
	ld e,Enemy.zh		; $51e9
	ld a,(de)		; $51eb
	rlca			; $51ec
	jr c,++			; $51ed
	ld (hl),$00		; $51ef
++
	; Check if the collision was a shovel or shield (enemy will flip over)
	ld e,Enemy.var2a		; $51f1
	ld a,(de)		; $51f3
	cp $80|ITEMCOLLISION_SHOVEL			; $51f4
	jr z,++			; $51f6
	res 7,a			; $51f8
	sub ITEMCOLLISION_L1_SHIELD			; $51fa
	cp (ITEMCOLLISION_L3_SHIELD-ITEMCOLLISION_L1_SHIELD)+1
	jr nc,@normalStatus	; $51fe
++
	; If already flipped, return.
	ld e,Enemy.state		; $5200
	ld a,(de)		; $5202
	cp $0b			; $5203
	ret z			; $5205

	; Flip over.

	ld (hl),$01 ; [var30] = $01
	ld bc,-$180		; $5208
	call objectSetSpeedZ		; $520b

	ld l,Enemy.state		; $520e
	ld (hl),$0b		; $5210

	ld l,Enemy.enemyCollisionMode		; $5212
	ld (hl),ENEMYCOLLISION_SPIKED_BEETLE_FLIPPED		; $5214

	ld l,Enemy.counter1		; $5216
	ld (hl),180		; $5218

	ld l,Enemy.knockbackAngle		; $521a
	ld a,(hl)		; $521c
	xor $10			; $521d
	ld l,Enemy.angle		; $521f
	ld (hl),a		; $5221

	ld a,SND_BOMB_LAND		; $5222
	call playSound		; $5224
	ld a,$01		; $5227
	jp enemySetAnimation		; $5229


@knockback:
	ld e,Enemy.var30		; $522c
	ld a,(de)		; $522e
	or a			; $522f
	jp z,_ecom_updateKnockbackAndCheckHazards		; $5230

	; If flipped over, knockback is considered to last until it stops bouncing.
	ld c,$18		; $5233
	call objectUpdateSpeedZAndBounce		; $5235
	ld a,$01		; $5238
	jr nc,+			; $523a
	xor a			; $523c
+
	ld e,Enemy.knockbackCounter		; $523d
	ld (de),a		; $523f
	ld e,Enemy.knockbackAngle		; $5240
	ld a,(de)		; $5242
	ld c,a			; $5243
	ld b,SPEED_e0		; $5244
	jp _ecom_applyGivenVelocity		; $5246


@normalStatus:
	ld e,Enemy.state		; $5249
	ld a,(de)		; $524b
	rst_jumpTable			; $524c
	.dw @state_uninitialized
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw _ecom_blownByGaleSeedState
	.dw @state_stub
	.dw @state_stub
	.dw @state8
	.dw @state9
	.dw @stateA
	.dw @stateB
	.dw @stateC


@state_uninitialized:
	call @setRandomAngleAndCounter1		; $5267
	ld a,SPEED_40		; $526a
	jp _ecom_setSpeedAndState8AndVisible		; $526c


@state_stub:
	ret			; $526f


; Wandering around until Link comes into range
@state8:
	ld b,$08		; $5270
	call objectCheckCenteredWithLink		; $5272
	jp c,@chargeLink		; $5275

	call _ecom_decCounter1		; $5278
	jp z,@setRandomAngleAndCounter1		; $527b
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $527e
	jp z,@setRandomAngleAndCounter1		; $5281
@animate:
	jp enemyAnimate		; $5284


; Charging at Link
@state9:
	call _ecom_decCounter2		; $5287
	call @incSpeed		; $528a
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $528d
	jr nz,@animate	; $5290

	; Hit wall
	call _ecom_incState		; $5292
	ld l,Enemy.counter1		; $5295
	ld (hl),30		; $5297
	ret			; $5299


; Standing still for 30 frames (unless it can charge Link again)
@stateA:
	ld b,$08		; $529a
	call objectCheckCenteredWithLink		; $529c
	jp c,@chargeLink		; $529f

	call _ecom_decCounter1		; $52a2
	jr nz,@animate	; $52a5

	ld l,Enemy.state		; $52a7
	ld (hl),$08		; $52a9
	ld l,Enemy.speed		; $52ab
	ld (hl),SPEED_40		; $52ad
	jp @setRandomAngleAndCounter1		; $52af


; Flipped over.
@stateB:
	call _ecom_decCounter1		; $52b2
	jr nz,++		; $52b5

	; Flip back to normal.

	ld l,e			; $52b7
	inc (hl) ; [state] = $0c
	ld l,Enemy.speed		; $52b9
	ld (hl),SPEED_c0		; $52bb

	ld l,Enemy.enemyCollisionMode		; $52bd
	ld (hl),ENEMYCOLLISION_SPIKED_BEETLE		; $52bf
	ld l,Enemy.xh		; $52c1
	inc (hl)		; $52c3
	ld bc,-$180		; $52c4
	call objectSetSpeedZ		; $52c7
	xor a			; $52ca
	jp enemySetAnimation		; $52cb
++
	; Waiting to flip back.
	ld a,(hl)		; $52ce
	cp 60			; $52cf
	jr nc,@animate	; $52d1

	; In last second, start shaking.
	and $06			; $52d3
	rrca			; $52d5
	ld hl,@xOscillationOffsets	; $52d6
	rst_addAToHl			; $52d9
	ld e,Enemy.xh		; $52da
	ld a,(de)		; $52dc
	add (hl)		; $52dd
	ld (de),a		; $52de
	jr @animate		; $52df


; In the process of flipping back to normal.
@stateC:
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $52e1
	call enemyAnimate		; $52e4

	ld c,$18		; $52e7
	call objectUpdateSpeedZ_paramC		; $52e9
	ret nz			; $52ec

	ld e,Enemy.state		; $52ed
	ld a,$08		; $52ef
	ld (de),a		; $52f1

	ld b,$10		; $52f2
	call objectCheckCenteredWithLink		; $52f4
	jr c,@chargeLink	; $52f7

	ld e,Enemy.speed		; $52f9
	ld a,SPEED_40		; $52fb
	ld (de),a		; $52fd
	ret			; $52fe

;;
; Angle and counter1 are set randomly (counter1 is between $30-$60, in increments of $10).
; @addr{52ff}
@setRandomAngleAndCounter1:
	ldbc $18,$30		; $52ff
	call _ecom_randomBitwiseAndBCE		; $5302
	ld e,Enemy.angle		; $5305
	ld a,b			; $5307
	ld (de),a		; $5308
	ld e,Enemy.counter1		; $5309
	ld a,$30		; $530b
	add c			; $530d
	ld (de),a		; $530e
	ret			; $530f

;;
; @addr{5310}
@chargeLink:
	call _ecom_updateCardinalAngleTowardTarget		; $5310
	ld h,d			; $5313
	ld l,Enemy.state		; $5314
	ld (hl),$09		; $5316
	ld l,Enemy.counter2		; $5318
	ld (hl),150		; $531a
	ld l,Enemy.speed		; $531c
	ld (hl),SPEED_40		; $531e
	ret			; $5320

;;
; @addr{5321}
@incSpeed:
	ld e,Enemy.counter2		; $5321
	ld a,(de)		; $5323
	and $03			; $5324
	ret nz			; $5326

	ld e,Enemy.speed		; $5327
	ld a,(de)		; $5329
	cp SPEED_180			; $532a
	ret nc			; $532c
	add SPEED_20			; $532d
	ld (de),a		; $532f
	ret			; $5330

@xOscillationOffsets:
	.db $01 $ff $ff $01


; ==============================================================================
; ENEMYID_BUBBLE
; ==============================================================================
enemyCode15:
	jr z,@normalStatus	; $5335
	sub ENEMYSTATUS_NO_HEALTH			; $5337
	ret c			; $5339

	; Check if collided with Link; disable sword if so.
	ld e,Enemy.var2a		; $533a
	ld a,(de)		; $533c
	cp $80|ITEMCOLLISION_LINK			; $533d
	jr nz,@normalStatus	; $533f

	ld a,WHISP_RING		; $5341
	call cpActiveRing		; $5343
	jr z,@normalStatus	; $5346

	ld a,180		; $5348
	ld (wSwordDisabledCounter),a		; $534a

@normalStatus:
	ld e,Enemy.state		; $534d
	ld a,(de)		; $534f
	rst_jumpTable			; $5350
	.dw @state_uninitialized
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state8

@state_uninitialized:
	call getRandomNumber_noPreserveVars		; $5363
	and $18			; $5366
	ld e,Enemy.angle		; $5368
	ld (de),a		; $536a
	ld a,SPEED_c0		; $536b
	call _ecom_setSpeedAndState8		; $536d
	jp objectSetVisible82		; $5370


@state_stub:
	ret			; $5373


@state8:
	call @checkCenteredOnTile		; $5374
	call z,@chooseNewDirection		; $5377
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $537a
	call z,@chooseNewDirection		; $537d
	jp enemyAnimate		; $5380

;;
; @addr{5383}
@chooseNewDirection:
	ldbc $07,$18		; $5383
	call _ecom_randomBitwiseAndBCE		; $5386
	or b			; $5389
	ret nz			; $538a
	ld e,Enemy.angle		; $538b
	ld a,c			; $538d
	ld (de),a		; $538e
	ret			; $538f

;;
; @param[out]	zflag	z if centered
; @addr{5390}
@checkCenteredOnTile:
	ld h,d			; $5390
	ld l,Enemy.yh		; $5391
	ldi a,(hl)		; $5393
	ld b,a			; $5394
	inc l			; $5395
	ld c,(hl)		; $5396
	or c			; $5397
	and $07			; $5398
	ret			; $539a


; ==============================================================================
; ENEMYID_BEAMOS
; ==============================================================================
enemyCode16:
	jr z,@normalStatus	; $539b
	sub ENEMYSTATUS_NO_HEALTH			; $539d
	ret c			; $539f

@normalStatus:
	ld e,Enemy.state		; $53a0
	ld a,(de)		; $53a2
	rst_jumpTable			; $53a3
	.dw @state_uninitialized
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state8
	.dw @state9


@state_uninitialized:
	call _ecom_setSpeedAndState8AndVisible		; $53b8
	ld l,Enemy.counter1		; $53bb
	ld (hl),$05		; $53bd
	jp objectMakeTileSolid		; $53bf


@state_stub:
	ret			; $53c2


@state8:
	call @updateAngle		; $53c3
	call _ecom_decCounter2		; $53c6
	ret nz			; $53c9
	jr @checkFireBeam		; $53ca


@state9:
	call _ecom_decCounter1		; $53cc
	jr nz,++		; $53cf
	ld (hl),$05 ; [counter1] = 5
	inc l			; $53d3
	ld (hl),40  ; [counter2] = 40
	ld l,e			; $53d6
	dec (hl) ; [state] = 8
	ret			; $53d8
++
	; Play sound on 11th-to-last frame
	ld a,(hl)		; $53d9
	cp $0b			; $53da
	ld a,SND_BEAM		; $53dc
	jp z,playSound		; $53de
	ret nc			; $53e1

	; Spawn projectile every frame for 10 frames
	ld b,PARTID_BEAM		; $53e2
	call _ecom_spawnProjectile		; $53e4
	ret nz			; $53e7

	ld e,Enemy.counter1		; $53e8
	ld a,(de)		; $53ea
	and $01			; $53eb
	ld l,Part.subid		; $53ed
	ld (hl),a		; $53ef
	ret			; $53f0

;;
; Increments angle every 5 frames.
; @addr{53f1}
@updateAngle:
	call _ecom_decCounter1		; $53f1
	ret nz			; $53f4

	ld (hl),$05		; $53f5
	ld l,Enemy.angle		; $53f7
	ld a,(hl)		; $53f9
	inc a			; $53fa
	and $1f			; $53fb
	ld (hl),a		; $53fd

	ld hl,@angleToAnimation		; $53fe
	rst_addAToHl			; $5401
	ld a,(hl)		; $5402
	jp enemySetAnimation		; $5403

@angleToAnimation:
	.db $00 $00 $01 $01 $01 $01 $01 $02
	.db $02 $02 $03 $03 $03 $03 $03 $04
	.db $04 $04 $05 $05 $05 $05 $05 $06
	.db $06 $06 $07 $07 $07 $07 $07 $00

;;
; @addr{5426}
@checkFireBeam:
	call objectGetAngleTowardEnemyTarget		; $5426
	ld h,d			; $5429
	ld l,Enemy.angle		; $542a
	sub (hl)		; $542c
	inc a			; $542d
	cp $02			; $542e
	ret nc			; $5430

	ld l,Enemy.counter1		; $5431
	ld (hl),20		; $5433

	; "Invincibility" is just for the glowing effect?
	ld l,Enemy.invincibilityCounter		; $5435
	ld (hl),$14		; $5437

	ld l,Enemy.state		; $5439
	inc (hl) ; [state] = 9
	ret			; $543c


; ==============================================================================
; ENEMYID_GHINI
;
; Variables:
;   var30/31: Target Y/X position for subid 2 only
; ==============================================================================
enemyCode17:
	jr z,@normalStatus	; $543d
	sub ENEMYSTATUS_NO_HEALTH			; $543f
	jr c,@stunned	; $5441
	jr z,@dead	; $5443
	dec a			; $5445
	jp nz,_ecom_updateKnockbackNoSolidity		; $5446
	ret			; $5449

@stunned:
	ld e,Enemy.stunCounter		; $544a
	ld a,(de)		; $544c
	or a			; $544d
	ret nz			; $544e

	; Restore normal Z position when stun is over?
	ld e,Enemy.zh		; $544f
	ld a,$fe		; $5451
	ld (de),a		; $5453
	ret			; $5454

@dead:
	ld e,Enemy.subid		; $5455
	ld a,(de)		; $5457
	dec a			; $5458
	jp z,enemyDie		; $5459

	; For subid 1 only, kill all other ghinis with subid 1.
	ldhl FIRST_ENEMY_INDEX, Enemy.id		; $545c
@nextGhini:
	ld a,(hl)		; $545f
	cp ENEMYID_GHINI			; $5460
	jr nz,++		; $5462
	inc l			; $5464
	ldd a,(hl)		; $5465
	dec a			; $5466
	jr nz,++			; $5467
	call _ecom_killObjectH		; $5469
	ld l,Enemy.id		; $546c
++
	inc h			; $546e
	ld a,h			; $546f
	cp LAST_ENEMY_INDEX+1			; $5470
	jr c,@nextGhini	; $5472
	jp enemyDie		; $5474


@normalStatus:
	call _ecom_getSubidAndCpStateTo08		; $5477
	jr nc,@normalState	; $547a
	rst_jumpTable			; $547c
	.dw @state_uninitialized
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw _ecom_blownByGaleSeedState
	.dw @state_stub
	.dw @state_stub

@normalState:
	ld a,b			; $548d
	rst_jumpTable			; $548e
	.dw _ghini_subid00
	.dw _ghini_subid01
	.dw _ghini_subid02


@state_uninitialized:
	ld a,SPEED_80		; $5495
	call _ecom_setSpeedAndState8		; $5497
	ld l,Enemy.zh		; $549a
	ld (hl),$fe		; $549c

	; Check for subid 1 only
	ld a,b			; $549e
	dec a			; $549f
	jr nz,++		; $54a0

	ld l,Enemy.counter1		; $54a2
	ld (hl),60		; $54a4
	ld l,Enemy.angle		; $54a6
	ld (hl),$10		; $54a8
	ld l,Enemy.collisionType		; $54aa
	res 7,(hl)		; $54ac
++
	jp objectSetVisiblec1		; $54ae


@state_stub:
	ret			; $54b1


; Normal ghini.
_ghini_subid00:
	ld a,(de)		; $54b2
	sub $08			; $54b3
	rst_jumpTable			; $54b5
	.dw @state8
	.dw @state9

@state8:
	; Set random angle, counter1
	ldbc $18,$7f		; $54ba
	call _ecom_randomBitwiseAndBCE		; $54bd
	ld h,d			; $54c0
	ld l,Enemy.counter1		; $54c1
	ld a,$30		; $54c3
	add c			; $54c5
	ld (hl),a		; $54c6
	ld l,Enemy.angle		; $54c7
	ld (hl),b		; $54c9

	ld l,Enemy.state		; $54ca
	inc (hl)		; $54cc
	jp _ghini_updateAnimationFromAngle		; $54cd

@state9:
	call _ghini_updateMovement		; $54d0
	call _ecom_decCounter1		; $54d3
	jr nz,++		; $54d6

	; Go back to state 8 to decide a new direction.
	ld l,Enemy.state		; $54d8
	dec (hl)		; $54da
++
	jp enemyAnimate		; $54db


; This type takes a second to spawn in, and killing one ghini of subid 1 makes all other
; die too?
_ghini_subid01:
	ld a,(de)		; $54de
	sub $08			; $54df
	rst_jumpTable			; $54e1
	.dw @state8
	.dw @state9
	.dw @stateA
	.dw @stateB
	.dw @stateC


; Fading in.
@state8:
	call _ecom_decCounter1		; $54ec
	jr z,++			; $54ef

	; Flicker visibility
	ld a,(hl)		; $54f1
	and $01			; $54f2
	ret nz			; $54f4
	jp _ecom_flickerVisibility		; $54f5
++
	; Make visible, enable collisions
	ld l,Enemy.visible		; $54f8
	set 7,(hl)		; $54fa
	ld l,Enemy.collisionType		; $54fc
	set 7,(hl)		; $54fe
	call @gotoStateC		; $5500
	jr @animate		; $5503


; Just wandering around until counter1 reaches 0.
@state9:
	call _ghini_updateMovement		; $5505
	ld a,(wFrameCounter)		; $5508
	rrca			; $550b
	jr nc,@animate	; $550c
	call _ecom_decCounter1		; $550e
	jr z,@incState	; $5511

	call getRandomNumber_noPreserveVars		; $5513
	cp $08			; $5516
	jr nc,@animate	; $5518

	; Rare chance (1/8192 per frame) of moving directly toward Link
	; Otherwise just takes a new random angle
	ldbc $1f,$1f		; $551a
	call _ecom_randomBitwiseAndBCE		; $551d
	or b			; $5520
	ld a,c			; $5521
	call z,objectGetAngleTowardEnemyTarget		; $5522
	ld e,Enemy.angle		; $5525
	ld (de),a		; $5527
	call _ghini_updateAnimationFromAngle		; $5528
	jr @animate		; $552b

@incState:
	call _ecom_incState		; $552d
	ld l,Enemy.counter1		; $5530
	ld (hl),$00		; $5532
	jr @animate		; $5534


; Gradually decrease speed for 128 frames
@stateA:
	ld h,d			; $5536
	ld l,Enemy.counter1		; $5537
	inc (hl)		; $5539
	ld a,(hl)		; $553a
	cp $80			; $553b
	jp c,_ghini_updateMovementAndSetSpeedFromCounter1		; $553d

	ld (hl),$80		; $5540
	ld l,e			; $5542
	inc (hl) ; [state] = $0b
@animate:
	jp enemyAnimate		; $5544


; Stop moving for 128 frames
@stateB:
	call _ecom_decCounter1		; $5547
	jr nz,@animate	; $554a


@gotoStateC:
	ld l,Enemy.state		; $554c
	ld (hl),$0c		; $554e
	ld l,Enemy.counter1		; $5550
	ld (hl),$7f		; $5552
	ld l,Enemy.speed		; $5554
	ld (hl),SPEED_20		; $5556
	jr @animate		; $5558


; Gradually increase speed for 128 frames
@stateC:
	call _ecom_decCounter1		; $555a
	jp nz,_ghini_updateMovementAndSetSpeedFromCounter1		; $555d

	ld l,e			; $5560
	ld (hl),$09		; $5561
	call getRandomNumber_noPreserveVars		; $5563
	ld e,Enemy.counter1		; $5566
	and $7f			; $5568
	add $7f			; $556a
	ld (de),a		; $556c
	jr @animate		; $556d


_ghini_subid02:
	ld a,(de)		; $556f
	sub $08			; $5570
	rst_jumpTable			; $5572
	.dw @state8
	.dw @state9
	.dw @stateA
	.dw @stateB


; Choose a random target position to move toward
@state8:
	ld h,d			; $557b
	ld l,e			; $557c
	inc (hl)		; $557d
	ld l,Enemy.speed		; $557e
	ld (hl),SPEED_40		; $5580
	ld l,Enemy.counter1		; $5582
	ld (hl),$24		; $5584
	call _ghini_chooseTargetPosition		; $5586


; Grudually increasing speed while moving toward target
@state9:
	call _ecom_decCounter1		; $5589
	jr nz,++		; $558c

	ld l,e			; $558e
	inc (hl) ; [state] = $0a
	jr @stateA		; $5590
++
	ld a,(hl)		; $5592
	and $07			; $5593
	jr nz,@stateA	; $5595
	ld l,Enemy.speed		; $5597
	ld a,(hl)		; $5599
	add SPEED_20			; $559a
	ld (hl),a		; $559c


; Moving toward target
@stateA:
	ld h,d			; $559d
	ld l,Enemy.var30		; $559e
	call _ecom_readPositionVars		; $55a0

	; Check that the target is at least 2 pixels away in either direction.
	sub c			; $55a3
	inc a			; $55a4
	cp $03			; $55a5
	jr nc,@moveTowardTarget	; $55a7
	ldh a,(<hFF8F)	; $55a9
	sub b			; $55ab
	inc a			; $55ac
	cp $03			; $55ad
	jr nc,@moveTowardTarget	; $55af

	; We've reached the target; go to state $0b.
	ld l,Enemy.state		; $55b1
	ld (hl),$0b		; $55b3
	ld l,Enemy.counter1		; $55b5
	ld (hl),$1c		; $55b7
	jr @stateB		; $55b9

@moveTowardTarget:
	call _ecom_moveTowardPosition		; $55bb
	call _ghini_updateAnimationFromAngle		; $55be
@animate:
	jp enemyAnimate		; $55c1


; Gradually decreasing speed
@stateB:
	call _ecom_decCounter1		; $55c4
	jr z,@gotoState8	; $55c7

	ld a,(hl)		; $55c9
	and $07			; $55ca
	jr nz,++		; $55cc
	ld l,Enemy.speed		; $55ce
	ld a,(hl)		; $55d0
	sub SPEED_20			; $55d1
	ld (hl),a		; $55d3
++
	call objectApplySpeed		; $55d4
	jr @animate		; $55d7

@gotoState8:
	ld l,e			; $55d9
	ld (hl),$08		; $55da
	jr @state8			; $55dc


;;
; Sets speed, where it's higher if counter1 is lower.
; @addr{55de}
_ghini_updateMovementAndSetSpeedFromCounter1:
	call _ghini_updateMovement		; $55de
	ld e,Enemy.counter1		; $55e1
	ld a,(de)		; $55e3
	ld b,$00		; $55e4
	cp $2a			; $55e6
	jr c,++			; $55e8
	inc b			; $55ea
	cp $54			; $55eb
	jr c,++			; $55ed
	inc b			; $55ef
++
	ld a,b			; $55f0
	ld hl,@speeds		; $55f1
	rst_addAToHl			; $55f4
	ld e,Enemy.speed		; $55f5
	ld a,(hl)		; $55f7
	ld (de),a		; $55f8
	jr _ghini_subid02@animate		; $55f9

@speeds:
	.db SPEED_80, SPEED_40, SPEED_20

;;
; @addr{55fe}
_ghini_updateMovement:
	call objectApplySpeed		; $55fe
	call _ecom_bounceOffScreenBoundary		; $5601
	ret z			; $5604

;;
; @addr{5605}
_ghini_updateAnimationFromAngle:
	ld h,d			; $5605
	ld l,Enemy.angle		; $5606
	ldd a,(hl)		; $5608
	cp $10			; $5609
	ld a,$01		; $560b
	jr c,+			; $560d
	dec a			; $560f
+
	cp (hl)			; $5610
	ret z			; $5611
	ld (hl),a		; $5612
	jp enemySetAnimation		; $5613

;;
; Sets var30/var31 to target position for subid 2.
;
; Target position seems to always be somewhere around the center of the room, even moreso
; for large rooms.
;
; @addr{5616}
_ghini_chooseTargetPosition:
	ldbc $70,$70		; $5616
	call _ecom_randomBitwiseAndBCE		; $5619
	ld a,b			; $561c
	sub $20			; $561d
	jr nc,+			; $561f
	xor a			; $5621
+
	ld b,a			; $5622

	; b = [wRoomEdgeY]/2 + b - $28
	ld hl,wRoomEdgeY		; $5623
	ldi a,(hl)		; $5626
	srl a			; $5627
	add b			; $5629
	sub $28			; $562a
	ld b,a			; $562c

	; c = [wRoomEdgeX]/2 + c - $38
	ld a,(hl)		; $562d
	srl a			; $562e
	add c			; $5630
	sub $38			; $5631
	ld c,a			; $5633
	ld h,d			; $5634

	ld l,Enemy.var30		; $5635
	ld (hl),b		; $5637
	inc l			; $5638
	ld (hl),c		; $5639
	ret			; $563a


; ==============================================================================
; ENEMYID_BUZZBLOB
;
; Variables:
;   var30: Animation index ($02 if in cukeman form)
;   var31: "pressedAButton" variable (set to $01 when pressed A, only in cukeman form)
; ==============================================================================
enemyCode18:
	call _ecom_checkHazards		; $563b
	jr z,@normalStatus	; $563e
	sub ENEMYSTATUS_NO_HEALTH			; $5640
	jp c,_buzzblob_checkShowText		; $5642
	jp z,enemyDie		; $5645

	dec a			; $5648
	jp nz,_ecom_updateKnockbackAndCheckHazards		; $5649

	; Just hit by something

	ld h,d			; $564c
	ld l,Enemy.var2a		; $564d
	ld a,(hl)		; $564f
	cp $80|ITEMCOLLISION_MYSTERY_SEED			; $5650
	jr z,@becomeCukeman	; $5652

	cp $80|ITEMCOLLISION_ELECTRIC_SHOCK			; $5654
	ret nz			; $5656

	; Link hit the buzzblob, go to state $0a
	ld l,Enemy.state		; $5657
	ld (hl),$0a		; $5659

	; Disable scent seeds
	ld l,Enemy.var3f		; $565b
	res 4,(hl)		; $565d

	ld l,Enemy.stunCounter		; $565f
	ld (hl),$00		; $5661
	ld l,Enemy.counter1		; $5663
	ld (hl),60		; $5665
	ld a,$01		; $5667
	jp enemySetAnimation		; $5669


; Buzzblob becomes cukeman when using mystery seed on it.
@becomeCukeman:
	ld l,Enemy.var30		; $566c
	ld a,$02		; $566e
	cp (hl)			; $5670
	ret z			; $5671
	ld (hl),a		; $5672
	call enemySetAnimation		; $5673
	ld e,Enemy.pressedAButton		; $5676
	jp objectAddToAButtonSensitiveObjectList		; $5678

@normalStatus:
	call _buzzblob_checkShowText		; $567b
	call _ecom_checkScentSeedActive		; $567e
	ld e,Enemy.state		; $5681
	ld a,(de)		; $5683
	rst_jumpTable			; $5684
	.dw _buzzblob_state_uninitialized
	.dw _buzzblob_state_stub
	.dw _buzzblob_state_stub
	.dw _buzzblob_state_stub
	.dw _buzzblob_state_scentSeed
	.dw _ecom_blownByGaleSeedState
	.dw _buzzblob_state_stub
	.dw _buzzblob_state_stub
	.dw _buzzblob_state8
	.dw _buzzblob_state9
	.dw _buzzblob_stateA


_buzzblob_state_uninitialized:
	ld a,SPEED_40		; $569b
	call _ecom_setSpeedAndState8AndVisible		; $569d

	; Enable moving toward scent seeds, and...?
	ld l,Enemy.var3f		; $56a0
	ld a,(hl)		; $56a2
	or $30			; $56a3
	ld (hl),a		; $56a5

	ret			; $56a6


_buzzblob_state_scentSeed:
	ld a,(wScentSeedActive)		; $56a7
	or a			; $56aa
	jr nz,++		; $56ab
	ld a,$08		; $56ad
	ld (de),a ; [state] = 8
	jr _buzzblob_animate		; $56b0
++
	call _ecom_updateAngleToScentSeed		; $56b2
	ld e,Enemy.angle		; $56b5
	ld a,(de)		; $56b7
	add $04			; $56b8
	and $18			; $56ba
	ld (de),a		; $56bc
	call _ecom_applyVelocityForSideviewEnemy		; $56bd
	jp enemyAnimate		; $56c0


_buzzblob_state_stub:
	ret			; $56c3


; Choosing a direction and duration to move
_buzzblob_state8:
	ld a,$09		; $56c4
	ld (de),a ; [state] = 9

	; Set random angle and counter1
	ldbc $1c,$30		; $56c7
	call _ecom_randomBitwiseAndBCE		; $56ca
	ld e,Enemy.counter1		; $56cd
	ld a,$30		; $56cf
	add c			; $56d1
	ld (de),a		; $56d2
	ld e,Enemy.angle		; $56d3
	ld a,b			; $56d5
	ld (de),a		; $56d6
	jr _buzzblob_animate		; $56d7


; Moving in some direction for a certain amount of time
_buzzblob_state9:
	call _ecom_decCounter1		; $56d9
	jr z,_buzzblob_chooseNewDirection	; $56dc
	call _ecom_bounceOffWallsAndHoles		; $56de
	call objectApplySpeed		; $56e1
_buzzblob_animate:
	jp enemyAnimate		; $56e4


; "Shocking Link" state
_buzzblob_stateA:
	call _ecom_decCounter1		; $56e7
	jr nz,_buzzblob_animate	; $56ea
	ld e,Enemy.var30		; $56ec
	ld a,(de)		; $56ee
	call enemySetAnimation		; $56ef

_buzzblob_chooseNewDirection:
	ld h,d			; $56f2
	ld l,Enemy.state		; $56f3
	ld (hl),$08 ; Will choose new direction in state 8

	; Enable scent seeds
	ld l,Enemy.var3f		; $56f7
	set 4,(hl)		; $56f9

	ld l,Enemy.collisionType		; $56fb
	set 7,(hl)		; $56fd
	jr _buzzblob_animate		; $56ff

;;
; @addr{5701}
_buzzblob_checkShowText:
	ld e,Enemy.var31		; $5701
	ld a,(de)		; $5703
	or a			; $5704
	ret z			; $5705

	xor a			; $5706
	ld (de),a		; $5707
	call getRandomNumber_noPreserveVars		; $5708
	and $07			; $570b
	add <TX_2f1e			; $570d
	ld c,a			; $570f
	ld b,>TX_2f00		; $5710
	jp showText		; $5712


; ==============================================================================
; ENEMYID_SAND_CRAB
; ==============================================================================
enemyCode1a:
	jr z,@normalStatus	; $5715
	sub ENEMYSTATUS_NO_HEALTH			; $5717
	ret c			; $5719
	jp z,enemyDie		; $571a
	dec a			; $571d
	jp nz,_ecom_updateKnockback		; $571e
	ret			; $5721
@normalStatus:
	call _ecom_checkScentSeedActive		; $5722
	ld e,Enemy.state		; $5725
	ld a,(de)		; $5727
	rst_jumpTable			; $5728
	.dw @state_uninitialized
	.dw @state_stub
	.dw @state_stub
	.dw @state_switchHook
	.dw @state_scentSeed
	.dw _ecom_blownByGaleSeedState
	.dw @state_stub
	.dw @state_stub
	.dw @state8
	.dw @state9


@state_uninitialized:
	ld h,d			; $573d
	ld l,Enemy.var3f		; $573e
	set 4,(hl)		; $5740
	jp _ecom_setSpeedAndState8AndVisible		; $5742


@state_scentSeed:
	ld a,(wScentSeedActive)		; $5745
	or a			; $5748
	jr nz,++		; $5749
	ld a,$08		; $574b
	ld (de),a ; [state] = 8
	jr @animate		; $574e
++
	call _ecom_updateAngleToScentSeed		; $5750
	ld e,Enemy.angle		; $5753
	ld a,(de)		; $5755
	add $04			; $5756
	and $18			; $5758
	ld (de),a		; $575a

	; Faster when moving left/right instead of up/down
	bit 3,a			; $575b
	ld a,SPEED_40		; $575d
	jr z,+			; $575f
	ld a,SPEED_100		; $5761
+
	ld e,Enemy.speed		; $5763
	ld (de),a		; $5765

	call _ecom_applyVelocityForSideviewEnemy		; $5766
	jr @animate		; $5769


@state_switchHook:
	inc e			; $576b
	ld a,(de)		; $576c
	rst_jumpTable			; $576d
	.dw _ecom_incState2
	.dw @@substate1
	.dw @@substate2
	.dw _ecom_fallToGroundAndSetState8


@@substate1:
@@substate2:
	ret			; $5776


@state_stub:
	ret			; $5777



; Choose random angle to move in
@state8:
	ld a,$09		; $5778
	ld (de),a ; [state] = 9

	; Get random angle & duration for walk
	ldbc $18,$30		; $577b
	call _ecom_randomBitwiseAndBCE		; $577e
	ld e,$86		; $5781
	ld a,$30		; $5783
	add c			; $5785
	ld (de),a		; $5786

	; Faster when moving left/right
	bit 3,b			; $5787
	ld a,SPEED_40		; $5789
	jr z,+			; $578b
	ld a,SPEED_100		; $578d
+
	ld e,$90		; $578f
	ld (de),a		; $5791

	ld e,Enemy.angle		; $5792
	ld a,b			; $5794
	ld (de),a		; $5795
	jr @animate		; $5796


; Moving in direction for [counter1] frames
@state9:
	call _ecom_decCounter1		; $5798
	jr z,++			; $579b
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $579d
	jr nz,@animate	; $57a0
++
	ld e,Enemy.state		; $57a2
	ld a,$08		; $57a4
	ld (de),a		; $57a6
@animate:
	jp enemyAnimate		; $57a7


; ==============================================================================
; ENEMYID_SPINY_BEETLE
;
; Variables:
;   var03: $80 when stationary, $81 when charging Link. Child object (bush or rock) reads
;          this to determine relative Z position. Bit 7 is set to indicate it's grabbable.
;   var3b: Probably unused?
; ==============================================================================
enemyCode1b:
	call _ecom_checkHazards		; $57aa
	jr z,@normalStatus	; $57ad
	sub ENEMYSTATUS_NO_HEALTH			; $57af
	ret c			; $57b1
	jp z,enemyDie		; $57b2

	dec a			; $57b5
	jp nz,_ecom_updateKnockbackAndCheckHazards		; $57b6

	; ENEMYSTATUS_JUST_HIT
	; If Link just hit the enemy, start moving
	ld e,Enemy.var2a		; $57b9
	ld a,(de)		; $57bb
	cp $80|ITEMCOLLISION_LINK			; $57bc
	ret nz			; $57be

	ld e,Enemy.state		; $57bf
	ld a,(de)		; $57c1
	cp $08			; $57c2
	jr nz,@normalStatus	; $57c4
	call _ecom_updateCardinalAngleTowardTarget		; $57c6
	jp @chargeAtLink		; $57c9

@normalStatus:
	ld e,Enemy.state		; $57cc
	ld a,(de)		; $57ce
	rst_jumpTable			; $57cf
	.dw @state_uninitialized
	.dw @state_stub
	.dw @state_stub
	.dw @state_switchHook
	.dw @state_stub
	.dw _ecom_blownByGaleSeedState
	.dw @state_stub
	.dw @state_stub
	.dw @state8
	.dw @state9
	.dw @stateA
	.dw @stateB


@state_uninitialized:
	; Spawn the bush or rock to hide under
	ld b,ENEMYID_BUSH_OR_ROCK		; $57e8
	call _ecom_spawnUncountedEnemyWithSubid01		; $57ea
	ret nz			; $57ed

	ld e,l			; $57ee
	ld a,(de)		; $57ef
	ld (hl),a ; [child.subid] = [this.subid]

	ld l,Enemy.relatedObj1		; $57f1
	ld a,Enemy.start		; $57f3
	ldi (hl),a		; $57f5
	ld (hl),d		; $57f6

	ld e,Enemy.relatedObj2		; $57f7
	ld (de),a		; $57f9
	inc e			; $57fa
	ld a,h			; $57fb
	ld (de),a		; $57fc

	call objectCopyPosition		; $57fd

	ld a,SPEED_e0		; $5800
	call _ecom_setSpeedAndState8		; $5802

	ld l,Enemy.collisionRadiusY		; $5805
	ld a,$03		; $5807
	ldi (hl),a		; $5809
	ld (hl),a		; $580a

	ld l,Enemy.var03		; $580b
	ld (hl),$80		; $580d

	; Change collisionType only for those hiding under rocks?
	dec l			; $580f
	ld a,(hl)		; $5810
	cp $02			; $5811
	ret c			; $5813

	; Borrow beamos collisions (nothing can kill it until rock is removed)
	ld l,Enemy.collisionType		; $5814
	ld (hl),$80|ENEMYID_BEAMOS		; $5816
	ret			; $5818


@state_switchHook:
	inc e			; $5819
	ld a,(de)		; $581a
	rst_jumpTable			; $581b
	.dw _ecom_incState2
	.dw @@substate1
	.dw @@substate2
	.dw _ecom_fallToGroundAndSetState8

@@substate1:
@@substate2:
	ret			; $5824


@state_stub:
	ret			; $5825


; Waiting for Link to move close enough.
@state8:
	call @checkBushOrRockGone		; $5826
	ret z			; $5829
	call _ecom_decCounter2		; $582a
	ret nz			; $582d

	ld b,$0c		; $582e
	call objectCheckCenteredWithLink		; $5830
	ret nc			; $5833

	call _ecom_updateCardinalAngleTowardTarget		; $5834
	or a			; $5837
	ret z ; For some reason he never moves up?

	ld a,$01		; $5839
	call _ecom_getTopDownAdjacentWallsBitset		; $583b
	ret nz			; $583e


@chargeAtLink:
	call _ecom_incState ; [state] = 9
	ld l,Enemy.counter1		; $5842
	ld (hl),$38		; $5844
	ld l,Enemy.var03		; $5846
	ld (hl),$81		; $5848
	jp objectSetVisiblec3		; $584a


; Moving toward Link
@state9:
	call @checkBushOrRockGone		; $584d
	ret z			; $5850
	call _ecom_decCounter1		; $5851
	jr z,++			; $5854
	call _ecom_applyVelocityForTopDownEnemyNoHoles		; $5856
	jr nz,@animate	; $5859
++
	ld h,d			; $585b
	ld l,Enemy.counter2		; $585c
	ld (hl),30		; $585e

	ld l,Enemy.state		; $5860
	dec (hl)		; $5862

	ld l,Enemy.var03		; $5863
	ld (hl),$80		; $5865
	ld l,Enemy.var3b		; $5867
	ld (hl),$00		; $5869

	jp objectSetInvisible		; $586b


; Just lost protection (bush or rock).
@stateA:
	call _ecom_decCounter1		; $586e
	jr nz,@animate	; $5871
	inc (hl)		; $5873
	ld l,e			; $5874
	inc (hl)		; $5875
	jr @animate		; $5876


; Moving around randomly after losing protection.
@stateB:
	call _ecom_decCounter1		; $5878
	jr nz,++		; $587b

	ld (hl),40		; $587d
	call getRandomNumber_noPreserveVars		; $587f
	and $1c			; $5882
	ld e,Enemy.angle		; $5884
	ld (de),a		; $5886
	jr @animate		; $5887
++
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $5889
@animate:
	jp enemyAnimate		; $588c


;;
; Checks if the object we're hiding under is gone; if so, updates collisionType,
; collisiosRadius, visibility, and sets state to $0a
;
; @param[out]	zflag	z if the object it's hiding under is gone
; @addr{588f}
@checkBushOrRockGone:
	ld e,Enemy.relatedObj2+1		; $588f
	ld a,(de)		; $5891
	or a			; $5892
	ret nz			; $5893

	ld h,d			; $5894
	ld l,Enemy.state		; $5895
	ld (hl),$0a		; $5897
	ld l,Enemy.counter1		; $5899
	ld (hl),60		; $589b

	; Restore normal collisions
	ld l,Enemy.collisionType		; $589d
	ld (hl),$80|ENEMYID_SPINY_BEETLE		; $589f

	ld l,Enemy.collisionRadiusY		; $58a1
	ld a,$06		; $58a3
	ldi (hl),a		; $58a5
	ld (hl),a		; $58a6
	call objectSetVisiblec3		; $58a7
	xor a			; $58aa
	ret			; $58ab

; ==============================================================================
; ENEMYID_ARMOS
;
; Variables:
;   subid: If bit 7 is set, it's a real armos; otherwise it's an armos spawner.
;   var31: The initial position of the armos (subid 1 only)
; ==============================================================================
enemyCode1d:
	call _ecom_checkHazards		; $58ac
	jr z,@normalStatus	; $58af
	sub ENEMYSTATUS_NO_HEALTH			; $58b1
	ret c			; $58b3
	jp z,_armos_dead		; $58b4

	dec a			; $58b7
	jp nz,_ecom_updateKnockbackAndCheckHazards		; $58b8

	; ENEMYSTATUS_JUST_HIT

	; For subid $80, if Link touches this position, activate the armos.
	ld e,Enemy.var2a		; $58bb
	ld a,(de)		; $58bd
	cp $80|ITEMCOLLISION_LINK			; $58be
	ret nz			; $58c0

	ld e,Enemy.subid		; $58c1
	ld a,(de)		; $58c3
	cp $80			; $58c4
	jr nz,@normalStatus	; $58c6

	ld h,d			; $58c8
	ld l,Enemy.state		; $58c9
	ld a,(hl)		; $58cb
	cp $09			; $58cc
	jr nc,@normalStatus	; $58ce
	ld (hl),$09		; $58d0
	ret			; $58d2

@normalStatus:
	call _ecom_getSubidAndCpStateTo08		; $58d3
	jr nc,@normalState	; $58d6
	rst_jumpTable			; $58d8
	.dw _armos_uninitialized
	.dw _armos_state1
	.dw _armos_state_stub
	.dw _armos_state_switchHook
	.dw _armos_state_stub
	.dw _armos_state_stub
	.dw _armos_state_stub
	.dw _armos_state_stub

@normalState:
	res 7,b			; $58e9
	ld a,b			; $58eb
	rst_jumpTable			; $58ec
	.dw _armos_subid00
	.dw _armos_subid01


_armos_uninitialized:
	ld a,b			; $58f1
	bit 7,a			; $58f2
	jr z,@gotoState1	; $58f4

	add a			; $58f6
	ld hl,@oamFlagsAndSpeeds		; $58f7
	rst_addAToHl			; $58fa
	ld e,Enemy.oamFlags		; $58fb
	ldi a,(hl)		; $58fd
	ld (de),a		; $58fe
	dec e			; $58ff
	ld (de),a		; $5900
	ld a,(hl)		; $5901
	call _ecom_setSpeedAndState8		; $5902

	; Subid 1 gets more health
	ld l,Enemy.subid		; $5905
	bit 0,(hl)		; $5907
	jr z,+			; $5909
	ld l,Enemy.health		; $590b
	inc (hl)		; $590d
+
	; Effectively disable collisions
	ld l,Enemy.collisionType		; $590e
	ld (hl),$80|ENEMYID_PODOBOO		; $5910
	ret			; $5912

@gotoState1:
	ld a,$01		; $5913
	ld (de),a		; $5915
	ret			; $5916

@oamFlagsAndSpeeds:
	.db $05, SPEED_80 ; subid 0
	.db $04, SPEED_c0 ; subid 1


; For subid where bit 7 isn't set; spawn armos at all positions where their tiles are.
; (Enemy.yh currently contains the tile to replace, Enemy.xh is the new tile it becomes.)
_armos_state1:
	ld e,Enemy.yh		; $591b
	ld a,(de)		; $591d
	ld b,a			; $591e
	ld hl,wRoomLayout		; $591f
	ld c,LARGE_ROOM_HEIGHT<<4		; $5922
--
	ld a,(hl)		; $5924
	cp b			; $5925
	call z,_armos_spawnArmosAtPosition		; $5926
	inc l			; $5929
	dec c			; $592a
	jr nz,--		; $592b

	call _armos_clearKilledArmosBuffer		; $592d
	call decNumEnemies		; $5930
	jp enemyDelete		; $5933


_armos_state_switchHook:
	inc e			; $5936
	ld a,(de)		; $5937
	rst_jumpTable			; $5938
	.dw _ecom_incState2
	.dw @substate1
	.dw @substate2
	.dw @substate3


@substate1:
@substate2:
	ret			; $5941

@substate3:
	ld b,$0b		; $5942
	jp _ecom_fallToGroundAndSetState		; $5944


_armos_state_stub:
	ret			; $5947


_armos_subid00:
	ld a,(de)		; $5948
	sub $08			; $5949
	rst_jumpTable			; $594b
	.dw _armos_subid00_state8
	.dw _armos_state9
	.dw _armos_subid00_stateA
	.dw _armos_subid00_stateB
	.dw _armos_subid00_stateC

; Waiting for Link to touch the statue (or for "$cca2" trigger?)
_armos_subid00_state8:
	ld a,($cca2)		; $5956
	or a			; $5959
	ret z			; $595a
	ld a,$09		; $595b
	ld (de),a		; $595d
	ret			; $595e


; The statue was just activated
_armos_state9:
	ld h,d			; $595f
	ld l,e			; $5960
	inc (hl) ; [state] = $0a
	ld l,Enemy.counter1		; $5962
	ld (hl),60		; $5964
	ld l,Enemy.yh		; $5966
	inc (hl)		; $5968
	inc (hl)		; $5969
	jp objectSetVisible82		; $596a


; Flickering until it starts moving
_armos_subid00_stateA:
	call _ecom_decCounter1		; $596d
	jp nz,_ecom_flickerVisibility		; $5970

	ld a,ENEMYCOLLISION_ACTIVE_RED_ARMOS		; $5973

;;
; @param	a	EnemyCollisionMode
; @addr{5975}
_armos_beginMoving:
	ld l,e			; $5975
	inc (hl) ; [state] = $0b

	; Enable normal collisions
	ld l,Enemy.collisionType		; $5977
	ld (hl),$80|ENEMYID_ARMOS		; $5979

	inc l			; $597b
	ldi (hl),a ; Set enemyCollisionMode

	; Set collisionRadiusY/X
	ld a,$06		; $597d
	ldi (hl),a		; $597f
	ld (hl),a		; $5980

	call _armos_replaceTileUnderSelf		; $5981
	jp objectSetVisiblec2		; $5984


; Choose a direction to move
_armos_subid00_stateB:
	ld h,d			; $5987
	ld l,e			; $5988
	inc (hl) ; [state] = $0c

	ld l,Enemy.counter1		; $598a
	ld (hl),61		; $598c
	call _ecom_setRandomCardinalAngle		; $598e


; Moving in some direction for [counter1] frames
_armos_subid00_stateC:
	call _ecom_decCounter1		; $5991
	call nz,_ecom_applyVelocityForTopDownEnemyNoHoles		; $5994
	jr nz,++		; $5997
	ld e,Enemy.state		; $5999
	ld a,$0b		; $599b
	ld (de),a		; $599d
++
	jp enemyAnimate		; $599e


_armos_subid01:
	ld a,(de)		; $59a1
	sub $08			; $59a2
	rst_jumpTable			; $59a4
	.dw _armos_subid01_state8
	.dw _armos_state9
	.dw _armos_subid01_stateA
	.dw _armos_subid02_stateB
	.dw _armos_subid03_stateC


; Waiting for Link to approach the statue
_armos_subid01_state8:
	call _armos_subid00_state8		; $59af
	ret nz			; $59b2

	ld h,d			; $59b3
	ld l,Enemy.yh		; $59b4
	ldh a,(<hEnemyTargetY)	; $59b6
	sub (hl)		; $59b8
	add $18			; $59b9
	cp $31			; $59bb
	ret nc			; $59bd

	ld b,(hl)		; $59be
	ld l,Enemy.xh		; $59bf
	ldh a,(<hEnemyTargetX)	; $59c1
	sub (hl)		; $59c3
	add $18			; $59c4
	cp $31			; $59c6
	ret nc			; $59c8

	; Link has gotten close enough; activate the armos.
	ld a,(hl)		; $59c9
	and $f0			; $59ca
	swap a			; $59cc
	ld c,a			; $59ce
	ld a,b			; $59cf
	and $f0			; $59d0
	or c			; $59d2
	ld l,Enemy.var31		; $59d3
	ld (hl),a		; $59d5

	ld l,e			; $59d6
	inc (hl) ; [state] = 9
	ret			; $59d8


; Flickering until it starts moving
_armos_subid01_stateA:
	call _ecom_decCounter1		; $59d9
	jp nz,_ecom_flickerVisibility		; $59dc
	ld a,ENEMYCOLLISION_ACTIVE_BLUE_ARMOS		; $59df
	jp _armos_beginMoving		; $59e1


; Choose random new direction & amount of time to move in that direction
_armos_subid02_stateB:
	ld a,$0c		; $59e4
	ld (de),a ; [state] = $0c

	; Get counter1
	ldbc $03,$03		; $59e7
	call _ecom_randomBitwiseAndBCE		; $59ea
	ld a,b			; $59ed
	ld hl,@counter1Vals		; $59ee
	rst_addAToHl			; $59f1
	ld e,Enemy.counter1		; $59f2
	ld a,(hl)		; $59f4
	ld (de),a		; $59f5

	; 1 in 4 chance of moving directly toward Link
	ld a,c			; $59f6
	or a			; $59f7
	jp z,_ecom_updateCardinalAngleTowardTarget		; $59f8
	jp _ecom_setRandomCardinalAngle		; $59fb

@counter1Vals:
	.db 30, 45, 60, 75


; Moving in some direction for [counter1] frames
_armos_subid03_stateC:
	call _ecom_decCounter1		; $5a02
	jr z,++			; $5a05
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $5a07
	jr z,++			; $5a0a
	jp enemyAnimate		; $5a0c
++
	ld e,Enemy.state		; $5a0f
	ld a,$0b		; $5a11
	ld (de),a		; $5a13
	ret			; $5a14

;;
; @param	l	Position to spawn at
; @addr{5a15}
_armos_spawnArmosAtPosition:
	push bc			; $5a15
	push hl			; $5a16
	ld c,l			; $5a17

	ld b,ENEMYID_ARMOS		; $5a18
	call _ecom_spawnEnemyWithSubid01		; $5a1a
	jr nz,@ret	; $5a1d

	ld e,l			; $5a1f
	ld a,(de)		; $5a20
	set 7,a			; $5a21
	ld (hl),a ; [child.subid] = [this.subid]|$80

	; [child.var30] = [this.xh] = tile to replace underneath new armos
	ld e,Enemy.xh		; $5a24
	ld l,Enemy.var30		; $5a26
	ld a,(de)		; $5a28
	ld (hl),a		; $5a29

	; Take short-form position in 'c', write to child's position
	ld l,e			; $5a2a
	ld a,c			; $5a2b
	and $0f			; $5a2c
	swap a			; $5a2e
	add $08			; $5a30
	ldd (hl),a		; $5a32
	dec l			; $5a33
	ld a,c			; $5a34
	and $f0			; $5a35
	add $06			; $5a37
	ld (hl),a		; $5a39
@ret:
	pop hl			; $5a3a
	pop bc			; $5a3b
	ret			; $5a3c

;;
; @addr{5a3d}
_armos_dead:
	ld e,Enemy.subid		; $5a3d
	ld a,(de)		; $5a3f
	rrca			; $5a40
	jp nc,enemyDie		; $5a41

	; Subid 1 only: record the initial position of the armos that was killed.
	ld e,Enemy.var31		; $5a44
	ld a,(de)		; $5a46
	ld b,a			; $5a47
	ld hl,wTmpcfc0.armosStatue.killedArmosPositions-1		; $5a48
--
	inc l			; $5a4b
	ld a,(hl)		; $5a4c
	or a			; $5a4d
	jr nz,--		; $5a4e
	ld (hl),b		; $5a50
	jp enemyDie		; $5a51

;;
; @addr{5a54}
_armos_clearKilledArmosBuffer:
	ld hl,wTmpcfc0.armosStatue.killedArmosPositions		; $5a54
	xor a			; $5a57
	ld b,$04		; $5a58
--
	ldi (hl),a		; $5a5a
	ldi (hl),a		; $5a5b
	ldi (hl),a		; $5a5c
	ldi (hl),a		; $5a5d
	dec b			; $5a5e
	jr nz,--		; $5a5f
	ret			; $5a61

;;
; Replace the tile underneath the armos with [var30].
; @addr{5a62}
_armos_replaceTileUnderSelf:
	call objectGetTileAtPosition		; $5a62
	ld c,l			; $5a65
	ld e,Enemy.var30		; $5a66
	ld a,(de)		; $5a68
	jp setTile		; $5a69


; ==============================================================================
; ENEMYID_PIRANHA
;
; Variables:
;   zh: Equals 2 when underwater
;   var30: Current animation index
; ==============================================================================
enemyCode1e:
	jr z,@normalStatus	; $5a6c
	sub $03			; $5a6e
	jr c,@stunned	; $5a70
	jp z,enemyDie		; $5a72
	dec a			; $5a75
	ret z			; $5a76

	; ENEMYSTATUS_KNOCKBACK

	ld e,Enemy.speed		; $5a77
	ld a,SPEED_200		; $5a79
	ld (de),a		; $5a7b
	call _fish_getAdjacentWallsBitsetForKnockback		; $5a7c

	ld e,Enemy.knockbackAngle		; $5a7f
	call _ecom_applyVelocityGivenAdjacentWalls		; $5a81

	ld e,Enemy.speed		; $5a84
	ld a,SPEED_c0		; $5a86
	ld (de),a		; $5a88
	ret			; $5a89

@stunned:
	ld e,Enemy.zh		; $5a8a
	ld a,(de)		; $5a8c
	cp $02			; $5a8d
	ret z			; $5a8f
	or a			; $5a90
	ret nz			; $5a91
	jp _fish_enterWater		; $5a92

@normalStatus:
	call _ecom_getSubidAndCpStateTo08		; $5a95
	jr nc,@normalState	; $5a98
	rst_jumpTable			; $5a9a
	.dw _fish_state_uninitialized
	.dw _fish_state_stub
	.dw _fish_state_stub
	.dw _fish_state_stub
	.dw _fish_state_stub
	.dw _ecom_blownByGaleSeedState
	.dw _fish_state_stub
	.dw _fish_state_stub

@normalState:
	ld a,b			; $5aab
	rst_jumpTable			; $5aac
	.dw _fish_subid00
	.dw _fish_subid01


_fish_state_uninitialized:
	ld a,SPEED_80		; $5ab1
	call _ecom_setSpeedAndState8		; $5ab3
	call objectSetVisible83		; $5ab6

	ld l,Enemy.zh		; $5ab9
	ld (hl),$02		; $5abb
	ld l,Enemy.angle		; $5abd
	ld (hl),ANGLE_RIGHT		; $5abf

	call _fish_setRandomCounter1		; $5ac1
	jp _fish_updateAnimationFromAngle		; $5ac4


_fish_state_stub:
	ret			; $5ac7


_fish_subid00:
	ld a,(de)		; $5ac8
	sub $08			; $5ac9
	rst_jumpTable			; $5acb
	.dw @state8
	.dw @state9


; Moving below water.
@state8:
	ld a,(wScentSeedActive)		; $5ad0
	or a			; $5ad3
	jr nz,++		; $5ad4
	call _ecom_decCounter1		; $5ad6
	jr z,@leapOutOfWater		; $5ad9
++
	call _fish_updatePosition		; $5adb
	jp _fish_checkReverseAngle		; $5ade

@leapOutOfWater:
	ld l,e			; $5ae1
	inc (hl)		; $5ae2
	ld l,Enemy.enemyCollisionMode		; $5ae3
	ld (hl),ENEMYCOLLISION_SWITCHHOOK_DAMAGE_ENEMY		; $5ae5
	ld l,Enemy.zh		; $5ae7
	ld (hl),$00		; $5ae9

	ld l,Enemy.speedZ		; $5aeb
	ld a,<(-$180)		; $5aed
	ldi (hl),a		; $5aef
	ld (hl),>(-$180)		; $5af0

	ld l,Enemy.speed		; $5af2
	ld (hl),SPEED_c0		; $5af4
	ld b,INTERACID_SPLASH		; $5af6
	call objectCreateInteractionWithSubid00		; $5af8
	call objectSetVisiblec1		; $5afb
	ld b,$00		; $5afe
	jp _fish_setAnimation		; $5b00


; Leaping outside the water.
@state9:
	ld c,$10		; $5b03
	call objectUpdateSpeedZ_paramC		; $5b05
	jr z,_fish_enterWater	; $5b08

	ld l,Enemy.speedZ		; $5b0a
	ld a,(hl)		; $5b0c
	or a			; $5b0d
	jr nz,++		; $5b0e
	inc l			; $5b10
	ld a,(hl)		; $5b11
	or a			; $5b12
	jr nz,++		; $5b13
	ld b,$01		; $5b15
	call _fish_setAnimation		; $5b17
++
	jp _fish_updatePosition		; $5b1a


;;
; @addr{5b1d}
_fish_enterWater:
	ld h,d			; $5b1d
	ld l,Enemy.enemyCollisionMode		; $5b1e
	ld (hl),ENEMYCOLLISION_PODOBOO		; $5b20
	ld l,Enemy.zh		; $5b22
	ld (hl),$02		; $5b24

	ld l,Enemy.state		; $5b26
	ld (hl),$08		; $5b28

	ld l,Enemy.speed		; $5b2a
	ld (hl),SPEED_80		; $5b2c

	call _fish_setRandomCounter1		; $5b2e
	ld b,INTERACID_SPLASH		; $5b31
	call objectCreateInteractionWithSubid00		; $5b33
	call objectSetVisible83		; $5b36
	jp _fish_updateAnimationFromAngle		; $5b39



_fish_subid01:
	ld a,(de)		; $5b3c
	sub $08			; $5b3d
	rst_jumpTable			; $5b3f
	.dw @state8

@state8:
	ret			; $5b42

;;
; @param	cflag	c if we were able to move
; @addr{5b43}
_fish_checkReverseAngle:
	ret c			; $5b43
	ld e,Enemy.angle		; $5b44
	ld a,(de)		; $5b46
	xor $10			; $5b47
	ld (de),a		; $5b49

;;
; @addr{5b4a}
_fish_updateAnimationFromAngle:
	ld e,Enemy.angle		; $5b4a
	ld a,(de)		; $5b4c
	swap a			; $5b4d
	rlca			; $5b4f
	ld hl,@animations		; $5b50
	rst_addAToHl			; $5b53
	ld a,(hl)		; $5b54
	ld h,d			; $5b55
	ld l,Enemy.var30		; $5b56
	cp (hl)			; $5b58
	ret z			; $5b59
	ld (hl),a		; $5b5a
	jp enemySetAnimation		; $5b5b

@animations:
	.db $02 $01 $02 $00

;;
; Sets animation (3 or 5 is added to value passed if we're moving right or left)
;
; @param	b	Value to add to animation index
; @addr{5b62}
_fish_setAnimation:
	ld e,Enemy.angle		; $5b62
	ld a,(de)		; $5b64
	swap a			; $5b65
	and $01			; $5b67
	ld a,$03		; $5b69
	jr nz,+			; $5b6b
	ld a,$05		; $5b6d
+
	add b			; $5b6f
	ld h,d			; $5b70
	ld l,Enemy.var30		; $5b71
	cp (hl)			; $5b73
	ret z			; $5b74
	ld (hl),a		; $5b75
	jp enemySetAnimation		; $5b76


;;
; @param[out]	cflag	c if we were able to move (tile in front of us is traversable)
; @addr{5b79}
_fish_updatePosition:
	ld e,Enemy.angle		; $5b79
	ld a,(de)		; $5b7b
	rrca			; $5b7c
	rrca			; $5b7d
	ld hl,@directionOffsets		; $5b7e
	rst_addAToHl			; $5b81

	ld e,Enemy.yh		; $5b82
	ld a,(de)		; $5b84
	add (hl)		; $5b85
	and $f0			; $5b86
	ld c,a			; $5b88

	inc hl			; $5b89
	ld e,Enemy.xh		; $5b8a
	ld a,(de)		; $5b8c
	add (hl)		; $5b8d
	and $f0			; $5b8e
	swap a			; $5b90

	or c			; $5b92
	ld c,a			; $5b93
	ld b,>wRoomLayout		; $5b94
	ld a,(bc)		; $5b96
	sub TILEINDEX_PUDDLE			; $5b97
	cp TILEINDEX_FD-TILEINDEX_PUDDLE+1			; $5b99
	ret nc			; $5b9b
	call objectApplySpeed		; $5b9c
	scf			; $5b9f
	ret			; $5ba0

@directionOffsets:
	.db $f0 $00
	.db $00 $10
	.db $10 $00
	.db $00 $f0

;;
; @addr{5ba9}
_fish_setRandomCounter1:
	call getRandomNumber_noPreserveVars		; $5ba9
	and $03			; $5bac
	ld hl,@counter1Vals		; $5bae
	rst_addAToHl			; $5bb1
	ld e,Enemy.counter1		; $5bb2
	ld a,(hl)		; $5bb4
	ld (de),a		; $5bb5
	ret			; $5bb6

@counter1Vals:
	.db $40 $50 $60 $70

;;
; Gets the "adjacent walls bitset" for the fish; since this swims, water is traversable,
; everything else is not.
;
; This is identical to "_waterTektite_getAdjacentWallsBitsetGivenAngle".
;
; @param[out]	hFF8B	Bitset of adjacent walls
; @addr{5bbb}
_fish_getAdjacentWallsBitsetForKnockback:
	ld e,Enemy.knockbackAngle		; $5bbb
	ld a,(de)		; $5bbd
	call _ecom_getAdjacentWallTableOffset		; $5bbe

	ld h,d			; $5bc1
	ld l,Enemy.yh		; $5bc2
	ld b,(hl)		; $5bc4
	ld l,Enemy.xh		; $5bc5
	ld c,(hl)		; $5bc7
	ld hl,_ecom_sideviewAdjacentWallOffsetTable		; $5bc8
	rst_addAToHl			; $5bcb

	ld a,$10		; $5bcc
	ldh (<hFF8B),a	; $5bce
	ld d,>wRoomLayout		; $5bd0
---
	ldi a,(hl)		; $5bd2
	add b			; $5bd3
	ld b,a			; $5bd4
	and $f0			; $5bd5
	ld e,a			; $5bd7
	ldi a,(hl)		; $5bd8
	add c			; $5bd9
	ld c,a			; $5bda
	and $f0			; $5bdb
	swap a			; $5bdd
	or e			; $5bdf
	ld e,a			; $5be0
	ld a,(de)		; $5be1
	sub TILEINDEX_PUDDLE			; $5be2
	cp TILEINDEX_FD-TILEINDEX_PUDDLE+1			; $5be4
	ldh a,(<hFF8B)	; $5be6
	rla			; $5be8
	ldh (<hFF8B),a	; $5be9
	jr nc,---		; $5beb

	xor $0f			; $5bed
	ldh (<hFF8B),a	; $5bef
	ldh a,(<hActiveObject)	; $5bf1
	ld d,a			; $5bf3
	ret			; $5bf4


; ==============================================================================
; ENEMYID_POLS_VOICE
;
; Variables:
;   var30: gravity
; ==============================================================================
enemyCode23:
	call _ecom_checkHazardsNoAnimationForHoles		; $5bf5
	call _polsVoice_checkLinkPlayingInstrument		; $5bf8
	jr z,@normalStatus	; $5bfb
	sub ENEMYSTATUS_NO_HEALTH			; $5bfd
	ret c			; $5bff
	jp z,enemyDie		; $5c00

	dec a			; $5c03
	jp nz,_ecom_updateKnockbackAndCheckHazards		; $5c04
	ret			; $5c07

@normalStatus:
	ld e,Enemy.state		; $5c08
	ld a,(de)		; $5c0a
	rst_jumpTable			; $5c0b
	.dw _polsVoice_state_uninitialized
	.dw _polsVoice_state_stub
	.dw _polsVoice_state_stub
	.dw _polsVoice_state_stub
	.dw _polsVoice_state_stub
	.dw _ecom_blownByGaleSeedState
	.dw _polsVoice_state_stub
	.dw _polsVoice_state_stub
	.dw _polsVoice_state8
	.dw _polsVoice_state9

_polsVoice_state_uninitialized:
	; Note: a is uninitialized; arbitrary speed
	call _ecom_setSpeedAndState8		; $5c20

	call getRandomNumber_noPreserveVars		; $5c23
	ld e,Enemy.counter1		; $5c26
	and $3f			; $5c28
	inc a			; $5c2a
	ld (de),a		; $5c2b
	jr _polsVoice_setLandedAnimation		; $5c2c


_polsVoice_state_stub:
	ret			; $5c2e


_polsVoice_state8:
	call _ecom_decCounter1		; $5c2f
	ret nz			; $5c32

	ld l,e			; $5c33
	inc (hl) ; [state] = 9

	; Randomly read in 3 speed values: speedZ, gravity (var30), and speed.
	ld bc,$0f1c		; $5c35
	call _ecom_randomBitwiseAndBCE		; $5c38
	or b			; $5c3b
	ld hl,@jumpSpeeds1		; $5c3c
	jr nz,+			; $5c3f
	ld hl,@jumpSpeeds2		; $5c41
+
	ld e,Enemy.speedZ		; $5c44
	ldi a,(hl)		; $5c46
	ld (de),a		; $5c47
	inc e			; $5c48
	ldi a,(hl)		; $5c49
	ld (de),a		; $5c4a

	; [var30] = gravity
	ld e,Enemy.var30		; $5c4b
	ldi a,(hl)		; $5c4d
	ld (de),a		; $5c4e

	ld e,Enemy.speed		; $5c4f
	ld a,(hl)		; $5c51
	ld (de),a		; $5c52
	cp SPEED_80			; $5c53
	jr z,++			; $5c55

	; For high speed jump, target Link directly instead of using a random angle
	call objectGetAngleTowardEnemyTarget		; $5c57
	add $02			; $5c5a
	and $1c			; $5c5c
	ld c,a			; $5c5e
++
	ld e,Enemy.angle		; $5c5f
	ld a,c			; $5c61
	ld (de),a		; $5c62
	xor a			; $5c63
	call enemySetAnimation		; $5c64
	jp objectSetVisiblec1		; $5c67


; Word: Initial speedZ
; Byte: gravity
; Byte: speed
@jumpSpeeds1:
	dwbb -$128, $0c, SPEED_80
@jumpSpeeds2:
	dwbb -$180, $0c, SPEED_c0


_polsVoice_state9:
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $5c72
	ld e,Enemy.var30		; $5c75
	ld a,(de)		; $5c77
	ld c,a			; $5c78
	call objectUpdateSpeedZ_paramC		; $5c79
	ret nz			; $5c7c

	; Landed
	ld h,d			; $5c7d
	ld l,Enemy.state		; $5c7e
	dec (hl) ; [state] = 8
	ld l,Enemy.counter1		; $5c81
	ld (hl),$20		; $5c83

_polsVoice_setLandedAnimation:
	ld a,$01		; $5c85
	call enemySetAnimation		; $5c87
	jp objectSetVisiblec2		; $5c8a

;;
; @param	a	Enemy status
; @param[out]	a	Updated enemy status
; @addr{5c8d}
_polsVoice_checkLinkPlayingInstrument:
	ld b,a			; $5c8d
	ld a,(wLinkPlayingInstrument)		; $5c8e
	or a			; $5c91
	jr z,+			; $5c92
	ld b,ENEMYSTATUS_NO_HEALTH		; $5c94
+
	ld a,b			; $5c96
	or a			; $5c97
	ret			; $5c98


; ==============================================================================
; ENEMYID_LIKE_LIKE
;
; Variables:
;   relatedObj1: Pointer to the like-like spawner (subid 1), if one exists.
;   var30: Number of like-likes on-screen (for subid 1)
; ==============================================================================
enemyCode24:
	call _likelike_checkHazards		; $5c99
	jr z,@normalStatus	; $5c9c
	sub ENEMYSTATUS_NO_HEALTH			; $5c9e
	ret c			; $5ca0
	jr z,@dead	; $5ca1

	dec a			; $5ca3
	jp nz,_ecom_updateKnockbackAndCheckHazards		; $5ca4

	; ENEMYSTATUS_JUST_HIT

	ld e,Enemy.var2a		; $5ca7
	ld a,(de)		; $5ca9
	cp $80|ITEMCOLLISION_LINK			; $5caa
	ret nz			; $5cac

	; Just collided with Link. omnomnom
	ld h,d			; $5cad
	ld l,Enemy.yh		; $5cae
	ldi a,(hl)		; $5cb0
	ld b,a			; $5cb1
	inc l			; $5cb2
	ld c,(hl)		; $5cb3

	; Don't eat him if Link would (somehow) get stuck in a wall
	callab bank5.checkPositionSurroundedByWalls		; $5cb4
	rl b			; $5cbc
	jp c,_likelike_releaseLink		; $5cbe

	ld e,Enemy.subid		; $5cc1
	ld a,(de)		; $5cc3
	or a			; $5cc4
	ld a,$0b		; $5cc5
	jr z,+			; $5cc7
	inc a			; $5cc9
+
	ld h,d			; $5cca
	ld l,Enemy.state		; $5ccb
	ldi (hl),a		; $5ccd
	inc l			; $5cce
	ld (hl),$00 ; [counter1] = 0
	inc l			; $5cd1
	ld (hl),90  ; [counter2] = 90

	ld l,Enemy.collisionType		; $5cd4
	res 7,(hl)		; $5cd6

	; Link copies Likelike's position
	ld hl,w1Link		; $5cd8
	call objectCopyPosition		; $5cdb

	ld l,<w1Link.collisionType		; $5cde
	res 7,(hl)		; $5ce0

	ld a,$01		; $5ce2
	call enemySetAnimation		; $5ce4
	jp objectSetVisiblec1		; $5ce7


@dead:
	; Decrement spawner's counter
	ld e,Enemy.relatedObj1+1		; $5cea
	ld a,(de)		; $5cec
	or a			; $5ced
	jp z,enemyDie		; $5cee

	ld h,a			; $5cf1
	ld l,Enemy.var30		; $5cf2
	dec (hl)		; $5cf4
	jp enemyDie		; $5cf5


@normalStatus:
	call _ecom_getSubidAndCpStateTo08		; $5cf8
	jr nc,@normalState	; $5cfb
	rst_jumpTable			; $5cfd
	.dw _likelike_state_uninitialized
	.dw _likelike_state_stub
	.dw _likelike_state_stub
	.dw _likelike_state_switchHook
	.dw _likelike_state_stub
	.dw _likelike_state_galeSeed
	.dw _likelike_state_stub
	.dw _likelike_state_stub

@normalState:
	ld a,b			; $5d0e
	rst_jumpTable			; $5d0f
	.dw _likelike_subid00
	.dw _likelike_subid01
	.dw _likelike_subid02
	.dw _likelike_subid03


_likelike_state_uninitialized:
	bit 0,b			; $5d18
	call z,objectSetVisiblec2		; $5d1a
	ld a,SPEED_40		; $5d1d
	jp _ecom_setSpeedAndState8		; $5d1f


_likelike_state_switchHook:
	inc e			; $5d22
	ld a,(de)		; $5d23
	rst_jumpTable			; $5d24
	.dw _ecom_incState2
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate1:
@substate2:
	ret			; $5d2d

@substate3:
	ld e,Enemy.subid		; $5d2e
	ld a,(de)		; $5d30
	ld hl,@defaultStates		; $5d31
	rst_addAToHl			; $5d34
	ld b,(hl)		; $5d35
	jp _ecom_fallToGroundAndSetState		; $5d36

@defaultStates:
	.db $09 $08 $0a $0a


_likelike_state_galeSeed:
	call _ecom_galeSeedEffect		; $5d3d
	ret c			; $5d40

	; Decrement spawner's counter
	ld e,Enemy.relatedObj1+1		; $5d41
	ld a,(de)		; $5d43
	or a			; $5d44
	jr z,++			; $5d45
	ld h,a			; $5d47
	ld l,Enemy.var30		; $5d48
	dec (hl)		; $5d4a
++
	call decNumEnemies		; $5d4b
	jp enemyDelete		; $5d4e


_likelike_state_stub:
	ret			; $5d51


_likelike_subid00:
	ld a,(de)		; $5d52
	sub $08			; $5d53
	rst_jumpTable			; $5d55
	.dw _likelike_subid00_state8
	.dw _likelike_state9
	.dw _likelike_stateA
	.dw _likelike_stateB
	.dw _likelike_stateC


; Initialization
_likelike_subid00_state8:
	ld h,d			; $5d60
	ld l,e			; $5d61
	inc (hl) ; [state]++
	ld l,Enemy.collisionType		; $5d63
	set 7,(hl)		; $5d65


; Choosing a new direction & duration
_likelike_state9:
	ld h,d			; $5d67
	ld l,e			; $5d68
	inc (hl) ; [state]++

	ldbc $18,$30		; $5d6a
	call _ecom_randomBitwiseAndBCE		; $5d6d
	ld e,Enemy.angle		; $5d70
	ld a,b			; $5d72
	ld (de),a		; $5d73
	ld e,Enemy.counter1		; $5d74
	ld a,$38		; $5d76
	add c			; $5d78
	ld (de),a		; $5d79
	jr _likelike_animate		; $5d7a


; Moving in some direction for [counter1] frames
_likelike_stateA:
	call _ecom_decCounter1		; $5d7c
	jr nz,@move	; $5d7f

@newDirection:
	ld h,d			; $5d81
	ld l,Enemy.state		; $5d82
	dec (hl)		; $5d84
	jr _likelike_animate		; $5d85

@move:
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $5d87
	jr z,@newDirection	; $5d8a

_likelike_animate:
	jp enemyAnimate		; $5d8c


; Eating Link
_likelike_stateB:
	call _ecom_decCounter2		; $5d8f
	jr z,@releaseLink	; $5d92

	; Mashing 19 buttons before being released prevents like-like from eating shield
	ld a,(wGameKeysJustPressed)		; $5d94
	or a			; $5d97
	jr z,_likelike_animate	; $5d98
	dec l			; $5d9a
	inc (hl) ; [counter1]++
	jr _likelike_animate		; $5d9c

@releaseLink:
	ld (hl),60		; $5d9e

	ld l,Enemy.state		; $5da0
	inc (hl)		; $5da2

	ld l,Enemy.counter1		; $5da3
	ld a,(hl)		; $5da5
	cp 19			; $5da6
	jr nc,++		; $5da8
	ld a,TREASURE_SHIELD		; $5daa
	call checkTreasureObtained		; $5dac
	jr nc,++		; $5daf

	ld a,TREASURE_SHIELD		; $5db1
	call loseTreasure		; $5db3
	ld bc,TX_510b		; $5db6
	call showText		; $5db9
++
	call getRandomNumber_noPreserveVars		; $5dbc
	and $18			; $5dbf
	ld e,Enemy.angle		; $5dc1
	ld (de),a		; $5dc3
	call objectSetVisiblec2		; $5dc4

;;
; @addr{5dc7}
_likelike_releaseLink:
	; Release link from LINK_STATE_GRABBED
	ld hl,w1Link.state2		; $5dc7
	ld (hl),$04		; $5dca

	ld l,<w1Link.collisionType		; $5dcc
	set 7,(hl)		; $5dce
	xor a			; $5dd0
	jp enemySetAnimation		; $5dd1


; Cooldown after eating Link; won't eat him again for another 60 frames
_likelike_stateC:
	call _ecom_decCounter2		; $5dd4
	jr nz,++		; $5dd7

	ld l,e			; $5dd9
	ld a,(hl)		; $5dda
	sub $03			; $5ddb
	ld (hl),a ; [state] -= 3

	ld l,Enemy.collisionType		; $5dde
	set 7,(hl)		; $5de0
	jr _likelike_animate		; $5de2
++
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $5de4
	jr nz,_likelike_animate	; $5de7

	; Ran into wall
	call getRandomNumber_noPreserveVars		; $5de9
	and $18			; $5dec
	ld e,Enemy.angle		; $5dee
	ld (de),a		; $5df0
	jr _likelike_animate		; $5df1


; Like-like spawner.
_likelike_subid01:
	ld a,(de)		; $5df3
	sub $08			; $5df4
	rst_jumpTable			; $5df6
	.dw @state8
	.dw @state9
	.dw @stateA

@state8:
	ld h,d			; $5dfd
	ld l,e			; $5dfe
	inc (hl)		; $5dff
	ld l,Enemy.counter1		; $5e00
	inc (hl)		; $5e02
	jp _likelike_findAllLikelikesWithSubid0		; $5e03


; Wait for Link to move past the screen edge
@state9:
	; Y from $10-$6f
	ld a,(w1Link.yh)		; $5e06
	sub $10			; $5e09
	cp (SMALL_ROOM_HEIGHT<<4)-$20			; $5e0b
	ret nc			; $5e0d

	; X from $10-$8f
	ld a,(w1Link.xh)		; $5e0e
	sub $10			; $5e11
	cp (SMALL_ROOM_WIDTH<<4)-$20			; $5e13
	ret nc			; $5e15

	ld a,$0a		; $5e16
	ld (de),a ; [state] = $0a

; Check to spawn more like-likes.
@stateA:
	call _ecom_decCounter1		; $5e19
	ret nz			; $5e1c

	inc (hl) ; [counter1] = 1

	; No more than 6 like-likes at once
	ld l,Enemy.var30		; $5e1e
	ld a,(hl)		; $5e20
	cp $06			; $5e21
	ret nc			; $5e23

	call getRandomNumber_noPreserveVars		; $5e24
	and $02			; $5e27
	ld c,a			; $5e29
	ld a,(wActiveRoom)		; $5e2a
	cp $50			; $5e2d
	jr z,@fromTop	; $5e2f
	cp $40			; $5e31
	jr z,@fromBottom	; $5e33

	set 2,c			; $5e35
	cp $51			; $5e37
	ret nz			; $5e39

@fromBottom:
	ld e,$02		; $5e3a
	call _likelike_spawn		; $5e3c
	ret nz			; $5e3f
	call _likelike_setChildSpawnPosition		; $5e40
	jr ++			; $5e43
@fromTop:
	ld e,$03		; $5e45
	call _likelike_spawn		; $5e47
	ret nz			; $5e4a
++
	; Successfully spawned a like-like.
	ld h,d			; $5e4b
	ld l,Enemy.var30		; $5e4c
	inc (hl)		; $5e4e
	ld l,Enemy.counter1		; $5e4f
	ld (hl),120		; $5e51
	ret			; $5e53


_likelike_subid02:
	ld a,(de)		; $5e54
	sub $08			; $5e55
	rst_jumpTable			; $5e57
	.dw @state8
	.dw @state9
	.dw _likelike_state9 ; States actually offset by 1 compared to subid 0...
	.dw _likelike_stateA
	.dw _likelike_stateB
	.dw _likelike_stateC

; Initialization
@state8:
	ld h,d			; $5e64
	ld l,e			; $5e65
	inc (hl) ; [state] = 9

	; Set angle to ANGLE_UP (default) if spawning from bottom, or ANGLE_RIGHT if
	; spawning from left of screen
	ld l,Enemy.yh		; $5e67
	ld a,(hl)		; $5e69
	cp (SMALL_ROOM_HEIGHT<<4)+8			; $5e6a
	jr z,+			; $5e6c
	ld l,Enemy.angle		; $5e6e
	ld (hl),ANGLE_RIGHT		; $5e70
+
	ld l,Enemy.counter1		; $5e72
	ld (hl),45		; $5e74
	ret			; $5e76

; Move forward until we're well into the screen boundary
@state9:
	call _ecom_decCounter1		; $5e77
	jr z,++			; $5e7a
	call objectApplySpeed		; $5e7c
	jr _likelike_animate2		; $5e7f
++
	ld l,e			; $5e81
	inc (hl)		; $5e82
	ld l,Enemy.collisionType		; $5e83
	set 7,(hl)		; $5e85

_likelike_animate2:
	jp enemyAnimate		; $5e87


_likelike_subid03:
	ld a,(de)		; $5e8a
	sub $08			; $5e8b
	rst_jumpTable			; $5e8d
	.dw @state8
	.dw @state9
	.dw _likelike_state9 ; States actually offset by 1 compared to subid 0...
	.dw _likelike_stateA
	.dw @stateB
	.dw _likelike_stateC


; Initialization (spawning above the screen).
@state8:
	call _likelike_chooseRandomPosition		; $5e9a
	ret nz			; $5e9d
	ld l,Enemy.state		; $5e9e
	inc (hl)		; $5ea0
	ld l,Enemy.collisionType		; $5ea1
	set 7,(hl)		; $5ea3

	ld l,Enemy.speedZ+1		; $5ea5
	ld (hl),$02		; $5ea7
	jp objectSetVisiblec1		; $5ea9


; Falling to the ground.
@state9:
	ld c,$08		; $5eac
	call objectUpdateSpeedZ_paramC		; $5eae
	jr nz,_likelike_animate2	; $5eb1

	; Hit the ground.
	ld l,Enemy.state		; $5eb3
	inc (hl)		; $5eb5
	call objectSetVisiblec2		; $5eb6
	jr _likelike_animate2		; $5eb9


; Eating Link. Since this falls from the sky, this has extra height-related code.
@stateB:
	ld c,$08		; $5ebb
	call objectUpdateSpeedZ_paramC		; $5ebd
	ld l,Enemy.zh		; $5ec0
	ld a,(hl)		; $5ec2
	ld (w1Link.zh),a		; $5ec3
	jp _likelike_stateB		; $5ec6

;;
; Spawner (subid 1) calls this to make new like-likes where their relatedObj1 references
; the spawner.
;
; @param	e	Subid of like-like to spwan
; @addr{5ec9}
_likelike_spawn:
	ld b,ENEMYID_LIKE_LIKE		; $5ec9
	call _ecom_spawnEnemyWithSubid01		; $5ecb
	ret nz			; $5ece
	ld (hl),e		; $5ecf
	ld l,Enemy.relatedObj1		; $5ed0
	ld a,Enemy.start		; $5ed2
	ldi (hl),a		; $5ed4
	ld (hl),d		; $5ed5
	xor a			; $5ed6
	ret			; $5ed7

;;
; @param	c	Index of spawn position to use
; @addr{5ed8}
_likelike_setChildSpawnPosition:
	push hl			; $5ed8
	ld a,c			; $5ed9
	ld hl,@spawnPositions		; $5eda
	rst_addAToHl			; $5edd
	ldi a,(hl)		; $5ede
	ld b,a			; $5edf
	ld c,(hl)		; $5ee0
	pop hl			; $5ee1
	ld l,Enemy.yh		; $5ee2
	ld (hl),b		; $5ee4
	ld l,Enemy.xh		; $5ee5
	ld (hl),c		; $5ee7
	ret			; $5ee8

@spawnPositions:
	.db $88 $48
	.db $88 $58
	.db $38 $f8
	.db $48 $f8

;;
; Searches for all existing like-likes with subid 0, sets their relatedObj1 to point to
; this object (the spawner), and stores the current like-like count in var30.
; @addr{5ef1}
_likelike_findAllLikelikesWithSubid0:
	ldhl FIRST_ENEMY_INDEX, Enemy.id		; $5ef1
	ld c,$00		; $5ef4
@nextEnemy:
	; Find like-like with subid 0
	ld a,(hl)		; $5ef6
	cp ENEMYID_LIKE_LIKE			; $5ef7
	jr nz,++		; $5ef9
	inc l			; $5efb
	ldd a,(hl)		; $5efc
	or a			; $5efd
	jr nz,++		; $5efe

	; Set its relatedObj1 to this
	ld l,Enemy.relatedObj1		; $5f00
	ld a,Enemy.start		; $5f02
	ldi (hl),a		; $5f04
	ld (hl),d		; $5f05
	ld l,Enemy.id		; $5f06
	inc c			; $5f08
++
	inc h			; $5f09
	ld a,h			; $5f0a
	cp LAST_ENEMY_INDEX+1			; $5f0b
	jr c,@nextEnemy	; $5f0d

	ld e,Enemy.var30		; $5f0f
	ld a,c			; $5f11
	ld (de),a		; $5f12
	ret			; $5f13

;;
; Choose a random position to fall from the sky. If a good position is chosen, the
; Z position is also set to be above the screen.
;
; @param[out]	zflag	z if chose valid position
; @addr{5f14}
_likelike_chooseRandomPosition:
	call getRandomNumber_noPreserveVars		; $5f14
	and $77			; $5f17
	inc a			; $5f19
	ld c,a			; $5f1a
	ld b,>wRoomCollisions		; $5f1b
	ld a,(bc)		; $5f1d
	or a			; $5f1e
	ret nz			; $5f1f
	call objectSetShortPosition		; $5f20
	ld c,$08		; $5f23
	call _ecom_setZAboveScreen		; $5f25
	xor a			; $5f28
	ret			; $5f29


;;
; @addr{5f2a}
_likelike_checkHazards:
	push af			; $5f2a
	ld a,(w1Link.state)		; $5f2b
	cp LINK_STATE_GRABBED			; $5f2e
	jr nz,++		; $5f30

	ld e,Enemy.zh		; $5f32
	ld a,(de)		; $5f34
	rlca			; $5f35
	jr c,++			; $5f36
	ld bc,$0500		; $5f38
	call objectGetRelativeTile		; $5f3b
	ld hl,hazardCollisionTable		; $5f3e
	call lookupCollisionTable		; $5f41
	call c,_likelike_releaseLink		; $5f44
++
	pop af			; $5f47
	jp _ecom_checkHazards		; $5f48


; ==============================================================================
; ENEMYID_GOPONGA_FLOWER
; ==============================================================================
enemyCode25:
	jr z,@normalStatus	; $5f4b
	sub ENEMYSTATUS_NO_HEALTH			; $5f4d
	ret c			; $5f4f
	jp z,enemyDie		; $5f50

	ld e,Enemy.health		; $5f53
	ld a,(de)		; $5f55
	or a			; $5f56
	jp z,_ecom_updateKnockback		; $5f57

@normalStatus:
	ld e,Enemy.state		; $5f5a
	ld a,(de)		; $5f5c
	rst_jumpTable			; $5f5d
	.dw @state_uninitialized
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state8
	.dw @state9


@state_uninitialized:
	ld h,d			; $5f72
	ld l,Enemy.counter1		; $5f73
	ld (hl),90		; $5f75
	ld l,Enemy.subid		; $5f77
	ld a,(hl)		; $5f79
	or a			; $5f7a
	jr z,++			; $5f7b

	ld l,Enemy.oamTileIndexBase		; $5f7d
	ld a,(hl)		; $5f7f
	add $04			; $5f80
	ld (hl),a		; $5f82
	ld l,Enemy.enemyCollisionMode		; $5f83
	ld (hl),ENEMYCOLLISION_BIG_GOPONGA_FLOWER		; $5f85
++
	call _ecom_setSpeedAndState8		; $5f87
	jp objectSetVisible83		; $5f8a


@state_stub:
	ret			; $5f8d


; Closed
@state8:
	call _ecom_decCounter1		; $5f8e
	ret nz			; $5f91
	ld (hl),60		; $5f92
	ld l,e			; $5f94
	inc (hl)		; $5f95
	ld a,$01		; $5f96
	jp enemySetAnimation		; $5f98


; Open, about to shoot a projectile
@state9:
	call _ecom_decCounter1		; $5f9b
	jr z,@closeFlower	; $5f9e

	ld a,(hl)		; $5fa0
	cp 40			; $5fa1
	ret nz			; $5fa3

	ld e,Enemy.subid		; $5fa4
	ld a,(de)		; $5fa6
	dec a			; $5fa7
	call nz,getRandomNumber_noPreserveVars		; $5fa8
	and $03			; $5fab
	ret nz			; $5fad
	ld b,PARTID_GOPONGA_PROJECTILE		; $5fae
	jp _ecom_spawnProjectile		; $5fb0

@closeFlower:
	ld e,Enemy.subid		; $5fb3
	ld a,(de)		; $5fb5
	ld bc,@counter1Vals		; $5fb6
	call addAToBc		; $5fb9
	ld a,(bc)		; $5fbc
	ld (hl),a		; $5fbd

	ld l,Enemy.state		; $5fbe
	dec (hl)		; $5fc0

	xor a			; $5fc1
	jp enemySetAnimation		; $5fc2


@counter1Vals: ; counter1 values per subid
	.db $78 $b4


; ==============================================================================
; ENEMYID_DEKU_SCRUB
;
; Variables:
;   var03: Read by ENEMYID_BUSH_OR_ROCK to control Z-offset
;   var30: Starts at 2, gets decremented each time one of the scrub's bullets hits itself.
;   var31: Index of ENEMYID_BUSH_OR_ROCK
;   var32: "pressedAButton" variable (nonzero when player presses A)
;   var33: Former var03 value (low byte of text index, TX_45XX)
; ==============================================================================
enemyCode27:
	jr z,@normalStatus	; $5fc7
	sub ENEMYSTATUS_NO_HEALTH			; $5fc9
	ret c			; $5fcb
	jr z,@dead	; $5fcc
	dec a			; $5fce
	jr nz,@normalStatus	; $5fcf

	; ENEMYSTATUS_JUST_HIT

	; Check var30, which is decremented by PARTID_DEKU_SCRUB_PROJECTILE each time it
	; hits the deku scrub.
	ld e,Enemy.var30		; $5fd1
	ld a,(de)		; $5fd3
	or a			; $5fd4
	ret nz			; $5fd5

	; We've been hit twice, go to state $0c and delete the bush.
	ld h,d			; $5fd6
	ld l,Enemy.state		; $5fd7
	ld (hl),$0c		; $5fd9
	ld l,Enemy.var31		; $5fdb
	ld h,(hl)		; $5fdd
	jp _ecom_killObjectH		; $5fde

@dead:
	ld e,Enemy.subid		; $5fe1
	ld a,(de)		; $5fe3
	dec a			; $5fe4
	jp nz,enemyDie		; $5fe5

@normalStatus:
	ld e,Enemy.state		; $5fe8
	ld a,(de)		; $5fea
	rst_jumpTable			; $5feb
	.dw _dekuScrub_state_uninitialized
	.dw _dekuScrub_state_stub
	.dw _dekuScrub_state_stub
	.dw _dekuScrub_state_stub
	.dw _dekuScrub_state_stub
	.dw _dekuScrub_state_stub
	.dw _dekuScrub_state_stub
	.dw _dekuScrub_state_stub
	.dw _dekuScrub_state8
	.dw _dekuScrub_state9
	.dw _dekuScrub_stateA
	.dw _dekuScrub_stateB
	.dw _dekuScrub_stateC
	.dw _dekuScrub_stateD


_dekuScrub_state_uninitialized:
	call _dekuScrub_spawnBush		; $6008
	ret nz			; $600b

	call objectMakeTileSolid		; $600c
	ld h,>wRoomLayout		; $600f
	ld (hl),$00		; $6011

	; The value of 'a' here depends on "objectMakeTileSolid.
	; It should be 0 if the enemy spawned on an empty space.
	; In any case it shouldn't matter since this enemy doesn't move.
	call _ecom_setSpeedAndState8		; $6013

	ld l,Enemy.counter1		; $6016
	inc (hl)		; $6018

	ld l,Enemy.var30		; $6019
	ld (hl),$02		; $601b

	ld l,Enemy.var03		; $601d
	ld a,(hl)		; $601f
	ld (hl),$00		; $6020
	ld l,Enemy.var33		; $6022
	ld (hl),a		; $6024
	ret			; $6025


_dekuScrub_state_stub:
	ret			; $6026


; Waiting for Link to be a certain distance away
_dekuScrub_state8:
	ld c,$2c		; $6027
	call objectCheckLinkWithinDistance		; $6029
	ret c			; $602c
	call _ecom_decCounter1		; $602d
	ret nz			; $6030

	ld (hl),90		; $6031

	ld l,Enemy.state		; $6033
	inc (hl)		; $6035

	ld l,Enemy.var03		; $6036
	ld (hl),$02		; $6038

	xor a			; $603a
	call enemySetAnimation		; $603b
	jp objectSetVisiblec3		; $603e


; Link is at a good distance, wait a bit longer before emerging from bush
_dekuScrub_state9:
	ld c,$2c		; $6041
	call objectCheckLinkWithinDistance		; $6043
	jp c,_dekuScrub_hideInBush		; $6046

	call _ecom_decCounter1		; $6049
	jr nz,_dekuScrub_animate	; $604c

	; Emerge from under the bush
	ld l,Enemy.state		; $604e
	inc (hl)		; $6050

	ld l,Enemy.collisionType		; $6051
	set 7,(hl)		; $6053
	ld l,Enemy.var03		; $6055
	inc (hl)		; $6057

	; Calculate angle to shoot
	call objectGetAngleTowardEnemyTarget		; $6058
	ld hl,_dekuScrub_targetAngles		; $605b
	rst_addAToHl			; $605e
	ld a,(hl)		; $605f
	or a			; $6060
	jr z,_dekuScrub_hideInBush	; $6061

	ld e,Enemy.angle		; $6063
	ld (de),a		; $6065
	rrca			; $6066
	rrca			; $6067
	sub $02			; $6068
	ld hl,_dekuScrub_fireAnimations		; $606a
	rst_addAToHl			; $606d
	ld a,(hl)		; $606e
	jp enemySetAnimation		; $606f


; Firing sequence
_dekuScrub_stateA:
	ld c,$2c		; $6072
	call objectCheckLinkWithinDistance		; $6074
	jr c,_dekuScrub_hideInBush	; $6077

	ld e,Enemy.animParameter		; $6079
	ld a,(de)		; $607b
	inc a			; $607c
	jr z,_dekuScrub_hideInBush	; $607d

	ld a,(de)		; $607f
	dec a			; $6080
	jr nz,_dekuScrub_animate	; $6081
	ld (de),a		; $6083

	ld b,PARTID_DEKU_SCRUB_PROJECTILE		; $6084
	call _ecom_spawnProjectile		; $6086

_dekuScrub_animate:
	jp enemyAnimate		; $6089


; Go hide in the bush again
_dekuScrub_stateB:
	ld e,Enemy.animParameter		; $608c
	ld a,(de)		; $608e
	inc a			; $608f
	jr nz,_dekuScrub_animate	; $6090

	ld h,d			; $6092
	ld l,Enemy.state		; $6093
	ld (hl),$08		; $6095

	ld l,Enemy.var03		; $6097
	ld (hl),$00		; $6099
	jp objectSetInvisible		; $609b


; He's just been defeated
_dekuScrub_stateC:
	ld h,d			; $609e
	ld l,e			; $609f
	inc (hl) ; [state] = $0d

	ld l,Enemy.collisionType		; $60a1
	res 7,(hl)		; $60a3

	ld e,Enemy.var32		; $60a5
	call objectAddToAButtonSensitiveObjectList		; $60a7
	ld a,$07		; $60aa
	call enemySetAnimation		; $60ac


; Waiting for Link to talk to him
_dekuScrub_stateD:
	call objectSetPriorityRelativeToLink_withTerrainEffects		; $60af
	ld e,Enemy.var32		; $60b2
	ld a,(de)		; $60b4
	or a			; $60b5
	jr z,_dekuScrub_animate	; $60b6

	; Pressed A in front of deku scrub
	ld e,Enemy.var32		; $60b8
	xor a			; $60ba
	ld (de),a		; $60bb

	; Show text
	ld e,Enemy.var33		; $60bc
	ld a,(de)		; $60be
	ld c,a			; $60bf
	ld b,>TX_4500		; $60c0
	jp showText		; $60c2


;;
; @addr{60c5}
_dekuScrub_hideInBush:
	ld h,d			; $60c5
	ld l,Enemy.state		; $60c6
	ld (hl),$0b		; $60c8

	ld l,Enemy.counter1		; $60ca
	ld (hl),120		; $60cc

	ld l,Enemy.collisionType		; $60ce
	res 7,(hl)		; $60d0

	ld l,Enemy.var03		; $60d2
	ld (hl),$02		; $60d4
	ld a,$06		; $60d6
	jp enemySetAnimation		; $60d8


; Takes the relative angle between the deku scrub and Link as an index, and the
; corresponding value is the angle at which to shoot a projectile. "0" means can't shoot
; from this angle.
_dekuScrub_targetAngles:
	.db $00 $00 $00 $00 $00 $00 $00 $08
	.db $08 $08 $0c $0c $0c $0c $0c $10
	.db $10 $10 $14 $14 $14 $14 $14 $18
	.db $18 $18 $00 $00 $00 $00 $00 $00

_dekuScrub_fireAnimations:
	.db $05 $04 $03 $02 $01

;;
; @param[out]	zflag	z if spawned bus successfully
; @addr{6100}
_dekuScrub_spawnBush:
	ld b,ENEMYID_BUSH_OR_ROCK		; $6100
	call _ecom_spawnUncountedEnemyWithSubid01		; $6102
	ret nz			; $6105

	call objectCopyPosition		; $6106

	; [child.relatedObj1] = this
	ld l,Enemy.relatedObj1		; $6109
	ld a,Enemy.start		; $610b
	ldi (hl),a		; $610d
	ld (hl),d		; $610e

	; Save projectile's index to var31
	ld e,Enemy.var31		; $610f
	ld a,h			; $6111
	ld (de),a		; $6112

	ld l,Enemy.subid		; $6113
	ld e,l			; $6115
	ld a,(de)		; $6116
	ld (hl),a		; $6117
	xor a			; $6118
	ret			; $6119


; ==============================================================================
; ENEMYID_WALLMASTER
;
; Variables:
;   relatedObj1: For actual wallmaster (subid 1): reference to spawner.
;   relatedObj2: For spawner (subid 0): reference to actual wallmaster.
;   var30: Nonzero if collided with Link (currently warping him out)
; ==============================================================================
enemyCode28:
	jr z,@normalStatus	; $611a
	sub $03			; $611c
	ret c			; $611e
	jr z,@dead	; $611f
	dec a			; $6121
	jp nz,_ecom_updateKnockback		; $6122

	; ENEMYSTATUS_JUST_HIT

	ld e,Enemy.var2a		; $6125
	ld a,(de)		; $6127
	cp $80|ITEMCOLLISION_LINK			; $6128
	ret nz			; $612a

	; Link just touched the hand. If not experiencing knockback, begin warping Link
	; out.
	ld e,Enemy.knockbackCounter		; $612b
	ld a,(de)		; $612d
	or a			; $612e
	ret nz			; $612f

	ld h,d			; $6130
	ld l,Enemy.var30		; $6131
	ld (hl),$01		; $6133

	ld l,Enemy.collisionType		; $6135
	res 7,(hl)		; $6137

	ld l,Enemy.yh		; $6139
	ldi a,(hl)		; $613b
	ld (w1Link.yh),a		; $613c
	inc l			; $613f
	ld a,(hl)		; $6140
	ld (w1Link.xh),a		; $6141
	ret			; $6144

@dead:
	ld e,Enemy.relatedObj1+1		; $6145
	ld a,(de)		; $6147
	or a			; $6148
	jr z,++		; $6149
	ld h,a			; $614b
	ld l,Enemy.relatedObj2+1		; $614c
	ld (hl),$00		; $614e
	ld l,Enemy.yh		; $6150
	dec (hl)		; $6152
++
	jp enemyDie_uncounted		; $6153


@normalStatus:
	ld e,Enemy.state		; $6156
	ld a,(de)		; $6158
	rst_jumpTable			; $6159
	.dw _wallmaster_state_uninitialized
	.dw _wallmaster_state1
	.dw _wallmaster_state_stub
	.dw _wallmaster_state_stub
	.dw _wallmaster_state_stub
	.dw _wallmaster_state_galeSeed
	.dw _wallmaster_state_stub
	.dw _wallmaster_state_stub
	.dw _wallmaster_state8
	.dw _wallmaster_state9
	.dw _wallmaster_stateA
	.dw _wallmaster_stateB
	.dw _wallmaster_stateC
	.dw _wallmaster_stateD


_wallmaster_state_uninitialized:
	ld e,Enemy.subid		; $6176
	ld a,(de)		; $6178
	or a			; $6179
	jp nz,_ecom_setSpeedAndState8		; $617a

	ld h,d			; $617d
	ld l,Enemy.state		; $617e
	inc (hl)		; $6180
	ld l,Enemy.counter1		; $6181
	ld (hl),180		; $6183

	ld l,Enemy.relatedObj2		; $6185
	ld (hl),Enemy.start		; $6187
	ret			; $6189


; Subid 0 (wallmaster spawner) stays in this state indefinitely; spawns a wallmaster every
; 2 seconds.
_wallmaster_state1:
	; "yh" acts as the number of wallmasters remaining to spawn, for the spawner.
	ld e,Enemy.yh		; $618a
	ld a,(de)		; $618c
	or a			; $618d
	jr z,@delete	; $618e

	ld e,Enemy.relatedObj2+1		; $6190
	ld a,(de)		; $6192
	or a			; $6193
	ret nz			; $6194

	call _ecom_decCounter1		; $6195
	ret nz			; $6198

	ld (hl),120		; $6199

	ld a,(w1Link.yh)		; $619b
	ld b,a			; $619e
	ld a,(w1Link.xh)		; $619f
	ld c,a			; $61a2
	call getTileCollisionsAtPosition		; $61a3
	ret nz			; $61a6

	push bc			; $61a7
	ld b,ENEMYID_WALLMASTER		; $61a8
	call _ecom_spawnUncountedEnemyWithSubid01		; $61aa
	pop bc			; $61ad
	ret nz			; $61ae
	ld l,Enemy.relatedObj1		; $61af
	ld a,Enemy.start		; $61b1
	ldi (hl),a		; $61b3
	ld (hl),d		; $61b4

	ld e,Enemy.relatedObj2+1		; $61b5
	ld a,h			; $61b7
	ld (de),a		; $61b8
	ret			; $61b9

@delete:
	call decNumEnemies		; $61ba
	call markEnemyAsKilledInRoom		; $61bd
	jp enemyDelete		; $61c0


_wallmaster_state_galeSeed:
	call _ecom_galeSeedEffect		; $61c3
	ret c			; $61c6

	; Tell spawner that this wallmaster is dead
	ld e,Enemy.relatedObj1+1		; $61c7
	ld a,(de)		; $61c9
	or a			; $61ca
	jr z,++			; $61cb
	ld h,a			; $61cd
	ld l,Enemy.relatedObj2+1		; $61ce
	ld (hl),$00		; $61d0
++
	jp enemyDelete		; $61d2


_wallmaster_state_stub:
	ret			; $61d5


; Spawning at Link's position, above the screen
_wallmaster_state8:
	ld h,d			; $61d6
	ld l,e			; $61d7
	inc (hl) ; [state]++

	ld l,Enemy.collisionType		; $61d9
	ld (hl),$80|ENEMYID_FLOORMASTER		; $61db

	; Copy Link's position, set high Z position
	ld l,Enemy.zh		; $61dd
	ld (hl),$a0		; $61df
	ld l,Enemy.yh		; $61e1
	ld a,(w1Link.yh)		; $61e3
	ldi (hl),a		; $61e6
	inc l			; $61e7
	ld a,(w1Link.xh)		; $61e8
	ld (hl),a		; $61eb

	ld a,SND_FALLINHOLE		; $61ec
	call playSound		; $61ee
	jp objectSetVisiblec1		; $61f1


; Falling to ground
_wallmaster_state9:
	ld c,$0e		; $61f4
	call objectUpdateSpeedZ_paramC		; $61f6
	jr z,@hitGround	; $61f9

	call _wallmaster_flickerVisibilityIfHighUp		; $61fb

	; Chechk for collision with Link
	ld e,Enemy.var30		; $61fe
	ld a,(de)		; $6200
	or a			; $6201
	ret z			; $6202
	ld e,Enemy.zh		; $6203
	ld a,(de)		; $6205
	ld (w1Link.zh),a		; $6206
	ret			; $6209

@hitGround:
	ld l,Enemy.counter1		; $620a
	ld (hl),30		; $620c
	ld l,Enemy.state		; $620e
	inc (hl)		; $6210
	ret			; $6211


; Waiting on ground for [counter1] frames before moving back up
_wallmaster_stateA:
	call _ecom_decCounter1		; $6212
	jr nz,++		; $6215
	ld l,e			; $6217
	inc (hl) ; [state]++
	ret			; $6219
++
	ld a,(hl)		; $621a
	cp 20 ; [counter1] == 20?
	jr c,++			; $621d
	ret nz			; $621f

	; Close hand when [counter1] == 20
	ld a,$01		; $6220
	jp enemySetAnimation		; $6222
++
	dec a			; $6225
	jr nz,++		; $6226

	; Set collisionType when [counter1] == 1?
	ld l,Enemy.collisionType		; $6228
	ld a,(hl)		; $622a
	and $80			; $622b
	or ENEMYID_WALLMASTER			; $622d
	ld (hl),a		; $622f
++
	ld l,Enemy.var30		; $6230
	bit 0,(hl)		; $6232
	ret z			; $6234
	xor a			; $6235
	ld (w1Link.visible),a		; $6236
	ret			; $6239


; Moving back up
_wallmaster_stateB:
	call _wallmaster_flickerVisibilityIfHighUp		; $623a
	ld h,d			; $623d
	ld l,Enemy.zh		; $623e
	dec (hl)		; $6240
	dec (hl)		; $6241
	ld a,(hl)		; $6242
	cp $a0			; $6243
	ret nc			; $6245

	; Moved high enough
	call objectSetInvisible		; $6246
	ld l,Enemy.var30		; $6249
	bit 0,(hl)		; $624b
	jr z,++			; $624d

	; We just pulled Link out, go to state $0d
	ld l,Enemy.state		; $624f
	ld (hl),$0d		; $6251
	ret			; $6253
++
	ld l,Enemy.state		; $6254
	inc (hl) ; [state] = $0c
	ld l,Enemy.collisionType		; $6257
	res 7,(hl)		; $6259
	ld l,Enemy.counter1		; $625b
	ld (hl),120		; $625d
	ret			; $625f


; Waiting off-screen until time to attack again
_wallmaster_stateC:
	call _ecom_decCounter1		; $6260
	ret nz			; $6263

	ld l,e			; $6264
	ld (hl),$08 ; [state] = 8
	ld l,Enemy.speedZ		; $6267
	xor a			; $6269
	ldi (hl),a		; $626a
	ld (hl),a		; $626b
	jp enemySetAnimation		; $626c


; Just dragged Link off-screen
_wallmaster_stateD:
	; Go to substate 2 in LINK_STATE_GRABBED_BY_WALLMASTER.
	ld a,$02		; $626f
	ld (w1Link.state2),a		; $6271
	ret			; $6274


;;
; Flickers visibility if very high up (zh < $b8)
; @addr{6275}
_wallmaster_flickerVisibilityIfHighUp:
	ld e,Enemy.zh		; $6275
	ld a,(de)		; $6277
	or a			; $6278
	ret z			; $6279
	cp $b8			; $627a
	jp c,_ecom_flickerVisibility		; $627c
	cp $bc			; $627f
	ret nc			; $6281
	jp objectSetVisiblec1		; $6282


; ==============================================================================
; ENEMYID_PODOBOO
;
; Variables:
;   relatedObj1: "Parent" (for subid 1, the lava particle)
;   var30: Animation index
;   var31: Initial Y position; the point at which the podoboo returns back to the lava
; ==============================================================================
enemyCode29:
	; Return for ENEMYSTATUS_01 or ENEMYSTATUS_STUNNED
	dec a			; $6285
	ret z			; $6286
	dec a			; $6287
	ret z			; $6288

	ld e,Enemy.state		; $6289
	ld a,(de)		; $628b
	rst_jumpTable			; $628c
	.dw podoboo_state_uninitialized
	.dw _podoboo_state_stub
	.dw _podoboo_state_stub
	.dw _podoboo_state_stub
	.dw _podoboo_state_stub
	.dw _podoboo_state_stub
	.dw _podoboo_state_stub
	.dw _podoboo_state_stub
	.dw _podoboo_state8
	.dw _podoboo_state9
	.dw _podoboo_stateA
	.dw _podoboo_stateB
	.dw _podoboo_stateC

podoboo_state_uninitialized:
	; Note: a is uninitialized; arbitrary speed
	call _ecom_setSpeedAndState8		; $62a7
	ld e,Enemy.subid		; $62aa
	ld a,(de)		; $62ac
	or a			; $62ad
	ret z			; $62ae

	; Subid 1 only

	ld (hl),$0c ; [state] = $0c

	ld l,Enemy.relatedObj1+1		; $62b1
	ld h,(hl)		; $62b3
	ld l,Enemy.var30		; $62b4
	ld a,(hl)		; $62b6
	inc a			; $62b7
	call enemySetAnimation		; $62b8
	jp objectSetVisible83		; $62bb


_podoboo_state_stub:
	ret			; $62be


; Subid 0: Waiting for Link to approach horizontally
_podoboo_state8:
	ld h,d			; $62bf
	ld l,Enemy.xh		; $62c0
	ldh a,(<hEnemyTargetX)	; $62c2
	sub (hl)		; $62c4
	add $30			; $62c5
	cp $61			; $62c7
	ret nc			; $62c9

	; Save initial Y-position so we know when the leap is done
	ld l,Enemy.yh		; $62ca
	ld a,(hl)		; $62cc
	ld l,Enemy.var31		; $62cd
	ld (hl),a		; $62cf
	jr _podoboo_beginMovingUp		; $62d0


; Leaping out of lava
_podoboo_state9:
	call enemyAnimate		; $62d2
	call _podoboo_updatePosition		; $62d5
	jr z,@doneLeaping	; $62d8

	ld a,(hl) ; hl == Enemy.speedZ+1
	or a			; $62db
	jr nz,_podoboo_spawnLavaParticleEvery16Frames	; $62dc

	; Moving down
	ld l,Enemy.var30		; $62de
	cp (hl)			; $62e0
	ret z			; $62e1
	ld (hl),a		; $62e2
	call enemySetAnimation		; $62e3
	jr _podoboo_spawnLavaParticle		; $62e6

@doneLeaping:
	ld l,Enemy.state		; $62e8
	inc (hl)		; $62ea
	ld l,Enemy.collisionType		; $62eb
	res 7,(hl)		; $62ed


; Just re-entered the lava
_podoboo_stateA:
	call _podoboo_makeLavaSplash		; $62ef
	ret nz			; $62f2

	; Wait a random amount of time before resurfacing
	call getRandomNumber_noPreserveVars		; $62f3
	and $03			; $62f6
	ld hl,_podoboo_counter1Vals		; $62f8
	rst_addAToHl			; $62fb
	ld e,Enemy.counter1		; $62fc
	ld a,(hl)		; $62fe
	ld (de),a		; $62ff

	call _ecom_incState		; $6300
	jp objectSetInvisible		; $6303


; Waiting for [counter1] frames before jumping out again.
_podoboo_stateB:
	call _ecom_decCounter1		; $6306
	ret nz			; $6309
	inc (hl)		; $630a
	jr _podoboo_beginMovingUp		; $630b


; State for "lava particle" (subid 1); just animate until time to delete self.
_podoboo_stateC:
	call enemyAnimate		; $630d
	ld e,Enemy.animParameter		; $6310
	ld a,(de)		; $6312
	inc a			; $6313
	jp z,enemyDelete		; $6314
	dec a			; $6317
	jp nz,objectSetInvisible		; $6318
	jp _ecom_flickerVisibility		; $631b


;;
; @addr{631e}
_podoboo_spawnLavaParticleEvery16Frames:
	call _ecom_decCounter1		; $631e
	ld a,(hl)		; $6321
	and $0f			; $6322
	ret nz			; $6324

;;
; @addr{6325}
_podoboo_spawnLavaParticle:
	ld b,ENEMYID_PODOBOO		; $6325
	call _ecom_spawnUncountedEnemyWithSubid01		; $6327
	ret nz			; $632a
	call objectCopyPosition		; $632b
	ld l,Enemy.relatedObj1		; $632e
	ld a,Enemy.start		; $6330
	ldi (hl),a		; $6332
	ld (hl),d		; $6333
	ret			; $6334


;;
; Makes a splash, sets animation and speed, enables collisions for when the splash has
; just spawned, sets state to 9.
; @addr{6335}
_podoboo_beginMovingUp:
	call _podoboo_makeLavaSplash		; $6335
	ret nz			; $6338

	call objectSetVisible82		; $6339

	ld e,Enemy.var30		; $633c
	ld a,$02		; $633e
	ld (de),a		; $6340
	call enemySetAnimation		; $6341

	ld bc,-$440		; $6344
	call objectSetSpeedZ		; $6347

	ld l,Enemy.state		; $634a
	ld (hl),$09		; $634c
	ld l,Enemy.collisionType		; $634e
	set 7,(hl)		; $6350
	xor a			; $6352
	ret			; $6353


;;
; @param[out]	zflag	z if created successfully
; @addr{6354}
_podoboo_makeLavaSplash:
	ldbc INTERACID_LAVASPLASH,$01		; $6354
	jp objectCreateInteraction		; $6357


; Value randomly chosen from here
_podoboo_counter1Vals:
	.db $10 $50 $50 $50


;;
; @param[out]	zflag	z if returned to original position.
; @addr{635e}
_podoboo_updatePosition:
	ld h,d			; $635e
	ld l,Enemy.speedZ		; $635f
	ld e,Enemy.y		; $6361
	call add16BitRefs		; $6363
	ld b,a			; $6366

	; Check if Enemy.y has returned to its original position
	ld e,Enemy.var31		; $6367
	ld a,(de)		; $6369
	cp b			; $636a
	jr c,++			; $636b

	; If so, [Enemy.speedZ] += $001c
	dec l			; $636d
	ld a,$1c		; $636e
	add (hl)		; $6370
	ldi (hl),a		; $6371
	ld a,$00		; $6372
	adc (hl)		; $6374
	ld (hl),a		; $6375
	or d			; $6376
	ret			; $6377
++
	; Reached original position.
	ld l,Enemy.yh		; $6378
	ldd (hl),a		; $637a
	ld (hl),$00		; $637b
	xor a			; $637d
	ret			; $637e


; ==============================================================================
; ENEMYID_GIANT_BLADE_TRAP
; ==============================================================================
enemyCode2a:
	; Return for ENEMYSTATUS_01 or ENEMYSTATUS_STUNNED
	dec a			; $637f
	ret z			; $6380
	dec a			; $6381
	ret z			; $6382

	call _ecom_getSubidAndCpStateTo08		; $6383
	jr c,@commonState	; $6386
	ld a,b			; $6388
	rst_jumpTable			; $6389
	.dw _giantBladeTrap_subid00
	.dw _giantBladeTrap_subid01
	.dw _giantBladeTrap_subid02
	.dw _giantBladeTrap_subid03

@commonState:
	rst_jumpTable			; $6392
	.dw _giantBladeTrap_state_uninitialized
	.dw _giantBladeTrap_state_stub
	.dw _giantBladeTrap_state_stub
	.dw _giantBladeTrap_state_stub
	.dw _giantBladeTrap_state_stub
	.dw _giantBladeTrap_state_stub
	.dw _giantBladeTrap_state_stub
	.dw _giantBladeTrap_state_stub


_giantBladeTrap_state_uninitialized:
	call _ecom_setSpeedAndState8		; $63a3
	jp objectSetVisible82		; $63a6


_giantBladeTrap_state_stub:
	ret			; $63a9


_giantBladeTrap_subid00:
	ret			; $63aa


_giantBladeTrap_subid01:
	ld a,(de)		; $63ab
	sub $08			; $63ac
	rst_jumpTable			; $63ae
	.dw _giantBladeTrap_subid01_state8
	.dw _giantBladeTrap_subid01_state9
	.dw _giantBladeTrap_subid01_stateA


; Choosing initial direction to move.
_giantBladeTrap_subid01_state8:
	ld a,$09		; $63b5
	ld (de),a ; [state] = 9
	call _giantBladeTrap_chooseInitialAngle		; $63b8
	ld e,Enemy.speed		; $63bb
	ld a,SPEED_80		; $63bd
	ld (de),a		; $63bf
	ret			; $63c0


; Move until hitting a wall.
_giantBladeTrap_subid01_state9:
	call _giantBladeTrap_checkCanMoveInDirection		; $63c1
	jp z,objectApplySpeed		; $63c4
	call _ecom_incState		; $63c7
	ld l,Enemy.counter1		; $63ca
	ld (hl),$10		; $63cc
	ret			; $63ce


; Wait 16 frames, then change directions and start moving again.
_giantBladeTrap_subid01_stateA:
	call _ecom_decCounter1		; $63cf
	ret nz			; $63d2

	ld l,e			; $63d3
	dec (hl) ; [state]--

	; Rotate angle clockwise
	ld l,Enemy.angle		; $63d5
	ld a,(hl)		; $63d7
	add $08			; $63d8
	and $18			; $63da
	ld (hl),a		; $63dc
	ret			; $63dd


_giantBladeTrap_subid02:
	ld a,(de)		; $63de
	sub $08			; $63df
	rst_jumpTable			; $63e1
	.dw _giantBladeTrap_subid02_state8
	.dw _giantBladeTrap_commonState9
	.dw _giantBladeTrap_subid02_stateA


; Initialization
_giantBladeTrap_subid02_state8:
	ld h,d			; $63e8
	ld l,e			; $63e9
	inc (hl)		; $63ea
	ld l,Enemy.counter1		; $63eb
	ld (hl),60		; $63ed
	ret			; $63ef


; Accelerate until hitting a wall.
_giantBladeTrap_commonState9:
	call _giantBladeTrap_updateSpeed		; $63f0
	call _giantBladeTrap_checkCanMoveInDirection		; $63f3
	jp z,objectApplySpeed		; $63f6

	call _ecom_incState		; $63f9

	; Round Y, X to center of tile
	ld l,Enemy.yh		; $63fc
	ld a,(hl)		; $63fe
	add $02			; $63ff
	and $f8			; $6401
	ldi (hl),a		; $6403
	inc l			; $6404
	ld a,(hl)		; $6405
	add $02			; $6406
	and $f8			; $6408
	ld (hl),a		; $640a

	ld l,Enemy.counter1		; $640b
	ld (hl),$10		; $640d
	ret			; $640f


; Hit a wall, waiting for a bit then changing direction.
_giantBladeTrap_subid02_stateA:
	call _ecom_decCounter1		; $6410
	ret nz			; $6413

	; Rotate angle clockwise
	ld e,Enemy.angle		; $6414
	ld a,(de)		; $6416
	add $08			; $6417
	and $1f			; $6419
	ld (de),a		; $641b

	call _giantBladeTrap_checkCanMoveInDirection		; $641c
	jr z,@canMove	; $641f

	; Can't move this way; try reversing direction.
	ld e,Enemy.angle		; $6421
	ld a,(de)		; $6423
	xor $10			; $6424
	ld (de),a		; $6426
	call _giantBladeTrap_checkCanMoveInDirection		; $6427
	jr z,@canMove	; $642a

	; Can't move backward either; try another direction.
	ld e,Enemy.angle		; $642c
	ld a,(de)		; $642e
	sub $08			; $642f
	and $1f			; $6431
	ld (de),a		; $6433

@canMove:
	 ; Return to state 9
	ld h,d			; $6434
	ld l,Enemy.state		; $6435
	dec (hl)		; $6437
	ld l,Enemy.counter1		; $6438
	ld (hl),90		; $643a
	ret			; $643c


_giantBladeTrap_subid03:
	ld a,(de)		; $643d
	sub $08			; $643e
	rst_jumpTable			; $6440
	.dw _giantBladeTrap_subid03_state8
	.dw _giantBladeTrap_commonState9
	.dw _giantBladeTrap_subid03_stateA


; Initialization
_giantBladeTrap_subid03_state8:
	ld h,d			; $6447
	ld l,e			; $6448
	inc (hl)		; $6449
	ld l,Enemy.angle		; $644a
	ld (hl),$10		; $644c
	ld l,Enemy.counter1		; $644e
	ld (hl),90		; $6450
	ret			; $6452


; Hit a wall, waiting for a bit then changing direction.
_giantBladeTrap_subid03_stateA:
	call _ecom_decCounter1		; $6453
	ret nz			; $6456

	; Rotate angle counterclockwise
	ld e,Enemy.angle		; $6457
	ld a,(de)		; $6459
	sub $08			; $645a
	and $1f			; $645c
	ld (de),a		; $645e

	call _giantBladeTrap_checkCanMoveInDirection		; $645f
	jr z,@canMove	; $6462

	; Can't move this way; try reversing direction.
	ld e,Enemy.angle		; $6464
	ld a,(de)		; $6466
	xor $10			; $6467
	ld (de),a		; $6469
	call _giantBladeTrap_checkCanMoveInDirection		; $646a
	jr z,@canMove	; $646d

	; Can't move backward either; try another direction.
	ld e,Enemy.angle		; $646f
	ld a,(de)		; $6471
	add $08			; $6472
	and $1f			; $6474
	ld (de),a		; $6476

@canMove:
	; Return to state 9
	ld h,d			; $6477
	ld l,Enemy.state		; $6478
	dec (hl)		; $647a
	ld l,Enemy.counter1		; $647b
	ld (hl),90		; $647d
	ret			; $647f


;;
; Subid 1 only; check all directions, choose which way to go.
; @addr{6480}
_giantBladeTrap_chooseInitialAngle:
	call _giantBladeTrap_checkCanMoveInDirection		; $6480
	ld a,ANGLE_RIGHT		; $6483
	jr nz,@setAngle	; $6485

	ld e,Enemy.angle		; $6487
	ld (de),a		; $6489
	call _giantBladeTrap_checkCanMoveInDirection		; $648a
	ld a,ANGLE_DOWN		; $648d
	jr nz,@setAngle	; $648f

	ld e,Enemy.angle		; $6491
	ld (de),a		; $6493
	call _giantBladeTrap_checkCanMoveInDirection		; $6494
	ld a,ANGLE_LEFT		; $6497
	jr nz,@setAngle	; $6499

	xor a			; $649b
@setAngle:
	ld e,Enemy.angle		; $649c
	ld (de),a		; $649e
	ret			; $649f

;;
; Based on current angle value, this checks if it can move in that direction (it is not
; blocked by solid tiles directly ahead).
;
; @param[out]	zflag	z if it can move in this direction.
; @addr{64a0}
_giantBladeTrap_checkCanMoveInDirection:
	ld e,Enemy.yh		; $64a0
	ld a,(de)		; $64a2
	ld b,a			; $64a3
	ld e,Enemy.xh		; $64a4
	ld a,(de)		; $64a6
	ld c,a			; $64a7

	ld e,Enemy.angle		; $64a8
	ld a,(de)		; $64aa
	rrca			; $64ab
	ld hl,@positionOffsets		; $64ac
	rst_addAToHl			; $64af
	push de			; $64b0
	ld d,>wRoomCollisions		; $64b1
	call @checkTileAtOffsetSolid		; $64b3
	jr nz,+			; $64b6
	call @checkTileAtOffsetSolid		; $64b8
+
	pop de			; $64bb
	ret			; $64bc

;;
; @param	bc	Position
; @param	hl	Pointer to position offsets
; @param[out]	zflag	z if tile is solid
; @addr{64bd}
@checkTileAtOffsetSolid:
	ldi a,(hl)		; $64bd
	add b			; $64be
	and $f0			; $64bf
	ld e,a			; $64c1
	ldi a,(hl)		; $64c2
	add c			; $64c3
	swap a			; $64c4
	and $0f			; $64c6
	or e			; $64c8
	ld e,a			; $64c9
	ld a,(de)		; $64ca
	or a			; $64cb
	ret			; $64cc

@positionOffsets:
	.db $ef $f8  $ef $07 ; DIR_UP
	.db $f8 $10  $07 $10 ; DIR_RIGHT
	.db $10 $f8  $10 $07 ; DIR_DOWN
	.db $f8 $ef  $07 $ef ; DIR_LEFT

;;
; Decrements counter1 and uses its value to determine speed. Lower values = higher speed.
; @addr{64dd}
_giantBladeTrap_updateSpeed:
	ld e,Enemy.counter1		; $64dd
	ld a,(de)		; $64df
	or a			; $64e0
	ret z			; $64e1
	ld a,(de)		; $64e2
	dec a			; $64e3
	ld (de),a		; $64e4

	and $f0			; $64e5
	swap a			; $64e7
	ld hl,@speeds		; $64e9
	rst_addAToHl			; $64ec
	ld e,Enemy.speed		; $64ed
	ld a,(hl)		; $64ef
	ld (de),a		; $64f0
	ret			; $64f1

@speeds:
	.db SPEED_280, SPEED_200, SPEED_180, SPEED_100, SPEED_80, SPEED_20


; ==============================================================================
; ENEMYID_CHEEP_CHEEP
;
; Variables:
;   var03: How far to travel (copied to counter1)
; ==============================================================================
enemyCode2c:
	jr z,@normalStatus	; $64f8
	sub ENEMYSTATUS_NO_HEALTH			; $64fa
	ret c			; $64fc
	jp z,enemyDie		; $64fd
	dec a			; $6500
	jp nz,_ecom_updateKnockback		; $6501

@normalStatus:
	call _ecom_getSubidAndCpStateTo08		; $6504
	jr nc,@normalState	; $6507
	rst_jumpTable			; $6509
	.dw _cheepCheep_state_uninitialized
	.dw _cheepCheep_state_stub
	.dw _cheepCheep_state_stub
	.dw _cheepCheep_state_stub
	.dw _cheepCheep_state_stub
	.dw _ecom_blownByGaleSeedState
	.dw _cheepCheep_state_stub
	.dw _cheepCheep_state_stub

@normalState:
	ld a,b			; $651a
	rst_jumpTable			; $651b
	.dw _cheepCheep_subid00
	.dw _cheepCheep_subid01


_cheepCheep_state_uninitialized:
	ld a,SPEED_80		; $6520
	call _ecom_setSpeedAndState8		; $6522
	jp objectSetVisible82		; $6525


_cheepCheep_state_stub:
	ret			; $6528


_cheepCheep_subid00:
	ld a,(de)		; $6529
	sub $08			; $652a
	rst_jumpTable			; $652c
	.dw _cheepCheep_subid00_state8
	.dw _cheepCheep_state9
	.dw _cheepCheep_stateA


; Initialize angle (left), counter1.
_cheepCheep_subid00_state8:
	ld h,d			; $6533
	ld l,e			; $6534
	inc (hl) ; [state]++

	ld l,Enemy.angle		; $6536
	ld (hl),ANGLE_LEFT		; $6538

	ld l,Enemy.var03		; $653a
	ld a,(hl)		; $653c
	add a			; $653d
	ld (hl),a		; $653e
	ld l,Enemy.counter1		; $653f
	ld (hl),a		; $6541
	ret			; $6542


; Moving until counter1 expires
_cheepCheep_state9:
	call _ecom_decCounter1		; $6543
	jr nz,++		; $6546
	ld (hl),60		; $6548
	ld l,e			; $654a
	inc (hl) ; [state]++
++
	call objectApplySpeed		; $654c

_cheepCheep_animate:
	jp enemyAnimate		; $654f


; Waiting for 60 frames, then reverse direction
_cheepCheep_stateA:
	call _ecom_decCounter1		; $6552
	jr nz,_cheepCheep_animate	; $6555

	ld e,Enemy.var03		; $6557
	ld a,(de)		; $6559
	ld (hl),a ; [counter1] = [var03]

	ld l,Enemy.state		; $655b
	dec (hl)		; $655d

	; Reverse angle
	ld l,Enemy.angle		; $655e
	ld a,(hl)		; $6560
	xor $10			; $6561
	ldd (hl),a		; $6563

	; Reverse animation (in Enemy.direction variable)
	ld a,(hl)		; $6564
	xor $01			; $6565
	ld (hl),a		; $6567
	jp enemySetAnimation		; $6568


_cheepCheep_subid01:
	ld a,(de)		; $656b
	sub $08			; $656c
	rst_jumpTable			; $656e
	.dw _cheepCheep_subid01_state8
	.dw _cheepCheep_state9
	.dw _cheepCheep_stateA


; Initialize angle (down), counter1.
_cheepCheep_subid01_state8:
	ld h,d			; $6575
	ld l,e			; $6576
	inc (hl) ; [state]++
	ld l,Enemy.angle		; $6578
	ld (hl),ANGLE_DOWN		; $657a

	ld l,Enemy.var03		; $657c
	ld a,(hl)		; $657e
	add a			; $657f
	ld (hl),a		; $6580
	ld l,Enemy.counter1		; $6581
	ld (hl),a		; $6583
	ret			; $6584


; ==============================================================================
; ENEMYID_PODOBOO_TOWER
;
; Variables:
;   var30: Base y-position. (Actual y-position changes as it emerges from the ground.)
; ==============================================================================
enemyCode2d:
	jr z,@normalStatus	; $6585
	sub ENEMYSTATUS_NO_HEALTH			; $6587
	ret c			; $6589
	jp z,enemyDie_withoutItemDrop		; $658a

	; ENEMYSTATUS_JUST_HIT or ENEMYSTATUS_KNOCKBACK
	ld e,Enemy.var2a		; $658d
	ld a,(de)		; $658f
	cp $80|ITEMCOLLISION_MYSTERY_SEED			; $6590
	jp z,enemyDie_uncounted_withoutItemDrop		; $6592

@normalStatus:
	ld e,Enemy.state		; $6595
	ld a,(de)		; $6597
	rst_jumpTable			; $6598
	.dw @state_uninitialized
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state8
	.dw @state9
	.dw @stateA
	.dw @stateB
	.dw @stateC
	.dw @stateD


@state_uninitialized:
	call _ecom_setSpeedAndState8		; $65b5
	ld l,Enemy.var3f		; $65b8
	set 5,(hl)		; $65ba

	ld l,Enemy.counter1		; $65bc
	ld (hl),60		; $65be

	ld l,Enemy.yh		; $65c0
	ld a,(hl)		; $65c2
	ld l,Enemy.var30		; $65c3
	ld (hl),a		; $65c5
	ret			; $65c6


@state_stub:
	ret			; $65c7


; Head is in the ground, flickering, for 60 frames
@state8:
	call _ecom_decCounter1		; $65c8
	jp nz,_ecom_flickerVisibility		; $65cb
	ld l,e			; $65ce
	inc (hl) ; [state]++
	ld l,Enemy.collisionType		; $65d0
	set 7,(hl)		; $65d2
	jp objectSetVisible82		; $65d4


; Rising up out of the ground
@state9:
	call enemyAnimate		; $65d7
	ld e,Enemy.animParameter		; $65da
	ld a,(de)		; $65dc
	or a			; $65dd
	ret z			; $65de

	ld b,a			; $65df
	call @updateCollisionRadiiAndYPosition		; $65e0
	ld a,b			; $65e3
	cp $0f			; $65e4
	ret nz			; $65e6

	; Fully emerged
	ld h,d			; $65e7
	ld l,Enemy.state		; $65e8
	inc (hl)		; $65ea
	ld l,Enemy.counter1		; $65eb
	ld (hl),150		; $65ed
	inc l			; $65ef
	ld (hl),180 ; [counter2]


; Fully emerged from ground, firing at Link until counter2 reaches 0
@stateA:
	call @decCounter2Every4Frames		; $65f2
	jr nz,++		; $65f5
	ld l,e			; $65f7
	inc (hl) ; [state]++
	ld a,$01		; $65f9
	jp enemySetAnimation		; $65fb
++
	; Randomly fire projectile when [counter1] reaches 0
	call _ecom_decCounter1		; $65fe
	jr nz,@animate	; $6601

	ld (hl),150		; $6603

	call getRandomNumber_noPreserveVars		; $6605
	cp $b4			; $6608
	jr nc,@animate	; $660a

	ld b,PARTID_GOPONGA_PROJECTILE		; $660c
	call _ecom_spawnProjectile		; $660e
@animate:
	jp enemyAnimate		; $6611


; Moving back into the ground
@stateB:
	call enemyAnimate		; $6614
	ld e,Enemy.animParameter		; $6617
	ld a,(de)		; $6619
	or a			; $661a
	ret z			; $661b

	bit 7,a			; $661c
	jr z,@updateCollisionRadiiAndYPosition	; $661e

	; Head reached the ground
	call _ecom_incState		; $6620
	ld l,Enemy.collisionType		; $6623
	res 7,(hl)		; $6625
	ld l,Enemy.counter1		; $6627
	ld (hl),60		; $6629
	ret			; $662b


; Head is in the ground, flickering, for 60 frames.
@stateC:
	call _ecom_decCounter1		; $662c
	jp nz,_ecom_flickerVisibility		; $662f

	ld l,Enemy.state		; $6632
	inc (hl)		; $6634

	ld l,Enemy.counter1		; $6635
	ld (hl),180		; $6637
	jp objectSetInvisible		; $6639


; Waiting underground for [counter1] frames.
@stateD:
	call _ecom_decCounter1		; $663c
	ret nz			; $663f
	ld (hl),60		; $6640

	ld l,e			; $6642
	ld (hl),$08 ; [state]

	xor a			; $6645
	jp enemySetAnimation		; $6646

;;
; Updates the podoboo tower's collision radius and y-position while it's emerging from the
; ground.
;
; @param	a	Index of data to read (multiple of 3)
; @addr{6649}
@updateCollisionRadiiAndYPosition:
	sub $03			; $6649
	ld hl,@data		; $664b
	rst_addAToHl			; $664e
	ld e,Enemy.collisionRadiusY		; $664f
	ldi a,(hl)		; $6651
	ld (de),a		; $6652
	inc e			; $6653
	ldi a,(hl)		; $6654
	ld (de),a		; $6655

	ld e,Enemy.var30		; $6656
	ld a,(de)		; $6658
	add (hl)		; $6659
	ld e,Enemy.yh		; $665a
	ld (de),a		; $665c

	ld e,Enemy.animParameter		; $665d
	xor a			; $665f
	ld (de),a		; $6660
	ret			; $6661

; b0: collisionRadiusY
; b1: collisionRadiusX
; b2: Offset for y-position
@data:
	.db $06 $04 $00
	.db $08 $04 $f9
	.db $0b $04 $f7
	.db $0f $04 $f4
	.db $12 $04 $f2

;;
; @addr{6671}
@decCounter2Every4Frames:
	ld a,(wFrameCounter)		; $6671
	and $03			; $6674
	ret nz			; $6676
	jp _ecom_decCounter2		; $6677


; ==============================================================================
; ENEMYID_THWIMP
;
; Variables:
;   var30: Original y-position (where it returns to after stomping)
; ==============================================================================
enemyCode2e:
	jr z,@normalStatus	; $667a
	sub ENEMYSTATUS_NO_HEALTH			; $667c
	ret c			; $667e

@normalStatus:
	ld e,Enemy.state		; $667f
	ld a,(de)		; $6681
	rst_jumpTable			; $6682
	.dw @state_uninitialized
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state8
	.dw @state9
	.dw @stateA
	.dw @stateB
	.dw @stateC


@state_uninitialized:
	ld e,Enemy.yh		; $669d
	ld a,(de)		; $669f
	ld e,Enemy.var30		; $66a0
	ld (de),a		; $66a2

	ld h,d			; $66a3
	ld l,Enemy.counter1		; $66a4
	inc (hl)		; $66a6

	ld l,Enemy.angle		; $66a7
	ld (hl),ANGLE_DOWN		; $66a9
	jp _ecom_setSpeedAndState8AndVisible		; $66ab


@state_stub:
	ret			; $66ae


; Cooldown of [counter1] frames
@state8:
	call _ecom_decCounter1		; $66af
	ret nz			; $66b2
	ld l,e			; $66b3
	inc (hl) ; [state]
	xor a			; $66b5
	ret			; $66b6


; Waiting for Link to approach
@state9:
	ld h,d			; $66b7
	ld l,Enemy.xh		; $66b8
	ldh a,(<hEnemyTargetX)	; $66ba
	sub (hl)		; $66bc
	add $0a			; $66bd
	cp $15			; $66bf
	ret nc			; $66c1

	ld l,e			; $66c2
	inc (hl) ; [state]

	ld l,Enemy.speedZ		; $66c4
	xor a			; $66c6
	ldi (hl),a		; $66c7
	ld (hl),a		; $66c8

	inc a			; $66c9
	jp enemySetAnimation		; $66ca


; Falling down
@stateA:
	ld a,$40		; $66cd
	call objectUpdateSpeedZ_sidescroll		; $66cf
	jr c,@landed	; $66d2

	; Cap speedZ to $0200 (ish... doesn't fix the low byte)
	ld a,(hl)		; $66d4
	cp $03			; $66d5
	ret c			; $66d7
	ld (hl),$02		; $66d8
	ret			; $66da

@landed:
	call _ecom_incState		; $66db
	ld l,Enemy.counter1		; $66de
	ld (hl),45		; $66e0
	ld a,SND_CLINK		; $66e2
	jp playSound		; $66e4


; Just landed. Wait for [counter1] frames
@stateB:
	call @state8		; $66e7
	ret nz			; $66ea
	jp enemySetAnimation		; $66eb


; Moving back up at constant speed
@stateC:
	ld h,d			; $66ee
	ld l,Enemy.y		; $66ef
	ld a,(hl)		; $66f1
	sub $80			; $66f2
	ldi (hl),a		; $66f4
	ld a,(hl)		; $66f5
	sbc $00			; $66f6
	ld (hl),a		; $66f8

	ld e,Enemy.var30		; $66f9
	ld a,(de)		; $66fb
	cp (hl)			; $66fc
	ret nz			; $66fd

	ld l,Enemy.counter1		; $66fe
	ld (hl),24		; $6700
	ld l,Enemy.state		; $6702
	ld (hl),$08		; $6704
	ret			; $6706


; ==============================================================================
; ENEMYID_THWOMP
;
; Variables:
;   var30: Original y-position (where it returns to after stomping)
; ==============================================================================
enemyCode2f:
	jr z,@normalStatus	; $6707
	sub ENEMYSTATUS_NO_HEALTH			; $6709
	ret c			; $670b

@normalStatus:
	call @runState		; $670c
	jp _thwomp_updateLinkRidingSelf		; $670f

@runState:
	ld e,Enemy.state		; $6712
	ld a,(de)		; $6714
	rst_jumpTable			; $6715
	.dw _thwomp_uninitialized
	.dw _thwomp_state_stub
	.dw _thwomp_state_stub
	.dw _thwomp_state_stub
	.dw _thwomp_state_stub
	.dw _thwomp_state_stub
	.dw _thwomp_state_stub
	.dw _thwomp_state_stub
	.dw _thwomp_state8
	.dw _thwomp_state9
	.dw _thwomp_stateA
	.dw _thwomp_stateB


_thwomp_uninitialized:
	; Note: a is uninitialized; arbitrary speed
	call _ecom_setSpeedAndState8		; $672e

	ld l,Enemy.var30		; $6731
	ld e,Enemy.yh		; $6733
	ld a,(de)		; $6735
	ld (hl),a		; $6736

	ld l,Enemy.angle		; $6737
	ld (hl),ANGLE_DOWN		; $6739
	ld a,$04		; $673b
	call enemySetAnimation		; $673d
	jp objectSetVisible82		; $6740


_thwomp_state_stub:
	ret			; $6743


; Waiting for Link to approach
_thwomp_state8:
	ld h,d			; $6744
	ld l,Enemy.xh		; $6745
	ld a,(w1Link.xh)		; $6747
	sub (hl)		; $674a
	add $14			; $674b
	cp $29			; $674d
	jr c,@linkApproached	; $674f

	; Update eye looking at Link
	call objectGetAngleTowardLink		; $6751
	add $02			; $6754
	and $1c			; $6756
	ld h,d			; $6758
	ld l,Enemy.angle		; $6759
	cp (hl)			; $675b
	ret z			; $675c
	ld (hl),a		; $675d
	rrca			; $675e
	rrca			; $675f
	jp enemySetAnimation		; $6760

@linkApproached:
	call _ecom_incState		; $6763
	ld l,Enemy.speedZ		; $6766
	xor a			; $6768
	ldi (hl),a		; $6769
	ld (hl),a		; $676a
	ld a,$08		; $676b
	jp enemySetAnimation		; $676d


; Falling to ground
_thwomp_state9:
	ld b,$10		; $6770
	ld a,$30		; $6772
	call objectUpdateSpeedZ_sidescroll_givenYOffset		; $6774
	jr c,@hitGround	; $6777

	; Cap speedZ to $0200 (ish... doesn't fix the low byte)
	ld a,(hl)		; $6779
	cp $03			; $677a
	ret c			; $677c
	ld (hl),$02		; $677d
	ret			; $677f

@hitGround:
	call _ecom_incState		; $6780

	ld l,Enemy.counter2		; $6783
	ld (hl),60		; $6785
	ld a,45		; $6787
	ld (wScreenShakeCounterY),a		; $6789

	ld a,SND_DOORCLOSE		; $678c
	jp playSound		; $678e


; Resting on ground for 50 frames after hitting it, then moving back to starting position
_thwomp_stateA:
	call _ecom_decCounter2		; $6791
	ret nz			; $6794

	ld e,Enemy.yh		; $6795
	ld l,Enemy.var30		; $6797
	ld a,(de)		; $6799
	cp (hl)			; $679a
	jr z,@doneMovingUp	; $679b

	ld l,Enemy.y		; $679d
	ld a,(hl)		; $679f
	sub $80			; $67a0
	ldi (hl),a		; $67a2
	ld a,(hl)		; $67a3
	sbc $00			; $67a4
	ld (hl),a		; $67a6
	ret			; $67a7

@doneMovingUp:
	ld l,Enemy.state		; $67a8
	inc (hl)		; $67aa

	ld l,Enemy.counter1		; $67ab
	ld (hl),$20		; $67ad
	ret			; $67af


; Cooldown before stomping again
_thwomp_stateB:
	call _ecom_decCounter1		; $67b0
	ret nz			; $67b3

	ld l,e			; $67b4
	ld (hl),$08 ; [state] = 8
	jp _thwomp_updateLinkRidingSelf		; $67b7


;;
; Unused function
;
; @param	bc	Position offset
; @param[out]	a	Tile collisions at thwomp's position + offset bc
; @addr{67ba}
_thwomp_func67ba:
	ld e,Enemy.yh		; $67ba
	ld a,(de)		; $67bc
	add b			; $67bd
	ld b,a			; $67be
	ld e,Enemy.xh		; $67bf
	ld a,(de)		; $67c1
	ld c,a			; $67c2
	jp getTileCollisionsAtPosition		; $67c3


;;
; Checks if Link is riding the thwomp, updates appropriate variables if so.
; @addr{67c6}
_thwomp_updateLinkRidingSelf:
	ld h,d			; $67c6
	ld l,Enemy.xh		; $67c7
	ld a,(w1Link.xh)		; $67c9
	sub (hl)		; $67cc
	add $13			; $67cd
	cp $27			; $67cf
	jr nc,@notRiding		; $67d1

	ld a,(w1Link.collisionRadiusY)		; $67d3
	ld b,a			; $67d6
	ld l,Enemy.collisionRadiusY		; $67d7
	ld e,Enemy.yh		; $67d9
	ld a,(de)		; $67db
	sub (hl)		; $67dc
	sub b			; $67dd
	ld c,a			; $67de

	ld a,(w1Link.yh)		; $67df
	sub c			; $67e2
	add $03			; $67e3
	cp $07			; $67e5
	jr nc,@notRiding		; $67e7

	ld a,c			; $67e9
	sub $03			; $67ea
	ld (w1Link.yh),a		; $67ec
	ld a,d			; $67ef
	ld (wLinkRidingObject),a		; $67f0
	ret			; $67f3

@notRiding:
	; Only clear wLinkRidingObject if it's already equal to this object's index.
	ld a,(wLinkRidingObject)		; $67f4
	sub d			; $67f7
	ret nz			; $67f8
	ld (wLinkRidingObject),a		; $67f9
	ret			; $67fc


; ==============================================================================
; ENEMYID_VERAN_SPIDER
; ==============================================================================
enemyCode0f:
	ld b,a			; $67fd

	; Kill spiders when a cutscene trigger occurs
	ld a,(wTmpcfc0.genericCutscene.cfd0)		; $67fe
	or a			; $6801
	ld a,b			; $6802
	jr z,+			; $6803
	ld a,ENEMYSTATUS_NO_HEALTH		; $6805
+
	or a			; $6807
	jr z,@normalStatus			; $6808
	sub ENEMYSTATUS_NO_HEALTH			; $680a
	ret c			; $680c
	jp z,enemyDie		; $680d
	dec a			; $6810
	jp nz,_ecom_updateKnockback		; $6811
	ret			; $6814

@normalStatus:
	call _ecom_checkScentSeedActive		; $6815
	jr z,++			; $6818
	ld e,Enemy.speed		; $681a
	ld a,SPEED_140		; $681c
	ld (de),a		; $681e
++
	ld e,Enemy.state		; $681f
	ld a,(de)		; $6821
	rst_jumpTable			; $6822
	.dw _veranSpider_state_uninitialized
	.dw _veranSpider_state_stub
	.dw _veranSpider_state_stub
	.dw _veranSpider_state_switchHook
	.dw _veranSpider_state_scentSeed
	.dw _ecom_blownByGaleSeedState
	.dw _veranSpider_state_stub
	.dw _veranSpider_state_stub
	.dw _veranSpider_state8
	.dw _veranSpider_state9
	.dw _veranSpider_stateA


_veranSpider_state_uninitialized:
	ld a,PALH_8a		; $6839
	call loadPaletteHeader		; $683b

	; Choose a random position roughly within the current screen bounds to spawn the
	; spider at. This prevents the spider from spawning off-screen. But, the width is
	; only checked properly in the last row; if this were spawned in a small room, the
	; spiders could spawn off-screen. (Large rooms aren't a problem since there is no
	; off-screen area to the right, aside from one column, which is marked as solid.)
--
	call getRandomNumber		; $683e
	and $7f			; $6841
	cp $70 + SCREEN_WIDTH			; $6843
	jr nc,--		; $6845

	ld c,a			; $6847
	call objectSetShortPosition		; $6848

	; Adjust position to be relative to screen bounds
	ldh a,(<hCameraX)	; $684b
	add (hl)		; $684d
	ldd (hl),a		; $684e
	ld c,a			; $684f

	dec l			; $6850
	ldh a,(<hCameraY)	; $6851
	add (hl)		; $6853
	ld (hl),a		; $6854
	ld b,a			; $6855

	; If solid at this position, try again next frame.
	call getTileCollisionsAtPosition		; $6856
	ret nz			; $6859

	ld c,$08		; $685a
	call _ecom_setZAboveScreen		; $685c
	ld a,SPEED_60		; $685f
	call _ecom_setSpeedAndState8		; $6861

	ld l,Enemy.collisionType		; $6864
	set 7,(hl)		; $6866

	ld a,SND_FALLINHOLE		; $6868
	call playSound		; $686a
	jp objectSetVisiblec1		; $686d


_veranSpider_state_switchHook:
	inc e			; $6870
	ld a,(de)		; $6871
	rst_jumpTable			; $6872
	.dw _ecom_incState2
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate1:
@substate2:
	ret			; $687b

@substate3:
	ld b,$09		; $687c
	jp _ecom_fallToGroundAndSetState		; $687e


_veranSpider_state_scentSeed:
	ld a,(wScentSeedActive)		; $6881
	or a			; $6884
	jr z,_veranSpider_gotoState9	; $6885

	call _ecom_updateAngleToScentSeed		; $6887
	ld e,Enemy.angle		; $688a
	ld a,(de)		; $688c
	and $18			; $688d
	add $04			; $688f
	ld (de),a		; $6891
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $6892


;;
; @addr{6895}
_veranSpider_updateAnimation:
	ld h,d			; $6895
	ld l,Enemy.animCounter		; $6896
	ld a,(hl)		; $6898
	sub $03			; $6899
	jr nc,+			; $689b
	xor a			; $689d
+
	inc a			; $689e
	ld (hl),a		; $689f
	jp enemyAnimate		; $68a0

;;
; @addr{68a3}
_veranSpider_gotoState9:
	ld h,d			; $68a3
	ld l,Enemy.state		; $68a4
	ld (hl),$09		; $68a6
	ld l,Enemy.speed		; $68a8
	ld (hl),SPEED_60		; $68aa
	ret			; $68ac


_veranSpider_state_stub:
	ret			; $68ad


; Falling from sky
_veranSpider_state8:
	ld c,$0e		; $68ae
	call objectUpdateSpeedZ_paramC		; $68b0
	ret nz			; $68b3

	; Landed on ground
	ld l,Enemy.speedZ		; $68b4
	ldi (hl),a		; $68b6
	ld (hl),a		; $68b7

	ld l,Enemy.state		; $68b8
	inc (hl)		; $68ba

	; Enable scent seeds
	ld l,Enemy.var3f		; $68bb
	set 4,(hl)		; $68bd

	call objectSetVisiblec2		; $68bf
	ld a,SND_BOMB_LAND		; $68c2
	call playSound		; $68c4

	call _veranSpider_setRandomAngleAndCounter1		; $68c7
	jr _veranSpider_animate		; $68ca


; Moving in some direction for [counter1] frames
_veranSpider_state9:
	; Check if Link is along a diagonal relative to self?
	call objectGetAngleTowardEnemyTarget		; $68cc
	and $07			; $68cf
	sub $04			; $68d1
	inc a			; $68d3
	cp $03			; $68d4
	jr nc,@moveNormally	; $68d6

	; He is on a diagonal; if counter2 is zero, go to state $0a (charge at Link).
	ld e,Enemy.counter2		; $68d8
	ld a,(de)		; $68da
	or a			; $68db
	jr nz,@moveNormally	; $68dc

	call _ecom_updateAngleTowardTarget		; $68de
	and $18			; $68e1
	add $04			; $68e3
	ld (de),a		; $68e5

	call _ecom_incState		; $68e6
	ld l,Enemy.speed		; $68e9
	ld (hl),SPEED_140		; $68eb
	ld l,Enemy.counter1		; $68ed
	ld (hl),120		; $68ef
	ret			; $68f1

@moveNormally:
	call _ecom_decCounter2		; $68f2
	dec l			; $68f5
	dec (hl) ; [counter1]--
	call nz,_ecom_applyVelocityForSideviewEnemyNoHoles		; $68f7
	jp z,_veranSpider_setRandomAngleAndCounter1		; $68fa

_veranSpider_animate:
	jp enemyAnimate		; $68fd


; Charging in some direction for [counter1] frames
_veranSpider_stateA:
	call _ecom_decCounter1		; $6900
	jr z,++			; $6903
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $6905
	jp nz,_veranSpider_updateAnimation		; $6908
++
	call _veranSpider_gotoState9		; $690b
	ld l,Enemy.counter2		; $690e
	ld (hl),$40		; $6910


;;
; @addr{6912}
_veranSpider_setRandomAngleAndCounter1:
	ld bc,$1870		; $6912
	call _ecom_randomBitwiseAndBCE		; $6915
	ld e,Enemy.angle		; $6918
	ld a,b			; $691a
	add $04			; $691b
	ld (de),a		; $691d
	ld e,Enemy.counter1		; $691e
	ld a,c			; $6920
	add $70			; $6921
	ld (de),a		; $6923
	ret			; $6924


; ==============================================================================
; ENEMYID_EYESOAR_CHILD
;
; Variables:
;   relatedObj1: Pointer to ENEMYID_EYESOAR
;   relatedObj2: Pointer to INTERACID_0b?
;   var30: Distance away from Eyesoar (position in "circle arc")
;   var31: "Target" distance away from Eyesoar (var30 is moving toward this value)
;   var32: Angle offset for this child (each subid is a quarter circle apart)
;
; See also ENEMYID_EYESOAR variables.
; ==============================================================================
enemyCode11:
	jr z,@normalStatus	; $6925
	sub ENEMYSTATUS_NO_HEALTH			; $6927
	ret c			; $6929
	jr nz,@normalStatus	; $692a

	ld a,Object.health		; $692c
	call objectGetRelatedObject1Var		; $692e
	ld a,(hl)		; $6931
	or a			; $6932
	jp z,enemyDie_uncounted		; $6933

	call objectCreatePuff		; $6936
	ld h,d			; $6939
	ld l,Enemy.state		; $693a
	ld (hl),$0c		; $693c

	ld l,Enemy.counter1		; $693e
	ld (hl),30		; $6940

	ld l,Enemy.var30		; $6942
	ld (hl),$00		; $6944

	ld l,Enemy.collisionType		; $6946
	res 7,(hl)		; $6948

	ld l,Enemy.health		; $694a
	ld (hl),$04		; $694c
	call objectSetInvisible		; $694e

@normalStatus:
	ld a,Object.var39		; $6951
	call objectGetRelatedObject1Var		; $6953
	bit 1,(hl)		; $6956
	ld b,h			; $6958

	ld e,Enemy.state		; $6959
	jr z,@runState	; $695b
	ld a,(de)		; $695d
	cp $0f			; $695e
	jr nc,@runState	; $6960
	cp $0c			; $6962
	ld h,d			; $6964
	jr z,++		; $6965

	ld l,e			; $6967
	ld (hl),$0f ; [state]
	ld l,Enemy.counter1		; $696a
	ld (hl),$f0		; $696c
++
	ld l,Enemy.var31		; $696e
	ld (hl),$18		; $6970

@runState:
	; Note: b == parent (ENEMYID_EYESOAR), which is used in some of the states below.
	ld a,(de)		; $6972
	rst_jumpTable			; $6973
	.dw _eyesoarChild_state_uninitialized
	.dw _eyesoarChild_state_stub
	.dw _eyesoarChild_state_stub
	.dw _eyesoarChild_state_stub
	.dw _eyesoarChild_state_stub
	.dw _eyesoarChild_state_stub
	.dw _eyesoarChild_state_stub
	.dw _eyesoarChild_state_stub
	.dw _eyesoarChild_state8
	.dw _eyesoarChild_state9
	.dw _eyesoarChild_stateA
	.dw _eyesoarChild_stateB
	.dw _eyesoarChild_stateC
	.dw _eyesoarChild_stateD
	.dw _eyesoarChild_stateE
	.dw _eyesoarChild_stateF
	.dw _eyesoarChild_state10


_eyesoarChild_state_uninitialized:
	ld a,Object.yh		; $6996
	call objectGetRelatedObject1Var		; $6998
	ld b,(hl)		; $699b
	ld l,Enemy.xh		; $699c
	ld c,(hl)		; $699e

	ld e,Enemy.subid		; $699f
	ld a,(de)		; $69a1
	ld hl,@initialAnglesForSubids		; $69a2
	rst_addAToHl			; $69a5

	ld e,Enemy.angle		; $69a6
	ld a,(hl)		; $69a8
	ld (de),a		; $69a9
	ld e,Enemy.var32		; $69aa
	ld (de),a		; $69ac
	ld a,$18		; $69ad
	call objectSetPositionInCircleArc		; $69af

	ld e,Enemy.counter1		; $69b2
	ld a,90		; $69b4
	ld (de),a		; $69b6
	ld a,SPEED_100		; $69b7
	jp _ecom_setSpeedAndState8		; $69b9

@initialAnglesForSubids:
	.db ANGLE_UP, ANGLE_RIGHT, ANGLE_DOWN, ANGLE_LEFT



_eyesoarChild_state_stub:
	ret			; $69c0


; Wait for [counter1] frames before becoming visible
_eyesoarChild_state8:
	call _ecom_decCounter1		; $69c1
	ret nz			; $69c4
	ldbc INTERACID_0b,$02		; $69c5
	call objectCreateInteraction		; $69c8
	ret nz			; $69cb
	ld e,Enemy.relatedObj2		; $69cc
	ld a,Interaction.start		; $69ce
	ld (de),a		; $69d0
	inc e			; $69d1
	ld a,h			; $69d2
	ld (de),a		; $69d3

	jp _ecom_incState		; $69d4


_eyesoarChild_state9:
	ld a,Object.animParameter		; $69d7
	call objectGetRelatedObject2Var		; $69d9
	bit 7,(hl)		; $69dc
	ret z			; $69de

	call _ecom_incState		; $69df
	ld l,Enemy.counter1		; $69e2
	ld (hl),$f0		; $69e4
	ld l,Enemy.zh		; $69e6
	ld (hl),$fe		; $69e8
	ld l,Enemy.var30		; $69ea
	ld (hl),$18		; $69ec
	jp objectSetVisiblec2		; $69ee


; Moving around Eyesoar in a circle
_eyesoarChild_stateA:
	ld h,b			; $69f1
	ld l,Enemy.var39		; $69f2
	bit 2,(hl)		; $69f4
	jr z,_eyesoarChild_updatePosition			; $69f6

	ld l,Enemy.var38		; $69f8
	ld a,(hl)		; $69fa
	and $f8			; $69fb
	ld e,Enemy.var31		; $69fd
	ld (de),a		; $69ff
	ld e,Enemy.state		; $6a00
	ld a,$0b		; $6a02
	ld (de),a		; $6a04

;;
; @addr{6a05}
_eyesoarChild_updatePosition:
	ld l,Enemy.yh		; $6a05
	ld b,(hl)		; $6a07
	ld l,Enemy.xh		; $6a08
	ld c,(hl)		; $6a0a

	; [this.var32] += [parent.var3b] (update angle by rotation speed)
	ld l,Enemy.var3b		; $6a0b
	ld e,Enemy.var32		; $6a0d
	ld a,(de)		; $6a0f
	add (hl)		; $6a10
	and $1f			; $6a11
	ld e,Enemy.angle		; $6a13
	ld (de),a		; $6a15

	ld h,d			; $6a16
	ld l,Enemy.var30		; $6a17
	ld a,(hl)		; $6a19
	call objectSetPositionInCircleArc		; $6a1a
	jp enemyAnimate		; $6a1d


_eyesoarChild_stateB:
	; Check if we're the correct distance away
	ld h,d			; $6a20
	ld l,Enemy.var31		; $6a21
	ldd a,(hl)		; $6a23
	cp (hl) ; [var30]
	jr nz,_eyesoarChild_incOrDecHL	; $6a25

	ld l,e			; $6a27
	dec (hl) ; [state]

	; Mark flag in parent indicating we're in position
	ld h,b			; $6a29
	ld l,Enemy.var3a		; $6a2a
	ld e,Enemy.subid		; $6a2c
	ld a,(de)		; $6a2e
	call setFlag		; $6a2f
	jr _eyesoarChild_updatePosition		; $6a32


_eyesoarChild_incOrDecHL:
	ld a,$01		; $6a34
	jr nc,+			; $6a36
	ld a,$ff		; $6a38
+
	add (hl)		; $6a3a
	ld (hl),a		; $6a3b
	ld h,b			; $6a3c
	jr _eyesoarChild_updatePosition		; $6a3d


; Was just "killed"; waiting a bit before reappearing
_eyesoarChild_stateC:
	ld h,b			; $6a3f
	ld l,Enemy.var39		; $6a40
	bit 0,(hl)		; $6a42
	jr nz,@stillInvisible	; $6a44
	call _ecom_decCounter1		; $6a46
	jr nz,@stillInvisible	; $6a49

	ld l,e			; $6a4b
	inc (hl) ; [state]

	ld l,Enemy.collisionType		; $6a4d
	set 7,(hl)		; $6a4f
	call objectSetVisiblec2		; $6a51
	ld h,b			; $6a54
	jr _eyesoarChild_updatePosition		; $6a55

@stillInvisible:
	ld h,b			; $6a57
	ld e,Enemy.subid		; $6a58
	ld a,(de)		; $6a5a
	ld bc,@data		; $6a5b
	call addAToBc		; $6a5e
	ld a,(bc)		; $6a61
	ld l,Enemy.var3a		; $6a62
	or (hl)			; $6a64
	ld (hl),a		; $6a65
	ret			; $6a66

@data:
	.db $11 $22 $44 $88


; Just reappeared
_eyesoarChild_stateD:
	; Update position relative to eyesoar
	ld h,b			; $6a6b
	ld l,Enemy.var38		; $6a6c
	ld a,(hl)		; $6a6e
	and $f8			; $6a6f
	ld h,d			; $6a71
	ld l,Enemy.var30		; $6a72
	cp (hl)			; $6a74
	jr nz,_eyesoarChild_incOrDecHL	; $6a75

	; Reached desired position, go back to state $0a
	ld l,Enemy.state		; $6a77
	ld (hl),$0a		; $6a79

	ld h,b			; $6a7b
	jp _eyesoarChild_updatePosition		; $6a7c


_eyesoarChild_stateE:
	ld h,b			; $6a7f
	ld l,Enemy.var39		; $6a80
	bit 4,(hl)		; $6a82
	jp nz,_eyesoarChild_updatePosition		; $6a84

	ld a,$0b		; $6a87
	ld (de),a ; [state]
	jp _eyesoarChild_updatePosition		; $6a8a


; Moving around randomly
_eyesoarChild_stateF:
	ld h,b			; $6a8d
	ld l,Enemy.var39		; $6a8e
	bit 3,(hl)		; $6a90
	jr nz,@stillMovingRandomly	; $6a92

	; Calculate the angle relative to Eyesoar it should move to
	ld l,Enemy.var3b		; $6a94
	ld e,Enemy.var32		; $6a96
	ld a,(de)		; $6a98
	add (hl)		; $6a99
	and $1f			; $6a9a
	ld e,Enemy.angle		; $6a9c
	ld (de),a		; $6a9e

	call _ecom_incState		; $6a9f

	; $18 units away from Eyesoar
	ld l,Enemy.var30		; $6aa2
	ld (hl),$18		; $6aa4

	jr _eyesoarChild_animate		; $6aa6

@stillMovingRandomly:
	ld a,(wFrameCounter)		; $6aa8
	and $0f			; $6aab
	jr nz,+			; $6aad
	call objectGetAngleTowardEnemyTarget		; $6aaf
	call objectNudgeAngleTowards		; $6ab2
+
	call objectApplySpeed		; $6ab5
	call _ecom_bounceOffScreenBoundary		; $6ab8

_eyesoarChild_animate:
	jp enemyAnimate		; $6abb


; Moving back toward Eyesoar
_eyesoarChild_state10:
	; Load into wTmpcec0 the position offset relative to Eyesoar where we should be
	; moving to
	ld h,b			; $6abe
	ld l,Enemy.var3b		; $6abf
	ld a,(hl)		; $6ac1
	ld e,Enemy.var32		; $6ac2
	ld a,(de)		; $6ac4
	add (hl)		; $6ac5
	and $1f			; $6ac6
	ld c,a			; $6ac8
	ld a,$18		; $6ac9
	ld b,SPEED_100		; $6acb
	call getScaledPositionOffsetForVelocity		; $6acd

	; Get parent.position + offset in bc
	ld a,Object.yh		; $6ad0
	call objectGetRelatedObject1Var		; $6ad2
	ld a,(wTmpcec0+1)		; $6ad5
	add (hl)		; $6ad8
	ld b,a			; $6ad9
	ld l,Enemy.xh		; $6ada
	ld a,(wTmpcec0+3)		; $6adc
	add (hl)		; $6adf
	ld c,a			; $6ae0

	; Store current position
	ld e,l			; $6ae1
	ld a,(de)		; $6ae2
	ldh (<hFF8E),a	; $6ae3
	ld e,Enemy.yh		; $6ae5
	ld a,(de)		; $6ae7
	ldh (<hFF8F),a	; $6ae8

	; Check if we've reached the target position
	cp b			; $6aea
	jr nz,++		; $6aeb
	ldh a,(<hFF8E)	; $6aed
	cp c			; $6aef
	jr z,@reachedTargetPosition	; $6af0
++
	call _ecom_moveTowardPosition		; $6af2
	jr _eyesoarChild_animate		; $6af5

@reachedTargetPosition:
	; Wait for signal to change state
	ld l,Enemy.var39		; $6af7
	bit 1,(hl)		; $6af9
	ret nz			; $6afb

	ld e,Enemy.state		; $6afc
	ld a,$0e		; $6afe
	ld (de),a		; $6b00

	; Set flag in parent's var3a indicating we're good to go?
	ld e,Enemy.subid		; $6b01
	ld a,(de)		; $6b03
	add $04			; $6b04
	ld l,Enemy.var3a		; $6b06
	jp setFlag		; $6b08


; ==============================================================================
; ENEMYID_IRON_MASK
; ==============================================================================
enemyCode1c:
	call _ecom_checkHazards		; $6b0b
	jr z,@normalStatus	; $6b0e
	sub ENEMYSTATUS_NO_HEALTH			; $6b10
	ret c			; $6b12
	jp z,enemyDie		; $6b13
	dec a			; $6b16
	jp nz,_ecom_updateKnockbackAndCheckHazards		; $6b17

@normalStatus:
	call _ecom_getSubidAndCpStateTo08		; $6b1a
	jr c,@commonState	; $6b1d
	bit 0,b			; $6b1f
	jp z,_ironMask_subid00		; $6b21
	jp _ironMask_subid01		; $6b24

@commonState:
	rst_jumpTable			; $6b27
	.dw _ironMask_state_uninitialized
	.dw _ironMask_state_stub
	.dw _ironMask_state_stub
	.dw _ironMask_state_switchHook
	.dw _ironMask_state_stub
	.dw _ecom_blownByGaleSeedState
	.dw _ironMask_state_stub
	.dw _ironMask_state_stub


_ironMask_state_uninitialized:
	ld a,SPEED_80		; $6b38
	call _ecom_setSpeedAndState8AndVisible		; $6b3a

	ld l,Enemy.counter1		; $6b3d
	inc (hl)		; $6b3f

	bit 0,b			; $6b40
	ret z			; $6b42

	; Subid 1 only
	ld l,Enemy.enemyCollisionMode		; $6b43
	ld (hl),ENEMYCOLLISION_UNMASKED_IRON_MASK		; $6b45
	ld l,Enemy.knockbackCounter		; $6b47
	ld (hl),$10		; $6b49
	ld l,Enemy.invincibilityCounter		; $6b4b
	ld (hl),$e8		; $6b4d
	ld a,$04		; $6b4f
	jp enemySetAnimation		; $6b51


_ironMask_state_switchHook:
	inc e			; $6b54
	ld a,(de)		; $6b55
	rst_jumpTable			; $6b56
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3

; Using switch hook may cause this enemy's mask to be removed.
@substate0:
	ld e,Enemy.subid		; $6b5f
	ld a,(de)		; $6b61
	or a			; $6b62
	jr nz,@dontRemoveMask	; $6b63

	ld e,Enemy.enemyCollisionMode		; $6b65
	ld a,(de)		; $6b67
	cp ENEMYCOLLISION_UNMASKED_IRON_MASK			; $6b68
	jr z,@dontRemoveMask	; $6b6a

	ld b,ENEMYID_IRON_MASK		; $6b6c
	call _ecom_spawnUncountedEnemyWithSubid01		; $6b6e
	jr nz,@dontRemoveMask	; $6b71

	; Transfer "index" from enabled byte to new enemy
	ld l,Enemy.enabled		; $6b73
	ld e,l			; $6b75
	ld a,(de)		; $6b76
	ld (hl),a		; $6b77

	ld l,Enemy.knockbackAngle		; $6b78
	ld e,l			; $6b7a
	ld a,(de)		; $6b7b
	ld (hl),a		; $6b7c
	call objectCopyPosition		; $6b7d

	ld a,$05		; $6b80
	call enemySetAnimation		; $6b82

	ld a,SND_BOMB_LAND		; $6b85
	call playSound		; $6b87

	ld a,60		; $6b8a
	jr ++			; $6b8c

@dontRemoveMask:
	ld a,16		; $6b8e
++
	ld e,Enemy.counter1		; $6b90
	ld (de),a		; $6b92
	jp _ecom_incState2		; $6b93

@substate1:
@substate2:
	ret			; $6b96

@substate3:
	ld e,Enemy.subid		; $6b97
	ld a,(de)		; $6b99
	or a			; $6b9a
	jp nz,_ecom_fallToGroundAndSetState8		; $6b9b

	ld e,Enemy.enemyCollisionMode		; $6b9e
	ld a,(de)		; $6ba0
	cp ENEMYCOLLISION_IRON_MASK			; $6ba1
	jp nz,_ecom_fallToGroundAndSetState8		; $6ba3

	ld b,$0a		; $6ba6
	call _ecom_fallToGroundAndSetState		; $6ba8

	ld l,Enemy.collisionType		; $6bab
	res 7,(hl)		; $6bad
	ret			; $6baf


_ironMask_state_stub:
	ret			; $6bb0


; Iron mask with mask on
_ironMask_subid00:
	ld a,(de)		; $6bb1
	sub $08			; $6bb2
	rst_jumpTable			; $6bb4
	.dw @state8
	.dw @state9
	.dw @stateA


; Standing in place
@state8:
	call _ecom_decCounter1		; $6bbb
	jp nz,_ironMask_updateCollisionsFromLinkRelativeAngle		; $6bbe
	ld l,e			; $6bc1
	inc (hl) ; [state]
	call _ironMask_chooseRandomAngleAndCounter1		; $6bc3

; Moving in some direction for [counter1] frames
@state9:
	call _ecom_decCounter1		; $6bc6
	jr nz,++		; $6bc9
	ld l,e			; $6bcb
	dec (hl) ; [state]
	call _ironMask_chooseAmountOfTimeToStand		; $6bcd
++
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $6bd0
	call _ironMask_updateCollisionsFromLinkRelativeAngle		; $6bd3
	jp enemyAnimate		; $6bd6

; This enemy has turned into the mask that was removed; will delete self after [counter1]
; frames.
@stateA:
	call _ecom_decCounter1		; $6bd9
	jp nz,_ecom_flickerVisibility		; $6bdc
	jp enemyDelete		; $6bdf


; Iron mask without mask on
_ironMask_subid01:
	call _ecom_decCounter1		; $6be2
	call z,_ironMask_chooseRandomAngleAndCounter1		; $6be5
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $6be8
	jp enemyAnimate		; $6beb


;;
; Modifies this object's enemyCollisionMode based on if Link is directly behind the iron
; mask or not.
; @addr{6bee}
_ironMask_updateCollisionsFromLinkRelativeAngle:
	call objectGetAngleTowardEnemyTarget		; $6bee
	ld h,d			; $6bf1
	ld l,Enemy.angle		; $6bf2
	sub (hl)		; $6bf4
	and $1f			; $6bf5
	sub $0c			; $6bf7
	cp $09			; $6bf9
	ld l,Enemy.enemyCollisionMode		; $6bfb
	jr c,++			; $6bfd
	ld (hl),ENEMYCOLLISION_IRON_MASK		; $6bff
	ret			; $6c01
++
	ld (hl),ENEMYCOLLISION_UNMASKED_IRON_MASK		; $6c02
	ret			; $6c04


;;
; @addr{6c05}
_ironMask_chooseRandomAngleAndCounter1:
	ld bc,$0703		; $6c05
	call _ecom_randomBitwiseAndBCE		; $6c08
	ld a,b			; $6c0b
	ld hl,@counter1Vals		; $6c0c
	rst_addAToHl			; $6c0f

	ld e,Enemy.counter1		; $6c10
	ld a,(hl)		; $6c12
	ld (de),a		; $6c13

	ld e,Enemy.subid		; $6c14
	ld a,(de)		; $6c16
	or a			; $6c17
	jp nz,_ecom_setRandomCardinalAngle		; $6c18

	; Subid 0 only: 1 in 4 chance of turning directly toward Link, otherwise just
	; choose a random angle
	call @chooseAngle		; $6c1b
	swap a			; $6c1e
	rlca			; $6c20
	ld h,d			; $6c21
	ld l,Enemy.direction		; $6c22
	cp (hl)			; $6c24
	ret z			; $6c25
	ld (hl),a		; $6c26
	jp enemySetAnimation		; $6c27

@chooseAngle:
	ld a,c			; $6c2a
	or a			; $6c2b
	jp z,_ecom_updateCardinalAngleTowardTarget		; $6c2c
	jp _ecom_setRandomCardinalAngle		; $6c2f

@counter1Vals:
	.db 25 30 35 40 45 50 55 60

;;
; @addr{6c3a}
_ironMask_chooseAmountOfTimeToStand:
	call getRandomNumber_noPreserveVars		; $6c3a
	and $03			; $6c3d
	ld hl,@counter1Vals		; $6c3f
	rst_addAToHl			; $6c42
	ld e,Enemy.counter1		; $6c43
	ld a,(hl)		; $6c45
	ld (de),a		; $6c46
	ret			; $6c47

@counter1Vals:
	.db 15 30 45 60


; ==============================================================================
; ENEMYID_VERAN_CHILD_BEE
; ==============================================================================
enemyCode1f:
	jr z,@normalStatus	; $6c4c
	sub ENEMYSTATUS_NO_HEALTH			; $6c4e
	ret c			; $6c50
	jp z,enemyDie		; $6c51
	dec a			; $6c54
	jp nz,_ecom_updateKnockbackNoSolidity		; $6c55
	ret			; $6c58

@normalStatus:
	ld e,Enemy.state		; $6c59
	ld a,(de)		; $6c5b
	rst_jumpTable			; $6c5c
	.dw @state_uninitialized
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw _ecom_blownByGaleSeedState
	.dw @state_stub
	.dw @state_stub
	.dw @state8
	.dw @state9
	.dw @stateA


@state_uninitialized:
	ld a,SPEED_200		; $6c73
	call _ecom_setSpeedAndState8		; $6c75
	ld l,Enemy.counter1		; $6c78
	ld (hl),$10		; $6c7a

	ld e,Enemy.subid		; $6c7c
	ld a,(de)		; $6c7e
	ld hl,@angleVals		; $6c7f
	rst_addAToHl			; $6c82
	ld e,Enemy.angle		; $6c83
	ld a,(hl)		; $6c85
	ld (de),a		; $6c86
	jp objectSetVisible83		; $6c87

@angleVals:
	.db $10 $16 $0a


@state_stub:
	ret			; $6c8d


@state8:
	call _ecom_decCounter1		; $6c8e
	jr z,++			; $6c91
	call objectApplySpeed		; $6c93
	jr @animate		; $6c96
++
	ld (hl),$0c ; [counter1]
	ld l,e			; $6c9a
	inc (hl) ; [state]
@animate:
	jp enemyAnimate		; $6c9c


@state9:
	call _ecom_decCounter1		; $6c9f
	jr nz,@animate	; $6ca2
	ld l,e			; $6ca4
	inc (hl) ; [state]
	call _ecom_updateAngleTowardTarget		; $6ca6


@stateA:
	call objectApplySpeed		; $6ca9
	call objectCheckWithinRoomBoundary		; $6cac
	jr c,@animate	; $6caf
	call decNumEnemies		; $6cb1
	jp enemyDelete		; $6cb4


; ==============================================================================
; ENEMYID_ANGLER_FISH_BUBBLE
; ==============================================================================
enemyCode26:
	jr z,@normalStatus	; $6cb7
	sub ENEMYSTATUS_NO_HEALTH			; $6cb9
	ret c			; $6cbb
	call @popBubble		; $6cbc

@normalStatus:
	ld e,Enemy.state		; $6cbf
	ld a,(de)		; $6cc1
	rst_jumpTable			; $6cc2
	.dw @state0
	.dw @state1
	.dw @state2


; Initialization
@state0:
	ld h,d			; $6cc9
	ld l,e			; $6cca
	inc (hl) ; [state]

	; Can bounce off walls 5 times before popping
	ld l,Enemy.counter1		; $6ccc
	ld (hl),$05		; $6cce

	ld l,Enemy.speed		; $6cd0
	ld (hl),SPEED_100		; $6cd2

	ld a,Object.direction		; $6cd4
	call objectGetRelatedObject1Var		; $6cd6
	bit 0,(hl)		; $6cd9
	ld c,$f4		; $6cdb
	jr z,+			; $6cdd
	ld c,$0c		; $6cdf
+
	ld b,$00		; $6ce1
	call objectTakePositionWithOffset		; $6ce3
	call _ecom_updateAngleTowardTarget		; $6ce6
	jp objectSetVisible81		; $6ce9


; Bubble moving around
@state1:
	ld a,Object.id		; $6cec
	call objectGetRelatedObject1Var		; $6cee
	ld a,(hl)		; $6cf1
	cp ENEMYID_ANGLER_FISH			; $6cf2
	jr nz,@popBubble	; $6cf4

	call objectApplySpeed		; $6cf6
	call _ecom_bounceOffWallsAndHoles		; $6cf9
	jr z,@animate	; $6cfc

	; Each time it bounces off a wall, decrement counter1
	call _ecom_decCounter1		; $6cfe
	jr z,@popBubble	; $6d01

@animate:
	jp enemyAnimate		; $6d03

@popBubble:
	ld h,d			; $6d06
	ld l,Enemy.state		; $6d07
	ld (hl),$02		; $6d09

	ld l,Enemy.counter1		; $6d0b
	ld (hl),$08		; $6d0d

	ld l,Enemy.collisionType		; $6d0f
	res 7,(hl)		; $6d11

	ld l,Enemy.knockbackCounter		; $6d13
	ld (hl),$00		; $6d15

	; 1 in 4 chance of item drop
	call getRandomNumber_noPreserveVars		; $6d17
	cp $40			; $6d1a
	jr nc,++		; $6d1c

	call getFreePartSlot		; $6d1e
	jr nz,++		; $6d21
	ld (hl),PARTID_ITEM_DROP		; $6d23
	inc l			; $6d25
	ld (hl),ITEM_DROP_SCENT_SEEDS		; $6d26

	ld l,Part.invincibilityCounter		; $6d28
	ld (hl),$f0		; $6d2a
	call objectCopyPosition		; $6d2c
++
	; Bubble pop animation
	ld a,$01		; $6d2f
	call enemySetAnimation		; $6d31
	jp objectSetVisible83		; $6d34


; Bubble in the process of popping
@state2:
	call _ecom_decCounter1		; $6d37
	jr nz,@animate	; $6d3a
	jp enemyDelete		; $6d3c


; ==============================================================================
; ENEMYID_ENABLE_SIDESCROLL_DOWN_TRANSITION
; ==============================================================================
enemyCode2b:
	ld e,Enemy.state		; $6d3f
	ld a,(de)		; $6d41
	or a			; $6d42
	jp z,_ecom_incState		; $6d43

	ld hl,w1Link.xh		; $6d46
	ld a,(hl)		; $6d49
	cp $d0			; $6d4a
	ret c			; $6d4c

	ld l,<w1Link.yh		; $6d4d
	ld a,(hl)		; $6d4f
	ld l,<w1Link.speedZ+1		; $6d50
	add (hl)		; $6d52
	cp LARGE_ROOM_HEIGHT<<4 - 8			; $6d53
	ret c			; $6d55

	ld a,$80|DIR_DOWN		; $6d56
	ld (wScreenTransitionDirection),a		; $6d58
	ret			; $6d5b

.ends

 m_section_superfree Enemy_Animations
	.include "build/data/enemyAnimations.s"
.ends


.BANK $0e SLOT 1
.ORG 0

 m_section_free Enemy_Code_Bank0e NAMESPACE bank0e

	.include "code/enemyCommon.s"


; ==============================================================================
; ENEMYID_TEKTITE
;
; Variables:
;   var30: Gravity
;   var31: Minimum value for counter1 (lower value = more frequent jumping)
; ==============================================================================
enemyCode30:
	call _ecom_checkHazards		; $44f0
	jr z,@normalStatus	; $44f3
	sub ENEMYSTATUS_NO_HEALTH			; $44f5
	ret c			; $44f7
	jp z,enemyDie		; $44f8
	dec a			; $44fb
	jp nz,_ecom_updateKnockbackAndCheckHazards		; $44fc
	ret			; $44ff

@normalStatus:
	ld e,Enemy.state		; $4500
	ld a,(de)		; $4502
	rst_jumpTable			; $4503
	.dw @state_uninitialized
	.dw @state_stub
	.dw @state_stub
	.dw @state_switchHook
	.dw @state_stub
	.dw _ecom_blownByGaleSeedState
	.dw @state_stub
	.dw @state_stub
	.dw @state8
	.dw @state9
	.dw @stateA
	.dw @stateB


@state_uninitialized:
	; Subid 1 has lower value for var31, meaning more frequent jumps.
	ld h,d			; $451c
	ld l,Enemy.subid		; $451d
	bit 0,(hl)		; $451f
	ld l,Enemy.var31		; $4521
	ld (hl),90		; $4523
	jr z,+			; $4525
	ld (hl),45		; $4527
+
	call getRandomNumber_noPreserveVars		; $4529
	and $7f			; $452c
	inc a			; $452e
	ld e,Enemy.counter1		; $452f
	ld (de),a		; $4531
	ld a,SPEED_140		; $4532
	jp _ecom_setSpeedAndState8AndVisible		; $4534


@state_switchHook:
	inc e			; $4537
	ld a,(de)		; $4538
	rst_jumpTable			; $4539
	.dw _ecom_incState2
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate1:
@substate2:
	ret			; $4542

@substate3:
	ld b,$08		; $4543
	call _ecom_fallToGroundAndSetState		; $4545
	ret nz			; $4548
	jp @gotoState8		; $4549


@state_stub:
	ret			; $454c


; Standing in place for [counter1] frames
@state8:
	call _ecom_decCounter1		; $454d
	jr nz,@animate	; $4550

	; Set [counter1] to how long the crouch will last
	call getRandomNumber_noPreserveVars		; $4552
	and $7f			; $4555
	call _ecom_incState		; $4557
	ld l,Enemy.var31		; $455a
	add (hl)		; $455c
	ld l,Enemy.counter1		; $455d
	ldi (hl),a		; $455f
	ld (hl),$18		; $4560
	ld a,$01		; $4562
	jp enemySetAnimation		; $4564
@animate:
	jp enemyAnimate		; $4567


; Crouching before a leap
@state9:
	call _ecom_decCounter2		; $456a
	ret nz			; $456d
	ld l,e			; $456e
	inc (hl)		; $456f
	ld a,$02		; $4570
	jp enemySetAnimation		; $4572


; About to start a leap
@stateA:
	ld a,$0b		; $4575
	ld (de),a ; [state]

	call getRandomNumber_noPreserveVars		; $4578
	and $07			; $457b
	ld hl,@smallLeap		; $457d
	jr nz,+			; $4580
	ld hl,@bigLeap		; $4582
+
	ld e,Enemy.speedZ		; $4585
	ldi a,(hl)		; $4587
	ld (de),a		; $4588
	inc e			; $4589
	ldi a,(hl)		; $458a
	ld (de),a		; $458b

	; Gravity
	ld e,Enemy.var30		; $458c
	ldi a,(hl)		; $458e
	ld (de),a		; $458f

	call _ecom_updateAngleTowardTarget		; $4590
	ld a,SND_ENEMY_JUMP		; $4593
	call playSound		; $4595
	jp objectSetVisiblec1		; $4598


; speedZ, gravity
@smallLeap:
	dwb $feaa, $0e
@bigLeap:
	dwb $fe80, $0c


; Leaping
@stateB:
	call _ecom_bounceOffScreenBoundary		; $45a1
	ld e,Enemy.var30		; $45a4
	ld a,(de)		; $45a6
	ld c,a			; $45a7
	call objectUpdateSpeedZ_paramC		; $45a8
	jp nz,_ecom_applyVelocityForSideviewEnemy		; $45ab

;;
; @addr{45ae}
@gotoState8:
	call getRandomNumber_noPreserveVars		; $45ae
	and $7f			; $45b1
	ld h,d			; $45b3
	ld l,Enemy.var31		; $45b4
	add (hl)		; $45b6
	ld l,Enemy.counter1		; $45b7
	ld (hl),a		; $45b9
	ld l,Enemy.state		; $45ba
	ld (hl),$08		; $45bc
	xor a			; $45be
	call enemySetAnimation		; $45bf
	jp objectSetVisiblec2		; $45c2


; ==============================================================================
; ENEMYID_STALFOS
; ==============================================================================
enemyCode31:
	call _ecom_checkHazards		; $45c5
	jr z,@normalStatus	; $45c8
	sub ENEMYSTATUS_NO_HEALTH			; $45ca
	ret c			; $45cc
	jp z,enemyDie		; $45cd
	dec a			; $45d0
	jp nz,_ecom_updateKnockbackAndCheckHazards		; $45d1
	ret			; $45d4

@normalStatus:
	call _stalfos_checkJumpAwayFromLink		; $45d5
	ld e,Enemy.state		; $45d8
	ld a,(de)		; $45da
	rst_jumpTable			; $45db
	.dw _stalfos_state_uninitialized
	.dw _stalfos_state_stub
	.dw _stalfos_state_stub
	.dw _stalfos_state_switchHook
	.dw _stalfos_state_stub
	.dw _ecom_blownByGaleSeedState
	.dw _stalfos_state_stub
	.dw _stalfos_state_stub
	.dw _stalfos_state08
	.dw _stalfos_state09
	.dw _stalfos_state0a
	.dw _stalfos_state0b
	.dw _stalfos_state0c
	.dw _stalfos_state0d
	.dw _stalfos_state0e
	.dw _stalfos_state0f
	.dw _stalfos_state10


_stalfos_state_uninitialized:
	ld a,SPEED_80		; $45fe
	jp _ecom_setSpeedAndState8AndVisible		; $4600


_stalfos_state_switchHook:
	inc e			; $4603
	ld a,(de)		; $4604
	rst_jumpTable			; $4605
	.dw _ecom_incState2
	.dw @substate1
	.dw @substate2
	.dw _ecom_fallToGroundAndSetState8

@substate1:
@substate2:
	ret			; $460e


_stalfos_state_stub:
	ret			; $460f


; Choosing what to do next (move in a random direction, or shoot a bone an Link)
_stalfos_state08:
	call _stalfos_checkSubid3StompsLink		; $4610
	; Above function call may pop its return address, ignoring everything below this

	call getRandomNumber_noPreserveVars		; $4613
	and $07			; $4616
	jp nz,_stalfos_moveInRandomAngle		; $4618

	ld e,Enemy.subid		; $461b
	ld a,(de)		; $461d
	cp $02			; $461e
	jp nz,_stalfos_moveInRandomAngle		; $4620

	; For subid 2 only, there's a 1 in 8 chance of getting here (shooting a bone at
	; Link)
	ld e,Enemy.state		; $4623
	ld a,$0c		; $4625
	ld (de),a		; $4627
	ret			; $4628


; Moving in some direction for [counter1] frames
_stalfos_state09:
	call _stalfos_checkSubid3StompsLink		; $4629
	; Above function call may pop its return address, ignoring everything below this

	call _ecom_decCounter1		; $462c
	jr nz,++		; $462f
	ld l,Enemy.state		; $4631
	ld (hl),$08		; $4633
++
	call _ecom_bounceOffWallsAndHoles		; $4635
	call objectApplySpeed		; $4638
	jp enemyAnimate		; $463b


; Just starting a jump away from Link
_stalfos_state0a:
	ld bc,-$200		; $463e
	call objectSetSpeedZ		; $4641

	ld l,e			; $4644
	inc (hl) ; [state]

	; Make him invincible while he's moving upward
	ld l,Enemy.collisionType		; $4646
	res 7,(hl)		; $4648

	ld l,Enemy.speed		; $464a
	ld (hl),SPEED_140		; $464c

	call _ecom_updateCardinalAngleAwayFromTarget		; $464e
	jp _stalfos_beginJumpAnimation		; $4651


; Jumping until hitting the ground
_stalfos_state0b:
	ld c,$20		; $4654
	call objectUpdateSpeedZ_paramC		; $4656
	jr z,@hitGround	; $4659

	; Make him vulnerable to attack again once he starts moving down
	ld a,(hl) ; a = [speedZ]
	or a			; $465c
	jr nz,++		; $465d
	ld l,Enemy.collisionType		; $465f
	set 7,(hl)		; $4661
++
	jp _ecom_applyVelocityForSideviewEnemy		; $4663

@hitGround:
	ld a,SPEED_80		; $4666
	call _ecom_setSpeedAndState8		; $4668
	xor a			; $466b
	call enemySetAnimation		; $466c
	jp objectSetVisiblec2		; $466f


; Firing a projectile, then immediately going to state 9 to keep moving
_stalfos_state0c:
	ld b,PARTID_STALFOS_BONE		; $4672
	call _ecom_spawnProjectile		; $4674
	jr _stalfos_moveInRandomAngle		; $4677


; Stomping on Link
_stalfos_state0d:
	ld c,$20		; $4679
	call objectUpdateSpeedZ_paramC		; $467b

	; Check if he's begun moving down yet
	ld a,(hl)		; $467e
	or a			; $467f
	jp nz,_ecom_applyVelocityForSideviewEnemyNoHoles		; $4680

	; He's begun moving down. Go to next state so he freezes in the air.
	ld l,Enemy.counter1		; $4683
	ld (hl),$08		; $4685
	ld l,Enemy.state		; $4687
	inc (hl)		; $4689
	ret			; $468a


; Wait for 8 frames while hanging in the air mid-stomp
_stalfos_state0e:
	call _ecom_decCounter1		; $468b
	ret nz			; $468e
	ld l,e			; $468f
	inc (hl) ; [state]
	ret			; $4691


; Fall down for the stomp
_stalfos_state0f:
	ld h,d			; $4692
	ld l,Enemy.zh		; $4693
	ld a,(hl)		; $4695
	add $03			; $4696
	ld (hl),a		; $4698
	cp $80			; $4699
	ret nc			; $469b

	; Hit the ground
	xor a			; $469c
	ld (hl),a ; [zh] = 0

	ld l,e			; $469e
	inc (hl) ; [state]

	ld l,Enemy.counter1		; $46a0
	ld (hl),30		; $46a2
	jp objectSetVisiblec2		; $46a4


; Laying on the ground for [counter1] frames until he starts moving again
_stalfos_state10:
	call _ecom_decCounter1		; $46a7
	ret nz			; $46aa


;;
; Go to state 9 with a freshly chosen angle
; @addr{46ab}
_stalfos_moveInRandomAngle:
	ld e,$30		; $46ab
	ld bc,$1f0f		; $46ad
	call _ecom_randomBitwiseAndBCE		; $46b0

	ld h,d			; $46b3
	ld l,Enemy.state		; $46b4
	ld (hl),$09		; $46b6
	ld l,Enemy.speed		; $46b8
	ld (hl),SPEED_80		; $46ba

	ld a,$20		; $46bc
	add e			; $46be
	ld l,Enemy.counter1		; $46bf
	ld (hl),a		; $46c1

	; 1 in 16 chance of moving toward Link; otherwise, move in random direction
	dec c			; $46c2
	ld a,b			; $46c3
	call z,objectGetAngleTowardEnemyTarget		; $46c4
	ld e,Enemy.angle		; $46c7
	ld (de),a		; $46c9
	xor a			; $46ca
	jp enemySetAnimation		; $46cb


;;
; For subid 3 only, if Link approaches close enough, it will jump toward Link to stomp on
; him (goes to state $0d).
; @addr{46ce}
_stalfos_checkSubid3StompsLink:
	ld e,Enemy.subid		; $46ce
	ld a,(de)		; $46d0
	cp $03			; $46d1
	ret nz			; $46d3

	ld c,$1c		; $46d4
	call objectCheckLinkWithinDistance		; $46d6
	ret nc			; $46d9

	ld bc,-$240		; $46da
	call objectSetSpeedZ		; $46dd

	ld l,Enemy.state		; $46e0
	ld (hl),$0d		; $46e2
	ld l,Enemy.speed		; $46e4
	ld (hl),SPEED_180		; $46e6

	pop hl ; Return from caller

	call _ecom_updateAngleTowardTarget		; $46e9


;;
; @addr{46ec}
_stalfos_beginJumpAnimation:
	ld a,$01		; $46ec
	call enemySetAnimation		; $46ee
	ld a,SND_ENEMY_JUMP		; $46f1
	call playSound		; $46f3
	jp objectSetVisiblec1		; $46f6


;;
; If Link is swinging something near this object, it will set its state to $0a if not
; already jumping.
; @addr{46f9}
_stalfos_checkJumpAwayFromLink:
	; Not for subid 0
	ld e,Enemy.subid		; $46f9
	ld a,(de)		; $46fb
	or a			; $46fc
	ret z			; $46fd

	; Check specifically for w1WeaponItem being used?
	ld a,(wLinkUsingItem1)		; $46fe
	and $f0			; $4701
	ret z			; $4703

	ld e,Enemy.state		; $4704
	ld a,(de)		; $4706
	cp $0a			; $4707
	ret nc			; $4709

	ld c,$2c		; $470a
	call objectCheckLinkWithinDistance		; $470c
	ret nc			; $470f

	ld e,Enemy.state		; $4710
	ld a,$0a		; $4712
	ld (de),a		; $4714
	ret			; $4715

;;
; Unused
; @addr{4716}
_stalfos_setState8:
	ld e,Enemy.state		; $4716
	ld a,$08		; $4718
	ld (de),a		; $471a
	ret			; $471b


; ==============================================================================
; ENEMYID_KEESE
;
; Variables (for subid 1 only, the one that moves as Link approaches):
;   var30: Amount to add to angle each frame. (Clockwise or counterclockwise turning)
; ==============================================================================
enemyCode32:
	jr z,@normalStatus	; $471c
	sub ENEMYSTATUS_NO_HEALTH			; $471e
	ret c			; $4720
	jp z,enemyDie		; $4721
	dec a			; $4724
	jp nz,_ecom_updateKnockbackNoSolidity		; $4725
	ret			; $4728

@normalStatus:
	call _ecom_getSubidAndCpStateTo08		; $4729
	jr nc,@normalState	; $472c
	rst_jumpTable			; $472e
	.dw _keese_state_uninitialized
	.dw _keese_state_stub
	.dw _keese_state_stub
	.dw _keese_state_stub
	.dw _keese_state_stub
	.dw _ecom_blownByGaleSeedState
	.dw _keese_state_stub
	.dw _keese_state_stub

@normalState:
	ld a,b			; $473f
	rst_jumpTable			; $4740
	.dw _keese_subid00
	.dw _keese_subid01


_keese_state_uninitialized:
	call _ecom_setSpeedAndState8		; $4745
	call _keese_initializeSubid		; $4748
	jp objectSetVisible82		; $474b


_keese_state_stub:
	ret			; $474e


_keese_subid00:
	ld a,(de)		; $474f
	sub $08			; $4750
	rst_jumpTable			; $4752
	.dw _keese_subid00_state8
	.dw _keese_subid00_state9
	.dw _keese_subid00_stateA


; Resting for [counter1] frames
_keese_subid00_state8:
	call _ecom_decCounter1		; $4759
	ret nz			; $475c

	; Choose random angle and counter1
	ld bc,$1f3f		; $475d
	call _ecom_randomBitwiseAndBCE		; $4760
	call _ecom_incState		; $4763

	ld l,Enemy.angle		; $4766
	ld (hl),b		; $4768
	ld l,Enemy.speed		; $4769
	ld (hl),SPEED_c0		; $476b

	ld a,$c0		; $476d
	add c			; $476f
	ld l,Enemy.counter1		; $4770
	ld (hl),a		; $4772

	ld a,$01		; $4773
	call enemySetAnimation		; $4775
	jr _keese_animate		; $4778


; Moving in some direction for [counter1] frames
_keese_subid00_state9:
	call objectApplySpeed		; $477a
	call _ecom_bounceOffScreenBoundary		; $477d
	ld a,(wFrameCounter)		; $4780
	rrca			; $4783
	jr c,_keese_animate	; $4784

	call _ecom_decCounter1		; $4786
	jr z,@timeToStop			; $4789

	; 1 in 16 chance, per frame, of randomly choosing a new angle to move in
	ld bc,$0f1f		; $478b
	call _ecom_randomBitwiseAndBCE		; $478e
	or b			; $4791
	jr nz,_keese_animate	; $4792

	ld e,Enemy.angle		; $4794
	ld a,c			; $4796
	ld (de),a		; $4797
	jr _keese_animate		; $4798

@timeToStop:
	ld l,Enemy.state		; $479a
	inc (hl)		; $479c

_keese_animate:
	jp enemyAnimate		; $479d


; Decelerating until [counter1] counts up to $7f, when it stops completely.
_keese_subid00_stateA:
	ld e,Enemy.counter1		; $47a0
	ld a,(de)		; $47a2
	cp $68			; $47a3
	jr nc,++		; $47a5
	call objectApplySpeed		; $47a7
	call _ecom_bounceOffScreenBoundary		; $47aa
++
	call _keese_updateDeceleration		; $47ad
	ld h,d			; $47b0
	ld l,Enemy.counter1		; $47b1
	inc (hl)		; $47b3

	ld a,$7f		; $47b4
	cp (hl)			; $47b6
	ret nz			; $47b7

	; Full stop
	ld l,Enemy.state		; $47b8
	ld (hl),$08		; $47ba

	; Set counter1 randomly
	call getRandomNumber_noPreserveVars		; $47bc
	and $7f			; $47bf
	ld e,Enemy.counter1		; $47c1
	add $20			; $47c3
	ld (de),a		; $47c5
	xor a			; $47c6
	jp enemySetAnimation		; $47c7


_keese_subid01:
	ld a,(de)		; $47ca
	sub $08			; $47cb
	rst_jumpTable			; $47cd
	.dw _keese_subid01_state8
	.dw _keese_subid02_state9


; Waiting for Link to approach
_keese_subid01_state8:
	ld c,$31		; $47d2
	call objectCheckLinkWithinDistance		; $47d4
	ret nc			; $47d7

	call _ecom_updateAngleTowardTarget		; $47d8
	call _ecom_incState		; $47db

	ld l,Enemy.speed		; $47de
	ld (hl),SPEED_100		; $47e0

	; Turn clockwise or counterclockwise, based on var30
	ld e,Enemy.angle		; $47e2
	ld l,Enemy.var30		; $47e4
	ld a,(de)		; $47e6
	add (hl)		; $47e7
	and $1f			; $47e8
	ld (de),a		; $47ea

	ld l,Enemy.counter1		; $47eb
	ld (hl),12		; $47ed
	inc l			; $47ef
	ld (hl),12 ; [counter2]

	ld a,$01		; $47f2
	jp enemySetAnimation		; $47f4


_keese_subid02_state9:
	call objectApplySpeed		; $47f7
	call _ecom_bounceOffScreenBoundary		; $47fa
	call _ecom_decCounter1		; $47fd
	jr nz,_keese_animate	; $4800

	ld (hl),12 ; [counter1]

	; Turn clockwise or counterclockwise, based on var30
	ld l,Enemy.var30		; $4804
	ld e,Enemy.angle		; $4806
	ld a,(de)		; $4808
	add (hl)		; $4809
	and $1f			; $480a
	ld (de),a		; $480c

	ld l,Enemy.counter2		; $480d
	dec (hl)		; $480f
	jr nz,_keese_animate	; $4810

	; Done moving.
	ld l,Enemy.state		; $4812
	dec (hl)		; $4814
	call _keese_chooseWhetherToReverseTurningAngle		; $4815
	xor a			; $4818
	jp enemySetAnimation		; $4819


;;
; Every 16 frames (based on counter1) this updates the keese's speed as it's decelerating.
; Also handles the animation (which slows down).
; @addr{481c}
_keese_updateDeceleration:
	ld e,Enemy.counter1		; $481c
	ld a,(de)		; $481e
	and $0f			; $481f
	jr nz,++		; $4821

	ld a,(de)		; $4823
	swap a			; $4824
	ld hl,@speeds		; $4826
	rst_addAToHl			; $4829
	ld a,(hl)		; $482a
	ld e,Enemy.speed		; $482b
	ld (de),a		; $482d
++
	ld e,Enemy.counter1		; $482e
	ld a,(de)		; $4830
	and $f0			; $4831
	swap a			; $4833
	ld hl,@bits		; $4835
	rst_addAToHl			; $4838
	ld a,(wFrameCounter)		; $4839
	and (hl)		; $483c
	jp z,enemyAnimate		; $483d
	ret			; $4840

@speeds:
	.db SPEED_c0, SPEED_80, SPEED_40, SPEED_40, SPEED_20, SPEED_20, SPEED_20, SPEED_20

@bits:
	.db $00 $00 $01 $01 $03 $03 $07 $00


;;
; @addr{4851}
_keese_initializeSubid:
	dec b			; $4851
	jr z,@subid1			; $4852

@subid0:
	; Just set how long to wait initially
	ld l,Enemy.counter1		; $4854
	ld (hl),$20		; $4856
	ret			; $4858

@subid1:
	ld l,Enemy.zh		; $4859
	ld (hl),$ff		; $485b

	ld l,Enemy.var30		; $485d
	ld (hl),$02		; $485f

;;
; For subid 1 only, this has a 1 in 4 chance of deciding to reverse the turning angle
; (clockwise or counterclockwise).
; @addr{4861}
_keese_chooseWhetherToReverseTurningAngle:
	call getRandomNumber_noPreserveVars		; $4861
	and $03			; $4864
	ret nz			; $4866

	ld e,Enemy.var30		; $4867
	ld a,(de)		; $4869
	cpl			; $486a
	inc a			; $486b
	ld (de),a		; $486c
	ret			; $486d


; ==============================================================================
; ENEMYID_BABY_CUCCO
; ==============================================================================
enemyCode33:
	ld e,Enemy.state		; $486e
	ld a,(de)		; $4870
	rst_jumpTable			; $4871
	.dw _babyCucco_state_uninitialized
	.dw _babyCucco_state_stub
	.dw _babyCucco_state_grabbed
	.dw _babyCucco_state_stub
	.dw _babyCucco_state_stub
	.dw _babyCucco_state_stub
	.dw _babyCucco_state_stub
	.dw _babyCucco_state_stub
	.dw _babyCucco_state8
	.dw _babyCucco_state9


_babyCucco_state_uninitialized:
	ld a,SPEED_40		; $4886
	jp _ecom_setSpeedAndState8AndVisible		; $4888


_babyCucco_state_grabbed:
	inc e			; $488b
	ld a,(de)		; $488c
	rst_jumpTable			; $488d
	.dw @justGrabbed
	.dw @beingHeld
	.dw @released
	.dw @landed

@justGrabbed:
	ld h,d			; $4896
	ld l,e			; $4897
	inc (hl) ; [state2]

	ld l,Enemy.collisionType		; $4899
	res 7,(hl)		; $489b

	xor a			; $489d
	ld (wLinkGrabState2),a		; $489e

	ld a,(w1Link.direction)		; $48a1
	srl a			; $48a4
	xor $01			; $48a6
	ld l,Enemy.direction		; $48a8
	ld (hl),a		; $48aa
	call enemySetAnimation		; $48ab

	jp objectSetVisiblec1		; $48ae

@beingHeld:
	ld h,d			; $48b1
	ld l,Enemy.direction		; $48b2
	ld a,(w1Link.direction)		; $48b4
	srl a			; $48b7
	xor $01			; $48b9
	cp (hl)			; $48bb
	jr z,@released		; $48bc
	ld (hl),a		; $48be
	jp enemySetAnimation		; $48bf

@released:
	ld e,Enemy.yh		; $48c2
	ld a,(de)		; $48c4
	cp SMALL_ROOM_HEIGHT<<4			; $48c5
	jr nc,@delete		; $48c7

	ld e,Enemy.xh		; $48c9
	ld a,(de)		; $48cb
	cp SMALL_ROOM_WIDTH<<4			; $48cc
	jp c,enemyAnimate		; $48ce
@delete:
	jp enemyDelete		; $48d1

@landed:
	ld h,d			; $48d4
	ld l,Enemy.state		; $48d5
	ld (hl),$08		; $48d7
	ld l,Enemy.collisionType		; $48d9
	set 7,(hl)		; $48db
	ld l,Enemy.direction		; $48dd
	ld (hl),$ff		; $48df
	jp objectSetVisiblec2		; $48e1


_babyCucco_state_stub:
	ret			; $48e4


_babyCucco_state8:
	call objectAddToGrabbableObjectBuffer		; $48e5
	call objectSetPriorityRelativeToLink_withTerrainEffects		; $48e8

	call _ecom_updateAngleTowardTarget		; $48eb
	call _babyCucco_updateAnimationFromAngle		; $48ee

	ld c,$10		; $48f1
	call objectCheckLinkWithinDistance		; $48f3
	jr nc,@moveCloserToLink	; $48f6

	; If near Link, 1 in 64 chance of hopping (per frame)
	call getRandomNumber_noPreserveVars		; $48f8
	and $3f			; $48fb
	ret nz			; $48fd

	call _ecom_incState		; $48fe
	ld l,Enemy.speedZ		; $4901
	ld a,<($ff40)		; $4903
	ldi (hl),a		; $4905
	ld (hl),>($ff40)		; $4906
	ret			; $4908

@moveCloserToLink:
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $4909

_babyCucco_animate:
	jp enemyAnimate		; $490c


; Hopping
_babyCucco_state9:
	ld c,$12		; $490f
	call objectUpdateSpeedZ_paramC		; $4911
	jr nz,_babyCucco_animate	; $4914

	ld l,Enemy.state		; $4916
	dec (hl)		; $4918
	ret			; $4919


;;
; @addr{491a}
_babyCucco_updateAnimationFromAngle:
	ld e,Enemy.angle		; $491a
	ld a,(de)		; $491c
	cp $10			; $491d
	ld a,$01		; $491f
	jr c,+			; $4921
	xor a			; $4923
+
	ld h,d			; $4924
	ld l,Enemy.direction		; $4925
	cp (hl)			; $4927
	ret z			; $4928
	ld (hl),a		; $4929
	jp enemySetAnimation		; $492a


; ==============================================================================
; ENEMYID_ZOL
;
; Variables:
;   var30: 1 when the zol is out of the ground, 0 otherwise. (only for subid 0, and only
;          used to prevent the "jump" sound effect from playing more than once.)
; ==============================================================================
enemyCode34:
	call _ecom_checkHazardsNoAnimationForHoles		; $492d
	jr z,@normalStatus	; $4930
	sub ENEMYSTATUS_NO_HEALTH			; $4932
	ret c			; $4934
	jp z,enemyDie		; $4935
	dec a			; $4938
	jp nz,_ecom_updateKnockbackAndCheckHazardsNoAnimationsForHoles		; $4939

	; ENEMYSTATUS_JUST_HIT

	ld e,Enemy.subid		; $493c
	ld a,(de)		; $493e
	or a			; $493f
	ret z			; $4940

	; Subid 1 only: Collision with anything except Link or a shield causes it to
	; split in two.
	ld e,Enemy.var2a		; $4941
	ld a,(de)		; $4943
	cp ITEMCOLLISION_LINK|$80			; $4944
	jr z,@normalStatus	; $4946

	res 7,a			; $4948
	sub ITEMCOLLISION_L1_SHIELD			; $494a
	cp ITEMCOLLISION_L3_SHIELD - ITEMCOLLISION_L1_SHIELD + 1			; $494c
	ret c			; $494e

	ld e,Enemy.state		; $494f
	ld a,$0c		; $4951
	ld (de),a		; $4953
	ret			; $4954

@normalStatus:
	call _ecom_getSubidAndCpStateTo08		; $4955
	jr nc,@normalState	; $4958
	rst_jumpTable			; $495a
	.dw _zol_state_uninitialized
	.dw _zol_state_stub
	.dw _zol_state_stub
	.dw _zol_state_stub
	.dw _zol_state_stub
	.dw _ecom_blownByGaleSeedState
	.dw _zol_state_stub
	.dw _zol_state_stub

@normalState:
	ld a,b			; $496b
	rst_jumpTable			; $496c
	.dw _zol_subid00
	.dw _zol_subid01


_zol_state_uninitialized:
	ld a,b			; $4971
	or a			; $4972
	ld a,SPEED_c0		; $4973
	jp z,_ecom_setSpeedAndState8		; $4975

	; Subid 1 only
	ld h,d			; $4978
	ld l,Enemy.counter1		; $4979
	ld (hl),$18		; $497b
	ld l,Enemy.collisionType		; $497d
	set 7,(hl)		; $497f

	ld a,$04		; $4981
	call enemySetAnimation		; $4983
	jp _ecom_setSpeedAndState8AndVisible		; $4986


_zol_state_stub:
	ret			; $4989


_zol_subid00:
	ld a,(de)		; $498a
	sub $08			; $498b
	rst_jumpTable			; $498d
	.dw _zol_subid00_state8
	.dw _zol_subid00_state9
	.dw _zol_subid00_stateA
	.dw _zol_subid00_stateB
	.dw _zol_subid00_stateC
	.dw _zol_subid00_stateD


; Hiding in ground, waiting for Link to approach
_zol_subid00_state8:
	ld c,$28		; $499a
	call objectCheckLinkWithinDistance		; $499c
	ret nc			; $499f

	ld bc,-$200		; $49a0
	call objectSetSpeedZ		; $49a3

	ld l,Enemy.state		; $49a6
	inc (hl)		; $49a8

	; [counter2] = number of hops before disappearing
	ld l,Enemy.counter2		; $49a9
	ld (hl),$04		; $49ab

	jp objectSetVisiblec2		; $49ad


; Jumping out of ground
_zol_subid00_state9:
	ld h,d			; $49b0
	ld l,Enemy.animParameter		; $49b1
	ld a,(hl)		; $49b3
	or a			; $49b4
	jr z,_zol_animate	; $49b5

	ld l,Enemy.var30		; $49b7
	and (hl)		; $49b9
	jr nz,++		; $49ba
	ld (hl),$01		; $49bc
	ld a,SND_ENEMY_JUMP		; $49be
	call playSound		; $49c0
++
	ld c,$28		; $49c3
	call objectUpdateSpeedZ_paramC		; $49c5
	ret nz			; $49c8

	; Landed on ground; go to next state
	call _ecom_incState		; $49c9

	ld l,Enemy.counter1		; $49cc
	ld (hl),$30		; $49ce

	ld l,Enemy.collisionType		; $49d0
	set 7,(hl)		; $49d2
	inc a			; $49d4
	jp enemySetAnimation		; $49d5


; Holding still for [counter1] frames, preparing to hop toward Link
_zol_subid00_stateA:
	call _ecom_decCounter1		; $49d8
	ret nz			; $49db

	ld l,e			; $49dc
	inc (hl) ; [state]

	ld bc,-$200		; $49de
	call objectSetSpeedZ		; $49e1

	call _ecom_updateAngleTowardTarget		; $49e4

	ld a,$02		; $49e7
	call enemySetAnimation		; $49e9

	ld a,SND_ENEMY_JUMP		; $49ec
	call playSound		; $49ee

_zol_animate:
	jp enemyAnimate		; $49f1


; Hopping toward Link
_zol_subid00_stateB:
	call _ecom_applyVelocityForSideviewEnemy		; $49f4

	ld c,$28		; $49f7
	call objectUpdateSpeedZ_paramC		; $49f9
	ret nz			; $49fc

	; Hit the ground

	ld h,d			; $49fd
	ld l,Enemy.counter1		; $49fe
	ld (hl),$30		; $4a00
	inc l			; $4a02
	dec (hl) ; [counter2]-- (number of hops remaining)

	ld a,$0a		; $4a04
	ld b,$01		; $4a06
	jr nz,++		; $4a08

	; [counter2] == 0; go to state $0c, and disable collisions as we're disappearing
	; now
	ld l,Enemy.collisionType		; $4a0a
	res 7,(hl)		; $4a0c
	ld a,$0c		; $4a0e
	ld b,$03		; $4a10
++
	ld l,Enemy.state		; $4a12
	ld (hl),a		; $4a14
	ld a,b			; $4a15
	jp enemySetAnimation		; $4a16


; Disappearing into the ground
_zol_subid00_stateC:
	ld h,d			; $4a19
	ld l,Enemy.animParameter		; $4a1a
	ld a,(hl)		; $4a1c
	or a			; $4a1d
	jr z,_zol_animate	; $4a1e

	ld l,e			; $4a20
	inc (hl) ; [state]

	ld l,Enemy.counter1		; $4a22
	ld (hl),40		; $4a24

	ld l,Enemy.var30		; $4a26
	xor a			; $4a28
	ld (hl),a		; $4a29

	call enemySetAnimation		; $4a2a
	jp objectSetInvisible		; $4a2d


; Fully disappeared into ground. Wait [counter1] frames before we can emerge again
_zol_subid00_stateD:
	call _ecom_decCounter1		; $4a30
	ret nz			; $4a33

	ld l,e			; $4a34
	ld (hl),$08 ; [state]

	xor a			; $4a37
	jp enemySetAnimation		; $4a38


_zol_subid01:
	ld a,(de)		; $4a3b
	sub $08			; $4a3c
	rst_jumpTable			; $4a3e
	.dw _zol_subid01_state8
	.dw _zol_subid01_state9
	.dw _zol_subid01_stateA
	.dw _zol_subid01_stateB
	.dw _zol_subid01_stateC
	.dw _zol_subid01_stateD


; Holding still for [counter1] frames before deciding whether to hop or move forward
_zol_subid01_state8:
	call _ecom_decCounter1		; $4a4b
	jr nz,_zol_animate2	; $4a4e

	; 1 in 8 chance of hopping toward Link
	call getRandomNumber_noPreserveVars		; $4a50
	and $07			; $4a53
	ld h,d			; $4a55
	ld l,Enemy.counter1		; $4a56
	jr z,@hopTowardLink	; $4a58

	; 7 in 8 chance of sliding toward Link
	ld (hl),$10 ; [counter1]
	ld l,Enemy.state		; $4a5c
	inc (hl)		; $4a5e

	ld l,Enemy.speed		; $4a5f
	ld (hl),SPEED_80		; $4a61
	call _ecom_updateAngleTowardTarget		; $4a63
	jr _zol_animate2		; $4a66

@hopTowardLink:
	ld (hl),$20 ; [counter1]
	ld l,Enemy.state		; $4a6a
	ld (hl),$0a		; $4a6c
	ld a,$05		; $4a6e
	jp enemySetAnimation		; $4a70


; Sliding toward Link
_zol_subid01_state9:
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $4a73
	call _ecom_bounceOffScreenBoundary		; $4a76

	call _ecom_decCounter1		; $4a79
	jr nz,_zol_animate2	; $4a7c

	ld (hl),$18 ; [counter1]
	ld l,Enemy.state		; $4a80
	dec (hl)		; $4a82

_zol_animate2:
	jp enemyAnimate		; $4a83


; Shaking before hopping toward Link
_zol_subid01_stateA:
	call _ecom_decCounter1		; $4a86
	jr nz,_zol_animate2	; $4a89

	call _ecom_incState		; $4a8b

	ld l,Enemy.speedZ		; $4a8e
	ld (hl),<(-$200)		; $4a90
	inc l			; $4a92
	ld (hl),>(-$200)		; $4a93

	ld l,Enemy.speed		; $4a95
	ld (hl),SPEED_100		; $4a97
	call _ecom_updateAngleTowardTarget		; $4a99

	ld a,$02		; $4a9c
	call enemySetAnimation		; $4a9e
	ld a,SND_ENEMY_JUMP		; $4aa1
	call playSound		; $4aa3

	jp objectSetVisiblec1		; $4aa6


; Hopping toward Link
_zol_subid01_stateB:
	call _ecom_applyVelocityForSideviewEnemy		; $4aa9
	ld c,$28		; $4aac
	call objectUpdateSpeedZ_paramC		; $4aae
	ret nz			; $4ab1

	; Hit ground
	ld h,d			; $4ab2
	ld l,Enemy.counter1		; $4ab3
	ld (hl),$18		; $4ab5

	ld l,Enemy.state		; $4ab7
	ld (hl),$08		; $4ab9

	ld a,$04		; $4abb
	call enemySetAnimation		; $4abd
	jp objectSetVisiblec2		; $4ac0


; Zol has been attacked, create puff, disable collisions, prepare to spawn two gels in the
; zol's place.
_zol_subid01_stateC:
	ld b,INTERACID_KILLENEMYPUFF		; $4ac3
	call objectCreateInteractionWithSubid00		; $4ac5

	ld h,d			; $4ac8
	ld l,Enemy.counter2		; $4ac9
	ld (hl),18		; $4acb

	ld l,Enemy.collisionType		; $4acd
	res 7,(hl)		; $4acf

	ld l,Enemy.state		; $4ad1
	inc (hl)		; $4ad3

	ld a,SND_KILLENEMY		; $4ad4
	call playSound		; $4ad6

	jp objectSetInvisible		; $4ad9


; Zol has been attacked, spawn gels after [counter2] frames
_zol_subid01_stateD:
	call _ecom_decCounter2		; $4adc
	ret nz			; $4adf

	ld c,$04		; $4ae0
	call _zol_spawnGel		; $4ae2
	ld c,-$04		; $4ae5
	call _zol_spawnGel		; $4ae7

	call decNumEnemies		; $4aea
	jp enemyDelete		; $4aed

;;
; @param	c	X offset
; @addr{4af0}
_zol_spawnGel:
	ld b,ENEMYID_GEL		; $4af0
	call _ecom_spawnEnemyWithSubid01		; $4af2
	ret nz			; $4af5

	ld (hl),a ; [child.subid] = 0
	ld b,$00		; $4af7
	call objectCopyPositionWithOffset		; $4af9

	xor a			; $4afc
	ld l,Enemy.z		; $4afd
	ldi (hl),a		; $4aff
	ld (hl),a		; $4b00

	; Transfer "enemy index" to gel
	ld l,Enemy.enabled		; $4b01
	ld e,l			; $4b03
	ld a,(de)		; $4b04
	ld (hl),a		; $4b05
	ret			; $4b06


; ==============================================================================
; ENEMYID_FLOORMASTER
;
; Variables for subids other than 0:
;   relatedObj1: Reference to spawner object (subid 0)
;   var30: Animation index
;   var31: Index for z-position to use while chasing Link (0-7)
;   var32: Angle relative to Link where floormaster should spawn
;
; Variables for spawner (subid 0):
;   var30: Number of floormaster currently spawned (they delete themselves after
;          disappearing into the ground)
;   var31/var32: Link's position last time a floormaster was spawned. If Link hasn't moved
;                far from here, the floormaster will spawn at a random angle relative to
;                him; otherwise it will spawn in the direction Link is moving.
;   var33: # floormasters to spawn. Children decrement this when they're killed.
;          (High nibble of original Y value.)
;   var34: Subid for child objects (high nibble of original X value, plus one)
; ==============================================================================
enemyCode35:
	jr z,@normalStatus	; $4b07
	sub ENEMYSTATUS_NO_HEALTH			; $4b09
	ret c			; $4b0b
	jr z,@dead	; $4b0c
	dec a			; $4b0e
	jp nz,_ecom_updateKnockbackNoSolidity		; $4b0f

	; ENEMYSTATUS_JUST_HIT

	ld e,Enemy.var2a		; $4b12
	ld a,(de)		; $4b14
	cp $80|ITEMCOLLISION_LINK			; $4b15
	ret nz			; $4b17

	; Grabbed Link
	ld h,d			; $4b18
	ld l,Enemy.state		; $4b19
	ld (hl),$0c		; $4b1b
	ld l,Enemy.zh		; $4b1d
	ld (hl),$fb		; $4b1f

	call _floormaster_updateAngleTowardLink		; $4b21
	add $04			; $4b24
	call enemySetAnimation		; $4b26

	; Move to halfway point between Link and floormaster
	ld h,d			; $4b29
	ld l,Enemy.yh		; $4b2a
	ld a,(w1Link.yh)		; $4b2c
	sub (hl)		; $4b2f
	sra a			; $4b30
	add (hl)		; $4b32
	ld (hl),a		; $4b33

	ld l,Enemy.xh		; $4b34
	ld a,(w1Link.xh)		; $4b36
	sub (hl)		; $4b39
	sra a			; $4b3a
	add (hl)		; $4b3c
	ld (hl),a		; $4b3d
	ret			; $4b3e

@dead:
	ld a,Object.var30		; $4b3f
	call objectGetRelatedObject1Var		; $4b41
	dec (hl)		; $4b44
	ld l,Enemy.var33		; $4b45
	dec (hl)		; $4b47
	jp enemyDie_uncounted		; $4b48

@normalStatus:
	ld e,Enemy.state		; $4b4b
	ld a,(de)		; $4b4d
	rst_jumpTable			; $4b4e
	.dw _floormaster_state_uninitialized
	.dw _floormaster_state1
	.dw _floormaster_state_stub
	.dw _floormaster_state_stub
	.dw _floormaster_state_stub
	.dw _floormaster_state_galeSeed
	.dw _floormaster_state_stub
	.dw _floormaster_state_stub
	.dw _floormaster_state8
	.dw _floormaster_state9
	.dw _floormaster_stateA
	.dw _floormaster_stateB
	.dw _floormaster_stateC
	.dw _floormaster_stateD


_floormaster_state_uninitialized:
	ld h,d			; $4b6b
	ld l,Enemy.counter1		; $4b6c
	ld (hl),60		; $4b6e
	ld l,e			; $4b70
	inc (hl) ; [state] = 1

	ld e,Enemy.subid		; $4b72
	ld a,(de)		; $4b74
	or a			; $4b75
	jp z,_floormaster_initSpawner		; $4b76

	; Subid 1 only
	ld (hl),$08 ; [state] = 8
	ret			; $4b7b


; State 1: only for subid 0 (spawner).
_floormaster_state1:
	; Delete self if all floormasters were killed
	ld h,d			; $4b7c
	ld l,Enemy.var33		; $4b7d
	ld a,(hl)		; $4b7f
	or a			; $4b80
	jr z,@delete	; $4b81

	; Return if all available floormasters have spawned already
	ld e,Enemy.var30		; $4b83
	ld a,(de)		; $4b85
	sub (hl)		; $4b86
	ret nc			; $4b87

	; Spawn another floormaster in [counter1] frames
	ld l,Enemy.counter1		; $4b88
	dec (hl)		; $4b8a
	ret nz			; $4b8b

	ld (hl),$01 ; [counter1]

	; Maximum of 3 on-screen at any given time
	ld l,Enemy.var30		; $4b8e
	ld a,(hl)		; $4b90
	cp $03			; $4b91
	ret nc			; $4b93

	ld b,ENEMYID_FLOORMASTER		; $4b94
	call _ecom_spawnUncountedEnemyWithSubid01		; $4b96
	ret nz			; $4b99

	ld e,Enemy.var34		; $4b9a
	ld a,(de)		; $4b9c
	ld (hl),a ; [child.subid] = [this.var34]

	ld l,Enemy.relatedObj1		; $4b9e
	ld a,Enemy.start		; $4ba0
	ldi (hl),a		; $4ba2
	ld (hl),d		; $4ba3

	ld h,d			; $4ba4
	ld l,Enemy.var30		; $4ba5
	inc (hl)		; $4ba7

	ld l,Enemy.counter1		; $4ba8
	ld (hl),$80		; $4baa
	ret			; $4bac

@delete:
	call decNumEnemies		; $4bad
	call markEnemyAsKilledInRoom		; $4bb0
	jp enemyDelete		; $4bb3


_floormaster_state_galeSeed:
	call _ecom_galeSeedEffect		; $4bb6
	ret c			; $4bb9

	ld a,Object.var30		; $4bba
	call objectGetRelatedObject1Var		; $4bbc
	dec (hl)		; $4bbf
	ld l,Enemy.var33		; $4bc0
	dec (hl)		; $4bc2
	jp enemyDelete		; $4bc3


_floormaster_state_stub:
	ret			; $4bc6


; States 8+ are for subids 1+ (not spawner objects; actual, physical floormasters).

; Choosing a position to spawn at.
_floormaster_state8:
	; If Link is within 8 pixels of his position last time a floormaster was spawned,
	; the floormaster will spawn at a random angle relative to Link. Otherwise, it
	; will spawn in the direction Link is moving.
	call _floormaster_checkLinkMoved8PixelsAway		; $4bc7
	ld a,$00		; $4bca
	push bc			; $4bcc
	call c,getRandomNumber_noPreserveVars		; $4bcd
	pop bc			; $4bd0

	ld e,a			; $4bd1
	ld a,(w1Link.angle)		; $4bd2
	add e			; $4bd5
	and $1f			; $4bd6
	ld e,Enemy.var32		; $4bd8
	ld (de),a		; $4bda

	; Try various distances away from Link ($50 to $10)
	ld a,$50		; $4bdb
	ldh (<hFF8A),a	; $4bdd

@tryDistance:
	ldh a,(<hFF8A)	; $4bdf
	sub $10			; $4be1
	jr z,@doneLoop	; $4be3
	ldh (<hFF8A),a	; $4be5

	push bc			; $4be7
	ld e,Enemy.var32		; $4be8
	call objectSetPositionInCircleArc		; $4bea
	pop bc			; $4bed

	; Check that this position candidate is valid.

	; a = abs([w1Link.xh] - [this.xh])
	ld a,(de)		; $4bee
	ld e,a			; $4bef
	ld a,(w1Link.xh)		; $4bf0
	sub e			; $4bf3
	jr nc,+			; $4bf4
	cpl			; $4bf6
	inc a			; $4bf7
+
	cp $80			; $4bf8
	jr nc,@tryDistance	; $4bfa

	ld e,Enemy.yh		; $4bfc
	ld a,(de)		; $4bfe
	cp LARGE_ROOM_HEIGHT<<4			; $4bff
	jr nc,@tryDistance	; $4c01

	; Tile must not be solid
	push bc			; $4c03
	call objectGetTileCollisions		; $4c04
	pop bc			; $4c07
	jr nz,@tryDistance	; $4c08

	; Found a valid position. Go to state 9
	ld h,d			; $4c0a
	ld l,Enemy.state		; $4c0b
	ld (hl),$09		; $4c0d

	ld l,Enemy.counter1		; $4c0f
	ld (hl),$20		; $4c11

	call objectGetAngleTowardEnemyTarget		; $4c13
	ld b,a			; $4c16

	; Subid 1 only: angle must be a cardinal direction
	ld e,Enemy.subid		; $4c17
	ld a,(de)		; $4c19
	dec a			; $4c1a
	ld a,b			; $4c1b
	jr nz,+			; $4c1c
	add $04			; $4c1e
	and $18			; $4c20
+
	ld e,Enemy.angle		; $4c22
	ld (de),a		; $4c24

	; Decide animation to use
	cp $10			; $4c25
	ld a,$00		; $4c27
	jr nc,+			; $4c29
	inc a			; $4c2b
+
	ld e,Enemy.var30		; $4c2c
	ld (de),a		; $4c2e
	call enemySetAnimation		; $4c2f
	call objectSetVisiblec1		; $4c32

@doneLoop:
	; Copy Link's position to spawner.var31/var32
	ld e,Enemy.relatedObj1+1		; $4c35
	ld a,(de)		; $4c37
	ld h,a			; $4c38
	ld l,Enemy.var31		; $4c39
	ld a,(w1Link.yh)		; $4c3b
	ldi (hl),a		; $4c3e
	ld a,(w1Link.xh)		; $4c3f
	ld (hl),a		; $4c42
	ret			; $4c43


; Emerging from ground
_floormaster_state9:
	ld e,Enemy.animParameter		; $4c44
	ld a,(de)		; $4c46
	dec a			; $4c47
	jp nz,enemyAnimate		; $4c48

	ld e,Enemy.state		; $4c4b
	ld a,$0a		; $4c4d
	ld (de),a		; $4c4f

	ld e,Enemy.var30		; $4c50
	ld a,(de)		; $4c52
	add $02			; $4c53
	jp enemySetAnimation		; $4c55


; Floating in place for [counter1] frames before chasing Link
_floormaster_stateA:
	call _ecom_decCounter1		; $4c58
	jr z,@beginChasing	; $4c5b

	ld a,(hl)		; $4c5d
	srl a			; $4c5e
	srl a			; $4c60
	ld hl,@zVals		; $4c62
	rst_addAToHl			; $4c65
	ld a,(hl)		; $4c66
	ld e,Enemy.zh		; $4c67
	ld (de),a		; $4c69
	ret			; $4c6a

@beginChasing:
	ld (hl),$f0 ; [counter1]

	ld l,Enemy.collisionType		; $4c6d
	set 7,(hl)		; $4c6f

	ld l,Enemy.state		; $4c71
	ld (hl),$0b		; $4c73

	call _floormaster_updateAngleTowardLink		; $4c75
	ld b,a			; $4c78

	ld e,Enemy.relatedObj1+1		; $4c79
	ld a,(de)		; $4c7b
	ld h,a			; $4c7c
	ld l,Enemy.xh		; $4c7d
	bit 5,(hl)		; $4c7f

	; Certain subids have higher speed?
	ld h,d			; $4c81
	ld l,Enemy.speed		; $4c82
	ld (hl),SPEED_60		; $4c84
	jr z,+			; $4c86
	ld (hl),SPEED_a0		; $4c88
+
	ld a,b			; $4c8a
	add $02			; $4c8b
	call enemySetAnimation		; $4c8d
	jr _floormaster_animate		; $4c90

@zVals:
	.db $fb $fc $fd $fd $fe $fe $ff $ff


; Chasing Link
_floormaster_stateB:
	call _ecom_decCounter1		; $4c9a
	jr nz,@stillChasing	; $4c9d

	; Time to go back into ground
	ld l,Enemy.zh		; $4c9f
	ld (hl),$00		; $4ca1
	ld l,Enemy.collisionType		; $4ca3
	res 7,(hl)		; $4ca5

	ld l,e			; $4ca7
	ld (hl),$0d ; [state]

	ld l,Enemy.var30		; $4caa
	ld a,$06		; $4cac
	add (hl)		; $4cae
	jp enemySetAnimation		; $4caf

@stillChasing:
	ld e,Enemy.var30		; $4cb2
	ld a,(de)		; $4cb4
	ldh (<hFF8D),a	; $4cb5

	call _floormaster_updateAngleTowardLink		; $4cb7
	ld b,a			; $4cba
	ldh a,(<hFF8D)	; $4cbb
	cp b			; $4cbd
	jr z,++			; $4cbe
	ld a,$02		; $4cc0
	add b			; $4cc2
	call enemySetAnimation		; $4cc3
++
	call _floormaster_updateZPosition		; $4cc6
	call _floormaster_getAdjacentWallsBitset		; $4cc9
	call _ecom_applyVelocityGivenAdjacentWalls		; $4ccc

_floormaster_animate:
	jp enemyAnimate		; $4ccf


; Grabbing Link
_floormaster_stateC:
	ld e,Enemy.animParameter		; $4cd2
	ld a,(de)		; $4cd4
	dec a			; $4cd5
	jr z,@makeLinkInvisible	; $4cd6
	dec a			; $4cd8
	jr z,@setZToZero	; $4cd9
	dec a			; $4cdb
	jr nz,_floormaster_animate	; $4cdc

	; [animParameter] == 3
	; Set state2 for LINK_STATE_GRABBED_BY_WALLMASTER
	ld a,$02		; $4cde
	ld (w1Link.state2),a		; $4ce0
	jp objectSetInvisible		; $4ce3

@makeLinkInvisible: ; [animParameter] == 1
	ld (de),a		; $4ce6
	ld (w1Link.visible),a		; $4ce7

	ld e,Enemy.yh		; $4cea
	ld a,(w1Link.yh)		; $4cec
	ld (de),a		; $4cef
	ld e,Enemy.xh		; $4cf0
	ld a,(w1Link.xh)		; $4cf2
	ld (de),a		; $4cf5
	ret			; $4cf6

@setZToZero: ; [animParameter] == 2
	xor a			; $4cf7
	ld (de),a		; $4cf8
	ld e,Enemy.zh		; $4cf9
	ld (de),a		; $4cfb
	jr _floormaster_animate		; $4cfc


; Sinking into ground
_floormaster_stateD:
	ld e,Enemy.animParameter		; $4cfe
	ld a,(de)		; $4d00
	cp $03			; $4d01
	jr nz,_floormaster_animate	; $4d03

	; Tell spawner that there's one less floormaster on-screen before deleting self
	ld e,Enemy.relatedObj1+1		; $4d05
	ld a,(de)		; $4d07
	ld h,a			; $4d08
	ld l,Enemy.var30		; $4d09
	dec (hl)		; $4d0b

	jp enemyDelete		; $4d0c


;;
; @param[out]	a	Value written to var30 (0 if Link is to the left, 1 if right)
; @addr{4d0f}
_floormaster_updateAngleTowardLink:
	call @checkLinkCollisionsEnabled		; $4d0f
	ret nc			; $4d12

	call objectGetAngleTowardLink		; $4d13
	ld b,a			; $4d16
	and $0f			; $4d17
	jr nz,++		; $4d19

	; Link is directly above or below the floormaster
	ld e,Enemy.angle		; $4d1b
	ld a,b			; $4d1d
	ld (de),a		; $4d1e
	ld e,Enemy.var30		; $4d1f
	ld a,(de)		; $4d21
	ret			; $4d22
++
	ld e,Enemy.subid		; $4d23
	ld a,(de)		; $4d25
	dec a			; $4d26
	ld a,b			; $4d27
	jr nz,@subid0		; $4d28

@subid1:
	; Only move in cardinal directions
	ld e,Enemy.angle		; $4d2a
	and $f8			; $4d2c
	ld (de),a		; $4d2e

	cp $10			; $4d2f
	ld a,$00		; $4d31
	jr nc,+			; $4d33
	inc a			; $4d35
+
	ld e,Enemy.var30		; $4d36
	ld (de),a		; $4d38
	ret			; $4d39

@subid0:
	ld e,Enemy.angle		; $4d3a
	ld (de),a		; $4d3c

	cp $10			; $4d3d
	ld a,$00		; $4d3f
	jr nc,+			; $4d41
	inc a			; $4d43
+
	ld e,Enemy.var30		; $4d44
	ld (de),a		; $4d46
	ret			; $4d47

;;
; @param[out]	cflag	c if Link's collisions are enabled
; @addr{4d48}
@checkLinkCollisionsEnabled:
	ld a,(w1Link.collisionType)		; $4d48
	rlca			; $4d4b
	ret c			; $4d4c
	ld e,Enemy.var30		; $4d4d
	ld a,(de)		; $4d4f
	ret			; $4d50


;;
; @addr{4d51}
_floormaster_updateZPosition:
	ld e,Enemy.counter1		; $4d51
	ld a,(de)		; $4d53
	and $07			; $4d54
	ret nz			; $4d56

	ld e,Enemy.var31		; $4d57
	ld a,(de)		; $4d59
	inc a			; $4d5a
	and $07			; $4d5b
	ld (de),a		; $4d5d
	ld hl,@zVals		; $4d5e
	rst_addAToHl			; $4d61
	ld e,Enemy.zh		; $4d62
	ld a,(hl)		; $4d64
	ld (de),a		; $4d65
	ret			; $4d66

@zVals:
	.db $fb $fc $fd $fc $fb $fa $f9 $fa



;;
; Checks whether Link has moved 8 pixels away from his position last time a floormaster
; was spawned.
;
; @param[out]	bc	Link's position
; @param[out]	cflag	c if he's within 8 pixels
; @addr{4d6f}
_floormaster_checkLinkMoved8PixelsAway:
	ld a,Object.var31		; $4d6f
	call objectGetRelatedObject1Var		; $4d71
	ld a,(w1Link.yh)		; $4d74
	ld b,a			; $4d77
	sub (hl)		; $4d78
	add $08			; $4d79
	cp $10			; $4d7b
	ld a,(w1Link.xh)		; $4d7d
	ld c,a			; $4d80
	ret nc			; $4d81

	inc l			; $4d82
	sub (hl) ; [var32]
	add $08			; $4d84
	cp $10			; $4d86
	ret			; $4d88


;;
; @addr{4d89}
_floormaster_initSpawner:
	ld e,Enemy.yh		; $4d89
	ld a,(de)		; $4d8b
	and $f0			; $4d8c
	swap a			; $4d8e
	ld e,Enemy.var33		; $4d90
	ld (de),a		; $4d92

	ld e,Enemy.xh		; $4d93
	ld a,(de)		; $4d95
	and $f0			; $4d96
	swap a			; $4d98
	inc a			; $4d9a
	ld e,Enemy.var34		; $4d9b
	ld (de),a		; $4d9d
	ret			; $4d9e

;;
; Only screen boundaries count as "walls" for floormaster.
; @addr{4d9f}
_floormaster_getAdjacentWallsBitset:
	ld a,$02		; $4d9f
	jp _ecom_getTopDownAdjacentWallsBitset		; $4da1


; ==============================================================================
; ENEMYID_CUCCO
;
; Shares some code with ENEMYID_GIANT_CUCCO.
;
; Variables:
;   relatedObj1: INTERACID_PUFF object when transforming
;   var30: Number of times it's been hit (also read by PARTID_CUCCO_ATTACKER to decide
;          speed)
;   var31: Enemy ID to transform into, when a mystery seed is used on it
;   var32: Counter used while being held
;   var33: Counter until next PARTID_CUCCO_ATTACKER is spawned
; ==============================================================================
enemyCode36:
	jr z,@normalStatus	; $4da4

	ld h,d			; $4da6
	ld l,Enemy.var2a		; $4da7
	ld a,(hl)		; $4da9
	cp $80|ITEMCOLLISION_MYSTERY_SEED			; $4daa
	jp z,_cucco_hitWithMysterySeed		; $4dac

	cp $80|ITEMCOLLISION_GALE_SEED			; $4daf
	jp nz,_cucco_attacked		; $4db1

@normalStatus:
	call _cucco_checkSpawnCuccoAttacker		; $4db4
	ld e,Enemy.state		; $4db7
	ld a,(de)		; $4db9
	rst_jumpTable			; $4dba
	.dw _cucco_state_uninitialized
	.dw _cucco_state_stub
	.dw _cucco_state_grabbed
	.dw _cucco_state_stub
	.dw _cucco_state_stub
	.dw _ecom_blownByGaleSeedState
	.dw _cucco_state_stub
	.dw _cucco_state_stub
	.dw _cucco_state8
	.dw _cucco_state9
	.dw _cucco_stateA
	.dw _cucco_stateB


_cucco_state_uninitialized:
	ld a,SPEED_80		; $4dd3
	call _ecom_setSpeedAndState8AndVisible		; $4dd5

	ld l,Enemy.var3f		; $4dd8
	set 5,(hl)		; $4dda
	ret			; $4ddc


; Also used by ENEMYID_GIANT_CUCCO
_cucco_state_grabbed:
	inc e			; $4ddd
	ld a,(de)		; $4dde
	rst_jumpTable			; $4ddf
	.dw @justGrabbed
	.dw @holding
	.dw @checkOutOfScreenBounds
	.dw @landed

@justGrabbed:
	ld h,d			; $4de8
	ld l,e			; $4de9
	inc (hl) ; [state]

	ld l,Enemy.collisionType		; $4deb
	res 7,(hl)		; $4ded
	ld l,Enemy.var32		; $4def
	xor a			; $4df1
	ld (hl),a		; $4df2
	ld (wLinkGrabState2),a		; $4df3

	ld a,(w1Link.direction)		; $4df6
	srl a			; $4df9
	xor $01			; $4dfb
	ld l,Enemy.direction		; $4dfd
	ld (hl),a		; $4dff
	call enemySetAnimation		; $4e00

	ld a,SND_CHICKEN		; $4e03
	call playSound		; $4e05
	jp objectSetVisiblec1		; $4e08

@holding:
	call _cucco_playChickenSoundEvery32Frames		; $4e0b
	ld h,d			; $4e0e
	ld l,Enemy.direction		; $4e0f
	ld a,(w1Link.direction)		; $4e11
	srl a			; $4e14
	xor $01			; $4e16
	cp (hl)			; $4e18
	jr z,@checkOutOfScreenBounds	; $4e19
	ld (hl),a		; $4e1b
	jp enemySetAnimation		; $4e1c

@checkOutOfScreenBounds:
	ld e,Enemy.yh		; $4e1f
	ld a,(de)		; $4e21
	cp SMALL_ROOM_HEIGHT<<4			; $4e22
	jr nc,++		; $4e24
	ld e,Enemy.xh		; $4e26
	ld a,(de)		; $4e28
	cp SMALL_ROOM_WIDTH<<4			; $4e29
	jp c,enemyAnimate		; $4e2b
++
	jp enemyDelete		; $4e2e

@landed:
	ld h,d			; $4e31
	ld l,Enemy.state		; $4e32
	ld (hl),$0a		; $4e34

	ld l,Enemy.collisionType		; $4e36
	set 7,(hl)		; $4e38

	ld l,Enemy.speed		; $4e3a
	ld (hl),SPEED_100		; $4e3c

	ld l,Enemy.counter1		; $4e3e
	ld (hl),$01		; $4e40
	jp objectSetVisiblec2		; $4e42


_cucco_state_stub:
	ret			; $4e45


; Standing still.
; Also used by ENEMYID_GIANT_CUCCO.
_cucco_state8:
	call objectAddToGrabbableObjectBuffer		; $4e46

	ld e,$3f		; $4e49
	ld bc,$031f		; $4e4b
	call _ecom_randomBitwiseAndBCE		; $4e4e
	or e			; $4e51
	ret nz ; 63 in 64 chance of returning

	call _ecom_incState		; $4e53

	ld l,Enemy.counter1		; $4e56
	ldi (hl),a ; [counter1] = 0

	ld a,$02		; $4e59
	add b			; $4e5b
	ld (hl),a ; [counter2] = random value between 2-6 (number of hops)

	ld l,Enemy.angle		; $4e5d
	ld a,c			; $4e5f
	ld (hl),a		; $4e60
	jp _cucco_setAnimationFromAngle		; $4e61


; Moving in some direction until [counter2] == 0.
; Also used by ENEMYID_GIANT_CUCCO.
_cucco_state9:
	call objectAddToGrabbableObjectBuffer		; $4e64
	ld h,d			; $4e67
	ld l,Enemy.counter1		; $4e68
	ld a,(hl)		; $4e6a
	and $0f			; $4e6b
	inc (hl)		; $4e6d

	ld hl,_cucco_zVals		; $4e6e
	rst_addAToHl			; $4e71
	ld e,Enemy.zh		; $4e72
	ld a,(hl)		; $4e74
	ld (de),a		; $4e75
	or a			; $4e76
	jr nz,++		; $4e77

	; Just finished a hop
	call _ecom_decCounter2		; $4e79
	jr nz,++		; $4e7c

	; Stop moving
	ld l,Enemy.state		; $4e7e
	dec (hl)		; $4e80
++
	call _ecom_bounceOffWallsAndHoles		; $4e81
	call nz,_cucco_setAnimationFromAngle		; $4e84
	call objectApplySpeed		; $4e87
_cucco_animate:
	jp enemyAnimate		; $4e8a


; Just landed after being thrown. Run away from Link indefinitely.
_cucco_stateA:
	call objectAddToGrabbableObjectBuffer		; $4e8d
	call _ecom_updateCardinalAngleAwayFromTarget		; $4e90
	call _cucco_setAnimationFromAngle		; $4e93
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $4e96
	jr _cucco_animate		; $4e99


; In the process of transforming (into ENEMYID_BABY_CUCCO or ENEMYID_GIANT_CUCCO, based on
; var31)
_cucco_stateB:
	ld a,Object.animParameter		; $4e9b
	call objectGetRelatedObject1Var		; $4e9d
	bit 7,(hl)		; $4ea0
	ret z			; $4ea2

	ld e,Enemy.var31		; $4ea3
	ld a,(de)		; $4ea5
	ld b,a			; $4ea6
	ld c,$00		; $4ea7
	jp objectReplaceWithID		; $4ea9


; ==============================================================================
; ENEMYID_GIANT_CUCCO
;
; Variables are the same as ENEMYID_CUCCO.
; ==============================================================================
enemyCode3b:
	jr z,@normalStatus	; $4eac
	sub ENEMYSTATUS_NO_HEALTH			; $4eae
	ret c			; $4eb0

	ld e,Enemy.var2a		; $4eb1
	ld a,(de)		; $4eb3
	res 7,a			; $4eb4

	; Check if hit by anything other than Link or shield.
	cp ITEMCOLLISION_L1_SWORD			; $4eb6
	jr c,@normalStatus	; $4eb8

	ld h,d			; $4eba
	ld l,Enemy.var30		; $4ebb
	inc (hl)		; $4ebd

	; NOTE: The cucco starts with 0 health. It's constantly reset to $40 here. This
	; isn't a problem in Seasons, but in Ages this seems to trigger a bug causing its
	; collisions to get disabled. See enemyTypes.s for details.
	ld l,Enemy.health		; $4ebe
	ld (hl),$40		; $4ec0

	ld l,Enemy.state		; $4ec2
	ld a,(hl)		; $4ec4
	cp $0a			; $4ec5
	jr nc,@normalStatus	; $4ec7
	ld (hl),$0a		; $4ec9
	ld l,Enemy.zh		; $4ecb
	ld (hl),$00		; $4ecd

@normalStatus:
	ld e,Enemy.state		; $4ecf
	ld a,(de)		; $4ed1
	rst_jumpTable			; $4ed2
	.dw _giantCucco_state_uninitialized
	.dw _cucco_state_stub
	.dw _cucco_state_grabbed
	.dw _cucco_state_stub
	.dw _cucco_state_stub
	.dw _cucco_state_stub
	.dw _cucco_state_stub
	.dw _cucco_state_stub
	.dw _cucco_state8 ; States 8 and 9 same as normal cucco (wandering around)
	.dw _cucco_state9
	.dw _giantCucco_stateA
	.dw _giantCucco_stateB


_giantCucco_state_uninitialized:
	ld a,SPEED_c0		; $4eeb
	call _ecom_setSpeedAndState8		; $4eed
	ld a,$30		; $4ef0
	call setScreenShakeCounter		; $4ef2
	jp objectSetVisiblec1		; $4ef5


; Hit with anything other than Link or shield
_giantCucco_stateA:
	ld e,Enemy.var30		; $4ef8
	ld a,(de)		; $4efa
	cp $08			; $4efb
	jr c,@runAway	; $4efd

	; Hit at least 8 times
	call _ecom_incState		; $4eff

	ld l,Enemy.var32		; $4f02
	ld (hl),$00		; $4f04

	ld a,SND_TELEPORT		; $4f06
	jp playSound		; $4f08

@runAway:
	call _ecom_updateCardinalAngleAwayFromTarget		; $4f0b
	call _cucco_setAnimationFromAngle		; $4f0e
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $4f11
	jr _giantCucco_animate		; $4f14


; Charging toward Link after being hit 8 times
_giantCucco_stateB:
	call objectGetAngleTowardEnemyTarget		; $4f16
	call objectNudgeAngleTowards		; $4f19
	call _cucco_setAnimationFromAngle		; $4f1c
	call objectApplySpeed		; $4f1f

_giantCucco_animate:
	jp enemyAnimate		; $4f22


;;
; @addr{4f25}
_cucco_setAnimationFromAngle:
	ld h,d			; $4f25
	ld l,Enemy.angle		; $4f26
	ld a,(hl)		; $4f28
	and $0f			; $4f29
	ret z			; $4f2b

	ldd a,(hl)		; $4f2c
	and $10			; $4f2d
	swap a			; $4f2f
	xor $01			; $4f31
	cp (hl) ; hl == direction
	ret z			; $4f34
	ld (hl),a		; $4f35
	jp enemySetAnimation		; $4f36


_cucco_zVals:
	.db $00 $ff $ff $fe $fe $fe $fd $fd
	.db $fd $fd $fe $fe $fe $ff $ff $00


;;
; @addr{4f49}
_cucco_checkSpawnCuccoAttacker:
	ld h,d			; $4f49
	ld l,Enemy.var33		; $4f4a
	ld a,(hl)		; $4f4c
	or a			; $4f4d
	jr z,+			; $4f4e
	dec (hl)		; $4f50
	ret nz			; $4f51
+
	; Must have been hit at least 16 times
	ld l,Enemy.var30		; $4f52
	ld a,(hl)		; $4f54
	cp $10			; $4f55
	ret c			; $4f57

	ld b,PARTID_CUCCO_ATTACKER		; $4f58
	call _ecom_spawnProjectile		; $4f5a

	ld e,Enemy.var30		; $4f5d
	ld a,(de)		; $4f5f
	sub $10			; $4f60
	and $1e			; $4f62
	rrca			; $4f64
	ld hl,@var33Vals		; $4f65
	rst_addAToHl			; $4f68
	ld e,Enemy.var33		; $4f69
	ld a,(hl)		; $4f6b
	ld (de),a		; $4f6c
	ret			; $4f6d

@var33Vals:
	.db $1e $1a $18 $16 $14 $12 $10 $0e
	.db $0c


_cucco_attacked:
	ld l,Enemy.health		; $4f77
	ld (hl),$40		; $4f79

	ld l,Enemy.state		; $4f7b
	ld a,$0a		; $4f7d
	cp (hl)			; $4f7f
	jr z,++			; $4f80

	; Just starting to run away
	ld (hl),a		; $4f82
	ld l,Enemy.speed		; $4f83
	ld (hl),SPEED_100		; $4f85
	ld l,Enemy.zh		; $4f87
	ld (hl),$00		; $4f89
++
	ld e,Enemy.var2a		; $4f8b
	ld a,(de)		; $4f8d
	rlca			; $4f8e
	ret nc			; $4f8f

	; Increment number of times hit
	ld l,Enemy.var30		; $4f90
	bit 5,(hl)		; $4f92
	jr nz,+			; $4f94
	inc (hl)		; $4f96
+
	ld a,SND_CHICKEN		; $4f97
	jp playSound		; $4f99


;;
; Cucco will transform into ENEMYID_BABY_CUCCO (if not aggressive) or ENEMYID_GIANT_CUCCO
; (if aggressive).
; @addr{4f9c}
_cucco_hitWithMysterySeed:
	ld l,Enemy.collisionType		; $4f9c
	res 7,(hl)		; $4f9e

	; Check if the cucco been hit 16 or more times
	ld l,Enemy.var30		; $4fa0
	ld a,(hl)		; $4fa2
	cp $10			; $4fa3
	jr c,+			; $4fa5
	ld a,ENEMYID_GIANT_CUCCO		; $4fa7
	jr ++			; $4fa9
+
	ld a,ENEMYID_BABY_CUCCO		; $4fab
++
	ld e,Enemy.var31		; $4fad
	ld (de),a		; $4faf

	ldbc INTERACID_PUFF,$02		; $4fb0
	call objectCreateInteraction		; $4fb3
	ret nz			; $4fb6

	ld e,Enemy.relatedObj1		; $4fb7
	ld a,Interaction.start		; $4fb9
	ld (de),a		; $4fbb
	inc e			; $4fbc
	ld a,h			; $4fbd
	ld (de),a		; $4fbe

	ld e,Enemy.state		; $4fbf
	ld a,$0b		; $4fc1
	ld (de),a		; $4fc3

	jp objectSetInvisible		; $4fc4


;;
; @addr{4fc7}
_cucco_playChickenSoundEvery32Frames:
	ld h,d			; $4fc7
	ld l,Enemy.invincibilityCounter		; $4fc8
	ld a,(hl)		; $4fca
	or a			; $4fcb
	ret nz			; $4fcc

	ld l,Enemy.var32		; $4fcd
	dec (hl)		; $4fcf
	ld a,(hl)		; $4fd0
	and $1f			; $4fd1
	ret nz			; $4fd3
	ld a,SND_CHICKEN		; $4fd4
	jp playSound		; $4fd6


; ==============================================================================
; ENEMYID_BUTTERFLY
; ==============================================================================
enemyCode37:
	ld e,Enemy.state		; $4fd9
	ld a,(de)		; $4fdb
	rst_jumpTable			; $4fdc
	.dw @state0
	.dw @state1

@state0:
	ld h,d			; $4fe1
	ld l,e			; $4fe2
	inc (hl) ; [state]

	ld l,Enemy.speed		; $4fe4
	ld (hl),SPEED_40		; $4fe6
	call _ecom_setRandomAngle		; $4fe8

	jp objectSetVisible81		; $4feb

@state1:
	ld bc,$1f1f		; $4fee
	call _ecom_randomBitwiseAndBCE		; $4ff1
	or b			; $4ff4
	jr nz,++		; $4ff5
	ld h,d			; $4ff7
	ld l,Enemy.angle		; $4ff8
	ld (hl),c		; $4ffa
++
	call objectApplySpeed		; $4ffb
	call _ecom_bounceOffScreenBoundary		; $4ffe
	jp enemyAnimate		; $5001


; ==============================================================================
; ENEMYID_GREAT_FAIRY
;
; Variables:
;   relatedObj2: Reference to INTERACID_PUFF
;   var30: Counter used to update Z-position as she floats up and down
;   var31: Number of hearts spawned (the ones that circle around Link)
; ==============================================================================
enemyCode38:
	ld e,Enemy.state		; $5004
	ld a,(de)		; $5006
	rst_jumpTable			; $5007
	.dw _greatFairy_state_uninitialized
	.dw _greatFairy_state1
	.dw _greatFairy_state2
	.dw _greatFairy_state3
	.dw _greatFairy_state4
	.dw _greatFairy_state5
	.dw _greatFairy_state6
	.dw _greatFairy_state7
	.dw _greatFairy_state8
	.dw _greatFairy_state9


_greatFairy_state_uninitialized:
	ld h,d			; $501c
	ld l,e			; $501d
	inc (hl) ; [state]
	ld l,Enemy.zh		; $501f
	ld (hl),$f0		; $5021
	ret			; $5023


; Create puff
_greatFairy_state1:
	call _greatFairy_createPuff		; $5024
	ret nz			; $5027

	ld l,Enemy.state		; $5028
	inc (hl)		; $502a

	ld l,Enemy.counter1		; $502b
	ld (hl),$11		; $502d
	ld a,MUS_FAIRY		; $502f
	ld (wActiveMusic),a		; $5031
	ret			; $5034


; Waiting for puff to disappear
_greatFairy_state2:
	ld a,Object.animParameter		; $5035
	call objectGetRelatedObject2Var		; $5037
	bit 7,(hl)		; $503a
	ret z			; $503c

	call _ecom_incState		; $503d


; Waiting for Link to approach
_greatFairy_state3:
	call _greatFairy_checkLinkApproached		; $5040
	jr nc,_greatFairy_animate	; $5043

	ld a,$80		; $5045
	ld (wMenuDisabled),a		; $5047

	ld a,DISABLE_COMPANION|DISABLE_LINK		; $504a
	ld (wDisabledObjects),a		; $504c

	ld hl,wLinkHealth		; $504f
	ldi a,(hl)		; $5052
	cp (hl)			; $5053
	ld a,$04		; $5054
	ld bc,TX_4100		; $5056
	jr nz,++		; $5059

	; Full health already
	ld e,Enemy.counter1		; $505b
	ld a,30		; $505d
	ld (de),a		; $505f
	ld a,$08		; $5060
	ld bc,TX_4105		; $5062
++
	ld e,Enemy.state		; $5065
	ld (de),a		; $5067
	call showText		; $5068

_greatFairy_animate:
	call _greatFairy_updateZPosition		; $506b
	call enemyAnimate		; $506e
	ld e,Enemy.yh		; $5071
	ld a,(de)		; $5073
	ld b,a			; $5074
	ldh a,(<hEnemyTargetY)	; $5075
	cp b			; $5077
	jp c,objectSetVisiblec1		; $5078
	jp objectSetVisiblec2		; $507b


; Begin healing Link
_greatFairy_state4:
	ld h,d			; $507e
	ld l,e			; $507f
	inc (hl) ; [state]

	ld l,Enemy.counter1		; $5081
	ld (hl),$0c		; $5083
	inc l			; $5085
	ld (hl),$09 ; [counter2]


; Spawning hearts
_greatFairy_state5:
	call _greatFairy_playSoundEvery8Frames		; $5088
	call _ecom_decCounter1		; $508b
	jr nz,_greatFairy_animate	; $508e

	ld (hl),$0c ; [counter1]
	inc l			; $5092
	dec (hl) ; [counter2]
	jr z,@spawnedAllHearts			; $5094
	call _greatFairy_spawnCirclingHeart		; $5096
	jr _greatFairy_animate		; $5099

@spawnedAllHearts:
	dec l			; $509b
	ld (hl),30 ; [counter1]

	ld l,Enemy.state		; $509e
	inc (hl)		; $50a0
	jr _greatFairy_animate		; $50a1


; Hearts have all spawned, are now circling around Link
_greatFairy_state6:
	call _greatFairy_playSoundEvery8Frames		; $50a3
	call _ecom_decCounter1		; $50a6
	jr nz,_greatFairy_animate	; $50a9
	ld l,Enemy.state		; $50ab
	inc (hl)		; $50ad
	ld a,TREASURE_HEART_REFILL		; $50ae
	ld c,MAX_LINK_HEALTH		; $50b0
	call giveTreasure		; $50b2


; Waiting for all hearts to disappear
_greatFairy_state7:
	call _greatFairy_playSoundEvery8Frames		; $50b5
	ld e,Enemy.var31		; $50b8
	ld a,(de)		; $50ba
	or a			; $50bb
	jr nz,_greatFairy_animate	; $50bc

	call _ecom_incState		; $50be
	ld l,Enemy.counter1		; $50c1
	ld (hl),30		; $50c3


; About to disappear; staying in place for 30 frames
_greatFairy_state8:
	call _ecom_decCounter1		; $50c5
	jr nz,_greatFairy_animate	; $50c8

	ld (hl),60 ; [counter1]
	ld l,e			; $50cc
	inc (hl) ; [state]

	xor a			; $50ce
	ld (wDisabledObjects),a		; $50cf
	ld (wMenuDisabled),a		; $50d2

	ld a,SND_FAIRYCUTSCENE		; $50d5
	call playSound		; $50d7


; Disappearing
_greatFairy_state9:
	call _ecom_decCounter1		; $50da
	jp z,enemyDelete		; $50dd

	call _greatFairy_animate		; $50e0

	; Flicker visibility
	ld h,d			; $50e3
	ld l,Enemy.counter1		; $50e4
	bit 0,(hl)		; $50e6
	ret nz			; $50e8
	ld l,Enemy.visible		; $50e9
	res 7,(hl)		; $50eb
	ret			; $50ed


;;
; @addr{50ee}
_greatFairy_updateZPosition:
	ld h,d			; $50ee
	ld l,Enemy.var30		; $50ef
	dec (hl)		; $50f1
	ld a,(hl)		; $50f2
	and $07			; $50f3
	ret nz			; $50f5

	ld a,(hl)		; $50f6
	and $18			; $50f7
	swap a			; $50f9
	rlca			; $50fb
	sub $02			; $50fc
	bit 5,(hl)		; $50fe
	jr nz,++		; $5100
	cpl			; $5102
	inc a			; $5103
++
	sub $10			; $5104
	ld l,Enemy.zh		; $5106
	ld (hl),a		; $5108
	ret			; $5109


;;
; @param[out]	cflag	c if Link approached
; @addr{510a}
_greatFairy_checkLinkApproached:
	call checkLinkVulnerable		; $510a
	ret nc			; $510d

	ld h,d			; $510e
	ld l,Enemy.yh		; $510f
	ldh a,(<hEnemyTargetY)	; $5111
	sub (hl)		; $5113
	sub $10			; $5114
	cp $21			; $5116
	ret nc			; $5118

	ld l,Enemy.xh		; $5119
	ldh a,(<hEnemyTargetX)	; $511b
	sub (hl)		; $511d
	add $18			; $511e
	cp $31			; $5120
	ret			; $5122

;;
; @addr{5123}
_greatFairy_spawnCirclingHeart:
	call getFreePartSlot		; $5123
	ret nz			; $5126

	ld (hl),PARTID_GREAT_FAIRY_HEART		; $5127
	ld l,Part.relatedObj1		; $5129
	ld a,Enemy.start		; $512b
	ldi (hl),a		; $512d
	ld (hl),d		; $512e

	ld h,d			; $512f
	ld l,Enemy.var31		; $5130
	inc (hl)		; $5132
	ret			; $5133


;;
; @addr{5134}
_greatFairy_createPuff:
	ldbc INTERACID_PUFF,$02		; $5134
	call objectCreateInteraction		; $5137
	ret nz			; $513a

	ld a,h			; $513b
	ld h,d			; $513c
	ld l,Enemy.relatedObj2+1		; $513d
	ldd (hl),a		; $513f
	ld (hl),Interaction.start		; $5140
	xor a			; $5142
	ret			; $5143

;;
; @addr{5144}
_greatFairy_playSoundEvery8Frames:
	ld a,(wFrameCounter)		; $5144
	and $07			; $5147
	ret nz			; $5149
	ld a,SND_UNKNOWN7		; $514a
	jp playSound		; $514c


; ==============================================================================
; ENEMYID_FIRE_KEESE
;
; Variables:
;   var30: Distance away (in tiles) closest lit torch is
;   var31/var32: Position of lit torch it's moving towards to re-light itself
;   var33: Nonzero if fire has been shed (set to 2). Doubles as animation index?
;   var34: Position at which to search for a lit torch ($16 tiles are checked each frame,
;          so this gets incremented by $16 each frame)
;   var35: Angular rotation for subid 0. (set to -1 or 1 randomly on initialization, for
;          counterclockwise or clockwise movement)
; ==============================================================================
enemyCode39:
	jr z,@normalStatus	; $514f
	sub ENEMYSTATUS_NO_HEALTH			; $5151
	ret c			; $5153
	jp z,enemyDie		; $5154
	dec a			; $5157
	jp nz,_ecom_updateKnockbackNoSolidity		; $5158

	; ENEMYSTATUS_JUST_HIT
	ld e,Enemy.var2a		; $515b
	ld a,(de)		; $515d
	cp $80|ITEMCOLLISION_LINK			; $515e
	ret nz			; $5160

	; We collided with Link; if still on fire, transfer that fire to the ground.
	ld e,Enemy.var33		; $5161
	ld a,(de)		; $5163
	or a			; $5164
	ret nz			; $5165

	ld b,PARTID_FIRE		; $5166
	call _ecom_spawnProjectile		; $5168

	ld h,d			; $516b
	ld l,Enemy.oamFlags		; $516c
	ld a,$01		; $516e
	ldd (hl),a		; $5170
	ld (hl),a		; $5171

	ld l,Enemy.state		; $5172
	ld (hl),$08		; $5174

	ld l,Enemy.damage		; $5176
	ld (hl),-$04		; $5178

	ld l,Enemy.var33		; $517a
	ld (hl),$02		; $517c

	ld l,Enemy.speed		; $517e
	ld (hl),SPEED_c0		; $5180

	ld a,$03		; $5182
	jp enemySetAnimation		; $5184

@normalStatus:
	call _ecom_getSubidAndCpStateTo08		; $5187
	cp $0b			; $518a
	jr nc,_fireKeese_stateBOrHigher	; $518c
	rst_jumpTable			; $518e
	.dw _fireKeese_state_uninitialized
	.dw _fireKeese_state_stub
	.dw _fireKeese_state_stub
	.dw _fireKeese_state_stub
	.dw _fireKeese_state_stub
	.dw _ecom_blownByGaleSeedState
	.dw _fireKeese_state_stub
	.dw _fireKeese_state_stub
	.dw _fireKeese_state8
	.dw _fireKeese_state9
	.dw _fireKeese_stateA

_fireKeese_stateBOrHigher:
	ld a,b			; $51a5
	rst_jumpTable			; $51a6
	.dw _fireKeese_subid0
	.dw _fireKeese_subid1


_fireKeese_state_uninitialized:
	ld h,d			; $51ab
	ld l,Enemy.counter1		; $51ac
	ld (hl),$08		; $51ae

	ld l,Enemy.damage		; $51b0
	ld (hl),-$08		; $51b2

	bit 0,b			; $51b4
	ld l,e			; $51b6
	jr z,@subid0	; $51b7

@subid1:
	ld (hl),$0b ; [state]
	jp objectSetVisible82		; $51bb

@subid0:
	ld (hl),$0b ; [state]

	ld l,Enemy.zh		; $51c0
	ld (hl),-$1c		; $51c2

	ld l,Enemy.speed		; $51c4
	ld (hl),SPEED_80		; $51c6

	; Random angle
	ld bc,$1f01		; $51c8
	call _ecom_randomBitwiseAndBCE		; $51cb
	ld e,Enemy.angle		; $51ce
	ld a,b			; $51d0
	ld (de),a		; $51d1

	; Set var35 to 1 or -1 for clockwise or counterclockwise movement.
	ld a,c			; $51d2
	or a			; $51d3
	jr nz,+			; $51d4
	dec a			; $51d6
+
	ld e,Enemy.var35		; $51d7
	ld (de),a		; $51d9

	ld a,$01		; $51da
	call enemySetAnimation		; $51dc
	jp objectSetVisiblec1		; $51df


_fireKeese_state_stub:
	ret			; $51e2


; Just lost fire; looks for a torch if one exists, otherwise it will keep flying around
; like normal.
_fireKeese_state8:
	; Initialize "infinite" distance away from closest lit torch (none found yet)
	ld e,Enemy.var30		; $51e3
	ld a,$ff		; $51e5
	ld (de),a		; $51e7

	; Check all tiles in the room, try to find a lit torch to light self back on fire
	call objectGetTileAtPosition		; $51e8
	ld c,l			; $51eb
	ld l,$00		; $51ec
@nextTile:
	ld a,(hl)		; $51ee
	cp TILEINDEX_LIT_TORCH			; $51ef
	call z,_fireKeese_addCandidateTorch		; $51f1
	inc l			; $51f4
	ld a,l			; $51f5
	cp LARGE_ROOM_HEIGHT<<4			; $51f6
	jr c,@nextTile	; $51f8

	; Check if one was found
	ld e,Enemy.var30		; $51fa
	ld a,(de)		; $51fc
	inc a			; $51fd
	ld h,d			; $51fe
	jr nz,@torchFound	; $51ff

	; No torch found. Go back to doing subid-specific movement.

	ld l,Enemy.subid		; $5201
	bit 0,(hl)		; $5203
	ld a,$0d		; $5205
	jr z,++			; $5207

	; Subid 1
	ld l,Enemy.counter1		; $5209
	ld (hl),120		; $520b
	ld a,$0c		; $520d
++
	ld l,Enemy.state		; $520f
	ld (hl),a		; $5211
	ret			; $5212

@torchFound:
	ld l,Enemy.state		; $5213
	inc (hl)		; $5215
	ld l,Enemy.speed		; $5216
	ld (hl),SPEED_c0		; $5218
	ld a,$03		; $521a
	jp enemySetAnimation		; $521c


; Moving towards a torch's position, marked in var31/var32
_fireKeese_state9:
	ld h,d			; $521f
	ld l,Enemy.var31		; $5220
	call _ecom_readPositionVars		; $5222
	cp c			; $5225
	jr nz,@notAtTargetPosition		; $5226

	ldh a,(<hFF8F)	; $5228
	cp b			; $522a
	jr z,@atTargetPosition	; $522b

@notAtTargetPosition:
	call _fireKeese_moveToGround		; $522d
	call _ecom_moveTowardPosition		; $5230
	jp enemyAnimate		; $5233

@atTargetPosition:
	call _fireKeese_moveToGround		; $5236
	ret c			; $5239

	ld l,Enemy.state		; $523a
	inc (hl)		; $523c

	ld l,Enemy.counter1		; $523d
	ld (hl),60		; $523f

	ld a,$02		; $5241
	jp enemySetAnimation		; $5243


; Touched down on the torch; in the process of being lit back on fire
_fireKeese_stateA:
	call _ecom_decCounter1		; $5246
	jr z,@gotoNextState	; $5249

	ld a,(hl) ; [counter1]
	sub 30			; $524c
	ret nz			; $524e

	; [counter1] == 30
	ld l,Enemy.oamFlags		; $524f
	ld a,$05		; $5251
	ldd (hl),a		; $5253
	ld (hl),a		; $5254

	ld l,Enemy.damage		; $5255
	ld (hl),-$08		; $5257
	ld l,Enemy.var33		; $5259
	xor a			; $525b
	ld (hl),a		; $525c
	jp enemySetAnimation		; $525d

@gotoNextState:
	ld l,Enemy.angle		; $5260
	ld a,(hl)		; $5262
	add $10			; $5263
	and $1f			; $5265
	ld (hl),a		; $5267

	ld l,Enemy.subid		; $5268
	bit 0,(hl)		; $526a
	ld a,$0d		; $526c
	jr z,++			; $526e

	; Subid 1
	ld l,Enemy.counter1		; $5270
	ld (hl),120		; $5272
	ld a,$0c		; $5274
++
	ld (de),a		; $5276
	ld a,$01		; $5277
	jp enemySetAnimation		; $5279


; Keese which move up and down on Z axis
_fireKeese_subid0:
	call _fireKeese_checkForNewlyLitTorch		; $527c
	; Above function call may pop its return address, ignore everything below here

	ld e,Enemy.state		; $527f
	ld a,(de)		; $5281
	sub $0b			; $5282
	rst_jumpTable			; $5284
	.dw _fireKeese_subid0_stateB
	.dw _fireKeese_subid0_stateC
	.dw _fireKeese_subid0_stateD


; Flying around on fire
_fireKeese_subid0_stateB:
	call _fireKeese_checkCloseToLink		; $528b
	jr nc,@linkNotClose	; $528e

	; Link is close
	ld l,Enemy.state		; $5290
	inc (hl)		; $5292
	ld l,Enemy.counter1		; $5293
	ld (hl),91		; $5295
	ld l,Enemy.speed		; $5297
	ld (hl),SPEED_a0		; $5299

@linkNotClose:
	call _ecom_decCounter1		; $529b
	jr nz,++		; $529e

	ld (hl),$08 ; [counter1]

	; Move clockwise or counterclockwise (var35 is randomly set to 1 or -1 on
	; initialization)
	ld e,Enemy.var35		; $52a2
	ld a,(de)		; $52a4
	ld l,Enemy.angle		; $52a5
	add (hl)		; $52a7
	and $1f			; $52a8
	ld (hl),a		; $52aa
++
	call objectApplySpeed		; $52ab
	call _fireKeese_moveTowardCenterIfOutOfBounds		; $52ae
	jr _fireKeese_animate		; $52b1


; Divebombing because Link got close enough
_fireKeese_subid0_stateC:
	call _ecom_decCounter1		; $52b3
	jr nz,++		; $52b6
	ld l,Enemy.state		; $52b8
	inc (hl)		; $52ba
	jr _fireKeese_animate		; $52bb
++
	; Add some amount to Z-position
	ld a,(hl)		; $52bd
	and $f0			; $52be
	swap a			; $52c0
	ld hl,_fireKeese_subid0_zOffsets		; $52c2
	rst_addAToHl			; $52c5

	ld e,Enemy.z		; $52c6
	ld a,(de)		; $52c8
	add (hl)		; $52c9
	ld (de),a		; $52ca
	inc e			; $52cb
	ld a,(de)		; $52cc
	adc $00			; $52cd
	ld (de),a		; $52cf

	; Adjust angle toward Link
	call objectGetAngleTowardEnemyTarget		; $52d0
	ld b,a			; $52d3
	ld e,Enemy.counter1		; $52d4
	ld a,(de)		; $52d6
	and $03			; $52d7
	ld a,b			; $52d9
	call z,objectNudgeAngleTowards		; $52da

_fireKeese_updatePosition:
	call _ecom_bounceOffScreenBoundary		; $52dd
	call objectApplySpeed		; $52e0

_fireKeese_animate:
	jp enemyAnimate		; $52e3


; Moving back up after divebombing
_fireKeese_subid0_stateD:
	ld h,d			; $52e6
	ld l,Enemy.z		; $52e7
	ld a,(hl)		; $52e9
	sub <($0040)			; $52ea
	ldi (hl),a		; $52ec
	ld a,(hl)		; $52ed
	sbc >($0040)			; $52ee
	ld (hl),a		; $52f0

	cp $e4			; $52f1
	jr nc,_fireKeese_updatePosition	; $52f3

	ld l,e			; $52f5
	ld (hl),$0b ; [state]

	ld l,Enemy.speed		; $52f8
	ld (hl),SPEED_80		; $52fa

	ld l,Enemy.counter1		; $52fc
	ld (hl),$08		; $52fe
	jr _fireKeese_animate		; $5300


; Keese which has no Z-axis movement
_fireKeese_subid1:
	call _fireKeese_checkForNewlyLitTorch		; $5302
	; Above function call may pop its return address, ignore everything below here

	ld e,Enemy.state		; $5305
	ld a,(de)		; $5307
	sub $0b			; $5308
	rst_jumpTable			; $530a
	.dw _fireKeese_subid1_stateB
	.dw _fireKeese_subid1_stateC
	.dw _fireKeese_subid1_stateD


; Waiting [counter1] frames (8 frames) before moving
_fireKeese_subid1_stateB:
	call _ecom_decCounter1		; $5311
	ret nz			; $5314

	ld l,e			; $5315
	inc (hl) ; [state]

	ld l,Enemy.speed		; $5317
	ld (hl),SPEED_c0		; $5319

	; Random angle
	ld bc,$1f3f		; $531b
	call _ecom_randomBitwiseAndBCE		; $531e
	ld e,Enemy.angle		; $5321
	ld a,b			; $5323
	ld (de),a		; $5324

	; Random counter1 between $c0-$ff
	ld a,$c0		; $5325
	add c			; $5327
	ld e,Enemy.counter1		; $5328
	ld (de),a		; $532a

	; Set animation based on if on fire
	ld e,Enemy.var33		; $532b
	ld a,(de)		; $532d
	inc a			; $532e
	call enemySetAnimation		; $532f

	; Create fire when initially spawning
	ld e,Enemy.var33		; $5332
	ld a,(de)		; $5334
	or a			; $5335
	ld b,PARTID_FIRE		; $5336
	call z,_ecom_spawnProjectile		; $5338
	jp enemyAnimate		; $533b


; Moving around randomly for [counter1]*2 frames
_fireKeese_subid1_stateC:
	call _fireKeese_updatePosition		; $533e

	ld a,(wFrameCounter)		; $5341
	and $01			; $5344
	ret nz			; $5346

	call _ecom_decCounter1		; $5347
	jr z,@gotoNextState	; $534a

	; 1 in 16 chance of changing angle (every 2 frames)
	ld bc,$0f1f		; $534c
	call _ecom_randomBitwiseAndBCE		; $534f
	or b			; $5352
	ret nz			; $5353
	ld e,Enemy.angle		; $5354
	ld a,c			; $5356
	ld (de),a		; $5357
	ret			; $5358

@gotoNextState:
	ld l,Enemy.state		; $5359
	inc (hl)		; $535b
	ret			; $535c


; Slowing down, then stopping for a brief period
_fireKeese_subid1_stateD:
	ld e,Enemy.counter1		; $535d
	ld a,(de)		; $535f
	cp $68			; $5360
	jr nc,++		; $5362

	call _ecom_bounceOffScreenBoundary		; $5364
	call objectApplySpeed		; $5367
++
	call _fireKeese_subid1_setSpeedAndAnimateBasedOnCounter1		; $536a

	ld h,d			; $536d
	ld l,Enemy.counter1		; $536e
	inc (hl)		; $5370
	ld a,$7f		; $5371
	cp (hl)			; $5373
	ret nz			; $5374

	; Time to start moving again; go back to state $0b where we'll abruptly go fast.
	ld l,Enemy.state		; $5375
	ld (hl),$0b		; $5377

	ld e,Enemy.var33		; $5379
	ld a,(de)		; $537b
	call enemySetAnimation		; $537c

	; Set counter1 to random value from $20-$9f
	call getRandomNumber_noPreserveVars		; $537f
	and $7f			; $5382
	ld e,Enemy.counter1		; $5384
	add $20			; $5386
	ld (de),a		; $5388
	ret			; $5389


;;
; Subid 1 slows down gradually in state $0d.
; @addr{538a}
_fireKeese_subid1_setSpeedAndAnimateBasedOnCounter1:
	ld e,Enemy.counter1		; $538a
	ld a,(de)		; $538c
	and $0f			; $538d
	jr nz,++		; $538f

	; Set speed based on value of counter1
	ld a,(de)		; $5391
	swap a			; $5392
	ld hl,_fireKeese_subid1_speeds		; $5394
	rst_addAToHl			; $5397
	ld e,Enemy.speed		; $5398
	ld a,(hl)		; $539a
	ld (de),a		; $539b
++
	; Animate at some rate based on value of counter1
	ld e,Enemy.counter1		; $539c
	ld a,(de)		; $539e
	and $f0			; $539f
	swap a			; $53a1
	ld hl,_fireKeese_subid1_animFrequencies		; $53a3
	rst_addAToHl			; $53a6
	ld a,(wFrameCounter)		; $53a7
	and (hl)		; $53aa
	jp z,enemyAnimate		; $53ab
	ret			; $53ae


;;
; @param[out]	cflag	c if Link is within 32 pixels of keese in each direction
; @addr{53af}
_fireKeese_checkCloseToLink:
	ld h,d			; $53af
	ld l,Enemy.yh		; $53b0
	ldh a,(<hEnemyTargetY)	; $53b2
	sub (hl)		; $53b4
	add $20			; $53b5
	cp $41			; $53b7
	ret nc			; $53b9
	ld l,Enemy.xh		; $53ba
	ldh a,(<hEnemyTargetX)	; $53bc
	sub (hl)		; $53be
	add $20			; $53bf
	cp $41			; $53c1
	ret			; $53c3


;;
; Given the position of a torch, checks whether to update "position of closest known
; torch" (var31/var32).
;
; @param	c	Position of lit torch
; @addr{53c4}
_fireKeese_addCandidateTorch:
	; Get Y distance
	ld a,c			; $53c4
	and $f0			; $53c5
	swap a			; $53c7
	ld b,a			; $53c9
	ld a,l			; $53ca
	and $f0			; $53cb
	swap a			; $53cd
	sub b			; $53cf
	jr nc,+			; $53d0
	cpl			; $53d2
	inc a			; $53d3
+
	ld b,a			; $53d4

	; Get X distance
	ld a,c			; $53d5
	and $0f			; $53d6
	ld e,a			; $53d8
	ld a,l			; $53d9
	and $0f			; $53da
	sub e			; $53dc
	jr nc,+			; $53dd
	cpl			; $53df
	inc a			; $53e0
+
	; Compare with closest candidate, return if farther away
	add b			; $53e1
	ld b,a			; $53e2
	ld e,Enemy.var30		; $53e3
	ld a,(de)		; $53e5
	cp b			; $53e6
	ret c			; $53e7

	; This is the closest torch found so far.
	ld a,b			; $53e8
	ld (de),a		; $53e9

	; Mark its position in var31/var32
	ld e,Enemy.var31		; $53ea
	ld a,l			; $53ec
	and $f0			; $53ed
	add $08			; $53ef
	ld (de),a		; $53f1
	inc e			; $53f2
	ld a,l			; $53f3
	and $0f			; $53f4
	swap a			; $53f6
	add $08			; $53f8
	ld (de),a		; $53fa
	ret			; $53fb


;;
; While the keese is not lit on fire, this function checks if any new lit torches suddenly
; appear in the room. If so, it sets the state to 8 and returns from the caller (discards
; return address).
; @addr{53fc}
_fireKeese_checkForNewlyLitTorch:
	; Return if on fire already
	ld e,Enemy.var33		; $53fc
	ld a,(de)		; $53fe
	or a			; $53ff
	ret z			; $5400

	; Check $16 tiles per frame, searching for a torch. (Searching all of them could
	; cause lag, especially with a lot of bats on-screen.)
	ld e,Enemy.var34		; $5401
	ld a,(de)		; $5403
	ld l,a			; $5404
	ld h,>wRoomLayout		; $5405
	ld b,$16		; $5407
@loop:
	ldi a,(hl)		; $5409
	cp TILEINDEX_LIT_TORCH			; $540a
	jr z,@foundTorch	; $540c
	dec b			; $540e
	jr nz,@loop	; $540f

	ld a,l			; $5411
	cp LARGE_ROOM_HEIGHT<<4			; $5412
	jr nz,+			; $5414
	xor a			; $5416
+
	ld (de),a		; $5417
	ret			; $5418

@foundTorch:
	pop hl ; Return from caller

	ld h,d			; $541a
	ld l,e			; $541b
	ld (hl),$00 ; [var34]

	; State 8 will cause the bat to move toward the torch.
	; (var31/var32 are not set here because the search will be done again in state 8.)
	ld l,Enemy.state		; $541e
	ld (hl),$08		; $5420

	ld l,Enemy.speed		; $5422
	ld (hl),SPEED_c0		; $5424
	ret			; $5426

;;
; @param[out]	cflag	nc if reached ground (or at most 6 units away)
; @addr{5427}
_fireKeese_moveToGround:
	ld e,Enemy.zh		; $5427
	ld a,(de)		; $5429
	or a			; $542a
	ret z			; $542b

	cp $fa			; $542c
	ret nc			; $542e

	; [Enemy.z] += $0080
	dec e			; $542f
	ld a,(de)		; $5430
	add <($0080)			; $5431
	ld (de),a		; $5433
	inc e			; $5434
	ld a,(de)		; $5435
	adc >($0080)			; $5436
	ld (de),a		; $5438
	scf			; $5439
	ret			; $543a


;;
; @addr{543b}
_fireKeese_moveTowardCenterIfOutOfBounds:
	ld e,Enemy.yh		; $543b
	ld a,(de)		; $543d
	cp LARGE_ROOM_HEIGHT<<4			; $543e
	jr nc,@outOfBounds		; $5440

	ld e,Enemy.xh		; $5442
	ld a,(de)		; $5444
	cp $f0			; $5445
	ret c			; $5447

@outOfBounds:
	ld e,Enemy.yh		; $5448
	ld a,(de)		; $544a
	ldh (<hFF8F),a	; $544b
	ld e,Enemy.xh		; $544d
	ld a,(de)		; $544f
	ldh (<hFF8E),a	; $5450

	ldbc (LARGE_ROOM_HEIGHT/2)<<4 + 8, (LARGE_ROOM_WIDTH/2)<<4 + 8		; $5452
	call objectGetRelativeAngleWithTempVars		; $5455
	ld c,a			; $5458
	ld b,SPEED_100		; $5459
	ld e,Enemy.angle		; $545b
	jp objectApplyGivenSpeed		; $545d


; Offsets for Z position, in subpixels.
_fireKeese_subid0_zOffsets:
	.db $80 $60 $40 $30 $20 $20

; Speed values for subid 1, where it gradually slows down.
_fireKeese_subid1_speeds:
	.db SPEED_c0 SPEED_80 SPEED_40 SPEED_40
	.db SPEED_20 SPEED_20 SPEED_20 SPEED_20

_fireKeese_subid1_animFrequencies:
	.db $00 $00 $01 $01 $03 $03 $07 $00


; ==============================================================================
; ENEMYID_WATER_TEKTITE
; ==============================================================================
enemyCode3a:
	jr z,@normalStatus	; $5476
	sub ENEMYSTATUS_NO_HEALTH			; $5478
	ret c			; $547a
	jp z,enemyDie		; $547b
	dec a			; $547e
	ret z			; $547f

	; ENEMYSTATUS_KNOCKBACK
	; Need special knockback code for special "solidity" properties (water is
	; traversible, everything else is solid)
	ld e,Enemy.speed		; $5480
	ld a,(de)		; $5482
	push af			; $5483
	ld a,SPEED_200		; $5484
	ld (de),a		; $5486
	ld e,Enemy.knockbackAngle		; $5487
	call _waterTektite_getAdjacentWallsBitsetGivenAngle		; $5489
	ld e,Enemy.knockbackAngle		; $548c
	call _ecom_applyVelocityGivenAdjacentWalls		; $548e

	pop af			; $5491
	ld e,Enemy.speed		; $5492
	ld (de),a		; $5494
	ret			; $5495

@normalStatus:
	ld e,Enemy.state		; $5496
	ld a,(de)		; $5498
	rst_jumpTable			; $5499
	.dw _waterTektite_state_uninitialized
	.dw _waterTektike_state_stub
	.dw _waterTektike_state_stub
	.dw _waterTektike_state_stub
	.dw _waterTektike_state_stub
	.dw _ecom_blownByGaleSeedState
	.dw _waterTektike_state_stub
	.dw _waterTektike_state_stub
	.dw _waterTektike_state8
	.dw _waterTektike_state9


_waterTektite_state_uninitialized:
	call objectSetVisible82		; $54ae

_waterTektike_decideNewAngle:
	ld h,d			; $54b1
	ld l,Enemy.state		; $54b2
	ld (hl),$08		; $54b4

	ld l,Enemy.counter1		; $54b6
	ld (hl),$40		; $54b8

	ld a,(wScentSeedActive)		; $54ba
	or a			; $54bd
	jr nz,@scentSeedActive	; $54be

	; Random diagonal angle
	call getRandomNumber_noPreserveVars		; $54c0
	and $18			; $54c3
	add $04			; $54c5
	ld e,Enemy.angle		; $54c7
	ld (de),a		; $54c9
	jr _waterTektike_animate		; $54ca

@scentSeedActive:
	ldh a,(<hFFB2)	; $54cc
	ldh (<hFF8F),a	; $54ce
	ldh a,(<hFFB3)	; $54d0
	ldh (<hFF8E),a	; $54d2
	ld l,Enemy.yh		; $54d4
	ldi a,(hl)		; $54d6
	ld b,a			; $54d7
	inc l			; $54d8
	ld c,(hl)		; $54d9
	call objectGetRelativeAngleWithTempVars		; $54da
	ld e,Enemy.angle		; $54dd
	ld (de),a		; $54df
	jr _waterTektike_animate		; $54e0


_waterTektike_state_stub:
	ret			; $54e2


; Moving in some direction for [counter1] frames, at varying speeds.
_waterTektike_state8:
	call _ecom_decCounter1		; $54e3
	jr nz,++		; $54e6

	ld l,e			; $54e8
	inc (hl) ; [state]

	ld l,Enemy.counter1		; $54ea
	ld (hl),$08		; $54ec
	jr _waterTektike_animate		; $54ee
++
	call _waterTektike_setSpeedFromCounter1		; $54f0

	call _waterTektite_getAdjacentWallsBitset		; $54f3
	ld e,Enemy.angle		; $54f6
	call _ecom_applyVelocityGivenAdjacentWalls		; $54f8
	call _ecom_bounceOffScreenBoundary		; $54fb

_waterTektike_animate:
	jp enemyAnimate		; $54fe



; Not moving for [counter1] frames; then choosing new angle
_waterTektike_state9:
	call _ecom_decCounter1		; $5501
	jr nz,_waterTektike_animate	; $5504
	jr _waterTektike_decideNewAngle		; $5506

;;
; Gets the "adjacent walls bitset" for the tektike; since this swims, water is
; traversable, everything else is not.
;
; This is identical to "_fish_getAdjacentWallsBitsetForKnockback".
;
; @addr{5508}
_waterTektite_getAdjacentWallsBitset:
	ld e,Enemy.angle		; $5508

;;
; @param	de	Angle variable
; @addr{550a}
_waterTektite_getAdjacentWallsBitsetGivenAngle:
	ld a,(de)		; $550a
	call _ecom_getAdjacentWallTableOffset		; $550b

	ld h,d			; $550e
	ld l,Enemy.yh		; $550f
	ld b,(hl)		; $5511
	ld l,Enemy.xh		; $5512
	ld c,(hl)		; $5514
	ld hl,_ecom_sideviewAdjacentWallOffsetTable		; $5515
	rst_addAToHl			; $5518

	ld a,$10		; $5519
	ldh (<hFF8B),a	; $551b
	ld d,>wRoomLayout		; $551d
@nextOffset:
	ldi a,(hl)		; $551f
	add b			; $5520
	ld b,a			; $5521
	and $f0			; $5522
	ld e,a			; $5524
	ldi a,(hl)		; $5525
	add c			; $5526
	ld c,a			; $5527
	and $f0			; $5528
	swap a			; $552a
	or e			; $552c
	ld e,a			; $552d
	ld a,(de)		; $552e
	sub TILEINDEX_PUDDLE			; $552f
	cp TILEINDEX_FD-TILEINDEX_PUDDLE+1			; $5531
	ldh a,(<hFF8B)	; $5533
	rla			; $5535
	ldh (<hFF8B),a	; $5536
	jr nc,@nextOffset	; $5538

	xor $0f			; $553a
	ldh (<hFF8B),a	; $553c
	ldh a,(<hActiveObject)	; $553e
	ld d,a			; $5540
	ret			; $5541


;;
; @param	hl	Pointer to counter1
; @addr{5542}
_waterTektike_setSpeedFromCounter1:
	ld a,(hl)		; $5542
	srl a			; $5543
	srl a			; $5545
	ld hl,@speedVals		; $5547
	rst_addAToHl			; $554a
	ld e,Enemy.speed		; $554b
	ld a,(hl)		; $554d
	ld (de),a		; $554e
	ret			; $554f

@speedVals:
	.db SPEED_020 SPEED_040 SPEED_080 SPEED_0c0 SPEED_100 SPEED_140 SPEED_140 SPEED_140
	.db SPEED_100 SPEED_100 SPEED_0c0 SPEED_0c0 SPEED_080 SPEED_080 SPEED_040 SPEED_040


; ==============================================================================
; ENEMYID_SWORD_MOBLIN
; ENEMYID_SWORD_SHROUDED_STALFOS
; ENEMYID_SWORD_MASKED_MOBLIN
;
; Shares some code with ENEMYID_SWORD_DARKNUT.
;
; Variables:
;   var30: Nonzero if enemyCollisionMode was changed to ignore sword damage (due to the
;          enemy's sword blocking it)
; ==============================================================================
enemyCode3d:
enemyCode49:
enemyCode4a:
	call _ecom_checkHazards		; $5560
	call @runState		; $5563
	jp _swordEnemy_updateEnemyCollisionMode		; $5566

@runState:
	jr z,@normalStatus	; $5569
	sub ENEMYSTATUS_NO_HEALTH			; $556b
	ret c			; $556d
	jr z,@dead	; $556e
	dec a			; $5570
	jp nz,_ecom_updateKnockbackAndCheckHazards		; $5571
	ret			; $5574
@dead:
	pop hl			; $5575
	jp enemyDie		; $5576

@normalStatus:
	call _ecom_checkScentSeedActive		; $5579
	jr z,++			; $557c
	ld e,Enemy.speed		; $557e
	ld a,SPEED_a0		; $5580
	ld (de),a		; $5582
++
	ld e,Enemy.state		; $5583
	ld a,(de)		; $5585
	rst_jumpTable			; $5586
	.dw _swordEnemy_state_uninitialized
	.dw _swordEnemy_state_stub
	.dw _swordEnemy_state_stub
	.dw _swordEnemy_state_switchHook
	.dw _swordEnemy_state_scentSeed
	.dw _ecom_blownByGaleSeedState
	.dw _swordEnemy_state_stub
	.dw _swordEnemy_state_stub
	.dw _swordEnemy_state8
	.dw _swordEnemy_state9
	.dw _swordEnemy_stateA


_swordEnemy_state_uninitialized:
	ld b,PARTID_ENEMY_SWORD		; $559d
	call _ecom_spawnProjectile		; $559f
	ret nz			; $55a2

	call _ecom_setRandomCardinalAngle		; $55a3
	call _ecom_updateAnimationFromAngle		; $55a6

	ld a,SPEED_80		; $55a9
	call _ecom_setSpeedAndState8AndVisible		; $55ab

	ld l,Enemy.counter1		; $55ae
	inc (hl)		; $55b0

	; Enable scent seeds
	ld l,Enemy.var3f		; $55b1
	set 4,(hl)		; $55b3

	jp _swordEnemy_setChaseCooldown		; $55b5


_swordEnemy_state_switchHook:
	inc e			; $55b8
	ld a,(de)		; $55b9
	rst_jumpTable			; $55ba
	.dw _ecom_incState2
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate1:
@substate2:
	ret			; $55c3

@substate3:
	ld b,$09		; $55c4
	call _ecom_fallToGroundAndSetState		; $55c6
	ld l,Enemy.counter1		; $55c9
	ld (hl),$10		; $55cb
	ret			; $55cd


_swordEnemy_state_scentSeed:
	ld a,(wScentSeedActive)		; $55ce
	or a			; $55d1
	ld h,d			; $55d2
	jp z,_swordEnemy_gotoState8		; $55d3
	call _ecom_updateAngleToScentSeed		; $55d6
	call _ecom_updateAnimationFromAngle		; $55d9
	call _ecom_applyVelocityForSideviewEnemy		; $55dc
	call enemyAnimate		; $55df
	jr _swordEnemy_animate		; $55e2


_swordEnemy_state_stub:
	ret			; $55e4


; Moving slowly in cardinal directions until Link get close.
_swordEnemy_state8:
	call _swordEnemy_checkLinkIsClose		; $55e5
	jp c,_swordEnemy_beginChasingLink		; $55e8

	call _ecom_decCounter1		; $55eb
	jp z,_swordEnemy_chooseRandomAngleAndCounter1		; $55ee

	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $55f1
	jr nz,_swordEnemy_animate	; $55f4

	; Hit a wall
	call _ecom_bounceOffWallsAndHoles		; $55f6
	jp nz,_ecom_updateAnimationFromAngle		; $55f9

_swordEnemy_animate:
	jp enemyAnimate		; $55fc


; Started chasing Link (don't adjust angle until next state).
_swordEnemy_state9:
	call _ecom_decCounter1		; $55ff
	ret nz			; $5602
	ld (hl),$60		; $5603
	ld l,e			; $5605
	inc (hl) ; [state]
	ld l,Enemy.speed		; $5607
	ld (hl),SPEED_a0		; $5609
	ret			; $560b


; Chasing Link for [counter1] frames (adjusts angle appropriately).
_swordEnemy_stateA:
	call _ecom_decCounter1		; $560c
	jp z,_swordEnemy_gotoState8		; $560f

	ld a,(hl)		; $5612
	and $03			; $5613
	jr nz,++		; $5615
	call objectGetAngleTowardEnemyTarget		; $5617
	call objectNudgeAngleTowards		; $561a
	call _ecom_updateAnimationFromAngle		; $561d
++
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $5620

	; Animate at double speed
	call enemyAnimate		; $5623
	jr _swordEnemy_animate		; $5626


;;
; Reverts to state 8; wandering around in cardinal directions
; @addr{5628}
_swordEnemy_gotoState8:
	ld l,e			; $5628
	ld (hl),$08 ; [state]

	ld l,Enemy.speed		; $562b
	ld (hl),SPEED_80		; $562d
	ld l,Enemy.angle		; $562f
	ld a,(hl)		; $5631
	add $04			; $5632
	and $18			; $5634
	ld (hl),a		; $5636

	call _ecom_updateAnimationFromAngle		; $5637
	call _swordEnemy_setChaseCooldown		; $563a
	jr _swordEnemy_animate		; $563d


; ==============================================================================
; ENEMYID_SWORD_DARKNUT
; ==============================================================================
enemyCode48:
	call _ecom_checkHazards		; $563f
	call @runState		; $5642
	jp _swordDarknut_updateEnemyCollisionMode		; $5645

@runState:
	jr z,@normalStatus	; $5648
	sub ENEMYSTATUS_NO_HEALTH			; $564a
	ret c			; $564c
	jr z,@dead	; $564d
	dec a			; $564f
	call nz,_ecom_updateKnockbackAndCheckHazards		; $5650
	jp _swordDarknut_updateEnemyCollisionMode		; $5653

@dead:
	ld e,Enemy.subid		; $5656
	ld a,(de)		; $5658
	cp $02			; $5659
	jr nz,++		; $565b
	ld hl,wKilledGoldenEnemies		; $565d
	set 2,(hl)		; $5660
++
	pop hl			; $5662
	jp enemyDie		; $5663

@normalStatus:
	ld e,Enemy.state		; $5666
	ld a,(de)		; $5668
	rst_jumpTable			; $5669
	.dw _swordDarknut_state_uninitialized
	.dw _swordEnemy_state_stub
	.dw _swordEnemy_state_stub
	.dw _swordEnemy_state_switchHook
	.dw _swordEnemy_state_stub
	.dw _swordEnemy_state_stub
	.dw _swordEnemy_state_stub
	.dw _swordEnemy_state_stub
	.dw _swordDarknut_state8
	.dw _swordDarknut_state9
	.dw _swordDarknut_stateA


_swordDarknut_state_uninitialized:
	ld e,Enemy.subid		; $5680
	ld a,(de)		; $5682
	cp $02			; $5683
	jr nz,++		; $5685
	ld a,(wKilledGoldenEnemies)		; $5687
	bit 2,a			; $568a
	jp nz,_swordDarknut_delete		; $568c
++
	jp _swordEnemy_state_uninitialized		; $568f


; Moving slowly in cardinal directions until Link get close.
; Identical to _swordEnemy_state8.
_swordDarknut_state8:
	call _swordDarknut_checkLinkIsClose		; $5692
	jr c,_swordEnemy_beginChasingLink	; $5695

	call _ecom_decCounter1		; $5697
	jr z,_swordEnemy_chooseRandomAngleAndCounter1	; $569a

	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $569c
	jr nz,_swordDarknut_animate	; $569f

	; Hit a wall
	call _ecom_bounceOffWallsAndHoles		; $56a1
	jp nz,_ecom_updateAnimationFromAngle		; $56a4

_swordDarknut_animate:
	jp enemyAnimate		; $56a7


; Started chasing Link (don't adjust angle until next state).
; Identical to _swordEnemy_state9 except for the speed.
_swordDarknut_state9:
	call _ecom_decCounter1		; $56aa
	ret nz			; $56ad
	ld (hl),$60		; $56ae
	ld l,e			; $56b0
	inc (hl) ; [state]
	ld l,Enemy.speed		; $56b2
	ld (hl),SPEED_c0		; $56b4
	ret			; $56b6


; Chasing Link for [counter1] frames (adjusts angle appropriately).
; Identical to _swordEnemy_stateA except for how quickly it turns toward Link.
_swordDarknut_stateA:
	call _ecom_decCounter1		; $56b7
	jp z,_swordEnemy_gotoState8		; $56ba

	ld a,(hl)		; $56bd
	and $01			; $56be
	jr nz,++		; $56c0
	call objectGetAngleTowardEnemyTarget		; $56c2
	call objectNudgeAngleTowards		; $56c5
	call _ecom_updateAnimationFromAngle		; $56c8
++
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $56cb

	; Animate at double speed
	call enemyAnimate		; $56ce
	jr _swordDarknut_animate		; $56d1

;;
; @addr{56d3}
_swordEnemy_beginChasingLink:
	ld l,Enemy.state		; $56d3
	inc (hl)		; $56d5
	ld l,Enemy.counter1		; $56d6
	ld (hl),$10		; $56d8
	call _ecom_updateAngleTowardTarget		; $56da
	jp _ecom_updateAnimationFromAngle		; $56dd

;;
; @addr{56e0}
_swordEnemy_chooseRandomAngleAndCounter1:
	ld bc,$3f07		; $56e0
	call _ecom_randomBitwiseAndBCE		; $56e3
	ld e,Enemy.counter1		; $56e6
	ld a,$50		; $56e8
	add b			; $56ea
	ld (de),a		; $56eb

	call @chooseAngle		; $56ec
	jp _ecom_updateAnimationFromAngle		; $56ef

@chooseAngle:
	; 1 in 8 chance of moving toward Link
	ld a,c			; $56f2
	or a			; $56f3
	jp z,_ecom_updateCardinalAngleTowardTarget		; $56f4
	jp _ecom_setRandomCardinalAngle		; $56f7


;;
; @param[out]	cflag	c if Link is within 40 pixels of enemy in both directions (and
;			counter2, the timeout, has reached 0)
; @addr{56fa}
_swordEnemy_checkLinkIsClose:
	call _ecom_decCounter2		; $56fa
	ret nz			; $56fd

	; NOTE: Why does this use hFFB2, then hEnemyTargetX? It's mixing two position
	; variables.
	ld l,Enemy.yh		; $56fe
	ldh a,(<hFFB2)	; $5700
	sub (hl)		; $5702
	add $28			; $5703
	cp $51			; $5705
	ret nc			; $5707
	ld l,Enemy.xh		; $5708
	ldh a,(<hEnemyTargetX)	; $570a
	sub (hl)		; $570c
	add $28			; $570d
	cp $51			; $570f
	ret			; $5711

;;
; This is identical to the above function.
; @addr{5712}
_swordDarknut_checkLinkIsClose:
	call _ecom_decCounter2		; $5712
	ret nz			; $5715

	; NOTE: Why does this use hFFB2, then hEnemyTargetX? It's mixing two position
	; variables.
	ld l,Enemy.yh		; $5716
	ldh a,(<hFFB2)	; $5718
	sub (hl)		; $571a
	add $28			; $571b
	cp $51			; $571d
	ret nc			; $571f
	ld l,Enemy.xh		; $5720
	ldh a,(<hEnemyTargetX)	; $5722
	sub (hl)		; $5724
	add $28			; $5725
	cp $51			; $5727
	ret			; $5729


;;
; Sets counter2 to the number of frames to wait before chasing Link again. Higher subids
; have lower cooldowns.
; @addr{572a}
_swordEnemy_setChaseCooldown:
	ld e,Enemy.subid		; $572a
	ld a,(de)		; $572c
	ld bc,@counter2Vals		; $572d
	call addAToBc		; $5730
	ld e,Enemy.counter2		; $5733
	ld a,(bc)		; $5735
	ld (de),a		; $5736
	ret			; $5737

@counter2Vals:
	.db $14 $10 $0c


;;
; Updates enemyCollisionMode based on Link's angle relative to the enemy. In this way,
; Link's sword doesn't damage the enemy if positioned in such a way that their sword
; should block it.
; @addr{573b}
_swordEnemy_updateEnemyCollisionMode:
	ld b,$00		; $573b
	ld e,Enemy.stunCounter		; $573d
	ld a,(de)		; $573f
	or a			; $5740
	jr nz,++		; $5741

	call _swordEnemy_checkIgnoreCollision		; $5743
	ld a,ENEMYCOLLISION_STALFOS_BLOCKED_WITH_SWORD		; $5746
	ld b,$00		; $5748
	jr nz,@setVars	; $574a
++
	inc b			; $574c
	ld e,Enemy.id		; $574d
	ld a,(de)		; $574f
	cp ENEMYID_SWORD_SHROUDED_STALFOS			; $5750
	ld a,ENEMYCOLLISION_BURNABLE_ENEMY		; $5752
	jr nz,@setVars	; $5754
	ld a,ENEMYCOLLISION_BURNABLE_ENEMY		; $5756

@setVars:
	ld e,Enemy.enemyCollisionMode		; $5758
	ld (de),a		; $575a

	ld e,Enemy.var30		; $575b
	ld a,b			; $575d
	ld (de),a		; $575e
	ret			; $575f

;;
; Same as above, but with a different enemyCollisionMode for the darknut.
; @addr{5760}
_swordDarknut_updateEnemyCollisionMode:
	ld b,$00		; $5760
	ld e,Enemy.stunCounter		; $5762
	ld a,(de)		; $5764
	or a			; $5765
	jr nz,++		; $5766

	call _swordEnemy_checkIgnoreCollision		; $5768
	ld a,ENEMYCOLLISION_DARKNUT_BLOCKED_WITH_SWORD		; $576b
	ld b,$00		; $576d
	jr nz,@setVars	; $576f
++
	ld a,ENEMYCOLLISION_DARKNUT		; $5771
	inc b			; $5773

@setVars:
	ld e,Enemy.enemyCollisionMode		; $5774
	ld (de),a		; $5776

	ld e,Enemy.var30		; $5777
	ld a,b			; $5779
	ld (de),a		; $577a
	ret			; $577b

;;
; Check whether the angle between Link and the enemy is such that the collision should be
; ignored (due to the sword blocking it)
;
; Knockback is handled by PARTID_ENEMY_SWORD.
;
; @param[out]	zflag	z if sword hits should be ignored
; @addr{577c}
_swordEnemy_checkIgnoreCollision:
	ld e,Enemy.knockbackCounter		; $577c
	ld a,(de)		; $577e
	or a			; $577f
	ret nz			; $5780

	call objectGetAngleTowardEnemyTarget		; $5781
	ld b,a			; $5784
	ld e,Enemy.direction		; $5785
	ld a,(de)		; $5787
	add a			; $5788
	ld hl,@angleBits		; $5789
	rst_addDoubleIndex			; $578c
	ld a,b			; $578d
	jp checkFlag		; $578e

@angleBits:
	.db $3f $00 $00 $00 ; DIR_UP
	.db $00 $3f $00 $00 ; DIR_RIGHT
	.db $00 $00 $3f $00 ; DIR_DOWN
	.db $00 $00 $f8 $01 ; DIR_LEFT


;;
; @addr{57a1}
_swordDarknut_delete:
	call decNumEnemies		; $57a1
	jp enemyDelete		; $57a4


; ==============================================================================
; ENEMYID_PEAHAT
; ==============================================================================
enemyCode3e:
	jr z,@normalStatus	; $57a7
	sub ENEMYSTATUS_NO_HEALTH			; $57a9
	ret c			; $57ab
	jp z,enemyDie		; $57ac

	; ENEMYSTATUS_KNOCKBACK
	ld e,Enemy.enemyCollisionMode		; $57af
	ld a,(de)		; $57b1
	cp ENEMYCOLLISION_PEAHAT			; $57b2
	ret nz			; $57b4

@normalStatus:
	call _peahat_updateEnemyCollisionMode		; $57b5
	ld e,Enemy.state		; $57b8
	ld a,(de)		; $57ba
	rst_jumpTable			; $57bb
	.dw _peahat_state_uninitialized
	.dw _peahet_state_stub
	.dw _peahet_state_stub
	.dw _peahet_state_stub
	.dw _peahet_state_stub
	.dw _ecom_blownByGaleSeedState
	.dw _peahet_state_stub
	.dw _peahet_state_stub
	.dw _peahat_state8
	.dw _peahat_state9
	.dw _peahat_stateA
	.dw _peahat_stateB


_peahat_state_uninitialized:
	call _ecom_setSpeedAndState8AndVisible		; $57d4
	ld l,Enemy.counter1		; $57d7
	inc (hl)		; $57d9
	ret			; $57da


_peahet_state_stub:
	ret			; $57db


; Stationary for [counter1] frames
_peahat_state8:
	call _ecom_decCounter1		; $57dc
	ret nz			; $57df

	ld l,Enemy.state		; $57e0
	inc (hl)		; $57e2

	ld l,Enemy.counter1		; $57e3
	ld (hl),$7f		; $57e5

	ld l,Enemy.speed		; $57e7
	ld (hl),SPEED_20		; $57e9

	ld l,Enemy.var30		; $57eb
	ld (hl),$0f		; $57ed
	call objectSetVisiblec1		; $57ef
	jr _peahat_animate		; $57f2


; Accelerating
_peahat_state9:
	call _ecom_decCounter1		; $57f4
	jp nz,_peahat_updatePosition		; $57f7

	ld l,Enemy.state		; $57fa
	inc (hl)		; $57fc

	call getRandomNumber_noPreserveVars		; $57fd
	and $07			; $5800
	ld hl,_peahat_counter1Vals		; $5802
	rst_addAToHl			; $5805
	ld e,Enemy.counter1		; $5806
	ld a,(hl)		; $5808
	ld (de),a		; $5809
	call _ecom_setRandomAngle		; $580a
	jr _peahat_animate		; $580d


; Flying around at top speed
_peahat_stateA:
	call _ecom_decCounter1		; $580f
	jr z,@beginSlowingDown	; $5812

	; Change angle every 32 frames
	ld a,(hl)		; $5814
	and $1f			; $5815
	call z,_ecom_setRandomAngle		; $5817

	call objectApplySpeed		; $581a
	call _ecom_bounceOffScreenBoundary		; $581d
	jr _peahat_animate		; $5820

@beginSlowingDown:
	ld l,e			; $5822
	inc (hl) ; [state]
	ld l,Enemy.counter1		; $5824
	ld (hl),$00		; $5826

_peahat_animate:
	jp enemyAnimate		; $5828


; Slowing down
_peahat_stateB:
	ld h,d			; $582b
	ld l,Enemy.counter1		; $582c
	inc (hl)		; $582e

	ld a,$80		; $582f
	cp (hl)			; $5831
	jp nz,_peahat_updatePosition		; $5832

	; Go to state 8 for $80 frames (if tile is non-solid) or 1 frame (if tile is
	; solid).
	ld (hl),$80 ; [counter1]
	push hl			; $5837
	call objectGetTileCollisions		; $5838
	pop hl			; $583b
	jr z,+			; $583c
	ld (hl),$01 ; [counter1]
+
	ld l,Enemy.state		; $5840
	ld (hl),$08		; $5842
	call objectSetVisiblec2		; $5844
	jr _peahat_animate		; $5847


;;
; @addr{5849}
_peahat_updateEnemyCollisionMode:
	ld e,Enemy.zh		; $5849
	ld a,(de)		; $584b
	or a			; $584c
	ld a,ENEMYCOLLISION_PEAHAT_VULNERABLE		; $584d
	jr z,+			; $584f
	ld a,ENEMYCOLLISION_PEAHAT		; $5851
+
	ld e,Enemy.enemyCollisionMode		; $5853
	ld (de),a		; $5855
	ret			; $5856

;;
; Adjusts speed based on counter1, updates position, animates.
; @addr{5857}
_peahat_updatePosition:
	ld e,Enemy.counter1		; $5857
	ld a,(de)		; $5859
	dec a			; $585a
	cp $41			; $585b
	jr nc,@animate	; $585d

	and $78			; $585f
	swap a			; $5861
	rlca			; $5863
	ld b,a			; $5864
	sub $06			; $5865
	jr c,+			; $5867
	xor a			; $5869
+
	ld e,Enemy.zh		; $586a
	ld (de),a		; $586c

	; Determine speed
	ld a,b			; $586d
	ld hl,@speedVals		; $586e
	rst_addAToHl			; $5871
	ld e,Enemy.speed		; $5872
	ld a,(hl)		; $5874
	ld (de),a		; $5875
	call objectApplySpeed		; $5876
	call _ecom_bounceOffScreenBoundary		; $5879

@animate:
	ld e,Enemy.counter1		; $587c
	ld a,(de)		; $587e
	and $f0			; $587f
	swap a			; $5881
	ld hl,@animFrequencies		; $5883
	rst_addAToHl			; $5886
	ld b,(hl)		; $5887
	ld a,b			; $5888
	inc a			; $5889
	jr nz,+			; $588a
	call enemyAnimate		; $588c
	ld b,$00		; $588f
+
	ld a,(wFrameCounter)		; $5891
	and b			; $5894
	jp z,enemyAnimate		; $5895
	ret			; $5898

@animFrequencies:
	.db $ff $ff $ff $00 $00 $01 $03 $07

@speedVals:
	.db SPEED_c0 SPEED_c0 SPEED_c0 SPEED_80 SPEED_80 SPEED_40 SPEED_40 SPEED_20
	.db SPEED_20

_peahat_counter1Vals:
	.db 180 180 210 210 240 240 0 0


; ==============================================================================
; ENEMYID_WIZZROBE
;
; Variables:
;   var30: The low byte of wWizzrobePositionReservations that this wizzrobe is using
;          (red wizzrobes only)
;   var31/var32: Target position (blue wizzrobes only)
; ==============================================================================
enemyCode40:
	call _ecom_checkHazardsNoAnimationForHoles		; $58b2
	jr z,@normalStatus	; $58b5
	sub ENEMYSTATUS_NO_HEALTH			; $58b7
	ret c			; $58b9
	jp z,enemyDie		; $58ba
	dec a			; $58bd
	jp nz,_ecom_updateKnockbackAndCheckHazards		; $58be
	jr @justHit		; $58c1

@justHit:
	; For red wizzrobes only...
	ld e,Enemy.subid		; $58c3
	ld a,(de)		; $58c5
	dec a			; $58c6
	ret nz			; $58c7

	ld e,Enemy.stunCounter		; $58c8
	ld a,(de)		; $58ca
	or a			; $58cb
	ret nz			; $58cc

	ld e,Enemy.var2a		; $58cd
	ld a,(de)		; $58cf
	cp ITEMCOLLISION_LINK|$80			; $58d0
	ret z			; $58d2

	; The wizzrobe is knocked out of its normal position; allow other wizzrobes to
	; spawn there
	jp _wizzrobe_removePositionReservation		; $58d3

@normalStatus:
	call _ecom_getSubidAndCpStateTo08		; $58d6
	jr nc,@normalState	; $58d9
	rst_jumpTable			; $58db
	.dw _wizzrobe_state_uninitialized
	.dw _wizzrobe_state_stub
	.dw _wizzrobe_state_stub
	.dw _wizzrobe_state_switchHook
	.dw _wizzrobe_state_stub
	.dw _ecom_blownByGaleSeedState
	.dw _wizzrobe_state_stub
	.dw _wizzrobe_state_stub

@normalState:
	ld a,b			; $58ec
	rst_jumpTable			; $58ed
	.dw _wizzrobe_subid0
	.dw _wizzrobe_subid1
	.dw _wizzrobe_subid2


_wizzrobe_state_uninitialized:
	ld h,d			; $58f4
	ld l,Enemy.visible		; $58f5
	ld a,(hl)		; $58f7
	or $42			; $58f8
	ld (hl),a		; $58fa

	ld l,e			; $58fb
	ld e,Enemy.subid		; $58fc
	ld a,(de)		; $58fe
	or a			; $58ff
	jr nz,@subid1Or2	; $5900

@subid0:
	ld (hl),$08 ; [state]
	ld l,Enemy.counter1		; $5904
	ld (hl),$50		; $5906
	ret			; $5908

@subid1Or2:
	dec a			; $5909
	jr nz,@subid2	; $590a

@subid1:
	ld (hl),$08 ; [state]
	ld hl,wWizzrobePositionReservations		; $590e
	ld b,$10		; $5911
	jp clearMemory		; $5913

@subid2:
	ld (hl),$0b ; [state]
	ld l,Enemy.speed		; $5918
	ld (hl),SPEED_80		; $591a

	ld l,Enemy.counter1		; $591c
	ld (hl),$08		; $591e
	call _ecom_setRandomCardinalAngle		; $5920
	jp _wizzrobe_setAnimationFromAngle		; $5923


_wizzrobe_state_switchHook:
	inc e			; $5926
	ld a,(de)		; $5927
	rst_jumpTable			; $5928
	.dw _ecom_incState2
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate1:
@substate2:
	ret			; $5931

@substate3:
	call _ecom_fallToGroundAndSetState		; $5932
	ret nz			; $5935

	ld l,Enemy.collisionType		; $5936
	res 7,(hl)		; $5938

	ld e,Enemy.subid		; $593a
	ld a,(de)		; $593c
	ld hl,@stateAndCounter1		; $593d
	rst_addDoubleIndex			; $5940

	ld e,Enemy.state		; $5941
	ldi a,(hl)		; $5943
	ld (de),a		; $5944
	ld e,Enemy.counter1		; $5945
	ld a,(hl)		; $5947
	ld (de),a		; $5948
	ret			; $5949

@stateAndCounter1:
	.db $0b,  30 ; 0 == [subid]
	.db $0b, 150 ; 1
	.db $09,   0 ; 2


_wizzrobe_state_stub:
	ret			; $5950


; Green wizzrobe
_wizzrobe_subid0:
	ld a,(de)		; $5951
	sub $08			; $5952
	rst_jumpTable			; $5954
	.dw _wizzrobe_subid0_state8
	.dw _wizzrobe_subid0_state9
	.dw _wizzrobe_subid0_stateA
	.dw _wizzrobe_subid0_stateB


; Waiting [counter1] frames before spawning in
_wizzrobe_subid0_state8:
	call _ecom_decCounter1		; $595d
	ret nz			; $5960
	ld (hl),75		; $5961
	ld l,e			; $5963
	inc (hl) ; [state]
	jp objectSetVisiblec2		; $5965


; Phasing in for [counter1] frames
_wizzrobe_subid0_state9:
	call _ecom_decCounter1		; $5968
	jp nz,_wizzrobe_checkFlickerVisibility		; $596b

	ld (hl),72 ; [counter1]
	ld l,e			; $5970
	inc (hl) ; [state]

	ld l,Enemy.collisionType		; $5972
	set 7,(hl)		; $5974

	call _ecom_updateCardinalAngleTowardTarget		; $5976
	jp _wizzrobe_setAnimationFromAngle		; $5979


; Fully phased in; standing there for [counter1] frames, and firing a projectile at some
; point
_wizzrobe_subid0_stateA:
	call _ecom_decCounter1		; $597c
	jr z,@phaseOut	; $597f

	; Fire a projectile when [counter1] == 52
	ld a,(hl)		; $5981
	cp 52			; $5982
	ret nz			; $5984
	ld b,PARTID_WIZZROBE_PROJECTILE		; $5985
	jp _ecom_spawnProjectile		; $5987

@phaseOut:
	ld l,e			; $598a
	inc (hl) ; [state]

	ld l,Enemy.collisionType		; $598c
	res 7,(hl)		; $598e

	xor a			; $5990
	jp enemySetAnimation		; $5991


; Phasing out
_wizzrobe_subid0_stateB:
	ld h,d			; $5994
	ld l,Enemy.counter1		; $5995
	inc (hl)		; $5997
	ld a,(hl)		; $5998
	cp 75			; $5999
	jp c,_wizzrobe_checkFlickerVisibility		; $599b

	ld (hl),72 ; [counter1]
	ld l,e			; $59a0
	ld (hl),$08 ; [state]
	jp objectSetInvisible		; $59a3


; Red wizzrobe
_wizzrobe_subid1:
	ld a,(de)		; $59a6
	sub $08			; $59a7
	rst_jumpTable			; $59a9
	.dw _wizzrobe_subid1_state8
	.dw _wizzrobe_subid1_state9
	.dw _wizzrobe_subid1_stateA
	.dw _wizzrobe_subid1_stateB


; Choosing a new position to spawn at
_wizzrobe_subid1_state8:
	call _wizzrobe_chooseSpawnPosition		; $59b2
	ret nz			; $59b5
	call _wizzrobe_markSpotAsTaken		; $59b6
	ret z			; $59b9

	ld h,d			; $59ba
	ld l,Enemy.yh		; $59bb
	ld (hl),b		; $59bd
	ld l,Enemy.xh		; $59be
	ld (hl),c		; $59c0

	ld l,Enemy.state		; $59c1
	inc (hl)		; $59c3

	ld l,Enemy.counter1		; $59c4
	ld (hl),60		; $59c6

	call _ecom_updateCardinalAngleTowardTarget		; $59c8
	jp _wizzrobe_setAnimationFromAngle		; $59cb


; Phasing in for [counter1] frames
_wizzrobe_subid1_state9:
	call _ecom_decCounter1		; $59ce
	jp nz,_ecom_flickerVisibility		; $59d1

	ld (hl),72 ; [counter1]
	ld l,e			; $59d6
	inc (hl) ; [state]

	ld l,Enemy.collisionType		; $59d8
	set 7,(hl)		; $59da
	jp objectSetVisiblec2		; $59dc


; Fully phased in; standing there for [counter1] frames, and firing a projectile at some
; point
_wizzrobe_subid1_stateA:
	call _ecom_decCounter1		; $59df
	jr z,@phaseOut	; $59e2

	; Fire a projectile when [counter1] == 52
	ld a,(hl)		; $59e4
	cp 52			; $59e5
	ret nz			; $59e7
	ld b,PARTID_WIZZROBE_PROJECTILE		; $59e8
	jp _ecom_spawnProjectile		; $59ea

@phaseOut:
	ld (hl),180 ; [counter1]
	ld l,e			; $59ef
	inc (hl) ; [state]

	ld l,Enemy.collisionType		; $59f1
	res 7,(hl)		; $59f3
	ret			; $59f5


; Phasing out
_wizzrobe_subid1_stateB:
	call _ecom_decCounter1		; $59f6
	jr z,@gotoState8	; $59f9

	ld a,(hl)		; $59fb
	cp 120			; $59fc
	ret c			; $59fe
	jp z,objectSetInvisible		; $59ff
	jp _ecom_flickerVisibility		; $5a02

@gotoState8:
	ld l,e			; $5a05
	ld (hl),$08 ; [state]


;;
; Removes position reservation in "wWizzrobePositionReservations" allowing other wizzrobes
; to spawn here.
; @addr{5a08}
_wizzrobe_removePositionReservation:
	ld h,d			; $5a08
	ld l,Enemy.var30		; $5a09
	ld l,(hl)		; $5a0b
	ld h,>wWizzrobePositionReservations		; $5a0c
	ld a,(hl)		; $5a0e
	sub d			; $5a0f
	ret nz			; $5a10
	ldd (hl),a		; $5a11
	ld (hl),a		; $5a12
	ret			; $5a13


; Blue wizzrobe
_wizzrobe_subid2:
	ld a,(de)		; $5a14
	sub $08			; $5a15
	rst_jumpTable			; $5a17
	.dw _wizzrobe_subid2_state8
	.dw _wizzrobe_subid2_state9
	.dw _wizzrobe_subid2_stateA
	.dw _wizzrobe_subid2_stateB


; Currently phased in, attacking until [counter1] reaches 0 or it hits a wall
_wizzrobe_subid2_state8:
	call _ecom_decCounter1		; $5a20
	jr z,@phaseOut	; $5a23

	; Reorient toward Link in [counter2] frames
	inc l			; $5a25
	dec (hl) ; [counter2]
	jr nz,@updatePosition	; $5a27

	call _ecom_updateCardinalAngleTowardTarget		; $5a29
	call _wizzrobe_setAnimationFromAngle		; $5a2c

	; Set random counter2 from $20-$5f
	call getRandomNumber_noPreserveVars		; $5a2f
	and $3f			; $5a32
	add $20			; $5a34
	ld e,Enemy.counter2		; $5a36
	ld (de),a		; $5a38

@updatePosition:
	call _wizzrobe_fireEvery32Frames		; $5a39
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $5a3c
	ret nz			; $5a3f

@phaseOut:
	call _ecom_incState		; $5a40
	ld l,Enemy.collisionType		; $5a43
	res 7,(hl)		; $5a45
	ret			; $5a47


; Currently phased out, choosing a target position
_wizzrobe_subid2_state9:
	call _wizzrobe_chooseSpawnPosition		; $5a48
	jp nz,_ecom_flickerVisibility		; $5a4b

	; Store target position
	ld h,d			; $5a4e
	ld l,Enemy.var31		; $5a4f
	ld (hl),b		; $5a51
	inc l			; $5a52
	ld (hl),c		; $5a53

	ld l,Enemy.state		; $5a54
	inc (hl)		; $5a56

	ld l,Enemy.zh		; $5a57
	dec (hl)		; $5a59

	call _wizzrobe_setAngleTowardTargetPosition		; $5a5a
	jr _wizzrobe_setAnimationFromAngle		; $5a5d


; Currently phased out, moving toward target position
_wizzrobe_subid2_stateA:
	call _wizzrobe_setAngleTowardTargetPosition		; $5a5f
	call _ecom_flickerVisibility		; $5a62
	call _wizzrobe_checkReachedTargetPosition		; $5a65
	jp nc,objectApplySpeed		; $5a68

	; Reached target position
	ld l,Enemy.state		; $5a6b
	inc (hl)		; $5a6d

	ld l,Enemy.counter1		; $5a6e
	ld (hl),$08		; $5a70

	ld l,Enemy.zh		; $5a72
	ld (hl),$00		; $5a74

	call _ecom_updateCardinalAngleTowardTarget		; $5a76
	call _wizzrobe_setAnimationFromAngle		; $5a79
	jp objectSetVisiblec2		; $5a7c


; Standing still for [counter1] frames (8 frames) before phasing in and attacking again
_wizzrobe_subid2_stateB:
	call _ecom_decCounter1		; $5a7f
	jp nz,_ecom_flickerVisibility		; $5a82

	ld h,d			; $5a85
	ld l,e			; $5a86
	ld (hl),$08 ; [state]

	ld l,Enemy.collisionType		; $5a89
	set 7,(hl)		; $5a8b

	; Choose random counter1 between $80-$ff (how long to stay in state 8)
	ld bc,$7f3f		; $5a8d
	call _ecom_randomBitwiseAndBCE		; $5a90
	ld e,Enemy.counter1		; $5a93
	ld a,b			; $5a95
	add $80			; $5a96
	ld (de),a		; $5a98

	; Choose random counter2 between $10-$4f (when to reorient toward Link)
	inc e			; $5a99
	ld a,c			; $5a9a
	add $10			; $5a9b
	ld (de),a		; $5a9d

	call _ecom_updateCardinalAngleTowardTarget		; $5a9e
	call _wizzrobe_setAnimationFromAngle		; $5aa1
	jp objectSetVisiblec2		; $5aa4

;;
; @addr{5aa7}
_wizzrobe_setAnimationFromAngle:
	ld e,Enemy.angle		; $5aa7
	ld a,(de)		; $5aa9
	add $04			; $5aaa
	and $18			; $5aac
	swap a			; $5aae
	rlca			; $5ab0
	inc a			; $5ab1
	jp enemySetAnimation		; $5ab2

;;
; Flicker visibility when [counter1] < 45.
; @addr{5ab5}
_wizzrobe_checkFlickerVisibility:
	ld e,Enemy.counter1		; $5ab5
	ld a,(de)		; $5ab7
	cp 45			; $5ab8
	ret c			; $5aba
	jp _ecom_flickerVisibility		; $5abb

;;
; @param[out]	cflag	c if within 1 pixel of target position in both directions
; @addr{5abe}
_wizzrobe_checkReachedTargetPosition:
	ld h,d			; $5abe
	ld l,Enemy.yh		; $5abf
	ld e,Enemy.var31		; $5ac1
	ld a,(de)		; $5ac3
	sub (hl)		; $5ac4
	inc a			; $5ac5
	cp $03			; $5ac6
	ret nc			; $5ac8
	ld l,Enemy.xh		; $5ac9
	inc e			; $5acb
	ld a,(de)		; $5acc
	sub (hl)		; $5acd
	inc a			; $5ace
	cp $03			; $5acf
	ret			; $5ad1


;;
; @addr{5ad2}
_wizzrobe_setAngleTowardTargetPosition:
	ld h,d			; $5ad2
	ld l,Enemy.var31		; $5ad3
	call _ecom_readPositionVars		; $5ad5
	call objectGetRelativeAngleWithTempVars		; $5ad8
	ld e,Enemy.angle		; $5adb
	ld (de),a		; $5add
	ret			; $5ade


;;
; Chooses a random position somewhere within the screen boundaries (accounting for camera
; position). It may choose a solid position (in which case this need to be called again).
;
; @param[out]	bc	Chosen position (long form)
; @param[out]	l	Chosen position (short form)
; @param[out]	zflag	nz if this tile has solidity
; @addr{5adf}
_wizzrobe_chooseSpawnPosition:
	call getRandomNumber_noPreserveVars		; $5adf
	and $70 ; Value strictly under SCREEN_HEIGHT<<4
	ld b,a			; $5ae4
	ldh a,(<hCameraY)	; $5ae5
	add b			; $5ae7
	and $f0			; $5ae8
	add $08			; $5aea
	ld b,a			; $5aec
--
	call getRandomNumber		; $5aed
	and $f0			; $5af0
	cp SCREEN_WIDTH<<4			; $5af2
	jr nc,--		; $5af4

	ld c,a			; $5af6
	ldh a,(<hCameraX)	; $5af7
	add c			; $5af9
	and $f0			; $5afa
	add $08			; $5afc
	ld c,a			; $5afe
	jp getTileCollisionsAtPosition		; $5aff

;;
; @addr{5b02}
_wizzrobe_fireEvery32Frames:
	ld e,Enemy.counter1		; $5b02
	ld a,(de)		; $5b04
	and $1f			; $5b05
	ret nz			; $5b07
	ld b,PARTID_WIZZROBE_PROJECTILE		; $5b08
	jp _ecom_spawnProjectile		; $5b0a


;;
; Marks a spot as taken in wWizzrobePositionReservations; the position is reserved so no
; other red wizzrobe can spawn there. If this position is already reserved, this returns
; with the zflag set.
;
; @param	l	Position
; @param[out]	zflag	z if position already reserved, or wWizzrobePositionReservations
;			is full
; @addr{5b0d}
_wizzrobe_markSpotAsTaken:
	push bc			; $5b0d
	ld e,l			; $5b0e
	ld b,$08		; $5b0f
	ld c,b			; $5b11
	ld hl,wWizzrobePositionReservations		; $5b12
--
	ldi a,(hl)		; $5b15
	cp e			; $5b16
	jr z,@ret	; $5b17
	inc l			; $5b19
	dec b			; $5b1a
	jr nz,--		; $5b1b

	ld l,<wWizzrobePositionReservations		; $5b1d
--
	ld a,(hl)		; $5b1f
	or a			; $5b20
	jr z,@fillBlankSpot	; $5b21
	inc l			; $5b23
	inc l			; $5b24
	dec c			; $5b25
	jr nz,--		; $5b26
	jr @ret		; $5b28

@fillBlankSpot:
	ld (hl),e		; $5b2a
	inc l			; $5b2b
	ld (hl),d		; $5b2c
	ld e,Enemy.var30		; $5b2d
	ld a,l			; $5b2f
	ld (de),a		; $5b30
	or d			; $5b31

@ret:
	pop bc			; $5b32
	ret			; $5b33


; ==============================================================================
; ENEMYID_CROW
; ENEMYID_BLUE_CROW
;
; Variables:
;   var30: "Base" animation index (direction gets added to this)
;   var31: Actual animation index
;   var32/var33: Target position (subid 1 only)
; ==============================================================================
enemyCode41:
enemyCode4c:
	jr z,@normalStatus	; $5b34
	sub ENEMYSTATUS_NO_HEALTH			; $5b36
	ret c			; $5b38
	jp z,enemyDie		; $5b39
	dec a			; $5b3c
	ret z			; $5b3d
	jp _ecom_updateKnockbackNoSolidity		; $5b3e

@normalStatus:
	call _ecom_getSubidAndCpStateTo08		; $5b41
	jr nc,@normalState	; $5b44
	rst_jumpTable			; $5b46
	.dw _crow_state_uninitialized
	.dw _crow_state_stub
	.dw _crow_state_stub
	.dw _crow_state_stub
	.dw _crow_state_stub
	.dw _ecom_blownByGaleSeedState
	.dw _crow_state_stub
	.dw _crow_state_stub

@normalState:
	ld a,b			; $5b57
	rst_jumpTable			; $5b58
	.dw _crow_subid0
	.dw _crow_subid1


_crow_state_uninitialized:
	ld e,Enemy.subid		; $5b5d
	ld a,(de)		; $5b5f
	or a			; $5b60
	jp nz,_ecom_setSpeedAndState8		; $5b61

	; Subid 0
	ld a,SPEED_140		; $5b64
	call _ecom_setSpeedAndState8		; $5b66
	jp objectSetVisiblec1		; $5b69


_crow_state_stub:
	ret			; $5b6c


_crow_subid0:
	ld a,(de)		; $5b6d
	sub $08			; $5b6e
	rst_jumpTable			; $5b70
	.dw _crow_subid0_state8
	.dw _crow_subid0_state9
	.dw _crow_subid0_stateA


; Perched, waiting for Link to approach
_crow_subid0_state8:
	call _ecom_updateAngleTowardTarget		; $5b77
	call _crow_setAnimationFromAngle		; $5b7a

	; Check if Link has approached
	ld h,d			; $5b7d
	ld l,Enemy.yh		; $5b7e
	ldh a,(<hEnemyTargetY)	; $5b80
	sub (hl)		; $5b82
	add $30			; $5b83
	cp $61			; $5b85
	ret nc			; $5b87

	ld l,Enemy.xh		; $5b88
	ldh a,(<hEnemyTargetX)	; $5b8a
	sub (hl)		; $5b8c
	add $18			; $5b8d
	cp $31			; $5b8f
	ret nc			; $5b91

	; Link has approached.
	call _ecom_incState		; $5b92
	ld l,Enemy.counter1		; $5b95
	ld (hl),25		; $5b97

	ld l,Enemy.var30		; $5b99
	ld (hl),$02		; $5b9b
	ret			; $5b9d


; Moving up and preparing to charge at Link after [counter1] frames (25 frames)
_crow_subid0_state9:
	call _ecom_updateAngleTowardTarget		; $5b9e
	call _crow_setAnimationFromAngle		; $5ba1
	call _ecom_decCounter1		; $5ba4
	jr z,@beginCharge	; $5ba7

	ld a,(hl) ; [counter1]
	and $03			; $5baa
	jr nz,_crow_subid0_animate	; $5bac

	ld l,Enemy.zh		; $5bae
	dec (hl)		; $5bb0
	jr _crow_subid0_animate		; $5bb1

@beginCharge:
	inc l			; $5bb3
	ld (hl),90 ; [counter2]

	ld l,Enemy.state		; $5bb6
	inc (hl)		; $5bb8

	ld l,Enemy.collisionType		; $5bb9
	set 7,(hl)		; $5bbb

	call _ecom_updateAngleTowardTarget		; $5bbd

	; Randomly add or subtract 4 from angle (will either overshoot or undershoot Link)
	call getRandomNumber_noPreserveVars		; $5bc0
	and $04			; $5bc3
	jr nz,+			; $5bc5
	ld a,-$04		; $5bc7
+
	ld b,a			; $5bc9
	ld e,Enemy.angle		; $5bca
	ld a,(de)		; $5bcc
	add b			; $5bcd
	ld (de),a		; $5bce

	jr _crow_subid0_animate		; $5bcf


; Charging toward Link
_crow_subid0_stateA:
	call _crow_subid0_checkWithinScreenBounds		; $5bd1
	jp nc,enemyDelete		; $5bd4

	call _ecom_decCounter2		; $5bd7
	jr z,@applySpeed	; $5bda

	; Adjust angle toward Link every 8 frames
	ld a,(hl)		; $5bdc
	and $07			; $5bdd
	jr nz,@applySpeed	; $5bdf

	call objectGetAngleTowardEnemyTarget		; $5be1
	call objectNudgeAngleTowards		; $5be4
	call _crow_setAnimationFromAngle		; $5be7

@applySpeed:
	call objectApplySpeed		; $5bea

_crow_subid0_animate:
	jp enemyAnimate		; $5bed


_crow_subid1:
	ld a,(de)		; $5bf0
	sub $08			; $5bf1
	rst_jumpTable			; $5bf3
	.dw _crow_subid1_state8
	.dw _crow_subid1_state9
	.dw _crow_subid1_stateA
	.dw _crow_subid1_stateB
	.dw _crow_subid1_stateC
	.dw _crow_subid1_stateD


; Checking whether it's ok to charge in right now
_crow_subid1_state8:
	; Count the number of crows that are in state 9 or higher (number of crows that
	; are either about to or are already charging across the screen)
	ldhl FIRST_ENEMY_INDEX, Enemy.id		; $5c00
	ld b,$00		; $5c03
@nextEnemy:
	ld a,(hl)		; $5c05
	cp ENEMYID_CROW			; $5c06
	jr nz,++		; $5c08

	ld l,e ; l = state
	ldd a,(hl)		; $5c0b
	dec l			; $5c0c
	dec l			; $5c0d
	cp $09			; $5c0e
	jr c,++		; $5c10
	inc b			; $5c12
++
	inc h			; $5c13
	ld a,h			; $5c14
	cp LAST_ENEMY_INDEX+1			; $5c15
	jr c,@nextEnemy	; $5c17

	; Only allow 2 such crows at a time (this one needs to wait)
	ld a,b			; $5c19
	cp $02			; $5c1a
	ret nc			; $5c1c

	ld h,d			; $5c1d
	ld l,e			; $5c1e
	inc (hl) ; [state]

	ld l,Enemy.counter1		; $5c20
	or a			; $5c22
	ld a,60   ; 1st crow on-screen
	jr z,+			; $5c25
	ld a,240  ; 2nd crow on-screen
+
	ld (hl),a		; $5c29

	ld l,Enemy.var30		; $5c2a
	ld (hl),$02		; $5c2c
	ret			; $5c2e


; Spawn in after [counter1] frames
_crow_subid1_state9:
	call _ecom_decCounter1		; $5c2f
	ret nz			; $5c32

	; Determine spawn/target position data to read based on which screen quadrant Link
	; is in
	ld b,$00		; $5c33
	ldh a,(<hEnemyTargetY)	; $5c35
	cp (SMALL_ROOM_HEIGHT/2)<<4			; $5c37
	jr c,+			; $5c39
	ld b,$08		; $5c3b
+
	ldh a,(<hEnemyTargetX)	; $5c3d
	cp (SMALL_ROOM_WIDTH/2)<<4			; $5c3f
	jr c,+			; $5c41
	set 2,b			; $5c43
+
	ld a,b			; $5c45
	ld hl,_crow_offScreenSpawnData		; $5c46
	rst_addAToHl			; $5c49

	; Read in spawn position
	ld e,Enemy.yh		; $5c4a
	ldi a,(hl)		; $5c4c
	ld (de),a		; $5c4d
	ldh (<hFF8F),a	; $5c4e

	ld e,Enemy.xh		; $5c50
	ldi a,(hl)		; $5c52
	ld (de),a		; $5c53
	ldh (<hFF8E),a	; $5c54

	; Read in target position
	ld e,Enemy.var32		; $5c56
	ldi a,(hl)		; $5c58
	ld (de),a		; $5c59
	ld b,a			; $5c5a

	inc e			; $5c5b
	ld a,(hl)		; $5c5c
	ld (de),a		; $5c5d
	ld c,a			; $5c5e

	; Set angle to target position
	call _ecom_updateAngleTowardTarget		; $5c5f

	call _ecom_incState		; $5c62

	ld l,Enemy.collisionType		; $5c65
	set 7,(hl)		; $5c67

	ld l,Enemy.speed		; $5c69
	ld (hl),SPEED_80		; $5c6b

	ld l,Enemy.zh		; $5c6d
	ld (hl),-$06		; $5c6f

	call _crow_setAnimationFromAngle		; $5c71
	jp objectSetVisiblec1		; $5c74


; Moving into screen
_crow_subid1_stateA:
	call _crow_moveTowardTargetPosition		; $5c77
	jr nc,_crow_subid1_animate	; $5c7a

	ld l,e			; $5c7c
	inc (hl) ; [state]

	ld l,Enemy.counter1		; $5c7e
	ld (hl),60		; $5c80

	call _ecom_updateAngleTowardTarget		; $5c82
	call _crow_setAnimationFromAngle		; $5c85

_crow_subid1_animate:
	jp enemyAnimate		; $5c88


; Hovering in position for [counter1] frames before charging
_crow_subid1_stateB:
	call _ecom_decCounter1		; $5c8b
	jr nz,_crow_subid1_animate	; $5c8e

	ld (hl),24  ; [counter1]
	inc l			; $5c92
	ld (hl),$00 ; [counter2]

	ld l,e			; $5c95
	inc (hl) ; [state]

	ld l,Enemy.var32		; $5c97
	ldh a,(<hEnemyTargetY)	; $5c99
	ldi (hl),a		; $5c9b
	ldh a,(<hEnemyTargetX)	; $5c9c
	ld (hl),a		; $5c9e

	ld l,Enemy.speed		; $5c9f
	ld (hl),SPEED_20		; $5ca1
	jr _crow_subid1_animate		; $5ca3


; Moving, accelerating toward Link
_crow_subid1_stateC:
	call _crow_subid1_checkWithinScreenBounds		; $5ca5
	jr nc,@outOfBounds	; $5ca8

	call _crow_updateAngleTowardLinkIfCounter1Zero		; $5caa
	call _crow_updateSpeed		; $5cad
	call objectApplySpeed		; $5cb0
	jr _crow_subid1_animate		; $5cb3

@outOfBounds:
	call _ecom_incState		; $5cb5
	jr _crow_subid1_animate		; $5cb8


; Moved out of bounds; go back to state 8 to eventually charge again
_crow_subid1_stateD:
	ld h,d			; $5cba
	ld l,e			; $5cbb
	ld (hl),$08 ; [state]

	ld l,Enemy.collisionType		; $5cbe
	res 7,(hl)		; $5cc0

	jp objectSetInvisible		; $5cc2


;;
; Adjusts angle to move directly toward Link when [counter1] reaches 0. After this it
; underflows to 255, so the angle correction only happens once.
; @addr{5cc5}
_crow_updateAngleTowardLinkIfCounter1Zero:
	call _ecom_decCounter1		; $5cc5
	ret nz			; $5cc8
	call _ecom_updateAngleTowardTarget		; $5cc9


;;
; @addr{5ccc}
_crow_setAnimationFromAngle:
	ld h,d			; $5ccc
	ld l,Enemy.angle		; $5ccd
	ld a,(hl)		; $5ccf
	and $0f			; $5cd0
	ret z			; $5cd2

	bit 4,(hl)		; $5cd3
	ld l,Enemy.var30		; $5cd5
	ld a,(hl)		; $5cd7
	jr nz,+			; $5cd8
	inc a			; $5cda
+
	ld l,Enemy.var31		; $5cdb
	cp (hl)			; $5cdd
	ret z			; $5cde
	ld (hl),a		; $5cdf
	jp enemySetAnimation		; $5ce0

;;
; Identical to _crow_subid1_checkWithinScreenBounds.
;
; @param[out]	cflag	c if within screen bounds
; @addr{5ce3}
_crow_subid0_checkWithinScreenBounds:
	ld e,Enemy.yh		; $5ce3
	ld a,(de)		; $5ce5
	cp SMALL_ROOM_HEIGHT<<4 + 8			; $5ce6
	ret nc			; $5ce8
	ld e,Enemy.xh		; $5ce9
	ld a,(de)		; $5ceb
	cp SMALL_ROOM_WIDTH<<4 + 8			; $5cec
	ret			; $5cee

;;
; @param[out]	cflag	c if within 1 pixel of target position
; @addr{5cef}
_crow_moveTowardTargetPosition:
	ld h,d			; $5cef
	ld l,Enemy.var32		; $5cf0
	call _ecom_readPositionVars		; $5cf2
	sub c			; $5cf5
	inc a			; $5cf6
	cp $02			; $5cf7
	jr nc,@moveToward	; $5cf9

	ldh a,(<hFF8F)	; $5cfb
	sub b			; $5cfd
	inc a			; $5cfe
	cp $02			; $5cff
	ret c			; $5d01

@moveToward:
	call _ecom_moveTowardPosition		; $5d02
	call _crow_setAnimationFromAngle		; $5d05
	or d			; $5d08
	ret			; $5d09

;;
; Updates speed based on counter2. For subid 1.
; @addr{5d0a}
_crow_updateSpeed:
	ld e,Enemy.counter2		; $5d0a
	ld a,(de)		; $5d0c
	cp $7f			; $5d0d
	jr z,+			; $5d0f
	inc a			; $5d11
	ld (de),a		; $5d12
+
	and $f0			; $5d13
	swap a			; $5d15
	ld hl,_crow_speeds		; $5d17
	rst_addAToHl			; $5d1a
	ld e,Enemy.speed		; $5d1b
	ld a,(hl)		; $5d1d
	ld (de),a		; $5d1e
	ret			; $5d1f


;;
; Identical to _crow_subid0_checkWithinScreenBounds.
;
; @param[out]	cflag	c if within screen bounds
; @addr{5d20}
_crow_subid1_checkWithinScreenBounds:
	ld e,Enemy.yh		; $5d20
	ld a,(de)		; $5d22
	cp SCREEN_HEIGHT<<4 + 8			; $5d23
	ret nc			; $5d25
	ld e,Enemy.xh		; $5d26
	ld a,(de)		; $5d28
	cp SCREEN_WIDTH<<4 + 8			; $5d29
	ret			; $5d2b


; Speeds for subid 1; accerelates while chasing Link.
_crow_speeds:
	.db SPEED_040 SPEED_080 SPEED_0c0 SPEED_100
	.db SPEED_140 SPEED_180 SPEED_1c0 SPEED_200

; Each row corresponds to a screen quadrant Link is in.
; Byte values:
;   b0/b1: Spawn Y/X position
;   b2/b3: Target Y/X position (position to move to before charging in)
_crow_offScreenSpawnData:
	.db $60 $a0 $70 $90
	.db $60 $00 $70 $10
	.db $20 $a0 $10 $90
	.db $20 $00 $10 $10


; ==============================================================================
; ENEMYID_GEL
; ==============================================================================
enemyCode43:
	call _ecom_checkHazardsNoAnimationForHoles		; $5d44
	jr z,@normalStatus	; $5d47
	sub ENEMYSTATUS_NO_HEALTH			; $5d49
	ret c			; $5d4b
	jp z,enemyDie		; $5d4c

	; ENEMYSTATUS_JUST_HIT or ENEMYSTATUS_KNOCKBACK
	ld e,Enemy.var2a		; $5d4f
	ld a,(de)		; $5d51
	cp $80|ITEMCOLLISION_LINK			; $5d52
	jr nz,@normalStatus	; $5d54

	; Touched Link; attach self to him.
	ld e,Enemy.state		; $5d56
	ld a,$0c		; $5d58
	ld (de),a		; $5d5a

@normalStatus:
	ld e,Enemy.state		; $5d5b
	ld a,(de)		; $5d5d
	rst_jumpTable			; $5d5e
	.dw _gel_state_uninitialized
	.dw _gel_state_stub
	.dw _gel_state_stub
	.dw _gel_state_stub
	.dw _gel_state_stub
	.dw _ecom_blownByGaleSeedState
	.dw _gel_state_stub
	.dw _gel_state_stub
	.dw _gel_state8
	.dw _gel_state9
	.dw _gel_stateA
	.dw _gel_stateB
	.dw _gel_stateC
	.dw _gel_stateD


_gel_state_uninitialized:
	ld e,Enemy.counter1		; $5d7b
	ld a,$10		; $5d7d
	ld (de),a		; $5d7f
	jp _ecom_setSpeedAndState8AndVisible		; $5d80


_gel_state_stub:
	ret			; $5d83


; Standing in place for [counter1] frames
_gel_state8:
	call _ecom_decCounter1		; $5d84
	jr nz,_gel_animate	; $5d87

	; 1 in 8 chance of switching to "hopping" state
	call getRandomNumber_noPreserveVars		; $5d89
	and $07			; $5d8c
	ld h,d			; $5d8e
	jr nz,@inchForward	; $5d8f

	; Prepare to hop
	ld l,Enemy.counter1		; $5d91
	ld (hl),$30		; $5d93

	ld l,Enemy.state		; $5d95
	ld (hl),$0a		; $5d97

	ld a,$02		; $5d99
	jp enemySetAnimation		; $5d9b

@inchForward:
	ld l,Enemy.counter1		; $5d9e
	ld (hl),$08		; $5da0

	ld l,Enemy.state		; $5da2
	inc (hl)		; $5da4

	ld l,Enemy.speed		; $5da5
	ld (hl),SPEED_40		; $5da7

	call _ecom_updateAngleTowardTarget		; $5da9
	jr _gel_animate		; $5dac


; Inching toward Link for [counter1] frames
_gel_state9:
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $5dae
	call _ecom_decCounter1		; $5db1
	jr nz,_gel_animate	; $5db4

	ld l,Enemy.state		; $5db6
	ld (hl),$08		; $5db8
	ld l,Enemy.counter1		; $5dba
	ld (hl),$10		; $5dbc

_gel_animate:
	jp enemyAnimate		; $5dbe


; Preparing to hop toward Link
_gel_stateA:
	call _ecom_decCounter1		; $5dc1
	jr nz,_gel_animate	; $5dc4

	call _gel_beginHop		; $5dc6
	jp _ecom_updateAngleTowardTarget		; $5dc9


; Hopping toward Link
_gel_stateB:
	call _ecom_applyVelocityForSideviewEnemy		; $5dcc
	ld c,$28		; $5dcf
	call objectUpdateSpeedZ_paramC		; $5dd1
	ret nz			; $5dd4

	; Just landed

	ld h,d			; $5dd5
	ld l,Enemy.state		; $5dd6
	ld (hl),$08		; $5dd8

	ld l,Enemy.counter1		; $5dda
	ld (hl),$10		; $5ddc

	ld l,Enemy.collisionType		; $5dde
	set 7,(hl)		; $5de0
	jp objectSetVisiblec2		; $5de2


; Just latched onto Link
_gel_stateC:
	ld h,d			; $5de5
	ld l,e			; $5de6
	inc (hl) ; [state]

	ld l,Enemy.counter2		; $5de8
	ld (hl),120		; $5dea

	ld a,$01		; $5dec
	jp enemySetAnimation		; $5dee


; Attached to Link, slowing him down
_gel_stateD:
	ld a,(w1Link.yh)		; $5df1
	ld e,Enemy.yh		; $5df4
	ld (de),a		; $5df6
	ld a,(w1Link.xh)		; $5df7
	ld e,Enemy.xh		; $5dfa
	ld (de),a		; $5dfc

	call _ecom_decCounter2		; $5dfd
	jr z,@hopOff	; $5e00

	; If any button is pressed, counter2 goes down more quickly
	ld a,(wGameKeysJustPressed)		; $5e02
	or a			; $5e05
	jr z,++		; $5e06

	ld a,(hl) ; [counter2]
	sub $03			; $5e09
	jr nc,+			; $5e0b
	ld a,$01		; $5e0d
+
	ld (hl),a		; $5e0f
++
	; Invert draw priority every 4 frames
	ld a,(hl)		; $5e10
	and $03			; $5e11
	jr nz,++		; $5e13
	ld l,Enemy.visible		; $5e15
	ld a,(hl)		; $5e17
	xor $07			; $5e18
	ld (hl),a		; $5e1a
++
	; Disable use of sword
	ld hl,wccd8		; $5e1b
	set 5,(hl)		; $5e1e

	; Disable movement every other frame
	ld a,(wFrameCounter)		; $5e20
	rrca			; $5e23
	jr nc,_gel_animate	; $5e24
	ld hl,wLinkImmobilized		; $5e26
	set 5,(hl)		; $5e29
	jr _gel_animate		; $5e2b

@hopOff:
	call _gel_setAngleAwayFromLink		; $5e2d
	jr _gel_beginHop		; $5e30


;;
; @addr{5e32}
_gel_beginHop:
	ld bc,-$200		; $5e32
	call objectSetSpeedZ		; $5e35

	ld l,Enemy.state		; $5e38
	ld (hl),$0b		; $5e3a

	ld l,Enemy.speed		; $5e3c
	ld (hl),SPEED_100		; $5e3e

	xor a			; $5e40
	call enemySetAnimation		; $5e41

	ld a,SND_ENEMY_JUMP		; $5e44
	call playSound		; $5e46
	jp objectSetVisiblec1		; $5e49

;;
; @addr{5e4c}
_gel_setAngleAwayFromLink:
	ld a,(w1Link.angle)		; $5e4c
	bit 7,a			; $5e4f
	jp nz,_ecom_setRandomAngle		; $5e51
	xor $10			; $5e54
	ld e,Enemy.angle		; $5e56
	ld (de),a		; $5e58
	ret			; $5e59


; ==============================================================================
; ENEMYID_PINCER
;
; Variables:
;   relatedObj1: Pointer to "head", aka subid 1 (only for body parts, subids 2+)
;   var31/var32: Base Y/X position (where it originates from)
;   var33: Amount extended (0 means still in hole)
;   var34: Copy of parent's "id" value. For body parts only.
; ==============================================================================
enemyCode45:
	jr z,@normalStatus	; $5e5a
	sub ENEMYSTATUS_NO_HEALTH			; $5e5c
	ret c			; $5e5e
	jp z,enemyDie		; $5e5f

@normalStatus:
	call _ecom_getSubidAndCpStateTo08		; $5e62
	jr nc,@normalState	; $5e65
	rst_jumpTable			; $5e67
	.dw _pincer_state_uninitialized
	.dw _pincer_state1
	.dw _pincer_state_stub
	.dw _pincer_state_stub
	.dw _pincer_state_stub
	.dw _pincer_state_stub
	.dw _pincer_state_stub
	.dw _pincer_state_stub

@normalState:
	dec b			; $5e78
	ld a,b			; $5e79
	rst_jumpTable			; $5e7a
	.dw _pincer_head
	.dw _pincer_body
	.dw _pincer_body
	.dw _pincer_body


_pincer_state_uninitialized:
	ld a,b			; $5e83
	or a			; $5e84
	jp nz,_ecom_setSpeedAndState8		; $5e85

	; subid 0 only
	inc a			; $5e88
	ld (de),a ; [state] = 1


; Spawner only (subid 0): Spawn head and body parts, then delete self.
_pincer_state1:
	ld b,$04		; $5e8a
	call checkBEnemySlotsAvailable		; $5e8c
	ret nz			; $5e8f

	; Spawn head
	ld b,ENEMYID_PINCER		; $5e90
	call _ecom_spawnUncountedEnemyWithSubid01		; $5e92
	ld l,Enemy.enabled		; $5e95
	ld e,l			; $5e97
	ld a,(de)		; $5e98
	ld (hl),a		; $5e99
	call objectCopyPosition		; $5e9a

	; Spawn body parts
	ld c,h			; $5e9d
	call _ecom_spawnUncountedEnemyWithSubid01		; $5e9e
	call _pincer_setChildRelatedObj1		; $5ea1
	; [child.subid] = 2 (incremented in above function call)

	call _ecom_spawnUncountedEnemyWithSubid01		; $5ea4
	inc (hl)
	call _pincer_setChildRelatedObj1		; $5ea8
	; [child.subid] = 3

	call _ecom_spawnUncountedEnemyWithSubid01		; $5eab
	inc (hl)		; $5eae
	inc (hl)
	call _pincer_setChildRelatedObj1		; $5eb0
	; [child.subid] = 4

	; Spawner no longer needed
	jp enemyDelete		; $5eb3


_pincer_state_stub:
	ret			; $5eb6


; Subid 1: Head of pincer (the "main" part, which is attackable)
_pincer_head:
	ld a,(de)		; $5eb7
	sub $08			; $5eb8
	rst_jumpTable			; $5eba
	.dw _pincer_head_state8
	.dw _pincer_head_state9
	.dw _pincer_head_stateA
	.dw _pincer_head_stateB
	.dw _pincer_head_stateC
	.dw _pincer_head_stateD
	.dw _pincer_head_stateE


; Initialization
_pincer_head_state8:
	ld h,d			; $5ec9
	ld l,e			; $5eca
	inc (hl) ; [state]

	ld e,Enemy.yh		; $5ecc
	ld l,Enemy.var31		; $5ece
	ld a,(de)		; $5ed0
	ldi (hl),a		; $5ed1
	ld e,Enemy.xh		; $5ed2
	ld a,(de)		; $5ed4
	ld (hl),a		; $5ed5
	ret			; $5ed6


; Waiting for Link to approach
_pincer_head_state9:
	ld c,$28		; $5ed7
	call objectCheckLinkWithinDistance		; $5ed9
	ret nc			; $5edc

	ld e,Enemy.state		; $5edd
	ld a,$0a		; $5edf
	ld (de),a		; $5ee1
	jp objectSetVisible82		; $5ee2


; Showing eyes as a "warning" that it's about to attack
_pincer_head_stateA:
	ld e,Enemy.animParameter		; $5ee5
	ld a,(de)		; $5ee7
	dec a			; $5ee8
	jp nz,enemyAnimate		; $5ee9

	; Time to attack
	call _ecom_incState		; $5eec

	ld l,Enemy.collisionType		; $5eef
	set 7,(hl)		; $5ef1

	; Initial "extended" amount is 0
	ld l,Enemy.var33		; $5ef3
	ld (hl),$00		; $5ef5

	; "Dig up" the tile if coming from underground
	ld l,Enemy.yh		; $5ef7
	ld b,(hl)		; $5ef9
	ld l,Enemy.xh		; $5efa
	ld c,(hl)		; $5efc
	ld a,BREAKABLETILESOURCE_06		; $5efd
	call tryToBreakTile		; $5eff

	; If in water, create a splash
	call objectCheckTileAtPositionIsWater		; $5f02
	jr nc,++		; $5f05

	call getFreeInteractionSlot		; $5f07
	jr nz,++		; $5f0a
	ld (hl),INTERACID_SPLASH		; $5f0c
	ld bc,$fa00		; $5f0e
	call objectCopyPositionWithOffset		; $5f11
++
	call _ecom_updateAngleTowardTarget		; $5f14
	add $02			; $5f17
	and $1c			; $5f19
	rrca			; $5f1b
	rrca			; $5f1c
	inc a			; $5f1d
	jp enemySetAnimation		; $5f1e


; Extending toward target
_pincer_head_stateB:
	call _pincer_updatePosition		; $5f21

	ld e,Enemy.var33		; $5f24
	ld a,(de)		; $5f26
	add $02			; $5f27
	cp $20			; $5f29
	jr nc,@fullyExtended	; $5f2b
	ld (de),a		; $5f2d
	ret			; $5f2e

@fullyExtended:
	call _ecom_incState		; $5f2f
	ld l,Enemy.counter1		; $5f32
	ld (hl),$08		; $5f34
	ret			; $5f36


; Staying fully extended for several frames
_pincer_head_stateC:
	call _ecom_decCounter1		; $5f37
	ret nz			; $5f3a
	ld l,e			; $5f3b
	inc (hl) ; [state]
	ret			; $5f3d


; Retracting
_pincer_head_stateD:
	call _pincer_updatePosition		; $5f3e

	ld h,d			; $5f41
	ld l,Enemy.var33		; $5f42
	dec (hl)		; $5f44
	ret nz			; $5f45

	; Fully retracted
	ld l,Enemy.counter1		; $5f46
	ld (hl),30		; $5f48

	ld l,Enemy.state		; $5f4a
	inc (hl)		; $5f4c

	ld l,Enemy.collisionType		; $5f4d
	res 7,(hl)		; $5f4f
	jp objectSetInvisible		; $5f51


; Fully retracted; on cooldown
_pincer_head_stateE:
	call _ecom_decCounter1		; $5f54
	ret nz			; $5f57

	; Cooldown over
	ld l,e			; $5f58
	ld (hl),$09 ; [state]

	; Make sure Y/X position is fully fixed back to origin
	ld l,Enemy.var31		; $5f5b
	ld e,Enemy.yh		; $5f5d
	ldi a,(hl)		; $5f5f
	ld (de),a		; $5f60
	ld e,Enemy.xh		; $5f61
	ld a,(hl)		; $5f63
	ld (de),a		; $5f64

	xor a			; $5f65
	jp enemySetAnimation		; $5f66


;;
; Subid 2-4: body of pincer (just decoration)
; @addr{5f69}
_pincer_body:
	ld a,(de)		; $5f69
	sub $08			; $5f6a
	rst_jumpTable			; $5f6c
	.dw @state8
	.dw @state9

; Initialization
@state8:
	ld a,$09		; $5f71
	ld (de),a ; [state]

	; Copy parent's base position (var31/var32)
	ld a,Object.yh		; $5f74
	call objectGetRelatedObject1Var		; $5f76
	ld e,Enemy.var31		; $5f79
	ldi a,(hl)		; $5f7b
	ld (de),a		; $5f7c
	inc l			; $5f7d
	inc e			; $5f7e
	ld a,(hl)		; $5f7f
	ld (de),a		; $5f80

	ld e,Enemy.var34		; $5f81
	ld l,Enemy.id		; $5f83
	ld a,(hl)		; $5f85
	ld (de),a		; $5f86

	ld a,$09		; $5f87
	jp enemySetAnimation		; $5f89

@state9:
	; Check if parent was deleted
	ld a,Object.id		; $5f8c
	call objectGetRelatedObject1Var		; $5f8e
	ld e,Enemy.var34		; $5f91
	ld a,(de)		; $5f93
	cp (hl)			; $5f94
	jp nz,enemyDelete		; $5f95

	; Copy parent's angle, invincibilityCounter
	ld l,Enemy.angle		; $5f98
	ld e,l			; $5f9a
	ld a,(hl)		; $5f9b
	ld (de),a		; $5f9c
	ld l,Enemy.invincibilityCounter		; $5f9d
	ld e,l			; $5f9f
	ld a,(hl)		; $5fa0
	ld (de),a		; $5fa1

	; Copy parent's visibility only if parent is in state $0b or higher
	ld l,Enemy.state		; $5fa2
	ld a,(hl)		; $5fa4
	cp $0b			; $5fa5
	jr c,++		; $5fa7

	ld l,Enemy.visible		; $5fa9
	ld e,l			; $5fab
	ld a,(hl)		; $5fac
	ld (de),a		; $5fad
++
	call _pincer_body_updateExtendedAmount		; $5fae
	jr _pincer_updatePosition		; $5fb1


;;
; Sets relatedObj1 of object 'h' to object 'c'.
; 'h' is part of the pincer's body, 'c' is the pincer's head.
; Also increments the body part's subid since that does need to be done...
; @addr{5fb3}
_pincer_setChildRelatedObj1:
	inc (hl) ; [subid]++
	ld l,Enemy.relatedObj1		; $5fb4
	ld a,Enemy.start		; $5fb6
	ldi (hl),a		; $5fb8
	ld (hl),c		; $5fb9
	ret			; $5fba

;;
; Updates position based on "base position" (var31), angle, and distance extended (var33).
; @addr{5fbb}
_pincer_updatePosition:
	ld h,d			; $5fbb
	ld l,Enemy.var31		; $5fbc
	ld b,(hl)		; $5fbe
	inc l			; $5fbf
	ld c,(hl)		; $5fc0
	inc l			; $5fc1
	ld a,(hl)		; $5fc2
	ld e,Enemy.angle		; $5fc3
	jp objectSetPositionInCircleArc		; $5fc5

;;
; Calculates value for var33 (amount extended) for a body part.
; @addr{5fc8}
_pincer_body_updateExtendedAmount:
	push hl			; $5fc8
	ld e,Enemy.subid		; $5fc9
	ld a,(de)		; $5fcb
	sub $02			; $5fcc
	rst_jumpTable			; $5fce
	.dw @subid2
	.dw @subid3
	.dw @subid4

@subid2:
	pop hl			; $5fd5
	call @getExtendedAmountDividedByFour		; $5fd6
	ld b,a			; $5fd9
	add a			; $5fda
	add b			; $5fdb
	ld (de),a		; $5fdc
	ret			; $5fdd

@subid3:
	pop hl			; $5fde
	call @getExtendedAmountDividedByFour		; $5fdf
	add a			; $5fe2
	ld (de),a		; $5fe3
	ret			; $5fe4

@subid4:
	pop hl			; $5fe5
	call @getExtendedAmountDividedByFour		; $5fe6
	ld (de),a		; $5fe9
	ret			; $5fea

@getExtendedAmountDividedByFour:
	ld l,Enemy.var33		; $5feb
	ld e,l			; $5fed
	ld a,(hl)		; $5fee
	srl a			; $5fef
	srl a			; $5ff1
	ret			; $5ff3


; ==============================================================================
; ENEMYID_BALL_AND_CHAIN_SOLDIER
;
; Variables:
;   relatedObj2: reference to PARTID_SPIKED_BALL
;   counter1: Written to by PARTID_SPIKED_BALL?
;   var30: Signal for PARTID_SPIKED_BALL.
;          0: Ball should rotate at normal speed.
;          1: Ball should rotate at double speed.
;          2: Ball should be thrown at Link.
;   var31: State to return to after switch hook is used on enemy
; ==============================================================================
enemyCode4b:
	jr z,@normalStatus	; $5ff4
	sub ENEMYSTATUS_NO_HEALTH			; $5ff6
	ret c			; $5ff8
	jr nz,@normalStatus	; $5ff9
	jp enemyDie		; $5ffb

@normalStatus:
	call _ecom_checkHazards		; $5ffe
	ld e,Enemy.state		; $6001
	ld a,(de)		; $6003
	rst_jumpTable			; $6004
	.dw _ballAndChain_state_uninitialized
	.dw _ballAndChain_state_stub
	.dw _ballAndChain_state_stub
	.dw _ballAndChain_state_switchHook
	.dw _ballAndChain_state_stub
	.dw _ballAndChain_state_stub
	.dw _ballAndChain_state_stub
	.dw _ballAndChain_state_stub
	.dw _ballAndChain_state8
	.dw _ballAndChain_state9
	.dw _ballAndChain_stateA


_ballAndChain_state_uninitialized:
	call _ballAndChain_spawnSpikedBall		; $601b
	ret nz			; $601e

	ld a,SPEED_60		; $601f
	call _ecom_setSpeedAndState8AndVisible		; $6021

	ld l,Enemy.var31		; $6024
	ld (hl),$08		; $6026
	ret			; $6028


_ballAndChain_state_switchHook:
	inc e			; $6029
	ld a,(de)		; $602a
	rst_jumpTable			; $602b
	.dw _ecom_incState2
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate1:
@substate2:
	ret			; $6034

@substate3:
	ld e,Enemy.var31		; $6035
	ld a,(de)		; $6037
	ld b,a			; $6038
	jp _ecom_fallToGroundAndSetState		; $6039


_ballAndChain_state_stub:
	ret			; $603c


; Waiting for Link to be close enough to attack
_ballAndChain_state8:
	ld c,$38		; $603d
	call objectCheckLinkWithinDistance		; $603f
	jr nc,@moveTowardLink	; $6042

	; Link is close enough
	call _ecom_incState		; $6044
	call _ballAndChain_setDefaultState		; $6047

	ld l,Enemy.counter1		; $604a
	ld (hl),90		; $604c

	; Signal PARTID_SPIKED_BALL to rotate faster
	ld l,Enemy.var30		; $604e
	inc (hl)		; $6050

	ld a,$01		; $6051
	jp enemySetAnimation		; $6053

@moveTowardLink:
	call _ecom_updateAngleTowardTarget		; $6056
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $6059

_ballAndChain_animate:
	jp enemyAnimate		; $605c


; Spinning up ball for [counter1] frames before attacking
_ballAndChain_state9:
	call _ecom_decCounter1		; $605f
	jr nz,_ballAndChain_animate	; $6062

	inc (hl) ; [counter1]
	ld l,e			; $6065
	inc (hl) ; [state]

	call _ballAndChain_setDefaultState		; $6067

	; Signal PARTID_SPIKED_BALL to begin throw toward Link
	ld l,Enemy.var30		; $606a
	inc (hl)		; $606c
	ret			; $606d


; Waiting for PARTID_SPIKED_BALL to set this object's counter1 to 0 (signalling the throw
; is done)
_ballAndChain_stateA:
	ld e,Enemy.counter1		; $606e
	ld a,(de)		; $6070
	or a			; $6071
	ret nz			; $6072

	; Throw done

	ld c,$38		; $6073
	call objectCheckLinkWithinDistance		; $6075
	ld h,d			; $6078
	ld l,Enemy.state		; $6079
	jr nc,@gotoState8	; $607b

	; Link is close; attack again immediately
	dec (hl) ; [state] = 9
	call _ballAndChain_setDefaultState		; $607e
	ld l,Enemy.counter1		; $6081
	ld (hl),90		; $6083

	ld l,Enemy.var30		; $6085
	dec (hl)		; $6087
	ret			; $6088

@gotoState8:
	; Link isn't close; go to state 8, waiting for him to be close enough
	ld (hl),$08 ; [state]
	call _ballAndChain_setDefaultState		; $608b

	ld l,Enemy.var30		; $608e
	xor a			; $6090
	ld (hl),a		; $6091
	jp enemySetAnimation		; $6092


;;
; @param[out]	zflag	z if spawned successfully
; @addr{6095}
_ballAndChain_spawnSpikedBall:
	; BUG: This checks for 4 enemy slots, but we actually need 4 part slots...
	ld b,$04		; $6095
	call checkBEnemySlotsAvailable		; $6097
	ret nz			; $609a

	; Spawn the ball
	ld b,PARTID_SPIKED_BALL		; $609b
	call _ecom_spawnProjectile		; $609d

	; Spawn the 3 parts of the chain. Their "relatedObj1" will be set to the ball (not
	; this enemy).
	ld c,h			; $60a0
	ld e,$01		; $60a1
@nextChain:
	call getFreePartSlot		; $60a3
	ld (hl),b		; $60a6
	inc l			; $60a7
	ld (hl),e		; $60a8
	ld l,Part.relatedObj1		; $60a9
	ld a,Part.start		; $60ab
	ldi (hl),a		; $60ad
	ld (hl),c		; $60ae
	inc e			; $60af
	ld a,e			; $60b0
	cp $04			; $60b1
	jr nz,@nextChain	; $60b3
	ret			; $60b5


;;
; Sets state the enemy will return to after switch hook is used on it
;
; @param	hl	Pointer to state
; @addr{60b6}
_ballAndChain_setDefaultState:
	ld a,(hl)		; $60b6
	ld l,Enemy.var31		; $60b7
	ld (hl),a		; $60b9
	ret			; $60ba


; ==============================================================================
; ENEMYID_HARDHAT_BEETLE
; ENEMYID_HARMLESS_HARDHAT_BEETLE
; ==============================================================================
enemyCode4d:
enemyCode5f:
	call _ecom_checkHazards		; $60bb
	jr z,@normalStatus	; $60be
	sub ENEMYSTATUS_NO_HEALTH			; $60c0
	ret c			; $60c2
	jp z,enemyDie		; $60c3
	dec a			; $60c6
	jp nz,_ecom_updateKnockbackAndCheckHazards		; $60c7
	ret			; $60ca

@normalStatus:
	ld e,Enemy.state		; $60cb
	ld a,(de)		; $60cd
	rst_jumpTable			; $60ce
	.dw @state_uninitialized
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw _ecom_blownByGaleSeedState
	.dw @state_stub
	.dw @state_stub
	.dw @state8

@state_uninitialized:
	ld e,Enemy.id		; $60e1
	ld a,(de)		; $60e3
	cp ENEMYID_HARMLESS_HARDHAT_BEETLE			; $60e4
	ld a,PALH_8d		; $60e6
	call z,loadPaletteHeader		; $60e8

	ld a,SPEED_60		; $60eb
	jp _ecom_setSpeedAndState8AndVisible		; $60ed

@state_stub:
	ret			; $60f0

@state8:
	call _ecom_updateAngleTowardTarget		; $60f1
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $60f4
	jp enemyAnimate		; $60f7


; ==============================================================================
; ENEMYID_LINK_MIMIC
;
; Shares code with ENEMYID_ARM_MIMIC.
; ==============================================================================
enemyCode64:
	jr z,@normalStatus	; $60fa
	sub ENEMYSTATUS_NO_HEALTH			; $60fc
	ret c			; $60fe
	jp z,enemyDie		; $60ff
	dec a			; $6102
	jp nz,_ecom_updateKnockback		; $6103
	ret			; $6106

@normalStatus:
	ld e,Enemy.state		; $6107
	ld a,(de)		; $6109
	rst_jumpTable			; $610a
	.dw @state_uninitialized
	.dw _armMimic_state_stub
	.dw _armMimic_state_stub
	.dw _armMimic_state_switchHook
	.dw _armMimic_state_stub
	.dw _ecom_blownByGaleSeedState
	.dw _armMimic_state_stub
	.dw _armMimic_state_stub
	.dw _linkMimic_state8


@state_uninitialized:
	ld a,PALH_82		; $611d
	call loadPaletteHeader		; $611f
	call _armMimic_uninitialized		; $6122
	jp objectSetVisible83		; $6125


_linkMimic_state8:
	ld a,(wDisabledObjects)		; $6128
	or a			; $612b
	ret nz			; $612c
	jr _armMimic_state8		; $612d


; ==============================================================================
; ENEMYID_ARM_MIMIC
;
; Shares code with ENEMYID_LINK_MIMIC.
;
; Variables:
;   var30: Animation index
; ==============================================================================
enemyCode4e:
	call _ecom_checkHazards		; $612f
	jr z,@normalStatus	; $6132
	sub ENEMYSTATUS_NO_HEALTH			; $6134
	ret c			; $6136
	jp z,enemyDie		; $6137
	dec a			; $613a
	jp nz,_ecom_updateKnockbackAndCheckHazards		; $613b
	ret			; $613e

@normalStatus:
	ld e,Enemy.state		; $613f
	ld a,(de)		; $6141
	rst_jumpTable			; $6142
	.dw _armMimic_uninitialized
	.dw _armMimic_state_stub
	.dw _armMimic_state_stub
	.dw _armMimic_state_switchHook
	.dw _armMimic_state_stub
	.dw _ecom_blownByGaleSeedState
	.dw _armMimic_state_stub
	.dw _armMimic_state_stub
	.dw _armMimic_state8


_armMimic_uninitialized:
	ld e,Enemy.var30		; $6155
	ld a,(w1Link.direction)		; $6157
	add $02			; $615a
	and $03			; $615c
	ld (de),a		; $615e
	call enemySetAnimation		; $615f

	ld a,SPEED_100		; $6162
	jp _ecom_setSpeedAndState8AndVisible		; $6164


_armMimic_state_switchHook:
	inc e			; $6167
	ld a,(de)		; $6168
	rst_jumpTable			; $6169
	.dw _ecom_incState2
	.dw @substate1
	.dw @substate2
	.dw _ecom_fallToGroundAndSetState8

@substate1:
@substate2:
	ret			; $6172


_armMimic_state_stub:
	ret			; $6173


; Only "normal" state; simply moves in reverse of Link's direction.
_armMimic_state8:
	; Check that Link is moving
	ld a,(wLinkAngle)		; $6174
	inc a			; $6177
	ret z			; $6178

	add $0f			; $6179
	and $1f			; $617b
	ld e,Enemy.angle		; $617d
	ld (de),a		; $617f
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $6180

	ld h,d			; $6183
	ld l,Enemy.var30		; $6184
	ld a,(w1Link.direction)		; $6186
	add $02			; $6189
	and $03			; $618b
	cp (hl)			; $618d
	jr z,@animate	; $618e

	ld (hl),a		; $6190
	call enemySetAnimation		; $6191
@animate:
	jp enemyAnimate		; $6194


; ==============================================================================
; ENEMYID_MOLDORM
;
; Variables for head (subid 1):
;   var30: Tail 1 object index
;   var31: Tail 2 object index
;   var32: Animation index
;   var33: Angular speed (added to angle)
;
; Variables for tail (subids 2-3):
;   relatedObj1: Object to follow (either the head or the tail in front)
;   var30: Index for offset buffer
;   var31/var32: Parent object's position last frame
;   var33-var3b: Offset buffer. Stores the parent's movement offsets for up to 8 frames.
; ==============================================================================
enemyCode4f:
	call _moldorm_checkHazards		; $6197
	jr z,@normalStatus	; $619a
	sub ENEMYSTATUS_NO_HEALTH			; $619c
	ret c			; $619e
	jr z,@dead	; $619f
	dec a			; $61a1
	jr nz,@knockback	; $61a2

	; ENEMYSTATUS_JUST_HIT
	; Only apply this to the head (subid 1)
	ld e,Enemy.subid		; $61a4
	ld a,(de)		; $61a6
	dec a			; $61a7
	jr nz,@normalStatus	; $61a8

	; [tail1.invincibilityCounter] = [this.invincibilityCounter]
	ld e,Enemy.invincibilityCounter		; $61aa
	ld l,e			; $61ac
	ld a,(de)		; $61ad
	ld b,a			; $61ae
	ld e,Enemy.var30		; $61af
	ld a,(de)		; $61b1
	ld h,a			; $61b2
	ld (hl),b		; $61b3

	; [tail2.invincibilityCounter] = [this.invincibilityCounter]
	inc e			; $61b4
	ld a,(de)		; $61b5
	ld h,a			; $61b6
	ld (hl),b		; $61b7
	ret			; $61b8

@dead:
	ld e,Enemy.subid		; $61b9
	ld a,(de)		; $61bb
	dec a			; $61bc
	jp nz,_moldorm_tail_delete		; $61bd

	; Head only; kill the tails.
	ld e,Enemy.var30		; $61c0
	ld a,(de)		; $61c2
	ld h,a			; $61c3
	call _ecom_killObjectH		; $61c4
	inc e			; $61c7
	ld a,(de)		; $61c8
	ld h,a			; $61c9
	call _ecom_killObjectH		; $61ca
	jp enemyDie		; $61cd

@knockback:
	ld e,Enemy.subid		; $61d0
	ld a,(de)		; $61d2
	dec a			; $61d3
	jr nz,@normalStatus	; $61d4
	jp _ecom_updateKnockbackAndCheckHazards		; $61d6

@normalStatus:
	call _ecom_getSubidAndCpStateTo08		; $61d9
	jr nc,@normalState	; $61dc
	rst_jumpTable			; $61de
	.dw _moldorm_state_uninitialized
	.dw _moldorm_state1
	.dw _moldorm_state_stub
	.dw _moldorm_state_stub
	.dw _moldorm_state_stub
	.dw _moldorm_state_stub
	.dw _moldorm_state_stub
	.dw _moldorm_state_stub

@normalState:
	dec b			; $61ef
	ld a,b			; $61f0
	rst_jumpTable			; $61f1
	.dw _moldorm_head
	.dw _moldorm_tail
	.dw _moldorm_tail


_moldorm_state_uninitialized:
	ld a,b			; $61f8
	or a			; $61f9
	jr nz,@notSpawner		; $61fa

@spawner:
	inc a			; $61fc
	ld (de),a ; [state] = 1
	jr _moldorm_state1		; $61fe

@notSpawner:
	call _ecom_setSpeedAndState8AndVisible		; $6200
	ld a,b			; $6203
	dec a			; $6204
	ret z			; $6205
	add $07			; $6206
	jp enemySetAnimation		; $6208


; Spawner; spawn the head and tails, then delete self.
_moldorm_state1:
	ld b,$03		; $620b
	call checkBEnemySlotsAvailable		; $620d
	jp nz,objectSetVisible82		; $6210

	; Spawn head
	ld b,ENEMYID_MOLDORM		; $6213
	call _ecom_spawnUncountedEnemyWithSubid01		; $6215

	; Spawn tail 1
	ld c,h			; $6218
	push hl			; $6219
	call _ecom_spawnEnemyWithSubid01		; $621a
	inc (hl) ; [subid] = 2
	call _moldorm_tail_setRelatedObj1AndCopyPosition ; Follows head

	; Spawn tail 2
	ld c,h			; $6221
	call _ecom_spawnEnemyWithSubid01		; $6222
	inc (hl)		; $6225
	inc (hl) ; [subid] = 3
	call _moldorm_tail_setRelatedObj1AndCopyPosition ; Follows tail1

	; [head.var30] = tail1
	ld b,h			; $622a
	pop hl			; $622b
	ld l,Enemy.var30		; $622c
	ld (hl),c		; $622e

	; [head.var31] = tail2
	inc l			; $622f
	ld (hl),b		; $6230

	; [head.enabled] = [this.enabled] (copy spawned index value)
	ld l,Enemy.enabled		; $6231
	ld e,l			; $6233
	ld a,(de)		; $6234
	ld (hl),a		; $6235

	call objectCopyPosition		; $6236
	jp enemyDelete		; $6239


_moldorm_state_stub:
	ret			; $623c


; Subid 1
_moldorm_head:
	ld a,(de)		; $623d
	sub $08			; $623e
	rst_jumpTable			; $6240
	.dw @state8
	.dw @state9


; Initialization
@state8:
	ld h,d			; $6245
	ld l,e			; $6246
	inc (hl) ; [state]

	ld l,Enemy.counter1		; $6248
	ld (hl),$08		; $624a

	ld l,Enemy.speed		; $624c
	ld (hl),SPEED_100		; $624e

	; Angular speed
	ld l,Enemy.var33		; $6250
	ld (hl),$02		; $6252

	call _ecom_setRandomAngle		; $6254
	jp _moldorm_head_updateAnimationFromAngle		; $6257


; Main state for head
@state9:
	call _ecom_decCounter1		; $625a
	jr nz,@applySpeed	; $625d

	ld (hl),$08 ; [counter1]

	; Angle is updated every 8 frames.
	ld l,Enemy.var33		; $6261
	ld e,Enemy.angle		; $6263
	ld a,(de)		; $6265
	add (hl)		; $6266
	and $1f			; $6267
	ld (de),a		; $6269
	call _moldorm_head_updateAnimationFromAngle		; $626a

	; 1 in 16 chance of inverting rotation every 8 frames
	call getRandomNumber_noPreserveVars		; $626d
	and $0f			; $6270
	jr nz,@applySpeed	; $6272
	ld e,Enemy.var33		; $6274
	ld a,(de)		; $6276
	cpl			; $6277
	inc a			; $6278
	ld (de),a		; $6279

@applySpeed:
	call _ecom_bounceOffWallsAndHoles		; $627a
	call nz,_moldorm_head_updateAnimationFromAngle		; $627d
	jp objectApplySpeed		; $6280


_moldorm_tail:
	ld e,Enemy.state		; $6283
	ld a,(de)		; $6285
	sub $08			; $6286
	rst_jumpTable			; $6288
	.dw @state8
	.dw @state9


; Initialization
@state8:
	ld h,d			; $628d
	ld l,e			; $628e
	inc (hl) ; [state]

	ld l,Enemy.collisionType		; $6290
	res 7,(hl)		; $6292

	; Copy parent's current position into var31/var32
	ld l,Enemy.relatedObj1+1		; $6294
	ld h,(hl)		; $6296
	ld l,Enemy.yh		; $6297
	ld e,Enemy.var31		; $6299
	ldi a,(hl)		; $629b
	ld (de),a		; $629c
	inc e			; $629d
	inc l			; $629e
	ld a,(hl)		; $629f
	ld (de),a		; $62a0

	jp _moldorm_tail_clearOffsetBuffer		; $62a1


; Main state for tail
@state9:
	; Check if parent deleted
	ld a,Object.enabled		; $62a4
	call objectGetRelatedObject1Var		; $62a6
	ld a,(hl)		; $62a9
	or a			; $62aa
	jr z,_moldorm_tail_delete	; $62ab

	; Get distance between parent's last and current Y position in high nibble of 'b'.
	; (Add 8 so it's positive.)
	ld l,Enemy.yh		; $62ad
	ld e,Enemy.var31		; $62af
	ld a,(de)		; $62b1
	ld b,a			; $62b2
	ldi a,(hl)		; $62b3
	sub b			; $62b4
	add $08			; $62b5
	swap a			; $62b7
	ld b,a			; $62b9

	; Get distance between parent's last and current X position in low nibble of 'b'.
	inc e			; $62ba
	inc l			; $62bb
	ld a,(de)		; $62bc
	ld c,a			; $62bd
	ld a,(hl)		; $62be
	sub c			; $62bf
	add $08			; $62c0
	or b			; $62c2
	ld b,a			; $62c3

	; Copy parent's Y/X to var31/var32
	ldd a,(hl)		; $62c4
	ld (de),a		; $62c5
	dec e			; $62c6
	dec l			; $62c7
	ld a,(hl)		; $62c8
	ld (de),a		; $62c9

	; Add the calculated position difference to the offset buffer starting at var33
	ld e,Enemy.var30		; $62ca
	ld a,(de)		; $62cc
	add Enemy.var33			; $62cd
	ld e,a			; $62cf
	ld a,b			; $62d0
	ld (de),a		; $62d1
	ld h,d			; $62d2
	ld l,Enemy.yh		; $62d3

	; Offset buffer index ++
	ld e,Enemy.var30		; $62d5
	ld a,(de)		; $62d7
	inc a			; $62d8
	and $07			; $62d9
	ld (de),a		; $62db

	; Read next byte in offset buffer (value from 8 frames ago) to get the value to
	; add to our current position.
	add Enemy.var33			; $62dc
	ld e,a			; $62de
	ld a,(de)		; $62df
	ld b,a			; $62e0
	and $f0			; $62e1
	swap a			; $62e3
	sub $08			; $62e5
	add (hl) ; [yh]
	ldi (hl),a		; $62e8
	inc l			; $62e9
	ld a,b			; $62ea
	and $0f			; $62eb
	sub $08			; $62ed
	add (hl) ; [xh]
	ld (hl),a		; $62f0
	ret			; $62f1

;;
; @addr{62f2}
_moldorm_tail_delete:
	call decNumEnemies		; $62f2
	jp enemyDelete		; $62f5


;;
; @param	h	Object to follow (either the head or the tail in front)
; @addr{62f8}
_moldorm_tail_setRelatedObj1AndCopyPosition:
	ld l,Enemy.relatedObj1		; $62f8
	ld a,Enemy.start		; $62fa
	ldi (hl),a		; $62fc
	ld (hl),c		; $62fd
	jp objectCopyPosition		; $62fe


;;
; @addr{6301}
_moldorm_head_updateAnimationFromAngle:
	ld e,Enemy.angle		; $6301
	ld a,(de)		; $6303
	add $02			; $6304
	and $1c			; $6306
	rrca			; $6308
	rrca			; $6309
	ld h,d			; $630a
	ld l,Enemy.var32		; $630b
	cp (hl)			; $630d
	ret z			; $630e
	ld (hl),a		; $630f
	jp enemySetAnimation		; $6310

;;
; @addr{6313}
_moldorm_tail_clearOffsetBuffer:
	ld h,d			; $6313
	ld l,Enemy.var33		; $6314
	ld b,$02		; $6316
	ld a,$88		; $6318
--
	ldi (hl),a		; $631a
	ldi (hl),a		; $631b
	ldi (hl),a		; $631c
	ldi (hl),a		; $631d
	dec b			; $631e
	jr nz,--		; $631f
	ret			; $6321


;;
; @addr{6322}
_moldorm_checkHazards:
	ld b,a			; $6322
	ld e,Enemy.subid		; $6323
	ld a,(de)		; $6325
	dec a			; $6326
	jr z,@checkHazards	; $6327

	; Tails only; check if parent fell into a hazard
	ld a,Object.var3f		; $6329
	call objectGetRelatedObject1Var		; $632b
	ld a,(hl)		; $632e
	and $07			; $632f
	jr nz,@checkHazards	; $6331
	ld a,b			; $6333
	or a			; $6334
	ret			; $6335

@checkHazards:
	ld a,b			; $6336
	jp _ecom_checkHazardsNoAnimationForHoles		; $6337


; ==============================================================================
; ENEMYID_FIREBALL_SHOOTER
; ==============================================================================
enemyCode50:
	dec a			; $633a
	ret z			; $633b
	dec a			; $633c
	ret z			; $633d
	ld e,Enemy.state		; $633e
	ld a,(de)		; $6340
	rst_jumpTable			; $6341
	.dw _fireballShooter_state_uninitialized
	.dw _fireballShooter_state1
	.dw _fireballShooter_state_stub
	.dw _fireballShooter_state_stub
	.dw _fireballShooter_state_stub
	.dw _fireballShooter_state_stub
	.dw _fireballShooter_state_stub
	.dw _fireballShooter_state_stub
	.dw _fireballShooter_state8
	.dw _fireballShooter_state9


_fireballShooter_state_uninitialized:
	ld h,d			; $6356
	ld l,e			; $6357
	inc (hl) ; [state]

	ld e,Enemy.subid		; $6359
	ld a,(de)		; $635b
	bit 7,a			; $635c
	ret z			; $635e
	ld (hl),$08 ; [state]
	ret			; $6361


; "Spawner"; spawns shooters at each appropriate tile index, then deletes self.
_fireballShooter_state1:
	xor a			; $6362
	ldh (<hFF8D),a	; $6363

	ld e,Enemy.yh		; $6365
	ld a,(de)		; $6367
	ld c,a ; c = tile index to spawn at

	ld hl,wRoomLayout		; $6369
	ld b,LARGE_ROOM_HEIGHT<<4		; $636c

@nextTile:
	ldi a,(hl)		; $636e
	cp c			; $636f
	jr nz,+++		; $6370

	push bc			; $6372
	push hl			; $6373
	ld c,l			; $6374
	dec c			; $6375
	ld b,ENEMYID_FIREBALL_SHOOTER		; $6376
	call _ecom_spawnUncountedEnemyWithSubid01		; $6378
	jr nz,@delete	; $637b

	; [child.subid] = [this.subid] | $80
	ld e,l			; $637d
	ld a,(de)		; $637e
	set 7,a			; $637f
	ldi (hl),a		; $6381

	; [child.var03] = ([hFF8D]+1)&3 (timing offset)
	ldh a,(<hFF8D)	; $6382
	inc a			; $6384
	and $03			; $6385
	ldh (<hFF8D),a	; $6387
	ld (hl),a		; $6389

	; Set child's position
	ld a,c			; $638a
	and $f0			; $638b
	add $06			; $638d
	ld l,Enemy.yh		; $638f
	ldi (hl),a		; $6391
	ld a,c			; $6392
	and $0f			; $6393
	swap a			; $6395
	add $08			; $6397
	inc l			; $6399
	ld (hl),a		; $639a

	pop hl			; $639b
	pop bc			; $639c
+++
	dec b			; $639d
	jr nz,@nextTile	; $639e

@delete:
	jp enemyDelete		; $63a0


_fireballShooter_state_stub:
	ret			; $63a3


; Initialization for "actual" shooter (not spawner)
_fireballShooter_state8:
	ld a,$09		; $63a4
	ld (de),a ; [state]

	ld e,Enemy.var03		; $63a7
	ld a,(de)		; $63a9
	ld hl,_fireballShooter_timingOffsets		; $63aa
	rst_addAToHl			; $63ad
	ld e,Enemy.counter1		; $63ae
	ld a,(hl)		; $63b0
	ld (de),a		; $63b1
	ret			; $63b2


; Main state for actual shooter
_fireballShooter_state9:
	call _fireballShooter_checkAllEnemiesKilled		; $63b3
	; BUG: This does NOT return if it's just deleted itself! This could cause counter1
	; to be dirty the next time an enemy is spawned in its former slot.

	; Wait for Link to be far enough away
	ld c,$24		; $63b6
	call objectCheckLinkWithinDistance		; $63b8
	ret c			; $63bb

	; Wait for cooldown
	call _ecom_decCounter1		; $63bc
	ret nz			; $63bf

	ld b,PARTID_GOPONGA_PROJECTILE		; $63c0
	call _ecom_spawnProjectile		; $63c2

	; Random cooldown between $c0-$c7
	call getRandomNumber_noPreserveVars		; $63c5
	and $07			; $63c8
	add $c0			; $63ca
	ld e,Enemy.counter1		; $63cc
	ld (de),a		; $63ce
	ret			; $63cf


_fireballShooter_timingOffsets:
	.db $4e $7e $ae $de


;;
; For subid $81 only, this deletes itself when all enemies are killed.
; @addr{63d4}
_fireballShooter_checkAllEnemiesKilled:
	ld e,Enemy.subid	; $63d4
	ld a,(de)		; $63d6
	cp $81			; $63d7
	ret nz			; $63d9
	ld a,(wNumEnemies)		; $63da
	or a			; $63dd
	ret nz			; $63de
	jp enemyDelete		; $63df


; ==============================================================================
; ENEMYID_BEETLE
;
; Variables for spawner (subid 0):
;   var30: Number of beetles spawned in? It's never actually used, and it doesn't seem to
;          update correctly, so this was probably for some abandoned idea.
;
; Variables for actual beetles (subid 1+):
;   relatedObj1: Reference to spawner object (optional)
; ==============================================================================
enemyCode51:
	call _beetle_checkHazards		; $63e2
	or a			; $63e5
	jr z,@normalStatus	; $63e6
	sub ENEMYSTATUS_NO_HEALTH			; $63e8
	ret c			; $63ea
	jr z,@dead	; $63eb
	dec a			; $63ed
	jp nz,_ecom_updateKnockbackAndCheckHazards		; $63ee

	; ENEMYSTATUS_JUST_HIT

	ld e,Enemy.subid		; $63f1
	ld a,(de)		; $63f3
	cp $02			; $63f4
	ret nz			; $63f6

	ld e,Enemy.var2a		; $63f7
	ld a,(de)		; $63f9
	cp $80|ITEMCOLLISION_LINK			; $63fa
	ret z			; $63fc

	ld h,d			; $63fd
	ld l,Enemy.state		; $63fe
	ld (hl),$0a		; $6400

	ld l,Enemy.counter1		; $6402
	ld (hl),$01		; $6404
	ret			; $6406

@dead:
	ld e,Enemy.subid		; $6407
	ld a,(de)		; $6409
	dec a			; $640a
	jr nz,++		; $640b

	; Subid 1 only (falling from sky): Update spawner's var30.
	; Since the spawner spawns subid 2, this is probably broken... (not that it
	; matters since the spawner doesn't check its var30 anyway)
	ld e,Enemy.relatedObj1+1		; $640d
	ld a,(de)		; $640f
	or a			; $6410
	jr z,++			; $6411
	ld a,Object.var30		; $6413
	call objectGetRelatedObject1Var		; $6415
	dec (hl)		; $6418
++
	jp enemyDie		; $6419

@normalStatus:
	call _ecom_getSubidAndCpStateTo08		; $641c
	jr nc,@normalState	; $641f
	rst_jumpTable			; $6421
	.dw _beetle_state_uninitialized
	.dw _beetle_state_spawner
	.dw _beetle_state_stub
	.dw _beetle_state_switchHook
	.dw _beetle_state_stub
	.dw _beetle_state_galeSeed
	.dw _beetle_state_stub
	.dw _beetle_state_stub

@normalState:
	dec b			; $6432
	ld a,b			; $6433
	rst_jumpTable			; $6434
	.dw _beetle_subid1
	.dw _beetle_subid2
	.dw _beetle_subid3


_beetle_state_uninitialized:
	ld a,b			; $643b
	or a			; $643c
	ld a,SPEED_80		; $643d
	jp nz,_ecom_setSpeedAndState8		; $643f

	; Subid 0
	ld a,$01		; $6442
	ld (de),a ; [state]


_beetle_state_spawner:
	call _ecom_decCounter2		; $6445
	ret nz			; $6448

	; Only spawn beetles when Link is close
	ld c,$20		; $6449
	call objectCheckLinkWithinDistance		; $644b
	ret nc			; $644e

	ld e,Enemy.counter2		; $644f
	ld a,90		; $6451
	ld (de),a		; $6453

	ld b,ENEMYID_BEETLE		; $6454
	call _ecom_spawnEnemyWithSubid01		; $6456
	ret nz			; $6459
	inc (hl) ; [subid] = 2
	jp objectCopyPosition		; $645b


_beetle_state_galeSeed:
	call _ecom_galeSeedEffect		; $645e
	ret c			; $6461

	ld e,Enemy.relatedObj1+1		; $6462
	ld a,(de)		; $6464
	or a			; $6465
	jr z,++			; $6466

	ld h,a			; $6468
	ld l,Enemy.var30		; $6469
	dec (hl)		; $646b
++
	call decNumEnemies		; $646c
	jp enemyDelete		; $646f


_beetle_state_switchHook:
	inc e			; $6472
	ld a,(de)		; $6473
	rst_jumpTable			; $6474
	.dw _ecom_incState2
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate1:
@substate2:
	ret			; $647d

@substate3:
	ld b,$0a		; $647e
	jp _ecom_fallToGroundAndSetState		; $6480


_beetle_state_stub:
	ret			; $6483


; Falls from the sky
_beetle_subid1:
	ld a,(de)		; $6484
	sub $08			; $6485
	rst_jumpTable			; $6487
	.dw @state8
	.dw @state9
	.dw _beetle_stateA


; Initialization
@state8:
	ld h,d			; $648e
	ld l,e			; $648f
	inc (hl) ; [state]

	ld l,Enemy.collisionType		; $6491
	set 7,(hl)		; $6493

	ld c,$08		; $6495
	call _ecom_setZAboveScreen		; $6497

	call objectSetVisiblec1		; $649a

	ld a,SND_FALLINHOLE		; $649d
	jp playSound		; $649f


; Falling in from above the screen
@state9:
	ld c,$0e		; $64a2
	call objectUpdateSpeedZ_paramC		; $64a4
	ret nz			; $64a7

	; [speedZ] = 0
	ld l,Enemy.speedZ		; $64a8
	ldi (hl),a		; $64aa
	ld (hl),a		; $64ab

	ld l,Enemy.state		; $64ac
	inc (hl)		; $64ae

	call objectSetVisiblec2		; $64af

	ld a,SND_BOMB_LAND		; $64b2
	call playSound		; $64b4

	call _beetle_chooseRandomAngleAndCounter1		; $64b7
	jr _beetle_animate		; $64ba


; Common beetle state
_beetle_stateA:
	call _ecom_decCounter1		; $64bc
	call z,_beetle_chooseRandomAngleAndCounter1		; $64bf
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $64c2

_beetle_animate:
	jp enemyAnimate		; $64c5


; Spawns in instantly
_beetle_subid2:
	ld a,(de)		; $64c8
	sub $08			; $64c9
	rst_jumpTable			; $64cb
	.dw @state8
	.dw @state9
	.dw _beetle_stateA


; Initialization
@state8:
	ld h,d			; $64d2
	ld l,e			; $64d3
	inc (hl) ; [state]

	ld l,Enemy.counter1		; $64d5
	ld (hl),30		; $64d7

	call _ecom_updateCardinalAngleTowardTarget		; $64d9
	jp objectSetVisiblec2		; $64dc


; Moving toward Link for 30 frames, before starting random movement
@state9:
	call _ecom_decCounter1		; $64df
	jr nz,@keepMovingTowardLink	; $64e2

	inc (hl) ; [counter1] = 1
	ld l,e			; $64e5
	inc (hl) ; [state]
	jr _beetle_stateA		; $64e7

@keepMovingTowardLink:
	ld a,(hl)		; $64e9
	cp 22			; $64ea
	jr nz,++		; $64ec
	ld l,Enemy.collisionType		; $64ee
	set 7,(hl)		; $64f0
++
	call _ecom_applyVelocityForSideviewEnemy		; $64f2
	jr _beetle_animate		; $64f5


; "Bounces in" when it spawns (dug up from the ground)
_beetle_subid3:
	ld a,(de)		; $64f7
	sub $08			; $64f8
	rst_jumpTable			; $64fa
	.dw @state8
	.dw @state9
	.dw _beetle_stateA


; Initialization
@state8:
	ld h,d			; $6501
	ld l,e			; $6502
	inc (hl) ; [state]

	ld l,Enemy.speedZ		; $6504
	ld a,<(-$102)		; $6506
	ldi (hl),a		; $6508
	ld (hl),>(-$102)		; $6509

	ld l,Enemy.speed		; $650b
	ld (hl),SPEED_c0		; $650d

	; Bounce in the direction Link is facing
	ld l,Enemy.angle		; $650f
	ld a,(w1Link.direction)		; $6511
	swap a			; $6514
	rrca			; $6516
	ld (hl),a		; $6517

	jp objectSetVisiblec2		; $6518


; Bouncing
@state9:
	ld c,$0e		; $651b
	call objectUpdateSpeedZAndBounce		; $651d
	jr c,@doneBouncing	; $6520

	ld a,SND_BOMB_LAND		; $6522
	call z,playSound		; $6524

	; Enable collisions when it starts moving back down
	ld e,Enemy.speedZ+1		; $6527
	ld a,(de)		; $6529
	or a			; $652a
	jr nz,++		; $652b
	ld h,d			; $652d
	ld l,Enemy.collisionType		; $652e
	set 7,(hl)		; $6530
++
	jp _ecom_applyVelocityForSideviewEnemyNoHoles		; $6532

@doneBouncing:
	call _ecom_incState		; $6535
	ld l,Enemy.speed		; $6538
	ld (hl),SPEED_80		; $653a


;;
; @addr{653c}
_beetle_chooseRandomAngleAndCounter1:
	ld bc,$071c		; $653c
	call _ecom_randomBitwiseAndBCE		; $653f
	ld e,Enemy.angle		; $6542
	ld a,c			; $6544
	ld (de),a		; $6545

	ld a,b			; $6546
	ld hl,@counter1Vals		; $6547
	rst_addAToHl			; $654a
	ld e,Enemy.counter1		; $654b
	ld a,(hl)		; $654d
	ld (de),a		; $654e
	ret			; $654f

@counter1Vals:
	.db 15 30 30 60 60 60 90 90



;;
; Beetle has custom checkHazards function so it can decrease the spawner's var30 (number
; of spawned
; @addr{6558}
_beetle_checkHazards:
	ld b,a			; $6558
	ld e,Enemy.state		; $6559
	ld a,(de)		; $655b
	cp $0a			; $655c
	ld a,b			; $655e
	ret c			; $655f

	; Check if currently sinking in lava? (water doesn't count?)
	ld h,d			; $6560
	ld l,Enemy.var3f		; $6561
	bit 1,(hl)		; $6563
	jr z,@checkHazards	; $6565

	; When [counter1] == 59, decrement spawner's var30 if it exists?
	ld l,Enemy.counter1		; $6567
	ld a,(hl)		; $6569
	cp 59			; $656a
	jr nz,@checkHazards	; $656c

	ld l,Enemy.relatedObj1+1		; $656e
	ld a,(hl)		; $6570
	or a			; $6571
	jr z,@checkHazards	; $6572

	ld h,a			; $6574
	ld l,Enemy.var30		; $6575
	dec (hl)		; $6577

@checkHazards:
	ld a,b			; $6578
	jp _ecom_checkHazards		; $6579


; ==============================================================================
; ENEMYID_FLYING_TILE
;
; Variables:
;   var30/var31: Pointer to current address in _flyingTile_layoutData
; ==============================================================================
enemyCode52:
	jr z,@normalStatus	; $657c
	sub ENEMYSTATUS_NO_HEALTH			; $657e
	ret c			; $6580
	jp _flyingTile_dead		; $6581

@normalStatus:
	ld e,Enemy.state		; $6584
	ld a,(de)		; $6586
	rst_jumpTable			; $6587
	.dw _flyingTile_state_uninitialized
	.dw _flyingTile_state_spawner
	.dw _flyingTile_state_stub
	.dw _flyingTile_state_stub
	.dw _flyingTile_state_stub
	.dw _flyingTile_state_stub
	.dw _flyingTile_state_stub
	.dw _flyingTile_state_stub
	.dw _flyingTile_state8
	.dw _flyingTile_state9
	.dw _flyingTile_stateA
	.dw _flyingTile_stateB


_flyingTile_state_uninitialized:
	ld e,Enemy.subid		; $65a0
	ld a,(de)		; $65a2
	rlca			; $65a3
	ld a,SPEED_1c0		; $65a4
	jp c,_ecom_setSpeedAndState8		; $65a6

	; Subids $00-$7f only
	ld e,Enemy.state		; $65a9
	ld a,$01		; $65ab
	ld (de),a		; $65ad
	ret			; $65ae


_flyingTile_state_spawner:
	inc e			; $65af
	ld a,(de) ; [state2]
	rst_jumpTable			; $65b1
	.dw @substate0
	.dw @substate1

@substate0:
	ld h,d			; $65b6
	ld l,e			; $65b7
	inc (hl) ; [state2]

	inc l			; $65b9
	ld (hl),120 ; [counter1]

	ld e,Enemy.subid		; $65bc
	ld a,(de)		; $65be
	ld hl,_flyingTile_layoutData		; $65bf
	rst_addDoubleIndex			; $65c2
	ldi a,(hl)		; $65c3
	ld h,(hl)		; $65c4
	ld l,a			; $65c5

	ld e,Enemy.var03		; $65c6
	ldi a,(hl)		; $65c8
	ld (de),a		; $65c9


;;
; @param	hl	Address to save to var30/var31
; @addr{65ca}
@flyingTile_saveTileDataAddress:
	ld e,Enemy.var30		; $65ca
	ld a,l			; $65cc
	ld (de),a		; $65cd
	inc e			; $65ce
	ld a,h			; $65cf
	ld (de),a		; $65d0
	ret			; $65d1

@substate1:
	call _ecom_decCounter1		; $65d2
	ret nz			; $65d5

	ld (hl),60		; $65d6

	; Retrieve address in _flyingTile_layoutData
	ld l,Enemy.var30		; $65d8
	ldi a,(hl)		; $65da
	ld h,(hl)		; $65db
	ld l,a			; $65dc

	; Get next position to spawn tile at
	ldi a,(hl)		; $65dd
	ld c,a			; $65de
	push hl			; $65df

	call @flyingTile_saveTileDataAddress		; $65e0
	ld b,ENEMYID_FLYING_TILE		; $65e3
	call _ecom_spawnEnemyWithSubid01		; $65e5
	jr nz,++		; $65e8

	; [child.subid] = [this.var03]
	ld l,Enemy.subid		; $65ea
	ld e,Enemy.var03		; $65ec
	ld a,(de)		; $65ee
	ld (hl),a		; $65ef

	ld l,Enemy.yh		; $65f0
	call setShortPosition_paramC		; $65f2
++
	pop hl			; $65f5
	ld a,(hl)		; $65f6
	or a			; $65f7
	ret nz			; $65f8

	; Spawned all tiles; delete the spawner.
	jp _flyingTile_delete		; $65f9


_flyingTile_state_stub:
	ret			; $65fc


; Initialization of actual flying tile (not spawner)
_flyingTile_state8:
	ld h,d			; $65fd
	ld l,e			; $65fe
	inc (hl) ; [state]

	ld l,Enemy.collisionType		; $6600
	set 7,(hl)		; $6602

	call _flyingTile_overwriteTileHere		; $6604
	jp objectSetVisiblec2		; $6607


; Moving up before charging at Link
_flyingTile_state9:
	ld h,d			; $660a
	ld l,Enemy.z		; $660b
	ld a,(hl)		; $660d
	sub <($0080)			; $660e
	ldi (hl),a		; $6610
	ld a,(hl)		; $6611
	sbc >($0080)			; $6612
	ld (hl),a		; $6614

	cp $fd			; $6615
	jr nc,_flyingTile_animate		; $6617

	; Moved high enoguh
	ld l,e			; $6619
	inc (hl) ; [state]
	ld l,Enemy.counter1		; $661b
	ld (hl),$0f		; $661d

_flyingTile_animate:
	jp enemyAnimate		; $661f


; Staying in place for [counter1] frames before charging Link
_flyingTile_stateA:
	call _ecom_decCounter1		; $6622
	jr nz,_flyingTile_animate	; $6625

	ld l,e			; $6627
	inc (hl) ; [state]

	call _ecom_updateAngleTowardTarget		; $6629
	jr _flyingTile_animate		; $662c


; Charging at Link
_flyingTile_stateB:
	call objectApplySpeed		; $662e
	call objectCheckTileCollision_allowHoles		; $6631
	jr nc,_flyingTile_animate	; $6634


;;
; @addr{6636}
_flyingTile_dead:
	ld b,INTERACID_ROCKDEBRIS		; $6636
	call objectCreateInteractionWithSubid00		; $6638

;;
; @addr{663b}
_flyingTile_delete:
	call decNumEnemies		; $663b
	jp enemyDelete		; $663e

;;
; Overwrites the tile at this position with whatever it should become after a flying tile
; is created there (depends on subid).
; @addr{6641}
_flyingTile_overwriteTileHere:
	call objectGetShortPosition		; $6641
	ld c,a			; $6644
	ld e,Enemy.subid		; $6645
	ld a,(de)		; $6647
	and $0f			; $6648
	ld hl,@tileReplacements		; $664a
	rst_addAToHl			; $664d
	ld a,(hl)		; $664e
	jp setTile		; $664f


@tileReplacements:
	.db $a0 $f3 $f4 $4c $a4


_flyingTile_layoutData:
	.dw @subid0
	.dw @subid1
	.dw @subid2

; First byte is value for var03 (subid for spawned children).
; All remaining bytes are positions at which to spawn flying tiles.
; Ends when it reads $00.
@subid0:
	.db $80
	.db $57 $56 $46 $47 $48 $58 $68 $67
	.db $66 $65 $55 $45 $36 $37 $38 $49
	.db $59 $69 $78 $77 $76 $54 $5a
	.db $00

@subid1:
	.db $80
	.db $57 $46 $48 $39 $35 $26 $37 $59
	.db $49 $38 $29 $28 $36 $45 $56 $58
	.db $27 $47 $55 $25
	.db $00

@subid2:
	.db $80
	.db $67 $54 $5a $47 $34 $3a $76 $38
	.db $78 $36 $58 $45 $49 $56 $65 $69
	.db $00


; ==============================================================================
; ENEMYID_DRAGONFLY
; ==============================================================================
enemyCode53:
	ld e,Enemy.state		; $669e
	ld a,(de)		; $66a0
	rst_jumpTable			; $66a1
	.dw _dragonfly_state0
	.dw _dragonfly_state1
	.dw _dragonfly_state2
	.dw _dragonfly_state3
	.dw _dragonfly_state4
	.dw _dragonfly_state5


; Initialization
_dragonfly_state0:
	ld h,d			; $66ae
	ld l,e			; $66af
	inc (hl) ; [state]

	ld l,Enemy.subid		; $66b1
	ld a,(hl)		; $66b3
	ld l,Enemy.oamFlagsBackup		; $66b4
	ldi (hl),a		; $66b6
	ld (hl),a		; $66b7

	ld l,Enemy.zh		; $66b8
	ld (hl),-$08		; $66ba
	jp objectSetVisiblec1		; $66bc


; Choosing new direction to move in
_dragonfly_state1:
	ld h,d			; $66bf
	ld l,e			; $66c0
	inc (hl) ; [state]

	ld l,Enemy.counter1		; $66c2
	ld (hl),$03		; $66c4

	ld l,Enemy.speed		; $66c6
	ld (hl),SPEED_200		; $66c8

	call getRandomNumber_noPreserveVars		; $66ca
	and $06			; $66cd
	ld c,a			; $66cf

	ld b,$00		; $66d0
	ld e,Enemy.yh		; $66d2
	ld a,(de)		; $66d4
	cp (SMALL_ROOM_HEIGHT/2)<<4			; $66d5
	jr c,+			; $66d7
	inc b			; $66d9
+
	ld e,Enemy.xh		; $66da
	ld a,(de)		; $66dc
	cp (SMALL_ROOM_WIDTH/2)<<4			; $66dd
	jr c,+			; $66df
	set 1,b			; $66e1
+
	ld a,b			; $66e3
	ld hl,@angleVals		; $66e4
	rst_addAToHl			; $66e7
	ld a,(hl)		; $66e8
	add c			; $66e9
	and $1f			; $66ea
	ld e,Enemy.angle		; $66ec
	ld (de),a		; $66ee

	; Update animation
	ld e,Enemy.angle		; $66ef
	ld a,(de)		; $66f1
	ld b,a			; $66f2
	and $0f			; $66f3
	ret z			; $66f5

	ld a,b			; $66f6
	cp $10			; $66f7
	ld a,$01		; $66f9
	jr c,+			; $66fb
	dec a			; $66fd
+
	jp enemySetAnimation		; $66fe

@angleVals:
	.db $08 $02 $12 $18


; Move in given direction for 3 frames at SPEED_200
_dragonfly_state2:
	call _dragonfly_applySpeed		; $6705
	jr nz,@nextState	; $6708

	call _ecom_decCounter1		; $670a
	jr nz,_dragonfly_animate	; $670d

@nextState:
	call _ecom_incState		; $670f
	ld l,Enemy.counter1		; $6712
	ld (hl),$0c		; $6714

_dragonfly_animate:
	jp enemyAnimate		; $6716


; Slowing down over 12 frames, eventually reaching SPEED_140
_dragonfly_state3:
	call _dragonfly_applySpeed		; $6719
	jr nz,@nextState	; $671c

	call _ecom_decCounter1		; $671e
	jr z,@nextState	; $6721

	ld a,(hl) ; [counter1]
	rrca			; $6724
	jr nc,_dragonfly_animate	; $6725

	ld l,Enemy.speed		; $6727
	ld a,(hl)		; $6729
	sub SPEED_20			; $672a
	ld (hl),a		; $672c
	jr _dragonfly_animate		; $672d

@nextState:
	ld e,Enemy.state		; $672f
	ld a,$04		; $6731
	ld (de),a		; $6733

	; Set counter1 somewhere in range $18-$1f
	call getRandomNumber_noPreserveVars		; $6734
	and $07			; $6737
	add $18			; $6739
	ld e,Enemy.counter1		; $673b
	ld (de),a		; $673d
	jr _dragonfly_animate		; $673e


; Moving at SPEED_140 for between 24-31 frames
_dragonfly_state4:
	call _dragonfly_applySpeed		; $6740
	jr nz,@nextState	; $6743

	call _ecom_decCounter1		; $6745
	jr nz,_dragonfly_animate	; $6748

@nextState:
	call getRandomNumber_noPreserveVars		; $674a
	and $7f			; $674d
	add $20			; $674f
	ld e,Enemy.counter1		; $6751
	ld (de),a		; $6753

	ld e,Enemy.state		; $6754
	ld a,$05		; $6756
	ld (de),a		; $6758
	jr _dragonfly_animate		; $6759


; Holding still for [counter1] frames
_dragonfly_state5:
	call _ecom_decCounter1		; $675b
	jr nz,_dragonfly_animate	; $675e

	ld l,e			; $6760
	ld (hl),$01 ; [state]
	jr _dragonfly_animate		; $6763


;;
; @param[out]	zflag	nz if touched a wall
; @addr{6765}
_dragonfly_applySpeed:
	ld a,$02 ; Only screen boundaries count as walls
	call _ecom_getSideviewAdjacentWallsBitset		; $6767
	ret nz			; $676a
	call objectApplySpeed		; $676b
	xor a			; $676e
	ret			; $676f


; ==============================================================================
; ENEMYID_BUSH_OR_ROCK
;
; Variables:
;   var30: Enemy ID of parent object
; ==============================================================================
enemyCode58:
	jr z,@normalStatus	; $6770
	sub ENEMYSTATUS_NO_HEALTH			; $6772
	ret c			; $6774
	jp z,@destroyed		; $6775

@normalStatus:
	ld e,Enemy.state		; $6778
	ld a,(de)		; $677a
	rst_jumpTable			; $677b
	.dw @state_uninitialized
	.dw @state_stub
	.dw @state_grabbed
	.dw @state_switchHook
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state_stub
	.dw @state8


@state_uninitialized:
	; Initialize enemyCollisionMode and load tile to mimic
	ld e,Enemy.subid		; $678e
	ld a,(de)		; $6790
	ld hl,@collisionAndTileData		; $6791
	rst_addDoubleIndex			; $6794

	ld e,Enemy.enemyCollisionMode		; $6795
	ldi a,(hl)		; $6797
	ld (de),a		; $6798

	ld a,(hl)		; $6799
	call objectMimicBgTile		; $679a

	call @checkDisableDestruction		; $679d
	call _ecom_setSpeedAndState8		; $67a0
	call @copyParentPosition		; $67a3
	jr @setPriorityRelativeToLink		; $67a6


@collisionAndTileData:
	.db ENEMYCOLLISION_BUSH, TILEINDEX_OVERWORLD_BUSH ; Subid 0
	.db ENEMYCOLLISION_BUSH, TILEINDEX_DUNGEON_BUSH   ; Subid 1
	.db ENEMYCOLLISION_ROCK,           TILEINDEX_DUNGEON_POT    ; Subid 2
	.db ENEMYCOLLISION_ROCK,           TILEINDEX_OVERWORLD_ROCK ; Subid 3



@state_grabbed:
	inc e			; $67b0
	ld a,(de)		; $67b1
	rst_jumpTable			; $67b2
	.dw @@substate0
	.dw @@substate1
	.dw @@substate2
	.dw @@substate3

@@substate0: ; Just picked up
	ld h,d			; $67bb
	ld l,e			; $67bc
	inc (hl)		; $67bd

	ld l,Enemy.collisionType		; $67be
	res 7,(hl)		; $67c0

	xor a			; $67c2
	ld (wLinkGrabState2),a		; $67c3
	call @makeParentEnemyVisibleAndRemoveReference		; $67c6
	jp objectSetVisible81		; $67c9

@@substate1: ; Being held
	ret			; $67cc

@@substate2: ; Being thrown
	ld h,d			; $67cd

	; No longer persist between screens
	ld l,Enemy.enabled		; $67ce
	res 1,(hl)		; $67d0

	ld l,Enemy.zh		; $67d2
	bit 7,(hl)		; $67d4
	ret nz			; $67d6

@@substate3:
	call objectSetPriorityRelativeToLink		; $67d7
	jr @makeDebrisAndDelete		; $67da


@state_switchHook:
	inc e			; $67dc
	ld a,(de)		; $67dd
	rst_jumpTable			; $67de
	.dw @@substate0
	.dw @@substate1
	.dw @@substate2
	.dw @@substate3

@@substate0:
	call @makeParentEnemyVisibleAndRemoveReference		; $67e7
	jp _ecom_incState2		; $67ea

@@substate1:
@@substate2:
	ret			; $67ed

@@substate3:
	ld c,$20		; $67ee
	call objectUpdateSpeedZ_paramC		; $67f0
	ret nz			; $67f3
	jr @makeDebrisAndDelete		; $67f4


@state_stub:
	ret			; $67f6


@state8:
	; Check if parent object's type has changed, if so, delete self?
	ld a,Object.id		; $67f7
	call objectGetRelatedObject1Var		; $67f9
	ld e,Enemy.var30		; $67fc
	ld a,(de)		; $67fe
	cp (hl)			; $67ff
	jp nz,enemyDelete		; $6800

	ld l,Enemy.var03		; $6803
	ld a,(hl)		; $6805
	rlca			; $6806
	call c,objectAddToGrabbableObjectBuffer		; $6807
	call @copyParentPosition		; $680a

@setPriorityRelativeToLink:
	jp objectSetPriorityRelativeToLink		; $680d


@destroyed:
	call @makeParentEnemyVisibleAndRemoveReference		; $6810

@makeDebrisAndDelete:
	ld e,Enemy.subid		; $6813
	ld a,(de)		; $6815
	ld hl,@debrisTypes		; $6816
	rst_addAToHl			; $6819
	ld b,(hl)		; $681a
	call objectCreateInteractionWithSubid00		; $681b
	jp enemyDelete		; $681e

; Debris for each subid (0-3)
@debrisTypes:
	.db INTERACID_GRASSDEBRIS
	.db INTERACID_GRASSDEBRIS
	.db INTERACID_ROCKDEBRIS
	.db INTERACID_ROCKDEBRIS

;;
; Make parent visible, remove self from Parent.relatedObj2
; @addr{6825}
@makeParentEnemyVisibleAndRemoveReference:
	ld a,Object.visible		; $6825
	call objectGetRelatedObject1Var		; $6827
	set 7,(hl)		; $682a
	ld l,Enemy.relatedObj2		; $682c
	xor a			; $682e
	ldi (hl),a		; $682f
	ld (hl),a		; $6830
	ret			; $6831

;;
; Copies parent position, with a Z offset determined by parent.var03.
; @addr{6832}
@copyParentPosition:
	ld a,Object.yh		; $6832
	call objectGetRelatedObject1Var		; $6834
	call objectTakePosition		; $6837

	ld l,Enemy.var03		; $683a
	ld a,(hl)		; $683c
	and $03			; $683d
	ld hl,@zVals		; $683f
	rst_addAToHl			; $6842
	ld e,Enemy.zh		; $6843
	ld a,(de)		; $6845
	add (hl)		; $6846
	ld (de),a		; $6847
	ret			; $6848

@zVals:
	.db $00 $fc $f8 $f4

;;
; Disable bush destruction for deku scrubs only.
; @addr{684d}
@checkDisableDestruction:
	ld a,Object.id		; $684d
	call objectGetRelatedObject1Var		; $684f
	ld e,Enemy.var30		; $6852
	ld a,(hl)		; $6854
	ld (de),a		; $6855

	; Don't allow destruction of bush for deku scrubs
	cp ENEMYID_DEKU_SCRUB			; $6856
	ret nz			; $6858
	ld e,Enemy.enemyCollisionMode		; $6859
	ld a,ENEMYCOLLISION_ROCK		; $685b
	ld (de),a		; $685d
	ret			; $685e


; ==============================================================================
; ENEMYID_ITEM_DROP_PRODUCER
;
; Variables:
;   var30: Tile at position (item drop will spawn when this changes)
; ==============================================================================
enemyCode59:
	ld e,Enemy.state		; $685f
	ld a,(de)		; $6861
	or a			; $6862
	jr nz,@state1		; $6863

@state0:
	; Initialization
	ld a,$01		; $6865
	ld (de),a ; [state]
	call objectGetTileAtPosition		; $6868
	ld e,Enemy.var30		; $686b
	ld (de),a		; $686d

@state1
	call objectGetTileAtPosition		; $686e
	ld h,d			; $6871
	ld l,Enemy.var30		; $6872
	cp (hl)			; $6874
	ret z			; $6875

	; Tile has changed.

	; Delete self if Link can't get the item drop yet (ie. doesn't have bombs)
	ld e,Enemy.subid		; $6876
	ld a,(de)		; $6878
	call checkItemDropUnavailable		; $6879
	jp z,enemyDelete		; $687c

	call getFreePartSlot		; $687f
	ret nz			; $6882
	ld (hl),PARTID_ITEM_DROP		; $6883

	; [child.subid] = [this.subid]
	inc l			; $6885
	ld e,Enemy.subid		; $6886
	ld a,(de)		; $6888
	ld (hl),a		; $6889

	call objectCopyPosition		; $688a
	call markEnemyAsKilledInRoom		; $688d
	jp enemyDelete		; $6890


; ==============================================================================
; ENEMYID_SEEDS_ON_TREE
;
; Variables:
;   var03: Child "PARTID_SEED_ON_TREE" objects write here when Link touches them?
; ==============================================================================
enemyCode5a:
	ld e,Enemy.state	; $6893
	ld a,(de)		; $6895
	or a			; $6896
	jr nz,@state1	; $6897


; Initialization
@state0:
	ld a,$01		; $6899
	ld (de),a ; [state]

	; Locate tree
	ld a,TILEINDEX_MYSTICAL_TREE_TL		; $689c
	call findTileInRoom		; $689e
	jp nz,interactionDelete ; BUG: Wrong function call! (see below)

	; Move to that position
	ld c,l			; $68a4
	ld h,d			; $68a5
	ld l,Enemy.yh		; $68a6
	call setShortPosition_paramC		; $68a8
	ld bc,$0808		; $68ab
	call objectCopyPositionWithOffset		; $68ae

	ld e,Enemy.subid	; $68b1
	ld a,(de)		; $68b3
	and $0f			; $68b4
	ld hl,wSeedTreeRefilledBitset		; $68b6
	call checkFlag		; $68b9
	jp z,interactionDelete		; $68bc

	; BUG: Above function call is wrong! Should be "enemyDelete"!
	; If a seed tree's seeds are exhausted, instead of deleting this object, it will
	; try to delete the interaction in the corresponding spot!
	; This is not be very noticeable, because often this will be in slot $d0, which
	; for interactions, is reserved for items from chests and stuff like that. But
	; that can be manipulated by digging up enemies from the ground...

	ld a,(de)		; $68bf
	swap a			; $68c0
	and $0f			; $68c2
	ldh (<hFF8B),a	; $68c4

	; Spawn the 3 seed objects
	xor a			; $68c6
	call @addSeed		; $68c7
	ld a,$01		; $68ca
	call @addSeed		; $68cc
	ld a,$02		; $68cf
@addSeed:
	ld hl,@positionOffsets		; $68d1
	rst_addDoubleIndex			; $68d4
	ld e,Enemy.yh		; $68d5
	ld a,(de)		; $68d7
	add (hl)		; $68d8
	inc hl			; $68d9
	ld b,a			; $68da
	ld e,Enemy.xh		; $68db
	ld a,(de)		; $68dd
	add (hl)		; $68de
	ld c,a			; $68df

	call getFreePartSlot		; $68e0
	ld (hl),PARTID_SEED_ON_TREE		; $68e3
	inc l			; $68e5
	ldh a,(<hFF8B)	; $68e6
	ld (hl),a ; [subid]

	ld l,Part.yh		; $68e9
	ld (hl),b		; $68eb
	ld l,Part.xh		; $68ec
	ld (hl),c		; $68ee

	ld l,Part.relatedObj2	; $68ef
	ld (hl),Enemy.start	; $68f1
	inc l			; $68f3
	ld (hl),d		; $68f4
	ret			; $68f5

@positionOffsets:
	.db $f8 $00
	.db $00 $f8
	.db $00 $08


@state1:
	; Waiting for one of the PARTID_SEED_ON_TREE objects to write to var03, indicating
	; that they were grabbed
	ld e,Enemy.var03
	ld a,(de)		; $68fe
	or a			; $68ff
	ret z			; $6900

	; Mark seeds as taken
	ld e,Enemy.subid	; $6901
	ld a,(de)		; $6903
	and $0f			; $6904
	ld hl,wSeedTreeRefilledBitset		; $6906
	call unsetFlag		; $6909

	jp enemyDelete		; $690c


; ==============================================================================
; ENEMYID_TWINROVA_ICE
;
; Variables:
;   var3e: ?
; ==============================================================================
enemyCode5d:
	jr z,@normalStatus	; $690f
	sub ENEMYSTATUS_NO_HEALTH			; $6911
	ret c			; $6913

	; Hit something
	ld e,Enemy.var2a		; $6914
	ld a,(de)		; $6916
	cp $80|ITEMCOLLISION_LINK			; $6917
	jr z,@normalStatus	; $6919

	res 7,a			; $691b
	sub ITEMCOLLISION_L2_SHIELD			; $691d
	cp ITEMCOLLISION_L3_SHIELD-ITEMCOLLISION_L2_SHIELD + 1			; $691f
	call c,_twinrovaIce_bounceOffShield		; $6921
	call _ecom_updateCardinalAngleAwayFromTarget		; $6924

@normalStatus:
	ld e,Enemy.state		; $6927
	ld a,(de)		; $6929
	rst_jumpTable			; $692a
	.dw @state0
	.dw @state1
	.dw @state2


; Initialization
@state0:
	ld h,d			; $6931
	ld l,e			; $6932
	inc (hl) ; [state]

	ld l,Enemy.speed		; $6934
	ld (hl),SPEED_1c0		; $6936

	ld l,Enemy.counter1		; $6938
	ld (hl),120		; $693a

	ld l,Enemy.var3e		; $693c
	ld (hl),$08		; $693e

	ld a,SND_POOF		; $6940
	call playSound		; $6942
	jp objectSetVisible82		; $6945


@state1:
	call _ecom_decCounter1		; $6948
	jp nz,enemyAnimate		; $694b

	ld l,e			; $694e
	inc (hl)		; $694f


@state2:
	; Check if parent is dead
	ld a,Object.health		; $6950
	call objectGetRelatedObject1Var		; $6952
	ld a,(hl)		; $6955
	or a			; $6956
	jr z,@delete	; $6957

	ld l,Enemy.state		; $6959
	ld a,(hl)		; $695b
	cp $0a			; $695c
	jr z,@delete	; $695e

	call objectApplySpeed		; $6960
	call _ecom_bounceOffWallsAndHoles		; $6963
	ret z			; $6966
	ld a,SND_CLINK		; $6967
	jp playSound		; $6969

@delete:
	call objectCreatePuff		; $696c
	jp enemyDelete		; $696f


;;
; This doesn't appear to do anything other than make a sound, because the angle is
; immediately overwritten after this is called?
; @addr{6972}
_twinrovaIce_bounceOffShield:
	ld a,(w1Link.direction)		; $6972
	swap a			; $6975
	ld b,a			; $6977
	ld e,Enemy.angle		; $6978
	ld a,(de)		; $697a
	add b			; $697b
	ld hl,@bounceTable		; $697c
	rst_addAToHl			; $697f
	ld e,Enemy.angle		; $6980
	ld a,(hl)		; $6982
	ld (de),a		; $6983
	ld a,SND_CLINK		; $6984
	jp playSound		; $6986

@bounceTable:
	.db $10 $0f $0e $0d $0c $0b $0a $09
	.db $08 $07 $06 $05 $04 $03 $02 $01

	.db $00 $1f $1e $1d $1c $1b $1a $19
	.db $18 $17 $16 $15 $14 $13 $12 $11

	.db $10 $0f $0e $0d $0c $0b $0a $09
	.db $08 $07 $06 $05 $04 $03 $02 $01

	.db $00 $1f $1e $1d $1c $1b $1a $19
	.db $18 $17 $16 $15 $14 $13 $12 $11

	.db $10 $0f $0e $0d $0c $0b $0a $09
	.db $08 $07 $06 $05 $04 $03 $02 $01



; ==============================================================================
; ENEMYID_TWINROVA_BAT
; ==============================================================================
enemyCode5e:
	jr z,+			; $69d9
	sub ENEMYSTATUS_NO_HEALTH			; $69db
	ret c			; $69dd
	jp z,enemyDie_uncounted		; $69de
+
	ld a,Object.id		; $69e1
	call objectGetRelatedObject1Var		; $69e3
	ld a,(hl)		; $69e6
	cp ENEMYID_MERGED_TWINROVA			; $69e7
	jp nz,enemyDelete		; $69e9

	ld e,Enemy.counter1		; $69ec
	ld a,(de)		; $69ee
	inc a			; $69ef
	and $1f			; $69f0
	ld a,SND_BOOMERANG		; $69f2
	call z,playSound		; $69f4

	ld e,Enemy.state		; $69f7
	ld a,(de)		; $69f9
	rst_jumpTable			; $69fa
	.dw @state0
	.dw @state1
	.dw @state2


@state0:
	ld h,d			; $6a01
	ld l,e			; $6a02
	inc (hl) ; [state]

	ld l,Enemy.speed		; $6a04
	ld (hl),SPEED_200		; $6a06

	ld l,Enemy.counter2		; $6a08
	ld (hl),$50		; $6a0a

	call getRandomNumber_noPreserveVars		; $6a0c
	ld e,Enemy.counter1		; $6a0f
	ld (de),a		; $6a11

	ld a,SND_VERAN_FAIRY_ATTACK		; $6a12
	call playSound		; $6a14
	jp objectSetVisible82		; $6a17


@state1:
	call @updateOamFlags		; $6a1a
	call _ecom_decCounter2		; $6a1d
	jr nz,@animate	; $6a20

	ld l,e			; $6a22
	inc (hl) ; [state]
	call _ecom_updateAngleTowardTarget		; $6a24


@state2:
	call @checkInBounds		; $6a27
	jp nc,enemyDelete		; $6a2a

	call @updateOamFlags		; $6a2d
	call objectApplySpeed		; $6a30
@animate:
	jp enemyAnimate		; $6a33


;;
; @param[out]	cflag	c if in bounds
; @addr{6a36}
@checkInBounds:
	ld e,Enemy.yh		; $6a36
	ld a,(de)		; $6a38
	cp LARGE_ROOM_HEIGHT<<4			; $6a39
	ret nc			; $6a3b
	ld e,Enemy.xh		; $6a3c
	ld a,(de)		; $6a3e
	cp LARGE_ROOM_WIDTH<<4			; $6a3f
	ret			; $6a41

;;
; @addr{6a42}
@updateOamFlags:
	call _ecom_decCounter1		; $6a42
	ld a,(hl)		; $6a45
	and $04			; $6a46
	rrca			; $6a48
	rrca			; $6a49
	add $02			; $6a4a
	ld l,Enemy.oamFlagsBackup		; $6a4c
	ldi (hl),a		; $6a4e
	ld (hl),a		; $6a4f
	ret			; $6a50


; ==============================================================================
; ENEMYID_GANON_REVIVAL_CUTSCENE
;
; Variables:
;   var30: Copied to counter2?
;   var31: Nonzero if initialization has occurred? (spawner only)
; ==============================================================================
enemyCode60:
	ld e,Enemy.subid		; $6a51
	ld a,(de)		; $6a53
	or a			; $6a54
	ld e,Enemy.var31		; $6a55
	jr z,_ganonRevivalCutscene_controller	; $6a57

	; This is an individual shadow in the cutscene.

	ld a,(de)		; $6a59
	or a			; $6a5a
	jr nz,_label_266	; $6a5b

	ld h,d			; $6a5d
	ld l,e			; $6a5e
	inc (hl) ; [state]

	ld l,Enemy.speed		; $6a60
	ld (hl),SPEED_200		; $6a62

	call objectSetVisible83		; $6a64

	ld a,SND_WIND		; $6a67
	call playSound		; $6a69

_label_266:
	ld bc,$5478		; $6a6c
	ld e,Enemy.yh		; $6a6f
	ld a,(de)		; $6a71
	ldh (<hFF8F),a	; $6a72
	ld e,Enemy.xh		; $6a74
	ld a,(de)		; $6a76
	ldh (<hFF8E),a	; $6a77
	sub c			; $6a79
	add $08			; $6a7a
	cp $11			; $6a7c
	jr nc,_label_267	; $6a7e

	ldh a,(<hFF8F)	; $6a80
	sub b			; $6a82
	add $08			; $6a83
	cp $11			; $6a85
	jp c,enemyDelete		; $6a87

_label_267:
	; Nudge toward target every 8 frames
	ld a,(wFrameCounter)		; $6a8a
	and $07			; $6a8d
	jr nz,++		; $6a8f
	call objectGetRelativeAngleWithTempVars		; $6a91
	call objectNudgeAngleTowards		; $6a94
++
	call objectApplySpeed		; $6a97
	jp _ecom_flickerVisibility		; $6a9a


_ganonRevivalCutscene_controller:
	ld a,(de) ; [var31]
	or a			; $6a9e
	jr nz,_label_270	; $6a9f

	; Just starting the cutscene

	ld a,(wPaletteThread_mode)		; $6aa1
	or a			; $6aa4
	ret nz			; $6aa5

	ld h,d			; $6aa6
	ld l,e			; $6aa7
	inc (hl) ; [var31] = 1

	ld l,Enemy.var30		; $6aa9
	ld (hl),$28		; $6aab

	call hideStatusBar		; $6aad

	ldh a,(<hActiveObject)	; $6ab0
	ld d,a			; $6ab2
	ld a,$0e		; $6ab3
	call fadeoutToBlackWithDelay		; $6ab5

	xor a			; $6ab8
	ld (wDirtyFadeSprPalettes),a		; $6ab9
	ld (wFadeSprPaletteSources),a		; $6abc

_label_270:
	call _ecom_decCounter2		; $6abf
	ret nz			; $6ac2

	; Check number of shadows spawned already
	dec l			; $6ac3
	ld a,(hl) ; [counter1]
	cp $10			; $6ac5
	inc (hl)		; $6ac7
	jr nc,@delete	; $6ac8

	call _ganonRevivalCutscene_spawnShadow		; $6aca

	ld e,Enemy.var30		; $6acd
	ld a,(de)		; $6acf
	ld e,Enemy.counter2		; $6ad0
	ld (de),a		; $6ad2

	ld e,Enemy.var30		; $6ad3
	ld a,(de)		; $6ad5
	sub $04			; $6ad6
	cp $10			; $6ad8
	ret c			; $6ada
	ld (de),a		; $6adb
	ret			; $6adc

@delete:
	; Signal parent to move to next phase of cutscene?
	ld a,Object.counter1		; $6add
	call objectGetRelatedObject1Var		; $6adf
	inc (hl)		; $6ae2
	jp enemyDelete		; $6ae3

;;
; @addr{6ae6}
_ganonRevivalCutscene_spawnShadow:
	call getFreeEnemySlot_uncounted		; $6ae6
	ret nz			; $6ae9

	ld (hl),ENEMYID_GANON_REVIVAL_CUTSCENE		; $6aea
	inc l			; $6aec
	inc (hl) ; [child.subid] = 1

	ld e,Enemy.counter1		; $6aee
	ld a,(de)		; $6af0
	and $07			; $6af1
	ld b,a			; $6af3
	add a			; $6af4
	add b			; $6af5
	ld bc,@shadowVariables		; $6af6
	call addAToBc		; $6af9

	ld l,Enemy.yh		; $6afc
	ld a,(bc)		; $6afe
	ldi (hl),a		; $6aff
	inc l			; $6b00
	inc bc			; $6b01
	ld a,(bc)		; $6b02
	ld (hl),a ; [xh]

	ld l,Enemy.angle		; $6b04
	inc bc			; $6b06
	ld a,(bc)		; $6b07
	ld (hl),a		; $6b08
	ret			; $6b09

; Byte 0: yh
; Byte 1: xh
; Byte 2: angle
@shadowVariables:
	.db $60 $f0 $19
	.db $b8 $d0 $00
	.db $90 $00 $02
	.db $40 $f0 $16
	.db $b8 $60 $1e
	.db $b8 $20 $05
	.db $90 $f0 $18
	.db $40 $00 $06


; ==============================================================================
; TODO: what object uses this?

data_6b22:
	.dw @subid00

@subid00:
	.db SPEED_80
	.db DIR_UP
@@loop:
	ms_right $98
	ms_left  $68
	ms_loop  @@loop


;;
; Called from objectRunMovementScript in bank0. See include/movementscript_commands.s.
;
; @param	hl	Script address
; @addr{6b2d}
objectLoadMovementScript_body:
	ldh a,(<hActiveObjectType)	; $6b2d
	add Object.subid			; $6b2f
	ld e,a			; $6b31
	ld a,(de)		; $6b32
	rst_addDoubleIndex			; $6b33
	ldi a,(hl)		; $6b34
	ld h,(hl)		; $6b35
	ld l,a			; $6b36

	ld a,e			; $6b37
	add Object.speed-Object.subid			; $6b38
	ld e,a			; $6b3a
	ldi a,(hl)		; $6b3b
	ld (de),a		; $6b3c

	ld a,e			; $6b3d
	add Object.direction-Object.speed			; $6b3e
	ld e,a			; $6b40
	ldi a,(hl)		; $6b41
	ld (de),a		; $6b42

	ld a,e			; $6b43
	add Object.var30-Object.direction 			; $6b44
	ld e,a			; $6b46
	ld a,l			; $6b47
	ld (de),a		; $6b48
	inc e			; $6b49
	ld a,h			; $6b4a
	ld (de),a		; $6b4b

;;
; Called from objectRunMovementScript in bank0. See include/movementscript_commands.s.
; @addr{6b4c}
objectRunMovementScript_body:
	ldh a,(<hActiveObjectType)	; $6b4c
	add Object.var30			; $6b4e
	ld e,a			; $6b50
	ld a,(de)		; $6b51
	ld l,a			; $6b52
	inc e			; $6b53
	ld a,(de)		; $6b54
	ld h,a			; $6b55

@nextOp:
	ldi a,(hl)		; $6b56
	push hl			; $6b57
	rst_jumpTable			; $6b58
	.dw @cmd00_jump
	.dw @moveUp
	.dw @moveRight
	.dw @moveDown
	.dw @moveLeft
	.dw @wait
	.dw @setstate


@cmd00_jump:
	pop hl			; $6b67
	ldi a,(hl)		; $6b68
	ld h,(hl)		; $6b69
	ld l,a			; $6b6a
	jr @nextOp		; $6b6b


@moveUp:
	pop bc			; $6b6d
	ld h,d			; $6b6e
	ldh a,(<hActiveObjectType)	; $6b6f
	add Object.var32			; $6b71
	ld l,a			; $6b73
	ld a,(bc)		; $6b74
	ld (hl),a		; $6b75

	ld a,l			; $6b76
	add Object.angle-Object.var32			; $6b77
	ld l,a			; $6b79
	ld (hl),ANGLE_UP		; $6b7a

	add Object.state-Object.angle			; $6b7c
	ld l,a			; $6b7e
	ld (hl),$08		; $6b7f
	jr @storePointer		; $6b81


@moveRight:
	pop bc			; $6b83
	ld h,d			; $6b84
	ldh a,(<hActiveObjectType)	; $6b85
	add Object.var33			; $6b87
	ld l,a			; $6b89
	ld a,(bc)		; $6b8a
	ld (hl),a		; $6b8b

	ld a,l			; $6b8c
	add Object.angle-Object.var33			; $6b8d
	ld l,a			; $6b8f
	ld (hl),ANGLE_RIGHT		; $6b90

	add Object.state-Object.angle			; $6b92
	ld l,a			; $6b94
	ld (hl),$09		; $6b95
	jr @storePointer		; $6b97


@moveDown:
	pop bc			; $6b99
	ld h,d			; $6b9a
	ldh a,(<hActiveObjectType)	; $6b9b
	add Object.var32			; $6b9d
	ld l,a			; $6b9f
	ld a,(bc)		; $6ba0
	ld (hl),a		; $6ba1

	ld a,l			; $6ba2
	add Object.angle-Object.var32			; $6ba3
	ld l,a			; $6ba5
	ld (hl),ANGLE_DOWN		; $6ba6

	add Object.state-Object.angle			; $6ba8
	ld l,a			; $6baa
	ld (hl),$0a		; $6bab
	jr @storePointer		; $6bad


@moveLeft:
	pop bc			; $6baf
	ld h,d			; $6bb0
	ldh a,(<hActiveObjectType)	; $6bb1
	add Object.var33			; $6bb3
	ld l,a			; $6bb5
	ld a,(bc)		; $6bb6
	ld (hl),a		; $6bb7

	ld a,l			; $6bb8
	add Object.angle-Object.var33			; $6bb9
	ld l,a			; $6bbb
	ld (hl),ANGLE_LEFT		; $6bbc

	add Object.state-Object.angle			; $6bbe
	ld l,a			; $6bc0
	ld (hl),$0b		; $6bc1
	jr @storePointer		; $6bc3


@wait:
	pop bc			; $6bc5
	ld h,d			; $6bc6
	ldh a,(<hActiveObjectType)	; $6bc7
	add Object.counter1			; $6bc9
	ld l,a			; $6bcb
	ld a,(bc)		; $6bcc
	ldd (hl),a		; $6bcd

	dec l			; $6bce
	ld (hl),$0c ; [state]

@storePointer:
	inc bc			; $6bd1
	ld a,l			; $6bd2
	add Object.var30-Object.state			; $6bd3
	ld l,a			; $6bd5
	ld (hl),c		; $6bd6
	inc l			; $6bd7
	ld (hl),b		; $6bd8
	ret			; $6bd9


@setstate:
	pop bc			; $6bda
	ld h,d			; $6bdb
	ldh a,(<hActiveObjectType)	; $6bdc
	add Object.counter1			; $6bde
	ld l,a			; $6be0
	ld a,(bc)		; $6be1
	ldd (hl),a		; $6be2

	dec l			; $6be3
	inc bc			; $6be4
	ld a,(bc)		; $6be5
	ld (hl),a ; [state]

	jr @storePointer		; $6be7


; ==============================================================================
; ENEMYID_BARI
;
; Variables:
;   var30/var31: Initial Y/X position (aka target position; they always hover around this
;                area. For subid 0 (large baris) only.)
;   var32: Counter for "bobbing" of Z position
; ==============================================================================
enemyCode3c:
	jr z,@normalStatus	; $6be9
	sub ENEMYSTATUS_NO_HEALTH			; $6beb
	ret c			; $6bed
	jp z,enemyDie		; $6bee
	dec a			; $6bf1
	jp nz,_ecom_updateKnockback		; $6bf2

	; ENEMYSTATUS_JUST_HIT
	; The bari should be split in two if it's subid 0, and the right kind of collision
	; occurred, while it's not in its "shocking" state.

	ld e,Enemy.var2a		; $6bf5
	ld a,(de)		; $6bf7
	cp $80|ITEMCOLLISION_GALE_SEED			; $6bf8
	jr z,@normalStatus	; $6bfa

	ld e,Enemy.health		; $6bfc
	ld a,(de)		; $6bfe
	or a			; $6bff
	ret z			; $6c00

	ld e,Enemy.subid		; $6c01
	ld a,(de)		; $6c03
	or a			; $6c04
	jr nz,@normalStatus	; $6c05

	ld e,Enemy.enemyCollisionMode		; $6c07
	ld a,(de)		; $6c09
	cp ENEMYCOLLISION_BARI_ELECTRIC_SHOCK			; $6c0a
	jr z,@normalStatus	; $6c0c

	; FIXME: This checks if collisionType is strictly less than L3 shield, which is
	; odd? Does that mean the mirror shield would cause the bari to split? Though it
	; shouldn't matter anyway, shields can't be used underwater...
	ld e,Enemy.var2a		; $6c0e
	ld a,(de)		; $6c10
	cp $80|ITEMCOLLISION_L3_SHIELD			; $6c11
	jr c,@normalStatus	; $6c13

	ld h,d			; $6c15
	ld l,Enemy.state		; $6c16
	ld (hl),$0a		; $6c18

@normalStatus:
	call _ecom_getSubidAndCpStateTo08		; $6c1a
	jr c,@commonState	; $6c1d

	call _bari_updateZPosition		; $6c1f
	ld e,Enemy.state		; $6c22
	ld a,b			; $6c24
	or a			; $6c25
	jp z,_bari_subid0		; $6c26
	jp _bari_subid1		; $6c29

@commonState:
	ld a,(de)		; $6c2c
	rst_jumpTable			; $6c2d
	.dw _bari_state_uninitialized
	.dw _bari_state_stub
	.dw _bari_state_stub
	.dw _bari_state_stub
	.dw _bari_state_stub
	.dw _ecom_blownByGaleSeedState
	.dw _bari_state_stub
	.dw _bari_state_stub


_bari_state_uninitialized:
	ld a,SPEED_60		; $6c3e
	call _ecom_setSpeedAndState8AndVisible		; $6c40

	ld l,Enemy.counter1		; $6c43
	ld (hl),$04		; $6c45

	ld l,Enemy.zh		; $6c47
	ld (hl),$fc		; $6c49

	; Copy Y/X to var30/var31
	ld e,Enemy.yh		; $6c4b
	ld l,Enemy.var30		; $6c4d
	ld a,(de)		; $6c4f
	ldi (hl),a		; $6c50
	ld e,Enemy.xh		; $6c51
	ld a,(de)		; $6c53
	ld (hl),a		; $6c54

	call getRandomNumber_noPreserveVars		; $6c55
	ld e,Enemy.var32		; $6c58
	ld (de),a		; $6c5a

	ld e,Enemy.subid		; $6c5b
	ld a,(de)		; $6c5d
	or a			; $6c5e
	jp z,_bari_setRandomAngleAndCounter2		; $6c5f

	; Subid 1 only
	ld e,Enemy.speed		; $6c62
	ld a,SPEED_40		; $6c64
	ld (de),a		; $6c66
	ld a,$02		; $6c67
	jp enemySetAnimation		; $6c69


_bari_state_stub:
	ret			; $6c6c


_bari_subid0:
	ld a,(de)		; $6c6d
	sub $08			; $6c6e
	rst_jumpTable			; $6c70
	.dw _bari_subid0_state8
	.dw _bari_state9
	.dw _bari_subid0_stateA


; "Non-electric-shock" state
_bari_subid0_state8:
	call _ecom_decCounter2		; $6c77
	jr nz,@dontShockYet	; $6c7a

	; Begin electric shock
	ld (hl),60 ; [counter2]
	ld l,e			; $6c7e
	inc (hl) ; [state]

	ld l,Enemy.enemyCollisionMode		; $6c80
	ld (hl),ENEMYCOLLISION_BARI_ELECTRIC_SHOCK		; $6c82

	ld a,$01		; $6c84
	jp enemySetAnimation		; $6c86

@dontShockYet:
	call _ecom_decCounter1		; $6c89
	jr nz,_bari_applySpeed	; $6c8c

	call getRandomNumber		; $6c8e
	and $0e			; $6c91
	add $02			; $6c93
	ld (hl),a ; [counter1]

	; Nudge angle towards target position (original position)
	ld l,Enemy.var30		; $6c96
	call _ecom_readPositionVars		; $6c98
	call objectGetRelativeAngleWithTempVars		; $6c9b
	call objectNudgeAngleTowards		; $6c9e

_bari_applySpeed:
	call objectApplySpeed		; $6ca1
	call _ecom_bounceOffScreenBoundary		; $6ca4

_bari_animate:
	jp enemyAnimate		; $6ca7


; In its "electric shock" state. This is shared between subids 0 and 1 (large and small).
_bari_state9:
	call _ecom_decCounter2		; $6caa
	jr nz,_bari_animate	; $6cad

	; Stop the shock
	ld l,e			; $6caf
	dec (hl) ; [state] = 8

	ld l,Enemy.enemyCollisionMode		; $6cb1
	ld (hl),ENEMYCOLLISION_BARI		; $6cb3

	dec l			; $6cb5
	set 7,(hl) ; [collisionType]

	xor a			; $6cb8
	call enemySetAnimation		; $6cb9


;;
; @addr{6cbc}
_bari_setRandomAngleAndCounter2:
	call getRandomNumber_noPreserveVars		; $6cbc
	and $03			; $6cbf
	ld hl,@counter2Vals		; $6cc1
	rst_addAToHl			; $6cc4
	ld e,Enemy.counter2		; $6cc5
	ld a,(hl)		; $6cc7
	ld (de),a		; $6cc8
	jp _ecom_setRandomAngle		; $6cc9

@counter2Vals:
	.db 60 90 120 150


; Bari has just been attacked; now it's splitting in two.
_bari_subid0_stateA:
	inc e			; $6cd0
	ld a,(de) ; [state2]
	or a			; $6cd2
	jr z,@substate0	; $6cd3

@substate1:
	call _ecom_decCounter2		; $6cd5
	ret nz			; $6cd8

	; Spawn the two small baris, then delete self.
	call _ecom_updateAngleTowardTarget		; $6cd9
	ld c,$04		; $6cdc
	call @spawnSmallBari		; $6cde
	ld c,$fc		; $6ce1
	call @spawnSmallBari		; $6ce3
	call decNumEnemies		; $6ce6
	jp enemyDelete		; $6ce9

;;
; @param	c	X-offset (and value to add to angle)
; @addr{6cec}
@spawnSmallBari:
	ld b,ENEMYID_BARI		; $6cec
	call _ecom_spawnEnemyWithSubid01		; $6cee
	ret nz			; $6cf1

	; Copy "enemy index" value
	ld l,Enemy.enabled		; $6cf2
	ld e,l			; $6cf4
	ld a,(de)		; $6cf5
	ld (hl),a		; $6cf6

	ld l,Enemy.angle		; $6cf7
	ld e,l			; $6cf9
	ld a,(de)		; $6cfa
	add c			; $6cfb
	and $1f			; $6cfc
	ld (hl),a		; $6cfe

	ld b,$00		; $6cff
	jp objectCopyPositionWithOffset		; $6d01

@substate0:
	ld b,INTERACID_KILLENEMYPUFF		; $6d04
	call objectCreateInteractionWithSubid00		; $6d06

	ld h,d			; $6d09
	ld l,Enemy.collisionType		; $6d0a
	res 7,(hl)		; $6d0c

	ld l,Enemy.counter2		; $6d0e
	ld (hl),$04		; $6d10

	ld l,Enemy.state2		; $6d12
	inc (hl)		; $6d14

	ld a,SND_KILLENEMY		; $6d15
	call playSound		; $6d17
	jp objectSetInvisible		; $6d1a


; A small bari.
_bari_subid1:
	ld a,(de)		; $6d1d
	sub $08			; $6d1e
	jp nz,_bari_state9		; $6d20

@state8:
	call _ecom_decCounter1		; $6d23
	jp nz,_bari_applySpeed		; $6d26

	; Randomly choose counter1 value
	call getRandomNumber		; $6d29
	and $1c			; $6d2c
	inc a			; $6d2e
	ld (hl),a		; $6d2f

	; Adjust angle toward Link
	call objectGetAngleTowardEnemyTarget		; $6d30
	call objectNudgeAngleTowards		; $6d33
	jp _bari_applySpeed		; $6d36


;;
; Bobs up and down
; @addr{6d39}
_bari_updateZPosition:
	ld h,d			; $6d39
	ld l,Enemy.var32		; $6d3a
	dec (hl)		; $6d3c
	ld a,(hl)		; $6d3d
	and $30			; $6d3e
	swap a			; $6d40
	ld hl,@zVals		; $6d42
	rst_addAToHl			; $6d45
	ld e,Enemy.zh		; $6d46
	ld a,(hl)		; $6d48
	ld (de),a		; $6d49
	ret			; $6d4a

@zVals:
	.db $fc $fd $fe $fd


; ==============================================================================
; ENEMYID_GIANT_GHINI_CHILD
; ==============================================================================
enemyCode3f:
	jr z,@normalStatus	; $6d4f
	sub ENEMYSTATUS_NO_HEALTH			; $6d51
	ret c			; $6d53
	jr z,@dead	; $6d54
	dec a			; $6d56
	jp nz,_ecom_updateKnockbackNoSolidity		; $6d57

	; ENEMYSTATUS_JUST_HIT

	ld e,Enemy.var2a		; $6d5a
	ld a,(de)		; $6d5c
	cp $80|ITEMCOLLISION_LINK			; $6d5d
	jr nz,@normalStatus	; $6d5f

	; Attach self to Link
	ld h,d			; $6d61
	ld l,Enemy.state		; $6d62
	ld (hl),$0b		; $6d64

	ld l,Enemy.counter1		; $6d66
	ld (hl),120		; $6d68

	ld l,Enemy.collisionType		; $6d6a
	res 7,(hl)		; $6d6c

	ld l,Enemy.zh		; $6d6e
	ld (hl),$00		; $6d70

	; Signal parent to charge at Link
	ld l,Enemy.relatedObj1+1		; $6d72
	ld h,(hl)		; $6d74
	ld l,Enemy.var32		; $6d75
	ld (hl),$01		; $6d77

	jr @normalStatus		; $6d79

@dead:
	; Decrement parent's "child counter" before deleting self
	ld e,Enemy.relatedObj1+1		; $6d7b
	ld a,(de)		; $6d7d
	ld h,a			; $6d7e
	ld l,Enemy.var30		; $6d7f
	dec (hl)		; $6d81
	jp enemyDie		; $6d82

@normalStatus:
	; Die if parent is dead
	ld e,Enemy.relatedObj1+1		; $6d85
	ld a,(de)		; $6d87
	ld h,a			; $6d88
	ld l,Enemy.health		; $6d89
	ld a,(hl)		; $6d8b
	or a			; $6d8c
	jr z,@dead	; $6d8d

	ld e,Enemy.state		; $6d8f
	ld a,(de)		; $6d91
	rst_jumpTable			; $6d92
	.dw _giantGhiniChild_state_uninitialized
	.dw _giantGhiniChild_state_stub
	.dw _giantGhiniChild_state_stub
	.dw _giantGhiniChild_state_stub
	.dw _giantGhiniChild_state_stub
	.dw _giantGhiniChild_state_stub
	.dw _giantGhiniChild_state_stub
	.dw _giantGhiniChild_state_stub
	.dw _giantGhiniChild_state8
	.dw _giantGhiniChild_state9
	.dw _giantGhiniChild_stateA
	.dw _giantGhiniChild_stateB
	.dw _giantGhiniChild_stateC


_giantGhiniChild_state_stub:
	ret			; $6dad


_giantGhiniChild_state_uninitialized:
	; Determine spawn offset based on subid
	ld e,Enemy.subid		; $6dae
	ld a,(de)		; $6db0
	and $7f			; $6db1
	dec a			; $6db3
	ld hl,_giantGhiniChild_spawnOffsets		; $6db4
	rst_addDoubleIndex			; $6db7
	ld e,Enemy.yh		; $6db8
	ld a,(de)		; $6dba
	add (hl)		; $6dbb
	ld (de),a		; $6dbc
	inc hl			; $6dbd
	ld e,Enemy.xh		; $6dbe
	ld a,(de)		; $6dc0
	add (hl)		; $6dc1
	ld (de),a		; $6dc2

	ld a,SPEED_c0		; $6dc3
	call _ecom_setSpeedAndState8		; $6dc5
	ld l,Enemy.zh		; $6dc8
	ld (hl),$fc		; $6dca

	ld l,Enemy.subid		; $6dcc
	ld a,(hl)		; $6dce
	rlca			; $6dcf
	ret c			; $6dd0

	ld l,Enemy.state		; $6dd1
	ld (hl),$09		; $6dd3
	ld l,Enemy.counter1		; $6dd5
	ld (hl),30		; $6dd7
	call objectSetVisiblec1		; $6dd9
	jp objectCreatePuff		; $6ddc


; Waiting for battle to start
_giantGhiniChild_state8:
	ld e,Enemy.relatedObj1+1		; $6ddf
	ld a,(de)		; $6de1
	ld h,a			; $6de2
	ld l,Enemy.state		; $6de3
	ld a,(hl)		; $6de5
	cp $09			; $6de6
	jr c,@battleNotStartedYet			; $6de8

	call _giantGhiniChild_gotoStateA		; $6dea
	jp objectSetVisiblec1		; $6ded

@battleNotStartedYet:
	; Enable shadows
	ld l,Enemy.visible		; $6df0
	ld e,l			; $6df2
	ld a,(hl)		; $6df3
	or $40			; $6df4
	ld (de),a		; $6df6
	ret			; $6df7


; Just spawned in, will charge after [counter1] frames
_giantGhiniChild_state9:
	call _ecom_decCounter1		; $6df8
	ret nz			; $6dfb

_giantGhiniChild_gotoStateA:
	ld e,Enemy.state		; $6dfc
	ld a,$0a		; $6dfe
	ld (de),a		; $6e00
	ld e,Enemy.counter1		; $6e01
	ld a,$05		; $6e03
	ld (de),a		; $6e05

	call objectGetAngleTowardLink		; $6e06
	ld e,Enemy.angle		; $6e09
	ld (de),a		; $6e0b
	ret			; $6e0c


; Charging at Link
_giantGhiniChild_stateA:
	call enemyAnimate		; $6e0d
	call objectApplySpeed		; $6e10
	call _ecom_decCounter1		; $6e13
	ret nz			; $6e16

	ld (hl),$05 ; [counter1]
	call objectGetAngleTowardLink		; $6e19
	jp objectNudgeAngleTowards		; $6e1c


; Attached to Link
_giantGhiniChild_stateB:
	call enemyAnimate		; $6e1f

	ld a,(w1Link.yh)		; $6e22
	ld e,Enemy.yh		; $6e25
	ld (de),a		; $6e27
	ld a,(w1Link.xh)		; $6e28
	ld e,Enemy.xh		; $6e2b
	ld (de),a		; $6e2d

	call _ecom_decCounter1		; $6e2e
	jr z,@detach	; $6e31

	; Decrement counter more if pressing buttons
	ld a,(wGameKeysJustPressed)		; $6e33
	or a			; $6e36
	jr z,++			; $6e37
	ld a,(hl)		; $6e39
	sub BTN_A|BTN_B			; $6e3a
	jr nc,+			; $6e3c
	ld a,$01		; $6e3e
+
	ld (hl),a		; $6e40
++
	; Adjust visibility
	ld a,(hl)		; $6e41
	and $03			; $6e42
	jr nz,++		; $6e44
	ld l,Enemy.visible		; $6e46
	ld a,(hl)		; $6e48
	xor $80			; $6e49
	ld (hl),a		; $6e4b
++
	; Make Link slow, disable item use
	ld hl,wccd8		; $6e4c
	set 5,(hl)		; $6e4f
	ld a,(wFrameCounter)		; $6e51
	rrca			; $6e54
	ret nc			; $6e55
	ld hl,wLinkImmobilized		; $6e56
	set 5,(hl)		; $6e59
	ret			; $6e5b

@detach:
	ld l,Enemy.state		; $6e5c
	ld (hl),$0c		; $6e5e
	ld l,Enemy.counter1		; $6e60
	ld (hl),60		; $6e62

	; Cancel parent charging (or at least he won't adjust his angle anymore)
	ld l,Enemy.relatedObj1+1		; $6e64
	ld h,(hl)		; $6e66
	ld l,Enemy.var32		; $6e67
	ld (hl),$00		; $6e69
	ret			; $6e6b


; Just detached from Link, fading away
_giantGhiniChild_stateC:
	call enemyAnimate		; $6e6c
	ld e,Enemy.visible		; $6e6f
	ld a,(de)		; $6e71
	xor $80			; $6e72
	ld (de),a		; $6e74

	call _ecom_decCounter1		; $6e75
	ret nz			; $6e78

	; Decrement parent's "child counter"
	ld e,Enemy.relatedObj1+1		; $6e79
	ld a,(de)		; $6e7b
	ld h,a			; $6e7c
	ld l,Enemy.var30		; $6e7d
	dec (hl)		; $6e7f
	call decNumEnemies		; $6e80
	jp enemyDelete		; $6e83


_giantGhiniChild_spawnOffsets:
	.db  $00, -$18
	.db -$18,  $00
	.db  $00,  $18


; ==============================================================================
; ENEMYID_SHADOW_HAG_BUG
;
; Variables:
;   counter2: Lifetime counter
; ==============================================================================
enemyCode42:
	jr z,++			; $6e8c
	sub ENEMYSTATUS_NO_HEALTH			; $6e8e
	ret c			; $6e90
	jr z,@dead	; $6e91

	dec a			; $6e93
	jp nz,_ecom_updateKnockbackNoSolidity		; $6e94
	ret			; $6e97

@dead:
	; Decrement parent object's "bug count"
	ld a,Object.var30		; $6e98
	call objectGetRelatedObject1Var		; $6e9a
	dec (hl)		; $6e9d
	jp enemyDie_uncounted		; $6e9e
++
	ld e,Enemy.state		; $6ea1
	ld a,(de)		; $6ea3
	rst_jumpTable			; $6ea4
	.dw _shadowHagBug_state_uninitialized
	.dw _shadowHagBug_state_stub
	.dw _shadowHagBug_state_stub
	.dw _shadowHagBug_state_stub
	.dw _shadowHagBug_state_stub
	.dw _shadowHagBug_state_galeSeed
	.dw _shadowHagBug_state_stub
	.dw _shadowHagBug_state_stub
	.dw _shadowHagBug_state8
	.dw _shadowHagBug_state9


_shadowHagBug_state_uninitialized:
	ld a,SPEED_60		; $6eb9
	call _ecom_setSpeedAndState8		; $6ebb

	ld l,Enemy.speedZ		; $6ebe
	ld a,<(-$e0)		; $6ec0
	ldi (hl),a		; $6ec2
	ld (hl),>(-$e0)		; $6ec3

	call getRandomNumber_noPreserveVars		; $6ec5
	and $1f			; $6ec8
	ld e,Enemy.angle		; $6eca
	ld (de),a		; $6ecc
	jp objectSetVisible82		; $6ecd


_shadowHagBug_state_galeSeed:
	call _ecom_galeSeedEffect		; $6ed0
	ret c			; $6ed3
	jp enemyDelete		; $6ed4


_shadowHagBug_state_stub:
	ret			; $6ed7


_shadowHagBug_state8:
	ld c,$12		; $6ed8
	call objectUpdateSpeedZ_paramC		; $6eda
	jr nz,_shadowHagBug_applySpeedAndAnimate	; $6edd

	ld l,Enemy.state		; $6edf
	inc (hl)		; $6ee1

	call getRandomNumber		; $6ee2
	ld l,Enemy.counter1		; $6ee5
	ldi (hl),a		; $6ee7
	ld (hl),180 ; [counter2]


_shadowHagBug_state9:
	call _ecom_decCounter2		; $6eea
	jr z,_shadowHagBug_delete	; $6eed

	ld a,(hl)		; $6eef
	cp 30			; $6ef0
	call c,_ecom_flickerVisibility		; $6ef2

	dec l			; $6ef5
	dec (hl) ; [counter1]
	ld a,(hl)		; $6ef7
	and $07			; $6ef8
	jr nz,_shadowHagBug_applySpeedAndAnimate	; $6efa

	; Choose a random position within link's 16x16 square
	ld bc,$0f0f		; $6efc
	call _ecom_randomBitwiseAndBCE		; $6eff
	ldh a,(<hEnemyTargetY)	; $6f02
	add b			; $6f04
	sub $08			; $6f05
	ld b,a			; $6f07
	ldh a,(<hEnemyTargetX)	; $6f08
	add c			; $6f0a
	sub $08			; $6f0b
	ld c,a			; $6f0d

	; Nudge angle toward chosen position
	ld e,Enemy.yh		; $6f0e
	ld a,(de)		; $6f10
	ldh (<hFF8F),a	; $6f11
	ld e,Enemy.xh		; $6f13
	ld a,(de)		; $6f15
	ldh (<hFF8E),a	; $6f16
	call objectGetRelativeAngleWithTempVars		; $6f18
	call objectNudgeAngleTowards		; $6f1b

_shadowHagBug_applySpeedAndAnimate:
	call objectApplySpeed		; $6f1e
	jp enemyAnimate		; $6f21

_shadowHagBug_delete:
	; Decrement parent's "bug count"
	ld a,Object.var30		; $6f24
	call objectGetRelatedObject1Var		; $6f26
	dec (hl)		; $6f29
	jp enemyDelete		; $6f2a


; ==============================================================================
; ENEMYID_COLOR_CHANGING_GEL
;
; Variables:
;   var30/var31: Target position while hopping
;   var32: Tile index at current position (purposely outdated so there's lag in updating
;          the color)
; ==============================================================================
enemyCode47:
	call _ecom_checkHazards		; $6f2d
	jr z,@normalStatus	; $6f30
	sub ENEMYSTATUS_NO_HEALTH			; $6f32
	ret c			; $6f34
	jp z,enemyDie		; $6f35

	; ENEMYSTATUS_JUST_HIT

	ld h,d			; $6f38
	ld l,Enemy.var2a		; $6f39
	ld a,(hl)		; $6f3b
	cp $80|ITEMCOLLISION_MYSTERY_SEED			; $6f3c
	jr nz,@attacked	; $6f3e

	; Mystery seed hit the gel
	call _colorChangingGel_chooseRandomColor		; $6f40
	jr @normalStatus		; $6f43

@attacked:
	; Ignore all attacks if color matches floor
	ld e,Enemy.enemyCollisionMode		; $6f45
	ld a,(de)		; $6f47
	cp ENEMYCOLLISION_COLOR_CHANGING_GEL			; $6f48
	jr nz,@normalStatus	; $6f4a

	; Only allow switch hook and sword attacks to kill the gel
	ldi a,(hl)		; $6f4c
	res 7,a			; $6f4d
	cp ITEMCOLLISION_SWITCH_HOOK			; $6f4f
	jr z,@wasDamagingAttack			; $6f51
	sub ITEMCOLLISION_L1_SWORD			; $6f53
	cp ITEMCOLLISION_SWORD_HELD-ITEMCOLLISION_L1_SWORD + 1
	jr nc,@normalStatus	; $6f57

@wasDamagingAttack
	ld (hl),$f4 ; [invincibilityCounter] = $f4
	ld a,SND_DAMAGE_ENEMY		; $6f5b
	call playSound		; $6f5d

@normalStatus:
	call _colorChangingGel_updateColor		; $6f60
	ld e,Enemy.state		; $6f63
	ld a,(de)		; $6f65
	rst_jumpTable			; $6f66
	.dw _colorChangingGel_state_uninitialized
	.dw _colorChangingGel_state_stub
	.dw _colorChangingGel_state_stub
	.dw _colorChangingGel_state_stub
	.dw _colorChangingGel_state_stub
	.dw _ecom_blownByGaleSeedState
	.dw _colorChangingGel_state_stub
	.dw _colorChangingGel_state_stub
	.dw _colorChangingGel_state8
	.dw _colorChangingGel_state9
	.dw _colorChangingGel_stateA


_colorChangingGel_state_uninitialized:
	ld a,SPEED_140		; $6f7d
	call _ecom_setSpeedAndState8AndVisible		; $6f7f

	ld l,Enemy.counter1		; $6f82
	ld (hl),150		; $6f84
	inc l			; $6f86
	ld (hl),$00 ; [counter2]

	ld l,Enemy.enemyCollisionMode		; $6f89
	ld (hl),ENEMYCOLLISION_COLOR_CHANGING_GEL		; $6f8b

	ld l,Enemy.var3f		; $6f8d
	set 5,(hl)		; $6f8f

	call objectGetTileAtPosition		; $6f91
	ld e,Enemy.var32		; $6f94
	ld (de),a		; $6f96

	ld a,PALH_bf		; $6f97
	call loadPaletteHeader		; $6f99
	ld a,$03		; $6f9c
	jp enemySetAnimation		; $6f9e


_colorChangingGel_state_stub:
	ret			; $6fa1


; Standing still for [counter1] frames
_colorChangingGel_state8:
	call _ecom_decCounter1		; $6fa2
	ret nz			; $6fa5

	inc (hl) ; [counter1] = 1

	; Choose random direction to jump
	call getRandomNumber_noPreserveVars		; $6fa7
	and $0e			; $6faa
	ld hl,@directionsToJump		; $6fac
	rst_addAToHl			; $6faf

	; Store target position in var30/var31
	ld e,Enemy.yh		; $6fb0
	ld a,(de)		; $6fb2
	add (hl)		; $6fb3
	ld e,Enemy.var30		; $6fb4
	ld (de),a		; $6fb6
	ld b,a			; $6fb7

	ld e,Enemy.xh		; $6fb8
	ld a,(de)		; $6fba
	inc hl			; $6fbb
	add (hl)		; $6fbc
	ld e,Enemy.var31		; $6fbd
	ld (de),a		; $6fbf
	ld c,a			; $6fc0

	; Target position must not be solid (if it is, try again next frame)
	call getTileCollisionsAtPosition		; $6fc1
	ret nz			; $6fc4

	call _ecom_incState		; $6fc5

	ld l,Enemy.counter1		; $6fc8
	ld (hl),60		; $6fca

	ld l,Enemy.speedZ		; $6fcc
	ld a,<(-$180)		; $6fce
	ldi (hl),a		; $6fd0
	ld (hl),>(-$180)		; $6fd1

	ld a,$02		; $6fd3
	jp enemySetAnimation		; $6fd5

@directionsToJump:
	.db $f0 $f0
	.db $f0 $00
	.db $f0 $10
	.db $00 $f0
	.db $00 $10
	.db $10 $f0
	.db $10 $00
	.db $10 $10


; Waiting [counter1] frames before hopping to target position
_colorChangingGel_state9:
	call _ecom_decCounter1		; $6fe8
	jp nz,enemyAnimate		; $6feb

	ld l,e			; $6fee
	inc (hl) ; [state]

	; Calculate angle to jump in
	ld h,d			; $6ff0
	ld l,Enemy.var30		; $6ff1
	call _ecom_readPositionVars		; $6ff3
	call objectGetRelativeAngleWithTempVars		; $6ff6
	and $10			; $6ff9
	swap a			; $6ffb
	jp enemySetAnimation		; $6ffd


; Hopping to target
_colorChangingGel_stateA:
	ld c,$30		; $7000
	call objectUpdateSpeedZ_paramC		; $7002
	jr nz,@stillInAir	; $7005

	; Landed
	ld l,Enemy.state		; $7007
	ld (hl),$08		; $7009

	ld l,Enemy.counter1		; $700b
	ld (hl),150		; $700d

	call objectCenterOnTile		; $700f

	ld a,$03		; $7012
	jp enemySetAnimation		; $7014

@stillInAir:
	; Move toward position if we're not there yet already (ignoring Z position)
	ld l,Enemy.var30		; $7017
	call _ecom_readPositionVars		; $7019
	sub c			; $701c
	inc a			; $701d
	cp $03			; $701e
	jr nc,++		; $7020
	ldh a,(<hFF8F)	; $7022
	sub b			; $7024
	inc a			; $7025
	cp $03			; $7026
	ret c			; $7028
++
	jp _ecom_moveTowardPosition		; $7029


;;
; Updates the gel's color with intentional lag. Every 90 frames, this uses the value of
; var32 (tile index) to set the gel's color, then it updates the value of var32. Due to
; the order this is done in, it takes 180 frames for the color to update fully.
; @addr{702c}
_colorChangingGel_updateColor:
	; Must be on ground
	ld e,Enemy.zh		; $702c
	ld a,(de)		; $702e
	rlca			; $702f
	ret c			; $7030

	; Wait for cooldown
	call _ecom_decCounter2		; $7031
	jr z,@updateStoredColor	; $7034

	; If [counter2] == 1, update color
	ld a,(hl)		; $7036
	dec a			; $7037
	jr z,@updateColor	; $7038

	pop bc			; $703a
	jr @updateImmunity		; $703b

@updateColor:
	; Update color based on tile index stored in var32 (which may be outdated).
	ld e,Enemy.var32		; $703d
	ld a,(de)		; $703f
	call @lookupFloorColor		; $7040
	ldi (hl),a ; [oamFlagsBackup]
	ld (hl),a  ; [oamFlags]

@updateStoredColor:
	call @updateImmunity		; $7045
	ret z			; $7048

	pop bc			; $7049
	ld l,Enemy.counter2		; $704a
	ld (hl),90		; $704c

	; Write tile index to var32?
	ld l,Enemy.var32		; $704e
	ld (hl),e		; $7050
	ret			; $7051

;;
; Sets enemyCollisionMode depending on whether the gel's color matches the floor or not.
;
; @param[out]	zflag	z if immune
; @addr{7052}
@updateImmunity:
	call objectGetTileAtPosition		; $7052
	cp TILEINDEX_SOMARIA_BLOCK			; $7055
	ret z			; $7057

	call @lookupFloorColor		; $7058
	cp (hl)			; $705b
	ld b,ENEMYCOLLISION_COLOR_CHANGING_GEL		; $705c
	jr z,+			; $705e
	ld b,ENEMYCOLLISION_GOHMA_GEL		; $7060
+
	ld l,Enemy.enemyCollisionMode		; $7062
	ld (hl),b		; $7064
	ret			; $7065

;;
; @param	a	Tile index
; @param[out]	a	Color (defaults to red ($02) if floor tile not listed)
; @param[out]	hl	Enemy.oamFlagsBackup
; @addr{7066}
@lookupFloorColor:
	ld e,a			; $7066
	ld hl,@floorColors		; $7067
	call lookupKey		; $706a
	ld h,d			; $706d
	ld l,Enemy.oamFlagsBackup		; $706e
	ret c			; $7070
	ld a,$02		; $7071
	ret			; $7073

@floorColors:
	.db TILEINDEX_RED_FLOOR,         , $02
	.db TILEINDEX_YELLOW_FLOOR       , $06
	.db TILEINDEX_BLUE_FLOOR         , $01
	.db TILEINDEX_RED_TOGGLE_FLOOR   , $02
	.db TILEINDEX_YELLOW_TOGGLE_FLOOR, $06
	.db TILEINDEX_BLUE_TOGGLE_FLOOR  , $01
	.db $00

;;
; Sets the gel's color to something random that isn't its current color.
; @addr{7081}
_colorChangingGel_chooseRandomColor:
	call getRandomNumber_noPreserveVars		; $7081
	and $01			; $7084
	ld b,a			; $7086
	ld e,Enemy.oamFlagsBackup		; $7087
	ld a,(de)		; $7089
	res 0,a			; $708a
	add b			; $708c
	ld hl,@oamFlagMap		; $708d
	rst_addAToHl			; $7090

	ldi a,(hl)		; $7091
	ld (de),a ; [oamFlagsBackup]
	inc e			; $7093
	ld (de),a ; [oamFlags]
	ret			; $7095

@oamFlagMap:
	.db $02 $06 $01 $06 $ff $ff $01 $02


; ==============================================================================
; ENEMYID_AMBI_GUARD
;
; Variables:
;   relatedObj2: PARTID_DETECTION_HELPER; checks when Link is visible.
;   var30-var31: Movement script address
;   var32: Y-destination (reserved by movement script)
;   var33: X-destination (reserved by movement script)
;   var34: Bit 0 set when Link should be noticed; Bit 1 set once the guard has started
;          reacting to Link (shown exclamation mark).
;   var35: Nonzero if just hit with an indirect attack (moves more quickly)
;   var36: While this is nonzero, all "normal code" is ignored. It counts down to zero,
;          and once it's done, it sets var35 to 1 (move more quickly) and normal code
;          resumes. Used for the delay between noticing Link and taking action.
;   var37: Timer until guard "notices" scent seed.
;   var3a: When set to $ff, faces PARTID_DETECTION_HELPER?
;   var3b: When set to $ff, the guard immediately notices Link. (Written to by
;          PARTID_DETECTION_HELPER.)
; ==============================================================================
enemyCode54:
	jr z,@normalStatus	 		; $709e
	sub ENEMYSTATUS_NO_HEALTH			; $70a0
	ret c			; $70a2
	jp z,_ambiGuard_noHealth		; $70a3
	dec a			; $70a6
	jp nz,_ecom_updateKnockback		; $70a7
	call _ambiGuard_collisionOccured		; $70aa

@normalStatus:
	ld e,Enemy.subid		; $70ad
	ld a,(de)		; $70af
	rlca			; $70b0
	jp c,_ambiGuard_attacksLink		; $70b1


; Subids $00-$7f
_ambiGuard_tossesLinkOut:
	call _ambiGuard_checkSpottedLink		; $70b4
	call _ambiGuard_checkAlertTrigger		; $70b7
	ld e,Enemy.state		; $70ba
	ld a,(de)		; $70bc
	rst_jumpTable			; $70bd
	.dw _ambiGuard_tossesLinkOut_uninitialized
	.dw _ambiGuard_state_stub
	.dw _ambiGuard_state_stub
	.dw _ambiGuard_state_stub
	.dw _ambiGuard_state_stub
	.dw _ambiGuard_state_galeSeed
	.dw _ambiGuard_state_stub
	.dw _ambiGuard_state_stub
	.dw _ambiGuard_state8
	.dw _ambiGuard_state9
	.dw _ambiGuard_stateA
	.dw _ambiGuard_stateB
	.dw _ambiGuard_stateC
	.dw _ambiGuard_stateD
	.dw _ambiGuard_stateE
	.dw _ambiGuard_tossesLinkOut_stateF
	.dw _ambiGuard_tossesLinkOut_state10
	.dw _ambiGuard_tossesLinkOut_state11


_ambiGuard_tossesLinkOut_uninitialized:
	ld hl,_ambiGuard_tossesLinkOut_scriptTable		; $70e2
	call objectLoadMovementScript		; $70e5

	call _ambiGuard_commonInitialization		; $70e8
	ret nz			; $70eb

	ld e,Enemy.direction		; $70ec
	ld a,(de)		; $70ee
	jp enemySetAnimation		; $70ef


; NOTE: Guards don't seem to react to gale seeds? Is this unused?
_ambiGuard_state_galeSeed:
	call _ecom_galeSeedEffect		; $70f2
	ret c			; $70f5

	ld e,Enemy.var34		; $70f6
	ld a,(de)		; $70f8
	or a			; $70f9
	ld e,Enemy.var35		; $70fa
	call z,_ambiGuard_alertAllGuards		; $70fc
	call decNumEnemies		; $70ff
	jp enemyDelete		; $7102


_ambiGuard_state_stub:
	ret			; $7105


; Moving up
_ambiGuard_state8:
	ld e,Enemy.var32		; $7106
	ld a,(de)		; $7108
	ld h,d			; $7109
	ld l,Enemy.yh		; $710a
	cp (hl)			; $710c
	jr nc,@reachedDestination		; $710d
	call objectApplySpeed		; $710f
	jr _ambiGuard_animate		; $7112

@reachedDestination:
	ld a,(de)		; $7114
	ld (hl),a		; $7115
	jp _ambiGuard_runMovementScript		; $7116


; Moving right
_ambiGuard_state9:
	ld e,Enemy.xh		; $7119
	ld a,(de)		; $711b
	ld h,d			; $711c
	ld l,Enemy.var33		; $711d
	cp (hl)			; $711f
	jr nc,@reachedDestination		; $7120
	call objectApplySpeed		; $7122
	jr _ambiGuard_animate		; $7125

@reachedDestination:
	ld a,(hl)		; $7127
	ld (de),a		; $7128
	jp _ambiGuard_runMovementScript		; $7129


; Moving down
_ambiGuard_stateA:
	ld e,Enemy.yh		; $712c
	ld a,(de)		; $712e
	ld h,d			; $712f
	ld l,Enemy.var32		; $7130
	cp (hl)			; $7132
	jr nc,@reachedDestination		; $7133
	call objectApplySpeed		; $7135
	jr _ambiGuard_animate		; $7138

@reachedDestination:
	ld a,(hl)		; $713a
	ld (de),a		; $713b
	jp _ambiGuard_runMovementScript		; $713c


; Moving left
_ambiGuard_stateB:
	ld e,Enemy.var33		; $713f
	ld a,(de)		; $7141
	ld h,d			; $7142
	ld l,Enemy.xh		; $7143
	cp (hl)			; $7145
	jr nc,@reachedDestination		; $7146
	call objectApplySpeed		; $7148
	jr _ambiGuard_animate		; $714b

@reachedDestination:
	ld a,(de)		; $714d
	ld (hl),a		; $714e
	jp _ambiGuard_runMovementScript		; $714f


; Waiting
_ambiGuard_stateC:
_ambiGuard_stateE:
	call _ecom_decCounter1		; $7152
	jp z,_ambiGuard_runMovementScript		; $7155

_ambiGuard_animate:
	jp enemyAnimate		; $7158


; Standing in place for [counter1] frames, then turn the other way for 30 frames, then
; resume movemnet
_ambiGuard_stateD:
	call _ecom_decCounter1		; $715b
	ret nz			; $715e

	ld l,e			; $715f
	inc (hl) ; [state]

	ld l,Enemy.counter1		; $7161
	ld (hl),30		; $7163

	ld l,Enemy.angle		; $7165
	ld a,(hl)		; $7167
	xor $10			; $7168
	ld (hl),a		; $716a
	swap a			; $716b
	rlca			; $716d
	jp enemySetAnimation		; $716e


; Begin moving toward Link after noticing him
_ambiGuard_tossesLinkOut_stateF:
	ld h,d			; $7171
	ld l,e			; $7172
	inc (hl) ; [state]

	ld l,Enemy.counter1		; $7174
	ld (hl),90		; $7176
	call _ambiGuard_turnToFaceLink		; $7178
	ld a,SND_WHISTLE		; $717b
	jp playSound		; $717d


; Moving toward Link until screen fades out and Link gets booted out
_ambiGuard_tossesLinkOut_state10:
	call enemyAnimate		; $7180
	call _ecom_decCounter1		; $7183
	jr z,++		; $7186
	ld c,$18		; $7188
	call objectCheckLinkWithinDistance		; $718a
	jp nc,_ecom_applyVelocityForSideviewEnemyNoHoles		; $718d
++
	ld a,CUTSCENE_BOOTED_FROM_PALACE		; $7190
	ld (wCutsceneTrigger),a		; $7192
	ret			; $7195


_ambiGuard_tossesLinkOut_state11:
	ret			; $7196


_ambiGuard_attacksLink:
	call _ambiGuard_checkSpottedLink		; $7197
	call _ambiGuard_checkAlertTrigger		; $719a
	ld e,Enemy.state		; $719d
	ld a,(de)		; $719f
	rst_jumpTable			; $71a0
	.dw _ambiGuard_attacksLink_state_uninitialized
	.dw _ambiGuard_state_stub
	.dw _ambiGuard_state_stub
	.dw _ambiGuard_state_stub
	.dw _ambiGuard_state_stub
	.dw _ambiGuard_state_galeSeed
	.dw _ambiGuard_state_stub
	.dw _ambiGuard_state_stub
	.dw _ambiGuard_state8
	.dw _ambiGuard_state9
	.dw _ambiGuard_stateA
	.dw _ambiGuard_stateB
	.dw _ambiGuard_stateC
	.dw _ambiGuard_stateD
	.dw _ambiGuard_stateE
	.dw _ambiGuard_attacksLink_stateF
	.dw _ambiGuard_attacksLink_state10
	.dw _ambiGuard_attacksLink_state11


_ambiGuard_attacksLink_state_uninitialized:
	ld h,d			; $71c5
	ld l,Enemy.subid		; $71c6
	res 7,(hl)		; $71c8

	ld hl,_ambiGuard_attacksLink_scriptTable		; $71ca
	call objectLoadMovementScript		; $71cd

	ld h,d			; $71d0
	ld l,Enemy.subid		; $71d1
	set 7,(hl)		; $71d3

	call _ambiGuard_commonInitialization		; $71d5
	ret nz			; $71d8

	ld e,Enemy.direction		; $71d9
	ld a,(de)		; $71db
	jp enemySetAnimation		; $71dc


; Just noticed Link
_ambiGuard_attacksLink_stateF:
	ld h,d			; $71df
	ld l,e			; $71e0
	inc (hl) ; [state]

	ld l,Enemy.counter2		; $71e2
	ld a,(hl)		; $71e4
	or a			; $71e5
	jr nz,+			; $71e6
	ld (hl),60		; $71e8
+
	call _ambiGuard_createExclamationMark		; $71ea
	jr _ambiGuard_turnToFaceLink		; $71ed


; Looking at Link; counting down until he starts chasing him
_ambiGuard_attacksLink_state10:
	call _ecom_decCounter2		; $71ef
	jr z,@beginChasing	; $71f2

	ld a,(hl)		; $71f4
	cp 60			; $71f5
	ret nz			; $71f7

	ld a,SND_WHISTLE		; $71f8
	call playSound		; $71fa
	ld e,Enemy.var34		; $71fd
	jp _ambiGuard_alertAllGuards		; $71ff

@beginChasing:
	dec l			; $7202
	ld (hl),20 ; [counter1]
	ld l,e			; $7205
	inc (hl) ; [state]

	ld l,Enemy.speed		; $7207
	ld (hl),SPEED_180		; $7209
	ld l,Enemy.enemyCollisionMode		; $720b
	ld (hl),ENEMYCOLLISION_AMBI_GUARD_CHASING_LINK		; $720d

;;
; @addr{720f}
_ambiGuard_turnToFaceLink:
	call _ecom_updateCardinalAngleTowardTarget		; $720f
	swap a			; $7212
	rlca			; $7214
	jp enemySetAnimation		; $7215


; Currently chasing Link
_ambiGuard_attacksLink_state11:
	call _ecom_decCounter1		; $7218
	jr nz,++		; $721b
	ld (hl),20		; $721d
	call _ambiGuard_turnToFaceLink		; $721f
++
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $7222
	jp enemyAnimate		; $7225

;;
; Deletes self if Veran was defeated, otherwise spawns PARTID_DETECTION_HELPER.
;
; @param[out]	zflag	nz if caller should return immediately (deleted self)
; @addr{7228}
_ambiGuard_commonInitialization:
	ld hl,wGroup4Flags+$fc		; $7228
	bit 7,(hl)		; $722b
	jr z,++			; $722d
	call enemyDelete		; $722f
	or d			; $7232
	ret			; $7233
++
	call getFreePartSlot		; $7234
	jr nz,++		; $7237
	ld (hl),PARTID_DETECTION_HELPER		; $7239
	ld l,Part.relatedObj1		; $723b
	ld a,Enemy.start		; $723d
	ldi (hl),a		; $723f
	ld (hl),d		; $7240

	ld e,Enemy.relatedObj2		; $7241
	ld a,Part.start		; $7243
	ld (de),a		; $7245
	inc e			; $7246
	ld a,h			; $7247
	ld (de),a		; $7248

	ld h,d			; $7249
	ld l,Enemy.direction		; $724a
	ldi a,(hl)		; $724c
	swap a			; $724d
	rrca			; $724f
	ld (hl),a		; $7250
	call objectSetVisiblec2		; $7251
	xor a			; $7254
	ret			; $7255
++
	ld e,Enemy.state		; $7256
	xor a			; $7258
	ld (de),a		; $7259
	ret			; $725a

;;
; @addr{725b}
_ambiGuard_runMovementScript:
	call objectRunMovementScript		; $725b

	; Update animation
	ld e,Enemy.angle		; $725e
	ld a,(de)		; $7260
	and $18			; $7261
	swap a			; $7263
	rlca			; $7265
	jp enemySetAnimation		; $7266

;;
; When var36 is nonzero, this counts it down, then sets var35 to nonzero when var36
; reaches 0. (This alerts the guard to start moving faster.) Also, all other guards
; on-screen will be alerted in this way.
;
; As long as var36 is nonzero, this "returns from caller" (discards return address).
; @addr{7269}
_ambiGuard_checkAlertTrigger:
	ld h,d			; $7269
	ld l,Enemy.var36		; $726a
	ld a,(hl)		; $726c
	or a			; $726d
	ret z			; $726e

	pop bc ; return from caller

	dec (hl)		; $7270
	ld a,(hl)		; $7271
	dec a			; $7272
	jr nz,@stillCountingDown	; $7273

	; Check if in a standard movement state
	ld l,Enemy.state		; $7275
	ld a,(hl)		; $7277
	sub $08			; $7278
	cp $04			; $727a
	ret nc			; $727c

	; Update angle, animation based on state
	ld b,a			; $727d
	swap a			; $727e
	rrca			; $7280
	ld e,Enemy.angle		; $7281
	ld (de),a		; $7283
	ld a,b			; $7284
	jp enemySetAnimation		; $7285

@stillCountingDown:
	cp 59			; $7288
	ret nz			; $728a

	; NOTE: Why on earth is this sound played? SND_WHISTLE would make more sense...
	ld a,SND_MAKU_TREE_PAST		; $728b
	call playSound		; $728d

	; Alert all guards to start moving more quickly
	ld e,Enemy.var35		; $7290


;;
; @param	de	Variable to set on the guards. "var34" to alert them to Link
;			immediately, "var35" to make them patrol faster.
; @addr{7292}
_ambiGuard_alertAllGuards:
	ldhl FIRST_ENEMY_INDEX,Enemy.enabled		; $7292
---
	ld l,Enemy.id		; $7295
	ld a,(hl)		; $7297
	cp ENEMYID_AMBI_GUARD			; $7298
	jr nz,@nextEnemy	; $729a

	ld a,h			; $729c
	cp d			; $729d
	jr z,@nextEnemy	; $729e

	ld l,e			; $72a0
	ld a,(hl)		; $72a1
	or a			; $72a2
	jr nz,@nextEnemy	; $72a3

	inc (hl)		; $72a5
	bit 0,l			; $72a6
	jr z,@nextEnemy	; $72a8

	ld l,Enemy.var36		; $72aa
	ld (hl),60		; $72ac
@nextEnemy:
	inc h			; $72ae
	ld a,h			; $72af
	cp LAST_ENEMY_INDEX+1			; $72b0
	jr c,---		; $72b2
	ret			; $72b4


;;
; Checks for spotting Link, among other things?
; @addr{72b5}
_ambiGuard_checkSpottedLink:
	ld a,(wScentSeedActive)		; $72b5
	or a			; $72b8
	jr nz,@scentSeed	; $72b9

@normalCheck:
	; Notice Link if playing the flute.
	; (Doesn't work properly for harp tunes?)
	ld a,(wLinkPlayingInstrument)		; $72bb
	or a			; $72be
	jr nz,@faceLink	; $72bf

	; if var3a == $ff, turn toward part object?
	ld e,Enemy.var3a		; $72c1
	ld a,(de)		; $72c3
	inc a			; $72c4
	jr nz,@commonUpdate	; $72c5

	ld (de),a ; [var3a] = 0

	ld a,Object.yh		; $72c8
	call objectGetRelatedObject2Var		; $72ca
	ld b,(hl)		; $72cd
	ld l,Object.xh		; $72ce
	ld c,(hl)		; $72d0
	call objectGetRelativeAngle		; $72d1
	jr @alertGuardToMoveFast		; $72d4

@scentSeed:
	; When [var37] == 0, the guard notices the scent seed (turns toward it and has an
	; exclamation point).
	ld h,d			; $72d6
	ld l,Enemy.var37		; $72d7
	ld a,(hl)		; $72d9
	or a			; $72da
	jr z,@noticedScentSeed	; $72db

	ld a,(wFrameCounter)		; $72dd
	rrca			; $72e0
	jr c,@normalCheck	; $72e1
	dec (hl)		; $72e3
	jr @normalCheck		; $72e4

@noticedScentSeed:
	; Set the counter to more than the duration of a scent seed, so the guard only
	; turns toward it once...
	ld (hl),150 ; [var37]

@faceLink:
	call objectGetAngleTowardEnemyTarget		; $72e8

@alertGuardToMoveFast:
	; When reaching here, a == angle the guard should face
	ld h,d			; $72eb
	ld l,Enemy.var35		; $72ec
	inc (hl)		; $72ee
	inc l			; $72ef
	ld (hl),60 ; [var36]
	call _ambiGuard_setAngle		; $72f2

@commonUpdate:
	; If [var3b] == $ff, notice Link immediately.
	ld h,d			; $72f5
	ld l,Enemy.var3b		; $72f6
	ld a,(hl)		; $72f8
	ld (hl),$00		; $72f9
	inc a			; $72fb
	jr nz,++		; $72fc
	ld l,Enemy.var34		; $72fe
	ld a,(hl)		; $7300
	or a			; $7301
	jr nz,++		; $7302
	inc (hl) ; [var34]
	call _ambiGuard_setCounter2ForAttackingTypeOnly		; $7305
++
	ld e,Enemy.var34		; $7308
	ld a,(de)		; $730a
	rrca			; $730b
	jr nc,@haventSeenLinkYet	; $730c

	; Return if bit 1 of var34 set (already noticed Link)
	rrca			; $730e
	ret c			; $730f

	; Link is close enough to have been noticed. Do some extra checks for the "tossing
	; Link out" subids only.

	ld l,Enemy.subid		; $7310
	bit 7,(hl)		; $7312
	jr nz,@noticedLink	; $7314

	call checkLinkCollisionsEnabled		; $7316
	ret nc			; $7319

	ld a,(w1Link.zh)		; $731a
	rlca			; $731d
	ret c			; $731e

	; Link has been seen. Disable inputs, etc.

	ld a,$80		; $731f
	ld (wMenuDisabled),a		; $7321

	ld a,DISABLE_COMPANION|DISABLE_LINK		; $7324
	ld (wDisabledObjects),a		; $7326
	ld (wDisableScreenTransitions),a		; $7329

	; Wait for 60 frames
	ld e,Enemy.var36		; $732c
	ld a,60		; $732e
	ld (de),a		; $7330

	call _ambiGuard_createExclamationMark		; $7331

@noticedLink:
	; Mark bit 1 to indicate the exclamation mark was shown already, etc.
	ld h,d			; $7334
	ld l,Enemy.var34		; $7335
	set 1,(hl)		; $7337

	ld l,Enemy.state		; $7339
	ld (hl),$0f		; $733b

	; Delete PARTID_DETECTION_HELPER
	ld a,Object.health		; $733d
	call objectGetRelatedObject2Var		; $733f
	ld (hl),$00		; $7342
	ret			; $7344

@haventSeenLinkYet:
	; Was the guard hit with an indirect attack?
	inc e			; $7345
	ld a,(de) ; [var35]
	rrca			; $7347
	ret nc			; $7348

	; He was; update speed, make exclamation mark.
	xor a			; $7349
	ld (de),a		; $734a

	ld l,Enemy.speed		; $734b
	ld (hl),SPEED_140		; $734d

	; fall through

;;
; @addr{734f}
_ambiGuard_createExclamationMark:
	ld a,45		; $734f
	ld bc,$f408		; $7351
	jp objectCreateExclamationMark		; $7354


_ambiGuard_collisionOccured:
	; If already noticed Link, return
	ld e,Enemy.var34		; $7357
	ld a,(de)		; $7359
	or a			; $735a
	ret nz			; $735b

	; Check whether attack type was direct or indirect
	ld h,d			; $735c
	ld l,Enemy.var2a		; $735d
	ld a,(hl)		; $735f
	cp $80|ITEMCOLLISION_11+1			; $7360
	jr c,_ambiGuard_directAttackOccurred	; $7362

	cp $80|ITEMCOLLISION_GALE_SEED			; $7364
	ret z			; $7366

	; COLLISION_TYPE_SOMARIA_BLOCK or above (indirect attack)
	ld h,d			; $7367
	ld l,Enemy.var35		; $7368
	ld a,(hl)		; $736a
	or a			; $736b
	ret nz			; $736c

	inc (hl) ; [var35] = 1 (make guard move move quickly)
	inc l			; $736e
	ld (hl),90 ; [var36] (wait for 90 frames)

	ld l,Enemy.knockbackAngle		; $7371
	ld a,(hl)		; $7373
	xor $10			; $7374

	; fall through


;;
; @param	a	Angle
; @addr{7376}
_ambiGuard_setAngle:
	add $04			; $7376
	and $18			; $7378
	ld e,Enemy.angle		; $737a
	ld (de),a		; $737c

	swap a			; $737d
	rlca			; $737f
	jp enemySetAnimation		; $7380

;;
; A collision with one of Link's direct attacks (sword, fist, etc) occurred.
; @addr{7383}
_ambiGuard_directAttackOccurred:
	; Guard notices Link right away
	ld e,Enemy.var34		; $7383
	ld a,$01		; $7385
	ld (de),a		; $7387

;;
; Does some initialization for "attacking link" type only, when they just notice Link.
; @addr{7388}
_ambiGuard_setCounter2ForAttackingTypeOnly:
	ld e,Enemy.subid		; $7388
	ld a,(de)		; $738a
	rlca			; $738b
	ret nc			; $738c

	; For "attacking Link" subids only, do extra initialization
	ld e,Enemy.counter2		; $738d
	ld a,90		; $738f
	ld (de),a		; $7391
	ld e,Enemy.var36		; $7392
	xor a			; $7394
	ld (de),a		; $7395
	ret			; $7396


; Scampering away when health is 0
_ambiGuard_noHealth:
	ld e,Enemy.state2		; $7397
	ld a,(de)		; $7399
	rst_jumpTable			; $739a
	.dw @substate0
	.dw @substate1
	.dw @substate2

@substate0:
	ld h,d			; $73a1
	ld l,e			; $73a2
	inc (hl) ; [state2]

	ld l,Enemy.speedZ		; $73a4
	ld a,$00		; $73a6
	ldi (hl),a		; $73a8
	ld (hl),$ff		; $73a9

; Initial jump before moving away
@substate1:
	ld c,$20		; $73ab
	call objectUpdateSpeedZ_paramC		; $73ad
	ret nz			; $73b0

	; Landed
	ld l,Enemy.state2		; $73b1
	inc (hl)		; $73b3

	ld l,Enemy.speedZ		; $73b4
	ld a,<(-$1c0)		; $73b6
	ldi (hl),a		; $73b8
	ld (hl),>(-$1c0)		; $73b9

	ld l,Enemy.speed		; $73bb
	ld (hl),SPEED_140		; $73bd

	ld l,Enemy.knockbackAngle		; $73bf
	ld a,(hl)		; $73c1
	ld l,Enemy.angle		; $73c2
	ld (hl),a		; $73c4

	add $04			; $73c5
	and $18			; $73c7
	swap a			; $73c9
	rlca			; $73cb
	jp enemySetAnimation		; $73cc

; Moving away until off-screen
@substate2:
	ld e,Enemy.yh		; $73cf
	ld a,(de)		; $73d1
	cp LARGE_ROOM_HEIGHT<<4			; $73d2
	jp nc,enemyDelete		; $73d4

	ld e,Enemy.xh		; $73d7
	ld a,(de)		; $73d9
	cp LARGE_ROOM_WIDTH<<4			; $73da
	jp nc,enemyDelete		; $73dc

	call objectApplySpeed		; $73df
	ld c,$20		; $73e2
	call objectUpdateSpeedZ_paramC		; $73e4
	jp nz,enemyAnimate		; $73e7

	; Landed on ground
	ld l,Enemy.speedZ		; $73ea
	ld a,<(-$1c0)		; $73ec
	ldi (hl),a		; $73ee
	ld (hl),>(-$1c0)		; $73ef
	ret			; $73f1


; The tables below define the guards' patrol patterns.
; See include/movementscript_commands.s.
_ambiGuard_tossesLinkOut_scriptTable:
	.dw @subid00
	.dw @subid01
	.dw @subid02
	.dw @subid03
	.dw @subid04
	.dw @subid05
	.dw @subid06
	.dw @subid07
	.dw @subid08
	.dw @subid09
	.dw @subid0a
	.dw @subid0b
	.dw @subid0c

@subid00:
	.db SPEED_c0
	.db DIR_UP
@@loop:
	ms_up    $18
	ms_left  $28
	ms_down  $58
	ms_right $68
	ms_loop  @@loop

@subid01:
	.db SPEED_c0
	.db DIR_RIGHT
@@loop:
	ms_right $30
	ms_state 15, $0d
	ms_right $58
	ms_wait  30
	ms_left  $30
	ms_state 15, $0d
	ms_left  $08
	ms_wait  30
	ms_loop  @@loop

@subid02:
	.db SPEED_80
	.db DIR_RIGHT
@@loop:
	ms_right $78
	ms_down  $18
	ms_wait  60
	ms_left  $38
	ms_down  $18
	ms_wait  60
	ms_right $58
	ms_loop  @@loop

@subid03:
	.db SPEED_80
	.db DIR_RIGHT
@@loop:
	ms_right $78
	ms_up    $38
	ms_wait  60
	ms_left  $18
	ms_down  $38
	ms_wait  60
	ms_right $48
	ms_loop  @@loop

@subid04:
	.db SPEED_80
	.db DIR_DOWN
@@loop:
	ms_down  $38
	ms_right $48
	ms_wait  60
	ms_left  $18
	ms_down  $38
	ms_wait  60
	ms_up    $18
	ms_right $48
	ms_state 15, $0d
	ms_wait  40
	ms_state 15, $0d
	ms_loop  @@loop

@subid05:
	.db SPEED_80
	.db DIR_UP
@@loop:
	ms_up    $38
	ms_state 15, $0d
	ms_wait  40
	ms_state 15, $0d
	ms_left  $38
	ms_down  $58
	ms_left  $38
	ms_wait  60
	ms_right $68
	ms_state 15, $0d
	ms_wait  40
	ms_state 15, $0d
	ms_loop  @@loop

@subid06:
	.db SPEED_80
	.db DIR_RIGHT
@@loop:
	ms_right $38
	ms_down  $48
	ms_right $38
	ms_wait  60
	ms_down  $68
	ms_left  $18
	ms_up    $18
	ms_loop  @@loop

@subid07:
	.db SPEED_80
	.db DIR_UP
@@loop:
	ms_up    $18
	ms_right $88
	ms_down  $68
	ms_left  $68
	ms_up    $48
	ms_left  $68
	ms_wait  60
	ms_loop  @@loop

@subid08:
	.db SPEED_80
	.db DIR_LEFT
@@loop:
	ms_left  $18
	ms_state 15, $0d
	ms_up    $18
	ms_state 15, $0d
	ms_right $78
	ms_state 15, $0d
	ms_down  $58
	ms_state 15, $0d
	ms_left  $48
	ms_loop  @@loop

@subid09:
	.db SPEED_80
	.db DIR_RIGHT
@@loop:
	ms_right $78
	ms_state 15, $0d
	ms_up    $18
	ms_state 15, $0d
	ms_left  $28
	ms_state 15, $0d
	ms_down  $58
	ms_state 15, $0d
	ms_right $58
	ms_loop  @@loop

@subid0a:
	.db SPEED_80
	.db DIR_DOWN
@@loop:
	ms_wait  127
	ms_loop  @@loop

@subid0b:
	.db SPEED_80
	.db DIR_RIGHT
@@loop:
	ms_wait  127
	ms_loop  @@loop

@subid0c:
	.db SPEED_80
	.db DIR_LEFT
@@loop:
	ms_wait  127
	ms_loop  @@loop


_ambiGuard_attacksLink_scriptTable:
	.dw @subid80
	.dw @subid81
	.dw @subid82
	.dw @subid83
	.dw @subid84
	.dw @subid85
	.dw @subid86
	.dw @subid87
	.dw @subid88
	.dw @subid89
	.dw @subid8a
	.dw @subid8b
	.dw @subid8c


@subid80:
	.db SPEED_c0
	.db DIR_UP
@@loop:
	ms_up    $18
	ms_left  $28
	ms_down  $58
	ms_right $68
	ms_loop  @@loop

@subid81:
	.db SPEED_c0
	.db DIR_RIGHT
@@loop:
	ms_right $30
	ms_state 15, $0d
	ms_right $58
	ms_wait  30
	ms_left  $30
	ms_state 15, $0d
	ms_left  $08
	ms_wait  30
	ms_loop  @@loop

@subid82:
	.db SPEED_80
	.db DIR_DOWN
@@loop:
	ms_down  $88
	ms_left  $28
	ms_up    $48
	ms_state 15, $0d
	ms_down  $88
	ms_right $98
	ms_up    $28
	ms_left  $28
	ms_down  $48
	ms_state 15, $0d
	ms_up    $28
	ms_right $98
	ms_loop  @@loop

@subid83:
	.db SPEED_80
	.db DIR_UP
@@loop:
	ms_up    $58
	ms_right $d8
	ms_up    $28
	ms_left  $98
	ms_down  $58
	ms_right $d8
	ms_down  $88
	ms_left  $98
	ms_up    $78
	ms_loop  @@loop

@subid84:
	.db SPEED_80
	.db DIR_UP
@@loop:
	ms_up    $18
	ms_right $d8
	ms_down  $88
	ms_left  $18
	ms_loop  @@loop

@subid85:
	.db SPEED_80
	.db DIR_DOWN
@@loop:
	ms_down  $88
	ms_left  $18
	ms_up    $18
	ms_right $d8
	ms_loop  @@loop

@subid86:
	.db SPEED_80
	.db DIR_DOWN
@@loop:
	ms_down  $58
	ms_left  $28
	ms_up    $28
	ms_right $68
	ms_loop  @@loop

@subid87:
	.db SPEED_80
	.db DIR_RIGHT
@@loop:
	ms_right $c8
	ms_up    $28
	ms_left  $88
	ms_down  $58
	ms_loop  @@loop

@subid88:
	.db SPEED_80
	.db DIR_UP
@@loop:
	ms_up    $58
	ms_left  $58
	ms_down  $88
	ms_right $98
	ms_loop  @@loop

@subid89:
	.db SPEED_80
	.db DIR_UP
@@loop:
	ms_up    $28
	ms_left  $38
	ms_down  $88
	ms_right $98
	ms_loop  @@loop

@subid8a:
	.db SPEED_80
	.db DIR_DOWN
@@loop:
	ms_down  $98
	ms_right $c8
	ms_up    $18
	ms_left  $a8
	ms_wait  60
	ms_right $c8
	ms_down  $98
	ms_left  $a8
	ms_up    $18
	ms_wait  60
	ms_loop  @@loop

@subid8b:
	.db SPEED_80
	.db DIR_UP
@@loop:
	ms_up    $18
	ms_left  $28
	ms_down  $58
	ms_right $48
	ms_down  $98
	ms_left  $28
	ms_up    $58
	ms_right $48
	ms_loop  @@loop

@subid8c:
	.db SPEED_80
	.db DIR_LEFT
@@loop:
	ms_left  $78
	ms_wait  60
	ms_down  $58
	ms_wait  60
	ms_right $78
	ms_wait  60
	ms_up    $58
	ms_wait  60
	ms_loop  @@loop



; ==============================================================================
; ENEMYID_CANDLE
;
; Variables:
;   relatedObj1: reference to INTERACID_EXPLOSION while exploding
; ==============================================================================
enemyCode55:
	call _ecom_checkHazards		; $760a
	jr z,@normalStatus	; $760d
	sub ENEMYSTATUS_NO_HEALTH			; $760f
	ret c			; $7611

	; ENEMYSTATUS_JUST_HIT or ENEMYSTATUS_KNOCKBACK
	; Check for ember seed collision to light self on fire
	ld e,Enemy.var2a		; $7612
	ld a,(de)		; $7614
	cp $80|ITEMCOLLISION_EMBER_SEED			; $7615
	jr nz,@normalStatus	; $7617

	ld e,Enemy.state		; $7619
	ld a,(de)		; $761b
	cp $0a			; $761c
	jr nc,@normalStatus	; $761e

	ld a,$0a		; $7620
	ld (de),a		; $7622

@normalStatus:
	ld e,Enemy.state		; $7623
	ld a,(de)		; $7625
	rst_jumpTable			; $7626
	.dw _candle_state_uninitialized
	.dw _candle_state_stub
	.dw _candle_state_stub
	.dw _candle_state_stub
	.dw _candle_state_stub
	.dw _candle_state_stub
	.dw _candle_state_stub
	.dw _candle_state_stub
	.dw _candle_state8
	.dw _candle_state9
	.dw _candle_stateA
	.dw _candle_stateB
	.dw _candle_stateC
	.dw _candle_stateD
	.dw _candle_stateE


_candle_state_uninitialized:
	ld e,Enemy.counter1		; $7645
	ld a,30		; $7647
	ld (de),a		; $7649

	ld a,SPEED_40		; $764a
	jp _ecom_setSpeedAndState8AndVisible		; $764c


_candle_state_stub:
	ret			; $764f


; Standing still for [counter1] frames
_candle_state8:
	call _ecom_decCounter1		; $7650
	ret nz			; $7653

	ld l,e			; $7654
	inc (hl) ; [state]

	ld l,Enemy.counter1		; $7656
	ld (hl),90		; $7658

	; Choose random angle
	call getRandomNumber_noPreserveVars		; $765a
	and $18			; $765d
	add $04			; $765f
	ld e,Enemy.angle		; $7661
	ld (de),a		; $7663
	ld a,$01		; $7664
	jp enemySetAnimation		; $7666


; Walking for [counter1] frames
_candle_state9:
	call _ecom_decCounter1		; $7669
	jr nz,++		; $766c

	ld (hl),30 ; [counter1]
	ld l,e			; $7670
	dec (hl) ; [state]
	xor a			; $7672
	call enemySetAnimation		; $7673
++
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $7676
	jr _candle_animate		; $7679


; Just lit on fire
_candle_stateA:
	ld b,PARTID_CANDLE_FLAME		; $767b
	call _ecom_spawnProjectile		; $767d
	ret nz			; $7680

	call _ecom_incState		; $7681

	ld l,Enemy.counter1		; $7684
	ld (hl),120		; $7686

	ld l,Enemy.speed		; $7688
	ld (hl),SPEED_100		; $768a

	ld a,$02		; $768c
	jp enemySetAnimation		; $768e


; Moving slowly at first
_candle_stateB:
	call _ecom_decCounter1		; $7691
	jr nz,_candle_applySpeed		; $7694

	ld (hl),120 ; [counter1]
	ld l,e			; $7698
	inc (hl) ; [state]

	ld l,Enemy.speed		; $769a
	ld (hl),SPEED_200		; $769c
	ld a,$03		; $769e
	call enemySetAnimation		; $76a0

_candle_applySpeed:
	call objectApplySpeed		; $76a3
	call _ecom_bounceOffWallsAndHoles		; $76a6

_candle_animate:
	jp enemyAnimate		; $76a9


; Moving faster
_candle_stateC:
	call _ecom_decCounter1		; $76ac
	jr nz,_candle_applySpeed	; $76af

	ld (hl),60 ; [counter1]
	ld l,e			; $76b3
	inc (hl) ; [state]


; Flickering visibility, about to explode
_candle_stateD:
	call _ecom_flickerVisibility		; $76b5
	call _ecom_decCounter1		; $76b8
	jr nz,_candle_applySpeed	; $76bb

	inc (hl) ; [counter1] = 1

	; Create an explosion object; but the collisions are still provided by the candle
	; object, so this doesn't delete itself yet.
	ld b,INTERACID_EXPLOSION		; $76be
	call objectCreateInteractionWithSubid00		; $76c0
	ret nz			; $76c3
	ld a,h			; $76c4
	ld h,d			; $76c5
	ld l,Enemy.relatedObj1+1		; $76c6
	ldd (hl),a		; $76c8
	ld (hl),Interaction.start		; $76c9

	ld l,Enemy.state		; $76cb
	inc (hl)		; $76cd

	ld l,Enemy.enemyCollisionMode		; $76ce
	ld (hl),ENEMYCOLLISION_PODOBOO		; $76d0

	jp objectSetInvisible		; $76d2


; Waiting for explosion to end
_candle_stateE:
	ld a,Object.animParameter		; $76d5
	call objectGetRelatedObject1Var		; $76d7
	ld a,(hl)		; $76da
	or a			; $76db
	ret z			; $76dc

	rlca			; $76dd
	jr c,@done	; $76de

	; Explosion radius increased
	ld (hl),$00 ; [child.animParameter]
	ld l,Enemy.collisionRadiusY		; $76e2
	ld a,$0c		; $76e4
	ldi (hl),a		; $76e6
	ld (hl),a		; $76e7
	ret			; $76e8

@done:
	call markEnemyAsKilledInRoom		; $76e9
	call decNumEnemies		; $76ec
	jp enemyDelete		; $76ef


; ==============================================================================
; ENEMYID_KING_MOBLIN_MINION
; ==============================================================================
enemyCode56:
	jpab bank10.enemyCode56_body		; $76f2


; ==============================================================================
; ENEMYID_VERAN_POSSESSION_BOSS
;
; Variables:
;   relatedObj1: For subid 2 (veran ghost/human), this is a reference to subid 0 or 1
;                (nayru/ambi form).
;   var30: Animation index
;   var31/var32: Target position when moving
;   var33: Number of hits remaining
;   var34: Current pillar index
;   var35: Bit 0 set if already showed veran's "taunting" text after using switch hook
; ==============================================================================
enemyCode61:
	jr z,@normalStatus	; $76fa
	sub ENEMYSTATUS_NO_HEALTH			; $76fc
	ret c			; $76fe

	; ENEMYSTATUS_KNOCKBACK or ENEMYSTATUS_JUST_HIT
	call _veranPossessionBoss_wasHit		; $76ff

@normalStatus:
	call _ecom_getSubidAndCpStateTo08		; $7702
	jr c,@commonState	; $7705
	ld a,b			; $7707
	rst_jumpTable			; $7708
	.dw _veranPossessionBoss_subid0
	.dw _veranPossessionBoss_subid1
	.dw _veranPossessionBoss_subid2
	.dw _veranPossessionBoss_subid3

@commonState:
	rst_jumpTable			; $7711
	.dw _veranPossessionBoss_state_uninitialized
	.dw _veranPossessionBoss_state_stub
	.dw _veranPossessionBoss_state_stub
	.dw _veranPossessionBoss_state_switchHook
	.dw _veranPossessionBoss_state_stub
	.dw _veranPossessionBoss_state_stub
	.dw _veranPossessionBoss_state_stub
	.dw _veranPossessionBoss_state_stub


_veranPossessionBoss_state_uninitialized:
	bit 1,b			; $7722
	jr nz,++		; $7724
	ld a,ENEMYID_VERAN_POSSESSION_BOSS		; $7726
	ld (wEnemyIDToLoadExtraGfx),a		; $7728
++
	ld a,b			; $772b
	add a			; $772c
	add b			; $772d
	ld e,Enemy.var30		; $772e
	ld (de),a		; $7730
	call enemySetAnimation		; $7731

	call objectSetVisible82		; $7734

	ld a,SPEED_200		; $7737
	call _ecom_setSpeedAndState8		; $7739

	ld l,Enemy.subid		; $773c
	bit 1,(hl)		; $773e
	ret z			; $7740

	; For subids 2-3 only
	ld l,Enemy.oamFlagsBackup		; $7741
	ld a,$01		; $7743
	ldi (hl),a ; [oamFlagsBackup]
	ld (hl),a  ; [oamFlags]

	ld l,Enemy.counter1		; $7747
	ld (hl),$0c		; $7749

	ld l,Enemy.speed		; $774b
	ld (hl),SPEED_80		; $774d
	ret			; $774f


_veranPossessionBoss_state_switchHook:
	inc e			; $7750
	ld a,(de)		; $7751
	rst_jumpTable			; $7752
	.dw @substate0
	.dw enemyAnimate
	.dw enemyAnimate
	.dw @substate3

@substate0:
	ld h,d			; $775b
	ld l,Enemy.collisionType		; $775c
	res 7,(hl)		; $775e
	jp _ecom_incState2		; $7760

@substate3:
	ld b,$0b		; $7763
	call _ecom_fallToGroundAndSetState		; $7765
	ld l,Enemy.counter1		; $7768
	ld (hl),40		; $776a
	ret			; $776c


_veranPossessionBoss_state_stub:
	ret			; $776d


; Possessed Nayru
_veranPossessionBoss_subid0:
	ld a,(de)		; $776e
	sub $08			; $776f
	rst_jumpTable			; $7771
	.dw _veranPossessionBoss_nayruAmbi_state8
	.dw _veranPossessionBoss_nayruAmbi_state9
	.dw _veranPossessionBoss_nayruAmbi_stateA
	.dw _veranPossessionBoss_nayruAmbi_stateB
	.dw _veranPossessionBoss_nayru_stateC
	.dw _veranPossessionBoss_nayru_stateD
	.dw _veranPossessionBoss_nayruAmbi_stateE
	.dw _veranPossessionBoss_nayruAmbi_stateF
	.dw _veranPossessionBoss_nayruAmbi_state10
	.dw _veranPossessionBoss_nayruAmbi_state11
	.dw _veranPossessionBoss_nayruAmbi_state12
	.dw _veranPossessionBoss_nayruAmbi_state13
	.dw _veranPossessionBoss_nayru_state14


; Initialization
_veranPossessionBoss_nayruAmbi_state8:
	call getFreePartSlot		; $778c
	ret nz			; $778f

	ld (hl),PARTID_SHADOW		; $7790
	ld l,Part.var03		; $7792
	ld (hl),$06 ; Y-offset of shadow relative to self

	ld l,Part.relatedObj1		; $7796
	ld a,Enemy.start		; $7798
	ldi (hl),a		; $779a
	ld (hl),d		; $779b

	; Go to state 9
	call _veranPossessionBoss_nayruAmbi_beginMoving		; $779c

	ld l,Enemy.var3f		; $779f
	set 5,(hl)		; $77a1

	ld l,Enemy.var33		; $77a3
	ld (hl),$03		; $77a5
	inc l			; $77a7
	dec (hl) ; [var34] = $ff (current pillar index)

	xor a			; $77a9
	ld (wTmpcfc0.genericCutscene.cfd0),a		; $77aa

	ld a,MUS_BOSS		; $77ad
	ld (wActiveMusic),a		; $77af
	jp playSound		; $77b2


; Flickering before moving
_veranPossessionBoss_nayruAmbi_state9:
	call _ecom_decCounter1		; $77b5
	jp nz,_ecom_flickerVisibility		; $77b8

	ld l,e			; $77bb
	inc (hl) ; [state]

	ld l,Enemy.zh		; $77bd
	ld (hl),-2		; $77bf
	call objectSetInvisible		; $77c1

	; Choose a position to move to.
	; First it chooses a pillar randomly, then it chooses the side of the pillar based
	; on where Link is in relation.

@choosePillar:
	call getRandomNumber_noPreserveVars		; $77c4
	and $0e			; $77c7
	cp $0b			; $77c9
	jr nc,@choosePillar	; $77cb

	; Pillar must be different from last one
	ld h,d			; $77cd
	ld l,Enemy.var34		; $77ce
	cp (hl)			; $77d0
	jr z,@choosePillar	; $77d1

	ld (hl),a ; [var34]

	ld hl,@pillarList		; $77d4
	rst_addAToHl			; $77d7
	ldi a,(hl)		; $77d8
	ld b,a			; $77d9
	ld c,(hl)		; $77da
	push bc			; $77db

	; Choose the side of the pillar that is furthest from Link
	ldh a,(<hEnemyTargetY)	; $77dc
	ldh (<hFF8F),a	; $77de
	ldh a,(<hEnemyTargetX)	; $77e0
	ldh (<hFF8E),a	; $77e2
	call objectGetRelativeAngleWithTempVars		; $77e4
	add $04			; $77e7
	and $18			; $77e9
	rrca			; $77eb
	rrca			; $77ec

	ld hl,@pillarOffsets		; $77ed
	rst_addAToHl			; $77f0
	pop bc			; $77f1
	ldi a,(hl)		; $77f2
	add b			; $77f3
	ld e,Enemy.var31		; $77f4
	ld (de),a ; [var31]
	ld a,(hl)		; $77f7
	add c			; $77f8
	inc e			; $77f9
	ld (de),a ; [var32]

	ld a,SND_CIRCLING		; $77fb
	jp playSound		; $77fd

@pillarList:
	.db $58 $58
	.db $58 $98
	.db $38 $38
	.db $38 $b8
	.db $78 $38
	.db $78 $b8

@pillarOffsets:
	.db $e8 $00
	.db $00 $10
	.db $10 $00
	.db $00 $f0


; Moving to new position
_veranPossessionBoss_nayruAmbi_stateA:
	ld h,d			; $7814
	ld l,Enemy.var31		; $7815
	call _ecom_readPositionVars		; $7817
	sub c			; $781a
	add $02			; $781b
	cp $05			; $781d
	jp nc,_ecom_moveTowardPosition		; $781f

	ldh a,(<hFF8F)	; $7822
	sub b			; $7824
	add $02			; $7825
	cp $05			; $7827
	jp nc,_ecom_moveTowardPosition		; $7829

	; Reached target position.

	ld l,Enemy.yh		; $782c
	ld (hl),b		; $782e
	ld l,Enemy.xh		; $782f
	ld (hl),c		; $7831

	ld l,e			; $7832
	inc (hl) ; [state]

	ld l,Enemy.zh		; $7834
	ld (hl),$00		; $7836

	ld l,Enemy.counter1		; $7838
	ld (hl),30		; $783a
	ret			; $783c


; Just reached new position
_veranPossessionBoss_nayruAmbi_stateB:
	call _ecom_decCounter1		; $783d
	jp nz,_ecom_flickerVisibility		; $7840

	call getRandomNumber_noPreserveVars		; $7843
	and $0f			; $7846
	ld b,a			; $7848

	ld h,d			; $7849
	ld l,Enemy.subid		; $784a
	ld a,(hl)		; $784c
	add a			; $784d
	add a			; $784e
	add (hl)		; $784f
	ld l,Enemy.var33		; $7850
	add (hl)		; $7852
	dec a			; $7853

	ld hl,@attackProbabilities		; $7854
	rst_addAToHl			; $7857
	ld a,b			; $7858
	cp (hl)			; $7859
	jr c,@beginAttacking			; $785a

	; Move again
	call _veranPossessionBoss_nayruAmbi_beginMoving		; $785c
	ld (hl),30		; $785f
	jp _ecom_flickerVisibility		; $7861

@beginAttacking:
	call _ecom_incState		; $7864

	ld l,Enemy.counter1		; $7867
	ld (hl),30		; $7869

	ld l,Enemy.collisionType		; $786b
	set 7,(hl)		; $786d

	ld l,Enemy.var30		; $786f
	ld a,(hl)		; $7871
	inc a			; $7872
	call enemySetAnimation		; $7873
	jp objectSetVisiblec2		; $7876

; Each byte is the probability of veran attacking when she has 'n' hits left (ie. 1st byte is
; for when she has 1 hit left). Higher values mean a higher probability of attacking. If
; she doesn't attack, she moves again.
@attackProbabilities:
	.db $05 $0a $10 $10 $10 ; Nayru
	.db $05 $06 $08 $08 $08 ; Ambi


; Delay before attacking with projectiles. (Nayru only)
_veranPossessionBoss_nayru_stateC:
	call _ecom_decCounter1		; $7883
	ret nz			; $7886

	ld (hl),142 ; [counter1]
	ld l,e			; $7889
	inc (hl) ; [state]

	ld b,PARTID_VERAN_PROJECTILE		; $788b
	jp _ecom_spawnProjectile		; $788d


; Attacking with projectiles. (This is only Nayru's state D, but Ambi's state D may call
; this if it's not spawning spiders instead.)
_veranPossessionBoss_nayru_stateD:
	call _ecom_decCounter1		; $7890
	ret nz			; $7893

_veranPossessionBoss_doneAttacking:
	call _veranPossessionBoss_nayruAmbi_beginMoving		; $7894

	ld l,Enemy.collisionType		; $7897
	res 7,(hl)		; $7899

	ld l,Enemy.var30		; $789b
	ld a,(hl)		; $789d
	jp enemySetAnimation		; $789e


; Just shot with mystery seeds
_veranPossessionBoss_nayruAmbi_stateE:
	call _ecom_decCounter2		; $78a1
	ret nz			; $78a4

	; Spawn veran ghost form
	call getFreeEnemySlot_uncounted		; $78a5
	ret nz			; $78a8
	ld (hl),ENEMYID_VERAN_POSSESSION_BOSS		; $78a9
	inc l			; $78ab
	ld (hl),$02 ; [child.subid]

	; [child.var33] = [this.var33] (remaining hits before death)
	ld l,Enemy.var33		; $78ae
	ld e,l			; $78b0
	ld a,(de)		; $78b1
	ld (hl),a		; $78b2

	ld l,Enemy.relatedObj1		; $78b3
	ld a,Enemy.start		; $78b5
	ldi (hl),a		; $78b7
	ld (hl),d		; $78b8

	ld bc,$fc04		; $78b9
	call objectCopyPositionWithOffset		; $78bc

	call _ecom_incState		; $78bf

	ld l,Enemy.collisionType		; $78c2
	res 7,(hl)		; $78c4

	ld l,Enemy.oamFlagsBackup		; $78c6
	ld a,$01		; $78c8
	ldi (hl),a ; [child.oamFlagsBackup]
	ld (hl),a  ; [child.oamFlags]

	jp objectSetVisible83		; $78cc


; Collapsed (ghost Veran is showing)
_veranPossessionBoss_nayruAmbi_stateF:
	ret			; $78cf


; Veran just returned to nayru/ambi's body
_veranPossessionBoss_nayruAmbi_state10:
	ld h,d			; $78d0
	ld l,e			; $78d1
	inc (hl) ; [state]

	ld l,Enemy.oamFlagsBackup		; $78d3
	ld a,$06		; $78d5
	ldi (hl),a ; [oamFlagsBackup]
	ld (hl),a  ; [oamFlags]

	ld l,Enemy.counter1		; $78d9
	ld (hl),15		; $78db
	jp objectSetVisible82		; $78dd


; Remains collapsed on the floor for a few frames before moving again
_veranPossessionBoss_nayruAmbi_state11:
	call _ecom_decCounter1		; $78e0
	ret nz			; $78e3

	ld l,Enemy.var30		; $78e4
	ld a,(hl)		; $78e6
	call enemySetAnimation		; $78e7


_veranPossessionBoss_nayruAmbi_beginMoving:
	ld h,d			; $78ea
	ld l,Enemy.state		; $78eb
	ld (hl),$09		; $78ed

	ld l,Enemy.counter1		; $78ef
	ld (hl),60		; $78f1
	ret			; $78f3


; Veran was just defeated.
_veranPossessionBoss_nayruAmbi_state12:
	ld a,(wTextIsActive)		; $78f4
	or a			; $78f7
	ret nz			; $78f8
	call _ecom_incState		; $78f9
	ld a,$02		; $78fc
	jp fadeoutToWhiteWithDelay		; $78fe


; Waiting for screen to go white
_veranPossessionBoss_nayruAmbi_state13:
	ld a,(wPaletteThread_mode)		; $7901
	or a			; $7904
	ret nz			; $7905

	call _ecom_incState		; $7906
	jpab clearAllItemsAndPutLinkOnGround		; $7909


; Delete all objects (including self), resume cutscene with a newly created object
_veranPossessionBoss_nayru_state14:
	call clearWramBank1		; $7911

	ld hl,w1Link.enabled		; $7914
	ld (hl),$03		; $7917

	call getFreeInteractionSlot		; $7919
	ld (hl),INTERACID_NAYRU_SAVED_CUTSCENE		; $791c
	ret			; $791e


; Possessed Ambi
_veranPossessionBoss_subid1:
	ld a,(de)		; $791f
	sub $08			; $7920
	rst_jumpTable			; $7922
	.dw _veranPossessionBoss_nayruAmbi_state8
	.dw _veranPossessionBoss_nayruAmbi_state9
	.dw _veranPossessionBoss_nayruAmbi_stateA
	.dw _veranPossessionBoss_nayruAmbi_stateB
	.dw _veranPossessionBoss_ambi_stateC
	.dw _veranPossessionBoss_ambi_stateD
	.dw _veranPossessionBoss_nayruAmbi_stateE
	.dw _veranPossessionBoss_nayruAmbi_stateF
	.dw _veranPossessionBoss_nayruAmbi_state10
	.dw _veranPossessionBoss_nayruAmbi_state11
	.dw _veranPossessionBoss_nayruAmbi_state12
	.dw _veranPossessionBoss_nayruAmbi_state13
	.dw _veranPossessionBoss_ambi_state14


; Delay before attacking with projectiles or spawning spiders. (Ambi only)
_veranPossessionBoss_ambi_stateC:
	call _ecom_decCounter1		; $793d
	ret nz			; $7940

	ld (hl),142 ; [counter1]
	ld l,e			; $7943
	inc (hl) ; [state]

	call getRandomNumber_noPreserveVars		; $7945
	and $0f			; $7948
	ld b,a			; $794a

	ld e,Enemy.var33		; $794b
	ld a,(de)		; $794d
	dec a			; $794e
	ld hl,@spiderSpawnProbabilities		; $794f
	rst_addAToHl			; $7952
	ld a,b			; $7953
	cp (hl)			; $7954

	; Set [var03] to 1 if we're spawning spiders, 0 otherwise
	ld h,d			; $7955
	ld l,Enemy.var03		; $7956
	ld (hl),$01		; $7958
	ret nc			; $795a

	dec (hl)		; $795b
	ld b,PARTID_VERAN_PROJECTILE		; $795c
	jp _ecom_spawnProjectile		; $795e

; Each byte is the probability of veran spawning spiders when she has 'n' hits left (ie.
; 1st byte is for when she has 1 hit left). Lower values mean a higher probability of
; spawning spiders. If she doesn't spawn spiders, she fires projectiles.
@spiderSpawnProbabilities:
	.db $08 $08 $0a $0a $0a


; Attacking with projectiles or spiders. (Ambi only)
_veranPossessionBoss_ambi_stateD:
	; Jump to Nayru's state D if we're firing projectiles
	ld e,Enemy.var03		; $7966
	ld a,(de)		; $7968
	or a			; $7969
	jp z,_veranPossessionBoss_nayru_stateD		; $796a

	; Spawning spiders

	call _ecom_decCounter1		; $796d
	jp z,_veranPossessionBoss_doneAttacking		; $7970

	; Spawn spider every 32 frames
	ld a,(hl) ; [counter1]
	and $1f			; $7974
	ret nz			; $7976

	ld a,(wNumEnemies)		; $7977
	cp $06			; $797a
	ret nc			; $797c

	ld b,ENEMYID_VERAN_SPIDER		; $797d
	jp _ecom_spawnEnemyWithSubid01		; $797f


; Ambi-specific cutscene after Veran defeated
_veranPossessionBoss_ambi_state14:
	ld a,(wPaletteThread_mode)		; $7982
	or a			; $7985
	ret nz			; $7986

	; Deletes all objects, including self
	call clearWramBank1		; $7987

	ld a,$01		; $798a
	ld (wNumEnemies),a		; $798c

	ld hl,w1Link.enabled		; $798f
	ld (hl),$03		; $7992

	ld l,<w1Link.yh		; $7994
	ld (hl),$58		; $7996
	ld l,<w1Link.xh		; $7998
	ld (hl),$78		; $799a

	call setCameraFocusedObjectToLink		; $799c
	call resetCamera		; $799f

	; Spawn subid 3 of this object
	call getFreeEnemySlot_uncounted		; $79a2
	ld (hl),ENEMYID_VERAN_POSSESSION_BOSS		; $79a5
	inc l			; $79a7
	ld (hl),$03 ; [subid]

	ld l,Enemy.yh		; $79aa
	ld (hl),$48		; $79ac
	ld l,Enemy.xh		; $79ae
	ld (hl),$78		; $79b0
	ret			; $79b2


; Veran emerged in human form
_veranPossessionBoss_subid2:
	ld a,(de)		; $79b3
	sub $08			; $79b4
	rst_jumpTable			; $79b6
	.dw _veranPossessionBoss_humanForm_state8
	.dw _veranPossessionBoss_humanForm_state9
	.dw _veranPossessionBoss_humanForm_stateA
	.dw _veranPossessionBoss_humanForm_stateB
	.dw _veranPossessionBoss_humanForm_stateC
	.dw _veranPossessionBoss_humanForm_stateD
	.dw _veranPossessionBoss_humanForm_stateE
	.dw _veranPossessionBoss_humanForm_stateF
	.dw _veranPossessionBoss_humanForm_state10


; Moving upward just after spawning
_veranPossessionBoss_humanForm_state8:
	call objectApplySpeed		; $79c9
	call _ecom_decCounter1		; $79cc
	jr nz,_veranPossessionBoss_animate	; $79cf

	ld (hl),120 ; [counter1]
	ld l,Enemy.state		; $79d3
	inc (hl)		; $79d5

	ld l,Enemy.collisionType		; $79d6
	set 7,(hl)		; $79d8

	ld l,Enemy.enemyCollisionMode		; $79da
	ld (hl),ENEMYCOLLISION_VERAN_GHOST		; $79dc

	; If this is Nayru, and we haven't shown veran's taunting text yet, show it.
	ld a,Object.subid		; $79de
	call objectGetRelatedObject1Var		; $79e0
	ld a,(hl)		; $79e3
	or a			; $79e4
	jr nz,_veranPossessionBoss_animate	; $79e5

	ld l,Enemy.var35		; $79e7
	bit 0,(hl)		; $79e9
	jr nz,_veranPossessionBoss_animate	; $79eb

	inc (hl) ; [var35] |= 1

	ld bc,TX_2f2a		; $79ee
	call showText		; $79f1
	jr _veranPossessionBoss_animate		; $79f4


; Waiting for Link to use switch hook
_veranPossessionBoss_humanForm_state9:
	call _ecom_decCounter1		; $79f6
	jr nz,_veranPossessionBoss_animate	; $79f9

	ld (hl),12 ; [counter1]
	ld l,e			; $79fd
	inc (hl) ; [state]

	ld l,Enemy.angle		; $79ff
	ld (hl),ANGLE_DOWN		; $7a01

	ld l,Enemy.collisionType		; $7a03
	res 7,(hl)		; $7a05

_veranPossessionBoss_animate:
	jp enemyAnimate		; $7a07


; Moving down to re-possess her victim
_veranPossessionBoss_humanForm_stateA:
	call objectApplySpeed		; $7a0a
	call _ecom_decCounter1		; $7a0d
	jr nz,_veranPossessionBoss_animate	; $7a10

	ld l,Enemy.collisionType		; $7a12
	res 7,(hl)		; $7a14

_veranPossessionBoss_humanForm_returnToHost:
	; Send parent to state $10
	ld a,Object.state		; $7a16
	call objectGetRelatedObject1Var		; $7a18
	inc (hl)		; $7a1b

	; Update parent's "hits remaining" counter
	ld l,Enemy.var33		; $7a1c
	ld e,l			; $7a1e
	ld a,(de)		; $7a1f
	ld (hl),a		; $7a20

	jp enemyDelete		; $7a21


; Just finished using switch hook on ghost. Flickering between ghost and human forms.
_veranPossessionBoss_humanForm_stateB:
	call _ecom_decCounter1		; $7a24
	jr nz,@flickerBetweenForms	; $7a27

	ld (hl),120 ; [counter1]

	ld l,Enemy.enemyCollisionMode		; $7a2b
	ld (hl),ENEMYCOLLISION_VERAN_FAIRY		; $7a2d

	ld l,e			; $7a2f
	inc (hl) ; [state]

	ld l,Enemy.collisionType		; $7a31
	set 7,(hl)		; $7a33

	; NOTE: hl is supposed to be [counter1] for below, which it isn't. It only affects
	; the animation though, so no big deal...

@flickerBetweenForms:
	ld a,(hl) ; [counter1]
	rrca			; $7a36
	ld a,$09		; $7a37
	jr c,+			; $7a39
	ld a,$06		; $7a3b
+
	jp enemySetAnimation		; $7a3d


; Veran is vulnerable to attacks.
_veranPossessionBoss_humanForm_stateC:
	call _ecom_decCounter1		; $7a40
	jr nz,_veranPossessionBoss_animate	; $7a43

	; Time to return to host

	ld l,e			; $7a45
	inc (hl) ; [state]

	ld l,Enemy.collisionType		; $7a47
	res 7,(hl)		; $7a49

	ld l,Enemy.speed		; $7a4b
	ld (hl),SPEED_280		; $7a4d

	ld l,Enemy.speedZ		; $7a4f
	ld a,<(-$280)		; $7a51
	ldi (hl),a		; $7a53
	ld (hl),>(-$280)		; $7a54

	call objectSetVisiblec1		; $7a56

	; Set target position to be the nayru/ambi's position.
	; [this.var31] = [parent.yh], [this.var32] = [parent.xh]
	ld a,Object.yh		; $7a59
	call objectGetRelatedObject1Var		; $7a5b
	ld e,Enemy.var31		; $7a5e
	ldi a,(hl)		; $7a60
	ld (de),a ; [this.var31]
	inc e			; $7a62
	inc l			; $7a63
	ld a,(hl)		; $7a64
	ld (de),a ; [this.var32]

	jr _veranPossessionBoss_animate		; $7a66


; Moving back to nayru/ambi
_veranPossessionBoss_humanForm_stateD:
	ld c,$20		; $7a68
	call objectUpdateSpeedZ_paramC		; $7a6a

	ld l,Enemy.var31		; $7a6d
	call _ecom_readPositionVars		; $7a6f
	sub c			; $7a72
	add $02			; $7a73
	cp $05			; $7a75
	jp nc,_ecom_moveTowardPosition		; $7a77

	ldh a,(<hFF8F)	; $7a7a
	sub b			; $7a7c
	add $02			; $7a7d
	cp $05			; $7a7f
	jp nc,_ecom_moveTowardPosition		; $7a81

	; Reached nayru/ambi.

	ld l,Enemy.yh		; $7a84
	ld (hl),b		; $7a86
	ld l,Enemy.xh		; $7a87
	ld (hl),c		; $7a89

	; Wait until reached ground
	ld e,Enemy.zh		; $7a8a
	ld a,(de)		; $7a8c
	or a			; $7a8d
	ret nz			; $7a8e

	jp _veranPossessionBoss_humanForm_returnToHost		; $7a8f


; Health is zero; about to begin cutscene.
_veranPossessionBoss_humanForm_stateE:
	ld e,Enemy.invincibilityCounter		; $7a92
	ld a,(de)		; $7a94
	or a			; $7a95
	ret nz			; $7a96

	call checkLinkCollisionsEnabled		; $7a97
	ret nc			; $7a9a

	ldbc INTERACID_PUFF,$02		; $7a9b
	call objectCreateInteraction		; $7a9e
	ret nz			; $7aa1
	ld a,h			; $7aa2
	ld h,d			; $7aa3
	ld l,Enemy.relatedObj2+1		; $7aa4
	ldd (hl),a		; $7aa6
	ld (hl),Interaction.start		; $7aa7

	ld l,Enemy.state		; $7aa9
	inc (hl)		; $7aab

	ld a,DISABLE_LINK		; $7aac
	ld (wDisabledObjects),a		; $7aae
	ld (wMenuDisabled),a		; $7ab1

	jp objectSetInvisible		; $7ab4


; Waiting for puff to finish its animation
_veranPossessionBoss_humanForm_stateF:
	ld a,Object.animParameter		; $7ab7
	call objectGetRelatedObject2Var		; $7ab9
	bit 7,(hl)		; $7abc
	ret z			; $7abe
	jp _ecom_incState		; $7abf


; Sets nayru/ambi's state to $12, shows text, then deletes self
_veranPossessionBoss_humanForm_state10:
	ld a,Object.state		; $7ac2
	call objectGetRelatedObject1Var		; $7ac4
	ld (hl),$12		; $7ac7

	ld l,Enemy.subid		; $7ac9
	bit 0,(hl)		; $7acb
	ld bc,TX_560b		; $7acd
	jr z,+			; $7ad0
	ld bc,TX_5611		; $7ad2
+
	call showText		; $7ad5
	jp enemyDelete		; $7ad8



; Collapsed Ambi after the fight.
_veranPossessionBoss_subid3:
	ld a,(de)		; $7adb
	cp $08			; $7adc
	jr nz,@state9	; $7ade


; Waiting for palette to fade out
@state8:
	ld a,(wPaletteThread_mode)		; $7ae0
	or a			; $7ae3
	ret nz			; $7ae4

	call _ecom_incState		; $7ae5

	ld l,Enemy.counter2		; $7ae8
	ld (hl),60		; $7aea

	ld a,$05		; $7aec
	call enemySetAnimation		; $7aee

	jp fadeinFromWhite		; $7af1


; Waiting for palette to fade in; then spawn the real Ambi object and delete self.
@state9:
	ld a,(wPaletteThread_mode)		; $7af4
	or a			; $7af7
	ret nz			; $7af8

	call _ecom_decCounter2		; $7af9
	ret nz			; $7afc

	call getFreeInteractionSlot		; $7afd
	ret nz			; $7b00
	ld (hl),INTERACID_AMBI		; $7b01
	inc l			; $7b03
	ld (hl),$07 ; [subid]

	call objectCopyPosition		; $7b06

	ld a,TREE_GFXH_01		; $7b09
	ld (wLoadedTreeGfxIndex),a		; $7b0b

	jp enemyDelete		; $7b0e


;;
; @addr{7b11}
_veranPossessionBoss_wasHit:
	ld h,d			; $7b11
	ld l,Enemy.knockbackCounter		; $7b12
	ld (hl),$00		; $7b14

	ld e,Enemy.subid		; $7b16
	ld a,(de)		; $7b18
	cp $02			; $7b19
	ld l,Enemy.var2a		; $7b1b
	ld a,(hl)		; $7b1d
	jr z,@subid2	; $7b1e

	; Subid 0 or 1 (possessed Nayru or Ambi)

	res 7,a			; $7b20
	cp ITEMCOLLISION_MYSTERY_SEED			; $7b22
	jr z,@mysterySeed	; $7b24

	; Direct attacks from Link cause damage to Link, not Veran
	sub ITEMCOLLISION_L1_SWORD			; $7b26
	ret c			; $7b28
	cp ITEMCOLLISION_SHOVEL - ITEMCOLLISION_L1_SWORD + 1			; $7b29
	ret nc			; $7b2b

	ld l,Enemy.invincibilityCounter		; $7b2c
	ld (hl),-24		; $7b2e
	ld hl,w1Link.invincibilityCounter		; $7b30
	ld (hl),40		; $7b33

	; [w1Link.knockbackAngle] = [this.knockbackAngle] ^ $10
	inc l			; $7b35
	ld e,Enemy.knockbackAngle		; $7b36
	ld a,(de)		; $7b38
	xor $10			; $7b39
	ldi (hl),a		; $7b3b

	ld (hl),21 ; [w1Link.knockbackCounter]

	ld l,<w1Link.damageToApply		; $7b3e
	ld (hl),-8		; $7b40
	ret			; $7b42

@mysterySeed:
	ld l,Enemy.state		; $7b43
	ld (hl),$0e		; $7b45

	ld l,Enemy.counter2		; $7b47
	ld (hl),30		; $7b49

	ld l,Enemy.collisionType		; $7b4b
	res 7,(hl)		; $7b4d

	ld l,Enemy.var30		; $7b4f
	ld a,(hl)		; $7b51
	add $02			; $7b52
	jp enemySetAnimation		; $7b54

@subid2:
	; Collisions on emerged Veran (ghost/human form)
	; Check if a direct attack occurred
	res 7,a			; $7b57
	cp ITEMCOLLISION_L1_SWORD			; $7b59
	ret c			; $7b5b
	cp ITEMCOLLISION_EXPERT_PUNCH + 1			; $7b5c
	ret nc			; $7b5e

	ld l,Enemy.enemyCollisionMode		; $7b5f
	ld a,(hl)		; $7b61
	cp ENEMYCOLLISION_VERAN_GHOST			; $7b62
	jr nz,++		; $7b64

	; No effect on ghost form
	ld l,Enemy.invincibilityCounter		; $7b66
	ld (hl),-8		; $7b68
	ret			; $7b6a
++
	ld l,Enemy.counter1		; $7b6b
	ld (hl),$08		; $7b6d
	ld l,Enemy.var33		; $7b6f
	dec (hl)		; $7b71
	ret nz			; $7b72

	; Veran has been hit enough times to die now.

	ld l,Enemy.health		; $7b73
	ld (hl),$80		; $7b75

	ld l,Enemy.collisionType		; $7b77
	res 7,(hl)		; $7b79

	ld l,Enemy.state		; $7b7b
	ld (hl),$0e		; $7b7d

	ld a,$01		; $7b7f
	ld (wTmpcfc0.genericCutscene.cfd0),a		; $7b81

	ld a,SNDCTRL_STOPMUSIC		; $7b84
	jp playSound		; $7b86


; ==============================================================================
; ENEMYID_VINE_SPROUT
;
; Variables:
;   var31: Tile index underneath the sprout?
;   var32: Short-form position of vine sprout
;   var33: Nonzero if the "tile properties" underneath this sprout have been modified
; ==============================================================================
enemyCode62:
	call objectReplaceWithAnimationIfOnHazard		; $7b89
	ret c			; $7b8c

	ld e,Enemy.state		; $7b8d
	ld a,(de)		; $7b8f
	rst_jumpTable			; $7b90
	.dw _vineSprout_state0
	.dw _vineSprout_state1
	.dw _vineSprout_state_grabbed
	.dw _vineSprout_state_switchHook
	.dw _vineSprout_state4


; Initialization
_vineSprout_state0:
	; Delete self if there is any other vine sprout on-screen already?
	ldhl FIRST_ENEMY_INDEX, Enemy.id		; $7b9b
@nextEnemy:
	ld a,(hl)		; $7b9e
	cp ENEMYID_VINE_SPROUT			; $7b9f
	jr nz,++		; $7ba1
	ld a,d			; $7ba3
	cp h			; $7ba4
	jp nz,enemyDelete		; $7ba5
++
	inc h			; $7ba8
	ld a,h			; $7ba9
	cp LAST_ENEMY_INDEX+1			; $7baa
	jr c,@nextEnemy	; $7bac

	ld h,d			; $7bae
	ld l,e			; $7baf
	inc (hl) ; [state]

	ld l,Enemy.counter1		; $7bb1
	ld (hl),20		; $7bb3

	ld l,Enemy.speed		; $7bb5
	ld (hl),SPEED_c0		; $7bb7

	call _vineSprout_getPosition		; $7bb9
	call objectSetShortPosition		; $7bbc
	jp objectSetVisiblec2		; $7bbf


_vineSprout_state1:
	ld a,(wLinkInAir)		; $7bc2
	rlca			; $7bc5
	jp c,_vineSprout_linkJumpingDownCliff		; $7bc6

	call _vineSprout_checkLinkInSprout		; $7bc9
	ld e,Enemy.var33		; $7bcc
	ld a,(de)		; $7bce
	jp c,_vineSprout_restoreTileAtPosition		; $7bcf

	call objectAddToGrabbableObjectBuffer		; $7bd2
	call _vineSprout_updateTileAtPosition		; $7bd5

	; Check various conditions for whether to push the sprout
	ld hl,w1Link.id		; $7bd8
	ld a,(hl)		; $7bdb
	cpa SPECIALOBJECTID_LINK			; $7bdc
	jr nz,@notPushingSprout	; $7bdd

	ld l,<w1Link.state		; $7bdf
	ld a,(hl)		; $7be1
	cp LINK_STATE_NORMAL			; $7be2
	jr nz,@notPushingSprout	; $7be4

	; Must not be in midair
	ld l,<w1Link.zh		; $7be6
	bit 7,(hl)		; $7be8
	jr nz,@notPushingSprout	; $7bea

	; Can't be swimming
	ld a,(wLinkSwimmingState)		; $7bec
	or a			; $7bef
	jr nz,@notPushingSprout	; $7bf0

	; Must be moving
	ld a,(wLinkAngle)		; $7bf2
	inc a			; $7bf5
	jr z,@notPushingSprout	; $7bf6

	; Must not be pressing A or B
	ld a,(wGameKeysPressed)		; $7bf8
	and BTN_A|BTN_B			; $7bfb
	jr nz,@notPushingSprout	; $7bfd

	; Must not be holding anything
	ld a,(wLinkGrabState)		; $7bff
	or a			; $7c02
	jr nz,@notPushingSprout	; $7c03

	; Must be close enough
	ld c,$12		; $7c05
	call objectCheckLinkWithinDistance		; $7c07
	jr nc,@notPushingSprout	; $7c0a

	; Must be aligned properly
	ld b,$04		; $7c0c
	call objectCheckCenteredWithLink		; $7c0e
	jr nc,@notPushingSprout	; $7c11

	; Link must be moving forwards
	call _ecom_updateCardinalAngleAwayFromTarget		; $7c13
	add $04			; $7c16
	and $18			; $7c18
	ld (de),a ; [angle]
	swap a			; $7c1b
	rlca			; $7c1d
	ld b,a			; $7c1e
	ld a,(w1Link.direction)		; $7c1f
	cp b			; $7c22
	jr nz,@notPushingSprout	; $7c23

	; All the above must hold for 20 frames
	call _ecom_decCounter1		; $7c25
	ret nz			; $7c28

	; Attempt to push the sprout.

	ld a,(de) ; [angle]
	rrca			; $7c2a
	rrca			; $7c2b
	ld hl,@pushOffsets		; $7c2c
	rst_addAToHl			; $7c2f

	; Get destination position
	call objectGetPosition		; $7c30
	ldi a,(hl)		; $7c33
	add b			; $7c34
	ld b,a			; $7c35
	ld a,(hl)		; $7c36
	add c			; $7c37
	ld c,a			; $7c38

	; Must not be solid there
	call getTileCollisionsAtPosition		; $7c39
	jr nz,@notPushingSprout	; $7c3c

	; Push the sprout
	ld h,d			; $7c3e
	ld l,Enemy.state		; $7c3f
	ld (hl),$04		; $7c41
	ld l,Enemy.counter1		; $7c43
	ld (hl),$16		; $7c45
	ld a,SND_MOVEBLOCK		; $7c47
	call playSound		; $7c49
	jp _vineSprout_restoreTileAtPosition		; $7c4c

@notPushingSprout:
	ld e,Enemy.counter1		; $7c4f
	ld a,20		; $7c51
	ld (de),a		; $7c53
	ret			; $7c54

@pushOffsets:
	.db $f0 $00 ; DIR_UP
	.db $00 $10 ; DIR_RIGHT
	.db $10 $00 ; DIR_DOWN
	.db $00 $f0 ; DIR_LEFT


_vineSprout_linkJumpingDownCliff:
	call _vineSprout_restoreTileAtPosition		; $7c5d
	call _vineSprout_checkLinkInSprout		; $7c60
	ret nc			; $7c63

	; Check Link is close to ground
	ld l,SpecialObject.zh		; $7c64
	ld a,(hl)		; $7c66
	add $03			; $7c67
	ret nc			; $7c69

_vineSprout_destroy:
	ld b,INTERACID_ROCKDEBRIS		; $7c6a
	call objectCreateInteractionWithSubid00		; $7c6c

	call _vineSprout_getDefaultPosition		; $7c6f
	ld b,a			; $7c72
	ld a,(de) ; [subid]
	ld hl,wVinePositions		; $7c74
	rst_addAToHl			; $7c77
	ld (hl),b		; $7c78

	jp enemyDelete		; $7c79


_vineSprout_state_grabbed:
	inc e			; $7c7c
	ld a,(de)		; $7c7d
	rst_jumpTable			; $7c7e
	.dw @justGrabbed
	.dw @beingHeld
	.dw @justReleased
	.dw @hitGround

@justGrabbed:
	xor a			; $7c87
	ld (wLinkGrabState2),a		; $7c88
	inc a			; $7c8b
	ld (de),a		; $7c8c
	call _vineSprout_restoreTileAtPosition		; $7c8d
	jp objectSetVisiblec1		; $7c90

@beingHeld:
	ret			; $7c93

@justReleased:
	ld h,d			; $7c94
	ld l,Enemy.enabled		; $7c95
	res 1,(hl) ; Don't persist across rooms anymore
	ld l,Enemy.zh		; $7c99
	bit 7,(hl)		; $7c9b
	ret nz			; $7c9d

@hitGround:
	jr _vineSprout_destroy		; $7c9e


_vineSprout_state_switchHook:
	inc e			; $7ca0
	ld a,(de)		; $7ca1
	rst_jumpTable			; $7ca2
	.dw @justLatched
	.dw @beforeSwitch
	.dw objectCenterOnTile
	.dw @released

@justLatched:
	call _vineSprout_restoreTileAtPosition		; $7cab
	jp _ecom_incState2		; $7cae

@beforeSwitch:
	ret			; $7cb1

@released:
	ld b,$01		; $7cb2
	call _ecom_fallToGroundAndSetState		; $7cb4
	ret nz			; $7cb7
	call objectCenterOnTile		; $7cb8
	jp _vineSprout_updateTileAtPosition		; $7cbb


; Being pushed
_vineSprout_state4:
	ld hl,w1Link		; $7cbe
	call preventObjectHFromPassingObjectD		; $7cc1

	call _ecom_decCounter1		; $7cc4
	jp nz,_ecom_applyVelocityForTopDownEnemyNoHoles		; $7cc7

	; Done pushing
	ld (hl),20 ; [counter1]
	ld l,Enemy.state		; $7ccc
	ld (hl),$01		; $7cce

	call objectCenterOnTile		; $7cd0

	; fall through


;;
; Updates tile properties at current position, updates wVinePositions, if var33 is
; nonzero.
; @addr{7cd3}
_vineSprout_updateTileAtPosition:
	; Return if we've already done this
	ld e,Enemy.var33		; $7cd3
	ld a,(de)		; $7cd5
	or a			; $7cd6
	ret nz			; $7cd7

	call objectGetTileCollisions		; $7cd8
	ld (hl),$0f		; $7cdb
	ld e,Enemy.var31		; $7cdd
	ld h,>wRoomLayout		; $7cdf
	ld a,(hl)		; $7ce1
	ld (de),a ; [var31] = tile index
	inc e			; $7ce3
	ld a,l			; $7ce4
	ld (de),a ; [var32] = tile position
	ld (hl),TILEINDEX_00		; $7ce6

	inc e			; $7ce8
	ld a,$01		; $7ce9
	ld (de),a ; [var33] = 1

	; Ensure that the position is not on the screen boundary.
	; BUG: This could push the sprout into a wall? (Probably not possible with the
	; room layouts of the vanilla game...)
@fixVerticalBoundary:
	ld a,l			; $7cec
	and $f0			; $7ced
	jr nz,++		; $7cef
	set 4,l			; $7cf1
	jr @fixHorizontalBoundary			; $7cf3
++
	cp (SMALL_ROOM_HEIGHT-1)<<4			; $7cf5
	jr nz,@fixHorizontalBoundary		; $7cf7
	res 4,l			; $7cf9

@fixHorizontalBoundary:
	ld a,l			; $7cfb
	and $0f			; $7cfc
	jr nz,++		; $7cfe
	inc l			; $7d00
	jr @setPosition		; $7d01
++
	cp SMALL_ROOM_WIDTH-1			; $7d03
	jr nz,@setPosition	; $7d05
	dec l			; $7d07

@setPosition:
	ld e,Enemy.subid		; $7d08
	ld a,(de)		; $7d0a
	ld bc,wVinePositions		; $7d0b
	call addAToBc		; $7d0e
	ld a,l			; $7d11
	ld (bc),a		; $7d12
	ret			; $7d13

;;
; Undoes the changes done previously to the tile at the sprout's current position (the
; sprout is just moving off, or being destroyed, etc).
; @addr{7d14}
_vineSprout_restoreTileAtPosition:
	; Return if there's nothing to undo
	ld e,Enemy.var33		; $7d14
	ld a,(de)		; $7d16
	or a			; $7d17
	ret z			; $7d18

	xor a			; $7d19
	ld (de),a ; [var33]

	; Restore tile at this position
	dec e			; $7d1b
	ld a,(de) ; [var32]
	ld l,a			; $7d1d

	dec e			; $7d1e
	ld a,(de) ; [var31]
	ld h,>wRoomLayout		; $7d20
	ld (hl),a		; $7d22
	ld h,>wRoomCollisions		; $7d23
	ld (hl),$00		; $7d25
	ret			; $7d27


;;
; @param[out]	cflag	c if Link is in the sprout
; @addr{7d28}
_vineSprout_checkLinkInSprout:
	ld a,(wLinkObjectIndex)		; $7d28
	ld h,a			; $7d2b
	ld l,SpecialObject.yh		; $7d2c
	ld e,Enemy.yh		; $7d2e
	ld a,(de)		; $7d30
	sub (hl)		; $7d31
	add $06			; $7d32
	cp $0d			; $7d34
	ret nc			; $7d36

	ld l,SpecialObject.xh		; $7d37
	ld e,Enemy.xh		; $7d39
	ld a,(de)		; $7d3b
	sub (hl)		; $7d3c
	add $06			; $7d3d
	cp $0d			; $7d3f
	ret			; $7d41

;;
; @param[out]	a	Sprout's default position
; @param[out]	de	Enemy.subid
; @addr{7d42}
_vineSprout_getDefaultPosition:
	ld e,Enemy.subid		; $7d42
	ld a,(de)		; $7d44
	ld bc,@defaultVinePositions		; $7d45
	call addAToBc		; $7d48
	ld a,(bc)		; $7d4b
	ret			; $7d4c

@defaultVinePositions:
	.include "build/data/defaultVinePositions.s"


;;
; @param[out]	c	Sprout's position
; @addr{7d53}
_vineSprout_getPosition:
	ld e,Enemy.subid		; $7d53
	ld a,(de)		; $7d55
	ld hl,wVinePositions		; $7d56
	rst_addAToHl			; $7d59
	ld c,(hl)		; $7d5a

	; Check if the sprout is under a "respawnable tile" (ie. a bush). If so, return to
	; default position.
	ld b,>wRoomLayout		; $7d5b
	ld a,(bc)		; $7d5d
	ld e,a			; $7d5e
	ld hl,@respawnableTiles		; $7d5f
-
	ldi a,(hl)		; $7d62
	or a			; $7d63
	ret z			; $7d64
	cp e			; $7d65
	jr nz,-			; $7d66

	call _vineSprout_getDefaultPosition		; $7d68
	ld c,a			; $7d6b
	ret			; $7d6c

@respawnableTiles:
	.db $c0 $c1 $c2 $c3 $c4 $c5 $c6 $c7
	.db $c8 $c9 $ca $00


; ==============================================================================
; ENEMYID_TARGET_CART_CRYSTAL
;
; Variables:
;   var03: 0 for no movement, 1 for up/down, 2 for left/right
; ==============================================================================
enemyCode63:
	jr z,@normalStatus	 		; $7d79

	; ENEMYSTATUS_JUST_HIT
	ld e,Enemy.state		; $7d7b
	ld a,$02		; $7d7d
	ld (de),a		; $7d7f

@normalStatus:
	ld e,Enemy.state		; $7d80
	ld a,(de)		; $7d82
	rst_jumpTable			; $7d83
	.dw _targetCartCrystal_state0
	.dw _targetCartCrystal_state1
	.dw _targetCartCrystal_state2


; Initialization
_targetCartCrystal_state0:
	ld a,$01		; $7d8a
	ld (de),a ; [state]
	call _targetCartCrystal_loadPosition		; $7d8d
	call _targetCartCrystal_loadBehaviour		; $7d90
	jr z,+			; $7d93
	call _targetCartCrystal_initSpeed		; $7d95
+
	jp objectSetVisible80		; $7d98


; Standard update state (update movement if it's a moving type)
_targetCartCrystal_state1:
	ld e,Enemy.var03		; $7d9b
	ld a,(de)		; $7d9d
	or a			; $7d9e
	jr z,+			; $7d9f
	call _targetCartCrystal_updateMovement		; $7da1
+
	ld e,Enemy.subid		; $7da4
	ld a,(de)		; $7da6
	cp $05			; $7da7
	jr nc,++		; $7da9
	ld a,(wTmpcfc0.targetCarts.cfdf)		; $7dab
	or a			; $7dae
	jp nz,enemyDelete		; $7daf
++
	jp enemyAnimate		; $7db2


; Target destroyed
_targetCartCrystal_state2:
	ld hl,wTmpcfc0.targetCarts.numTargetsHit		; $7db5
	inc (hl)		; $7db8

	; If in the first room, mark this one as destroyed
	ld e,Enemy.subid		; $7db9
	ld a,(de)		; $7dbb
	cp $05			; $7dbc
	jr nc,++		; $7dbe
	ld hl,wTmpcfc0.targetCarts.crystalsHitInFirstRoom		; $7dc0
	call setFlag		; $7dc3
++
	ld a,SND_GALE_SEED		; $7dc6
	call playSound		; $7dc8

	; Create the "debris" from destroying it
	ld a,$04		; $7dcb
@spawnNext:
	ldh (<hFF8B),a	; $7dcd
	ldbc INTERACID_FALLING_ROCK,$03		; $7dcf
	call objectCreateInteraction		; $7dd2
	jr nz,@delete	; $7dd5
	ld l,Interaction.angle		; $7dd7
	ldh a,(<hFF8B)	; $7dd9
	dec a			; $7ddb
	ld (hl),a		; $7ddc
	jr nz,@spawnNext	; $7ddd

@delete:
	jp enemyDelete		; $7ddf



;;
; Sets var03 to "behaviour" value (0-2)
;
; @param[out]	zflag	z iff [var03] == 0
; @addr{7de2}
_targetCartCrystal_loadBehaviour:
	ld a,(wTmpcfc0.targetCarts.targetConfiguration)		; $7de2
	swap a			; $7de5
	ld hl,@behaviourTable		; $7de7
	rst_addAToHl			; $7dea
	ld e,Enemy.subid		; $7deb
	ld a,(de)		; $7ded
	rst_addAToHl			; $7dee
	ld a,(hl)		; $7def
	inc e			; $7df0
	ld (de),a ; [var03]
	or a			; $7df2
	ret			; $7df3

@behaviourTable:
	.db $00 $00 $00 $00 $00 $00 $00 $00 ; Configuration 0
	.db $00 $00 $00 $00 $00 $00 $00 $00

	.db $00 $00 $00 $00 $02 $00 $00 $00 ; Configuration 1
	.db $00 $01 $00 $02 $00 $00 $00 $00

	.db $01 $00 $02 $00 $00 $00 $00 $02 ; Configuration 2
	.db $01 $01 $02 $02 $00 $00 $00 $00


;;
; Sets Y/X position based on "wTmpcfc0.targetCarts.targetConfiguration" and subid.
; @addr{7e24}
_targetCartCrystal_loadPosition:
	ld a,(wTmpcfc0.targetCarts.targetConfiguration)		; $7e24
	ld hl,@configurationTable		; $7e27
	rst_addAToHl			; $7e2a
	ld a,(hl)		; $7e2b
	rst_addAToHl			; $7e2c

	ld e,Enemy.subid		; $7e2d
	ld a,(de)		; $7e2f
	rst_addDoubleIndex			; $7e30
	ldi a,(hl)		; $7e31
	ld e,Enemy.yh		; $7e32
	ld (de),a		; $7e34
	ld a,(hl)		; $7e35
	ld e,Enemy.xh		; $7e36
	ld (de),a		; $7e38
	ret			; $7e39


; Lists positions of the 12 targets for each of the 3 configurations.
@configurationTable:
	.db @configuration0 - CADDR
	.db @configuration1 - CADDR
	.db @configuration2 - CADDR

@configuration0:
	.db $18 $38 ; 0 == [subid]
	.db $48 $58 ; 1 == [subid]
	.db $28 $98 ; ...
	.db $48 $c8
	.db $18 $b8
	.db $58 $38
	.db $28 $98
	.db $28 $d8
	.db $58 $d8
	.db $98 $d8
	.db $98 $90
	.db $98 $58

@configuration1:
	.db $48 $18
	.db $18 $38
	.db $48 $58
	.db $48 $68
	.db $18 $a8
	.db $18 $48
	.db $58 $68
	.db $18 $88
	.db $18 $d8
	.db $58 $d8
	.db $98 $d8
	.db $98 $78

@configuration2:
	.db $20 $18
	.db $48 $68
	.db $18 $70
	.db $48 $98
	.db $48 $c8
	.db $28 $68
	.db $58 $68
	.db $18 $b8
	.db $40 $d8
	.db $80 $d8
	.db $98 $90
	.db $98 $50

;;
; @addr{7e85}
_targetCartCrystal_initSpeed:
	ld h,d			; $7e85
	ld l,Enemy.speed		; $7e86
	ld (hl),SPEED_80		; $7e88

	ld l,Enemy.counter1		; $7e8a
	ld (hl),$20		; $7e8c

	ld l,Enemy.var03		; $7e8e
	ld a,(hl)		; $7e90
	cp $02			; $7e91
	jr z,++		; $7e93
	ld l,Enemy.angle		; $7e95
	ld (hl),ANGLE_UP		; $7e97
	ret			; $7e99
++
	ld l,Enemy.angle		; $7e9a
	ld (hl),ANGLE_LEFT		; $7e9c
	ret			; $7e9e

;;
; Crystal moves for a bit, switches directions, moves other way.
; @addr{7e9f}
_targetCartCrystal_updateMovement:
	call _ecom_decCounter1		; $7e9f
	jr nz,++		; $7ea2
	ld (hl),$40		; $7ea4
	ld l,Enemy.angle		; $7ea6
	ld a,(hl)		; $7ea8
	xor $10			; $7ea9
	ld (hl),a		; $7eab
++
	jp objectApplySpeed		; $7eac


; ==============================================================================
; Data for INTERACID_MOVING_SIDESCROLL_PLATFORM and INTERACID_MOVING_SIDESCROLL_CONVEYOR
; ==============================================================================

movingSidescrollPlatformScriptTable:
	.dw _movingSidescrollPlatformScript_subid00
	.dw _movingSidescrollPlatformScript_subid01
	.dw _movingSidescrollPlatformScript_subid02
	.dw _movingSidescrollPlatformScript_subid03
	.dw _movingSidescrollPlatformScript_subid04
	.dw _movingSidescrollPlatformScript_subid05
	.dw _movingSidescrollPlatformScript_subid06
	.dw _movingSidescrollPlatformScript_subid07
	.dw _movingSidescrollPlatformScript_subid08
	.dw _movingSidescrollPlatformScript_subid09
	.dw _movingSidescrollPlatformScript_subid0a
	.dw _movingSidescrollPlatformScript_subid0b
	.dw _movingSidescrollPlatformScript_subid0c
	.dw _movingSidescrollPlatformScript_subid0d
	.dw _movingSidescrollPlatformScript_subid0e


_movingSidescrollPlatformScript_subid00:
	.db SPEED_80
	.db $04
@@loop:
	ms_right $78
	ms_left  $58
	ms_loop  @@loop


_movingSidescrollPlatformScript_subid01:
	.db SPEED_80
	.db $04
@@loop:
	ms_up    $28
	ms_down  $68
	ms_loop  @@loop


_movingSidescrollPlatformScript_subid02:
	.db SPEED_80
	.db $00
@@loop:
	ms_up    $28
	ms_right $50
	ms_down  $68
	ms_left  $30
	ms_loop  @@loop

_movingSidescrollPlatformScript_subid03:

	.db SPEED_80
	.db $00
@@loop:
	ms_left  $70
	ms_up    $28
	ms_right $90
	ms_down  $88
	ms_loop  @@loop


_movingSidescrollPlatformScript_subid04:
	.db SPEED_80
	.db $02
@@loop:
	ms_up    $48
	ms_down  $88
	ms_loop  @@loop


_movingSidescrollPlatformScript_subid05:
	.db SPEED_80
	.db $02
@@loop:
	ms_down  $78
	ms_up    $38
	ms_loop  @@loop



movingSidescrollConveyorScriptTable: ; INTERACID_MOVING_SIDESCROLL_CONVEYOR
	.dw @subid00

@subid00:
	.db SPEED_80
	.db $01
@@loop:
	ms_right $50
	ms_down  $88
	ms_left  $38
	ms_up    $38
	ms_loop  @@loop



_movingSidescrollPlatformScript_subid06:
	.db SPEED_80
	.db $04
@@loop:
	ms_up    $38
	ms_down  $68
	ms_loop  @@loop


_movingSidescrollPlatformScript_subid07:
	.db SPEED_80
	.db $04
@@loop:
	ms_left  $88
	ms_right $a8
	ms_loop  @@loop


_movingSidescrollPlatformScript_subid08:
	.db SPEED_80
	.db $04
@@loop:
	ms_up    $58
	ms_down  $98
	ms_loop  @@loop


_movingSidescrollPlatformScript_subid09:
	.db SPEED_80
	.db $04
@@loop:
	ms_up    $48
	ms_down  $98
	ms_loop  @@loop


_movingSidescrollPlatformScript_subid0a:
	.db SPEED_80
	.db $01
@@loop:
	ms_up    $38
	ms_down  $88
	ms_loop  @@loop


_movingSidescrollPlatformScript_subid0b:
	.db SPEED_80
	.db $03
@@loop:
	ms_left  $40
	ms_wait  30
	ms_right $80
	ms_wait  30
	ms_loop  @@loop


_movingSidescrollPlatformScript_subid0c:
	.db SPEED_80
	.db $00
@@loop:
	ms_down  $68
	ms_wait  30
	ms_up    $38
	ms_loop  @@loop


_movingSidescrollPlatformScript_subid0d:
	.db SPEED_80
	.db $00
@@loop:
	ms_down  $98
	ms_wait  30
	ms_up    $68
	ms_loop  @@loop


_movingSidescrollPlatformScript_subid0e:
	.db SPEED_80
	.db $00
@@loop:
	ms_left  $30
	ms_wait  30
	ms_right $a0
	ms_wait  30
	ms_loop  @@loop



; Garbage repeated data
.ifdef BUILD_VANILLA

_fake1:
	.db $00
	.dw $7f71

_fake2:
	.db SPEED_80
	.db $00
@@loop:
	ms_left  $30
	ms_wait  30
	ms_right $a0
	ms_wait  30
	ms_loop  @@loop
.endif

.ends

.BANK $0f SLOT 1
.ORG 0

 m_section_free Enemy_Code_Bank0f NAMESPACE bank0f

	.include "code/enemyCommon.s"
	.include "code/enemyBossCommon.s"


; ==============================================================================
; ENEMYID_GIANT_GHINI
;
; Variables:
;   var30: Number of children alive
;   var32: Nonzero to begin charging at Link (written to by ENEMYID_GIANT_GHINI_CHILD)
;   var33: Counter for Z-axis movement (reverses direction every 16 frames)
;   var34: The current "vertical half" of the screen it's moving toward
;   var35: Position the ghini is currently charging toward
; ==============================================================================
enemyCode70:
	jr z,@normalStatus	; $4594
	sub ENEMYSTATUS_NO_HEALTH			; $4596
	ret c			; $4598
	jr nz,@normalStatus	; $4599
	jp _enemyBoss_dead		; $459b

@normalStatus:
	call _giantGhini_updateZPos		; $459e
	ld e,Enemy.state		; $45a1
	ld a,(de)		; $45a3
	rst_jumpTable			; $45a4
	.dw _giantGhini_state_uninitialized
	.dw _giantGhini_state_stub
	.dw _giantGhini_state_stub
	.dw _giantGhini_state_stub
	.dw _giantGhini_state_stub
	.dw _giantGhini_state_stub
	.dw _giantGhini_state_stub
	.dw _giantGhini_state_stub
	.dw _giantGhini_state8
	.dw _giantGhini_state9
	.dw _giantGhini_stateA


_giantGhini_state_uninitialized:
	ld a,ENEMYID_GIANT_GHINI		; $45bb
	ld b,$00		; $45bd
	call _enemyBoss_initializeRoom		; $45bf
	call _ecom_setSpeedAndState8		; $45c2

	ld bc,$0040		; $45c5
	call objectSetSpeedZ		; $45c8

	ld l,Enemy.subid		; $45cb
	set 7,(hl)		; $45cd

	ld l,Enemy.counter1		; $45cf
	ld (hl),120		; $45d1

	ld l,Enemy.zh		; $45d3
	ld (hl),$f8		; $45d5

	ld l,Enemy.var33		; $45d7
	ld (hl),$10		; $45d9
	jp _giantGhini_spawnChildren		; $45db


_giantGhini_state_stub:
	ret			; $45de


; The ghini is spawning in before the fight starts
_giantGhini_state8:
	inc e			; $45df
	ld a,(de) ; [state2]
	rst_jumpTable			; $45e1
	.dw @substate0
	.dw @substate1
	.dw @substate2

@substate0:
	ld a,DISABLE_LINK		; $45e8
	ld (wDisabledObjects),a		; $45ea
	ld (wMenuDisabled),a		; $45ed

	; Wait for door to close
	ld a,($cc93)		; $45f0
	or a			; $45f3
	ret nz			; $45f4

	ld a,120		; $45f5
	ld e,Enemy.counter1		; $45f7
	ld (de),a		; $45f9

	inc e			; $45fa
	ld a,30		; $45fb
	ld (de),a ; [counter2]

	jp _ecom_incState2		; $45fe

@substate1:
	call _ecom_decCounter1		; $4601
	ret nz			; $4604

	ld (hl),60		; $4605

	ld l,Enemy.subid		; $4607
	res 7,(hl)		; $4609

	ld b,$01		; $460b
	ld c,$0c		; $460d
	call _enemyBoss_spawnShadow		; $460f
	jp _ecom_incState2		; $4612

@substate2:
	; Flicker visibility
	ld e,Enemy.visible		; $4615
	ld a,(de)		; $4617
	xor $80			; $4618
	ld (de),a		; $461a

	call _ecom_decCounter1		; $461b
	ret nz			; $461e

	; Finally begin the fight
	call _enemyBoss_beginMiniboss		; $461f
	call objectSetVisible80		; $4622

_giantGhini_gotoState9:
	xor a			; $4625
	call enemySetAnimation		; $4626

	call _giantGhini_getTargetAngle		; $4629
	ld h,d			; $462c
	ld e,Enemy.angle		; $462d
	ld (de),a		; $462f

	ld l,Enemy.state		; $4630
	ld (hl),$09		; $4632

	ld l,Enemy.speed		; $4634
	ld (hl),SPEED_c0		; $4636

	ld l,Enemy.counter1		; $4638
	ld (hl),$02		; $463a

	ld l,Enemy.var32		; $463c
	ld (hl),$00		; $463e

_giantGhini_setChildRespawnTimer:
	call getRandomNumber		; $4640
	and $03			; $4643
	ld c,60		; $4645
	call multiplyAByC		; $4647
	ld e,Enemy.counter2		; $464a
	ld a,l			; $464c
	ld (de),a		; $464d
	ret			; $464e


; "Normal" state during battle
_giantGhini_state9:
	ld e,Enemy.var32		; $464f
	ld a,(de)		; $4651
	or a			; $4652
	jr nz,@beginCharge	; $4653

	call enemyAnimate		; $4655
	call objectApplySpeed		; $4658

	; Nudge angle toward target every other frame
	call _ecom_decCounter1		; $465b
	jr nz,++		; $465e
	ld (hl),$02		; $4660
	call _giantGhini_getTargetAngle		; $4662
	call objectNudgeAngleTowards		; $4665
++
	call _ecom_decCounter2		; $4668
	ret nz			; $466b

	call _giantGhini_setChildRespawnTimer		; $466c
	ld e,Enemy.var30		; $466f
	ld a,(de)		; $4671
	or a			; $4672
	ret nz			; $4673
	call getRandomNumber		; $4674
	and $03			; $4677
	jp nz,_giantGhini_spawnChildren		; $4679

@beginCharge:
	ld a,$01		; $467c
	call enemySetAnimation		; $467e
	call _ecom_incState		; $4681

	ld l,Enemy.counter2		; $4684
	ld (hl),150		; $4686
	ld l,Enemy.speed		; $4688
	ld (hl),SPEED_20		; $468a

_giantGhini_updateChargeTargetPosition:
	; Get Link's position, save that as the position we're charging toward
	ld hl,w1Link.yh		; $468c
	ldi a,(hl)		; $468f
	ld b,a			; $4690
	inc l			; $4691
	ld a,(hl)		; $4692
	ld c,a			; $4693
	call getTileAtPosition		; $4694
	ld a,l			; $4697
	ld e,Enemy.var35		; $4698
	ld (de),a		; $469a

	call objectGetAngleTowardLink		; $469b
	ld e,Enemy.angle		; $469e
	ld (de),a		; $46a0
	ret			; $46a1


; Charging toward Link
_giantGhini_stateA:
	call enemyAnimate		; $46a2

	; Increase speed every 4 frames
	call _ecom_decCounter2		; $46a5
	ld a,(hl)		; $46a8
	and $03			; $46a9
	jr nz,++		; $46ab
	ld l,Enemy.speed		; $46ad
	ld a,(hl)		; $46af
	cp SPEED_300			; $46b0
	jr z,++			; $46b2
	add SPEED_20			; $46b4
	ld (hl),a		; $46b6
++
	call objectApplySpeed		; $46b7

	ld e,Enemy.var32		; $46ba
	ld a,(de)		; $46bc
	or a			; $46bd
	call nz,_giantGhini_updateChargeTargetPosition		; $46be

	ld e,Enemy.var35		; $46c1
	ld a,(de)		; $46c3
	call convertShortToLongPosition		; $46c4
	ld e,Enemy.yh		; $46c7
	call objectGetRelativeAngle		; $46c9
	ld e,Enemy.angle		; $46cc
	ld (de),a		; $46ce

	call objectGetTileAtPosition		; $46cf
	ld e,Enemy.var35		; $46d2
	ld a,(de)		; $46d4
	cp l			; $46d5
	jp z,_giantGhini_gotoState9		; $46d6
	ret			; $46d9


;;
; @addr{46da}
_giantGhini_updateZPos:
	ld c,$00		; $46da
	call objectUpdateSpeedZ_paramC		; $46dc

	ld l,Enemy.var33		; $46df
	ld a,(hl)		; $46e1
	dec a			; $46e2
	ld (hl),a		; $46e3
	ret nz			; $46e4

	ld a,$10		; $46e5
	ld (hl),a ; [var33]

	; Invert speedZ
	ld l,Enemy.speedZ		; $46e8
	ld a,(hl)		; $46ea
	cpl			; $46eb
	inc a			; $46ec
	ldi (hl),a		; $46ed
	ld a,(hl)		; $46ee
	cpl			; $46ef
	ld (hl),a		; $46f0
	ret			; $46f1


;;
; @addr{46f2}
_giantGhini_spawnChildren:
	ld c,$03		; $46f2
@nextChild:
	ld b,ENEMYID_GIANT_GHINI_CHILD		; $46f4
	call _ecom_spawnEnemyWithSubid01		; $46f6
	ret nz			; $46f9

	ld e,Enemy.var30		; $46fa
	ld a,(de)		; $46fc
	inc a			; $46fd
	ld (de),a		; $46fe

	; [child.subid] = [this.subid] | index
	ld e,Enemy.subid		; $46ff
	ld a,(de)		; $4701
	or c			; $4702
	ld (hl),a		; $4703

	ld l,Enemy.relatedObj1		; $4704
	ld a,Enemy.start		; $4706
	ldi (hl),a		; $4708
	ld (hl),d		; $4709

	call objectCopyPosition		; $470a

	dec c			; $470d
	jr nz,@nextChild	; $470e
	ret			; $4710


;;
; Decides on a position to move towards, for state 9 ("normal" state). It will target
; the horizontal center of the screen, with the Y-position one quarter away from the
; screen boundary (depends which side Link is on). The camera affects the target position.
;
; When Link moves beyond the half-screen boundary, the ghini recalculates its angle to
; face directly away from Link before it slowly moves toward him again.
;
; @param[out]	a	angle
; @addr{4711}
_giantGhini_getTargetAngle:
	ldh a,(<hCameraY)	; $4711
	ld c,a			; $4713
	ld a,(w1Link.yh)		; $4714
	sub c			; $4717
	ld b,(SCREEN_HEIGHT/4)<<4 + 8		; $4718
	cp (SCREEN_HEIGHT/2)<<4 + 8			; $471a
	jr nc,+			; $471c
	ld b,(SCREEN_HEIGHT*3/4)<<4 + 8		; $471e
+
	ld e,Enemy.var34		; $4720
	ld a,(de)		; $4722
	cp b			; $4723
	jr z,++			; $4724

	; Link changed sides on the screen boundary

	ld a,b			; $4726
	ld (de),a ; [var34]

	call objectGetAngleTowardLink		; $4728
	xor $10			; $472b
	ld e,Enemy.angle		; $472d
	ld (de),a		; $472f

	ld e,Enemy.counter1		; $4730
	ld a,$0a		; $4732
	ld (de),a		; $4734
	jr _giantGhini_getTargetAngle		; $4735
++
	ld a,c			; $4737
	add b			; $4738
	ld b,a			; $4739
	ldh a,(<hCameraX)	; $473a
	add (SCREEN_WIDTH/2)<<4			; $473c
	ld c,a			; $473e
	jp objectGetRelativeAngle		; $473f


; ==============================================================================
; ENEMYID_SWOOP
;
; Variables:
;   var30: Number of frames before swoop begins to stomp
;   var31: Target stomp position (short-form)
;   var32/var33: Target stomp position (long-form)
; ==============================================================================
enemyCode71:
	jr z,@normalStatus	; $4742
	sub ENEMYSTATUS_NO_HEALTH			; $4744
	ret c			; $4746
	jp nz,@normalStatus		; $4747
	jp _enemyBoss_dead		; $474a

@normalStatus:
	ld e,Enemy.state		; $474d
	ld a,(de)		; $474f
	rst_jumpTable			; $4750
	.dw _swoop_state_uninitialized
	.dw _swoop_state_stub
	.dw _swoop_state_stub
	.dw _swoop_state_stub
	.dw _swoop_state_stub
	.dw _swoop_state_stub
	.dw _swoop_state_stub
	.dw _swoop_state_stub
	.dw _swoop_state8
	.dw _swoop_state9
	.dw _swoop_stateA
	.dw _swoop_stateB


_swoop_state_uninitialized:
	ld a,ENEMYID_SWOOP		; $4769
	ld b,$00		; $476b
	call _enemyBoss_initializeRoom		; $476d
	call _ecom_setSpeedAndState8		; $4770
	ld b,$01		; $4773
	ld c,$08		; $4775
	jp _enemyBoss_spawnShadow		; $4777


_swoop_state_stub:
	ret			; $477a


; Spawning in before the fight starts
_swoop_state8:
	ld e,Enemy.state2		; $477b
	ld a,(de)		; $477d
	rst_jumpTable			; $477e
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate0:
	ld a,DISABLE_LINK		; $4787
	ld (wDisabledObjects),a		; $4789
	ld (wMenuDisabled),a		; $478c

	; Wait for door to close
	ld a,($cc93)		; $478f
	or a			; $4792
	ret nz			; $4793

	call _ecom_incState2		; $4794
	ld c,$08		; $4797
	call _ecom_setZAboveScreen		; $4799

	ld e,Enemy.counter1		; $479c
	ld a,60		; $479e
	ld (de),a		; $47a0

	inc e			; $47a1
	ld a,$02		; $47a2
	ld (de),a ; [counter2]

	call objectSetVisible82		; $47a5
	ld a,$02		; $47a8
	jp enemySetAnimation		; $47aa

; Falling to ground
@substate1:
	ld c,$10		; $47ad
	call objectUpdateSpeedZ_paramC		; $47af
	ret nz			; $47b2

	ld e,Enemy.counter2		; $47b3
	ld a,(de)		; $47b5
	or a			; $47b6
	jr z,@doneBouncing	; $47b7

	dec a			; $47b9
	ld (de),a		; $47ba
	jr nz,++		; $47bb

	ld a,$00		; $47bd
	call enemySetAnimation		; $47bf
	jr @doneBouncing		; $47c2
++
	ld bc,-$180		; $47c4
	call objectSetSpeedZ		; $47c7
	ld a,$0a		; $47ca
	call setScreenShakeCounter		; $47cc
	ld a,SND_DOORCLOSE		; $47cf
	jp playSound		; $47d1

@doneBouncing:
	call _ecom_decCounter1		; $47d4
	ret nz			; $47d7
	ld bc,TX_2f00		; $47d8
	call showText		; $47db
	jp _ecom_incState2		; $47de

@substate2:
	call retIfTextIsActive		; $47e1
	call _enemyBoss_beginMiniboss		; $47e4
	call _ecom_incState2		; $47e7
	jp _swoop_beginFlyingUp		; $47ea

@substate3:
	call _swoop_state9		; $47ed

	ld e,Enemy.state		; $47f0
	ld a,(de)		; $47f2
	cp $0a			; $47f3
	ret nz			; $47f5

	xor a			; $47f6
	ld (wDisabledObjects),a		; $47f7
	ld (wMenuDisabled),a		; $47fa
	ret			; $47fd


; Flying upward
_swoop_state9:
	call _swoop_animate		; $47fe

	; Set Z-speed if just flapped wings
	ld a,(de)		; $4801
	or a			; $4802
	ld bc,-$100		; $4803
	call nz,objectSetSpeedZ		; $4806

	ld c,$08		; $4809
	call objectUpdateSpeedZ_paramC		; $480b
	call _ecom_decCounter2		; $480e
	ret nz			; $4811

	call _ecom_decCounter1		; $4812
	jp nz,_swoop_flyFurtherUp		; $4815

	ld (hl),60 ; [counter1]

	ld a,$0a		; $481a
	ld l,Enemy.state		; $481c
	ldi (hl),a		; $481e
	ld (hl),$00 ; [state2]

	call _swoop_getAngerLevel		; $4821
	ld hl,_swoop_framesBeforeAttacking		; $4824
	rst_addAToHl			; $4827
	ld a,(hl)		; $4828
	ld e,Enemy.var30		; $4829
	ld (de),a		; $482b

	call objectGetAngleTowardLink		; $482c
	ld e,Enemy.angle		; $482f
	ld (de),a		; $4831

	ld a,$00		; $4832
	jp enemySetAnimation		; $4834


; Flying around, getting closer to Link before stomping
_swoop_stateA:
	call _swoop_animate		; $4837
	call _swoop_getAngerLevel		; $483a

	ld hl,_swoop_speedVals		; $483d
	rst_addAToHl			; $4840
	ld a,(hl)		; $4841
	ld e,Enemy.speed		; $4842
	ld (de),a		; $4844

	ld e,Enemy.var30		; $4845
	ld a,(de)		; $4847
	or a			; $4848
	jr z,++			; $4849
	dec a			; $484b
	ld (de),a		; $484c
	jr nz,@updatePosition	; $484d
++
	ld c,$30		; $484f
	call objectCheckLinkWithinDistance		; $4851
	jr nc,@updatePosition	; $4854

	call _ecom_incState		; $4856
	inc l			; $4859
	ld (hl),$00 ; [state2]
	ld l,Enemy.counter1		; $485c
	ld (hl),30		; $485e
	ret			; $4860

@updatePosition:
	call _ecom_decCounter1		; $4861
	jr nz,++		; $4864
	call objectGetAngleTowardLink		; $4866
	ld e,Enemy.angle		; $4869
	ld (de),a		; $486b
	ld e,Enemy.counter1		; $486c
	ld a,60		; $486e
	ld (de),a		; $4870
++
	jp _ecom_applyVelocityForSideviewEnemy		; $4871


; Stomping
_swoop_stateB:
	ld e,Enemy.state2		; $4874
	ld a,(de)		; $4876
	rst_jumpTable			; $4877
	.dw @substate0
	.dw @substate1
	.dw _swoop_stomp_substate2
	.dw _swoop_stomp_substate3

; Flapping wings quickly, telegraphing stomp is about to begin
@substate0:
	call _swoop_animate		; $4880
	call _swoop_animate		; $4883
	call _ecom_decCounter1		; $4886
	jr z,@beginStomp	; $4889

	ld a,(hl) ; [counter1]
	cp $0a			; $488c
	ret nz			; $488e

	; Decide on target position to stomp at, store in var31
	ld hl,w1Link.yh		; $488f
	ldi a,(hl)		; $4892
	ld b,a			; $4893
	inc l			; $4894
	ld c,(hl) ; [w1Link.xh]
	call getTileAtPosition		; $4896
	ld a,l			; $4899
	ld e,Enemy.var31		; $489a
	ld (de),a		; $489c

	; Convert to long-form, store in var32/var33
	call convertShortToLongPosition		; $489d
	ld e,Enemy.var32		; $48a0
	ld a,b			; $48a2
	and $f0			; $48a3
	ld (de),a		; $48a5
	inc e			; $48a6
	ld a,c			; $48a7
	ld (de),a		; $48a8

	; Get angle toward stomp position
	ld e,Enemy.yh		; $48a9
	call objectGetRelativeAngle		; $48ab
	ld e,Enemy.angle		; $48ae
	ld (de),a		; $48b0
	ret			; $48b1

@beginStomp:
	call _ecom_incState2		; $48b2
	ld l,Enemy.speed		; $48b5
	ld (hl),SPEED_200		; $48b7

	ld l,Enemy.collisionType		; $48b9
	set 7,(hl)		; $48bb

	ld bc,$0000		; $48bd
	call objectSetSpeedZ		; $48c0
	ld a,$02		; $48c3
	jp enemySetAnimation		; $48c5

; Moving toward stomp position while falling to ground
@substate1:
	; Get target stomp position
	ld h,d			; $48c8
	ld l,Enemy.var32		; $48c9
	ldi a,(hl)		; $48cb
	ld c,(hl)		; $48cc
	ld b,a			; $48cd

	; Compare with current position
	ld e,Enemy.yh		; $48ce
	ld l,e			; $48d0
	ldi a,(hl)		; $48d1
	and $fe			; $48d2
	cp b			; $48d4
	jr nz,++		; $48d5
	inc l			; $48d7
	ld a,(hl)		; $48d8
	and $fe			; $48d9
	cp c			; $48db
	jr z,+++		; $48dc
++
	; Must still move toward target position
	call objectGetRelativeAngle		; $48de
	ld e,Enemy.angle		; $48e1
	ld (de),a		; $48e3
	call _ecom_applyVelocityForSideviewEnemy		; $48e4
+++
	ld c,$10		; $48e7
	call objectUpdateSpeedZ_paramC		; $48e9
	ret nz			; $48ec

	; Hit the ground.
	call _swoop_hitGround		; $48ed
	call _ecom_incState2		; $48f0
	ld e,Enemy.health		; $48f3
	ld a,(de)		; $48f5
	cp $0a			; $48f6
	jr nc,_swoop_setVisible	; $48f8

	; Health is low; will bounce either 2 or 3 times.
	inc (hl) ; [state2] = 3

	; [counter1] = number of bounces
	call getRandomNumber		; $48fb
	and $01			; $48fe
	inc a			; $4900
	ld l,Enemy.counter1		; $4901
	ld (hl),a		; $4903

	ld l,Enemy.speed		; $4904
	ld (hl),SPEED_100		; $4906

	call objectGetAngleTowardLink		; $4908
	ld e,Enemy.angle		; $490b
	ld (de),a		; $490d

_swoop_setSpeedZForBounce:
	ld bc,-$100		; $490e
	jp objectSetSpeedZ		; $4911

_swoop_setVisible:
	jp objectSetVisible82		; $4914


; Completed stomp, about to fly back up.
_swoop_stomp_substate2:
	call _swoop_animate		; $4917

	; Wait until animation signals to fly up again, or Link attacks
	ld e,Enemy.invincibilityCounter		; $491a
	ld a,(de)		; $491c
	and $7f			; $491d
	jr nz,@flyBackUp		; $491f

	ld e,Enemy.animParameter		; $4921
	ld a,(de)		; $4923
	or a			; $4924
	ret z			; $4925

@flyBackUp:
	ld bc,$0000		; $4926
	call objectSetSpeedZ		; $4929

	ld l,Enemy.state		; $492c
	ld a,$09		; $492e
	ldi (hl),a		; $4930
	ld (hl),$00 ; [state2]

	ld l,Enemy.collisionType		; $4933
	res 7,(hl)		; $4935

;;
; @addr{4937}
_swoop_beginFlyingUp:
	ld l,Enemy.counter1		; $4937
	ld (hl),$03 ; 3 flaps before he goes to next state

;;
; @addr{493b}
_swoop_flyFurtherUp:
	ld l,Enemy.counter2		; $493b
	ld (hl),$30 ; $30 frames per wing flap
	call objectSetVisible80		; $493f
	ld a,$03		; $4942
	jp enemySetAnimation		; $4944


; Bouncing
_swoop_stomp_substate3:
	call _ecom_applyVelocityForSideviewEnemy		; $4947
	ld c,$10		; $494a
	call objectUpdateSpeedZ_paramC		; $494c
	ret nz			; $494f

	call _swoop_hitGround		; $4950
	call _ecom_decCounter1		; $4953
	jr nz,_swoop_setSpeedZForBounce	; $4956

	ld l,Enemy.state2		; $4958
	dec (hl)		; $495a
	jp objectSetVisible82		; $495b


;;
; @param[out]	a	Value from 0-2
; @addr{495e}
_swoop_getAngerLevel:
	ld b,$00		; $495e
	ld e,Enemy.health		; $4960
	ld a,(de)		; $4962
	cp $0a			; $4963
	jr nc,++		; $4965
	inc b			; $4967
	cp $06			; $4968
	jr nc,++		; $496a
	inc b			; $496c
++
	ld a,b			; $496d
	ret			; $496e

;;
; @addr{496f}
_swoop_hitGround:
	ld a,$30		; $496f
	call setScreenShakeCounter		; $4971
	ld a,SND_DOORCLOSE		; $4974
	call playSound		; $4976

	; Replace tile at this position if it's of the appropriate type, and not solid.
	ld bc,$0500		; $4979
	call objectGetRelativeTile		; $497c
	ld c,l			; $497f
	ld h,>wRoomCollisions		; $4980
	ld a,(hl)		; $4982
	cp $0f			; $4983
	ret z			; $4985

	ld h,>wRoomLayout		; $4986
	ld a,(hl)		; $4988
	cp $a2			; $4989
	ret z			; $498b
	cp $48			; $498c
	ret z			; $498e

	ld a,$48		; $498f
	call setTile		; $4991

	ld b,INTERACID_ROCKDEBRIS		; $4994
	jp objectCreateInteractionWithSubid00		; $4996


;;
; @param[out]	de	animParameter (if nonzero, just flapped wings)
; @addr{4999}
_swoop_animate:
	call enemyAnimate		; $4999
	ld e,Enemy.animParameter		; $499c
	ld a,(de)		; $499e
	or a			; $499f
	ret z			; $49a0
	ld a,SND_JUMP		; $49a1
	jp playSound		; $49a3

_swoop_speedVals:
	.db SPEED_80, SPEED_100, SPEED_180

_swoop_framesBeforeAttacking:
	.db 255, 150, 60


; ==============================================================================
; ENEMYID_SUBTERROR
;
; Variables:
;   var30: If nonzero, dirt is created at subterror's position every 8 frames.
;   var31: Counter until a new dirt object (PARTID_SUBTERROR_DIRT) is created.
; ==============================================================================
enemyCode72:
	jr z,@normalStatus	; $49ac
	sub ENEMYSTATUS_NO_HEALTH			; $49ae
	ret c			; $49b0
	jr nz,@normalStatus	; $49b1
	jp _enemyBoss_dead		; $49b3

@normalStatus:
	ld e,Enemy.var30		; $49b6
	ld a,(de)		; $49b8
	or a			; $49b9
	call nz,_subterror_spawnDirtEvery8Frames		; $49ba
	ld e,Enemy.state		; $49bd
	ld a,(de)		; $49bf
	rst_jumpTable			; $49c0
	.dw _subterror_state_uninitialized
	.dw _subterror_state_stub
	.dw _subterror_state_stub
	.dw _subterror_state_stub
	.dw _subterror_state_stub
	.dw _subterror_state_stub
	.dw _subterror_state_stub
	.dw _subterror_state_stub
	.dw _subterror_state8
	.dw _subterror_state9
	.dw _subterror_stateA
	.dw _subterror_stateB
	.dw _subterror_stateC


_subterror_state_uninitialized:
	ld a,ENEMYID_SUBTERROR		; $49db
	ld b,PALH_be		; $49dd
	call _enemyBoss_initializeRoom		; $49df
	call _ecom_setSpeedAndState8		; $49e2

	ld a,$07		; $49e5
	ld l,Enemy.var31		; $49e7
	ldd (hl),a ; [var31] = 7
	ld (hl),a  ; [var30] = 7

	ld l,Enemy.speed		; $49eb
	ld (hl),SPEED_180		; $49ed
	ld l,Enemy.angle		; $49ef
	ld (hl),ANGLE_DOWN		; $49f1

	ld l,Enemy.counter2		; $49f3
	ld (hl),30		; $49f5
	ret			; $49f7


_subterror_state_stub:
	ret			; $49f8


; Cutscene before fight
_subterror_state8:
	ld e,Enemy.state2		; $49f9
	ld a,(de)		; $49fb
	rst_jumpTable			; $49fc
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate0:
	ld a,DISABLE_LINK		; $4a05
	ld (wDisabledObjects),a		; $4a07
	ld (wMenuDisabled),a		; $4a0a

	; Wait for door to close
	ld a,($cc93)		; $4a0d
	or a			; $4a10
	ret nz			; $4a11

	call _ecom_decCounter2		; $4a12
	ret nz			; $4a15

	; Move further down
	call objectApplySpeed		; $4a16
	ld e,Enemy.yh		; $4a19
	ld a,(de)		; $4a1b
	cp $58			; $4a1c
	ret c			; $4a1e

	; Reached middle of screen, about to pop out

	ld a,SND_DIG		; $4a1f
	call playSound		; $4a21

	ld a,$06		; $4a24
	call enemySetAnimation		; $4a26
	call objectSetVisiblec2		; $4a29

	call _ecom_incState2		; $4a2c

	; Disable dirt animation
	ld l,Enemy.var30		; $4a2f
	ld (hl),$00		; $4a31

	call objectGetTileAtPosition		; $4a33
	ld c,l			; $4a36
	ld a,TILEINDEX_DUNGEON_DUG_DIRT		; $4a37
	jp setTile		; $4a39

@substate1:
	call _subterror_retFromCallerIfAnimationUnfinished		; $4a3c

	ld b,INTERACID_ROCKDEBRIS		; $4a3f
	call objectCreateInteractionWithSubid00		; $4a41

	call _ecom_incState2		; $4a44

	ld l,Enemy.counter1		; $4a47
	ld (hl),60		; $4a49

	ld bc,-$200		; $4a4b
	call objectSetSpeedZ		; $4a4e

	ld a,$05		; $4a51
	jp enemySetAnimation		; $4a53

@substate2:
	ld c,$10		; $4a56
	call objectUpdateSpeedZ_paramC		; $4a58
	ret nz			; $4a5b

	ld a,$02		; $4a5c
	call enemySetAnimation		; $4a5e
	call _ecom_decCounter1		; $4a61
	ret nz			; $4a64

	ld bc,TX_2f03		; $4a65
	call showText		; $4a68
	jp _ecom_incState2		; $4a6b

@substate3:
	call retIfTextIsActive		; $4a6e

	call _enemyBoss_beginMiniboss		; $4a71
	xor a			; $4a74
	ld (wDisabledObjects),a		; $4a75
	ld (wMenuDisabled),a		; $4a78


_subterror_digIntoGround:
	ld e,Enemy.state		; $4a7b
	ld a,$09		; $4a7d
	ld (de),a		; $4a7f

	ld a,$04		; $4a80
	jp enemySetAnimation		; $4a82


; Digging into ground
_subterror_state9:
	call _subterror_retFromCallerIfAnimationUnfinished		; $4a85

	; Done digging, about to start moving around
_subterror_beginUndergroundMovement:
	ld h,d			; $4a88
	ld l,Enemy.state		; $4a89
	ld (hl),$0a		; $4a8b
	inc l			; $4a8d
	xor a			; $4a8e
	ld (hl),a ; [state2]

	dec a			; $4a90
	ld l,Enemy.angle		; $4a91
	ld (hl),a ; [angle] = $ff

	ld l,Enemy.visible		; $4a94
	res 7,(hl)		; $4a96

	ld l,Enemy.enemyCollisionMode		; $4a98
	ld (hl),ENEMYCOLLISION_SUBTERROR_UNDERGROUND		; $4a9a

	ld l,Enemy.counter1		; $4a9c
	ld (hl),60		; $4a9e

	call _subterror_getAngerLevel		; $4aa0
	ld hl,_subterror_timeUntilDrillAttack		; $4aa3
	rst_addAToHl			; $4aa6
	ld a,(hl)		; $4aa7
	ld e,Enemy.counter2		; $4aa8
	ld (de),a		; $4aaa

	ld a,SND_DIG		; $4aab
	call playSound		; $4aad
	jp _subterror_spawnDirt		; $4ab0


; Currently in the ground, moving around
_subterror_stateA:
	ld e,Enemy.state2		; $4ab3
	ld a,(de)		; $4ab5
	rst_jumpTable			; $4ab6
	.dw @substate0
	.dw @substate1
	.dw @substate2

; Staying underground for [counter1] frames before moving
@substate0:
	call _ecom_decCounter1		; $4abd
	ret nz			; $4ac0

	call _ecom_incState2		; $4ac1

@resetUndergroundMovement:
	; Adjust angle toward Link?
	call objectGetAngleTowardLink		; $4ac4
	ld c,a			; $4ac7
	ld e,Enemy.angle		; $4ac8
	ld a,(de)		; $4aca
	xor $10			; $4acb
	cp c			; $4acd
	ld a,c			; $4ace
	jr nz,+			; $4acf
	add $08			; $4ad1
	and $1f			; $4ad3
+
	ld (de),a		; $4ad5

	ld e,Enemy.counter1		; $4ad6
	ld a,30		; $4ad8
	ld (de),a		; $4ada

	call _subterror_getAngerLevel		; $4adb
	ld hl,_subterror_speedVals		; $4ade
	rst_addAToHl			; $4ae1
	ld a,(hl)		; $4ae2
	ld e,Enemy.speed		; $4ae3
	ld (de),a		; $4ae5

	ld a,$0a		; $4ae6
	call objectSetCollideRadius		; $4ae8
	jp _subterror_spawnDirt		; $4aeb

; Moving around until shovel is used or he starts drilling
@substate1:
	ld e,Enemy.var2a		; $4aee
	ld a,(de)		; $4af0
	sla a			; $4af1
	jr nc,@noShovel	; $4af3
	cp ITEMCOLLISION_SHOVEL<<1			; $4af5
	jr nz,@noShovel	; $4af7

	; Shovel was used; will now pop out of ground

	ld bc,-$100		; $4af9
	call objectSetSpeedZ		; $4afc
	ld l,Enemy.speed		; $4aff
	ld (hl),SPEED_100		; $4b01

	ld a,$0c		; $4b03
	ld l,Enemy.state		; $4b05
	ldi (hl),a		; $4b07
	xor a			; $4b08
	ld (hl),a ; [state2] = 0

	ld l,Enemy.var30		; $4b0a
	ld (hl),a ; [var30] = 0

	inc a			; $4b0d
	ld l,Enemy.counter1		; $4b0e
	ld (hl),a ; [counter1] = 1

	ld l,Enemy.visible		; $4b11
	set 7,(hl)		; $4b13

	; Bounces away from Link
	call objectGetAngleTowardLink		; $4b15
	xor $10			; $4b18
	ld e,Enemy.angle		; $4b1a
	ld (de),a		; $4b1c

	ld a,$06		; $4b1d
	call objectSetCollideRadius		; $4b1f
	ld a,$05		; $4b22
	jp enemySetAnimation		; $4b24

@noShovel:
	call objectApplySpeed		; $4b27
	ld a,$01		; $4b2a
	call _ecom_getSideviewAdjacentWallsBitset		; $4b2c
	jr z,++			; $4b2f

	; Hit wall
	call _ecom_incState2		; $4b31
	ld l,Enemy.counter1		; $4b34
	ld (hl),90		; $4b36
	ld l,Enemy.visible		; $4b38
	res 7,(hl)		; $4b3a
	ld l,Enemy.var30		; $4b3c
	ld (hl),$00		; $4b3e
	ret			; $4b40
++
	call _ecom_decCounter1		; $4b41
	call z,@resetUndergroundMovement		; $4b44
	call _ecom_decCounter2		; $4b47
	ret nz			; $4b4a

	; If Link is close enough, drill him
	ld c,$18		; $4b4b
	call objectCheckLinkWithinDistance		; $4b4d
	ret nc			; $4b50

	; "Transport" to the tile at Link's position
	ld hl,w1Link.yh		; $4b51
	ldi a,(hl)		; $4b54
	inc l			; $4b55
	ld c,(hl)		; $4b56
	ld b,a			; $4b57
	call getTileAtPosition		; $4b58
	ld c,l			; $4b5b
	call convertShortToLongPosition_paramC		; $4b5c
	ld e,Enemy.yh		; $4b5f
	ld a,b			; $4b61
	ld (de),a		; $4b62
	ld e,Enemy.xh		; $4b63
	ld a,c			; $4b65
	ld (de),a		; $4b66

	call _ecom_incState ; [state] = $0b
	inc l			; $4b6a
	xor a			; $4b6b
	ld (hl),a ; [state2] = 0

	ld l,Enemy.var30		; $4b6d
	ld (hl),a ; [var30] = 0

	ld a,60		; $4b70
	ld l,Enemy.counter1		; $4b72
	ldi (hl),a		; $4b74
	sra a			; $4b75
	ld (hl),a ; [counter2] = 30

	ld a,$06		; $4b78
	call objectSetCollideRadius		; $4b7a
	ld a,$06		; $4b7d
	jp enemySetAnimation		; $4b7f

; Hit a wall; pause before resuming
@substate2:
	call _ecom_decCounter2		; $4b82
	call _ecom_decCounter1		; $4b85
	ret nz			; $4b88
	ld l,Enemy.state2		; $4b89
	dec (hl)		; $4b8b
	jp @resetUndergroundMovement		; $4b8c


; Drilling
_subterror_stateB:
	ld e,Enemy.state2		; $4b8f
	ld a,(de)		; $4b91
	rst_jumpTable			; $4b92
	.dw @substate0
	.dw @substate1

@substate0:
	ld h,d			; $4b97
	ld l,Enemy.counter2		; $4b98
	ld a,(hl)		; $4b9a
	or a			; $4b9b
	jr z,@drilling	; $4b9c

	dec (hl)		; $4b9e
	ret nz			; $4b9f

	; Just started drilling
	ld l,Enemy.enemyCollisionMode		; $4ba0
	ld (hl),ENEMYCOLLISION_SUBTERROR_DRILLING		; $4ba2
	ld l,Enemy.visible		; $4ba4
	set 7,(hl)		; $4ba6
	ld a,SND_SHOCK		; $4ba8
	call playSound		; $4baa

@drilling:
	call enemyAnimate		; $4bad
	call _ecom_decCounter1		; $4bb0
	ret nz			; $4bb3

	ld l,Enemy.counter1		; $4bb4
	ld (hl),60		; $4bb6
	ld a,$07		; $4bb8
	call enemySetAnimation		; $4bba
	jp _ecom_incState2		; $4bbd

@substate1:
	call _subterror_retFromCallerIfAnimationUnfinished		; $4bc0
	call _subterror_beginUndergroundMovement		; $4bc3
	ld e,Enemy.var30		; $4bc6
	xor a			; $4bc8
	ld (de),a		; $4bc9
	ret			; $4bca


; Popping out of ground after shovel was used
_subterror_stateC:
	ld e,Enemy.state2		; $4bcb
	ld a,(de)		; $4bcd
	rst_jumpTable			; $4bce
	.dw @substate0
	.dw @substate1
	.dw @substate2

@substate0:
	call _ecom_applyVelocityForSideviewEnemy		; $4bd5
	ld c,$10		; $4bd8
	call objectUpdateSpeedZ_paramC		; $4bda
	ret nz			; $4bdd

	ld e,Enemy.var2a		; $4bde
	ld (de),a ; [var2a] = 0

	ld e,Enemy.enemyCollisionMode		; $4be1
	ld a,ENEMYCOLLISION_STANDARD_MINIBOSS		; $4be3
	ld (de),a		; $4be5

	call _ecom_decCounter1		; $4be6
	jr z,++			; $4be9
	ld l,Enemy.counter1		; $4beb
	ld (hl),180		; $4bed
	jp _ecom_incState2		; $4bef
++
	ld bc,-$80		; $4bf2
	jp objectSetSpeedZ		; $4bf5

@substate1:
	ld e,Enemy.var2a		; $4bf8
	ld a,(de)		; $4bfa
	or a			; $4bfb
	jr nz,++		; $4bfc
	call enemyAnimate		; $4bfe
	call _ecom_decCounter1		; $4c01
	ret nz			; $4c04
++
	call _ecom_incState2		; $4c05

	call getRandomNumber		; $4c08
	and $1c			; $4c0b
	ld l,Enemy.angle		; $4c0d
	ld (hl),a		; $4c0f

	ld l,Enemy.speed		; $4c10
	ld (hl),SPEED_80		; $4c12

	call getRandomNumber		; $4c14
	and $03			; $4c17
	ld hl,_subterror_durationAboveGround		; $4c19
	rst_addAToHl			; $4c1c
	ldi a,(hl)		; $4c1d
	ld e,Enemy.counter1		; $4c1e
	ld (de),a		; $4c20

	jp _subterror_setAnimationFromAngle		; $4c21

@substate2:
	call enemyAnimate		; $4c24

	ld e,Enemy.animParameter		; $4c27
	ld a,(de)		; $4c29
	or a			; $4c2a
	ld a,SND_LAND		; $4c2b
	call nz,playSound		; $4c2d

	call objectApplySpeed		; $4c30
	call _ecom_bounceOffWallsAndHoles		; $4c33
	call nz,_subterror_setAnimationFromAngle		; $4c36

	; Dig back into ground when [counter1] reaches 0
	call _ecom_decCounter1		; $4c39
	ret nz			; $4c3c
	jp _subterror_digIntoGround		; $4c3d


;;
; @addr{4c40}
_subterror_spawnDirtEvery8Frames:
	inc e			; $4c40
	ld a,(de) ; [var31]
	dec a			; $4c42
	ld (de),a		; $4c43
	ret nz			; $4c44

;;
; @addr{4c45}
_subterror_spawnDirt:
	ld e,Enemy.var31		; $4c45
	ld a,$07		; $4c47
	ld (de),a ; [var31] = 7
	dec e			; $4c4a
	ld (de),a ; [var30] = 7

	ld b,PARTID_SUBTERROR_DIRT		; $4c4c
	call _ecom_spawnProjectile		; $4c4e

	call objectGetTileAtPosition		; $4c51
	ld c,l			; $4c54
	ld a,$ef		; $4c55
	jp setTile		; $4c57

;;
; @addr{4c5a}
_subterror_retFromCallerIfAnimationUnfinished:
	call enemyAnimate		; $4c5a
	ld h,d			; $4c5d
	ld l,Enemy.animParameter		; $4c5e
	ld a,(hl)		; $4c60
	or a			; $4c61
	ret nz			; $4c62
	pop af			; $4c63
	ret			; $4c64

;;
; @param[out]	a	Anger level (0-2)
; @addr{4c65}
_subterror_getAngerLevel:
	ld b,$00		; $4c65
	ld e,Enemy.health		; $4c67
	ld a,(de)		; $4c69
	cp $0a			; $4c6a
	jr nc,++		; $4c6c
	inc b			; $4c6e
	cp $06			; $4c6f
	jr nc,++		; $4c71
	inc b			; $4c73
++
	ld a,b			; $4c74
	ret			; $4c75

;;
; @addr{4c76}
_subterror_setAnimationFromAngle:
	ld h,d			; $4c76
	ld l,Enemy.angle		; $4c77
	ldd a,(hl)		; $4c79
	add a			; $4c7a
	swap a			; $4c7b
	and $03			; $4c7d
	ld (hl),a ; [direction]
	add $00			; $4c80
	jp enemySetAnimation		; $4c82


_subterror_speedVals: ; Chosen based on "anger level"
	.db SPEED_80 SPEED_100 SPEED_180

_subterror_timeUntilDrillAttack: ; Chosen based on "anger level"
	.db 120 90 60

_subterror_durationAboveGround: ; Chosen randomly
	.db 60 90 120 180


; ==============================================================================
; ENEMYID_ARMOS_WARRIOR
;
; Variables (for parent only, subid 1):
;   var30: "Turn" direction (should be 8 or -8)
;   var31: Shield
;   var32: Sword
;
; Variables (for shield only, subid 2):
;   relatedObj1: parent
;   relatedObj2: shield
;   var30: Animation index (0 or 1)
;   var31: Animation base (multiple of 2, for broken shield animation)
;   var32: Hits until destruction
;
; Variables (for sword only, subid 3):
;   relatedObj1: parent
;   relatedObj2: shield
;   var30/var31: Target position
;   var32/var33: Base position (yh and xh are manipulated by the animation to fix their
;                collision box, so need to be reset to these values each frame)
;   var34: If nonzero, checks for collision with shield
; ==============================================================================
enemyCode73:
	jr z,@normalStatus	; $4c8f
	sub ENEMYSTATUS_NO_HEALTH			; $4c91
	ret c			; $4c93
	jr nz,@normalStatus	; $4c94

	; ENEMYSTATUS_DEAD

	ld e,Enemy.subid		; $4c96
	ld a,(de)		; $4c98
	dec a			; $4c99
	jp z,_enemyBoss_dead		; $4c9a

	dec a			; $4c9d
	jr nz,@delete	; $4c9e

	; Subid 2 (shield) just destroyed

	; Destroy sword
	call _ecom_killRelatedObj2		; $4ca0

	; Set some variables on parent
	ld a,Object.state		; $4ca3
	call objectGetRelatedObject1Var		; $4ca5
	ld (hl),$0d		; $4ca8

	ld l,Enemy.counter1		; $4caa
	ld (hl),90		; $4cac

	ld l,Enemy.invincibilityCounter		; $4cae
	ld (hl),$60		; $4cb0

@delete:
	jp enemyDelete		; $4cb2

@normalStatus:
	call _ecom_getSubidAndCpStateTo08		; $4cb5
	jr nc,@normalState	; $4cb8
	rst_jumpTable			; $4cba
	.dw _armosWarrior_state_uninitialized
	.dw _armosWarrior_state_spawner
	.dw _armosWarrior_state_stub
	.dw _armosWarrior_state_stub
	.dw _armosWarrior_state_stub
	.dw _armosWarrior_state_stub
	.dw _armosWarrior_state_stub
	.dw _armosWarrior_state_stub

@normalState:
	dec b			; $4ccb
	ld a,b			; $4ccc
	rst_jumpTable			; $4ccd
	.dw _armosWarrior_parent
	.dw _armosWarrior_shield
	.dw _armosWarrior_sword


_armosWarrior_state_uninitialized:
	ld a,b			; $4cd4
	or a			; $4cd5
	jp nz,_ecom_setSpeedAndState8		; $4cd6

	; Spawner only

	inc a			; $4cd9
	ld (de),a ; [state] = 1
	ld (wDisabledObjects),a		; $4cdb
	ld (wMenuDisabled),a		; $4cde

	ld a,ENEMYID_ARMOS_WARRIOR		; $4ce1
	jp _enemyBoss_initializeRoom		; $4ce3


_armosWarrior_state_spawner:
	ld b,$03		; $4ce6
	call checkBEnemySlotsAvailable		; $4ce8
	ret nz			; $4ceb

	ld c,$0c		; $4cec
	call _ecom_setZAboveScreen		; $4cee

	; Spawn parent
	ld b,ENEMYID_ARMOS_WARRIOR		; $4cf1
	call _ecom_spawnUncountedEnemyWithSubid01		; $4cf3
	ld c,h			; $4cf6

	; Spawn shield
	call _ecom_spawnUncountedEnemyWithSubid01		; $4cf7
	inc (hl) ; [shield.subid] = 2

	; [shield.relatedObj1] = parent
	ld l,Enemy.relatedObj1		; $4cfb
	ld a,Enemy.start		; $4cfd
	ldi (hl),a		; $4cff
	ld (hl),c		; $4d00

	call objectCopyPosition		; $4d01
	push hl			; $4d04

	; Spawn sword
	call _ecom_spawnUncountedEnemyWithSubid01		; $4d05
	ld (hl),$03 ; [sword.subid] = 3

	; [sword.relatedObj1] = parent
	ld l,Enemy.relatedObj1		; $4d0a
	ld a,Enemy.start		; $4d0c
	ldi (hl),a		; $4d0e
	ld (hl),c		; $4d0f

	call objectCopyPosition		; $4d10

	; [parent.var31] = shield
	; [parent.var32] = sword
	ld b,h			; $4d13
	pop hl			; $4d14
	ld a,h			; $4d15
	ld h,c			; $4d16
	ld l,Enemy.var31		; $4d17
	ldi (hl),a		; $4d19
	ld (hl),b		; $4d1a

	call objectCopyPosition		; $4d1b

	; Transfer enabled byte to parent
	ld l,Enemy.enabled		; $4d1e
	ld e,l			; $4d20
	ld a,(de)		; $4d21
	ld (hl),a		; $4d22

	jp enemyDelete		; $4d23


_armosWarrior_state_stub:
	ret			; $4d26


_armosWarrior_parent:
	ld a,(de)		; $4d27
	sub $08			; $4d28
	rst_jumpTable			; $4d2a
	.dw _armosWarrior_parent_state8
	.dw _armosWarrior_parent_state9
	.dw _armosWarrior_parent_stateA
	.dw _armosWarrior_parent_stateB
	.dw _armosWarrior_parent_stateC
	.dw _armosWarrior_parent_stateD
	.dw _armosWarrior_parent_stateE
	.dw _armosWarrior_parent_stateF
	.dw _armosWarrior_parent_state10


; Waiting for door to close
_armosWarrior_parent_state8:
	ld a,($cc93)		; $4d3d
	or a			; $4d40
	ret nz			; $4d41

	ldbc $01,$08		; $4d42
	call _enemyBoss_spawnShadow		; $4d45
	ret nz			; $4d48

	ld h,d			; $4d49
	ld l,e			; $4d4a
	inc (hl) ; [state]

	ld l,Enemy.speed		; $4d4c
	ld (hl),SPEED_80		; $4d4e

	ld l,Enemy.enemyCollisionMode		; $4d50
	ld (hl),ENEMYCOLLISION_ARMOS_WARRIOR_PROTECTED		; $4d52
	jp objectSetVisible82		; $4d54


; Cutscene before fight starts (falling from sky)
_armosWarrior_parent_state9:
	inc e			; $4d57
	ld a,(de) ; [state2]
	rst_jumpTable			; $4d59
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4

@substate0:
	ld c,$20		; $4d64
	call objectUpdateSpeedZ_paramC		; $4d66
	ret nz			; $4d69

	; Hit the ground

	ld l,Enemy.state2		; $4d6a
	inc (hl)		; $4d6c

	inc l			; $4d6d
	ld a,$1a		; $4d6e
	ld (hl),a ; [counter1]
	ld (wScreenShakeCounterY),a		; $4d71
	ld (wScreenShakeCounterX),a		; $4d74

	; [sword.zh] = [parent.zh]
	ld l,Enemy.var32		; $4d77
	ld h,(hl)		; $4d79
	ld l,Enemy.zh		; $4d7a
	ld e,l			; $4d7c
	ld a,(de)		; $4d7d
	ld (hl),a		; $4d7e

	ld a,SND_STRONG_POUND		; $4d7f
	jp playSound		; $4d81

@substate1:
	call _ecom_decCounter1		; $4d84
	ret nz			; $4d87
	ld l,e			; $4d88
	inc (hl) ; [state2]
	ld bc,TX_2f01		; $4d8a
	jp showText		; $4d8d

@substate2:
	ld h,d			; $4d90
	ld l,e			; $4d91
	inc (hl) ; [state2]

	ld l,Enemy.counter1		; $4d93
	ld (hl),30		; $4d95

	call _enemyBoss_beginMiniboss		; $4d97
	ld a,$02		; $4d9a
	jp enemySetAnimation		; $4d9c

@substate3:
	call _ecom_decCounter1		; $4d9f
	ret nz			; $4da2

	ld (hl),70 ; [counter1]
	ld l,Enemy.angle		; $4da5
	ld (hl),ANGLE_DOWN		; $4da7

	ld l,e			; $4da9
	inc (hl) ; [state2]

	; [sword.yh] -= 2
	ld l,Enemy.var32		; $4dab
	ld h,(hl)		; $4dad
	ld l,Enemy.yh		; $4dae
	ld a,(hl)		; $4db0
	sub $02			; $4db1
	ldi (hl),a		; $4db3

	; [sword.xh] -= 1
	inc l			; $4db4
	dec (hl)		; $4db5

	xor a			; $4db6
	jp enemySetAnimation		; $4db7

; Sword moving up, parent moving down
@substate4:
	call _ecom_decCounter1		; $4dba
	jr nz,++		; $4dbd

	ld l,Enemy.state		; $4dbf
	inc (hl)		; $4dc1

	ld l,Enemy.angle		; $4dc2
	ld (hl),ANGLE_LEFT		; $4dc4

	ld l,Enemy.var30		; $4dc6
	ld (hl),$08		; $4dc8
++
	call objectApplySpeed		; $4dca
	jp enemyAnimate		; $4dcd


; Deciding which direction to move in next
_armosWarrior_parent_stateA:
	; If the armos is moving directly toward his sword, reverse direction
	ld e,Enemy.var32		; $4dd0
	ld a,(de)		; $4dd2
	ld h,a			; $4dd3
	ld l,Enemy.yh		; $4dd4
	ld b,(hl)		; $4dd6
	ld l,Enemy.xh		; $4dd7
	ld c,(hl)		; $4dd9
	call objectGetRelativeAngle		; $4dda
	add $04			; $4ddd
	and $18			; $4ddf
	ld b,a			; $4de1
	ld e,Enemy.angle		; $4de2
	ld a,(de)		; $4de4
	cp b			; $4de5
	jr nz,++		; $4de6

	; Reverse direction
	xor $10			; $4de8
	ld (de),a		; $4dea
	ld e,Enemy.var30		; $4deb
	ld a,(de)		; $4ded
	cpl			; $4dee
	inc a			; $4def
	ld (de),a		; $4df0
++
	call _ecom_incState		; $4df1
	ld l,Enemy.counter1		; $4df4
	ld (hl),75		; $4df6
	jr _armosWarrior_parent_animate		; $4df8


; Moving in "box" pattern for [counter1] frames
_armosWarrior_parent_stateB:
	call _ecom_decCounter1		; $4dfa
	jr nz,_armosWarrior_parent_updateBoxMovement		; $4dfd
	ld l,e			; $4dff
	dec (hl) ; [state]

_armosWarrior_parent_updateBoxMovement:
	call _armosWarrior_parent_checkReachedTurningPoint		; $4e01
	jr nz,_armosWarrior_parent_animate	; $4e04

	; Hit one of the turning points in his movement pattern; turn 90 degrees
	ld h,d			; $4e06
	ld l,Enemy.var30		; $4e07
	ld e,Enemy.angle		; $4e09
	ld a,(de)		; $4e0b
	add (hl)		; $4e0c
	and $18			; $4e0d
	ld (de),a		; $4e0f

_armosWarrior_parent_animate:
	jp enemyAnimate		; $4e10


; Shield just hit
_armosWarrior_parent_stateC:
	call enemyAnimate		; $4e13
	call _ecom_decCounter1		; $4e16
	jr nz,_armosWarrior_parent_updateBoxMovement	; $4e19

	ld l,Enemy.state		; $4e1b
	ld (hl),$0a		; $4e1d

	; Set speed based on number of shield hits
	ld l,Enemy.var31		; $4e1f
	ld h,(hl)		; $4e21
	ld l,Enemy.var32		; $4e22
	ld a,(hl)		; $4e24
	ld hl,_armosWarrior_parent_speedVals		; $4e25
	rst_addAToHl			; $4e28
	ld e,Enemy.speed		; $4e29
	ld a,(hl)		; $4e2b
	ld (de),a		; $4e2c
	ret			; $4e2d


; Shield just destroyed
_armosWarrior_parent_stateD:
	call _ecom_decCounter1		; $4e2e
	jr z,@gotoNextState	; $4e31

	; Create debris at random offset every 8 frames
	ld a,(hl)		; $4e33
	and $07			; $4e34
	ret nz			; $4e36

	call getRandomNumber_noPreserveVars		; $4e37
	ld c,a			; $4e3a
	and $70			; $4e3b
	swap a			; $4e3d
	sub $04			; $4e3f
	ld b,a			; $4e41
	ld a,c			; $4e42
	and $0f			; $4e43
	ld c,a			; $4e45
	call getFreeInteractionSlot		; $4e46
	ret nz			; $4e49
	ld (hl),INTERACID_ROCKDEBRIS		; $4e4a
	jp objectCopyPositionWithOffset		; $4e4c

@gotoNextState:
	ld (hl),30 ; [counter1]
	ld l,e			; $4e51
	inc (hl) ; [state]

	ld l,Enemy.enemyCollisionMode		; $4e53
	ld (hl),ENEMYCOLLISION_STANDARD_MINIBOSS		; $4e55

	ld l,Enemy.speed		; $4e57
	ld (hl),SPEED_200		; $4e59

	ld bc,TX_2f02		; $4e5b
	call showText		; $4e5e

	ld a,$01		; $4e61
	jp enemySetAnimation		; $4e63


; Standing still before charging Link
_armosWarrior_parent_stateE:
	call enemyAnimate		; $4e66
	call _ecom_decCounter1		; $4e69
	jr nz,_armosWarrior_parent_animate	; $4e6c
	ld l,Enemy.state		; $4e6e
	inc (hl)		; $4e70
	jp _ecom_updateAngleTowardTarget		; $4e71


; Charging
_armosWarrior_parent_stateF:
	call enemyAnimate		; $4e74
	ld a,$01		; $4e77
	call _ecom_getSideviewAdjacentWallsBitset		; $4e79
	jp z,objectApplySpeed		; $4e7c

	; Hit wall

	call _ecom_incState		; $4e7f
	ld l,Enemy.angle		; $4e82
	ld a,(hl)		; $4e84
	xor $10			; $4e85
	ld (hl),a		; $4e87

	ld l,Enemy.speedZ		; $4e88
	ld a,<(-$180)		; $4e8a
	ldi (hl),a		; $4e8c
	ld (hl),>(-$180)		; $4e8d

	ld l,Enemy.speed		; $4e8f
	ld (hl),SPEED_100		; $4e91

	ld a,30		; $4e93
	call setScreenShakeCounter		; $4e95

	ld a,SND_STRONG_POUND		; $4e98
	jp playSound		; $4e9a


; Recoiling from hitting wall
_armosWarrior_parent_state10:
	call enemyAnimate		; $4e9d
	ld c,$16		; $4ea0
	call objectUpdateSpeedZ_paramC		; $4ea2
	jp nz,objectApplySpeed		; $4ea5

	; Hit ground

	ld h,d			; $4ea8
	ld l,Enemy.state		; $4ea9
	ld (hl),$0e		; $4eab

	ld l,Enemy.speed		; $4ead
	ld (hl),SPEED_200		; $4eaf

	ld l,Enemy.counter1		; $4eb1
	ld (hl),60		; $4eb3
	ret			; $4eb5


_armosWarrior_shield:
	ld a,(de)		; $4eb6
	cp $08			; $4eb7
	jr z,@state8		; $4eb9

@state9:
	; Delete self if no hits remaining
	ld h,d			; $4ebb
	ld l,Enemy.var32		; $4ebc
	ld a,(hl)		; $4ebe
	or a			; $4ebf
	jp z,_ecom_killObjectH		; $4ec0

	ld a,Object.animParameter		; $4ec3
	call objectGetRelatedObject1Var		; $4ec5
	ld e,Enemy.var30		; $4ec8
	ld a,(de)		; $4eca
	cp (hl)			; $4ecb
	jr z,++			; $4ecc

	ld a,(hl)		; $4ece
	ld (de),a		; $4ecf
	ld e,Enemy.var31		; $4ed0
	ld a,(de)		; $4ed2
	add (hl)		; $4ed3
	call enemySetAnimation		; $4ed4
++
	jp _armosWarrior_shield_updatePosition		; $4ed7

; Uninitialized
@state8:
	ld a,($cc93)		; $4eda
	or a			; $4edd
	ret nz			; $4ede

	ld h,d			; $4edf
	ld l,e			; $4ee0
	inc (hl) ; [state]

	ld l,Enemy.enemyCollisionMode		; $4ee2
	ld (hl),ENEMYCOLLISION_ARMOS_WARRIOR_SHIELD		; $4ee4

	ld l,Enemy.var32		; $4ee6
	ld (hl),$03		; $4ee8

	; [shield.relatedObj2] = sword (parent.var32)
	ld l,Enemy.relatedObj1+1		; $4eea
	ld h,(hl)		; $4eec
	ld l,Enemy.var32		; $4eed
	ld e,Enemy.relatedObj2		; $4eef
	ld a,Enemy.start		; $4ef1
	ld (de),a		; $4ef3
	inc e			; $4ef4
	ld a,(hl)		; $4ef5
	ld (de),a		; $4ef6

	ld e,Enemy.var31		; $4ef7
	ld a,$03		; $4ef9
	ld (de),a		; $4efb

	call enemySetAnimation		; $4efc
	call _armosWarrior_shield_updatePosition		; $4eff
	jp objectSetVisible81		; $4f02


_armosWarrior_sword:
	ld e,Enemy.state		; $4f05
	ld a,(de)		; $4f07
	cp $0b			; $4f08
	call nc,_armosWarrior_sword_playSlashSound		; $4f0a

	ld e,Enemy.state		; $4f0d
	ld a,(de)		; $4f0f
	sub $08			; $4f10
	rst_jumpTable			; $4f12
	.dw _armosWarrior_sword_state8
	.dw _armosWarrior_sword_state9
	.dw _armosWarrior_sword_stateA
	.dw _armosWarrior_sword_stateB
	.dw _armosWarrior_sword_stateC


; Waiting for door to close
_armosWarrior_sword_state8:
	ld a,($cc93)		; $4f1d
	or a			; $4f20
	ret nz			; $4f21

	ld h,d			; $4f22
	ld l,e			; $4f23
	inc (hl) ; [state]

	ld l,Enemy.enemyCollisionMode		; $4f25
	ld (hl),ENEMYCOLLISION_ARMOS_WARRIOR_SWORD		; $4f27

	ld l,Enemy.speed		; $4f29
	ld (hl),SPEED_20		; $4f2b

	call _armosWarrior_sword_setPositionAsHeld		; $4f2d

	; [sword.relatedObj2] = shield (parent.var31)
	ld l,Enemy.var31		; $4f30
	ld e,Enemy.relatedObj2		; $4f32
	ld a,Enemy.start		; $4f34
	ld (de),a		; $4f36
	inc e			; $4f37
	ld a,(hl)		; $4f38
	ld (de),a		; $4f39

	ld a,$09		; $4f3a
	call enemySetAnimation		; $4f3c
	jp objectSetVisible80		; $4f3f


; Waiting for initial cutscene to end, then moving upward before fight starts
_armosWarrior_sword_state9:
	ld a,Object.state2		; $4f42
	call objectGetRelatedObject1Var		; $4f44
	ld a,(hl)		; $4f47
	or a			; $4f48
	jp z,_armosWarrior_sword_setPositionAsHeld		; $4f49

	sub $03			; $4f4c
	ret c			; $4f4e
	jr z,@parentSubstate3	; $4f4f

	dec l			; $4f51
	ld a,(hl) ; [parent.state]
	cp $0a			; $4f53
	jr nc,@gotoStateA	; $4f55
	call _armosWarrior_sword_playSlashSound		; $4f57
	jp enemyAnimate		; $4f5a

@gotoStateA:
	ld h,d			; $4f5d
	inc (hl) ; [state]

	ld l,Enemy.counter1		; $4f5f
	ld (hl),$01		; $4f61

	; Save position
	ld e,Enemy.yh		; $4f63
	ld l,Enemy.var32		; $4f65
	ld a,(de)		; $4f67
	ldi (hl),a		; $4f68
	ld e,Enemy.xh		; $4f69
	ld a,(de)		; $4f6b
	ld (hl),a		; $4f6c
	ret			; $4f6d

@parentSubstate3:
	ld h,d			; $4f6e
	ld l,Enemy.counter1		; $4f6f
	ld a,(hl)		; $4f71
	inc (hl)		; $4f72

	or a			; $4f73
	ld a,$0a		; $4f74
	jp z,enemySetAnimation		; $4f76

	ld l,Enemy.yh		; $4f79
	dec (hl)		; $4f7b
	ret			; $4f7c


; Staying still before charging toward Link
_armosWarrior_sword_stateA:
	call _ecom_decCounter1		; $4f7d
	ret nz			; $4f80

	ld l,e			; $4f81
	inc (hl) ; [state]

	ld l,Enemy.speed		; $4f83
	ld (hl),SPEED_180		; $4f85

	ld l,Enemy.counter1		; $4f87
	ld (hl),150		; $4f89

	; Write target position to var30/var31
	ld l,Enemy.var30		; $4f8b
	ldh a,(<hEnemyTargetY)	; $4f8d
	ldi (hl),a		; $4f8f
	ldh a,(<hEnemyTargetX)	; $4f90
	ld (hl),a		; $4f92

	call _ecom_updateAngleTowardTarget		; $4f93
	call enemyAnimate		; $4f96
	jp _armosWarrior_sword_updateCollisionBox		; $4f99


; Charging toward target position
_armosWarrior_sword_stateB:
	call _armosWarrior_sword_checkCollisionWithShield		; $4f9c
	ld a,(wFrameCounter)		; $4f9f
	and $03			; $4fa2
	jr nz,++		; $4fa4

	; Update angle toward target position every 4 frames
	ld h,d			; $4fa6
	ld l,Enemy.var30		; $4fa7
	call _ecom_readPositionVars		; $4fa9
	call objectGetRelativeAngleWithTempVars		; $4fac
	ld e,Enemy.angle		; $4faf
	ld (de),a		; $4fb1
++
	call _armosWarrior_sword_checkWentTooFar		; $4fb2
	jr c,@beginSlowingDown	; $4fb5

	; If within 28 pixels of target position, start slowing down
	ld l,Enemy.var30		; $4fb7
	ld a,(hl)		; $4fb9
	sub b			; $4fba
	add 28			; $4fbb
	cp 57			; $4fbd
	jr nc,@notSlowingDown	; $4fbf
	inc l			; $4fc1
	ld a,(hl)		; $4fc2
	sub c			; $4fc3
	add 28			; $4fc4
	cp 57			; $4fc6
	jr nc,@notSlowingDown	; $4fc8

@beginSlowingDown:
	ld l,Enemy.state		; $4fca
	inc (hl)		; $4fcc
	ld l,Enemy.counter1		; $4fcd
	ld (hl),$70		; $4fcf

@notSlowingDown:
	call enemyAnimate		; $4fd1

_armosWarrior_sword_updatePosition:
	call _ecom_applyVelocityForTopDownEnemy		; $4fd4

	; Save position
	ld h,d			; $4fd7
	ld l,Enemy.yh		; $4fd8
	ld e,Enemy.var32		; $4fda
	ldi a,(hl)		; $4fdc
	ld (de),a		; $4fdd
	inc e			; $4fde
	inc l			; $4fdf
	ld a,(hl)		; $4fe0
	ld (de),a		; $4fe1

	jp _armosWarrior_sword_updateCollisionBox		; $4fe2


; Slowing down
_armosWarrior_sword_stateC:
	call _armosWarrior_sword_checkCollisionWithShield		; $4fe5
	call _ecom_decCounter1		; $4fe8
	jr z,@stoppedMoving	; $4feb

	ld a,(hl) ; [counter1]
	swap a			; $4fee
	rrca			; $4ff0
	and $03			; $4ff1
	ld hl,_armosWarrior_sword_speedVals		; $4ff3
	rst_addAToHl			; $4ff6
	ld e,Enemy.speed		; $4ff7
	ld a,(hl)		; $4ff9
	ld (de),a		; $4ffa

	; Restore position (which was manipulated for shield collision detection)
	ld h,d			; $4ffb
	ld l,Enemy.yh		; $4ffc
	ld e,Enemy.var32		; $4ffe
	ld a,(de)		; $5000
	ldi (hl),a		; $5001
	inc e			; $5002
	inc l			; $5003
	ld a,(de)		; $5004
	ld (hl),a		; $5005

	ld e,Enemy.counter1		; $5006
	ld a,(de)		; $5008
	cp 30			; $5009
	jr nc,+			; $500b
	rrca			; $500d
+
	call nc,enemyAnimate		; $500e
	jr _armosWarrior_sword_updatePosition		; $5011

@stoppedMoving:
	ld e,Enemy.animParameter		; $5013
	ld a,(de)		; $5015
	cp $07			; $5016
	jr z,@atRest			; $5018
	ld (hl),$02 ; [counter1]
	jp enemyAnimate		; $501c

@atRest:
	ld l,Enemy.state		; $501f
	ld (hl),$0a		; $5021
	ld l,Enemy.var34		; $5023
	ld (hl),$00		; $5025

	; Set counter1 (frames to rest) based on number of hits until shield destroyed
	ld a,Object.var32		; $5027
	call objectGetRelatedObject2Var		; $5029
	ld a,(hl)		; $502c
	swap a			; $502d
	rlca			; $502f
	add 30			; $5030
	ld e,Enemy.counter1		; $5032
	ld (de),a		; $5034

	ld a,$0a		; $5035
	jp enemySetAnimation		; $5037


;;
; Shield copies parent's position plus an offset
; @addr{503a}
_armosWarrior_shield_updatePosition:
	ld a,Object.yh		; $503a
	call objectGetRelatedObject1Var		; $503c
	ldi a,(hl) ; [parent.yh]
	ld b,a			; $5040
	inc l			; $5041
	ldi a,(hl) ; [parent.xh]
	ld c,a			; $5043

	inc l			; $5044
	ld e,l			; $5045
	ld a,(hl)		; $5046
	ld (de),a ; [shield.zh] = [parent.zh]

	ld e,Enemy.var30		; $5048
	ld a,(de)		; $504a
	ld hl,_armosWarrior_shield_YXOffsets		; $504b
	rst_addDoubleIndex			; $504e
	ld e,Enemy.yh		; $504f
	ldi a,(hl)		; $5051
	add b			; $5052
	ld (de),a		; $5053
	ld e,Enemy.xh		; $5054
	ld a,(hl)		; $5056
	add c			; $5057
	ld (de),a		; $5058
	ret			; $5059


;;
; Updates collisionRadiusY/X based on animParameter, also adds an offset to Y/X position.
; @addr{505a}
_armosWarrior_sword_updateCollisionBox:
	ld e,Enemy.animParameter		; $505a
	ld a,(de)		; $505c
	add a			; $505d
	ld hl,_armosWarrior_sword_collisionBoxes		; $505e
	rst_addDoubleIndex			; $5061

	ld e,Enemy.var32		; $5062
	ld a,(de)		; $5064
	add (hl)		; $5065
	ld e,Enemy.yh		; $5066
	ld (de),a		; $5068

	inc hl			; $5069
	ld e,Enemy.var33		; $506a
	ld a,(de)		; $506c
	add (hl)		; $506d
	ld e,Enemy.xh		; $506e
	ld (de),a		; $5070
	inc hl			; $5071

	ld e,Enemy.collisionRadiusY		; $5072
	ldi a,(hl)		; $5074
	ld (de),a		; $5075
	inc e			; $5076
	ld a,(hl)		; $5077
	ld (de),a		; $5078
	ret			; $5079


;;
; Sets the sword's position assuming it's being held by the parent.
; @addr{507a}
_armosWarrior_sword_setPositionAsHeld:
	ld a,Object.yh		; $507a
	call objectGetRelatedObject1Var		; $507c
	ld bc,$f4fa		; $507f
	jp objectTakePositionWithOffset		; $5082

;;
; @addr{5085}
_armosWarrior_sword_checkCollisionWithShield:
	ld e,Enemy.var34		; $5085
	ld a,(de)		; $5087
	dec a			; $5088
	ret z			; $5089

	; Check if sword and shield collide
	ld a,Object.collisionRadiusY		; $508a
	call objectGetRelatedObject2Var		; $508c
	ld c,Enemy.yh		; $508f
	call @checkIntersection		; $5091
	ret nc			; $5094

	ld c,Enemy.xh		; $5095
	ld l,$a7		; $5097
	call @checkIntersection		; $5099
	ret nc			; $509c

	; They've collided

	ld e,Enemy.var34		; $509d
	ld a,$01		; $509f
	ld (de),a		; $50a1

	; Set various variables on the shield
	ld l,Enemy.invincibilityCounter		; $50a2
	ld (hl),$18		; $50a4

	; [Hits until destruction]--
	ld l,Enemy.var32		; $50a6
	dec (hl)		; $50a8

	ld l,Enemy.var31		; $50a9
	ld a,(hl)		; $50ab
	add $02			; $50ac
	ld (hl),a		; $50ae

	; h = [shield.relatedObj1] = parent
	ld l,Enemy.relatedObj1+1		; $50af
	ld h,(hl)		; $50b1

	ld l,Enemy.counter1		; $50b2
	ld (hl),60		; $50b4

	ld l,Enemy.state		; $50b6
	ld (hl),$0c		; $50b8

	ld l,Enemy.speed		; $50ba
	ld (hl),SPEED_300		; $50bc

	ld l,Enemy.invincibilityCounter		; $50be
	ld (hl),$18		; $50c0

	ld a,SND_BOSS_DAMAGE		; $50c2
	jp playSound		; $50c4

;;
; Checks for intersection on a position component given two objects.
; @addr{50c7}
@checkIntersection:
	; b = [sword.collisionRadius] + [shield.collisionRadius]
	ld e,l			; $50c7
	ld a,(de)		; $50c8
	add (hl)		; $50c9
	ld b,a			; $50ca

	; a = [sword.pos] - [shield.pos]
	ld l,c			; $50cb
	ld e,l			; $50cc
	ld a,(de)		; $50cd
	sub (hl)		; $50ce

	add b			; $50cf
	sla b			; $50d0
	inc b			; $50d2
	cp b			; $50d3
	ret			; $50d4


;;
; The armos always moves in a "box" pattern in his first phase, this checks if he's
; reached one of the "corners" of the box where he must turn.
;
; @param[out]	zflag	z if hit a turning point
; @addr{50d5}
_armosWarrior_parent_checkReachedTurningPoint:
	ld b,$31		; $50d5
	ld e,Enemy.yh		; $50d7
	ld a,(de)		; $50d9
	cp $30			; $50da
	jr c,@hitCorner	; $50dc

	ld b,$7f		; $50de
	cp $80			; $50e0
	jr nc,@hitCorner	; $50e2

	ld b,$bf		; $50e4
	ld e,Enemy.xh		; $50e6
	ld a,(de)		; $50e8
	cp $c0			; $50e9
	jr nc,@hitCorner	; $50eb

	ld b,$31		; $50ed
	cp $30			; $50ef
	jr c,@hitCorner	; $50f1

	call objectApplySpeed		; $50f3
	or d			; $50f6
	ret			; $50f7

@hitCorner:
	ld a,b			; $50f8
	ld (de),a		; $50f9
	xor a			; $50fa
	ret			; $50fb


;;
; @param[out]	bc	Position of sword
; @param[out]	cflag	c if the sword has gone to far and should stop now
; @addr{50fc}
_armosWarrior_sword_checkWentTooFar:
	; Fix position, store it in bc
	ld h,d			; $50fc
	ld l,Enemy.yh		; $50fd
	ld e,Enemy.var32		; $50ff
	ld a,(de)		; $5101
	ldi (hl),a		; $5102
	ld b,a			; $5103
	inc e			; $5104
	inc l			; $5105
	ld a,(de)		; $5106
	ld (hl),a		; $5107
	ld c,a			; $5108

	; Read in boundary data based on the angle, determine if the sword has gone past
	ld e,Enemy.angle		; $5109
	ld a,(de)		; $510b
	add $02			; $510c
	and $1c			; $510e
	rrca			; $5110
	ld hl,_armosWarrior_sword_angleBoundaries		; $5111
	rst_addAToHl			; $5114

	ldi a,(hl)		; $5115
	ld e,b			; $5116
	call @checkPositionComponent		; $5117
	jr c,++			; $511a
	ld e,c			; $511c
	ld a,(hl)		; $511d
	call @checkPositionComponent		; $511e
++
	ld h,d			; $5121
	ret			; $5122

;;
; @addr{5123}
@checkPositionComponent:
	; If bit 0 of the data structure is set, it's an upper / left boundary
	bit 0,a			; $5123
	jr nz,++		; $5125
	cp e			; $5127
	ret			; $5128
++
	cp e			; $5129
	ccf			; $512a
	ret			; $512b


_armosWarrior_shield_YXOffsets:
	.db $fb $03 ; Frame 0
	.db $fb $07 ; Frame 1


; This is a table of data values for various parts of the sword's animation, which adjusts
; its collision box.
;   b0: Y-offset
;   b1: X-offset
;   b2: collisionRadiusY
;   b3: collisionRadiusX
_armosWarrior_sword_collisionBoxes:
	.db $fc $00 $08 $03
	.db $fe $fe $06 $06
	.db $00 $fc $03 $08
	.db $02 $fe $06 $06
	.db $04 $ff $08 $03
	.db $02 $02 $06 $06
	.db $01 $04 $03 $08
	.db $fe $02 $06 $06


; Sword decelerates based on these values
_armosWarrior_sword_speedVals:
	.db SPEED_40, SPEED_80, SPEED_100, SPEED_140


; Parent chooses a speed from here based on how many hits the shield has taken
_armosWarrior_parent_speedVals:
	.db SPEED_180, SPEED_140, SPEED_100


; For each possible angle the sword can move in, this has Y and X boundaries where it
; should stop.
;   b0: Y-boundary. (If bit 0 is set, it's an upper boundary.)
;   b1: X-boundary. (If bit 0 is set, it's a left boundary.)
_armosWarrior_sword_angleBoundaries:
	.db $51 $fe ; Up
	.db $51 $98 ; Up-right
	.db $fe $98 ; Right
	.db $60 $98 ; Down-right
	.db $60 $fe ; Down
	.db $60 $51 ; Down-left
	.db $fe $51 ; Left
	.db $51 $51 ; Up-left

;;
; @addr{5167}
_armosWarrior_sword_playSlashSound:
	ld a,(wFrameCounter)		; $5167
	and $0f			; $516a
	ret nz			; $516c
	ld a,SND_SWORDSLASH		; $516d
	jp playSound		; $516f


; ==============================================================================
; ENEMYID_SMASHER
;
; Variables (ball, subid 0):
;   relatedObj1: parent
;   var30: Counter until the ball respawns
;
; Variables (parent, subid 1):
;   relatedObj1: ball
;   var30/var31: Target position (directly in front of ball object)
;   var32: Nonzero if already initialized
; ==============================================================================
enemyCode74:
	jr z,@normalStatus	; $5172
	sub ENEMYSTATUS_NO_HEALTH			; $5174
	ret c			; $5176
	jr z,@dead	; $5177
	dec a			; $5179
	jr z,@normalStatus	; $517a
	jp _ecom_updateKnockback		; $517c

@dead:
	ld e,Enemy.subid		; $517f
	ld a,(de)		; $5181
	or a			; $5182
	jr nz,@mainDead	; $5183

	; Ball dead
	call _smasher_ball_makeLinkDrop		; $5185
	call objectCreatePuff		; $5188
	jp enemyDelete		; $518b

@mainDead:
	ld e,Enemy.collisionType		; $518e
	ld a,(de)		; $5190
	or a			; $5191
	call nz,_ecom_killRelatedObj1		; $5192
	jp _enemyBoss_dead		; $5195

@normalStatus:
	call _smasher_ball_updateRespawnTimer		; $5198
	call _ecom_getSubidAndCpStateTo08		; $519b
	jr c,@commonState	; $519e
	ld a,b			; $51a0
	or a			; $51a1
	jp z,_smasher_ball		; $51a2
	jp _smasher_parent		; $51a5

@commonState:
	rst_jumpTable			; $51a8
	.dw _smasher_state_uninitialized
	.dw _smasher_state_stub
	.dw _smasher_state_grabbed
	.dw _smasher_state_stub
	.dw _smasher_state_stub
	.dw _smasher_state_stub
	.dw _smasher_state_stub
	.dw _smasher_state_stub


_smasher_state_uninitialized:
	ld a,b			; $51b9
	or a			; $51ba
	jr nz,@alreadySpawnedParent	; $51bb

@initializeBall:
	ld b,a			; $51bd
	ld a,$ff		; $51be
	call _enemyBoss_initializeRoom		; $51c0

	; Spawn parent
	ld b,ENEMYID_SMASHER		; $51c3
	call _ecom_spawnUncountedEnemyWithSubid01		; $51c5
	ret nz			; $51c8

	; [parent.enabled] = [ball.enabled]
	ld l,Enemy.enabled		; $51c9
	ld e,l			; $51cb
	ld a,(de)		; $51cc
	ld (hl),a		; $51cd

	; [ball.relatedObj1] = parent
	; [parent.relatedObj1] = ball
	ld l,Enemy.relatedObj1		; $51ce
	ld e,l			; $51d0
	ld a,Enemy.start		; $51d1
	ldi (hl),a		; $51d3
	ld (de),a		; $51d4
	inc e			; $51d5
	ld a,h			; $51d6
	ld (de),a		; $51d7
	ld (hl),d		; $51d8

	call objectCopyPosition		; $51d9

	; If parent object has a lower index than ball object, swap them
	ld a,h			; $51dc
	cp d			; $51dd
	jr nc,@initialize	; $51de

	ld l,Enemy.subid		; $51e0
	ld (hl),$80 ; Change former "parent" to "ball"
	ld e,l			; $51e4
	ld a,$01		; $51e5
	ld (de),a   ; Change former "ball" (this) to "parent"

@alreadySpawnedParent:
	dec a			; $51e8
	jr z,@gotoState8	; $51e9

	; Effectively clears bit 7 of parent's subid (should be $80 when it reaches here)
	ld e,Enemy.subid		; $51eb
	xor a			; $51ed
	ld (de),a		; $51ee

@initialize:
	ld a,$01		; $51ef
	call _smasher_setOamFlags		; $51f1

	ld l,Enemy.xh		; $51f4
	ld a,(hl)		; $51f6
	sub $20			; $51f7
	ld (hl),a		; $51f9

	ld a,$04		; $51fa
	call enemySetAnimation		; $51fc

@gotoState8:
	jp _ecom_setSpeedAndState8AndVisible		; $51ff


_smasher_state_grabbed:
	inc e			; $5202
	ld a,(de) ; [state2]
	rst_jumpTable			; $5204
	.dw @justGrabbed
	.dw @beingHeld
	.dw @released
	.dw @atRest

@justGrabbed:
	ld h,d			; $520d
	ld l,e			; $520e
	inc (hl)		; $520f
	ld a,2<<4		; $5210
	ld (wLinkGrabState2),a		; $5212
	jp objectSetVisiblec1		; $5215

@beingHeld:
	ret			; $5218

@released:
	call _ecom_bounceOffWallsAndHoles		; $5219
	jr z,++			; $521c

	; Hit a wall; copy new angle to the "throw item" that's controlling this
	ld e,Enemy.angle		; $521e
	ld a,(de)		; $5220
	ld hl,w1ReservedItemC.angle		; $5221
	ld (hl),a		; $5224
++
	; Return if parent was already hit
	ld a,Object.invincibilityCounter		; $5225
	call objectGetRelatedObject1Var		; $5227
	ld a,(hl)		; $522a
	or a			; $522b
	ret nz			; $522c

	; Check if we've collided with parent
	ld l,Enemy.zh		; $522d
	ld e,l			; $522f
	ld a,(de)		; $5230
	sub (hl)		; $5231
	add $08			; $5232
	cp $11			; $5234
	ret nc			; $5236
	call checkObjectsCollided		; $5237
	ret nc			; $523a

	; We've collided

	ld l,Enemy.invincibilityCounter		; $523b
	ld (hl),$20		; $523d
	ld l,Enemy.knockbackCounter		; $523f
	ld (hl),$10		; $5241

	ld l,Enemy.health		; $5243
	dec (hl)		; $5245

	; Calculate knockback angle for boss
	call _smasher_ball_loadPositions		; $5246
	push hl			; $5249
	call objectGetRelativeAngleWithTempVars		; $524a
	pop hl			; $524d
	ld l,Enemy.knockbackAngle		; $524e
	ld (hl),a		; $5250

	; Reverse knockback angle for ball
	xor $10			; $5251
	ld hl,w1ReservedItemC.angle		; $5253
	ld (hl),a		; $5256

	ld a,SND_BOSS_DAMAGE		; $5257
	jp playSound		; $5259

@atRest:
	dec e			; $525c
	ld a,$08		; $525d
	ld (de),a ; [state] = 8
	jp objectSetVisiblec2		; $5260


_smasher_state_stub:
	ret			; $5263


_smasher_ball:
	ld a,(de)		; $5264
	sub $08			; $5265
	rst_jumpTable			; $5267
	.dw _smasher_ball_state8
	.dw _smasher_ball_state9
	.dw _smasher_ball_stateA
	.dw _smasher_ball_stateB
	.dw _smasher_ball_stateC
	.dw _smasher_ball_stateD
	.dw _smasher_ball_stateE
	.dw _smasher_ball_stateF


; Initialization (or just reappeared after disappearing)
_smasher_ball_state8:
	ld h,d			; $5278
	ld l,e			; $5279
	inc (hl) ; [state]

	ld l,Enemy.enemyCollisionMode		; $527b
	ld (hl),ENEMYCOLLISION_SMASHER_BALL		; $527d
	ld l,Enemy.speed		; $527f
	ld (hl),SPEED_a0		; $5281


; Lying on ground, waiting for parent or Link to pick it up
_smasher_ball_state9:
	call objectAddToGrabbableObjectBuffer		; $5283
	jp objectPushLinkAwayOnCollision		; $5286


; Parent is picking up the ball
_smasher_ball_stateA:
	ld h,d			; $5289
	ld l,Enemy.zh		; $528a
	ldd a,(hl)		; $528c
	cp $f4			; $528d
	jr z,++			; $528f

	; [ball.z] -= $0080 (moving up)
	ld a,(hl)		; $5291
	sub <($0080)			; $5292
	ldi (hl),a		; $5294
	ld a,(hl)		; $5295
	sbc >($0080)			; $5296
	ld (hl),a		; $5298
++
	; Move toward parent on Y/X axis
	ld a,Object.yh		; $5299
	call objectGetRelatedObject1Var		; $529b
	call _smasher_ball_loadPositions		; $529e
	cp c			; $52a1
	jp nz,_ecom_moveTowardPosition		; $52a2
	ldh a,(<hFF8F)	; $52a5
	cp b			; $52a7
	jp nz,_ecom_moveTowardPosition		; $52a8

	; Reached parent's Y/X position; wait for Z as well
	ld e,Enemy.zh		; $52ab
	ld a,(de)		; $52ad
	cp $f4			; $52ae
	ret nz			; $52b0

	; Reached position; go to next state
	call _ecom_incState		; $52b1

	ld l,Enemy.collisionType		; $52b4
	set 7,(hl)		; $52b6

	ld l,Enemy.speed		; $52b8
	ld (hl),SPEED_300		; $52ba
	jp objectSetVisiblec1		; $52bc


; This state is a signal for the parent, which will update the ball's state when it gets
; released.
_smasher_ball_stateB:
	ret			; $52bf


; Being thrown
_smasher_ball_stateC:
	ld c,$20		; $52c0
	call objectUpdateSpeedZAndBounce		; $52c2
	jr c,@doneBouncing	; $52c5
	jr nz,++		; $52c7

	; Hit ground
	ld e,Enemy.speed		; $52c9
	ld a,(de)		; $52cb
	srl a			; $52cc
	ld (de),a		; $52ce
	call _smasher_ball_playLandSound		; $52cf
++
	call _ecom_bounceOffWallsAndHoles		; $52d2
	jp objectApplySpeed		; $52d5

@doneBouncing:
	ld h,d			; $52d8
	ld l,Enemy.state		; $52d9
	ld (hl),$08		; $52db

	ld l,Enemy.collisionType		; $52dd
	res 7,(hl)		; $52df
	call objectSetVisiblec2		; $52e1

_smasher_ball_playLandSound:
	ld a,SND_BOMB_LAND		; $52e4
	jp playSound		; $52e6


; Disappearing (either after being thrown, or after a time limit)
_smasher_ball_stateD:
	call objectCreatePuff		; $52e9
	ret nz			; $52ec

	; If parent is picking up or throwing the ball, cancel that
	ld a,Object.state		; $52ed
	call objectGetRelatedObject1Var		; $52ef
	ld a,(hl)		; $52f2
	cp $0b			; $52f3
	jr c,++			; $52f5
	ld (hl),$0d ; [parent.state]
	ld l,Enemy.oamFlagsBackup		; $52f9
	ld a,$03		; $52fb
	ldi (hl),a		; $52fd
	ld (hl),a		; $52fe
++
	call _ecom_incState		; $52ff

	ld l,Enemy.collisionType		; $5302
	res 7,(hl)		; $5304

	ld l,Enemy.counter1		; $5306
	ld (hl),60		; $5308
	jp objectSetInvisible		; $530a


; Ball is gone, will reappear after [counter1] frames
_smasher_ball_stateE:
	call _ecom_decCounter1		; $530d
	ret nz			; $5310

	ld l,e			; $5311
	inc (hl) ; [state]

	ld l,Enemy.zh		; $5313
	ld (hl),-$20		; $5315

	ld l,Enemy.speedZ		; $5317
	xor a			; $5319
	ldi (hl),a		; $531a
	ld (hl),a		; $531b

	; Choose random position to spawn at
	call getRandomNumber_noPreserveVars		; $531c
	and $0e			; $531f
	ld hl,@spawnPositions		; $5321
	rst_addAToHl			; $5324
	ld e,Enemy.yh		; $5325
	ldi a,(hl)		; $5327
	ld (de),a		; $5328
	ld e,Enemy.xh		; $5329
	ld a,(hl)		; $532b
	ld (de),a		; $532c

	call objectCreatePuff		; $532d
	jp objectSetVisiblec1		; $5330

@spawnPositions:
	.db $38 $38
	.db $78 $38
	.db $38 $78
	.db $78 $78
	.db $38 $b8
	.db $78 $b8
	.db $58 $58
	.db $58 $98


; Ball is falling to ground after reappearing
_smasher_ball_stateF:
	ld c,$20		; $5343
	call objectUpdateSpeedZAndBounce		; $5345
	jr c,@doneBouncing	; $5348
	ret nz			; $534a
	jp _smasher_ball_playLandSound		; $534b

@doneBouncing:
	ld e,Enemy.state		; $534e
	ld a,$08		; $5350
	ld (de),a		; $5352
	jp objectSetVisiblec2		; $5353


_smasher_parent:
	ld a,(de)		; $5356
	sub $08			; $5357
	rst_jumpTable			; $5359
	.dw _smasher_parent_state8
	.dw _smasher_parent_state9
	.dw _smasher_parent_stateA
	.dw _smasher_parent_stateB
	.dw _smasher_parent_stateC
	.dw _smasher_parent_stateD


; Initialization
_smasher_parent_state8:
	ld h,d			; $5366
	ld l,e			; $5367
	inc (hl) ; [state]

	ld l,Enemy.counter1		; $5369
	ld (hl),$01		; $536b

	ld l,Enemy.speed		; $536d
	ld (hl),SPEED_c0		; $536f

	; Don't do below function call if already initialized
	ld l,Enemy.var32		; $5371
	bit 0,(hl)		; $5373
	jr nz,_smasher_parent_state9	; $5375

	inc (hl) ; [var32]
	call _enemyBoss_beginMiniboss		; $5378


_smasher_parent_state9:
	ld a,Object.state		; $537b
	call objectGetRelatedObject1Var		; $537d
	ld a,(hl)		; $5380
	cp $09			; $5381
	jr z,@moveTowardBall	; $5383

	; Ball unavailable; moving aronund in random angles

	call _ecom_decCounter1		; $5385
	jr nz,@updateMovement	; $5388

	; Time to choose a new angle
	ld (hl),60 ; [counter1]

	call getRandomNumber_noPreserveVars		; $538c
	and $03			; $538f
	ld hl,@randomAngles		; $5391
	rst_addAToHl			; $5394
	ld e,Enemy.angle		; $5395
	ld a,(hl)		; $5397
	ld (de),a		; $5398
	call _smasher_updateDirectionFromAngle		; $5399

@updateMovement:
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $539c
	ld c,$20		; $539f
	call objectUpdateSpeedZ_paramC		; $53a1
	jr nz,@updateAnim	; $53a4

	call _smasher_hop		; $53a6
	ld e,Enemy.direction		; $53a9
	ld a,(de)		; $53ab
	inc a			; $53ac
	jp enemySetAnimation		; $53ad

@updateAnim:
	; Change animation when he reaches the peak of his hop (speedZ is zero)
	ldd a,(hl)		; $53b0
	or (hl)			; $53b1
	ret nz			; $53b2
	ld e,Enemy.direction		; $53b3
	ld a,(de)		; $53b5
	jp enemySetAnimation		; $53b6

@moveTowardBall:
	; Copy ball's Y-position to var30 (Y-position to move to)
	ld l,Enemy.yh		; $53b9
	ld e,Enemy.var30		; $53bb
	ldi a,(hl)		; $53bd
	ld (de),a		; $53be

	; Calculate X-position to move to ($0e pixels to one side of the ball), then store
	; the value in var31
	inc l			; $53bf
	ld e,l			; $53c0
	ld a,(de) ; [parent.xh]
	cp (hl)   ; [ball.xh]
	ld a,$0e		; $53c3
	jr nc,+			; $53c5
	ld a,-$0e		; $53c7
+
	ld c,a			; $53c9

	add (hl) ; [ball.xh]
	ld b,a			; $53cb
	sub $18			; $53cc
	cp $c0			; $53ce
	jr c,++			; $53d0
	ld a,c			; $53d2
	cpl			; $53d3
	inc a			; $53d4
	add a			; $53d5
	add b			; $53d6
	ld b,a			; $53d7
++
	ld h,d			; $53d8
	ld l,Enemy.var31		; $53d9
	ld (hl),b		; $53db

	; Goto next state to move toward the ball
	ld l,Enemy.state		; $53dc
	inc (hl)		; $53de

	ld l,Enemy.speed		; $53df
	ld (hl),SPEED_100		; $53e1

	ld l,Enemy.var30		; $53e3
	call _ecom_readPositionVars		; $53e5
	call _smasher_updateAngleTowardPosition		; $53e8
	jp enemySetAnimation		; $53eb


@randomAngles: ; When ball is unavailable, smasher move randomly in one of these angles
	.db $06 $0a $16 $1a


; Moving toward ball on the ground
_smasher_parent_stateA:
	ld a,Object.state		; $53f2
	call objectGetRelatedObject1Var		; $53f4
	ld a,(hl)		; $53f7
	cp $09			; $53f8
	jr nz,_smasher_parent_linkPickedUpBall	; $53fa

	; Check if we've reached the target position in front of the ball
	ld h,d			; $53fc
	ld l,Enemy.var30		; $53fd
	call _ecom_readPositionVars		; $53ff
	sub c			; $5402
	add $02			; $5403
	cp $05			; $5405
	jr nc,@movingTowardBall	; $5407
	ldh a,(<hFF8F)	; $5409
	sub b			; $540b
	add $02			; $540c
	cp $05			; $540e
	jr nc,@movingTowardBall	; $5410

	; We've reached the position

	ld l,Enemy.state		; $5412
	inc (hl) ; [parent.state]

	ld l,Enemy.zh		; $5415
	ld (hl),$00		; $5417

	ld a,$02		; $5419
	call _smasher_setOamFlags		; $541b

	ld a,Object.state		; $541e
	call objectGetRelatedObject1Var		; $5420
	inc (hl) ; [ball.state] = $0a

	; Face toward the ball? ('b' is still set to the y-position from before?)
	ld l,Enemy.xh		; $5424
	ld c,(hl)		; $5426
	call _smasher_updateAngleTowardPosition		; $5427
	inc a			; $542a
	jp enemySetAnimation		; $542b

@movingTowardBall:
	call _ecom_moveTowardPosition		; $542e

	ld e,Enemy.angle		; $5431
	ld a,(de)		; $5433
	call _smasher_updateDirectionFromAngle		; $5434
	call enemySetAnimation		; $5437

	ld c,$20		; $543a
	call objectUpdateSpeedZ_paramC		; $543c
	ret nz			; $543f
	jr _smasher_hop		; $5440


_smasher_parent_linkPickedUpBall:
	; Stop chasing the ball
	ld h,d			; $5442
	ld l,Enemy.state		; $5443
	ld (hl),$09		; $5445

	ld l,Enemy.speed		; $5447
	ld (hl),SPEED_c0		; $5449

	ld l,Enemy.counter1		; $544b
	ld (hl),60		; $544d

	ld a,$03		; $544f
	call _smasher_setOamFlags		; $5451

	; Run away from Link
	call _ecom_updateCardinalAngleAwayFromTarget		; $5454
	jp _smasher_updateDirectionFromAngle		; $5457


; About to pick up ball
_smasher_parent_stateB:
	ld a,Object.state		; $545a
	call objectGetRelatedObject1Var		; $545c
	ld a,(hl)		; $545f
	cp ENEMYSTATE_GRABBED			; $5460
	jr z,_smasher_parent_linkPickedUpBall	; $5462

	; Wait for ball's state to update
	cp $0b			; $5464
	ret c			; $5466

	ld a,$03		; $5467
	call _smasher_setOamFlags		; $5469

	ld l,Enemy.state		; $546c
	inc (hl)		; $546e

	ld l,Enemy.counter2		; $546f
	ld (hl),30		; $5471

	ld l,Enemy.speed		; $5473
	ld (hl),SPEED_40		; $5475

;;
; @addr{5477}
_smasher_hop:
	ld l,Enemy.speedZ		; $5477
	ld a,<(-$c0)		; $5479
	ldi (hl),a		; $547b
	ld (hl),>(-$c0)		; $547c
	ret			; $547e


; Just picked up ball; hopping while moving slowly toward Link
_smasher_parent_stateC:
	call _smasher_updateAngleTowardLink		; $547f
	inc a			; $5482
	call enemySetAnimation		; $5483

	call _ecom_decCounter2		; $5486

	ld c,$20		; $5489
	call objectUpdateSpeedZ_paramC		; $548b
	jr z,@hitGround	; $548e

	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $5490

	; Update ball's position
	ld a,Object.enabled		; $5493
	call objectGetRelatedObject1Var		; $5495
	call objectCopyPosition		; $5498
	dec l			; $549b
	ld e,l			; $549c
	ld a,(de) ; [parent.zh]
	add $f4			; $549e
	ld (hl),a ; [ball.zh]
	ret			; $54a1

@hitGround:
	ld e,Enemy.counter2		; $54a2
	ld a,(de)		; $54a4
	or a			; $54a5
	jp nz,_smasher_hop		; $54a6

	; Done hopping; go to next state to leap into the air

	ld a,>(-$1e0)		; $54a9
	ldd (hl),a		; $54ab
	ld (hl),<(-$1e0)		; $54ac

	ld l,Enemy.state		; $54ae
	inc (hl)		; $54b0

	ld a,$02		; $54b1
	jp _smasher_setOamFlags		; $54b3


; In midair just before throwing ball
_smasher_parent_stateD:
	ld c,$20		; $54b6
	call objectUpdateSpeedZ_paramC		; $54b8
	jr nz,@inMidair	; $54bb

	; Hit the ground
	ld l,Enemy.state		; $54bd
	ld (hl),$08		; $54bf
	ret			; $54c1

@inMidair:
	ld a,Object.zh		; $54c2
	call objectGetRelatedObject1Var		; $54c4
	ld e,l			; $54c7
	ld a,(de)		; $54c8
	add $f4			; $54c9
	ld (hl),a		; $54cb

	ld e,Enemy.speedZ+1		; $54cc
	ld a,(de)		; $54ce
	rlca			; $54cf
	jr nc,@movingDown		; $54d0

	; Moving up
	call _smasher_updateAngleTowardLink		; $54d2
	inc a			; $54d5
	jp enemySetAnimation		; $54d6

@movingDown:
	; Return if speedZ is nonzero (not at peak of jump)
	ld b,a			; $54d9
	dec e			; $54da
	ld a,(de)		; $54db
	or b			; $54dc
	ret nz			; $54dd

	; Throw the ball if its state is valid for this
	ld a,Object.state		; $54de
	call objectGetRelatedObject1Var		; $54e0
	ld a,(hl)		; $54e3
	cp $0b			; $54e4
	ret nz			; $54e6

	inc (hl) ; [ball.state]
	ld l,Enemy.angle		; $54e8
	ld e,l			; $54ea
	ld a,(de)		; $54eb
	ld (hl),a		; $54ec

	ld a,$03		; $54ed
	call _smasher_setOamFlags		; $54ef

	ld e,Enemy.direction		; $54f2
	ld a,(de)		; $54f4
	jp enemySetAnimation		; $54f5


;;
; @param[out]	a	direction value
; @addr{54f8}
_smasher_updateAngleTowardPosition:
	call objectGetRelativeAngleWithTempVars		; $54f8
	ld e,Enemy.angle		; $54fb
	ld (de),a		; $54fd
	jr _smasher_updateDirectionFromAngle			; $54fe

;;
; @addr{5500}
_smasher_updateAngleTowardLink:
	call objectGetAngleTowardEnemyTarget		; $5500
	ld e,Enemy.angle		; $5503
	ld (de),a		; $5505

;;
; @param	a	angle
; @param[out]	a	direction value
; @addr{5506}
_smasher_updateDirectionFromAngle:
	ld b,a			; $5506
	and $0f			; $5507
	ret z			; $5509
	ld a,b			; $550a
	and $10			; $550b
	xor $10			; $550d
	swap a			; $550f
	rlca			; $5511
	ld e,Enemy.direction		; $5512
	ld (de),a		; $5514
	ret			; $5515


;;
; @param	a	Value for oamFlags
; @addr{5516}
_smasher_setOamFlags:
	ld h,d			; $5516
	ld l,Enemy.oamFlagsBackup		; $5517
	ldi (hl),a		; $5519
	ld (hl),a		; $551a
	ret			; $551b

;;
; Loads positions into bc and hFF8E/hFF8F for subsequent call to
; "objectGetRelativeAngleWithTempVars".
;
; @param	h	Parent object
; @addr{551c}
_smasher_ball_loadPositions:
	ld l,Enemy.yh		; $551c
	ld e,l			; $551e
	ld a,(de)		; $551f
	ldh (<hFF8F),a	; $5520
	ld b,(hl)		; $5522
	ld l,Enemy.xh		; $5523
	ld e,l			; $5525
	ld a,(de)		; $5526
	ldh (<hFF8E),a	; $5527
	ld c,(hl)		; $5529
	ret			; $552a


;;
; Updates the ball's "respawn timer" and makes it disappear (goes to state $0d) when it
; hits zero.
; @addr{552b}
_smasher_ball_updateRespawnTimer:
	; Return if this isn't the ball
	ld e,Enemy.subid		; $552b
	ld a,(de)		; $552d
	or a			; $552e
	ret nz			; $552f

	ld e,Enemy.state		; $5530
	ld a,(de)		; $5532
	cp $0d			; $5533
	ret nc			; $5535
	ld a,(wFrameCounter)		; $5536
	rrca			; $5539
	ret c			; $553a

	ld h,d			; $553b
	ld l,Enemy.var30		; $553c
	inc (hl)		; $553e
	ld a,(hl)		; $553f
	cp 180			; $5540
	ret c			; $5542

	ld (hl),$00		; $5543
	call _smasher_ball_makeLinkDrop		; $5545
	ld e,Enemy.state		; $5548
	ld a,$0d		; $554a
	ld (de),a		; $554c
	ret			; $554d


;;
; @addr{554e}
_smasher_ball_makeLinkDrop:
	ld e,Enemy.state		; $554e
	ld a,(de)		; $5550
	cp $02			; $5551
	ret nz			; $5553
	inc e			; $5554
	ld a,(de)		; $5555
	cp $02			; $5556
	ret nc			; $5558
	jp dropLinkHeldItem		; $5559


; ==============================================================================
; ENEMYID_VIRE
;
; Variables (for main form, subid 0):
;   relatedObj2: INTERACID_PUFF?
;   var30: Rotation angle?
;   var32: Used for animations?
;   var33: Health?
;   var34: Number of "bat children" alive. Will die when this reaches 0.
;   var37: Marks whether text has been shown as health goes down
;   var38: If nonzero, he won't spawn a fairy when defeated?
;
; Variables (for bat form, subid 1):
;   relatedObj1: Reference to main form (subid 0)
;   var30: Rotation angle?
;   var35/var36: Target position?
; ==============================================================================
enemyCode75:
	jr z,@normalStatus	; $555c
	sub ENEMYSTATUS_NO_HEALTH			; $555e
	ret c			; $5560
	jr z,@dead	; $5561

	; ENEMYSTATUS_JUST_HIT
	ld e,Enemy.subid		; $5563
	ld a,(de)		; $5565
	or a			; $5566
	ld e,Enemy.health		; $5567
	ld a,(de)		; $5569
	jr z,++			; $556a
	or a			; $556c
	ret z			; $556d
	jr @normalStatus		; $556e
++
	ld h,d			; $5570
	ld l,Enemy.var33		; $5571
	cp (hl)			; $5573
	jr z,@normalStatus	; $5574

	ld (hl),a		; $5576
	or a			; $5577
	ret z			; $5578

	ld l,Enemy.state		; $5579
	ld (hl),$0e		; $557b
	inc l			; $557d
	ld (hl),$00		; $557e
	ret			; $5580

@dead:
	ld e,Enemy.subid		; $5581
	ld a,(de)		; $5583
	or a			; $5584
	jr z,@subid0Dead	; $5585

	; Subid 1 (bat child) death
	call objectCreatePuff		; $5587
	ld a,Object.var34		; $558a
	call objectGetRelatedObject1Var		; $558c
	dec (hl)		; $558f
	call z,objectCopyPosition		; $5590
	jp enemyDelete		; $5593

@subid0Dead:
	ld h,d			; $5596
	ld l,Enemy.state		; $5597
	ld a,(hl)		; $5599
	cp $0f			; $559a
	jp z,_enemyBoss_dead		; $559c

	ld (hl),$0f ; [state]
	inc l			; $55a1
	ld (hl),$00 ; [state2]
	inc l			; $55a4
	ld (hl),20 ; [counter1]

	ld l,Enemy.health		; $55a7
	ld (hl),$01		; $55a9

	ld l,Enemy.direction		; $55ab
	xor a			; $55ad
	ld (hl),a		; $55ae
	call enemySetAnimation		; $55af

@normalStatus:
	call _ecom_getSubidAndCpStateTo08		; $55b2
	jr c,@commonState	; $55b5

	ld a,b			; $55b7
	or a			; $55b8
	jp z,_vire_mainForm		; $55b9
	jp _vire_batForm		; $55bc

@commonState:
	ld e,Enemy.state		; $55bf
	ld a,(de)		; $55c1
	rst_jumpTable			; $55c2
	.dw _vire_state_uninitialized
	.dw _vire_state_stub
	.dw _vire_state_stub
	.dw _vire_state_stub
	.dw _vire_state_stub
	.dw _vire_state_stub
	.dw _vire_state_stub
	.dw _vire_state_stub


_vire_state_uninitialized:
	ld a,SPEED_c0		; $55d3
	call _ecom_setSpeedAndState8		; $55d5

	ld a,b			; $55d8
	or a			; $55d9
	ret nz			; $55da

	; "Main" vire only (not bat form)
	ld l,Enemy.zh		; $55db
	ld (hl),$fc		; $55dd

	dec a ; a = $ff
	ld b,$00		; $55e0
	jp _enemyBoss_initializeRoom		; $55e2


_vire_state_stub:
	ret			; $55e5


_vire_mainForm:
	ld e,Enemy.direction		; $55e6
	ld a,(de)		; $55e8
	or a			; $55e9
	jr z,@runState	; $55ea

	ld h,d			; $55ec
	ld l,Enemy.var32		; $55ed
	inc (hl)		; $55ef
	ld a,(hl)		; $55f0
	cp $18			; $55f1
	jr c,@runState	; $55f3

	xor a			; $55f5
	ld (hl),a ; [var32] = 0

	ld l,e			; $55f7
	ld (hl),a ; [direction] = 0
	call enemySetAnimation		; $55f9

@runState:
	ld e,Enemy.state		; $55fc
	ld a,(de)		; $55fe
	sub $08			; $55ff
	rst_jumpTable			; $5601
	.dw _vire_mainForm_state8
	.dw _vire_mainForm_state9
	.dw _vire_mainForm_stateA
	.dw _vire_mainForm_stateB
	.dw _vire_mainForm_stateC
	.dw _vire_mainForm_stateD
	.dw _vire_mainForm_stateE
	.dw _vire_mainForm_stateF


; Mini-cutscene before starting fight
_vire_mainForm_state8:
	inc e			; $5612
	ld a,(de) ; [state2]
	rst_jumpTable			; $5614
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate0:
	; Wait for Link to approach
	ldh a,(<hEnemyTargetY)	; $561d
	sub $38			; $561f
	cp $41			; $5621
	ret nc			; $5623
	ldh a,(<hEnemyTargetX)	; $5624
	sub $50			; $5626
	cp $51			; $5628
	ret nc			; $562a

	; Can't be dead...
	ld a,(wLinkDeathTrigger)		; $562b
	or a			; $562e
	ret nz			; $562f

	ldbc INTERACID_PUFF, $02		; $5630
	call objectCreateInteraction		; $5633
	ret nz			; $5636

	; [relatedObj2] = INTERACID_PUFF
	ld e,Enemy.relatedObj2+1		; $5637
	ld a,h			; $5639
	ld (de),a		; $563a
	dec e			; $563b
	ld a,Interaction.start		; $563c
	ld (de),a		; $563e

	ld e,Enemy.state2		; $563f
	ld a,$01		; $5641
	ld (de),a		; $5643
	ld (wDisabledObjects),a ; DISABLE_LINK
	ld (wDisableLinkCollisionsAndMenu),a		; $5647
	ret			; $564a

@substate1:
	; Wait for puff to disappear
	ld a,Object.animParameter		; $564b
	call objectGetRelatedObject2Var		; $564d
	bit 7,(hl)		; $5650
	ret z			; $5652

	ld h,d			; $5653
	ld l,Enemy.state2		; $5654
	inc (hl)		; $5656
	inc l			; $5657
	ld (hl),$08 ; [counter1]
	jp objectSetVisiblec1		; $565a

@substate2:
	; Show text in 8 frames
	call _ecom_decCounter1		; $565d
	jp nz,enemyAnimate		; $5660

	ld l,e			; $5663
	inc (hl) ; [state2]
	ld bc,TX_2f12		; $5665
	call checkIsLinkedGame		; $5668
	jr z,+			; $566b
	inc c ; TX_2f13
+
	jp showText		; $566e

@substate3:
	; Disappear
	call objectCreatePuff		; $5671
	ret nz			; $5674

	; a == 0
	ld (wDisabledObjects),a		; $5675
	ld (wDisableLinkCollisionsAndMenu),a		; $5678

	call _ecom_incState		; $567b
	inc l			; $567e
	ldi (hl),a ; [state2] = 0
	ld (hl),90 ; [counter1]

	ld l,Enemy.health		; $5682
	ld a,(hl)		; $5684
	ld l,Enemy.var33		; $5685
	ld (hl),a		; $5687

	call objectSetInvisible		; $5688
	ld a,MUS_MINIBOSS		; $568b
	ld (wActiveMusic),a		; $568d
	jp playSound		; $5690


; Off-screen for [counter1] frames
_vire_mainForm_state9:
	call _ecom_decCounter1		; $5693
	ret nz			; $5696

	; Decide what to do next (health affects probability)
	ld e,Enemy.health		; $5697
	ld a,(de)		; $5699
	ld c,$08		; $569a
	cp $0a			; $569c
	jr c,++			; $569e
	ld c,$04		; $56a0
	cp $10			; $56a2
	jr c,++		; $56a4
	ld c,$00		; $56a6
++
	call getRandomNumber		; $56a8
	and $07			; $56ab
	add c			; $56ad
	ld hl,@behaviourTable		; $56ae
	rst_addAToHl			; $56b1

	ld a,(hl)		; $56b2
	ld e,Enemy.state		; $56b3
	ld (de),a		; $56b5
	ret			; $56b6

; Vire chooses from 8 of these values, starting from index 0, 4, or 8 depending on health
; (starts from 0 when health is high).
@behaviourTable:
	.db $0a $0a $0b $0d $0a $0a $0a $0a
	.db $0b $0b $0c $0d $0a $0b $0c $0d


; Charges across screen
_vire_mainForm_stateA:
	inc e			; $56c7
	ld a,(de)		; $56c8
	rst_jumpTable			; $56c9
	.dw @substate0
	.dw @substate1
	.dw @substate2

@substate0:
	call _vire_spawnOutsideCamera		; $56d0
	inc l			; $56d3
	ld (hl),20 ; [counter1]
	ld l,Enemy.speed		; $56d6
	ld (hl),SPEED_100		; $56d8
	ret			; $56da

; Moving slowly before charging
@substate1:
	call _ecom_decCounter1		; $56db
	jp nz,_vire_mainForm_applySpeedAndAnimate		; $56de

	; Begin charging
	ld l,e			; $56e1
	inc (hl) ; [state2]

	ld l,Enemy.speed		; $56e3
	ld (hl),SPEED_200		; $56e5
	call _ecom_updateAngleTowardTarget		; $56e7
	call getRandomNumber_noPreserveVars		; $56ea
	and $03			; $56ed
	sub $02			; $56ef
	ld b,a			; $56f1
	ld e,Enemy.angle		; $56f2
	ld a,(de)		; $56f4
	add b			; $56f5
	and $1f			; $56f6
	ld (de),a		; $56f8

; Charging across screen
@substate2:
	call _vire_checkOffScreen		; $56f9
	jp nc,_vire_mainForm_leftScreen		; $56fc
	call _ecom_decCounter1		; $56ff
	ld a,(hl)		; $5702
	and $1f			; $5703
	call z,_vire_mainForm_fireProjectile		; $5705
	jp _vire_mainForm_applySpeedAndAnimate		; $5708


; Circling Link, runs away if Link gets too close (similar to state D)
_vire_mainForm_stateB:
	inc e			; $570b
	ld a,(de)		; $570c
	rst_jumpTable			; $570d
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate0: ; Also subid 0 for state D
	call _vire_spawnOutsideCamera		; $5716
	inc l			; $5719
	ld (hl),120 ; [counter1]
	call getRandomNumber_noPreserveVars		; $571c
	and $08			; $571f
	jr nz,+			; $5721
	ld a,$f8		; $5723
+
	ld e,Enemy.var30		; $5725
	ld (de),a		; $5727
	ret			; $5728

@substate1:
	ld a,(wFrameCounter)		; $5729
	and $03			; $572c
	jr nz,++		; $572e

	call _ecom_decCounter1		; $5730
	jr z,@beginCharge	; $5733

	ld a,(hl)		; $5735
	and $1f			; $5736
	ld b,$01		; $5738
	call z,_vire_mainForm_fireProjectileWithSubid		; $573a
++
	call _vire_mainForm_checkLinkTooClose		; $573d
	jp nc,_vire_mainForm_circleAroundScreen		; $5740

; Begin charging; initially toward Link, but will run away if he gets too close or Link
; attacks
@beginCharge:
	ld l,Enemy.state2		; $5743
	inc (hl)		; $5745
	ld l,Enemy.speed		; $5746
	ld (hl),SPEED_200		; $5748
	call _ecom_updateAngleTowardTarget		; $574a
	jr @animate		; $574d

; Charging toward Link
@substate2:
	call _vire_mainForm_checkLinkTooClose		; $574f
	jr c,@updateAngleAway			; $5752
	ld a,(wLinkUsingItem1)		; $5754
	or a			; $5757
	jr nz,@updateAngleAway		; $5758
	call _vire_checkOffScreen		; $575a
	jp nc,_vire_mainForm_leftScreen		; $575d
	jp _vire_mainForm_applySpeedAndAnimate		; $5760

; Charging away from Link
@updateAngleAway:
	ld l,e			; $5763
	inc (hl) ; [state2]
	call _ecom_updateCardinalAngleAwayFromTarget		; $5765
@animate:
	jp enemyAnimate		; $5768

@substate3:
	call _vire_checkOffScreen		; $576b
	jp nc,_vire_mainForm_leftScreen		; $576e

	call _ecom_decCounter1		; $5771
	ld a,(hl)		; $5774
	and $1f			; $5775
	ld b,$01		; $5777
	call z,_vire_mainForm_fireProjectileWithSubid		; $5779
	jp _vire_mainForm_applySpeedAndAnimate		; $577c


; Vire creeps in from the screen edge to fire one projectile, then runs away
_vire_mainForm_stateC:
	inc e			; $577f
	ld a,(de)		; $5780
	rst_jumpTable			; $5781
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate0:
	call _vire_spawnOutsideCamera		; $578a
	inc l			; $578d
	ld (hl),28 ; [counter1]
	ld l,Enemy.speed		; $5790
	ld (hl),SPEED_100		; $5792
	ret			; $5794

@substate1:
	call _ecom_decCounter1		; $5795
	jp nz,_vire_mainForm_applySpeedAndAnimate		; $5798

	ld (hl),12 ; [counter1]
	ld l,e			; $579d
	inc (hl) ; [state2]

	ld b,$03		; $579f
	call _vire_mainForm_fireProjectileWithSubid		; $57a1
	jr @animate		; $57a4

@substate2:
	call _ecom_decCounter1		; $57a6
	jr nz,@animate	; $57a9

	ld l,e			; $57ab
	inc (hl) ; [state2]

	ld l,Enemy.angle		; $57ad
	ld a,(hl)		; $57af
	xor $10			; $57b0
	ld (hl),a		; $57b2
	ld l,Enemy.speed		; $57b3
	ld (hl),SPEED_200		; $57b5

@animate:
	jp enemyAnimate		; $57b7

@substate3:
	call _vire_checkOffScreen		; $57ba
	jp nc,_vire_mainForm_leftScreen		; $57bd
	jp _vire_mainForm_applySpeedAndAnimate		; $57c0


; Circling Link, runs away if Link attempts to attack (similar to state B)
_vire_mainForm_stateD:
	inc e			; $57c3
	ld a,(de)		; $57c4
	rst_jumpTable			; $57c5
	.dw _vire_mainForm_stateB@substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4
	.dw _vire_state_moveOffScreen

@substate1:
	ld a,(wFrameCounter)		; $57d2
	and $03			; $57d5
	jr nz,++		; $57d7

	call _ecom_decCounter1		; $57d9
	jr z,@beginCharge	; $57dc

	ld a,(hl)		; $57de
	and $1f			; $57df
	ld b,$01		; $57e1
	call z,_vire_mainForm_fireProjectileWithSubid		; $57e3
++
	call _vire_mainForm_checkLinkTooClose		; $57e6
	jp nc,_vire_mainForm_circleAroundScreen		; $57e9

; Begin charging; initially toward Link, but will run away if he gets too close or Link
; attacks
@beginCharge:
	ld l,Enemy.state2		; $57ec
	inc (hl)		; $57ee
	ld l,Enemy.speed		; $57ef
	ld (hl),SPEED_200		; $57f1
	call _ecom_updateAngleTowardTarget		; $57f3
@animate:
	jp enemyAnimate		; $57f6

; Charging toward Link
@substate2:
	ld a,(wLinkUsingItem1)		; $57f9
	or a			; $57fc
	jr z,@moveOffScreen	; $57fd

	ld h,d			; $57ff
	ld l,e			; $5800
	inc (hl) ; [state2]
	inc l			; $5802
	ld (hl),12 ; [counter1]
	ld l,Enemy.speed		; $5805
	ld (hl),SPEED_300		; $5807
	call _ecom_updateCardinalAngleAwayFromTarget		; $5809
	jr @animate		; $580c

@moveOffScreen:
	call _vire_checkOffScreen		; $580e
	jp nc,_vire_mainForm_leftScreen		; $5811
	jp _vire_mainForm_applySpeedAndAnimate		; $5814

@substate3:
	call _ecom_decCounter1		; $5817
	jp nz,_vire_mainForm_applySpeedAndAnimate		; $581a

	ld (hl),12 ; [counter1]
	ld l,e			; $581f
	inc (hl) ; [state2]

	ld b,PARTID_VIRE_PROJECTILE		; $5821
	call _ecom_spawnProjectile		; $5823

	ld a,SND_SPLASH		; $5826
	call playSound		; $5828
	jr @animate		; $582b

@substate4:
	call _ecom_decCounter1		; $582d
	jr nz,@animate	; $5830

	ld l,e			; $5832
	inc (hl) ; [state2]

	ld l,Enemy.speed		; $5834
	ld (hl),SPEED_1c0		; $5836

	call _ecom_updateCardinalAngleAwayFromTarget		; $5838
	jr @animate		; $583b


_vire_state_moveOffScreen: ; Used by states D and E
	call _vire_checkOffScreen		; $583d
	jp nc,_vire_mainForm_leftScreen		; $5840
	jp _vire_mainForm_applySpeedAndAnimate		; $5843


; Just took damage
_vire_mainForm_stateE:
	inc e			; $5846
	ld a,(de)		; $5847
	rst_jumpTable			; $5848
	.dw @substate0
	.dw @substate1
	.dw _vire_state_moveOffScreen

@substate0:
	ld h,d			; $584f
	ld l,e			; $5850
	inc (hl) ; [state2]

	inc l			; $5852
	ld (hl),20 ; [counter1]

	ld l,Enemy.speed		; $5855
	ld (hl),SPEED_300		; $5857
	call _ecom_updateCardinalAngleAwayFromTarget		; $5859

	ld e,Enemy.direction		; $585c
	xor a			; $585e
	ld (de),a		; $585f

	ld e,Enemy.var32		; $5860
	ld (de),a		; $5862
	jp enemySetAnimation		; $5863

@substate1:
	call _ecom_decCounter1		; $5866
	jp nz,enemyAnimate		; $5869

	ld l,e			; $586c
	inc (hl) ; [state2]

	; Check whether to show text based on current health
	ld l,Enemy.health		; $586e
	ld a,(hl)		; $5870
	cp $10			; $5871
	ret nc			; $5873

	ld b,$01		; $5874
	cp $0a			; $5876
	jr nc,+			; $5878
	inc b			; $587a
+
	ld a,b			; $587b
	ld l,Enemy.var37		; $587c
	cp (hl)			; $587e
	ret z			; $587f

	ld (hl),a		; $5880
	add <TX_2f13			; $5881
	ld c,a			; $5883
	ld b,>TX_2f00		; $5884
	jp showText		; $5886


; "Main form" died, about to split into bats
_vire_mainForm_stateF:
	inc e			; $5889
	ld a,(de)		; $588a
	rst_jumpTable			; $588b
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4
	.dw @substate5

@substate0:
	call _ecom_decCounter1		; $5898
	ret nz			; $589b
	ld l,e			; $589c
	inc (hl) ; [counter1]
	ld bc,TX_2f16		; $589e
	jp showText		; $58a1

@substate1:
	ld b,$02		; $58a4
	call checkBEnemySlotsAvailable		; $58a6
	jp nz,enemyAnimate		; $58a9

	ld h,d			; $58ac
	ld l,Enemy.state2		; $58ad
	inc (hl)		; $58af

	ld l,Enemy.var34		; $58b0
	ld (hl),$02		; $58b2

	call objectSetInvisible		; $58b4
	call objectCreatePuff		; $58b7

	; Spawn bats
	ld b,ENEMYID_VIRE		; $58ba
	call _ecom_spawnUncountedEnemyWithSubid01		; $58bc
	call @initBat		; $58bf

	call _ecom_spawnUncountedEnemyWithSubid01		; $58c2
	inc a			; $58c5

@initBat:
	inc l			; $58c6
	ld (hl),a ; [var03] = a (0 or 1)
	rrca			; $58c8
	swap a			; $58c9
	jr nz,+			; $58cb
	ld a,$f8		; $58cd
+
	ld l,Enemy.var30 ; Bat's x-offset relative to vire
	ld (hl),a		; $58d1

	ld l,Enemy.relatedObj1		; $58d2
	ld a,Enemy.start		; $58d4
	ldi (hl),a		; $58d6
	ld (hl),d		; $58d7
	jp objectCopyPosition		; $58d8

@substate2:
	; Wait for "bat children" to be killed
	ld e,Enemy.var34		; $58db
	ld a,(de)		; $58dd
	or a			; $58de
	jp nz,_ecom_decCounter2		; $58df

	; Vire defeated
	ld h,d			; $58e2
	ld l,Enemy.state2		; $58e3
	inc (hl)		; $58e5
	inc l			; $58e6
	ld (hl),60 ; [counter1]
	ld a,SNDCTRL_STOPMUSIC		; $58e9
	jp playSound		; $58eb

@substate3:
	call _ecom_decCounter1		; $58ee
	jp nz,_ecom_flickerVisibility		; $58f1

	ld (hl),$10 ; [counter1]
	ld l,e			; $58f6
	inc (hl) ; [state2]
	jp objectSetVisiblec1		; $58f8

@substate4:
	call _ecom_decCounter1		; $58fb
	jp nz,enemyAnimate		; $58fe

	ld l,e			; $5901
	inc (hl) ; [state2]

	ld l,Enemy.angle		; $5903
	ld (hl),$06		; $5905
	ld l,Enemy.speed		; $5907
	ld (hl),SPEED_300		; $5909

	ld bc,TX_2f17		; $590b
	call checkIsLinkedGame		; $590e
	jr z,+			; $5911
	inc c ; TX_2f18
+
	jp showText		; $5914

@substate5:
	call checkIsLinkedGame		; $5917
	jr z,@unlinked	; $591a

@linked:
	ld e,Enemy.health		; $591c
	xor a			; $591e
	ld (de),a		; $591f
	ret			; $5920

@unlinked:
	; Spawn fairy if var38 is 0.
	ld e,Enemy.var38		; $5921
	ld a,(de)		; $5923
	or a			; $5924
	jr nz,++		; $5925
	inc a			; $5927
	ld (de),a		; $5928
	ld b,PARTID_ITEM_DROP		; $5929
	call _ecom_spawnProjectile		; $592b
++
	call enemyAnimate		; $592e

	ld h,d			; $5931
	ld l,Enemy.z		; $5932
	ld a,(hl)		; $5934
	sub <($0080)			; $5935
	ldi (hl),a		; $5937
	ld a,(hl)		; $5938
	sbc >($0080)			; $5939
	ld (hl),a		; $593b

	call _vire_checkOffScreen		; $593c
	jp c,objectApplySpeed		; $593f

	; Vire is gone; cleanup
	call markEnemyAsKilledInRoom		; $5942
	call decNumEnemies		; $5945
	ld a,(wActiveMusic2)		; $5948
	ld (wActiveMusic),a		; $594b
	call playSound		; $594e
	jp enemyDelete		; $5951


_vire_batForm:
	ld a,(de)		; $5954
	sub $08			; $5955
	rst_jumpTable			; $5957
	.dw _vire_batForm_state8
	.dw _vire_batForm_state9
	.dw _vire_batForm_stateA
	.dw _vire_batForm_stateB
	.dw _vire_batForm_stateC
	.dw _vire_batForm_stateD


_vire_batForm_state8:
	ld h,d			; $5964
	ld l,e			; $5965
	inc (hl) ; [state]

	ld l,Enemy.var30		; $5967
	ld a,(hl)		; $5969
	and $1f			; $596a
	ld l,Enemy.angle		; $596c
	ld (hl),a		; $596e

	ld l,Enemy.counter1		; $596f
	ld (hl),$10		; $5971

	ld l,Enemy.health		; $5973
	ld (hl),$01		; $5975

	ld a,$02		; $5977
	call enemySetAnimation		; $5979
	jp objectSetVisiblec1		; $597c


; Moving upward after charging (or after spawning)
_vire_batForm_state9:
	call _ecom_decCounter1		; $597f
	jr z,_vire_batForm_gotoStateA	; $5982

	; Move up while zh > -$10
	ld l,Enemy.zh		; $5984
	ldd a,(hl)		; $5986
	cp $f0			; $5987
	jr c,++			; $5989
	ld a,(hl)		; $598b
	sub <($00c0)			; $598c
	ldi (hl),a		; $598e
	ld a,(hl)		; $598f
	sbc >($00c0)			; $5990
	ld (hl),a		; $5992
++
	call objectApplySpeed		; $5993
	jr _vire_batForm_animate		; $5996

_vire_batForm_gotoStateA:
	ld l,e			; $5998
	ld (hl),$0a ; [state]

	ld l,Enemy.speed		; $599b
	ld (hl),SPEED_80		; $599d

	ld l,Enemy.collisionType		; $599f
	set 7,(hl)		; $59a1

	call getRandomNumber_noPreserveVars		; $59a3
	ld e,Enemy.counter1		; $59a6
	ld (de),a		; $59a8

	; [mainForm.counter2] = 180
	ld a,Object.counter2		; $59a9
	call objectGetRelatedObject1Var		; $59ab
	ld (hl),180		; $59ae
	jr _vire_batForm_animate		; $59b0


_vire_batForm_stateA:
	call _vire_batForm_updateZPos		; $59b2

	ld a,Object.counter2		; $59b5
	call objectGetRelatedObject1Var		; $59b7
	ld a,(hl)		; $59ba
	or a			; $59bb
	jr nz,++		; $59bc

	call _ecom_incState		; $59be
	ld l,Enemy.counter1		; $59c1
	ld (hl),$08		; $59c3
	ret			; $59c5
++
	call _vire_batForm_moveAwayFromLinkIfTooClose		; $59c6

	call objectGetAngleTowardEnemyTarget		; $59c9
	ld b,a			; $59cc
	ld e,Enemy.var30		; $59cd
	ld a,(de)		; $59cf
	add b			; $59d0
	and $1f			; $59d1
	ld e,Enemy.angle		; $59d3
	ld (de),a		; $59d5

	ld a,$02		; $59d6
	call _ecom_getSideviewAdjacentWallsBitset		; $59d8
	call z,objectApplySpeed		; $59db

_vire_batForm_animate:
	jp enemyAnimate		; $59de


; About to charge toward Link in [counter1] frames
_vire_batForm_stateB:
	call _ecom_decCounter1		; $59e1
	ret nz			; $59e4

	ld l,e			; $59e5
	inc (hl) ; [state]

	ld l,Enemy.speed		; $59e7
	ld (hl),SPEED_200		; $59e9

	ld l,Enemy.var35		; $59eb
	ldh a,(<hEnemyTargetY)	; $59ed
	ldi (hl),a		; $59ef
	ldh a,(<hEnemyTargetX)	; $59f0
	ld (hl),a		; $59f2
	ret			; $59f3


; Charging toward target position in var35/var36
_vire_batForm_stateC:
	ld h,d			; $59f4
	ld l,Enemy.var35		; $59f5
	call _ecom_readPositionVars		; $59f7
	sub c			; $59fa
	add $08			; $59fb
	cp $11			; $59fd
	jr nc,@notReachedPosition	; $59ff

	ldh a,(<hFF8F)	; $5a01
	sub b			; $5a03
	add $08			; $5a04
	cp $11			; $5a06
	jr nc,@notReachedPosition	; $5a08

	ld l,Enemy.zh		; $5a0a
	ld a,(hl)		; $5a0c
	cp $fa			; $5a0d
	jr c,@notReachedPosition	; $5a0f

	; Reached target position

	ld l,e			; $5a11
	inc (hl) ; [state]
	ld l,Enemy.counter1		; $5a13
	ld (hl),20		; $5a15
	jr _vire_batForm_animate		; $5a17

@notReachedPosition:
	ld l,Enemy.zh		; $5a19
	ld a,(hl)		; $5a1b
	cp $fe			; $5a1c
	jr nc,+			; $5a1e
	inc (hl)		; $5a20
+
	call _ecom_moveTowardPosition		; $5a21
	jr _vire_batForm_animate		; $5a24


; Moving back up after charging
_vire_batForm_stateD:
	call _ecom_decCounter1		; $5a26
	jp z,_vire_batForm_gotoStateA		; $5a29

	ld l,Enemy.zh		; $5a2c
	ldd a,(hl)		; $5a2e
	cp $f0			; $5a2f
	jr c,++			; $5a31

	ld a,(hl)		; $5a33
	sub <($00c0)			; $5a34
	ldi (hl),a		; $5a36
	ld a,(hl)		; $5a37
	sbc >($00c0)			; $5a38
	ld (hl),a		; $5a3a
++
	ld a,$02		; $5a3b
	call _ecom_getSideviewAdjacentWallsBitset		; $5a3d
	call z,objectApplySpeed		; $5a40
	jr _vire_batForm_animate		; $5a43


;;
; Sets Vire's position to just outside the camera (along with corresponding angle), and
; increments state2.
;
; @param[out]	hl	Enemy.state2
; @addr{5a45}
_vire_spawnOutsideCamera:
	call getRandomNumber_noPreserveVars		; $5a45
	and $07			; $5a48
	ld b,a			; $5a4a
	add a			; $5a4b
	add b			; $5a4c
	ld hl,@spawnPositions		; $5a4d
	rst_addAToHl			; $5a50

	ld e,Enemy.yh		; $5a51
	ldh a,(<hCameraY)	; $5a53
	add (hl)		; $5a55
	ld (de),a		; $5a56
	inc hl			; $5a57
	ld e,Enemy.xh		; $5a58
	ldh a,(<hCameraX)	; $5a5a
	add (hl)		; $5a5c
	ld (de),a		; $5a5d

	inc hl			; $5a5e
	ld e,Enemy.angle		; $5a5f
	ld a,(hl)		; $5a61
	ld (de),a		; $5a62

	ld h,d			; $5a63
	ld l,Enemy.collisionType		; $5a64
	set 7,(hl)		; $5a66

	ld l,Enemy.state2		; $5a68
	inc (hl)		; $5a6a
	jp objectSetVisiblec1		; $5a6b

; Data format:
;   b0: y (relative to hCameraY)
;   b1: x (relative to hCameraX)
;   b2: angle
@spawnPositions:
	.db $f8 $10 $10
	.db $f8 $90 $10
	.db $10 $f8 $08
	.db $10 $a8 $18
	.db $70 $f8 $08
	.db $70 $a8 $18
	.db $88 $10 $00
	.db $88 $90 $00

;;
; Vire has left the screen; set state to 9, where he'll wait for 90 frames before
; attacking again.
; @addr{5a86}
_vire_mainForm_leftScreen:
	ld h,d			; $5a86
	ld l,Enemy.state		; $5a87
	ld (hl),$09		; $5a89
	inc l			; $5a8b
	ld (hl),$00 ; [state2]
	inc l			; $5a8e
	ld (hl),90 ; [counter1]

	ld l,Enemy.collisionType		; $5a91
	res 7,(hl)		; $5a93
	jp objectSetInvisible		; $5a95

;;
; @param[out]	cflag	c if left screen
; @addr{5a98}
_vire_checkOffScreen:
	ld e,Enemy.yh		; $5a98
	ld a,(de)		; $5a9a
	cp (LARGE_ROOM_HEIGHT<<4)+8			; $5a9b
	ret nc			; $5a9d
	ld e,Enemy.xh		; $5a9e
	ld a,(de)		; $5aa0
	cp (LARGE_ROOM_WIDTH<<4)			; $5aa1
	ret			; $5aa3


;;
; @addr{5aa4}
_vire_mainForm_circleAroundScreen:
	ldh a,(<hCameraY)	; $5aa4
	add (SCREEN_HEIGHT<<3)+4			; $5aa6
	ld b,a			; $5aa8
	ldh a,(<hCameraX)	; $5aa9
	add SCREEN_WIDTH<<3			; $5aab
	ld c,a			; $5aad
	push bc			; $5aae
	call objectGetRelativeAngle		; $5aaf
	pop bc			; $5ab2

	ld h,a			; $5ab3
	ld e,Enemy.yh		; $5ab4
	ld a,(de)		; $5ab6
	sub b			; $5ab7
	jr nc,+		; $5ab8
	cpl			; $5aba
	inc a			; $5abb
+
	ld b,a			; $5abc
	cp $3e			; $5abd
	ld a,h			; $5abf
	jr nc,@setAngleAndSpeed	; $5ac0

	ld e,Enemy.xh		; $5ac2
	ld a,(de)		; $5ac4
	sub c			; $5ac5
	jr nc,+			; $5ac6
	cpl			; $5ac8
	inc a			; $5ac9
+
	ld c,a			; $5aca
	cp $3e			; $5acb
	ld a,h			; $5acd
	jr nc,@setAngleAndSpeed	; $5ace

	ld a,b			; $5ad0
	add c			; $5ad1
	sub $42			; $5ad2
	cp $08			; $5ad4
	jr c,@offsetAngle	; $5ad6

	rlca			; $5ad8
	ld a,h			; $5ad9
	jr nc,@setAngleAndSpeed	; $5ada

	xor $10			; $5adc

@setAngleAndSpeed:
	push hl			; $5ade
	ld e,Enemy.angle		; $5adf
	ld (de),a		; $5ae1
	ld e,Enemy.speed		; $5ae2
	ld a,SPEED_40		; $5ae4
	ld (de),a		; $5ae6
	call objectApplySpeed		; $5ae7
	pop hl			; $5aea

@offsetAngle:
	ld e,Enemy.var30		; $5aeb
	ld a,(de)		; $5aed
	add h			; $5aee
	and $1f			; $5aef
	ld e,Enemy.angle		; $5af1
	ld (de),a		; $5af3

	ld e,Enemy.speed		; $5af4
	ld a,SPEED_e0		; $5af6
	ld (de),a		; $5af8


;;
; @addr{5af9}
_vire_mainForm_applySpeedAndAnimate:
	call objectApplySpeed		; $5af9
	jp enemyAnimate		; $5afc

;;
; @param[out]	cflag	c if Link is too close (Vire will flee)
; @addr{5aff}
_vire_mainForm_checkLinkTooClose:
	ld h,d			; $5aff
	ld l,Enemy.yh		; $5b00
	ldh a,(<hEnemyTargetY)	; $5b02
	sub (hl)		; $5b04
	add 30			; $5b05
	cp 61			; $5b07
	ret nc			; $5b09
	ld l,Enemy.xh		; $5b0a
	ldh a,(<hEnemyTargetX)	; $5b0c
	sub (hl)		; $5b0e
	add 30			; $5b0f
	cp 61			; $5b11
	ret			; $5b13


;;
; @addr{5b14}
_vire_mainForm_fireProjectile:
	call getRandomNumber_noPreserveVars		; $5b14
	and $01			; $5b17
	inc a			; $5b19
	ld b,a			; $5b1a

;;
; @param	b	Subid
; @addr{5b1b}
_vire_mainForm_fireProjectileWithSubid:
	call getFreePartSlot		; $5b1b
	ret nz			; $5b1e
	ld (hl),PARTID_VIRE_PROJECTILE		; $5b1f
	inc l			; $5b21
	ld (hl),b ; [subid]

	ld l,Part.relatedObj1+1		; $5b23
	ld (hl),d		; $5b25
	dec l			; $5b26
	ld (hl),Enemy.start		; $5b27

	call objectCopyPosition		; $5b29
	ld a,SND_SPLASH		; $5b2c
	call playSound		; $5b2e

	ld e,Enemy.direction		; $5b31
	ld a,$01		; $5b33
	ld (de),a		; $5b35
	jp enemySetAnimation		; $5b36

;;
; @addr{5b39}
_vire_batForm_moveAwayFromLinkIfTooClose:
	ld h,d			; $5b39
	ld l,Enemy.yh		; $5b3a
	ldh a,(<hEnemyTargetY)	; $5b3c
	sub (hl)		; $5b3e
	add 12			; $5b3f
	cp 25			; $5b41
	ret nc			; $5b43
	ld l,Enemy.xh		; $5b44
	ldh a,(<hEnemyTargetX)	; $5b46
	sub (hl)		; $5b48
	add 12			; $5b49
	cp 25			; $5b4b
	ret nc			; $5b4d

	call objectGetAngleTowardEnemyTarget		; $5b4e
	xor $10			; $5b51
	ld c,a			; $5b53
	ld b,SPEED_200		; $5b54
	jp _ecom_applyGivenVelocity		; $5b56


;;
; @addr{5b59}
_vire_batForm_updateZPos:
	call _ecom_decCounter1		; $5b59
	ld a,(hl)		; $5b5c
	and $1c			; $5b5d
	rrca			; $5b5f
	rrca			; $5b60
	ld hl,@zVals		; $5b61
	rst_addAToHl			; $5b64
	ld e,Enemy.zh		; $5b65
	ld a,(hl)		; $5b67
	ld (de),a		; $5b68
	ret			; $5b69

@zVals:
	.db $f0 $f1 $f0 $ef $ee $ed $ee $ef


; ==============================================================================
; ENEMYID_ANGLER_FISH
;
; Variables:
;   relatedObj1: reference to other subid (main <-> antenna)
; ==============================================================================
enemyCode76:
	jr z,@normalStatus	; $5b72
	sub ENEMYSTATUS_NO_HEALTH			; $5b74
	ret c			; $5b76
	jr nz,@justHit	; $5b77

	; ENEMYSTATUS_DEAD
	ld e,Enemy.subid		; $5b79
	ld a,(de)		; $5b7b
	or a			; $5b7c
	jp z,_enemyBoss_dead		; $5b7d
	call _ecom_killRelatedObj1		; $5b80
	jp enemyDelete		; $5b83

@justHit:
	ld e,Enemy.subid		; $5b86
	ld a,(de)		; $5b88
	or a			; $5b89
	jr z,@fishHit	; $5b8a

@antennaHit:
	ld a,Object.invincibilityCounter		; $5b8c
	call objectGetRelatedObject1Var		; $5b8e
	ld e,l			; $5b91
	ld a,(de)		; $5b92
	ld (hl),a		; $5b93
	jr @normalStatus		; $5b94

@fishHit:
	ld e,Enemy.var2a		; $5b96
	ld a,(de)		; $5b98
	cp $80|ITEMCOLLISION_SCENT_SEED			; $5b99
	jr nz,@normalStatus	; $5b9b

	ld h,d			; $5b9d
	ld l,Enemy.state		; $5b9e
	ld (hl),$0d		; $5ba0

	ld l,Enemy.collisionType		; $5ba2
	res 7,(hl)		; $5ba4

	ld e,Enemy.direction		; $5ba6
	ld a,(de)		; $5ba8
	and $01			; $5ba9
	add $04			; $5bab
	ld (de),a		; $5bad
	call enemySetAnimation		; $5bae

	ld b,INTERACID_EXPLOSION		; $5bb1
	call objectCreateInteractionWithSubid00		; $5bb3

@normalStatus:
	call _ecom_getSubidAndCpStateTo08		; $5bb6
	jr c,@commonState	; $5bb9
	ld a,b			; $5bbb
	or a			; $5bbc
	jp z,anglerFish_main		; $5bbd
	jp _anglerFish_antenna		; $5bc0

@commonState:
	rst_jumpTable			; $5bc3
	.dw _anglerFish_state_uninitialized
	.dw _anglerFish_state_stub
	.dw _anglerFish_state_stub
	.dw _anglerFish_state_stub
	.dw _anglerFish_state_stub
	.dw _anglerFish_state_stub
	.dw _anglerFish_state_stub
	.dw _anglerFish_state_stub


_anglerFish_state_uninitialized:
	ld a,$ff		; $5bd4
	ld b,$00		; $5bd6
	call _enemyBoss_initializeRoom		; $5bd8

	; If bit 7 of subid is set, it's already been initialized
	ld e,Enemy.subid		; $5bdb
	ld a,(de)		; $5bdd
	bit 7,a			; $5bde
	res 7,a			; $5be0
	ld (de),a		; $5be2
	jr nz,@doneInit	; $5be3

	; Subid 1 has no special initialization
	dec a			; $5be5
	jr z,@doneInit	; $5be6

	; Subid 0 initialization; spawn subid 1, set their relatedObj1 to each other
	ld b,ENEMYID_ANGLER_FISH		; $5be8
	call _ecom_spawnUncountedEnemyWithSubid01		; $5bea
	ret nz			; $5bed
	ld e,Enemy.relatedObj1		; $5bee
	ld l,e			; $5bf0
	ld a,Enemy.start		; $5bf1
	ld (de),a		; $5bf3
	ldi (hl),a		; $5bf4
	inc e			; $5bf5
	ld (hl),d		; $5bf6
	ld a,h			; $5bf7
	ld (de),a		; $5bf8

	; Make sure subid 0 comes before subid 1, otherwise swap them
	ld a,h			; $5bf9
	cp d			; $5bfa
	jr nc,@doneInit	; $5bfb
	ld l,Enemy.subid		; $5bfd
	ld (hl),$80		; $5bff
	ld e,l			; $5c01
	ld a,$01		; $5c02
	ld (de),a		; $5c04
@doneInit:
	jp _ecom_setSpeedAndState8		; $5c05


_anglerFish_state_stub:
	ret			; $5c08


anglerFish_main:
	ld a,(de)		; $5c09
	sub $08			; $5c0a
	rst_jumpTable			; $5c0c
	.dw anglerFish_main_state8
	.dw anglerFish_main_state9
	.dw anglerFish_main_stateA
	.dw anglerFish_main_stateB
	.dw anglerFish_main_stateC
	.dw anglerFish_main_stateD
	.dw anglerFish_main_stateE
	.dw anglerFish_main_stateF


; Waiting for Link to enter
anglerFish_main_state8:
	ld a,(w1Link.state)		; $5c1d
	cp LINK_STATE_FORCE_MOVEMENT			; $5c20
	ret z			; $5c22
	call checkLinkVulnerable		; $5c23
	ret nc			; $5c26

	ld a,DISABLE_LINK		; $5c27
	ld (wDisabledObjects),a		; $5c29
	ld (wMenuDisabled),a		; $5c2c

	ld a,$42		; $5c2f
	ld c,$80		; $5c31
	call setTile		; $5c33
	ld a,$52		; $5c36
	ld c,$90		; $5c38
	call setTile		; $5c3a

	call _ecom_incState		; $5c3d
	ld l,Enemy.counter1		; $5c40
	ld (hl),30		; $5c42
	ld a,SND_DOORCLOSE		; $5c44
	jp playSound		; $5c46


; Delay before starting fight
anglerFish_main_state9:
	call _ecom_decCounter1		; $5c49
	ret nz			; $5c4c

	ld l,e			; $5c4d
	inc (hl) ; [state]

	ld l,Enemy.angle		; $5c4f
	ld (hl),ANGLE_LEFT		; $5c51
	ld l,Enemy.speed		; $5c53
	ld (hl),SPEED_c0		; $5c55

	jp objectSetVisible82		; $5c57


; Falling to the ground, then the fight will begin
anglerFish_main_stateA:
	ld b,$0c		; $5c5a
	ld a,$10		; $5c5c
	call objectUpdateSpeedZ_sidescroll_givenYOffset		; $5c5e
	jr c,@hitGround	; $5c61

	ld l,Enemy.speedZ+1		; $5c63
	ld a,(hl)		; $5c65
	cp $02			; $5c66
	ret c			; $5c68
	ld (hl),$02		; $5c69
	ret			; $5c6b

@hitGround:
	call _enemyBoss_beginMiniboss		; $5c6c
	call _ecom_incState		; $5c6f

	ld l,Enemy.counter2		; $5c72
	ld (hl),180		; $5c74

_anglerFish_bounceOffGround:
	ld h,d			; $5c76
	ld l,Enemy.speedZ		; $5c77
	ld a,<(-$320)		; $5c79
	ldi (hl),a		; $5c7b
	ld (hl),>(-$320)		; $5c7c

	ld a,SND_POOF		; $5c7e
	jp playSound		; $5c80


; Bouncing around normally
anglerFish_main_stateB:
	call _ecom_decCounter2		; $5c83
	call z,anglerFish_main_checkFireProjectile		; $5c86

_anglerFish_updatePosition:
	ld b,$0c		; $5c89
	ld a,$10		; $5c8b
	call objectUpdateSpeedZ_sidescroll_givenYOffset		; $5c8d
	jr nc,_anglerFish_applySpeed	; $5c90

	; Hit ground
	call _anglerFish_bounceOffGround		; $5c92

	call getRandomNumber_noPreserveVars		; $5c95
	and $10			; $5c98
	add $08			; $5c9a
	ld e,Enemy.angle		; $5c9c
	ld (de),a		; $5c9e

	and $10			; $5c9f
	xor $10			; $5ca1
	swap a			; $5ca3
	ld b,a			; $5ca5
	ld e,Enemy.direction		; $5ca6
	ld a,(de)		; $5ca8
	and $01			; $5ca9
	cp b			; $5cab
	call nz,_anglerFish_updateAnimation		; $5cac

_anglerFish_applySpeed:
	call objectApplySpeed		; $5caf
	call _ecom_bounceOffWallsAndHoles		; $5cb2
	jp z,enemyAnimate		; $5cb5

_anglerFish_updateAnimation:
	ld e,Enemy.direction		; $5cb8
	ld a,(de)		; $5cba
	xor $01			; $5cbb
	ld (de),a		; $5cbd
	jp enemySetAnimation		; $5cbe


; Firing a projectile
anglerFish_main_stateC:
	ld e,Enemy.animParameter		; $5cc1
	ld a,(de)		; $5cc3
	inc a			; $5cc4
	jr z,@doneFiring	; $5cc5
	dec a			; $5cc7
	jr z,_anglerFish_updatePosition	; $5cc8

	; Time to spawn the projectile
	xor a			; $5cca
	ld (de),a		; $5ccb
	call getFreeEnemySlot_uncounted		; $5ccc
	jr nz,_anglerFish_updatePosition	; $5ccf

	ld (hl),ENEMYID_ANGLER_FISH_BUBBLE		; $5cd1
	ld l,Enemy.relatedObj1		; $5cd3
	ld a,Enemy.start		; $5cd5
	ldi (hl),a		; $5cd7
	ld (hl),d		; $5cd8

	ld a,SND_FALLINHOLE		; $5cd9
	call playSound		; $5cdb
	jr _anglerFish_updatePosition		; $5cde

@doneFiring:
	ld h,d			; $5ce0
	ld l,Enemy.state		; $5ce1
	dec (hl)		; $5ce3

	ld l,Enemy.direction		; $5ce4
	ld a,(hl)		; $5ce6
	sub $02			; $5ce7
	ld (hl),a		; $5ce9
	call enemySetAnimation		; $5cea

	jr _anglerFish_updatePosition		; $5ced


; Just hit with a scent seed, falling to ground
anglerFish_main_stateD:
	ld a,$20		; $5cef
	call objectUpdateSpeedZ_sidescroll		; $5cf1
	ret nc			; $5cf4

	call _ecom_incState		; $5cf5
	ld l,Enemy.counter1		; $5cf8
	ld (hl),150		; $5cfa
	ret			; $5cfc


; Vulnerable for [counter1] frames
anglerFish_main_stateE:
	call _ecom_decCounter1		; $5cfd
	jp nz,enemyAnimate		; $5d00

	ld l,e			; $5d03
	inc (hl) ; [state]

	ld l,Enemy.speedZ		; $5d05
	ld a,<(-$400)		; $5d07
	ldi (hl),a		; $5d09
	ld (hl),>(-$400)		; $5d0a
	ret			; $5d0c


; Bouncing back up after being deflated
anglerFish_main_stateF:
	ld a,$20		; $5d0d
	call objectUpdateSpeedZ_sidescroll		; $5d0f

	ld l,Enemy.speedZ+1		; $5d12
	ld a,(hl)		; $5d14
	or a			; $5d15
	jr nz,_anglerFish_applySpeed	; $5d16

	ld l,Enemy.state		; $5d18
	ld (hl),$0b		; $5d1a

	ld l,Enemy.collisionType		; $5d1c
	set 7,(hl)		; $5d1e

	ld l,Enemy.counter1		; $5d20
	ld (hl),180		; $5d22

	ld l,Enemy.direction		; $5d24
	ld a,(hl)		; $5d26
	sub $04			; $5d27
	ld (hl),a		; $5d29
	call enemySetAnimation		; $5d2a

	ld a,SND_POOF		; $5d2d
	jp playSound		; $5d2f


_anglerFish_antenna:
	ld a,(de)		; $5d32
	cp $08			; $5d33
	jr z,@state8	; $5d35

@state9:
	ld a,Object.direction		; $5d37
	call objectGetRelatedObject1Var		; $5d39
	ld a,(hl)		; $5d3c
	push hl			; $5d3d

	ld hl,@positionOffsets		; $5d3e
	rst_addDoubleIndex			; $5d41
	ldi a,(hl)		; $5d42
	ld b,a			; $5d43
	ld c,(hl)		; $5d44

	pop hl			; $5d45
	call objectTakePositionWithOffset		; $5d46
	ld l,Enemy.invincibilityCounter		; $5d49
	ld a,(hl)		; $5d4b
	or a			; $5d4c
	jp nz,objectSetInvisible		; $5d4d

	ld a,(wFrameCounter)		; $5d50
	rrca			; $5d53
	ret c			; $5d54
	jp _ecom_flickerVisibility		; $5d55

@positionOffsets:
	.db $f0 $f6
	.db $f0 $0a
	.db $f0 $f6
	.db $f0 $0a
	.db $fc $f7
	.db $fc $09

@state8:
	ld h,d			; $5d64
	ld l,e			; $5d65
	inc (hl) ; [state]

	ld l,Enemy.enemyCollisionMode		; $5d67
	ld (hl),ENEMYCOLLISION_ANGLER_FISH_ANTENNA		; $5d69

	ld l,Enemy.collisionRadiusY		; $5d6b
	ld a,$03		; $5d6d
	ldi (hl),a		; $5d6f
	ld (hl),a		; $5d70

	ld l,Enemy.oamTileIndexBase		; $5d71
	ld (hl),$1e		; $5d73

	ld l,Enemy.oamFlagsBackup		; $5d75
	ld a,$0d		; $5d77
	ldi (hl),a		; $5d79
	ld (hl),a		; $5d7a

	ld a,$06		; $5d7b
	jp enemySetAnimation		; $5d7d

;;
; Changes state to $0c if conditions are appropriate to fire a projectile.
; @addr{5d80}
anglerFish_main_checkFireProjectile:
	ld e,Enemy.yh		; $5d80
	ld a,(de)		; $5d82
	cp $5c			; $5d83
	ret nc			; $5d85
	ld e,Enemy.xh		; $5d86
	ld a,(de)		; $5d88
	sub $38			; $5d89
	cp $70			; $5d8b
	ret nc			; $5d8d

	ld (hl),180		; $5d8e
	ld l,Enemy.state		; $5d90
	inc (hl)		; $5d92
	ld l,Enemy.direction		; $5d93
	ld a,(hl)		; $5d95
	add $02			; $5d96
	ld (hl),a		; $5d98
	jp enemySetAnimation		; $5d99


; ==============================================================================
; ENEMYID_BLUE_STALFOS
;
; Variables (for subid 1, "main" enemy):
;   var30/var31: Destination position while moving
;   var32: Projectile pattern index; number from 0-7 which cycles through ball types.
;          (Used by PARTID_BLUE_STALFOS_PROJECTILE.)
;
; Variables (for subid 3, the afterimage):
;   var30/var31: Y/X position?
;   var32: Index in position differenc buffer?
;   var33-var3a: Position difference buffer?
; ==============================================================================
enemyCode77:
	jr z,@normalStatus	; $5d9c
	sub ENEMYSTATUS_NO_HEALTH			; $5d9e
	ret c			; $5da0
	jp z,_enemyBoss_dead		; $5da1
	dec a			; $5da4
	jr nz,@normalStatus	; $5da5

@normalStatus:
	call _ecom_getSubidAndCpStateTo08		; $5da7
	jr nc,@normalState	; $5daa
	rst_jumpTable			; $5dac
	.dw _blueStalfos_state_uninitialized
	.dw _blueStalfos_state_spawner
	.dw _blueStalfos_state_stub
	.dw _blueStalfos_state_stub
	.dw _blueStalfos_state_stub
	.dw _blueStalfos_state_stub
	.dw _blueStalfos_state_stub
	.dw _blueStalfos_state_stub

@normalState:
	dec b			; $5dbd
	ld a,b			; $5dbe
	rst_jumpTable			; $5dbf
	.dw _blueStalfos_subid1
	.dw _blueStalfos_subid2
	.dw _blueStalfos_subid3


_blueStalfos_state_uninitialized:
	ld a,b			; $5dc6
	sub $02			; $5dc7
	call c,objectSetVisible82		; $5dc9
	ld a,b			; $5dcc
	or a			; $5dcd
	jp nz,_ecom_setSpeedAndState8		; $5dce

	; Spawner (subid 0) only
	call _ecom_incState		; $5dd1
	ld l,Enemy.zh		; $5dd4
	ld (hl),$ff		; $5dd6
	ld a,ENEMYID_BLUE_STALFOS		; $5dd8
	jp _enemyBoss_initializeRoom		; $5dda


_blueStalfos_state_spawner:
	ld b,$03		; $5ddd
	call checkBEnemySlotsAvailable		; $5ddf
	ret nz			; $5de2

	; Spawn subid 1
	ld b,ENEMYID_BLUE_STALFOS		; $5de3
	call _ecom_spawnUncountedEnemyWithSubid01		; $5de5
	call objectCopyPosition		; $5de8
	ld l,Enemy.enabled		; $5deb
	ld e,l			; $5ded
	ld a,(de)		; $5dee
	ld (hl),a		; $5def

	; Spawn subid 2
	ld c,h			; $5df0
	call _ecom_spawnUncountedEnemyWithSubid01		; $5df1
	inc (hl)		; $5df4

	; [subid2.relatedObj1] = subid1
	ld l,Enemy.relatedObj1		; $5df5
	ld a,Enemy.start		; $5df7
	ldi (hl),a		; $5df9
	ld (hl),c		; $5dfa

	call objectCopyPosition		; $5dfb

	; Spawn subid 3
	call _ecom_spawnUncountedEnemyWithSubid01		; $5dfe
	ld (hl),$03		; $5e01

	; [subid3.relatedObj1] = subid1
	ld l,Enemy.relatedObj1		; $5e03
	ld a,Enemy.start		; $5e05
	ldi (hl),a		; $5e07
	ld (hl),c		; $5e08

	call objectCopyPosition		; $5e09

	jp enemyDelete		; $5e0c


_blueStalfos_state_stub:
	ret			; $5e0f


_blueStalfos_subid1:
	ld a,(de)		; $5e10
	sub $08			; $5e11
	rst_jumpTable			; $5e13
	.dw _blueStalfos_main_state08
	.dw _blueStalfos_main_state09
	.dw _blueStalfos_main_state0a
	.dw _blueStalfos_main_state0b
	.dw _blueStalfos_main_state0c
	.dw _blueStalfos_main_state0d
	.dw _blueStalfos_main_state0e
	.dw _blueStalfos_main_state0f
	.dw _blueStalfos_main_state10
	.dw _blueStalfos_main_state11
	.dw _blueStalfos_main_state12
	.dw _blueStalfos_main_state13
	.dw _blueStalfos_main_state14
	.dw _blueStalfos_main_state15
	.dw _blueStalfos_main_state16
	.dw _blueStalfos_main_state17


_blueStalfos_main_state08:
	ld bc,$010b		; $5e34
	call _enemyBoss_spawnShadow		; $5e37
	ret nz			; $5e3a

	call _ecom_incState		; $5e3b

	ld l,Enemy.speed		; $5e3e
	ld (hl),SPEED_200		; $5e40
	ld l,Enemy.angle		; $5e42
	ld (hl),ANGLE_DOWN		; $5e44
	ret			; $5e46


; Moving down before fight starts
_blueStalfos_main_state09:
	call objectApplySpeed		; $5e47
	ld e,Enemy.yh		; $5e4a
	ld a,(de)		; $5e4c
	cp $58			; $5e4d
	jr nz,_blueStalfos_main_animate	; $5e4f

	; Fight starts now
	call _ecom_incState		; $5e51

	ld l,Enemy.counter1		; $5e54
	ld (hl),$40		; $5e56
	ld l,Enemy.speed		; $5e58
	ld (hl),SPEED_20		; $5e5a

	ld a,MUS_MINIBOSS		; $5e5c
	ld (wActiveMusic),a		; $5e5e
	call playSound		; $5e61

	ld e,$0f		; $5e64
	ld bc,$3030		; $5e66
	call _ecom_randomBitwiseAndBCE		; $5e69
	ld a,e			; $5e6c
	jp _blueStalfos_main_moveToQuadrant		; $5e6d


; Moving to position in var30/var31
_blueStalfos_main_state0a:
	ld h,d			; $5e70
	ld l,Enemy.var30		; $5e71
	call _ecom_readPositionVars		; $5e73
	sub c			; $5e76
	add $04			; $5e77
	cp $09			; $5e79
	jr nc,@moveToPosition	; $5e7b

	ldh a,(<hFF8F)	; $5e7d
	sub b			; $5e7f
	add $04			; $5e80
	cp $09			; $5e82
	jr nc,@moveToPosition	; $5e84

	; Reached target position
	ld h,d			; $5e86
	ld l,Enemy.state		; $5e87
	ld (hl),$0b		; $5e89
	ld l,Enemy.counter1		; $5e8b
	ld (hl),$10		; $5e8d
	jr _blueStalfos_main_animate		; $5e8f

@moveToPosition:
	call _blueStalfos_main_accelerate		; $5e91
	call _ecom_moveTowardPosition		; $5e94
	jr _blueStalfos_main_animate		; $5e97


; Reached position, standing still for [counter1] frames
_blueStalfos_main_state0b:
	call _ecom_decCounter1		; $5e99
	jr nz,_blueStalfos_main_animate	; $5e9c

	ld l,e			; $5e9e
	inc (hl) ; [state]

_blueStalfos_main_animate:
	jp enemyAnimate		; $5ea0


; Decide which attack to do
_blueStalfos_main_state0c:
	ld e,Enemy.yh		; $5ea3
	ld a,(de)		; $5ea5
	add $10			; $5ea6
	ld b,a			; $5ea8
	ld e,Enemy.xh		; $5ea9
	ld a,(de)		; $5eab
	add $04			; $5eac
	ld c,a			; $5eae

	; If Link is close enough, use the sickle on him
	ldh a,(<hEnemyTargetY)	; $5eaf
	sub b			; $5eb1
	add $14			; $5eb2
	cp $29			; $5eb4
	jr nc,@projectileAttack	; $5eb6
	ldh a,(<hEnemyTargetX)	; $5eb8
	sub c			; $5eba
	add $12			; $5ebb
	cp $25			; $5ebd
	jp c,_blueStalfos_main_beginSickleAttack		; $5ebf

@projectileAttack:
	ld b,PARTID_BLUE_STALFOS_PROJECTILE		; $5ec2
	call _ecom_spawnProjectile		; $5ec4
	ret nz			; $5ec7
	ld h,d			; $5ec8
	ld l,Enemy.counter1		; $5ec9
	ld (hl),120		; $5ecb
	ld l,Enemy.state		; $5ecd
	ld (hl),$0e		; $5ecf
	ld a,$02		; $5ed1
	jp enemySetAnimation		; $5ed3


; Sickle attack
_blueStalfos_main_state0d:
	call enemyAnimate		; $5ed6
	ld e,Enemy.animParameter		; $5ed9
	ld a,(de)		; $5edb
	inc a			; $5edc
	jr z,_blueStalfos_main_finishedAttack	; $5edd

	dec a			; $5edf
	ret nz			; $5ee0

	ld a,$08		; $5ee1
	ld (de),a ; [animParameter]

	ld a,SND_SWORDSPIN		; $5ee4
	jp playSound		; $5ee6


; Charging a projectile
_blueStalfos_main_state0e:
	call _ecom_decCounter1		; $5ee9
	jr nz,_blueStalfos_main_animate	; $5eec

	ld (hl),60		; $5eee
	ld l,e			; $5ef0
	inc (hl) ; [state]
	ld a,$03		; $5ef2
	jp enemySetAnimation		; $5ef4


; Just fired projectile
_blueStalfos_main_state0f:
	call _ecom_decCounter1		; $5ef7
	ret nz			; $5efa

_blueStalfos_main_finishedAttack:
	ld h,d			; $5efb
	ld l,Enemy.state		; $5efc
	ld (hl),$0a		; $5efe
	ld l,Enemy.counter1		; $5f00
	ld (hl),$40		; $5f02
	ld l,Enemy.speed		; $5f04
	ld (hl),SPEED_20		; $5f06
	xor a			; $5f08
	call enemySetAnimation		; $5f09
	jp _blueStalfos_main_decideNextPosition		; $5f0c


; Link just turned into a baby; about to turn transparent and warp to top of room
_blueStalfos_main_state10:
	call _ecom_decCounter1		; $5f0f
	jr nz,_blueStalfos_main_animate	; $5f12

	ld (hl),$10 ; [counter1]
	ld l,e			; $5f16
	inc (hl) ; [state]
	ld l,Enemy.collisionType		; $5f18
	res 7,(hl)		; $5f1a
	ret			; $5f1c


; Now transparent; waiting for [counter1] frames before warping
_blueStalfos_main_state11:
	call _ecom_decCounter1		; $5f1d
	jp nz,_ecom_flickerVisibility		; $5f20

	ld (hl),$08 ; [counter1]
	ld l,e			; $5f25
	inc (hl) ; [state]
	ld l,Enemy.collisionType		; $5f27
	set 7,(hl)		; $5f29

	ld l,Enemy.yh		; $5f2b
	ld (hl),$0c		; $5f2d
	ld l,Enemy.xh		; $5f2f
	ldh a,(<hEnemyTargetX)	; $5f31
	ld (hl),a		; $5f33

	xor a			; $5f34
	call enemySetAnimation		; $5f35
	jp objectSetInvisible		; $5f38


; Just warped to top of room; standing in place
_blueStalfos_main_state12:
	call _ecom_decCounter1		; $5f3b
	jp nz,_ecom_flickerVisibility		; $5f3e

	ld l,Enemy.angle		; $5f41
	ld (hl),$10		; $5f43

	ld l,e			; $5f45
	inc (hl) ; [state]

	call getRandomNumber_noPreserveVars		; $5f47
	and $03			; $5f4a
	ld hl,@speedTable		; $5f4c
	rst_addAToHl			; $5f4f
	ld e,Enemy.speed		; $5f50
	ld a,(hl)		; $5f52
	ld (de),a		; $5f53

	jp objectSetVisible82		; $5f54

@speedTable:
	.db SPEED_180, SPEED_1c0, SPEED_200, SPEED_300


; Moving down toward baby Link before attacking with sickle
_blueStalfos_main_state13:
	ld h,d			; $5f5b
	ld l,Enemy.yh		; $5f5c
	ldh a,(<hEnemyTargetY)	; $5f5e
	sub (hl)		; $5f60
	cp $18			; $5f61
	jp nc,objectApplySpeed		; $5f63

_blueStalfos_main_beginSickleAttack:
	ld e,Enemy.state		; $5f66
	ld a,$0d		; $5f68
	ld (de),a		; $5f6a
	ld a,$01		; $5f6b
	jp enemySetAnimation		; $5f6d


; Just hit by PARTID_BLUE_STALFOS_PROJECTILE; turning into a small bat
_blueStalfos_main_state14:
	call _blueStalfos_createPuff		; $5f70
	ret nz			; $5f73

	ld l,Enemy.state		; $5f74
	inc (hl)		; $5f76
	ld l,Enemy.collisionRadiusY		; $5f77
	ld (hl),$02		; $5f79
	inc l			; $5f7b
	ld (hl),$06		; $5f7c

	ld l,Enemy.counter1		; $5f7e
	ld (hl),$f0		; $5f80
	inc l			; $5f82
	ld (hl),$00 ; [counter2]

	ld l,Enemy.speed		; $5f85
	ld (hl),SPEED_c0		; $5f87

	call objectSetInvisible		; $5f89

	ld a,SND_SCENT_SEED		; $5f8c
	call playSound		; $5f8e

	ld a,$04		; $5f91
	jp enemySetAnimation		; $5f93


; Transforming into bat
_blueStalfos_main_state15:
	ld a,Object.animParameter		; $5f96
	call objectGetRelatedObject2Var		; $5f98
	bit 7,(hl)		; $5f9b
	ret nz			; $5f9d

	call _ecom_incState		; $5f9e

	ld l,Enemy.enemyCollisionMode		; $5fa1
	ld (hl),ENEMYCOLLISION_BLUE_STALFOS_BAT		; $5fa3

	ld l,Enemy.zh		; $5fa5
	ld (hl),$00		; $5fa7

	jp objectSetVisiblec2		; $5fa9


; Flying around as a bat
_blueStalfos_main_state16:
	call _ecom_decCounter1		; $5fac
	jr nz,@flyAround	; $5faf

	; Time to transform back into stalfos

	inc (hl) ; [counter1] = 1
	call _blueStalfos_createPuff		; $5fb2
	ret nz			; $5fb5

	ld l,Enemy.state		; $5fb6
	inc (hl)		; $5fb8

	ld l,Enemy.enemyCollisionMode		; $5fb9
	ld (hl),ENEMYCOLLISION_BLUE_STALFOS		; $5fbb
	ld l,Enemy.zh		; $5fbd
	ld (hl),$ff		; $5fbf
	jp objectSetInvisible		; $5fc1

@flyAround:
	call _ecom_decCounter2		; $5fc4
	jr nz,++		; $5fc7
	ld (hl),30 ; [counter2]
	call _ecom_setRandomAngle		; $5fcb
++
	call _ecom_bounceOffWallsAndHoles		; $5fce
	call objectApplySpeed		; $5fd1
	jp enemyAnimate		; $5fd4


; Transforming back into stalfos
_blueStalfos_main_state17:
	ld a,Object.animParameter		; $5fd7
	call objectGetRelatedObject2Var		; $5fd9
	bit 7,(hl)		; $5fdc
	ret nz			; $5fde

	ld e,Enemy.collisionRadiusY		; $5fdf
	ld a,$08		; $5fe1
	ld (de),a		; $5fe3
	inc e			; $5fe4
	ld (de),a		; $5fe5

	call _blueStalfos_main_finishedAttack		; $5fe6
	ld a,SND_SCENT_SEED		; $5fe9
	call playSound		; $5feb
	jp objectSetVisible82		; $5fee


; Hitbox for the sickle (invisible)
_blueStalfos_subid2:
	ld a,(de)		; $5ff1
	sub $08			; $5ff2
	jr z,_blueStalfos_initSubid2Or3	; $5ff4

@state9:
	ld a,Object.id		; $5ff6
	call objectGetRelatedObject1Var		; $5ff8
	ld a,(hl)		; $5ffb
	cp ENEMYID_BLUE_STALFOS			; $5ffc
	jp nz,enemyDelete		; $5ffe

	; [this.collisionType] = [subid0.collisionType]
	ld l,Enemy.collisionType		; $6001
	ld e,l			; $6003
	ld a,(hl)		; $6004
	ld (de),a		; $6005

	; Set collision and hitbox based on [subid0.animParameter]
	ld l,Enemy.animParameter		; $6006
	ld a,(hl)		; $6008
	cp $ff			; $6009
	jr nz,+			; $600b
	ld a,$0c		; $600d
+
	ld bc,@positionAndHitboxTable		; $600f
	call addAToBc		; $6012

	ld l,Enemy.yh		; $6015
	ld e,l			; $6017
	ld a,(bc)		; $6018
	add (hl)		; $6019
	ld (de),a		; $601a

	inc bc			; $601b
	ld l,Enemy.xh		; $601c
	ld e,l			; $601e
	ld a,(bc)		; $601f
	add (hl)		; $6020
	ld (de),a		; $6021

	inc bc			; $6022
	ld e,Enemy.collisionRadiusY		; $6023
	ld a,(bc)		; $6025
	ld (de),a		; $6026

	inc bc			; $6027
	inc e			; $6028
	ld a,(bc)		; $6029
	ld (de),a		; $602a

	; If collision size is 0, disable collisions
	or a			; $602b
	ret nz			; $602c
	ld h,d			; $602d
	ld l,Enemy.collisionType		; $602e
	res 7,(hl)		; $6030
	ret			; $6032

; Data format:
;   b0: Y offset
;   b1: X offset
;   b2: collisionRadiusY
;   b3: collisionRadiusX
@positionAndHitboxTable:
	.db $04 $0d $08 $03
	.db $f0 $04 $03 $0a
	.db $0c $06 $14 $0c
	.db $14 $fc $04 $0a
	.db $f4 $0e $04 $06
	.db $f6 $0c $04 $06
	.db $f4 $0a $04 $06
	.db $f2 $0c $04 $06
	.db $00 $00 $00 $00


_blueStalfos_initSubid2Or3:
	ld h,d			; $6057
	ld l,e			; $6058
	inc (hl) ; [state]

	ld l,Enemy.enemyCollisionMode		; $605a
	ld (hl),ENEMYCOLLISION_BLUE_STALFOS_SICKLE		; $605c

	ld a,Object.zh		; $605e
	call objectGetRelatedObject1Var		; $6060
	ld e,l			; $6063
	ld a,(hl)		; $6064
	ld (de),a		; $6065
	ret			; $6066


; "Afterimage" of blue stalfos visible while moving
_blueStalfos_subid3:
	ld a,(de)		; $6067
	sub $08			; $6068
	jr z,@state8	; $606a

@state9:
	ld a,Object.id		; $606c
	call objectGetRelatedObject1Var		; $606e
	ld a,(hl)		; $6071
	cp ENEMYID_BLUE_STALFOS			; $6072
	jp nz,enemyDelete		; $6074

	ld l,Enemy.state		; $6077
	ld a,(hl)		; $6079
	cp $12			; $607a
	jp z,_blueStalfos_afterImage_resetPositionVars		; $607c

	cp $14			; $607f
	call nc,objectSetVisible82		; $6081

	; Calculate Y-diff, update var30 (last frame's Y-position)
	ld l,Enemy.yh		; $6084
	ld e,Enemy.var30		; $6086
	ld a,(de)		; $6088
	ld b,a			; $6089
	ld a,(hl)		; $608a
	sub b			; $608b
	add $08			; $608c
	and $0f			; $608e
	swap a			; $6090
	ld c,a			; $6092
	ldi a,(hl)		; $6093
	ld (de),a		; $6094

	; Calculate X-diff, update var31 (last frame's Y-position)
	inc l			; $6095
	inc e			; $6096
	ld a,(de)		; $6097
	ld b,a			; $6098
	ld a,(hl)		; $6099
	sub b			; $609a
	add $08			; $609b
	and $0f			; $609d
	or c			; $609f
	ld c,a			; $60a0
	ld a,(hl)		; $60a1
	ld (de),a		; $60a2

	; Write position difference to offset buffer
	ld e,Enemy.var32		; $60a3
	ld a,(de)		; $60a5
	add Enemy.var33			; $60a6
	ld e,a			; $60a8
	ld a,c			; $60a9
	ld (de),a		; $60aa

	; Increment index in offset buffer
	ld e,Enemy.var32		; $60ab
	ld a,(de)		; $60ad
	inc a			; $60ae
	and $07			; $60af
	ld (de),a		; $60b1

	; Don't draw if difference is 0
	add Enemy.var33			; $60b2
	ld e,a			; $60b4
	ld a,(de)		; $60b5
	cp $88			; $60b6
	ld b,a			; $60b8
	jp z,objectSetInvisible		; $60b9

	; Update position based on offset, draw afterimage
	ld h,d			; $60bc
	ld l,Enemy.yh		; $60bd
	and $f0			; $60bf
	swap a			; $60c1
	sub $08			; $60c3
	add (hl)		; $60c5
	ldi (hl),a		; $60c6
	inc l			; $60c7
	ld a,b			; $60c8
	and $0f			; $60c9
	sub $08			; $60cb
	add (hl)		; $60cd
	ld (hl),a		; $60ce

	jp _ecom_flickerVisibility		; $60cf

@state8:
	call _blueStalfos_initSubid2Or3		; $60d2
	call _blueStalfos_afterImage_resetPositionVars		; $60d5
	ld l,Enemy.collisionType		; $60d8
	res 7,(hl)		; $60da
	call objectSetVisible83		; $60dc
	jp objectSetInvisible		; $60df


;;
; Decides the next position for the blue stalfos. It will always choose a different
; quadrant of the screen from the one it's in already.
; @addr{60e2}
_blueStalfos_main_decideNextPosition:
	ld e,$03		; $60e2
	ld bc,$3030		; $60e4
	call _ecom_randomBitwiseAndBCE		; $60e7

	ld h,e			; $60ea
	ld l,$00		; $60eb
	ld e,Enemy.yh		; $60ed
	ld a,(de)		; $60ef
	cp (LARGE_ROOM_HEIGHT<<4)/2			; $60f0
	jr c,+			; $60f2
	ld l,$02		; $60f4
+
	ld e,Enemy.xh		; $60f6
	ld a,(de)		; $60f8
	cp (LARGE_ROOM_WIDTH<<4)/2			; $60f9
	jr c,+			; $60fb
	inc l			; $60fd
+
	ld a,l			; $60fe
	add a			; $60ff
	add a			; $6100
	add h			; $6101


;;
; @param	a	Position index to use
; @param	bc	Offset to be added to target position
; @addr{6102}
_blueStalfos_main_moveToQuadrant:
	ld hl,@quadrantList		; $6102
	rst_addAToHl			; $6105
	call @getLinkQuadrant		; $6106
	cp (hl)			; $6109
	jr z,@moveToLinksPosition	; $610a

	ld a,(hl)		; $610c
	ld hl,@targetPositions		; $610d
	rst_addAToHl			; $6110
	ld e,Enemy.var30		; $6111
	ldi a,(hl)		; $6113
	add b			; $6114
	ld (de),a		; $6115
	inc e			; $6116
	ld a,(hl)		; $6117
	add c			; $6118
	ld (de),a		; $6119
	ret			; $611a

@moveToLinksPosition:
	ld e,Enemy.var30		; $611b
	ldh a,(<hEnemyTargetY)	; $611d
	sub $14			; $611f
	ld (de),a		; $6121
	inc e			; $6122
	ldh a,(<hEnemyTargetX)	; $6123
	ld (de),a		; $6125
	ret			; $6126

;;
; @param[out]	a	The quadrant of the screen Link is in.
;			(0/2/4/6 for up/left, up/right, down/left, down/right)
; @addr{6127}
@getLinkQuadrant:
	ld e,$00		; $6127
	ldh a,(<hEnemyTargetY)	; $6129
	cp (LARGE_ROOM_HEIGHT<<4)/2			; $612b
	jr c,+			; $612d
	ld e,$02		; $612f
+
	ldh a,(<hEnemyTargetX)	; $6131
	cp (LARGE_ROOM_WIDTH<<4)/2			; $6133
	jr c,+			; $6135
	inc e			; $6137
+
	ld a,e			; $6138
	add a			; $6139
	ret			; $613a

@quadrantList:
	.db $02 $04 $06 $04 ; Currently in TL quadrant
	.db $00 $06 $04 $06 ; Currently in TR quadrant
	.db $00 $02 $06 $02 ; Currently in BL quadrant
	.db $00 $02 $04 $00 ; Currently in BR quadrant

@targetPositions:
	.dw $3828
	.dw $8828
	.dw $3868
	.dw $8868


;;
; @addr{6153}
_blueStalfos_main_accelerate:
	ld e,Enemy.counter1		; $6153
	ld a,(de)		; $6155
	or a			; $6156
	ret z			; $6157

	dec a			; $6158
	ld (de),a		; $6159

	and $03			; $615a
	ret nz			; $615c

	ld e,Enemy.speed		; $615d
	ld a,(de)		; $615f
	add SPEED_20			; $6160
	ld (de),a		; $6162
	ret			; $6163


;;
; @addr{6164}
_blueStalfos_afterImage_resetPositionVars:
	; [this.position] = [parent.position]
	; (Also copy position to var30/var31)
	ld l,Enemy.yh		; $6164
	ld e,l			; $6166
	ldi a,(hl)		; $6167
	ld (de),a		; $6168
	ld e,Enemy.var30		; $6169

	ld (de),a		; $616b
	inc l			; $616c
	ld e,l			; $616d
	ld a,(hl)		; $616e
	ld (de),a		; $616f
	ld e,Enemy.var31		; $6170
	ld (de),a		; $6172

	ld h,d			; $6173
	ld l,Enemy.var32		; $6174
	xor a			; $6176
	ldi (hl),a		; $6177

	; Initialize "position offset" buffer
	ld a,$88		; $6178
	ldi (hl),a		; $617a
	ldi (hl),a		; $617b
	ldi (hl),a		; $617c
	ldi (hl),a		; $617d
	ldi (hl),a		; $617e
	ldi (hl),a		; $617f
	ldi (hl),a		; $6180
	ld (hl),a		; $6181
	ret			; $6182

;;
; @addr{6183}
_blueStalfos_createPuff:
	ldbc INTERACID_PUFF,$02		; $6183
	call objectCreateInteraction		; $6186
	ret nz			; $6189

	ld a,h			; $618a
	ld h,d			; $618b
	ld l,Enemy.relatedObj2+1		; $618c
	ldd (hl),a		; $618e
	ld (hl),Interaction.start		; $618f
	ret			; $6191


; ==============================================================================
; ENEMYID_PUMPKIN_HEAD
;
; Variables (body, subid 1):
;   relatedObj1: Reference to ghost
;   relatedObj2: Reference to head
;   var30: Stomp counter (stops stomping when it reaches 0)
;
; Variables (ghost, subid 2):
;   relatedObj1: Reference to body
;   var33/var34: Head's position (where ghost is moving toward)
;
; Variables (head, subid 3):
;   relatedObj1: Reference to body
;   var31: Link's direction last frame
;   var32: Head's orientation when it was picked up
; ==============================================================================
enemyCode78:
	jr z,@normalStatus	; $6192
	sub ENEMYSTATUS_NO_HEALTH			; $6194
	ret c			; $6196
	jr z,@dead	; $6197
	jr @normalStatus		; $6199

@dead:
	call _pumpkinHead_noHealth		; $619b
	ret z			; $619e

@normalStatus:
	call _ecom_getSubidAndCpStateTo08		; $619f
	jr c,@commonState	; $61a2
	dec b			; $61a4
	ld a,b			; $61a5
	rst_jumpTable			; $61a6
	.dw _pumpkinHead_body
	.dw _pumpkinHead_ghost
	.dw _pumpkinHead_head

@commonState:
	rst_jumpTable			; $61ad
	.dw _pumpkinHead_state_uninitialized
	.dw _pumpkinHead_state_spawner
	.dw _pumpkinHead_state_grabbed
	.dw _pumpkinHead_state_stub
	.dw _pumpkinHead_state_stub
	.dw _pumpkinHead_state_stub
	.dw _pumpkinHead_state_stub
	.dw _pumpkinHead_state_stub


_pumpkinHead_state_uninitialized:
	ld a,b			; $61be
	or a			; $61bf
	jp nz,_ecom_setSpeedAndState8		; $61c0

	; Subid 0 (spawner)
	inc a			; $61c3
	ld (de),a ; [state] = 1
	ld a,ENEMYID_PUMPKIN_HEAD		; $61c5
	ld b,$00		; $61c7
	jp _enemyBoss_initializeRoom		; $61c9


_pumpkinHead_state_spawner:
	; Wait for doors to close
	ld a,($cc93)		; $61cc
	or a			; $61cf
	ret nz			; $61d0

	ld b,$03		; $61d1
	call checkBEnemySlotsAvailable		; $61d3
	ret nz			; $61d6

	; Spawn body
	ld b,ENEMYID_PUMPKIN_HEAD		; $61d7
	call _ecom_spawnUncountedEnemyWithSubid01		; $61d9
	call objectCopyPosition		; $61dc
	ld c,h			; $61df

	; Spawn ghost
	call _ecom_spawnUncountedEnemyWithSubid01		; $61e0
	call @commonInit		; $61e3

	ld l,Enemy.enabled		; $61e6
	ld e,l			; $61e8
	ld a,(de)		; $61e9
	ld (hl),a		; $61ea

	; [body.relatedObj1] = ghost
	ld a,h			; $61eb
	ld h,c			; $61ec
	ld l,Enemy.relatedObj1+1		; $61ed
	ldd (hl),a		; $61ef
	ld (hl),Enemy.start		; $61f0

	; Spawn head
	call _ecom_spawnUncountedEnemyWithSubid01		; $61f2
	inc (hl)		; $61f5
	call @commonInit		; $61f6

	; [body.relatedObj2] = head
	ld a,h			; $61f9
	ld h,c			; $61fa
	ld l,Enemy.relatedObj2+1		; $61fb
	ldd (hl),a		; $61fd
	ld (hl),Enemy.start		; $61fe

	; Delete spawner
	jp enemyDelete		; $6200

@commonInit:
	inc (hl) ; [subid]++

	; [relatedObj1] = body
	ld l,Enemy.relatedObj1		; $6204
	ld (hl),Enemy.start		; $6206
	inc l			; $6208
	ld (hl),c		; $6209

	jp objectCopyPosition		; $620a


_pumpkinHead_state_grabbed:
	inc e			; $620d
	ld a,(de)		; $620e
	rst_jumpTable			; $620f
	.dw @justGrabbed
	.dw @beingHeld
	.dw @released
	.dw @atRest

@justGrabbed:
	ld h,d			; $6218
	ld l,e			; $6219
	inc (hl) ; [state2]

	xor a			; $621b
	ld (wLinkGrabState2),a		; $621c

	ld l,Enemy.var31		; $621f
	ld a,(w1Link.direction)		; $6221
	ld (hl),a		; $6224

	ld l,Enemy.direction		; $6225
	ld e,Enemy.var32		; $6227
	ld a,(hl)		; $6229
	ld (de),a		; $622a

	; [ghost.state] = $13
	ld a,Object.relatedObj1+1		; $622b
	call objectGetRelatedObject1Var		; $622d
	ld h,(hl)		; $6230
	ld l,Enemy.state		; $6231
	ld a,(hl)		; $6233
	ld (hl),$13		; $6234

	cp $13			; $6236
	jr nc,++		; $6238
	ld l,Enemy.zh		; $623a
	ld (hl),$f8		; $623c
	ld l,Enemy.invincibilityCounter		; $623e
	ld (hl),$f4		; $6240
++
	jp objectSetVisiblec1		; $6242

@beingHeld:
	; Update animation based on Link's facing direction
	ld a,(w1Link.direction)		; $6245
	ld h,d			; $6248
	ld l,Enemy.var31		; $6249
	cp (hl)			; $624b
	ret z			; $624c

	ld (hl),a		; $624d

	ld l,Enemy.var32		; $624e
	add (hl)		; $6250
	and $03			; $6251
	add a			; $6253
	ld l,Enemy.direction		; $6254
	ld (hl),a		; $6256
	jp enemySetAnimation		; $6257

@released:
	ret			; $625a

@atRest:
	; [ghost.state] = $15
	ld a,Object.relatedObj1+1		; $625b
	call objectGetRelatedObject1Var		; $625d
	ld h,(hl)		; $6260
	ld l,Enemy.state		; $6261
	ld (hl),$15		; $6263

	; [head.state] = $16
	ld h,d			; $6265
	ld (hl),$16		; $6266

	jp objectSetVisiblec2		; $6268


_pumpkinHead_state_stub:
	ret			; $626b


_pumpkinHead_body:
	ld a,(de)		; $626c
	sub $08			; $626d
	rst_jumpTable			; $626f
	.dw _pumpkinHead_body_state08
	.dw _pumpkinHead_body_state09
	.dw _pumpkinHead_body_state0a
	.dw _pumpkinHead_body_state0b
	.dw _pumpkinHead_body_state0c
	.dw _pumpkinHead_body_state0d
	.dw _pumpkinHead_body_state0e
	.dw _pumpkinHead_body_state0f
	.dw _pumpkinHead_body_state10
	.dw _pumpkinHead_body_state11
	.dw _pumpkinHead_body_state12
	.dw _pumpkinHead_body_state13


; Initialization
_pumpkinHead_body_state08:
	ld bc,$0106		; $6288
	call _enemyBoss_spawnShadow		; $628b
	ret nz			; $628e

	ld h,d			; $628f
	ld l,e			; $6290
	inc (hl) ; [state]

	ld l,Enemy.oamFlags		; $6292
	ld a,$01		; $6294
	ldd (hl),a		; $6296
	ld (hl),a		; $6297

	call objectSetVisible83		; $6298

	ld c,$08		; $629b
	call _ecom_setZAboveScreen		; $629d

	ld a,$0d		; $62a0
	jp enemySetAnimation		; $62a2


; Falling from ceiling
_pumpkinHead_body_state09:
	ld c,$10		; $62a5
	call objectUpdateSpeedZ_paramC		; $62a7
	ret nz			; $62aa

	ld l,Enemy.state		; $62ab
	inc (hl)		; $62ad

	ld l,Enemy.counter1		; $62ae
	ld (hl),30		; $62b0

	ld l,Enemy.angle		; $62b2
	ld (hl),ANGLE_DOWN		; $62b4

	ld a,30		; $62b6

_pumpkinHead_body_shakeScreen:
	call setScreenShakeCounter		; $62b8
	ld a,SND_DOORCLOSE		; $62bb
	jp playSound		; $62bd


; Waiting for head to catch up with body
_pumpkinHead_body_state0a:
	ld a,Object.zh		; $62c0
	call objectGetRelatedObject2Var		; $62c2
	ld a,(hl)		; $62c5
	cp $f0			; $62c6
	ret c			; $62c8

	call _ecom_decCounter1		; $62c9
	ret nz			; $62cc

	call _pumpkinHead_body_chooseRandomStompTimerAndCount		; $62cd
	jr _pumpkinHead_body_beginMoving		; $62d0


; Walking around
_pumpkinHead_body_state0b:
	call pumpkinHead_body_countdownUntilStomp		; $62d2
	ret z			; $62d5

	call _ecom_decCounter1		; $62d6
	jr z,_pumpkinHead_body_chooseNextAction	; $62d9

	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $62db
	jr z,_pumpkinHead_body_chooseNextAction	; $62de

	jp enemyAnimate		; $62e0


_pumpkinHead_body_chooseNextAction:
	call objectGetAngleTowardEnemyTarget		; $62e3
	add $04			; $62e6
	and $18			; $62e8
	ld b,a			; $62ea

	ld e,Enemy.angle		; $62eb
	ld a,(de)		; $62ed
	cp b			; $62ee
	jr nz,_pumpkinHead_body_beginMoving	; $62ef

	; Currently facing toward Link. 1 in 4 chance of head firing projectiles.
	call getRandomNumber_noPreserveVars		; $62f1
	cp $40			; $62f4
	jr c,_pumpkinHead_body_beginMoving	; $62f6

	; Head will fire projectiles.
	call _ecom_incState		; $62f8
	ld l,Enemy.counter1		; $62fb
	ld (hl),$38		; $62fd

	; [head.state] = $0b
	ld a,Object.state		; $62ff
	call objectGetRelatedObject2Var		; $6301
	inc (hl)		; $6304

	jr _pumpkinHead_body_updateAnimationFromAngle		; $6305


; Head is firing projectiles; waiting for it to finish.
_pumpkinHead_body_state0c:
	call _ecom_decCounter1		; $6307
	ret nz			; $630a

_pumpkinHead_body_beginMoving:
	ld h,d			; $630b
	ld l,Enemy.state		; $630c
	ld (hl),$0b		; $630e

	ld l,Enemy.speed		; $6310
	ld (hl),SPEED_80		; $6312

	; Random duration of time to walk
	call getRandomNumber_noPreserveVars		; $6314
	and $0f			; $6317
	ld hl,_pumpkinHead_body_walkDurations		; $6319
	rst_addAToHl			; $631c
	ld e,Enemy.counter1		; $631d
	ld a,(hl)		; $631f
	ld (de),a		; $6320

	call _ecom_setRandomCardinalAngle		; $6321

_pumpkinHead_body_updateAnimationFromAngle:
	ld e,Enemy.angle		; $6324
	ld a,(de)		; $6326
	swap a			; $6327
	rlca			; $6329
	ld b,a			; $632a

	ld hl,_pumpkinHead_body_collisionRadiusXVals		; $632b
	rst_addAToHl			; $632e
	ld e,Enemy.collisionRadiusX		; $632f
	ld a,(hl)		; $6331
	ld (de),a		; $6332

	ld a,b			; $6333
	add $0b			; $6334
	jp enemySetAnimation		; $6336


_pumpkinHead_body_walkDurations:
	.db 30, 30, 60, 60, 60, 60,  60,  90
	.db 90, 90, 90, 90, 90, 120, 120, 120

_pumpkinHead_body_collisionRadiusXVals:
	.db $0c $08 $0c $08


; Preparing to stomp
_pumpkinHead_body_state0d:
	call _ecom_decCounter1		; $634d
	jr z,_pumpkinHead_body_beginStomp	; $6350

	ld a,(hl)		; $6352
	rrca			; $6353
	ret nc			; $6354
	call _ecom_updateCardinalAngleTowardTarget		; $6355
	jr _pumpkinHead_body_updateAnimationFromAngle		; $6358

_pumpkinHead_body_beginStomp:
	ld l,Enemy.state		; $635a
	ld (hl),$0e		; $635c

	ld l,Enemy.speedZ		; $635e
	ld a,<(-$3a0)		; $6360
	ldi (hl),a		; $6362
	ld (hl),>(-$3a0)		; $6363

	ld l,Enemy.speed		; $6365
	ld (hl),SPEED_100		; $6367

	; [ghost.state] = $0c
	ld a,Object.state		; $6369
	call objectGetRelatedObject1Var		; $636b
	ld (hl),$0c		; $636e

	; [head.state] = $0e
	ld a,Object.state		; $6370
	call objectGetRelatedObject2Var		; $6372
	ld (hl),$0e		; $6375

	; Update angle based on direction toward Link
	call _ecom_updateAngleTowardTarget		; $6377
	add $04			; $637a
	and $18			; $637c
	swap a			; $637e
	rlca			; $6380
	ld b,a			; $6381
	ld hl,_pumpkinHead_body_collisionRadiusXVals		; $6382
	rst_addAToHl			; $6385
	ld e,Enemy.collisionRadiusX		; $6386
	ld a,(hl)		; $6388
	ld (de),a		; $6389

	ld a,b			; $638a
	add $0b			; $638b
	call enemySetAnimation		; $638d
	jp objectSetVisible81		; $6390


; In midair during stomp
_pumpkinHead_body_state0e:
	ld c,$30		; $6393
	call objectUpdateSpeedZ_paramC		; $6395
	jp nz,_ecom_applyVelocityForSideviewEnemyNoHoles		; $6398

	; Hit ground

	ld l,Enemy.state		; $639b
	inc (hl)		; $639d

	ld e,Enemy.var30		; $639e
	ld a,(de)		; $63a0
	dec a			; $63a1
	ld a,15		; $63a2
	jr nz,+			; $63a4
	ld a,30		; $63a6
+
	ld l,Enemy.counter1		; $63a8
	ld (hl),a		; $63aa

	ld a,20		; $63ab
	call _pumpkinHead_body_shakeScreen		; $63ad
	jp objectSetVisible83		; $63b0


; Landed after a stomp
_pumpkinHead_body_state0f:
	call _ecom_decCounter1		; $63b3
	ret nz			; $63b6

	ld l,Enemy.var30		; $63b7
	dec (hl)		; $63b9
	jr nz,_pumpkinHead_body_beginStomp	; $63ba
	jp _pumpkinHead_body_beginMoving		; $63bc


; Body has been destroyed
_pumpkinHead_body_state10:
	ret			; $63bf


; Head has moved up, body will now regenerate
_pumpkinHead_body_state11:
	ld h,d			; $63c0
	ld l,e			; $63c1
	inc (hl) ; [state]

	ld l,Enemy.counter1		; $63c3
	ld (hl),$08		; $63c5
	ld l,Enemy.angle		; $63c7
	ld (hl),$10		; $63c9
	jp objectCreatePuff		; $63cb


; Delay before making body visible
_pumpkinHead_body_state12:
	call _ecom_decCounter1		; $63ce
	ret nz			; $63d1

	ld (hl),30 ; [counter1]
	ld l,e			; $63d4
	inc (hl) ; [state]

	call objectSetVisible83		; $63d6

	ld a,$0d		; $63d9
	jp enemySetAnimation		; $63db


; Body has regenerated, waiting a moment before resuming
_pumpkinHead_body_state13:
	call _ecom_decCounter1		; $63de
	ret nz			; $63e1

	ld l,Enemy.collisionType		; $63e2
	set 7,(hl)		; $63e4

	call _pumpkinHead_body_chooseRandomStompTimerAndCount		; $63e6
	jp _pumpkinHead_body_beginMoving		; $63e9


_pumpkinHead_ghost:
	ld a,(de)		; $63ec
	sub $08			; $63ed
	rst_jumpTable			; $63ef
	.dw _pumpkinHead_ghost_state08
	.dw _pumpkinHead_ghost_state09
	.dw _pumpkinHead_ghost_state0a
	.dw _pumpkinHead_ghost_state0b
	.dw _pumpkinHead_ghost_state0c
	.dw _pumpkinHead_ghost_state0d
	.dw _pumpkinHead_ghost_state0e
	.dw _pumpkinHead_ghost_state0f
	.dw _pumpkinHead_ghost_state10
	.dw _pumpkinHead_ghost_state11
	.dw _pumpkinHead_ghost_state12
	.dw _pumpkinHead_ghost_state13
	.dw _pumpkinHead_ghost_state14
	.dw _pumpkinHead_ghost_state15
	.dw _pumpkinHead_ghost_state16
	.dw _pumpkinHead_ghost_state17


; Initialization
_pumpkinHead_ghost_state08:
	ld h,d			; $6410
	ld l,e			; $6411
	inc (hl) ; [state]

	ld l,Enemy.enemyCollisionMode		; $6413
	ld (hl),ENEMYCOLLISION_PUMPKIN_HEAD_GHOST		; $6415

	ld l,Enemy.oamFlags		; $6417
	ld a,$05		; $6419
	ldd (hl),a		; $641b
	ld (hl),a		; $641c

	ld l,Enemy.collisionType		; $641d
	res 7,(hl)		; $641f

	ld l,Enemy.collisionRadiusY		; $6421
	ld a,$06		; $6423
	ldi (hl),a		; $6425
	ld (hl),a		; $6426

	call objectSetVisible83		; $6427
	ld c,$20		; $642a
	call _ecom_setZAboveScreen		; $642c

	ld a,$0a		; $642f
	jp enemySetAnimation		; $6431


; Falling from ceiling. (Also called by "head" state 9.)
_pumpkinHead_ghost_state09:
	ld c,$10		; $6434
	call objectUpdateSpeedZ_paramC		; $6436
	ld l,Enemy.zh		; $6439
	ld a,(hl)		; $643b
	cp $f0			; $643c
	ret c			; $643e

	ld (hl),$f0		; $643f
	ld l,Enemy.state		; $6441
	inc (hl)		; $6443
	ret			; $6444


; Waiting for head to fall into place
_pumpkinHead_ghost_state0a:
	; Check [head.zh]
	ld a,Object.relatedObj2+1		; $6445
	call objectGetRelatedObject1Var		; $6447
	ld h,(hl)		; $644a
	ld l,Enemy.zh		; $644b
	ld a,(hl)		; $644d
	cp $f0			; $644e
	ret nz			; $6450

	ld e,Enemy.state		; $6451
	ld a,$0b		; $6453
	ld (de),a		; $6455
	call objectSetInvisible		; $6456


; Copy body's position
_pumpkinHead_ghost_state0b:
	ld a,Object.enabled		; $6459
	call objectGetRelatedObject1Var		; $645b
	jp objectTakePosition		; $645e


; Body just began stomping; is moving upward
_pumpkinHead_ghost_state0c:
	call _pumpkinHead_ghostOrHead_updatePositionWhileStompingUp		; $6461
	ret nz			; $6464

	call _ecom_incState		; $6465
	ld l,Enemy.speedZ		; $6468
	xor a			; $646a
	ldi (hl),a		; $646b
	ld (hl),a		; $646c
	call objectSetVisible81		; $646d


; Body is stomping; moving downward
_pumpkinHead_ghost_state0d:
	ld c,$28		; $6470
	call _pumpkinHead_ghostOrHead_updatePositionWhileStompingDown		; $6472
	ret c			; $6475

	ld (hl),$f0 ; [zh]
	ld l,Enemy.state		; $6478
	inc (hl)		; $647a
	jp objectSetVisible83		; $647b


; Reached target z-position after stomping; waiting for head to catch up
_pumpkinHead_ghost_state0e:
	ld a,Object.relatedObj2+1		; $647e
	call objectGetRelatedObject1Var		; $6480
	ld h,(hl)		; $6483
	ld l,Enemy.zh		; $6484
	ld a,(hl)		; $6486
	cp $ee			; $6487
	ret c			; $6489

	ld e,Enemy.state		; $648a
	ld a,$0b		; $648c
	ld (de),a		; $648e
	jp objectSetInvisible		; $648f


; Body just destroyed
_pumpkinHead_ghost_state0f:
	ld h,d			; $6492
	ld l,e			; $6493
	inc (hl) ; [state]

	ld l,Enemy.speedZ		; $6495
	ld a,<(-$120)		; $6497
	ldi (hl),a		; $6499
	ld (hl),>(-$120)		; $649a

	jp objectSetInvisible		; $649c


; Falling to ground after body disappeared
_pumpkinHead_ghost_state10:
	ld c,$28		; $649f
	call objectUpdateSpeedZ_paramC		; $64a1
	ret nz			; $64a4

	ld l,Enemy.state		; $64a5
	inc (hl)		; $64a7
	ld l,Enemy.counter1		; $64a8
	ld (hl),$08		; $64aa
	ret			; $64ac


; Delay before going to next state?
_pumpkinHead_ghost_state11:
	call _ecom_decCounter1		; $64ad
	ret nz			; $64b0
	ld l,e			; $64b1
	inc (hl) ; [state]
	ret			; $64b3


; Waiting for head to be picked up
_pumpkinHead_ghost_state12:
	ret			; $64b4


; Link just grabbed the head; ghost runs away
_pumpkinHead_ghost_state13:
	ld h,d			; $64b5
	ld l,e			; $64b6
	inc (hl) ; [state]

	ld l,Enemy.counter1		; $64b8
	ld (hl),60		; $64ba

	ld l,Enemy.speed		; $64bc
	ld (hl),SPEED_140		; $64be
	ld l,Enemy.speedZ		; $64c0
	xor a			; $64c2
	ldi (hl),a		; $64c3
	ld (hl),a		; $64c4

	ld l,Enemy.collisionType		; $64c5
	set 7,(hl)		; $64c7
	call objectSetVisiblec2		; $64c9

	call _ecom_updateCardinalAngleAwayFromTarget		; $64cc

	ld a,$0a		; $64cf
	jp enemySetAnimation		; $64d1


; Falling to ground, then running away with angle computed earlier
_pumpkinHead_ghost_state14:
	ld c,$20		; $64d4
	call objectUpdateSpeedZ_paramC		; $64d6
	ret nz			; $64d9

	call _ecom_decCounter1		; $64da
	jr nz,++		; $64dd

	ld l,Enemy.state		; $64df
	inc (hl)		; $64e1
	call objectSetVisible82		; $64e2
++
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $64e5
	jp enemyAnimate		; $64e8


; Stopped running away, or head just landed on ground
_pumpkinHead_ghost_state15:
	ld h,d			; $64eb
	ld l,e			; $64ec
	inc (hl) ; [state]

	ld l,Enemy.counter1		; $64ee
	ld (hl),120		; $64f0
	ld a,$09		; $64f2
	jp enemySetAnimation		; $64f4


; After [counter1] frames, will choose which direction to move in next
_pumpkinHead_ghost_state16:
	call _ecom_decCounter1		; $64f7
	jr nz,@checkHeadOnGround	; $64fa

	ld (hl),60 ; [counter1]
	ld l,e			; $64fe
	dec (hl)		; $64ff
	dec (hl) ; [state] = $14

	call getRandomNumber_noPreserveVars		; $6501
	and $1c			; $6504
	ld e,Enemy.angle		; $6506
	ld (de),a		; $6508
	jr @setAnim		; $6509

@checkHeadOnGround:
	; Check [head.state] to see if head is at rest on the ground
	ld a,Object.relatedObj2+1		; $650b
	call objectGetRelatedObject1Var		; $650d
	ld h,(hl)		; $6510
	ld l,Enemy.state		; $6511
	ld a,(hl)		; $6513
	cp $02			; $6514
	jp z,enemyAnimate		; $6516

	ld h,d			; $6519
	inc (hl) ; [this.state]

	; Copy head's position, use that as target position to move toward.
	; [this.var33] = [head.yh]
	ld a,Object.relatedObj2+1		; $651b
	call objectGetRelatedObject1Var		; $651d
	ld h,(hl)		; $6520
	ld l,Enemy.yh		; $6521
	ld e,Enemy.var33		; $6523
	ldi a,(hl)		; $6525
	ld (de),a		; $6526

	; [this.var34] = [head.xh]
	inc l			; $6527
	inc e			; $6528
	ld a,(hl)		; $6529
	ld (de),a		; $652a

@setAnim:
	ld a,$0a		; $652b
	jp enemySetAnimation		; $652d


; Moving toward head (or where head used to be)
_pumpkinHead_ghost_state17:
	ld h,d			; $6530
	ld l,Enemy.var33		; $6531
	call _ecom_readPositionVars		; $6533
	sub c			; $6536
	add $08			; $6537
	cp $11			; $6539
	jr nc,@moveTowardHead	; $653b
	ldh a,(<hFF8F)	; $653d
	sub b			; $653f
	add $08			; $6540
	cp $11			; $6542
	jr nc,@moveTowardHead	; $6544

	; Reached head.

	; Check [head.state] to see if it's being held
	ld a,Object.relatedObj2+1		; $6546
	call objectGetRelatedObject1Var		; $6548
	ld h,(hl)		; $654b
	ld l,Enemy.state		; $654c
	ld a,(hl)		; $654e
	cp $02			; $654f
	ret z			; $6551

	ld (hl),$13 ; [head.state] = $13

	ld h,d			; $6554
	ld (hl),$0b ; [this.state] = $0b

	ld l,Enemy.collisionType		; $6557
	res 7,(hl)		; $6559
	jp objectSetInvisible		; $655b

@moveTowardHead:
	call _ecom_moveTowardPosition		; $655e
	jp enemyAnimate		; $6561


_pumpkinHead_head:
	ld a,(de)		; $6564
	sub $08			; $6565
	rst_jumpTable			; $6567
	.dw _pumpkinHead_head_state08
	.dw _pumpkinHead_head_state09
	.dw _pumpkinHead_head_state0a
	.dw _pumpkinHead_head_state0b
	.dw _pumpkinHead_head_state0c
	.dw _pumpkinHead_head_state0d
	.dw _pumpkinHead_head_state0e
	.dw _pumpkinHead_head_state0f
	.dw _pumpkinHead_head_state10
	.dw _pumpkinHead_head_state11
	.dw _pumpkinHead_head_state12
	.dw _pumpkinHead_head_state13
	.dw _pumpkinHead_head_state14
	.dw _pumpkinHead_head_state15
	.dw _pumpkinHead_head_state16


; Initialization
_pumpkinHead_head_state08:
	ld h,d			; $6586
	ld l,e			; $6587
	inc (hl) ; [state]

	ld l,Enemy.angle		; $6589
	ld (hl),$ff		; $658b

	ld l,Enemy.enemyCollisionMode		; $658d
	ld (hl),ENEMYCOLLISION_PUMPKIN_HEAD_HEAD		; $658f

	ld l,Enemy.collisionRadiusY		; $6591
	ld (hl),$06		; $6593

	call objectSetVisible82		; $6595
	ld c,$30		; $6598
	call _ecom_setZAboveScreen		; $659a

	ld a,$04		; $659d
	ld b,$00		; $659f

;;
; @addr{65a1}
_pumpkinHead_head_setAnimation:
	ld e,Enemy.direction		; $65a1
	ld (de),a		; $65a3
	add b			; $65a4
	ld b,a			; $65a5
	srl a			; $65a6
	ld hl,@collisionRadiusXVals		; $65a8
	rst_addAToHl			; $65ab
	ld e,Enemy.collisionRadiusX		; $65ac
	ld a,(hl)		; $65ae
	ld (de),a		; $65af
	ld a,b			; $65b0
	jp enemySetAnimation		; $65b1

@collisionRadiusXVals:
	.db $08 $06 $08 $06


_pumpkinHead_head_state09:
	call _pumpkinHead_ghost_state09		; $65b8
	ret c			; $65bb

	ld a,MUS_BOSS		; $65bc
	ld (wActiveMusic),a		; $65be
	jp playSound		; $65c1


; Head follows body. Called by other states.
_pumpkinHead_head_state0a:
	call objectSetPriorityRelativeToLink		; $65c4

	ld a,Object.animParameter		; $65c7
	call objectGetRelatedObject1Var		; $65c9
	ld a,(hl)		; $65cc
	push hl			; $65cd
	ld hl,@headZOffsets		; $65ce
	rst_addAToHl			; $65d1
	ldi a,(hl)		; $65d2
	ld c,a			; $65d3
	ld b,$00		; $65d4
	ld a,(hl)		; $65d6
	pop hl			; $65d7
	push af			; $65d8
	call objectTakePositionWithOffset		; $65d9

	pop af			; $65dc
	ld e,Enemy.zh		; $65dd
	ld (de),a		; $65df

	; Check whether body's angle is different from head's angle
	ld l,Enemy.angle		; $65e0
	ld e,l			; $65e2
	ld a,(de)		; $65e3
	cp (hl)			; $65e4
	jp z,enemyAnimate		; $65e5

	ld a,(hl)		; $65e8
	ld (de),a		; $65e9
	rrca			; $65ea
	rrca			; $65eb
	ld b,$00		; $65ec
	jr _pumpkinHead_head_setAnimation		; $65ee

; Offsets for head relative to body. Indexed by body's animParameter.
;   b0: Y offset
;   b1: Z position
@headZOffsets:
	.db $00 $f0
	.db $01 $f0
	.db $00 $ef


; Preparing to fire projectiles
_pumpkinHead_head_state0b:
	ld h,d			; $65f6
	ld l,e			; $65f7
	inc (hl) ; [state]

	ld l,Enemy.counter1		; $65f9
	ld (hl),20		; $65fb

	call _pumpkinHead_head_state0a		; $65fd

	ld e,Enemy.angle		; $6600
	ld a,(de)		; $6602
	rrca			; $6603
	rrca			; $6604
	ld b,$01		; $6605
	jp _pumpkinHead_head_setAnimation		; $6607


; Delay before firing projectile
_pumpkinHead_head_state0c:
	call _ecom_decCounter1		; $660a
	jp nz,objectSetPriorityRelativeToLink		; $660d

	; Fire projectile
	ld (hl),36 ; [counter1]
	ld l,e			; $6612
	inc (hl) ; [state]

	ld l,Enemy.angle		; $6614
	ld a,(hl)		; $6616
	rrca			; $6617
	rrca			; $6618
	ld b,$00		; $6619
	call _pumpkinHead_head_setAnimation		; $661b
	call getFreePartSlot		; $661e
	ret nz			; $6621

	ld (hl),PARTID_PUMPKIN_HEAD_PROJECTILE		; $6622
	ld l,Part.angle		; $6624
	ld e,Enemy.angle		; $6626
	ld a,(de)		; $6628
	ld (hl),a		; $6629
	call objectCopyPosition		; $662a

	ld a,SND_VERAN_FAIRY_ATTACK		; $662d
	jp playSound		; $662f


; Delay after firing projectile
_pumpkinHead_head_state0d:
	call _ecom_decCounter1		; $6632
	jp nz,objectSetPriorityRelativeToLink		; $6635

	ld l,e			; $6638
	ld (hl),$0a ; [state]
	jr _pumpkinHead_head_state0a		; $663b


; Began a stomp; moving up
_pumpkinHead_head_state0e:
	call _pumpkinHead_ghostOrHead_updatePositionWhileStompingUp		; $663d
	jr z,@movingDown	; $6640

	; Update angle
	ld l,Enemy.angle		; $6642
	ld e,l			; $6644
	ld a,(de)		; $6645
	cp (hl)			; $6646
	ret z			; $6647
	ld a,(hl)		; $6648
	ld (de),a		; $6649
	add $04			; $664a
	and $18			; $664c
	rrca			; $664e
	rrca			; $664f
	ld b,$00		; $6650
	jp _pumpkinHead_head_setAnimation		; $6652

@movingDown:
	call _ecom_incState		; $6655
	ld l,Enemy.speedZ		; $6658
	xor a			; $665a
	ldi (hl),a		; $665b
	ld (hl),a		; $665c
	call objectSetVisible80		; $665d


; Body is stomping; moving down
_pumpkinHead_head_state0f:
	ld c,$20		; $6660
	call _pumpkinHead_ghostOrHead_updatePositionWhileStompingDown		; $6662
	ret c			; $6665

	; Reached target position
	ld (hl),$f0 ; [zh]
	ld l,Enemy.state		; $6668
	ld (hl),$0a		; $666a
	jp objectSetVisible82		; $666c


; Body just destroyed
_pumpkinHead_head_state10:
	ld h,d			; $666f
	ld l,e			; $6670
	inc (hl) ; [state]

	ld l,Enemy.speedZ		; $6672
	ld a,<(-$120)		; $6674
	ldi (hl),a		; $6676
	ld (hl),>(-$120)		; $6677
	jp objectSetVisiblec2		; $6679


; Head falling down after body destroyed
_pumpkinHead_head_state11:
	ld c,$20		; $667c
	call objectUpdateSpeedZ_paramC		; $667e
	ret nz			; $6681

	ld l,Enemy.state		; $6682
	inc (hl)		; $6684
	ld l,Enemy.counter1		; $6685
	ld (hl),120		; $6687
	ret			; $6689


; Head is grabbable for 120 frames
_pumpkinHead_head_state12:
	call _ecom_decCounter1		; $668a
	jp nz,_pumpkinHead_head_state16		; $668d

	ld l,e			; $6690
	inc (hl) ; [state]

	; [ghost.state] = $0b
	ld a,Object.relatedObj1+1		; $6692
	call objectGetRelatedObject1Var		; $6694
	ld h,(hl)		; $6697
	ld l,Enemy.state		; $6698
	ld (hl),$0b		; $669a
	ret			; $669c


; Ghost just re-entered head, or head timed out before Link grabbed it
_pumpkinHead_head_state13:
	ld h,d			; $669d
	ld l,e			; $669e
	inc (hl) ; [state]

	ld l,Enemy.counter1		; $66a0
	ld (hl),$10		; $66a2

	ld l,Enemy.collisionRadiusX		; $66a4
	ld (hl),$0a		; $66a6

	ld a,$08		; $66a8
	jp enemySetAnimation		; $66aa


; Delay before moving back up, respawning body
_pumpkinHead_head_state14:
	call _ecom_decCounter1		; $66ad
	ret nz			; $66b0

	ld l,e			; $66b1
	inc (hl) ; [state]

	ld l,Enemy.speedZ		; $66b3
	ld a,<(-$200)		; $66b5
	ldi (hl),a		; $66b7
	ld (hl),>(-$200)		; $66b8

	ld l,Enemy.collisionRadiusX		; $66ba
	ld (hl),$06		; $66bc
	ld a,$04		; $66be
	jp enemySetAnimation		; $66c0


; Head moving up
_pumpkinHead_head_state15:
	ld c,$20		; $66c3
	call objectUpdateSpeedZ_paramC		; $66c5

	ld l,Enemy.zh		; $66c8
	ld a,(hl)		; $66ca
	cp $f1			; $66cb
	ret nc			; $66cd

	; Head has gone up high enough; respawn body now.

	ld (hl),$f0 ; [zh]

	ld l,Enemy.state		; $66d0
	ld (hl),$0a		; $66d2

	ld l,Enemy.collisionRadiusX		; $66d4
	ld (hl),$0c		; $66d6

	call objectSetVisible82		; $66d8

	; [body.state] = $11
	ld a,Object.state		; $66db
	call objectGetRelatedObject1Var		; $66dd
	ld (hl),$11		; $66e0

	; Copy head's position to ghost
	call objectCopyPosition		; $66e2

	; [ghost.zh]
	ld l,Enemy.zh		; $66e5
	ld (hl),$00		; $66e7

	ld a,$04		; $66e9
	ld b,$00		; $66eb
	jp _pumpkinHead_head_setAnimation		; $66ed


; Head has just come to rest after being thrown.
; Called by other states (to make it grabbable).
_pumpkinHead_head_state16:
	ld a,Object.health		; $66f0
	call objectGetRelatedObject1Var		; $66f2
	ld a,(hl)		; $66f5
	or a			; $66f6
	ret z			; $66f7
	call objectAddToGrabbableObjectBuffer		; $66f8
	jp objectPushLinkAwayOnCollision		; $66fb


;;
; @param[out]	zflag	z if time to stomp
; @addr{66fe}
pumpkinHead_body_countdownUntilStomp:
	ld a,(wFrameCounter)		; $66fe
	rrca			; $6701
	ret c			; $6702
	call _ecom_decCounter2		; $6703
	ret nz			; $6706

	ld l,Enemy.state		; $6707
	ld (hl),$0d		; $6709
	ld l,Enemy.counter1		; $670b
	ld (hl),60		; $670d

;;
; Randomly sets the duration until a stomp occurs, and the number of stomps to perform.
; @addr{670f}
_pumpkinHead_body_chooseRandomStompTimerAndCount:
	ld bc,$0701		; $670f
	call _ecom_randomBitwiseAndBCE		; $6712
	ld a,b			; $6715
	ld hl,@counter2Vals		; $6716
	rst_addAToHl			; $6719

	ld e,Enemy.counter2		; $671a
	ld a,(hl)		; $671c
	ld (de),a		; $671d

	ld e,Enemy.var30		; $671e
	ld a,c			; $6720
	add $02			; $6721
	ld (de),a		; $6723
	xor a			; $6724
	ret			; $6725

@counter2Vals:
	.db 90, 120, 120, 120, 150, 150, 150, 180

;;
; @param[out]	zflag	z if body is moving down
; @addr{672e}
_pumpkinHead_ghostOrHead_updatePositionWhileStompingUp:
	ld a,Object.speedZ+1		; $672e
	call objectGetRelatedObject1Var		; $6730
	bit 7,(hl)		; $6733
	ret z			; $6735

	call objectTakePosition		; $6736
	ld e,Enemy.zh		; $6739
	ld a,(de)		; $673b
	sub $10			; $673c
	ld (de),a		; $673e
	ret			; $673f

;;
; @param	c	Gravity
; @param[out]	hl	Enemy.zh
; @param[out]	cflag	nc if reached target z-position
; @addr{6740}
_pumpkinHead_ghostOrHead_updatePositionWhileStompingDown:
	call objectUpdateSpeedZ_paramC		; $6740
	ld l,Enemy.zh		; $6743
	ld a,(hl)		; $6745
	cp $f0			; $6746
	ret nc			; $6748

	push af			; $6749
	ld a,Object.enabled		; $674a
	call objectGetRelatedObject1Var		; $674c
	call objectTakePosition		; $674f
	pop af			; $6752
	ld e,Enemy.zh		; $6753
	ld (de),a		; $6755
	ret			; $6756


;;
; @addr{6757}
_pumpkinHead_noHealth:
	ld e,Enemy.subid		; $6757
	ld a,(de)		; $6759
	dec a			; $675a
	jr z,@bodyHealthZero	; $675b
	dec a			; $675d
	jr z,@ghostHealthZero	; $675e

@headHealthZero:
	call objectCreatePuff		; $6760
	ld h,d			; $6763
	ld l,Enemy.state		; $6764
	ldi a,(hl)		; $6766
	cp $02			; $6767
	jr nz,@delete	; $6769

	ld a,(hl) ; [state2]
	cp $02			; $676c
	call c,dropLinkHeldItem		; $676e
@delete:
	jp enemyDelete		; $6771

@ghostHealthZero:
	ld e,Enemy.collisionType		; $6774
	ld a,(de)		; $6776
	or a			; $6777
	jr nz,++		; $6778
	call _ecom_killRelatedObj1		; $677a
	ld l,Enemy.relatedObj2+1		; $677d
	ld h,(hl)		; $677f
	call _ecom_killObjectH		; $6780
++
	call _enemyBoss_dead		; $6783
	xor a			; $6786
	ret			; $6787

@bodyHealthZero:
	; Delete self if ghost's health is 0
	ld a,Object.health		; $6788
	call objectGetRelatedObject1Var		; $678a
	ld a,(hl)		; $678d
	or a			; $678e
	jp z,enemyDelete		; $678f

	; Otherwise, the body just disappears temporarily
	ld h,d			; $6792
	ld l,Enemy.health		; $6793
	ld (hl),$08		; $6795

	ld l,Enemy.state		; $6797
	ld (hl),$10		; $6799

	ld l,Enemy.zh		; $679b
	ld (hl),$00		; $679d

	; [ghost.state] = $0f
	ld a,Object.state		; $679f
	call objectGetRelatedObject1Var		; $67a1
	ld (hl),$0f		; $67a4

	; [head.state] = $10
	ld a,Object.state		; $67a6
	call objectGetRelatedObject2Var		; $67a8
	ld (hl),$10		; $67ab

	call objectCreatePuff		; $67ad
	jp objectSetInvisible		; $67b0


; ==============================================================================
; ENEMYID_HEAD_THWOMP
;
; Variables:
;   direction: Current animation. Even numbers are face colors; odd numbers are
;              transitions.
;   var30: "Spin counter" used when bomb is thrown into head
;   var31: Which head the thwomp will settle on after throwing bomb in?
;   var32: Bit 0 triggers the effect of a bomb being thrown into head thwomp.
;   var33: ?
;   var34: Counter which determines when head thwomp starts shooting fireballs / bombs
; ==============================================================================
enemyCode79:
	jr z,@normalStatus	; $67b3
	sub ENEMYSTATUS_NO_HEALTH			; $67b5
	ret c			; $67b7
	jp z,_enemyBoss_dead		; $67b8

@normalStatus:
	ld e,Enemy.state		; $67bb
	ld a,(de)		; $67bd
	rst_jumpTable			; $67be
	.dw _headThwomp_state_uninitialized
	.dw _headThwomp_state_stub
	.dw _headThwomp_state_stub
	.dw _headThwomp_state_stub
	.dw _headThwomp_state_stub
	.dw _headThwomp_state_stub
	.dw _headThwomp_state_stub
	.dw _headThwomp_state_stub
	.dw _headThwomp_state8
	.dw _headThwomp_state9
	.dw _headThwomp_stateA
	.dw _headThwomp_stateB
	.dw _headThwomp_stateC
	.dw _headThwomp_stateD
	.dw _headThwomp_stateE
	.dw _headThwomp_stateF
	.dw _headThwomp_state10
	.dw _headThwomp_state11


_headThwomp_state_uninitialized:
	ld a,ENEMYID_HEAD_THWOMP		; $67e3
	ld b,PALH_81		; $67e5
	call _enemyBoss_initializeRoom		; $67e7

	call _ecom_setSpeedAndState8		; $67ea
	ld l,Enemy.counter1		; $67ed
	ld (hl),18		; $67ef

	call _headThwomp_setSolidTilesAroundSelf		; $67f1
	jp objectSetVisible80		; $67f4


_headThwomp_state_stub:
	ret			; $67f7


; Waiting for Link to move up for fight to start
_headThwomp_state8:
	ld a,(w1Link.yh)		; $67f8
	cp $9c			; $67fb
	ret nc			; $67fd

	ld c,$a4		; $67fe
	ld a,$3d		; $6800
	call setTile		; $6802

	ld a,SND_DOORCLOSE		; $6805
	call playSound		; $6807

	ld a,$98		; $680a
	ld (wLinkLocalRespawnY),a		; $680c
	ld a,$48		; $680f
	ld (wLinkLocalRespawnX),a		; $6811

	call _ecom_incState		; $6814

	ld l,Enemy.var34		; $6817
	ld (hl),$f0		; $6819

	call _enemyBoss_beginBoss		; $681b


; Spinning normally
_headThwomp_state9:
	call _headThwomp_checkBombThrownIntoHead		; $681e
	ret nz			; $6821

	call _headThwomp_checkShootProjectile		; $6822

	; Update rotation
	call _ecom_decCounter1		; $6825
	ret nz			; $6828

	ld e,Enemy.health		; $6829
	ld a,(de)		; $682b
	dec a			; $682c
	ld bc,@rotationSpeeds		; $682d
	call addDoubleIndexToBc		; $6830

	ld e,Enemy.direction		; $6833
	ld a,(de)		; $6835
	inc a			; $6836
	and $07			; $6837
	ld (de),a		; $6839
	rrca			; $683a
	jr nc,+			; $683b
	inc bc			; $683d
+
	ld a,(bc)		; $683e
	ld (hl),a		; $683f
	ld a,SND_CLINK2		; $6840
	call c,playSound		; $6842
	ld a,(de)		; $6845
	jp enemySetAnimation		; $6846

@rotationSpeeds:
	.db $11 $07 ; $01 == [health]
	.db $14 $08 ; $02
	.db $17 $0a ; $03
	.db $1a $0b ; $04


; Bomb just thrown into head thwomp
_headThwomp_stateA:
	call _ecom_decCounter1		; $6851
	jp nz,enemyAnimate		; $6854

	ld l,e			; $6857
	inc (hl) ; [state]
	inc l			; $6859
	ld (hl),$00 ; [state2]
	ret			; $685c


; Spinning after bomb was thrown into head
_headThwomp_stateB:
	inc e			; $685d
	ld a,(de) ; [state2]
	rst_jumpTable			; $685f
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate0:
	ld h,d			; $6868
	ld l,e			; $6869
	inc (hl) ; [state2]
	inc l			; $686b
	ld (hl),60 ; [counter1]

; Spinning at max speed
@substate1:
	call _ecom_decCounter1		; $686e
	ld b,$08		; $6871
	jp nz,_headThwomp_rotate		; $6873

	ld l,e			; $6876
	inc (hl) ; [state2]
	inc l			; $6878
	ld (hl),$01 ; [counter1]
	inc l			; $687b
	ld (hl),$02 ; [counter2]

	ld l,Enemy.var30		; $687e
	ld (hl),$01		; $6880

; Slower spinning
@substate2:
	call _ecom_decCounter1		; $6882
	ret nz			; $6885

	inc l			; $6886
	dec (hl) ; [counter2]
	jr nz,++		; $6888

	ld (hl),$02		; $688a
	ld l,Enemy.var30		; $688c
	inc (hl)		; $688e
	ld a,(hl)		; $688f
	cp $12			; $6890
	jr nc,@startSlowestSpinning	; $6892
++
	ld l,Enemy.var30		; $6894
	ld a,(hl)		; $6896
	ld l,Enemy.counter1		; $6897
	ld (hl),a		; $6899
	ld b,$08		; $689a
	jp _headThwomp_rotate		; $689c

@startSlowestSpinning:
	ld l,Enemy.counter1		; $689f
	ld (hl),$01		; $68a1
	inc l			; $68a3
	ld (hl),$06 ; [counter2]
	ld l,e			; $68a6
	inc (hl) ; [state2]

; Slowest spinning; will stop when it reaches the target head
@substate3:
	call _ecom_decCounter1		; $68a8
	ret nz			; $68ab

	inc l			; $68ac
	ld a,(hl) ; [counter2]
	add $0c			; $68ae
	ldd (hl),a ; [counter2]
	ld (hl),a  ; [counter1]

	; Continue rotating if head color is wrong
	ld l,Enemy.direction		; $68b2
	ld a,(hl)		; $68b4
	ld l,Enemy.var31		; $68b5
	cp (hl)			; $68b7
	ld b,$08		; $68b8
	jp nz,_headThwomp_rotate		; $68ba

	ld l,Enemy.state		; $68bd
	inc (hl)		; $68bf
	ld l,Enemy.counter1		; $68c0
	ld (hl),$10		; $68c2
	ret			; $68c4


; Just reached the target head color
_headThwomp_stateC:
	call _ecom_decCounter1		; $68c5
	ret nz			; $68c8

	; Set state to number from $0d-$10 based on head color
	ld l,Enemy.direction		; $68c9
	ld a,(hl)		; $68cb
	srl a			; $68cc
	inc a			; $68ce
	ld l,e ; [state]
	add (hl)		; $68d0
	ld (hl),a		; $68d1

	inc l			; $68d2
	ld (hl),$00 ; [state2]
	ret			; $68d5


; Green face (shoots fireballs)
_headThwomp_stateD:
	inc e			; $68d6
	ld a,(de) ; [state2]
	or a			; $68d8
	jr nz,@substate1	; $68d9

@substate0:
	ld h,d			; $68db
	ld l,e			; $68dc
	inc (hl) ; [state2]

	inc l			; $68de
	ld (hl),$f0 ; [counter1]

	ld hl,wRoomCollisions+$47		; $68e1
	ld (hl),$00		; $68e4
	ret			; $68e6

@substate1:
	call _headThwomp_checkBombThrownIntoHead		; $68e7
	ret nz			; $68ea

	call _ecom_decCounter1		; $68eb
	jr z,@resumeSpinning	; $68ee

	ld a,(hl)		; $68f0
	cp 210			; $68f1
	call nc,enemyAnimate		; $68f3

	ld e,$c6		; $68f6
	ld a,(hl)		; $68f8
	and $1f			; $68f9
	ret nz			; $68fb
	ld b,PARTID_HEAD_THWOMP_FIREBALL		; $68fc
	jp _ecom_spawnProjectile		; $68fe

@resumeSpinning:
	ld l,Enemy.state		; $6901
	ld (hl),$11		; $6903
	ld l,Enemy.counter1		; $6905
	ld (hl),$01		; $6907
	ret			; $6909


; Blue face (fires circular projectiles)
_headThwomp_stateE:
	inc e			; $690a
	ld a,(de)		; $690b
	rst_jumpTable			; $690c
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate0:
	ld h,d			; $6915
	ld l,e			; $6916
	inc (hl) ; [state2]

	inc l			; $6918
	ld a,$08		; $6919
	ldi (hl),a ; [counter1]
	ld (hl),a  ; [counter2] (number of times to fire)

	call getRandomNumber_noPreserveVars		; $691d
	and $02			; $6920
	jr nz,+			; $6922
	ld a,$fe		; $6924
+
	ld e,Enemy.var33		; $6926
	ld (de),a		; $6928
	ld hl,wRoomCollisions+$47		; $6929
	ld (hl),$00		; $692c
	ret			; $692e

; Waiting a moment before starting to fire
@substate1:
	call _headThwomp_checkBombThrownIntoHead		; $692f
	ret nz			; $6932
	call _ecom_decCounter1		; $6933
	jp nz,enemyAnimate		; $6936

	ld (hl),$08 ; [counter1]
	ld l,Enemy.state2		; $693b
	inc (hl)		; $693d

	ld hl,wRoomCollisions+$47		; $693e
	ld (hl),$03		; $6941

	call getFreePartSlot		; $6943
	jr nz,++		; $6946
	ld (hl),PARTID_3c		; $6948
	inc l			; $694a
	ld e,Enemy.var33		; $694b
	ld a,(de)		; $694d
	ld (hl),a ; [part.subid]
	ld bc,$f800		; $694f
	call objectCopyPositionWithOffset		; $6952
++
	ld e,Enemy.direction		; $6955
	ld a,(de)		; $6957
	jp enemySetAnimation		; $6958

; Cooldown after firing
@substate2:
	call _ecom_decCounter1		; $695b
	jp nz,enemyAnimate		; $695e

	ld (hl),30 ; [counter1]
	ld l,e			; $6963
	inc (hl) ; [state2]
	ret			; $6965

; Cooldown after firing; checks whether to fire again or return to normal state
@substate3:
	call _ecom_decCounter1		; $6966
	ret nz			; $6969

	inc l			; $696a
	dec (hl) ; [counter2]
	jr z,@resumeSpinning	; $696c

	; Fire again
	ld l,e			; $696e
	ld (hl),$01 ; [state2]
	ld a,$08		; $6971
	jr ++			; $6973

@resumeSpinning:
	ld l,Enemy.state		; $6975
	ld (hl),$11		; $6977

	ld a,$10		; $6979
++
	ld l,Enemy.counter1		; $697b
	ld (hl),a		; $697d

	ld hl,wRoomCollisions+$47		; $697e
	ld (hl),$00		; $6981
	ld e,Enemy.direction		; $6983
	ld a,(de)		; $6985
	add $08			; $6986
	jp enemySetAnimation		; $6988


; Purple face (stomps the ground)
_headThwomp_stateF:
	inc e			; $698b
	ld a,(de) ; [state2]
	rst_jumpTable			; $698d
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4

@substate0:
	ld h,d			; $6998
	ld l,e			; $6999
	inc (hl) ; [state2]

	ld l,Enemy.speedZ		; $699b
	xor a			; $699d
	ldi (hl),a		; $699e
	ld (hl),$02		; $699f
	jp _headThwomp_unsetSolidTilesAroundSelf		; $69a1

; Falling
@substate1:
	ld a,$20		; $69a4
	call objectUpdateSpeedZ_sidescroll		; $69a6

	ld e,Enemy.yh		; $69a9
	ld a,(de)		; $69ab
	cp $90			; $69ac
	ret c			; $69ae

	ld h,d			; $69af
	ld l,Enemy.state2		; $69b0
	inc (hl)		; $69b2

	inc l			; $69b3
	ld (hl),120 ; [counter1]

@poundGround: ; Also used by death code
	ld a,60		; $69b6
	ld (wScreenShakeCounterY),a		; $69b8

	ld a,SND_STRONG_POUND		; $69bb
	jp playSound		; $69bd

; Resting on ground
@substate2:
	call _ecom_decCounter1		; $69c0
	jr z,@beginMovingUp	; $69c3

	ld a,(hl) ; [counter1]
	cp 30			; $69c6
	ret c			; $69c8

	; Spawn falling rocks every 16 frames
	and $0f			; $69c9
	ret nz			; $69cb
	call getFreePartSlot		; $69cc
	ret nz			; $69cf
	ld (hl),PARTID_3b		; $69d0
	ret			; $69d2

@beginMovingUp:
	ld l,e			; $69d3
	inc (hl) ; [state2]
	ret			; $69d5

; Moving back up
@substate3:
	ld h,d			; $69d6
	ld l,Enemy.y		; $69d7
	ld a,(hl)		; $69d9
	sub <($0080)			; $69da
	ldi (hl),a		; $69dc
	ld a,(hl)		; $69dd
	sbc >($0080)			; $69de
	ld (hl),a		; $69e0

	cp $56			; $69e1
	ret nz			; $69e3
	ld l,e			; $69e4
	inc (hl) ; [state2]
	ret			; $69e6

; Reached original position
@substate4:
	; Don't set tile solidity as long as Link is within 16 pixels (wouldn't want him
	; to get stuck)
	ld h,d			; $69e7
	ld l,Enemy.yh		; $69e8
	ld a,(w1Link.yh)		; $69ea
	sub (hl)		; $69ed
	add $10			; $69ee
	cp $21			; $69f0
	jr nc,@setSolidity	; $69f2

	ld l,Enemy.xh		; $69f4
	ld a,(w1Link.xh)		; $69f6
	sub (hl)		; $69f9
	add $10			; $69fa
	cp $21			; $69fc
	ret c			; $69fe

@setSolidity:
	ld l,Enemy.state		; $69ff
	ld (hl),$11		; $6a01
	ld l,Enemy.counter1		; $6a03
	ld (hl),$10		; $6a05
	jp _headThwomp_setSolidTilesAroundSelf		; $6a07


; Red face (takes damage)
_headThwomp_state10:
	inc e			; $6a0a
	ld a,(de) ; [state2]
	or a			; $6a0c
	jr nz,@substate1	; $6a0d

@substate0:
	ld h,d			; $6a0f
	ld l,e			; $6a10
	inc (hl) ; [state2]

	inc l			; $6a12
	ld (hl),120 ; [counter1]

	ld l,Enemy.invincibilityCounter		; $6a15
	ld (hl),$18		; $6a17

	ld l,Enemy.health		; $6a19
	dec (hl)		; $6a1b
	jr nz,++		; $6a1c

	; He's dead
	dec (hl)		; $6a1e
	call _headThwomp_unsetSolidTilesAroundSelf		; $6a1f
	ld a,TREE_GFXH_01		; $6a22
	ld (wLoadedTreeGfxIndex),a		; $6a24
++
	ld e,Enemy.health		; $6a27
	ld a,(de)		; $6a29
	inc a			; $6a2a
	call nz,_headThwomp_dropHeart		; $6a2b

	ld a,$10		; $6a2e
	call enemySetAnimation		; $6a30
	ld a,SND_BOSS_DAMAGE		; $6a33
	jp playSound		; $6a35

@substate1:
	call _ecom_decCounter1		; $6a38
	jr z,@resumeSpinning	; $6a3b

	; Run below code only if he's dead
	ld e,Enemy.health		; $6a3d
	ld a,(de)		; $6a3f
	inc a			; $6a40
	ret nz			; $6a41

	ld (hl),$ff		; $6a42

	ld a,$20		; $6a44
	call objectUpdateSpeedZ_sidescroll		; $6a46

	ld e,Enemy.yh		; $6a49
	ld a,(de)		; $6a4b
	cp $90			; $6a4c
	ret c			; $6a4e

	; Trigger generic "boss death" code by setting health to 0 for real
	ld h,d			; $6a4f
	ld l,Enemy.health		; $6a50
	ld (hl),$00		; $6a52
	jp _headThwomp_stateF@poundGround		; $6a54

@resumeSpinning:
	ld l,Enemy.state		; $6a57
	ld (hl),$11		; $6a59

	ld l,Enemy.counter1		; $6a5b
	ld (hl),$10		; $6a5d

	ld hl,wRoomCollisions+$47		; $6a5f
	ld (hl),$00		; $6a62

	ld a,$0e		; $6a64
	jp enemySetAnimation		; $6a66


_headThwomp_state11:
	call _ecom_decCounter1		; $6a69
	jp nz,enemyAnimate		; $6a6c

	inc (hl) ; [counter1]
	ld l,e			; $6a70
	ld (hl),$09 ; [state]

	ld l,Enemy.var34		; $6a73
	ld (hl),$f0		; $6a75
	ret			; $6a77


;;
; @addr{6a78}
_headThwomp_setSolidTilesAroundSelf:
	ld hl,wRoomCollisions+$46		; $6a78
	ld (hl),$01		; $6a7b
	inc l			; $6a7d
	inc l			; $6a7e
	ld (hl),$02		; $6a7f

	ld a,l			; $6a81
	add $0e			; $6a82
	ld l,a			; $6a84
	ld (hl),$05		; $6a85
	inc l			; $6a87
	ld (hl),$0f		; $6a88
	inc l			; $6a8a
	ld (hl),$0a		; $6a8b
	ret			; $6a8d

;;
; @addr{6a8e}
_headThwomp_unsetSolidTilesAroundSelf:
	ld hl,wRoomCollisions+$46		; $6a8e
	xor a			; $6a91
	ldi (hl),a		; $6a92
	ldi (hl),a		; $6a93
	ld (hl),a		; $6a94
	ld l,$56		; $6a95
	ldi (hl),a		; $6a97
	ldi (hl),a		; $6a98
	ld (hl),a		; $6a99
	ret			; $6a9a


;;
; @param	b	Animation base
; @addr{6a9b}
_headThwomp_rotate:
	ld e,Enemy.direction		; $6a9b
	ld a,(de)		; $6a9d
	inc a			; $6a9e
	and $07			; $6a9f
	ld (de),a		; $6aa1

	add b			; $6aa2
	call enemySetAnimation		; $6aa3

	ld e,Enemy.direction		; $6aa6
	ld a,(de)		; $6aa8
	rrca			; $6aa9
	ret c			; $6aaa
	ld a,SND_CLINK2		; $6aab
	jp playSound		; $6aad


;;
; If a bomb is thrown into head thwomp, this sets the state to $0a.
;
; @param[out]	zflag	z if no bomb entered head thwomp
; @addr{6ab0}
_headThwomp_checkBombThrownIntoHead:
	ldhl FIRST_DYNAMIC_ITEM_INDEX,Item.start		; $6ab0
@itemLoop:
	ld l,Item.id		; $6ab3
	ld a,(hl)		; $6ab5
	cp ITEMID_BOMB			; $6ab6
	jr nz,@nextItem	; $6ab8

	ld l,Item.state		; $6aba
	ldi a,(hl)		; $6abc
	dec a			; $6abd
	jr z,@isNonExplodingBomb	; $6abe
	ld a,(hl)		; $6ac0
	cp $02			; $6ac1
	jr c,@nextItem	; $6ac3

@isNonExplodingBomb:
	; Check if bomb is in the right position to enter thwomp
	ld l,Item.yh		; $6ac5
	ldi a,(hl)		; $6ac7
	sub $50			; $6ac8
	add $0c			; $6aca
	cp $19			; $6acc
	jr nc,@nextItem	; $6ace
	inc l			; $6ad0
	ld a,(hl)		; $6ad1
	sub $78			; $6ad2
	add $0c			; $6ad4
	cp $19			; $6ad6
	jr c,@bombEnteredThwomp	; $6ad8

@nextItem:
	inc h			; $6ada
	ld a,h			; $6adb
	cp LAST_DYNAMIC_ITEM_INDEX+1			; $6adc
	jr c,@itemLoop		; $6ade

	ld e,Enemy.var32		; $6ae0
	ld a,(de)		; $6ae2
	rrca			; $6ae3
	jr c,@triggerBombEffect	; $6ae4

	xor a			; $6ae6
	ret			; $6ae7

@bombEnteredThwomp:
	ld l,Item.var2f		; $6ae8
	set 5,(hl)		; $6aea

@triggerBombEffect:
	ld h,d			; $6aec
	ld l,Enemy.var32		; $6aed
	set 0,(hl)		; $6aef

	ld e,Enemy.direction		; $6af1
	ld a,(de)		; $6af3
	bit 0,a			; $6af4
	jr nz,@betweenTwoHeads	; $6af6

	ld l,Enemy.var31		; $6af8
	ld (hl),a		; $6afa

	ld l,Enemy.var32		; $6afb
	ld (hl),$00		; $6afd

	ld l,Enemy.state		; $6aff
	ld (hl),$0a		; $6b01

	ld l,Enemy.counter1		; $6b03
	ld (hl),$06		; $6b05

	call enemySetAnimation		; $6b07

	ld hl,wRoomCollisions+$47		; $6b0a
	ld (hl),$03		; $6b0d
	or d			; $6b0f
	ret			; $6b10

@betweenTwoHeads:
	call _ecom_decCounter1		; $6b11
	ret nz			; $6b14

	ld b,$00		; $6b15
	call _headThwomp_rotate		; $6b17
	jr @triggerBombEffect		; $6b1a

;;
; @addr{6b1c}
_headThwomp_dropHeart:
	call getFreePartSlot		; $6b1c
	ret nz			; $6b1f
	ld (hl),PARTID_ITEM_DROP		; $6b20
	inc l			; $6b22
	ld (hl),ITEM_DROP_HEART		; $6b23
	ld bc,$1400		; $6b25
	jp objectCopyPositionWithOffset		; $6b28

;;
; @addr{6b2b}
_headThwomp_checkShootProjectile:
	ld a,(wFrameCounter)		; $6b2b
	rrca			; $6b2e
	ret c			; $6b2f

	ld h,d			; $6b30
	ld l,Enemy.var34		; $6b31
	dec (hl)		; $6b33
	jr nz,+			; $6b34
	ld (hl),$f0		; $6b36
+
	ld a,(hl)		; $6b38
	cp 90			; $6b39
	ret nc			; $6b3b
	and $0f			; $6b3c
	ret nz			; $6b3e

	call getRandomNumber_noPreserveVars		; $6b3f
	and $07			; $6b42
	jr z,@dropBomb			; $6b44

	ld b,PARTID_HEAD_THWOMP_FIREBALL		; $6b46
	jp _ecom_spawnProjectile		; $6b48

@dropBomb:
	ld b,$02		; $6b4b
	call checkBPartSlotsAvailable		; $6b4d
	ret nz			; $6b50

	; Spawn bomb drop
	call getFreePartSlot		; $6b51
	ld (hl),PARTID_ITEM_DROP		; $6b54
	inc l			; $6b56
	ld (hl),ITEM_DROP_BOMBS		; $6b57
	call objectCopyPosition		; $6b59

	; Spawn bomb drop "physics" object?
	ld b,h			; $6b5c
	call getFreePartSlot		; $6b5d
	ld (hl),PARTID_40		; $6b60

	ld l,Part.relatedObj1		; $6b62
	ld a,Part.start		; $6b64
	ldi (hl),a		; $6b66
	ld (hl),b		; $6b67

	jp objectCopyPosition		; $6b68


; ==============================================================================
; ENEMYID_SHADOW_HAG
;
; Variables:
;   counter2: Number of times to spawn bugs before shadows separate
;   var30: Number of bugs on-screen
;   var31: Set if the hag couldn't spawn because Link was in a bad position
; ==============================================================================
enemyCode7a:
	jr z,@normalStatus	; $6b6b
	sub ENEMYSTATUS_NO_HEALTH			; $6b6d
	ret c			; $6b6f
	jr nz,@normalStatus	; $6b70

	; Dead. Delete all "children" objects.
	ld e,Enemy.collisionType		; $6b72
	ld a,(de)		; $6b74
	or a			; $6b75
	jr z,@dead	; $6b76
	ldhl FIRST_ENEMY_INDEX, Enemy.start		; $6b78
@killNext:
	ld l,Enemy.id		; $6b7b
	ld a,(hl)		; $6b7d
	cp ENEMYID_SHADOW_HAG_BUG			; $6b7e
	call z,_ecom_killObjectH		; $6b80
	inc h			; $6b83
	ld a,h			; $6b84
	cp LAST_ENEMY_INDEX+1			; $6b85
	jr c,@killNext	; $6b87
@dead:
	jp _enemyBoss_dead		; $6b89

@normalStatus:
	ld e,Enemy.state		; $6b8c
	ld a,(de)		; $6b8e
	rst_jumpTable			; $6b8f
	.dw _shadowHag_state_uninitialized
	.dw _shadowHag_state_stub
	.dw _shadowHag_state_stub
	.dw _shadowHag_state_stub
	.dw _shadowHag_state_stub
	.dw _shadowHag_state_stub
	.dw _shadowHag_state_stub
	.dw _shadowHag_state_stub
	.dw _shadowHag_state8
	.dw _shadowHag_state9
	.dw _shadowHag_stateA
	.dw _shadowHag_stateB
	.dw _shadowHag_stateC
	.dw _shadowHag_stateD
	.dw _shadowHag_stateE
	.dw _shadowHag_stateF
	.dw _shadowHag_state10
	.dw _shadowHag_state11
	.dw _shadowHag_state12
	.dw _shadowHag_state13

_shadowHag_state_uninitialized:
	ld a,ENEMYID_SHADOW_HAG		; $6bb8
	ld b,$00		; $6bba
	call _enemyBoss_initializeRoom		; $6bbc
	ld a,SPEED_80		; $6bbf
	jp _ecom_setSpeedAndState8		; $6bc1


_shadowHag_state_stub:
	ret			; $6bc4


_shadowHag_state8:
	inc e			; $6bc5
	ld a,(de)		; $6bc6
	rst_jumpTable			; $6bc7
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4

; Wait for door to close, then begin cutscene
@substate0:
	ld a,($cc93)		; $6bd2
	or a			; $6bd5
	ret nz			; $6bd6

	inc a			; $6bd7
	ld (wDisabledObjects),a		; $6bd8

	ld bc,$0104		; $6bdb
	call _enemyBoss_spawnShadow		; $6bde
	ret nz			; $6be1

	ld h,d			; $6be2
	ld l,Enemy.state2		; $6be3
	inc (hl)		; $6be5
	ld l,Enemy.angle		; $6be6
	ld (hl),$18		; $6be8
	ld l,Enemy.zh		; $6bea
	ld (hl),$ff		; $6bec

	; Set position to Link's position
	ld l,Enemy.yh		; $6bee
	ldh a,(<hEnemyTargetY)	; $6bf0
	add $04			; $6bf2
	ldi (hl),a		; $6bf4
	inc l			; $6bf5
	ldh a,(<hEnemyTargetX)	; $6bf6
	ld (hl),a		; $6bf8
	ret			; $6bf9

; Moving left to center of room
@substate1:
	ld e,Enemy.xh		; $6bfa
	ld a,(de)		; $6bfc
	cp ((LARGE_ROOM_WIDTH/2)<<4)+8			; $6bfd
	jp nc,objectApplySpeed		; $6bff

	call _shadowHag_beginEmergingFromShadow		; $6c02
	ld h,d			; $6c05
	ld l,Enemy.state2		; $6c06
	inc (hl)		; $6c08

	inc l			; $6c09
	ld (hl),$10 ; [counter1]

	ld l,Enemy.zh		; $6c0c
	ld (hl),$00		; $6c0e
	jp _ecom_killRelatedObj2		; $6c10

; Emerging from shadow
@substate2:
	call _shadowHag_updateEmergingFromShadow		; $6c13
	ret nz			; $6c16

	ld e,Enemy.state2		; $6c17
	ld a,$03		; $6c19
	ld (de),a		; $6c1b
	dec a			; $6c1c
	jp enemySetAnimation		; $6c1d

; Delay before showing textbox
@substate3:
	call _ecom_decCounter1		; $6c20
	jr nz,@animate	; $6c23

	ld (hl),$08		; $6c25
	ld l,e			; $6c27
	inc (hl)		; $6c28
	ld bc,TX_2f2b		; $6c29
	jp showText		; $6c2c

@substate4:
	call _ecom_decCounter1		; $6c2f
	jr nz,@animate	; $6c32
	call _shadowHag_beginReturningToGround		; $6c34
	call _enemyBoss_beginBoss		; $6c37
@animate:
	jp enemyAnimate		; $6c3a


; Currently in the ground, showing eyes
_shadowHag_state9:
	call _ecom_decCounter2		; $6c3d
	jp nz,shadowHag_updateReturningToGround		; $6c40

	dec l			; $6c43
	ld a,(hl)		; $6c44
	or a			; $6c45
	jr z,@spawnShadows			; $6c46

	dec (hl)		; $6c48
	jp _ecom_flickerVisibility		; $6c49

@spawnShadows:
	ld b,$04		; $6c4c
	call checkBPartSlotsAvailable		; $6c4e
	ret nz			; $6c51

	ldbc PARTID_SHADOW_HAG_SHADOW,$04		; $6c52
--
	call _ecom_spawnProjectile		; $6c55
	dec c			; $6c58
	ld l,Part.angle		; $6c59
	ld (hl),c		; $6c5b
	jr nz,--		; $6c5c

	; Go to state A
	call _ecom_incState		; $6c5e
	ld l,Enemy.counter1		; $6c61
	ld (hl),150		; $6c63
	inc l			; $6c65
	ld (hl),$04 ; [counter2]

	ld l,Enemy.collisionType		; $6c68
	res 7,(hl)		; $6c6a
	jp objectSetInvisible		; $6c6c


; Shadows chasing Link
_shadowHag_stateA:
	ld a,(wFrameCounter)		; $6c6f
	rrca			; $6c72
	ret c			; $6c73
	call _ecom_decCounter1		; $6c74
	ret nz			; $6c77

	; Time for shadows to reconverge.

	dec (hl) ; [counter1] = $ff
	ld l,e			; $6c79
	inc (hl) ; [state] = $0b

	call getRandomNumber_noPreserveVars		; $6c7b
	and $06			; $6c7e
	ld hl,@targetPositions		; $6c80
	rst_addAToHl			; $6c83
	ld e,Enemy.yh		; $6c84
	ldi a,(hl)		; $6c86
	ld (de),a		; $6c87
	ld e,Enemy.xh		; $6c88
	ld a,(hl)		; $6c8a
	ld (de),a		; $6c8b
	ret			; $6c8c

; When the shadows reconverge, one of these positions is chosen randomly.
@targetPositions:
	.db $38 $48
	.db $38 $b8
	.db $78 $48
	.db $78 $b8


; Shadows reconverging to target position
_shadowHag_stateB:
	ld e,Enemy.counter2		; $6c95
	ld a,(de)		; $6c97
	or a			; $6c98
	ret nz			; $6c99

	; All shadows have now returned.

	; Decide how many times to spawn bugs before shadows separate again
	call getRandomNumber_noPreserveVars		; $6c9a
	and $01			; $6c9d
	add $02			; $6c9f
	ld e,Enemy.counter2		; $6ca1
	ld (de),a		; $6ca3

_shadowHag_initStateC:
	ld h,d			; $6ca4
	ld l,Enemy.state		; $6ca5
	ld (hl),$0c		; $6ca7
	ld l,Enemy.counter1		; $6ca9
	ld (hl),30		; $6cab

	ld l,Enemy.collisionType		; $6cad
	ld (hl),$80|ENEMYID_PODOBOO		; $6caf

	ld l,Enemy.collisionRadiusY		; $6cb1
	ld (hl),$03		; $6cb3
	inc l			; $6cb5
	ld (hl),$05		; $6cb6

	call objectSetVisible83		; $6cb8
	ld a,$04		; $6cbb
	jp enemySetAnimation		; $6cbd


; Delay before spawning bugs
_shadowHag_stateC:
	call _ecom_decCounter1		; $6cc0
	jr nz,++		; $6cc3
	ld (hl),$41		; $6cc5
	ld l,e			; $6cc7
	inc (hl)		; $6cc8
++
	jp enemyAnimate		; $6cc9


; Spawning bugs
_shadowHag_stateD:
	call enemyAnimate		; $6ccc
	call _ecom_decCounter1		; $6ccf
	jr z,@doneSpawningBugs	; $6cd2

	; Spawn bug every 16 frames
	ld a,(hl)		; $6cd4
	and $0f			; $6cd5
	ret nz			; $6cd7

	; Maximum of 7 at a time
	ld e,Enemy.var30		; $6cd8
	ld a,(de)		; $6cda
	cp $07			; $6cdb
	ret nc			; $6cdd

	; Spawn bug
	ld b,ENEMYID_SHADOW_HAG_BUG		; $6cde
	call _ecom_spawnUncountedEnemyWithSubid01		; $6ce0
	ret nz			; $6ce3

	; [child.relatedObj1] = this
	ld l,Enemy.relatedObj1		; $6ce4
	ld a,Enemy.start		; $6ce6
	ldi (hl),a		; $6ce8
	ld (hl),d		; $6ce9

	; [child.position] = [this.position]
	call objectCopyPosition		; $6cea

	ld h,d			; $6ced
	ld l,Enemy.var30		; $6cee
	inc (hl)		; $6cf0
	ret			; $6cf1

@doneSpawningBugs:
	call _ecom_incState		; $6cf2
	ld l,Enemy.counter1		; $6cf5
	ld (hl),30		; $6cf7
	ret			; $6cf9


; Done spawning bugs; delay before the hag herself spawns in
_shadowHag_stateE:
	call _ecom_decCounter1		; $6cfa
	jp nz,_ecom_flickerVisibility		; $6cfd

	ld e,Enemy.var31		; $6d00
	ld a,(de)		; $6d02
	or a			; $6d03
	ld a,90		; $6d04
	jr z,++			; $6d06
	xor a			; $6d08
	ld (de),a		; $6d09
	ld a,150		; $6d0a
++
	ld (hl),a ; [counter1] = a

	ld l,Enemy.state		; $6d0d
	inc (hl)		; $6d0f
	ld l,Enemy.collisionType		; $6d10
	res 7,(hl)		; $6d12
	jp objectSetInvisible		; $6d14


; Waiting for Link to be in a position where the hag can spawn behind him
_shadowHag_stateF:
	call _ecom_decCounter1		; $6d17
	jr z,@couldntSpawn	; $6d1a

	call _shadowHag_chooseSpawnPosition		; $6d1c
	ret nz			; $6d1f
	ld e,Enemy.yh		; $6d20
	ld a,b			; $6d22
	ld (de),a		; $6d23
	ld e,Enemy.xh		; $6d24
	ld a,c			; $6d26
	ld (de),a		; $6d27
	call _shadowHag_beginEmergingFromShadow		; $6d28
	jp _ecom_incState		; $6d2b

@couldntSpawn:
	ld e,Enemy.var31		; $6d2e
	ld a,$01		; $6d30
	ld (de),a		; $6d32

	inc l			; $6d33
	dec (hl) ; [counter2]--
	jp nz,_shadowHag_initStateC		; $6d35

	call _shadowHag_beginReturningToGround		; $6d38
	ld a,$04		; $6d3b
	jp enemySetAnimation		; $6d3d


; Spawning out of ground to attack Link
_shadowHag_state10:
	call _shadowHag_updateEmergingFromShadow		; $6d40
	ret nz			; $6d43

	call _ecom_incState		; $6d44

	ld l,Enemy.collisionType		; $6d47
	ld (hl),$80|ENEMYID_SHADOW_HAG		; $6d49

	ld l,Enemy.speed		; $6d4b
	ld (hl),SPEED_180		; $6d4d
	ld l,Enemy.counter1		; $6d4f
	ld (hl),30		; $6d51
	ld l,Enemy.direction		; $6d53
	ld (hl),$ff		; $6d55

	ld l,Enemy.collisionRadiusY		; $6d57
	ld (hl),$0c		; $6d59
	inc l			; $6d5b
	ld (hl),$08		; $6d5c

	call _ecom_updateCardinalAngleTowardTarget		; $6d5e
	jp _ecom_updateAnimationFromAngle		; $6d61


; Delay before charging at Link
_shadowHag_state11:
	call _shadowHag_checkLinkLookedAtHag		; $6d64
	jr z,_shadowHag_doneCharging	; $6d67

	call _ecom_decCounter1		; $6d69
	ret nz			; $6d6c
	ld (hl),60		; $6d6d

	ld l,Enemy.state		; $6d6f
	inc (hl)		; $6d71

_shadowHag_animate:
	jp enemyAnimate		; $6d72


; Charging at Link
_shadowHag_state12:
	call _shadowHag_checkLinkLookedAtHag		; $6d75
	jr z,_shadowHag_doneCharging	; $6d78

	call _ecom_decCounter1		; $6d7a
	jr z,_shadowHag_doneCharging	; $6d7d

	ld e,Enemy.yh		; $6d7f
	ld a,(de)		; $6d81
	sub $12			; $6d82
	cp (LARGE_ROOM_HEIGHT<<4)-$32			; $6d84
	jr nc,_shadowHag_doneCharging	; $6d86

	ld e,Enemy.xh		; $6d88
	ld a,(de)		; $6d8a
	sub $18			; $6d8b
	cp (LARGE_ROOM_WIDTH<<4)-$30			; $6d8d
	jr nc,_shadowHag_doneCharging	; $6d8f
	call objectApplySpeed		; $6d91
	jr _shadowHag_animate		; $6d94


_shadowHag_doneCharging:
	call _ecom_decCounter2		; $6d96
	jp z,_shadowHag_beginReturningToGround		; $6d99

	ld l,Enemy.counter1		; $6d9c
	ld (hl),30		; $6d9e

	ld l,Enemy.state		; $6da0
	inc (hl)		; $6da2

	ld l,Enemy.collisionType		; $6da3
	ld (hl),$80|ENEMYID_PODOBOO		; $6da5
	ld a,$06		; $6da7
	jp enemySetAnimation		; $6da9


; Delay before spawning bugs again
_shadowHag_state13:
	call _ecom_decCounter1		; $6dac
	jr nz,shadowHag_updateReturningToGround	; $6daf
	jp _shadowHag_initStateC		; $6db1


;;
; @addr{6db4}
_shadowHag_beginEmergingFromShadow:
	ld a,$05		; $6db4
	call enemySetAnimation		; $6db6
	call objectSetVisible82		; $6db9
	ld e,Enemy.yh		; $6dbc
	ld a,(de)		; $6dbe
	sub $04			; $6dbf
	ld (de),a		; $6dc1
	ret			; $6dc2

;;
; @param[out]	zflag	z if done emerging? (animParameter was $ff)
; @addr{6dc3}
_shadowHag_updateEmergingFromShadow:
	call enemyAnimate		; $6dc3
	ld e,Enemy.animParameter		; $6dc6
	ld a,(de)		; $6dc8
	inc a			; $6dc9
	ret z			; $6dca

	; If [animParameter] == 1, y -= 8? (To center the hitbox maybe?)
	sub $02			; $6dcb
	ret nz			; $6dcd
	ld (de),a		; $6dce

	ld e,Enemy.yh		; $6dcf
	ld a,(de)		; $6dd1
	sub $08			; $6dd2
	ld (de),a		; $6dd4
	or d			; $6dd5
	ret			; $6dd6

;;
; @addr{6dd7}
shadowHag_updateReturningToGround:
	call enemyAnimate		; $6dd7

	ld e,Enemy.animParameter		; $6dda
	ld a,(de)		; $6ddc
	or a			; $6ddd
	ret z			; $6dde
	bit 7,a			; $6ddf
	ret nz			; $6de1

	dec a			; $6de2
	ld hl,@yOffsets		; $6de3
	rst_addAToHl			; $6de6

	ld e,Enemy.yh		; $6de7
	ld a,(de)		; $6de9
	add (hl)		; $6dea
	ld (de),a		; $6deb

	ld e,Enemy.animParameter		; $6dec
	xor a			; $6dee
	ld (de),a		; $6def
	ret			; $6df0

@yOffsets:
	.db $08 $04

;;
; Sets state to 9 & initializes stuff
; @addr{6df3}
_shadowHag_beginReturningToGround:
	ld h,d			; $6df3
	ld l,Enemy.state		; $6df4
	ld (hl),$09		; $6df6

	ld l,Enemy.counter1		; $6df8
	ld (hl),90		; $6dfa
	inc l			; $6dfc
	ld (hl),30 ; [counter2]

	; Make hag invincible
	ld l,Enemy.collisionType		; $6dff
	ld (hl),$80|ENEMYID_PODOBOO		; $6e01

	ld l,Enemy.collisionRadiusY		; $6e03
	ld (hl),$03		; $6e05
	inc l			; $6e07
	ld (hl),$05		; $6e08

	ld a,$06		; $6e0a
	jp enemySetAnimation		; $6e0c

;;
; Chooses position to spawn at for charge attack based on Link's facing direction.
;
; @param[out]	bc	Spawn position
; @param[out]	zflag	nz if Link is too close to the wall to spawn in
; @addr{6e0f}
_shadowHag_chooseSpawnPosition:
	ld a,(w1Link.direction)		; $6e0f
	ld hl,@spawnOffsets		; $6e12
	rst_addDoubleIndex			; $6e15

	ld a,(w1Link.yh)		; $6e16
	add (hl)		; $6e19
	ld b,a			; $6e1a
	sub $1c			; $6e1b
	cp $80			; $6e1d
	jr nc,@invalid		; $6e1f

	inc hl			; $6e21
	ld a,(w1Link.xh)		; $6e22
	ld e,a			; $6e25
	add (hl)		; $6e26
	ld c,a			; $6e27
	cp $f0			; $6e28
	jr nc,@invalid		; $6e2a

	sub e			; $6e2c
	jr nc,++		; $6e2d
	cpl			; $6e2f
	inc a			; $6e30
++
	rlca			; $6e31
	jp nc,getTileCollisionsAtPosition		; $6e32

@invalid:
	or d			; $6e35
	ret			; $6e36

@spawnOffsets:
	.db $40 $00
	.db $08 $c0
	.db $c0 $00
	.db $08 $40

;;
; @param[out]	zflag	z if Link looked at the hag
; @addr{6e3f}
_shadowHag_checkLinkLookedAtHag:
	call objectGetAngleTowardEnemyTarget		; $6e3f
	add $14			; $6e42
	and $18			; $6e44
	swap a			; $6e46
	rlca			; $6e48
	ld b,a			; $6e49
	ld a,(w1Link.direction)		; $6e4a
	cp b			; $6e4d
	ret			; $6e4e


; ==============================================================================
; ENEMYID_EYESOAR
;
; Variables:
;   var30-var35: Object indices of children
;   var36/var37: Target Y/X position for state $0b
;   var38: The distance each child should be from Eyesoar (the value they're moving
;          toward)
;   var39: Bit 4: Set when children should return?
;          Bit 3: Unset to make the children start moving back to Eyesoar (after using
;                 switch hook on him)
;          Bit 2: Set while eyesoar is in his "dazed" state (Signals children to start
;                 moving around randomly)
;          Bit 1: Set to indicate the children should start moving again as normal after
;                 returning to Eyesoar
;          Bit 0: While set, children don't respawn?
;   var3a: Bits 0-3: set when corresponding children have reached their target distance
;                    away from eyesoar?
;          Bits 4-7: set when corresponding children have reached their target position
;                    relative to eyesoar after using the switch hook on him?
;   var3b: Current "angle" (rotation offset for children)
;   var3c: Counter until bit 0 of var39 gets reset
; ==============================================================================
enemyCode7b:
	jr z,@normalStatus	; $6e4f
	sub ENEMYSTATUS_NO_HEALTH			; $6e51
	ret c			; $6e53
	jp z,_eyesoar_dead		; $6e54

	; ENEMYSTATUS_JUST_HIT or ENEMYSTATUS_KNOCKBACK

	; TODO: Checking for mystery seed? Why?
	ld h,d			; $6e57
	ld l,Enemy.var2a		; $6e58
	ld a,(hl)		; $6e5a
	cp $80|ITEMCOLLISION_MYSTERY_SEED			; $6e5b
	jr nz,@normalStatus	; $6e5d
	ld l,Enemy.var3c		; $6e5f
	ld (hl),$78		; $6e61
	ld l,Enemy.var39		; $6e63
	set 0,(hl)		; $6e65

@normalStatus:
	ld h,d			; $6e67
	ld l,Enemy.var3c		; $6e68
	ld a,(hl)		; $6e6a
	or a			; $6e6b
	jr z,++			; $6e6c
	dec (hl)		; $6e6e
	jr nz,++		; $6e6f

	ld l,Enemy.var39		; $6e71
	res 0,(hl)		; $6e73
++
	ld e,Enemy.state		; $6e75
	ld a,(de)		; $6e77
	rst_jumpTable			; $6e78
	.dw _eyesoar_state_uninitialized
	.dw _eyesoar_state1
	.dw _eyesoar_state_stub
	.dw _eyesoar_state_switchHook
	.dw _eyesoar_state_stub
	.dw _eyesoar_state_stub
	.dw _eyesoar_state_stub
	.dw _eyesoar_state_stub
	.dw _eyesoar_state8
	.dw _eyesoar_state9
	.dw _eyesoar_stateA
	.dw _eyesoar_stateB
	.dw _eyesoar_stateC
	.dw _eyesoar_stateD
	.dw _eyesoar_stateE


_eyesoar_state_uninitialized:
	ld h,d			; $6e97
	ld l,Enemy.counter1		; $6e98
	ld (hl),60		; $6e9a

	ld l,Enemy.zh		; $6e9c
	ld (hl),$fe		; $6e9e

	; Check for subid 1
	ld l,Enemy.subid		; $6ea0
	ld a,(hl)		; $6ea2
	or a			; $6ea3
	ld a,SPEED_80		; $6ea4
	jp nz,_ecom_setSpeedAndState8		; $6ea6

	; BUG: This sets an invalid state!
	; 'a+1' == SPEED_80+1 == $15, a state which isn't defined.
	; Doesn't really matter, since this object will be deleted anyway...
	; But there are obscure conditions below where it returns before deleting itself.
	; Then this would become a problem. But those conditions probably never happen...
	inc a			; $6ea9
	ld (de),a ; [state] = $15 (!)

	ld a,$ff		; $6eab
	ld b,$00		; $6ead
	call _enemyBoss_initializeRoom		; $6eaf


; Spawning "real" eyesoar and children.
_eyesoar_state1:
	; If this actually returns here, the game could crash (see above note).
	ld b,$05		; $6eb2
	call checkBEnemySlotsAvailable		; $6eb4
	ret nz			; $6eb7

	; Spawn the "real" version of the boss (subid 1).
	ld b,ENEMYID_EYESOAR		; $6eb8
	call _ecom_spawnUncountedEnemyWithSubid01		; $6eba

	ld l,Enemy.enabled		; $6ebd
	ld e,l			; $6ebf
	ld a,(de)		; $6ec0
	ld (hl),a		; $6ec1
	call objectCopyPosition		; $6ec2

	; Spawn 4 children.
	ld l,Enemy.var30		; $6ec5
	ld b,h			; $6ec7
	ld c,$04		; $6ec8

@spawnChildLoop:
	push hl			; $6eca
	call getFreeEnemySlot_uncounted		; $6ecb
	ld (hl),ENEMYID_EYESOAR_CHILD		; $6ece
	inc l			; $6ed0
	dec c			; $6ed1
	ld (hl),c ; [child.subid]

	ld l,Enemy.relatedObj1+1		; $6ed3
	ld a,b			; $6ed5
	ldd (hl),a		; $6ed6
	ld (hl),Enemy.start		; $6ed7
	ld a,h			; $6ed9
	pop hl			; $6eda
	ldi (hl),a ; [var30+i] = child object index
	jr nz,@spawnChildLoop	; $6edc

	jp enemyDelete		; $6ede


_eyesoar_state_switchHook:
	inc e			; $6ee1
	ld a,(de)		; $6ee2
	rst_jumpTable			; $6ee3
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate0:
	; Signal children to run around randomly
	ld h,d			; $6eec
	ld l,Enemy.var39		; $6eed
	ld a,(hl)		; $6eef
	or $0a			; $6ef0
	ldd (hl),a		; $6ef2

	; Jdust var38 (distance away children should be)?
	ld a,(hl)		; $6ef3
	and $07			; $6ef4
	or $18			; $6ef6
	ld (hl),a		; $6ef8

	ld l,Enemy.enemyCollisionMode		; $6ef9
	ld (hl),ENEMYCOLLISION_EYESOAR_VULNERABLE		; $6efb
	ld l,Enemy.counter1		; $6efd
	ld (hl),150		; $6eff
	ld l,Enemy.direction		; $6f01
	ld (hl),$00		; $6f03
	jp _ecom_incState2		; $6f05

@substate1:
	ret			; $6f08

@substate2:
	ld e,Enemy.direction		; $6f09
	ld a,(de)		; $6f0b
	or a			; $6f0c
	ret nz			; $6f0d

	inc a			; $6f0e
	ld (de),a		; $6f0f
	jp enemySetAnimation		; $6f10

@substate3:
	ld b,$0c		; $6f13
	jp _ecom_fallToGroundAndSetState		; $6f15


_eyesoar_state_stub:
	ret			; $6f18


; Flickering into existence
_eyesoar_state8:
	; Something about doors?
	ld a,($cc93)		; $6f19
	or a			; $6f1c
	ret nz			; $6f1d

	inc a			; $6f1e
	ld (wDisabledObjects),a		; $6f1f
	call _ecom_decCounter1		; $6f22
	jp nz,_ecom_flickerVisibility		; $6f25

	ld (hl),60  ; [counter1]
	inc l			; $6f2a
	ld (hl),180 ; [counter2]

	; [var3a] = $ff (all children are in place at the beginning)
	ld l,Enemy.var3a		; $6f2d
	dec (hl)		; $6f2f

	ld l,e			; $6f30
	inc (hl) ; [state]
	jp objectSetVisiblec2		; $6f32


; Waiting [counter1] frames until fight begins
_eyesoar_state9:
	call _ecom_decCounter1		; $6f35
	jr nz,_eyesoar_animate	; $6f38

	ld l,e			; $6f3a
	inc (hl) ; [state]

	ld l,Enemy.counter1		; $6f3c
	inc (hl)		; $6f3e

	call _enemyBoss_beginBoss		; $6f3f
	jr _eyesoar_animate		; $6f42


; Standing still for [counter1] frames?
_eyesoar_stateA:
	call _eyesoar_updateFormation		; $6f44
	call _ecom_decCounter1		; $6f47
	jr nz,_eyesoar_animate	; $6f4a

	ld l,Enemy.state		; $6f4c
	inc (hl)		; $6f4e

	; Decide on target position (written to var36/var37)
	ld l,Enemy.var36		; $6f4f
	ldh a,(<hEnemyTargetY)	; $6f51
	ld b,a			; $6f53
	sub $40			; $6f54
	cp $30			; $6f56
	jr c,++			; $6f58
	cp $c0			; $6f5a
	ld b,$40		; $6f5c
	jr nc,++		; $6f5e
	ld b,$70		; $6f60
++
	ld a,b			; $6f62
	ldi (hl),a ; [var36]

	ldh a,(<hEnemyTargetX)	; $6f64
	ld b,a			; $6f66
	sub $40			; $6f67
	cp $70			; $6f69
	jr c,++			; $6f6b
	cp $c0			; $6f6d
	ld b,$40		; $6f6f
	jr nc,++		; $6f71
	ld b,$b0		; $6f73
++
	ld (hl),b ; [var37]

	jr _eyesoar_animate		; $6f76


; Moving until it reaches its target position
_eyesoar_stateB:
	call _eyesoar_updateFormation		; $6f78
	ld h,d			; $6f7b
	ld l,Enemy.var36		; $6f7c

	call _ecom_readPositionVars		; $6f7e
	sub c			; $6f81
	add $02			; $6f82
	cp $05			; $6f84
	jr nc,++	; $6f86
	ldh a,(<hFF8F)	; $6f88
	sub b			; $6f8a
	add $02			; $6f8b
	cp $05			; $6f8d
	jr nc,++	; $6f8f

	ld l,Enemy.state		; $6f91
	dec (hl)		; $6f93
	ld l,Enemy.counter1		; $6f94
	ld (hl),60		; $6f96
	jr _eyesoar_animate		; $6f98
++
	call _ecom_moveTowardPosition		; $6f9a

_eyesoar_animate:
	jp enemyAnimate		; $6f9d


; Spinning in place after being switch hook'd
_eyesoar_stateC:
	call _ecom_decCounter1		; $6fa0
	jr nz,_eyesoar_animate	; $6fa3

	ld l,e			; $6fa5
	inc (hl) ; [state]

	ld l,Enemy.enemyCollisionMode		; $6fa7
	ld (hl),ENEMYCOLLISION_EYESOAR		; $6fa9

	xor a			; $6fab
	call enemySetAnimation		; $6fac


; Moving back up into the air
_eyesoar_stateD:
	ld h,d			; $6faf
	ld l,Enemy.z		; $6fb0
	ld a,(hl)		; $6fb2
	sub $80			; $6fb3
	ldi (hl),a		; $6fb5
	ld a,(hl)		; $6fb6
	sbc $00			; $6fb7
	ld (hl),a		; $6fb9

	cp $fe			; $6fba
	jr nz,_eyesoar_animate	; $6fbc

	ld l,e			; $6fbe
	inc (hl) ; [state]

	ld l,Enemy.counter1		; $6fc0
	ld (hl),240		; $6fc2

	ld l,Enemy.var3a		; $6fc4
	ld (hl),$0f		; $6fc6

	ld l,Enemy.var39		; $6fc8
	res 1,(hl)		; $6fca
	call _eyesoar_chooseNewAngle		; $6fcc


; Flying around kinda randomly
_eyesoar_stateE:
	call _ecom_decCounter1		; $6fcf
	jr nz,++		; $6fd2
	ld l,Enemy.var39		; $6fd4
	res 3,(hl)		; $6fd6
	set 4,(hl)		; $6fd8
++
	ld l,Enemy.var3a		; $6fda
	ld a,(hl)		; $6fdc
	inc a			; $6fdd
	jr nz,++		; $6fde

	; All children dead?
	dec l			; $6fe0
	res 4,(hl) ; [var39]
	ld l,e			; $6fe3
	ld (hl),$0a ; [state]

	ld l,Enemy.counter1		; $6fe6
	ld (hl),$01 ; [counter1]		; $6fe8
	inc l			; $6fea
	ld (hl),$08 ; [counter2]
++
	ld l,Enemy.counter1		; $6fed
	ld a,(hl)		; $6fef
	and $3f			; $6ff0
	call z,_eyesoar_chooseNewAngle		; $6ff2
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $6ff5
	jr _eyesoar_animate		; $6ff8


;;
; Checks to update the "formation", that is, the distances away from Eyesoar for the
; children.
; @addr{6ffa}
_eyesoar_updateFormation:
	; Check all children are at their target distance away from Eyesoar
	ld e,Enemy.var3a		; $6ffa
	ld a,(de)		; $6ffc
	ld c,a			; $6ffd
	and $f0			; $6ffe
	cp $f0			; $7000
	ret nz			; $7002

	; Increment angle offset for children
	ld a,(wFrameCounter)		; $7003
	and $03			; $7006
	jr nz,++		; $7008
	ld e,Enemy.var3b		; $700a
	ld a,(de)		; $700c
	inc a			; $700d
	and $1f			; $700e
	ld (de),a		; $7010
++
	; Check that all children are in formation
	inc c			; $7011
	jr nz,@notInFormation	; $7012

	call _ecom_decCounter2		; $7014
	ret nz			; $7017
	ld (hl),180		; $7018

	; Signal children to begin moving to new distance away from eyesoar
	ld l,Enemy.var39		; $701a
	set 2,(hl)		; $701c
	ld l,Enemy.var3a		; $701e
	ld (hl),$f0		; $7020

	; Choose new distance away
	ld e,Enemy.var38		; $7022
	ld a,(de)		; $7024
	inc a			; $7025
	and $07			; $7026
	ld b,a			; $7028
	ld hl,distancesFromEyesoar		; $7029
	rst_addAToHl			; $702c
	ld a,(hl)		; $702d
	or b			; $702e
	ld (de),a		; $702f
	ret			; $7030

@notInFormation:
	ld e,Enemy.var39		; $7031
	ld a,(de)		; $7033
	res 2,a			; $7034
	ld (de),a		; $7036
	ret			; $7037

; Distances away from Eyesoar for the children
distancesFromEyesoar:
	.db $18 $28 $30 $20 $30 $18 $28 $20



_eyesoar_dead:
	ld e,Enemy.collisionType		; $7040
	ld a,(de)		; $7042
	or a			; $7043
	jr z,@doneKillingChildren	; $7044

	ld e,Enemy.var30		; $7046
@killNextChild:
	ld a,(de)		; $7048
	ld h,a			; $7049
	ld l,e			; $704a
	call _ecom_killObjectH		; $704b
	inc e			; $704e
	ld a,e			; $704f
	cp Enemy.var36			; $7050
	jr c,@killNextChild	; $7052

@doneKillingChildren:
	jp _enemyBoss_dead		; $7054


;;
; Chooses an angle which roughly goes toward the center of the room, plus a small, random
; angle offset.
; @addr{7057}
_eyesoar_chooseNewAngle:
	; Get random angle offset in 'c'
	call getRandomNumber_noPreserveVars		; $7057
	and $0f			; $705a
	cp $09			; $705c
	jr nc,_eyesoar_chooseNewAngle	; $705e

	ld c,a			; $7060
	ld b,$00		; $7061
	ld e,Enemy.yh		; $7063
	ld a,(de)		; $7065
	cp (LARGE_ROOM_HEIGHT/2)<<4 + 8			; $7066
	jr c,+			; $7068
	inc b			; $706a
+
	ld e,Enemy.xh		; $706b
	ld a,(de)		; $706d
	cp (LARGE_ROOM_WIDTH/2)<<4 + 8			; $706e
	jr c,+			; $7070
	set 1,b			; $7072
+
	ld a,b			; $7074
	ld hl,@angleVals		; $7075
	rst_addAToHl			; $7078
	ld a,(hl)		; $7079
	add c			; $707a
	and $1f			; $707b
	ld e,Enemy.angle		; $707d
	ld (de),a		; $707f
	ret			; $7080

@angleVals:
	.db $08 $00 $10 $18


; ==============================================================================
; ENEMYID_SMOG
;
; Variables:
;   var03: Phase of fight (0-3)
;   counter2: Stops movement temporarily (when sword collision occurs)
;   var30: "Adjacent walls bitset" (bitset of solid walls around smog, similar to the
;          variable used for special objects)
;   var31: Position of the tile it's "hugging"
;   var32: Number of frames to wait for a wall before disappearing and respawning
;   var33: Original value of "direction" (for subid 2 respawning)
;   var34/var35: Original Y/X position (for subid 2 respawning)
;   var36: Counter until "fire projectile" animation will begin
; ==============================================================================
enemyCode7c:
	jr z,@normalStatus	; $7085
	sub ENEMYSTATUS_NO_HEALTH			; $7087
	ret c			; $7089
	jr nz,@normalStatus	; $708a
	jp _enemyBoss_dead		; $708c

@normalStatus:
	ld e,Enemy.state		; $708f
	ld a,(de)		; $7091
	rst_jumpTable			; $7092
	.dw _smog_state_uninitialized
	.dw _smog_state_stub
	.dw _smog_state_stub
	.dw _smog_state_stub
	.dw _smog_state_stub
	.dw _smog_state_stub
	.dw _smog_state_stub
	.dw _smog_state_stub
	.dw _smog_state8


_smog_state_uninitialized:
	ld e,Enemy.subid		; $70a5
	ld a,(de)		; $70a7
	and $0f			; $70a8
	rst_jumpTable			; $70aa
	.dw @subid0Init
	.dw @subid1Init
	.dw @subid2Init
	.dw @subid3Init
	.dw @subid4Init
	.dw @subid5Init
	.dw @subid6Init

@subid0Init:
	ld bc,TX_2f26		; $70b9
	call showText		; $70bc
	ld e,Enemy.counter2		; $70bf
	ld a,60		; $70c1
	ld (de),a		; $70c3
	ld a,$04		; $70c4
	jr @setAnimationAndCommonInit		; $70c6

@subid1Init:
	ld e,Enemy.counter2		; $70c8
	ld a,120		; $70ca
	ld (de),a		; $70cc
	ld a,$00		; $70cd
	jr @setAnimationAndCommonInit		; $70cf

@subid2Init:
	call _enemyBoss_beginBoss		; $70d1

	ld h,d			; $70d4
	ld e,Enemy.direction		; $70d5
	ld l,Enemy.var33		; $70d7
	ld a,(de)		; $70d9
	ldi (hl),a		; $70da

	ld e,Enemy.yh		; $70db
	ld a,(de)		; $70dd
	ldi (hl),a		; $70de
	ld e,Enemy.xh		; $70df
	ld a,(de)		; $70e1
	ld (hl),a		; $70e2

	ld a,$04		; $70e3
	call @initCollisions		; $70e5
	ld a,$00		; $70e8
	jr @setAnimationAndCommonInit		; $70ea

@subid3Init:
	call _ecom_decCounter2		; $70ec

	ld l,Enemy.collisionType		; $70ef
	res 7,(hl)		; $70f1
	ret nz			; $70f3
	set 7,(hl)		; $70f4

	ld a,(wNumEnemies)		; $70f6
	cp $02			; $70f9
	jr z,@subid4Init	; $70fb

	; BUG?
	ld e,Interaction.counter2		; $70fd
	ld a,60		; $70ff
	ld (de),a		; $7101
	ld a,$06		; $7102
	call @initCollisions		; $7104

	ld a,$02		; $7107
	jr @setAnimationAndCommonInit		; $7109

@subid4Init:
	ld a,$04		; $710b
	ld (de),a ; [subid] = 4

	ld a,TILEINDEX_DUNGEON_a3		; $710e
	ld c,$11		; $7110
	call setTile		; $7112

	ld a,$04		; $7115

@setAnimationAndCommonInit:
	call enemySetAnimation		; $7117
	call _smog_setCounterToFireProjectile		; $711a
	ld e,Enemy.subid		; $711d
	ld a,(de)		; $711f
	and $0f			; $7120
	ld hl,@subidSpeedTable		; $7122
	rst_addAToHl			; $7125
	ld a,(hl)		; $7126
	jp _ecom_setSpeedAndState8AndVisible		; $7127

@subid5Init:
@subid6Init:
	ld a,ENEMYID_SMOG		; $712a
	ld b,$00		; $712c
	call _enemyBoss_initializeRoom		; $712e
	call _ecom_setSpeedAndState8		; $7131
	ld l,Enemy.collisionType		; $7134
	res 7,(hl)		; $7136
	ret			; $7138

;;
; @param	a	Collision radius
; @addr{7139}
@initCollisions:
	call objectSetCollideRadius		; $7139
	ld l,Enemy.enemyCollisionMode		; $713c
	ld a,ENEMYCOLLISION_PROJECTILE_WITH_RING_MOD		; $713e
	ld (hl),a		; $7140
	ret			; $7141

@subidSpeedTable:
	.db SPEED_00
	.db SPEED_00
	.db SPEED_e0
	.db SPEED_80
	.db SPEED_40


_smog_state_stub:
	ret			; $7147


_smog_state8:
	ld e,Enemy.subid		; $7148
	ld a,(de)		; $714a
	and $0f			; $714b
	rst_jumpTable			; $714d
	.dw _smog_state8_subid0
	.dw _smog_state8_subid1
	.dw _smog_state8_subid2
	.dw _smog_state8_subid3
	.dw _smog_state8_subid4
	.dw _smog_state8_subid5
	.dw _smog_deleteSelf

; Splitting into two?
_smog_state8_subid0:
	call retIfTextIsActive		; $715c
	call enemyAnimate		; $715f
	call _ecom_decCounter2		; $7162
	ret nz			; $7165

	call getFreeEnemySlot		; $7166
	ld (hl),ENEMYID_SMOG		; $7169
	inc l			; $716b
	ld (hl),$01 ; [child.subid]
	ld bc,$00f0		; $716e
	call objectCopyPositionWithOffset		; $7171

	call getFreeEnemySlot		; $7174
	ld (hl),ENEMYID_SMOG		; $7177
	inc l			; $7179
	ld (hl),$01 ; [child.subid]
	ld bc,$0010		; $717c
	call objectCopyPositionWithOffset		; $717f
	jr _smog_deleteSelf		; $7182

_smog_state8_subid1:
	call enemyAnimate		; $7184
	call _ecom_decCounter2		; $7187
	ret nz			; $718a

_smog_deleteSelf:
	call objectCreatePuff		; $718b
	call decNumEnemies		; $718e
	jp enemyDelete		; $7191


; Small or medium-sized smog
_smog_state8_subid2:
_smog_state8_subid3:
	ld e,Enemy.var2a		; $7194
	ld a,(de)		; $7196
	bit 7,a			; $7197
	jr z,@noCollision	; $7199

	and $7f			; $719b
	cp ITEMCOLLISION_L1_SWORD			; $719d
	jr c,@noCollision	; $719f
	cp ITEMCOLLISION_SWORD_HELD+1			; $71a1
	jr nc,@noCollision	; $71a3

	; If sword collision occurred, stop movement briefly?
	ld e,Enemy.counter2		; $71a5
	ld a,30		; $71a7
	ld (de),a		; $71a9

@noCollision:
	call _ecom_decCounter2		; $71aa
	jp nz,enemyAnimate		; $71ad

	call getThisRoomFlags		; $71b0
	bit ROOMFLAG_BIT_40,a			; $71b3
	jr nz,_smog_deleteSelf	; $71b5

	call enemyAnimate		; $71b7

	; If animParameter is nonzero, shoot projectile
	ld e,Enemy.animParameter		; $71ba
	ld a,(de)		; $71bc
	or a			; $71bd
	jr z,@doneShootingProjectile	; $71be

	ld e,Enemy.subid		; $71c0
	ld a,(de)		; $71c2
	and $0f			; $71c3
	add a			; $71c5
	add -4			; $71c6
	call enemySetAnimation		; $71c8
	call _smog_setCounterToFireProjectile		; $71cb
	ld b,PARTID_SMOG_PROJECTILE		; $71ce
	call _ecom_spawnProjectile		; $71d0
	call objectCopyPosition		; $71d3

@doneShootingProjectile:
	call _smog_decCounterToFireProjectile		; $71d6
	jr z,@runSubstate	; $71d9

	ld e,Enemy.subid		; $71db
	ld a,(de)		; $71dd
	and $0f			; $71de
	add a			; $71e0
	add -3			; $71e1
	call enemySetAnimation		; $71e3

@runSubstate:
	ld e,Enemy.state2		; $71e6
	ld a,(de)		; $71e8
	rst_jumpTable			; $71e9
	.dw @substate0
	.dw @substate1
	.dw @substate2

; Just spawned, or need to redetermine what direction to move in based on surrounding
; walls
@substate0:
	call _smog_applySpeed		; $71f0
	call _smog_checkHuggingWall		; $71f3
	jr nz,@checkHitWall	; $71f6

	ld l,Enemy.var32		; $71f8
	ld (hl),$10		; $71fa

@gotoState1:
	; Update direction based on angle
	ld e,Enemy.angle		; $71fc
	ld a,(de)		; $71fe
	add a			; $71ff
	swap a			; $7200
	dec e			; $7202
	ld (de),a		; $7203

	; Go to substate 1
	ld e,Enemy.state2		; $7204
	ld a,$01		; $7206
	ld (de),a		; $7208
	jp _smog_applySpeed		; $7209

@checkHitWall:
	call _smog_checkHitWall		; $720c
	jr nz,@hitWall	; $720f
	ret			; $7211

@substate1:
	call _smog_applySpeed		; $7212
	call _smog_checkHuggingWall		; $7215
	jr nz,@notHuggingWall	; $7218

	; The wall being hugged disappeared.

	; Check if this is a small or medium smog.
	ld l,Enemy.subid		; $721a
	ld a,(hl)		; $721c
	and $0f			; $721d
	cp $02			; $721f
	jr nz,@mediumSmog	; $7221

	; It's a small smog. Decrement counter before respawning
	ld l,Enemy.var32		; $7223
	dec (hl)		; $7225
	jr nz,@gotoState1	; $7226

	; Respawn
	call objectCreatePuff		; $7228
	ld h,d			; $722b
	ld l,Enemy.var33		; $722c
	ld e,Enemy.direction		; $722e
	ldi a,(hl)		; $7230
	ld (de),a		; $7231
	ld e,Enemy.yh		; $7232
	ldi a,(hl)		; $7234
	ld (de),a		; $7235
	ld e,Enemy.xh		; $7236
	ld a,(hl)		; $7238
	ld (de),a		; $7239
	call objectCreatePuff		; $723a
	jr @notHuggingWall		; $723d

@mediumSmog:
	; Just keep moving forward until we hit a wall
	call _smog_checkHitWall		; $723f
	ret z			; $7242

@hitWall:
	; Rotate direction clockwise or counterclockwise
	ld b,$01		; $7243
	ld e,Enemy.subid		; $7245
	ld a,(de)		; $7247
	bit 7,a			; $7248
	jr z,+			; $724a
	ld b,$ff		; $724c
+
	ld e,Enemy.direction		; $724e
	ld a,(de)		; $7250
	sub b			; $7251
	and $03			; $7252
	ld (de),a		; $7254
	ld e,Enemy.state2		; $7255
	ld a,$02		; $7257
	ld (de),a		; $7259
	ret			; $725a

; Moving normally along wall
@substate2:
	call _smog_updateAdjacentWallsBitset		; $725b
	call _smog_checkHitWall		; $725e
	jr nz,@hitWall	; $7261

@notHuggingWall:
	ld e,Enemy.state2		; $7263
	xor a			; $7265
	ld (de),a		; $7266
	jp _smog_applySpeed		; $7267


; Large smog (can be attacked)
_smog_state8_subid4:
	ld e,Enemy.var2a		; $726a
	ld a,(de)		; $726c
	cp $80|ITEMCOLLISION_ELECTRIC_SHOCK			; $726d
	jr nz,++		; $726f

	; Link attacked the boss and got shocked.
	ld a,$03		; $7271
	ld e,Enemy.state2		; $7273
	ld (de),a		; $7275
	ld a,70		; $7276
	ld e,Enemy.counter2		; $7278
	ld (de),a		; $727a
++
	call enemyAnimate		; $727b
	ld e,Enemy.state2		; $727e
	ld a,(de)		; $7280
	rst_jumpTable			; $7281
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate0:
	ld a,$01		; $728a
	ld (de),a ; [state2] = 1
	dec a			; $728d
	ld e,Enemy.speed		; $728e
	ld (de),a		; $7290

	call _ecom_updateAngleTowardTarget		; $7291

	ld e,Enemy.counter1		; $7294
	ld a,20		; $7296
	ld (de),a		; $7298

; Speeding up
@substate1:
	call @func_72b2		; $7299
	ret nz			; $729c

	add SPEED_20			; $729d
	ld (hl),a		; $729f
	cp SPEED_c0			; $72a0
	ret nz			; $72a2

	jp _ecom_incState2		; $72a3

; Slowing down
@substate2:
	call @func_72b2		; $72a6
	ret nz			; $72a9

	sub SPEED_20			; $72aa
	ld (hl),a		; $72ac
	ret nz			; $72ad

	ld l,Enemy.state2		; $72ae
	ld (hl),a ; [state2] = 0
	ret			; $72b1

;;
; @param[out]	zflag	z if counter1 reached 0 (should update speed)
; @addr{72b2}
@func_72b2:
	ld e,Enemy.animParameter		; $72b2
	ld a,(de)		; $72b4
	or a			; $72b5
	jr z,@parameter0	; $72b6

	dec a			; $72b8
	jr nz,@parameter1	; $72b9

	ld a,$04		; $72bb
	call enemySetAnimation		; $72bd
	jp _smog_setCounterToFireProjectile		; $72c0

@parameter1:
	ld b,PARTID_SMOG_PROJECTILE		; $72c3
	call _ecom_spawnProjectile		; $72c5
	ld l,Part.subid		; $72c8
	inc (hl)		; $72ca
	ld bc,$0800		; $72cb
	jp objectCopyPositionWithOffset		; $72ce

@parameter0:
	call _smog_decCounterToFireProjectile		; $72d1
	jr z,++			; $72d4
	ld a,$05		; $72d6
	call enemySetAnimation		; $72d8
++
	call objectApplySpeed		; $72db
	call _ecom_bounceOffScreenBoundary		; $72de
	call _ecom_decCounter1		; $72e1
	ret nz			; $72e4

	ld (hl),20		; $72e5
	ld l,Enemy.speed		; $72e7
	ld a,(hl)		; $72e9
	ret			; $72ea

; Stop while Link is shocked
@substate3:
	call _ecom_decCounter2		; $72eb
	ret nz			; $72ee
	xor a			; $72ef
	ld (de),a		; $72f0
	ld l,Enemy.collisionType		; $72f1
	set 7,(hl)		; $72f3
	ret			; $72f5


_smog_state8_subid5:
	ret			; $72f6


;;
; @param[out]	zflag	nz if hit a wall
; @addr{72f7}
_smog_checkHitWall:
	ld e,Enemy.direction		; $72f7
	ld a,(de)		; $72f9
	swap a			; $72fa
	rrca			; $72fc
	inc e			; $72fd
	ld (de),a		; $72fe
	jr _smog_checkAdjacentWallsBitset		; $72ff

_smog_positionOffsets:
	.db $f0 $00
	.db $00 $10
	.db $10 $00
	.db $00 $f0

;;
; @param[out]	zflag	nz if hugging a wall
; @addr{7309}
_smog_checkHuggingWall:
	ld b,$ff		; $7309
	ld e,Enemy.subid		; $730b
	ld a,(de)		; $730d
	bit 7,a			; $730e
	jr z,+			; $7310
	ld b,$01		; $7312
+
	; Get direction clockwise or counterclockwise from current direction
	ld e,Enemy.direction		; $7314
	ld a,(de)		; $7316
	sub b			; $7317
	and $03			; $7318
	ld c,a			; $731a

	; Set "angle" value perpendicular to "direction" value
	swap a			; $731b
	rrca			; $731d
	inc e			; $731e
	ld (de),a		; $731f

	; Get position offset in direction smog is moving in
	ld a,c			; $7320
	ld hl,_smog_positionOffsets		; $7321
	rst_addDoubleIndex			; $7324
	ldi a,(hl)		; $7325
	ld c,(hl)		; $7326
	ld b,a			; $7327

	; Put the position of the next tile in var31
	call objectGetRelativeTile		; $7328
	ld h,>wRoomCollisions		; $732b
	ld e,Enemy.var31		; $732d
	ld a,l			; $732f
	and $0f			; $7330
	ld c,a			; $7332
	ld a,l			; $7333
	swap a			; $7334
	and $0f			; $7336
	add c			; $7338
	ld (de),a		; $7339

;;
; Checks if there is a wall in the direction of the "angle" variable. (Angle could be
; facing forward, or in the direction of the wall being hugged, depending when this is
; called.)
;
; @param[out]	zflag	nz if a wall exists
; @addr{733a}
_smog_checkAdjacentWallsBitset:
	ld h,d			; $733a
	ld l,Enemy.angle		; $733b
	ld a,(hl)		; $733d
	bit 3,a			; $733e
	jr z,@upOrDown	; $7340

@leftOrRight:
	ld l,Enemy.var30		; $7342
	ld b,(hl)		; $7344
	bit 4,a			; $7345
	ld a,$03		; $7347
	jr z,+			; $7349
	ld a,$0c		; $734b
+
	and b			; $734d
	ret			; $734e

@upOrDown:
	ld l,Enemy.var30		; $734f
	ld c,(hl)		; $7351
	bit 4,a			; $7352
	ld a,$30		; $7354
	jr nz,+		; $7356
	ld a,$c0		; $7358
+
	and c			; $735a
	ret			; $735b

;;
; Applies speed and updates "adjacentWallsBitset"
; @addr{735c}
_smog_applySpeed:
	; Update angle based on direction
	ld e,Enemy.direction		; $735c
	ld a,(de)		; $735e
	swap a			; $735f
	rrca			; $7361
	inc e			; $7362
	ld (de),a		; $7363
	call objectApplySpeed		; $7364

_smog_updateAdjacentWallsBitset:
	; Clear collision value of wall being hugged?
	ld e,Enemy.var30		; $7367
	xor a			; $7369
	ld (de),a		; $736a

	; Update each bit of adjacent walls bitset
	ld h,d			; $736b
	ld l,Enemy.yh		; $736c
	ld b,(hl)		; $736e
	ld l,Enemy.xh		; $736f
	ld c,(hl)		; $7371
	ld a,$01		; $7372
	ldh (<hFF8B),a	; $7374
	ld hl,@offsetTable		; $7376
@loop:
	ldi a,(hl)		; $7379
	add b			; $737a
	ld b,a			; $737b
	ldi a,(hl)		; $737c
	add c			; $737d
	ld c,a			; $737e
	push hl			; $737f
	call getTileAtPosition		; $7380
	ld h,>wRoomCollisions		; $7383
	ld a,(hl)		; $7385
	or a			; $7386
	jr z,+			; $7387
	scf			; $7389
+
	pop hl			; $738a
	ldh a,(<hFF8B)	; $738b
	rla			; $738d
	ldh (<hFF8B),a	; $738e
	jr nc,@loop	; $7390

	ld e,Enemy.var30		; $7392
	ld (de),a		; $7394
	ret			; $7395

@offsetTable:
	.db $f7 $f8
	.db $00 $0f
	.db $11 $f1
	.db $00 $0f
	.db $f0 $f0
	.db $0f $00
	.db $f1 $11
	.db $0f $00

;;
; @param[out]	zflag	nz if smog should begin "firing projectile" animation
; @addr{73a6}
_smog_decCounterToFireProjectile:
	ld e,Enemy.var36		; $73a6
	ld a,(de)		; $73a8
	or a			; $73a9
	ret z			; $73aa

	dec a			; $73ab
	ld (de),a		; $73ac
	jr nz,@zflag		; $73ad

	or d			; $73af
	ret			; $73b0
@zflag:
	xor a			; $73b1
	ret			; $73b2


;;
; For given values of subid and var03, this reads one of four randomly chosen values and
; puts that value into var36 (counter until next projectile is fired).
; @addr{73b3}
_smog_setCounterToFireProjectile:
	ld e,Enemy.subid		; $73b3
	ld a,(de)		; $73b5
	and $0f			; $73b6
	sub $02			; $73b8
	ld hl,@table		; $73ba
	rst_addAToHl			; $73bd
	ld a,(hl)		; $73be
	rst_addAToHl			; $73bf
	inc e			; $73c0
	ld a,(de) ; [var03]
	rst_addAToHl			; $73c2
	ld a,(hl)		; $73c3
	rst_addAToHl			; $73c4
	call getRandomNumber		; $73c5
	and $03			; $73c8
	rst_addAToHl			; $73ca
	ld a,(hl)		; $73cb
	ld e,Enemy.var36		; $73cc
	ld (de),a		; $73ce
	ret			; $73cf

@table:
        .db @subid2 - CADDR
        .db @subid3 - CADDR
        .db @subid4 - CADDR

@subid2:
	.db @subid2_0 - CADDR
	.db @subid2_1 - CADDR
	.db @subid2_2 - CADDR
	.db @subid2_3 - CADDR
@subid3:
	.db @subid3_0 - CADDR
	.db @subid3_1 - CADDR
	.db @subid3_2 - CADDR
	.db @subid3_3 - CADDR
@subid4:
	.db @subid4_0 - CADDR
	.db @subid4_1 - CADDR
	.db @subid4_2 - CADDR
	.db @subid4_3 - CADDR

@subid2_0:
	.db $78 $f0 $ff $ff
@subid2_1:
	.db $78 $78 $b4 $f0
@subid2_2:
	.db $50 $50 $64 $78
@subid2_3:
	.db $32 $32 $3c $50

@subid3_0:
	.db $00 $00 $00 $00
@subid3_1:
	.db $50 $78 $96 $b4
@subid3_2:
	.db $32 $50 $96 $b4
@subid3_3:
	.db $32 $50 $64 $96

@subid4_0:
	.db $5a $78 $64 $96
@subid4_1:
	.db $1e $28 $32 $3c
@subid4_2:
	.db $14 $1e $32 $3c
@subid4_3:
	.db $14 $1e $28 $32


; ==============================================================================
; ENEMYID_OCTOGON
;
; Variables:
;   var03: Where it actually is? (0 = above water, 1 = below water)
;   counter2: Counter until it moves above or below the water?
;   relatedObj1: Reference to other instance of ENEMYID_OCTOGON?
;   var30: Index in "target position list"?
;   var31/var32: Target position to move to
;   var33/var34: Original Y/X position when this screen was entered
;   var35: Counter for animation purposes?
;   var36: Counter which, when 0 is reached, invokes a change of state (ie. fire at link
;          instead of moving around)
;   var37: Health value from when octogon appeared here (used to decide when to surface or
;          not)
; ==============================================================================
enemyCode7d:
	jr z,@normalStatus	; $740f
	sub ENEMYSTATUS_NO_HEALTH			; $7411
	ret c			; $7413
	jr nz,@justHit	; $7414

	; Dead
	ld e,Enemy.subid		; $7416
	ld a,(de)		; $7418
	cp $02			; $7419
	jp z,enemyDelete		; $741b

	ld e,Enemy.collisionType		; $741e
	ld a,(de)		; $7420
	or a			; $7421
	call nz,_ecom_killRelatedObj1		; $7422
	jp _enemyBoss_dead		; $7425

@justHit:
	ld a,Object.invincibilityCounter		; $7428
	call objectGetRelatedObject1Var		; $742a
	ld e,l			; $742d
	ld a,(de)		; $742e
	ld (hl),a		; $742f

	ld e,Enemy.subid		; $7430
	ld a,(de)		; $7432
	cp $02			; $7433
	jr z,@normalStatus	; $7435

	; Check if enough damage has been dealt to rise above or below the water
	ld h,d			; $7437
	ld l,Enemy.health		; $7438
	ld e,Enemy.var37		; $743a
	ld a,(de)		; $743c
	sub (hl)		; $743d
	cp $0a			; $743e
	jr c,+			; $7440
	ld l,Enemy.counter2		; $7442
	ld (hl),$01		; $7444
+
	ld e,Enemy.health		; $7446
	ld a,(de)		; $7448
	or a			; $7449
	jr nz,@normalStatus	; $744a

	; Health just reached 0
	ld hl,wGroup5Flags+$2d		; $744c
	set 7,(hl)		; $744f
	ld l,$36		; $7451
	set 7,(hl)		; $7453
	ld a,MUS_BOSS		; $7455
	ld (wActiveMusic),a		; $7457
	ret			; $745a

@normalStatus:
	call @doJumpTable		; $745b

	ld h,d			; $745e
	ld l,Enemy.var34		; $745f
	ld e,Enemy.xh		; $7461
	ld a,(de)		; $7463
	ldd (hl),a		; $7464
	ld e,Enemy.yh		; $7465
	ld a,(de)		; $7467
	ld (hl),a		; $7468
	ld l,Enemy.direction		; $7469
	ld a,(hl)		; $746b
	cp $10			; $746c
	jr c,+			; $746e
	ld a,$08		; $7470
+
	and $0c			; $7472
	rrca			; $7474
	ld hl,@offsetData		; $7475
	rst_addAToHl			; $7478

	; Add offsets to Y/X position
	ld a,(de)		; $7479
	add (hl)		; $747a
	ld (de),a		; $747b
	ld e,Enemy.xh		; $747c
	inc hl			; $747e
	ld a,(de)		; $747f
	add (hl)		; $7480
	ld (de),a		; $7481

	; Store some persistent variables?

	ld hl,wTmpcfc0.octogonBoss.var03		; $7482
	ld e,Enemy.var03		; $7485
	ld a,(de)		; $7487
	ldi (hl),a		; $7488

	ld e,Enemy.direction		; $7489
	ld a,(de)		; $748b
	ldi (hl),a ; [wTmpcfc0.octogonBoss.direction]

	ld e,Enemy.health		; $748d
	ld a,(de)		; $748f
	ldi (hl),a ; [wTmpcfc0.octogonBoss.health]

	ld e,Enemy.var33		; $7491
	ld a,(de)		; $7493
	ldi (hl),a ; [wTmpcfc0.octogonBoss.var33]
	inc e			; $7495
	ld a,(de) ; [var34]
	ldi (hl),a ; [wTmpcfc0.octogonBoss.var34]

	ld e,Enemy.var30		; $7498
	ld a,(de)		; $749a
	ld (hl),a ; [wTmpcfc0.octogonBoss.var30]
	ret			; $749c

@offsetData:
	.db $f8 $00
	.db $00 $08
	.db $08 $00
	.db $00 $f8

@doJumpTable:
	ld e,Enemy.state	; $74a5
	ld a,(de)		; $74a7
	cp $08			; $74a8
	ld e,Enemy.subid		; $74aa
	jr c,@state8OrLess	; $74ac

	ld a,(de)		; $74ae
	rst_jumpTable			; $74af
	.dw _octogon_subid0
	.dw _octogon_subid1
	.dw _octogon_subid2


@state8OrLess:
	rst_jumpTable			; $74b6
	.dw _octogon_state_uninitialized
	.dw _octogon_state_stub
	.dw _octogon_state_stub
	.dw _octogon_state_stub
	.dw _octogon_state_stub
	.dw _octogon_state_stub
	.dw _octogon_state_stub
	.dw _octogon_state_stub


_octogon_state_uninitialized:
	ld e,Enemy.subid		; $74c7
	ld a,(de)		; $74c9
	cp $02			; $74ca
	jr nz,@notSubid2	; $74cc

	ld e,Enemy.enemyCollisionMode		; $74ce
	ld a,ENEMYCOLLISION_OCTOGON_SHELL		; $74d0
	ld (de),a		; $74d2
	jp _ecom_setSpeedAndState8		; $74d3

@notSubid2:
	ld a,ENEMYID_OCTOGON		; $74d6
	ld (wEnemyIDToLoadExtraGfx),a		; $74d8
	ld a,PALH_88		; $74db
	call loadPaletteHeader		; $74dd

	ld hl,wTmpcfc0.octogonBoss.loadedExtraGfx		; $74e0
	ld a,(hl)		; $74e3
	or a			; $74e4
	jr nz,++		; $74e5
	inc (hl)		; $74e7
	call _enemyBoss_initializeRoomWithoutExtraGfx		; $74e8
++
	; Create "child" with subid 2? They will reference each other with relatedObj2.
	call getFreeEnemySlot_uncounted		; $74eb
	ret nz			; $74ee
	ld (hl),ENEMYID_OCTOGON		; $74ef
	inc l			; $74f1
	ld (hl),$02 ; [child.subid]
	ld l,Enemy.relatedObj1		; $74f4
	ld e,l			; $74f6
	ld a,Enemy.start		; $74f7
	ld (de),a		; $74f9
	ldi (hl),a		; $74fa
	inc e			; $74fb
	ld a,h			; $74fc
	ld (de),a		; $74fd
	ld (hl),d		; $74fe

	ld a,SPEED_100		; $74ff
	call _ecom_setSpeedAndState8		; $7501

	ld l,Enemy.var35		; $7504
	ld (hl),$0c ; [this.var35]
	inc l			; $7508
	ld (hl),120 ; [var36]

	ld l,Enemy.subid		; $750b
	ld a,(hl)		; $750d
	add a			; $750e
	ld b,a			; $750f
	call objectSetVisible83		; $7510

	; Load persistent variables

	ld hl,wTmpcfc0.octogonBoss.var30		; $7513
	ld e,Enemy.var30		; $7516
	ldd a,(hl)		; $7518
	ld (de),a		; $7519
	ld e,Enemy.xh		; $751a
	ldd a,(hl)		; $751c
	ld (de),a		; $751d
	ld e,Enemy.yh		; $751e
	ldd a,(hl)		; $7520
	ld (de),a		; $7521
	ld e,Enemy.health		; $7522
	ldd a,(hl)		; $7524
	ld (de),a		; $7525
	ld e,Enemy.var37		; $7526
	ld (de),a		; $7528
	ld e,Enemy.direction		; $7529
	ldd a,(hl)		; $752b
	ld (de),a		; $752c
	ld e,Enemy.var03		; $752d
	ld a,(hl)		; $752f
	ld (de),a		; $7530

	add b			; $7531
	rst_jumpTable			; $7532
	.dw @subid0_0
	.dw @subid0_1
	.dw @subid1_0
	.dw @subid1_1

@subid0_0:
	call _octogon_fixPositionAboveWater		; $753b

	ld h,d			; $753e
	ld l,Enemy.counter2		; $753f
	ld (hl),120		; $7541

	ld l,Enemy.var30		; $7543
	ld a,(hl)		; $7545
	inc a			; $7546
	jp z,_octogon_chooseRandomTargetPosition		; $7547

	call _octogon_loadTargetPosition		; $754a
	ret z			; $754d
	dec hl			; $754e
	dec hl			; $754f
	dec hl			; $7550
	ld a,(hl)		; $7551
	ld e,Enemy.direction		; $7552
	ld (de),a		; $7554
	jp enemySetAnimation		; $7555

@subid0_1:
	call _octogon_fixPositionAboveWater		; $7558
	jp _octogon_loadNormalSubmergedAnimation		; $755b

@subid1_0:
	ld h,d			; $755e
	ld l,Enemy.collisionType		; $755f
	res 7,(hl)		; $7561

	; Delete child object (subid 2)
	ld a,Object.start		; $7563
	call objectGetRelatedObject1Var		; $7565
	ld b,$40		; $7568
	call clearMemory		; $756a

	jp objectSetInvisible		; $756d

@subid1_1:
	ld a,$01		; $7570
	ld (wTmpcfc0.octogonBoss.posNeedsFixing),a		; $7572

	ld h,d			; $7575
	ld l,Enemy.oamFlagsBackup		; $7576
	ld a,$06		; $7578
	ldi (hl),a		; $757a
	ld (hl),a		; $757b

	ld l,Enemy.counter1		; $757c
	ld (hl),90		; $757e
	inc l			; $7580
	ld (hl),150 ; [counter2]

	ld l,Enemy.var31		; $7583
	ldh a,(<hEnemyTargetY)	; $7585
	ldi (hl),a		; $7587
	ldh a,(<hEnemyTargetX)	; $7588
	ld (hl),a		; $758a

	call _ecom_updateAngleTowardTarget		; $758b
	add $04			; $758e
	and $18			; $7590
	rrca			; $7592
	ld e,Enemy.direction		; $7593
	ld (de),a		; $7595
	call enemySetAnimation		; $7596

	call getFreeInteractionSlot		; $7599
	ret nz			; $759c
	ld (hl),INTERACID_BUBBLE		; $759d
	inc l			; $759f
	inc (hl) ; [bubble.subid] = 1
	ld l,Interaction.relatedObj1		; $75a1
	ld a,Enemy.start		; $75a3
	ldi (hl),a		; $75a5
	ld (hl),d		; $75a6
	ret			; $75a7


_octogon_state_stub:
	ret			; $75a8


_octogon_subid0:
	; Initialize Y/X position
	ld h,d			; $75a9
	ld l,Enemy.var33		; $75aa
	ld e,Enemy.yh		; $75ac
	ldi a,(hl)		; $75ae
	ld (de),a		; $75af
	ld e,Enemy.xh		; $75b0
	ld a,(hl)		; $75b2
	ld (de),a		; $75b3

	; Check if submerged
	ld e,Enemy.var03		; $75b4
	ld a,(de)		; $75b6
	or a			; $75b7
	ld e,Enemy.state		; $75b8
	ld a,(de)		; $75ba
	jp nz,_octogon_subid0BelowWater		; $75bb

	sub $08			; $75be
	rst_jumpTable			; $75c0
	.dw _octogon_subid0AboveWater_state8
	.dw _octogon_subid0AboveWater_state9
	.dw _octogon_subid0AboveWater_stateA
	.dw _octogon_subid0AboveWater_stateB
	.dw _octogon_subid0AboveWater_stateC
	.dw _octogon_subid0AboveWater_stateD
	.dw _octogon_subid0AboveWater_stateE
	.dw _octogon_subid0AboveWater_stateF
	.dw _octogon_subid0AboveWater_state10
	.dw _octogon_subid0AboveWater_state11


_octogon_subid0AboveWater_state8:
	; Wait for shutters to close
	ld a,($cc93)		; $75d5
	or a			; $75d8
	ret nz			; $75d9

	ld h,d			; $75da
	ld l,e			; $75db
	inc (hl) ; [state] = 9

	; Initialize music if necessary
	ld hl,wActiveMusic		; $75dd
	ld a,(hl)		; $75e0
	or a			; $75e1
	ret z			; $75e2
	ld (hl),$00		; $75e3
	ld a,MUS_BOSS		; $75e5
	jp playSound		; $75e7


; Moving normally around the room
_octogon_subid0AboveWater_state9:
	call _octogon_decVar36IfNonzero		; $75ea

	; Submerge into water after set amount of time
	ld a,(wFrameCounter)		; $75ed
	and $03			; $75f0
	jr nz,++		; $75f2
	ld l,Enemy.counter2		; $75f4
	dec (hl)		; $75f6
	jp z,_octogon_subid0_submergeIntoWater		; $75f7
++
	; Check if lined up to fire at Link.
	; BUG: Should set 'b', not 'c'? (b happens to be $0f here, so it works out ok.)
	ld c,$08		; $75fa
	call objectCheckCenteredWithLink		; $75fc
	jp nc,_octogon_updateMovementAndAnimation		; $75ff

	; If enough time has passed, begin firing at Link.
	ld h,d			; $7602
	ld l,Enemy.var36		; $7603
	ld a,(hl)		; $7605
	or a			; $7606
	jp nz,_octogon_updateMovementAndAnimation		; $7607

	ld (hl),120 ; [var36]

	; Begin turning toward Link to fire.
	call objectGetAngleTowardEnemyTarget		; $760c
	add $14			; $760f
	and $18			; $7611
	ld b,a			; $7613
	ld e,Enemy.direction		; $7614
	ld a,(de)		; $7616
	and $0c			; $7617
	add a			; $7619
	cp b			; $761a
	jp nz,_octogon_updateMovementAndAnimation		; $761b

	ld h,d			; $761e
	ld l,Enemy.state		; $761f
	ld (hl),$0b		; $7621

	ld l,Enemy.counter1		; $7623
	ld (hl),$08		; $7625
	ret			; $7627


_octogon_subid0AboveWater_stateA:
_octogon_subid0_pauseMovement:
	call _ecom_decCounter1		; $7628
	ret nz			; $762b

	ld l,e			; $762c
	dec (hl) ; [state]--

	ld l,Enemy.var30		; $762e
	ld a,(hl)		; $7630
	inc a			; $7631
	ld (hl),a		; $7632

	and $07			; $7633
	jr nz,_octogon_loadTargetPosition	; $7635


;;
; @addr{7637}
_octogon_chooseRandomTargetPosition:
	call getRandomNumber		; $7637
	and $18			; $763a
	ld (hl),a		; $763c

;;
; @param	hl	Pointer to index for a table
; @param[out]	hl	Pointer to some data
; @param[out]	zflag	z if animation changed
; @addr{763d}
_octogon_loadTargetPosition:
	ld a,(hl)		; $763d
	add a			; $763e
	add (hl)		; $763f
	ld hl,@targetPositionList		; $7640
	rst_addAToHl			; $7643
	ld e,Enemy.var31		; $7644
	ldi a,(hl)		; $7646
	ld (de),a		; $7647
	inc e			; $7648
	ldi a,(hl)		; $7649
	ld (de),a ; [var32]
	ld e,Enemy.var03		; $764b
	ld a,(de)		; $764d
	or a			; $764e
	ret nz			; $764f

	ld a,(hl)		; $7650
	bit 7,a			; $7651
	ret nz			; $7653

	ld e,Enemy.direction		; $7654
	ld (de),a		; $7656
	call enemySetAnimation		; $7657
	xor a			; $765a
	ret			; $765b

; data format: target position (2 bytes), animation
@targetPositionList:
	.db $28 $38 $00
	.db $58 $30 $0c
	.db $88 $38 $ff
	.db $88 $78 $08
	.db $88 $b8 $ff
	.db $58 $c0 $04
	.db $28 $b8 $ff
	.db $28 $78 $00

	.db $28 $b8 $00
	.db $58 $c0 $04
	.db $88 $b8 $ff
	.db $88 $78 $08
	.db $88 $38 $ff
	.db $58 $30 $0c
	.db $28 $38 $ff
	.db $28 $78 $00

	.db $28 $38 $00
	.db $58 $30 $0c
	.db $88 $38 $ff
	.db $88 $78 $08
	.db $88 $38 $ff
	.db $58 $30 $0c
	.db $28 $38 $ff
	.db $28 $78 $00

	.db $28 $b8 $00
	.db $58 $c0 $04
	.db $88 $b8 $ff
	.db $88 $78 $08
	.db $88 $b8 $ff
	.db $58 $c0 $04
	.db $28 $b8 $ff
	.db $28 $78 $00


; Turning around to fire projectile (or just after doing so)?
_octogon_subid0AboveWater_stateB:
_octogon_subid0AboveWater_stateF:
	ld b,$06		; $76bc
	jr _octogon_subid0AboveWater_turningAround	; $76be


; Turning around?
_octogon_subid0AboveWater_stateC:
	ld b,$18		; $76c0

_octogon_subid0AboveWater_turningAround:
	call _ecom_decCounter1		; $76c2
	ret nz			; $76c5

	ld (hl),b		; $76c6
	ld l,e			; $76c7
	inc (hl) ; [state]++

	ld l,Enemy.direction		; $76c9
	ld a,(hl)		; $76cb
	add $04			; $76cc
	and $0c			; $76ce
	ld (hl),a		; $76d0
	jp enemySetAnimation		; $76d1


; About to fire projectile?
_octogon_subid0AboveWater_stateD:
	call _ecom_decCounter1		; $76d4
	ret nz			; $76d7

	ld (hl),$08		; $76d8

	ld l,e			; $76da
	inc (hl) ; [state] = $0e

	ld l,Enemy.direction		; $76dc
	ld a,(hl)		; $76de
	add $02			; $76df
	ld (hl),a		; $76e1
	jp enemySetAnimation		; $76e2


; Firing projectile
_octogon_subid0AboveWater_stateE:
	call _ecom_decCounter1		; $76e5
	ret nz			; $76e8

	ld (hl),40		; $76e9
	ld l,e			; $76eb
	inc (hl) ; [state] = $0f
	ld l,Enemy.direction		; $76ed
	inc (hl)		; $76ef
	ld a,(hl)		; $76f0
	call enemySetAnimation		; $76f1
	jp _octogon_fireOctorokProjectile		; $76f4


; Turning around after firing projectile?
_octogon_subid0AboveWater_state10:
	ld b,$0c		; $76f7
	jr _octogon_subid0AboveWater_turningAround		; $76f9


; Delay before resuming normal movement
_octogon_subid0AboveWater_state11:
	call _ecom_decCounter1		; $76fb
	ret nz			; $76fe
	ld l,e			; $76ff
	ld (hl),$09 ; [state]
	ret			; $7702


; Octogon code where octogon itself is below water, and link is above water
_octogon_subid0BelowWater:
	sub $08			; $7703
	rst_jumpTable			; $7705
	.dw _octogon_subid0BelowWater_state8
	.dw _octogon_subid0BelowWater_state9
	.dw _octogon_subid0BelowWater_stateA
	.dw _octogon_subid0BelowWater_stateB
	.dw _octogon_subid0BelowWater_stateC
	.dw _octogon_subid0BelowWater_stateD


; Swimming normally
_octogon_subid0BelowWater_state8:
	call enemyAnimate		; $7712

	; Check whether to play swimming sound
	ld e,Enemy.animParameter		; $7715
	ld a,(de)		; $7717
	or a			; $7718
	jr nz,++		; $7719
	inc a			; $771b
	ld (de),a		; $771c
	ld a,SND_LINK_SWIM		; $771d
	call playSound		; $771f
++
	call _octogon_decVar36IfNonzero		; $7722
	jp nz,_octogon_moveTowardTargetPosition		; $7725

	; Reached target position
	ld (hl),90 ; [var36]
	call getRandomNumber		; $772a
	cp $50			; $772d
	jp nc,_octogon_moveTowardTargetPosition		; $772f

	; Random chance of going to state $0a (firing projectile)
	ld l,Enemy.state		; $7732
	ld (hl),$0a		; $7734
	ld l,Enemy.counter1		; $7736
	ld (hl),60		; $7738
	jr _octogon_loadNormalSubmergedAnimation		; $773a


; Waiting in place before moving again
_octogon_subid0BelowWater_state9:
	call _octogon_subid0_pauseMovement		; $773c
_octogon_animate:
	jp enemyAnimate		; $773f


; Delay before firing projectile
_octogon_subid0BelowWater_stateA:
	call _ecom_decCounter1		; $7742
	jr z,@beginFiring	; $7745

	ld a,(hl)		; $7747
	and $07			; $7748
	ret nz			; $774a
	ld l,Enemy.direction		; $774b
	ld a,(hl)		; $774d
	xor $01			; $774e
	ld (hl),a		; $7750
	jp enemySetAnimation		; $7751

@beginFiring:
	ld (hl),$08		; $7754
	ld l,e			; $7756
	inc (hl) ; [state] = $0b

_octogon_loadNormalSubmergedAnimation:
	ld e,Enemy.direction		; $7758
	ld a,$12		; $775a
	ld (de),a		; $775c
	jp enemySetAnimation		; $775d


; Firing projectile
_octogon_subid0BelowWater_stateB:
	call _ecom_decCounter1		; $7760
	jr z,@fireProjectile	; $7763

	ld a,(hl)		; $7765
	cp $06			; $7766
	ret nz			; $7768

	ld l,Enemy.direction		; $7769
	ld a,$14		; $776b
	ld (hl),a		; $776d
	jp enemySetAnimation		; $776e

@fireProjectile:
	ld (hl),60 ; [counter1]
	ld l,e			; $7773
	inc (hl) ; [state] = $0c
	ld b,PARTID_OCTOGON_DEPTH_CHARGE		; $7775
	call _ecom_spawnProjectile		; $7777
	jr _octogon_loadNormalSubmergedAnimation		; $777a


; Delay before moving again
_octogon_subid0BelowWater_stateC:
	call _ecom_decCounter1		; $777c
	jr nz,_octogon_animate	; $777f

	ld l,Enemy.var36		; $7781
	ld (hl),90		; $7783

	ld l,e			; $7785
	ld (hl),$08 ; [state]

	jr _octogon_animate		; $7788


; Just submerged into water
_octogon_subid0BelowWater_stateD:
	call _ecom_decCounter1		; $778a
	ret nz			; $778d
	ld (hl),30		; $778e

	ld l,e			; $7790
	ld (hl),$08 ; [state]

	jr _octogon_loadNormalSubmergedAnimation		; $7793


; Link is below water
_octogon_subid1:
	ld h,d			; $7795
	ld l,Enemy.var33		; $7796
	ld e,Enemy.yh		; $7798
	ldi a,(hl)		; $779a
	ld (de),a		; $779b
	ld e,Enemy.xh		; $779c
	ld a,(hl)		; $779e
	ld (de),a		; $779f

	ld e,Enemy.var03		; $77a0
	ld a,(de)		; $77a2
	or a			; $77a3
	ld e,Enemy.state		; $77a4
	ld a,(de)		; $77a6
	jp z,_octogon_subid1_aboveWater		; $77a7

	sub $08			; $77aa
	rst_jumpTable			; $77ac
	.dw _octogon_subid1_belowWater_state8
	.dw _octogon_subid1_belowWater_state9
	.dw _octogon_subid1_belowWater_stateA
	.dw _octogon_subid1_belowWater_stateB
	.dw _octogon_subid1_belowWater_stateC


; Normal movement (moving toward some target position decided already)
_octogon_subid1_belowWater_state8:
	call _octogon_decVar36IfNonzero		; $77b7
	jr nz,@normalMovement	; $77ba

	; var36 reached 0
	ld (hl),90		; $77bc

	; 50% chance to do check below...
	call getRandomNumber		; $77be
	rrca			; $77c1
	jr nc,@normalMovement	; $77c2

	; If the direction toward Link has not changed...
	call objectGetAngleTowardEnemyTarget		; $77c4
	add $04			; $77c7
	and $18			; $77c9
	ld b,a			; $77cb
	ld e,Enemy.angle		; $77cc
	ld a,(de)		; $77ce
	add $04			; $77cf
	and $18			; $77d1
	cp b			; $77d3
	ld h,d			; $77d4
	jr nz,@normalMovement	; $77d5

	; Go to state $0b (fire bubble projectile)
	ld l,Enemy.state		; $77d7
	ld (hl),$0b		; $77d9
	ld l,Enemy.counter1		; $77db
	ld (hl),$08		; $77dd
	ld l,Enemy.direction		; $77df
	ld a,(hl)		; $77e1
	and $0c			; $77e2
	add $02			; $77e4
	ld (hl),a		; $77e6
	jp enemySetAnimation		; $77e7

@normalMovement:
	; Will rise above water when counter2 reaches 0
	ld a,(wFrameCounter)		; $77ea
	and $03			; $77ed
	jr nz,++		; $77ef
	ld l,Enemy.counter2		; $77f1
	dec (hl)		; $77f3
	jp z,_octogon_beginRisingAboveWater		; $77f4
++
	call _ecom_decCounter1		; $77f7
	jr nz,_octogon_updateMovementAndAnimation	; $77fa

	ld (hl),60 ; [counter1]

	ld l,Enemy.state		; $77fe
	inc (hl) ; [state] = 9
	ret			; $7801

;;
; Moves toward target position and updates animation + sound effects accordingly
; @addr{7802}
_octogon_updateMovementAndAnimation:
	call _octogon_moveTowardTargetPosition		; $7802

	ld h,d			; $7805
	ld l,Enemy.var35		; $7806
	dec (hl)		; $7808
	ret nz			; $7809

	ld (hl),$0c		; $780a

	ld l,Enemy.direction		; $780c
	ld a,(hl)		; $780e
	xor $01			; $780f
	ld (hl),a		; $7811
	call enemySetAnimation		; $7812

	ld e,Enemy.subid		; $7815
	ld a,(de)		; $7817
	or a			; $7818
	ld a,SND_LINK_SWIM		; $7819
	jp nz,playSound		; $781b

	; Above-water only (subid 0)

;;
; @addr{781e}
_octogon_doSplashAnimation:
	ld a,SND_SWORDSPIN		; $781e
	call playSound		; $7820

	; Splash animation
	call getFreeInteractionSlot		; $7823
	ret nz			; $7826
	ld (hl),INTERACID_OCTOGON_SPLASH		; $7827
	ld e,Enemy.direction		; $7829
	ld a,(de)		; $782b
	and $0c			; $782c
	ld l,Interaction.direction		; $782e
	ld (hl),a		; $7830
	jp objectCopyPosition		; $7831


; Waiting in place until counter1 reaches 0, then will charge at Link.
_octogon_subid1_belowWater_state9:
	call _ecom_decCounter1		; $7834
	ret nz			; $7837

	ld (hl),$0c ; [counter1]

	ld l,e			; $783a
	inc (hl) ; [state] = $0a

	; Save Link's current position as target position to charge at
	ld l,Enemy.var31		; $783c
	ldh a,(<hEnemyTargetY)	; $783e
	ldi (hl),a		; $7840
	ldh a,(<hEnemyTargetX)	; $7841
	ld (hl),a		; $7843

	; Do some weird math to decide animation
	call _ecom_updateAngleTowardTarget		; $7844
	ld h,d			; $7847
	ld l,Enemy.direction		; $7848
	ld a,(hl)		; $784a
	and $0c			; $784b
	add a			; $784d
	ld b,a			; $784e

	ld e,Enemy.angle		; $784f
	ld a,(de)		; $7851
	sub b			; $7852
	and $1f			; $7853
	ld b,a			; $7855
	sub $04			; $7856
	cp $18			; $7858
	ret nc			; $785a

	bit 4,b			; $785b
	ld a,$04		; $785d
	jr z,+			; $785f
	ld a,$0c		; $7861
+
	add (hl)		; $7863
	and $0c			; $7864
	ld (hl),a		; $7866
	jp enemySetAnimation		; $7867


; Waiting for a split second before charging
_octogon_subid1_belowWater_stateA:
	call _ecom_decCounter1		; $786a
	ret nz			; $786d

	ld (hl),90		; $786e

	ld l,e			; $7870
	ld (hl),$08 ; [state]

	ld l,Enemy.angle		; $7873
	ldd a,(hl)		; $7875
	add $04			; $7876
	and $18			; $7878
	rrca			; $787a
	ld (hl),a		; $787b
	jp enemySetAnimation		; $787c


; Delay before firing bubble
_octogon_subid1_belowWater_stateB:
	call _ecom_decCounter1		; $787f
	ret nz			; $7882

	ld (hl),60		; $7883

	ld l,e			; $7885
	inc (hl) ; [state] = $0c

	ld l,Enemy.direction		; $7887
	inc (hl)		; $7889
	ld a,(hl)		; $788a
	call enemySetAnimation		; $788b

	call getFreePartSlot		; $788e
	jr nz,++		; $7891
	ld (hl),PARTID_OCTOGON_BUBBLE		; $7893
	call _octogon_initializeProjectile		; $7895
++
	jp _octogon_doSplashAnimation		; $7898


; Delay after firing bubble
_octogon_subid1_belowWater_stateC:
	call _ecom_decCounter1		; $789b
	ret nz			; $789e

	ld l,e			; $789f
	ld (hl),$08 ; [state]

	ld l,Enemy.direction		; $78a2
	ld a,(hl)		; $78a4
	and $0c			; $78a5
	ld (hl),a		; $78a7
	jp enemySetAnimation		; $78a8


; Octogon is above water, but Link is below water
_octogon_subid1_aboveWater:
	sub $08			; $78ab
	rst_jumpTable			; $78ad
	.dw @state8
	.dw @state9
	.dw @stateA

@state8:
	call _ecom_decCounter1		; $78b4
	ret nz			; $78b7
	ld (hl),120		; $78b8
	ld b,PARTID_OCTOGON_DEPTH_CHARGE		; $78ba
	jp _ecom_spawnProjectile		; $78bc


; States $09-$0a used while moving to surface
@state9:
	call _ecom_decCounter1		; $78bf
	ret nz			; $78c2

	ld l,e			; $78c3
	inc (hl) ; [state] = $0a

	ld l,Enemy.direction		; $78c5
	ld a,$11		; $78c7
	ld (hl),a		; $78c9
	call enemySetAnimation		; $78ca

	ld a,SND_ENEMY_JUMP		; $78cd
	call playSound		; $78cf

	ld bc,$0208		; $78d2
	jp _enemyBoss_spawnShadow		; $78d5

@stateA:
	ld h,d			; $78d8
	ld l,Enemy.z		; $78d9
	ld a,(hl)		; $78db
	sub <($00c0)			; $78dc
	ldi (hl),a		; $78de
	ld a,(hl)		; $78df
	sbc >($00c0)			; $78e0
	ld (hl),a		; $78e2

	cp $d0			; $78e3
	ret nc			; $78e5

	cp $c0			; $78e6
	jp nz,_ecom_flickerVisibility		; $78e8

	ld (hl),$00		; $78eb

	ld l,e			; $78ed
	ld (hl),$08 ; [state] = 8

	ld l,Enemy.collisionType		; $78f0
	res 7,(hl)		; $78f2

	ld l,Enemy.counter1		; $78f4
	ld (hl),60		; $78f6

	call objectSetInvisible		; $78f8
	jp _ecom_killRelatedObj1		; $78fb


; Invisible collision box for the shell
_octogon_subid2:
	ld a,Object.direction		; $78fe
	call objectGetRelatedObject1Var		; $7900
	ld a,(hl)		; $7903
	cp $10			; $7904
	jr c,+			; $7906
	ld a,$08		; $7908
+
	and $0c			; $790a
	push hl			; $790c
	ld hl,@data		; $790d
	rst_addAToHl			; $7910

	ld e,Enemy.collisionRadiusY		; $7911
	ldi a,(hl)		; $7913
	ld (de),a		; $7914
	inc e			; $7915
	ldi a,(hl)		; $7916
	ld (de),a		; $7917

	ldi a,(hl)		; $7918
	ld c,(hl)		; $7919
	ld b,a			; $791a
	pop hl			; $791b
	call objectTakePositionWithOffset		; $791c
	pop hl			; $791f
	ret			; $7920

; Data format: collisionRadiusY, collisionRadiusX, Y position, X position
@data:
	.db $06 $0a $0e $00
	.db $0a $06 $00 $f2
	.db $06 $0a $f2 $00
	.db $0a $06 $00 $0e


;;
; @addr{7931}
_octogon_subid0_submergeIntoWater:
	ld h,d			; $7931
	ld l,Enemy.state		; $7932
	ld (hl),$0d		; $7934
	ld l,Enemy.collisionType		; $7936
	res 7,(hl)		; $7938
	ld l,Enemy.var03		; $793a
	ld (hl),$01		; $793c
	ld l,Enemy.counter1		; $793e
	ld (hl),$10		; $7940
	ld l,Enemy.var36		; $7942
	ld (hl),90		; $7944
	ld l,Enemy.direction		; $7946
	ld a,$15		; $7948
	ld (hl),a		; $794a
	jp enemySetAnimation		; $794b


;;
; @addr{794e}
_octogon_beginRisingAboveWater:
	ld h,d			; $794e
	ld l,Enemy.state		; $794f
	ld (hl),$09		; $7951
	ld l,Enemy.var03		; $7953
	ld (hl),$00		; $7955

	ld l,Enemy.counter1		; $7957
	ld (hl),30		; $7959

	ld l,Enemy.var36		; $795b
	ld (hl),90		; $795d

	ld l,Enemy.direction		; $795f
	ld a,$10		; $7961
	ld (hl),a		; $7963
	jp enemySetAnimation		; $7964


;;
; Takes current position, fixes it to the closest valid spot above water, and decides
; a value for var30 (target position index).
; @addr{7967}
_octogon_fixPositionAboveWater:
	ld a,(wTmpcfc0.octogonBoss.posNeedsFixing)		; $7967
	or a			; $796a
	ret z			; $796b

	xor a			; $796c
	ld (wTmpcfc0.octogonBoss.posNeedsFixing),a		; $796d

	ld h,d			; $7970
	ld l,Enemy.yh		; $7971
	ldi a,(hl)		; $7973
	ld b,a			; $7974
	inc l			; $7975
	ld c,(hl)		; $7976
	call _octogon_getClosestTargetPositionIndex		; $7977
	ld l,e			; $797a

	ld a,(w1Link.yh)		; $797b
	ld b,a			; $797e
	ld a,(w1Link.xh)		; $797f
	ld c,a			; $7982
	call _octogon_getClosestTargetPositionIndex		; $7983

	; BUG: supposed to compare 'l' against 'e', not 'a'. As a result octogon may not
	; move out of the way properly if Link surfaces in the same position.
	; (In effect, it only matters when they're both around centre-bottom, and maybe
	; one other spot?)
	cp l			; $7986
	ld a,l			; $7987
	jr nz,++		; $7988
	ld hl,@linkCompensationIndices		; $798a
	rst_addAToHl			; $798d
	ld a,(hl)		; $798e
++
	add a			; $798f
	ld hl,@data		; $7990
	rst_addDoubleIndex			; $7993
	ld e,Enemy.yh		; $7994
	ldi a,(hl)		; $7996
	ld (de),a		; $7997
	ld e,Enemy.xh		; $7998
	ldi a,(hl)		; $799a
	ld (de),a		; $799b
	ld e,Enemy.var30		; $799c
	ld a,(hl)		; $799e
	ld (de),a		; $799f

	ld h,d			; $79a0
	ld l,e			; $79a1
	bit 7,a			; $79a2
	jp nz,_octogon_chooseRandomTargetPosition		; $79a4
	jp _octogon_loadTargetPosition		; $79a7

; Data format: Y, X, var30 (target position index), unused
@data:
	.db $28 $30 $01 $00
	.db $28 $78 $ff $00
	.db $28 $c0 $09 $00
	.db $58 $30 $02 $00
	.db $00 $00 $ff $00
	.db $58 $c0 $0a $00
	.db $88 $30 $0d $00
	.db $88 $78 $0c $00
	.db $88 $c0 $05 $00

; Corresponding index from this table is used if Link would have surfaced on top of
; octogon.
@linkCompensationIndices:
	.db $01 $00 $01 $06 $00 $08 $03 $08 $05

;;
; @addr{79d7}
_octogon_fireOctorokProjectile:
	call getFreePartSlot		; $79d7
	ret nz			; $79da
	ld (hl),PARTID_OCTOROK_PROJECTILE		; $79db

;;
; @param	h	Projectile (could be PARTID_OCTOROK_PROJECTILE or
;			PARTID_OCTOGON_BUBBLE)
; @addr{79dd}
_octogon_initializeProjectile:
	ld e,Enemy.direction		; $79dd
	ld a,(de)		; $79df
	and $0c			; $79e0
	ld b,a			; $79e2
	add a			; $79e3
	ld l,Part.angle		; $79e4
	ld (hl),a		; $79e6

	ld a,b			; $79e7
	rrca			; $79e8
	push hl			; $79e9
	ld hl,@positionOffsets		; $79ea
	rst_addAToHl			; $79ed
	ldi a,(hl)		; $79ee
	ld b,a			; $79ef
	ld c,(hl)		; $79f0

	pop hl			; $79f1
	call objectCopyPositionWithOffset		; $79f2
	ld a,SND_STRIKE		; $79f5
	jp playSound		; $79f7

@positionOffsets:
	.db $f0 $00
	.db $00 $10
	.db $10 $00
	.db $00 $f0

;;
; @addr{7a02}
_octogon_decVar36IfNonzero:
	ld h,d			; $7a02
	ld l,Enemy.var36		; $7a03
	ld a,(hl)		; $7a05
	or a			; $7a06
	ret z			; $7a07
	dec (hl)		; $7a08
	ret			; $7a09

;;
; Moves toward position stored in var31/var32. Increments state and sets counter1 to 30
; when it reaches that position.
; @addr{7a0a}
_octogon_moveTowardTargetPosition:
	ld h,d			; $7a0a
	ld l,Enemy.var31		; $7a0b
	call _ecom_readPositionVars		; $7a0d
	sub c			; $7a10
	inc a			; $7a11
	cp $03			; $7a12
	jp nc,_ecom_moveTowardPosition		; $7a14

	ldh a,(<hFF8F)	; $7a17
	sub b			; $7a19
	inc a			; $7a1a
	cp $03			; $7a1b
	jp nc,_ecom_moveTowardPosition		; $7a1d

	ld l,Enemy.yh		; $7a20
	ld (hl),b		; $7a22
	ld l,Enemy.xh		; $7a23
	ld (hl),c		; $7a25
	ld l,Enemy.state		; $7a26
	inc (hl)		; $7a28
	ld l,Enemy.counter1		; $7a29
	ld (hl),30		; $7a2b
	ret			; $7a2d


;;
; Given a position, this determines the "target position index" (value for var30) which
; that position most closely corresponds to.
;
; @param	bc	Position
; @param[out]	a
; @param[out]	e
; @addr{7a2e}
_octogon_getClosestTargetPositionIndex:
	ld e,$00		; $7a2e

@checkY:
	ld a,b			; $7a30
	cp $40			; $7a31
	jr c,@checkX	; $7a33
	ld e,$03		; $7a35
	cp $70			; $7a37
	jr c,@checkX	; $7a39

	ld e,$06		; $7a3b
@checkX:
	ld a,c			; $7a3d
	cp $50			; $7a3e
	jr c,++		; $7a40
	inc e			; $7a42
	cp $a0			; $7a43
	jr c,++		; $7a45

	inc e			; $7a47
++
	ld a,e			; $7a48
	cp $04			; $7a49
	ret nz			; $7a4b

	ld e,$00		; $7a4c
	ld a,b			; $7a4e
	cp $58			; $7a4f
	jr c,+			; $7a51
	ld e,$06		; $7a53
+
	ld a,c			; $7a55
	cp $78			; $7a56
	ret c			; $7a58
	inc e			; $7a59
	inc e			; $7a5a
	ret			; $7a5b

; ==============================================================================
; ENEMYID_PLASMARINE
;
; Variables:
;   counter2: Number of times to do shock attack before firing projectiles
;   var30/var31: Target position?
;   var32: Color (0 for blue, 1 for red)
;   var33: ?
;   var34: Number of projectiles to fire in one attack
; ==============================================================================
enemyCode7e:
	jr z,@normalStatus	; $7a5c

	sub ENEMYSTATUS_NO_HEALTH			; $7a5e
	ret c			; $7a60
	jp z,_enemyBoss_dead		; $7a61

	; Hit by something
	ld e,Enemy.enemyCollisionMode		; $7a64
	ld a,(de)		; $7a66
	cp ENEMYCOLLISION_PLASMARINE_SHOCK			; $7a67
	jr z,@normalStatus	; $7a69

	ld e,Enemy.var2a		; $7a6b
	ld a,(de)		; $7a6d
	res 7,a			; $7a6e
	cp ITEMCOLLISION_L1_SWORD			; $7a70
	call nc,_plasmarine_state_switchHook@swapColor		; $7a72

@normalStatus:
	ld e,Enemy.state		; $7a75
	ld a,(de)		; $7a77
	rst_jumpTable			; $7a78
	.dw _plasmarine_state_uninitialized
	.dw _plasmarine_state_stub
	.dw _plasmarine_state_stub
	.dw _plasmarine_state_switchHook
	.dw _plasmarine_state_stub
	.dw _plasmarine_state_stub
	.dw _plasmarine_state_stub
	.dw _plasmarine_state_stub
	.dw _plasmarine_state8
	.dw _plasmarine_state9
	.dw _plasmarine_stateA
	.dw _plasmarine_stateB
	.dw _plasmarine_stateC
	.dw _plasmarine_stateD
	.dw _plasmarine_stateE
	.dw _plasmarine_stateF


_plasmarine_state_uninitialized:
	ld a,SPEED_280		; $7a99
	call _ecom_setSpeedAndState8		; $7a9b
	ld l,Enemy.angle		; $7a9e
	ld (hl),$08		; $7aa0

	ld l,Enemy.counter1		; $7aa2
	ld (hl),$04		; $7aa4

	ld l,Enemy.var30		; $7aa6
	ld (hl),$58		; $7aa8
	inc l			; $7aaa
	ld (hl),$78		; $7aab

	ld a,$01		; $7aad
	ld (wMenuDisabled),a		; $7aaf
	ld (wDisabledObjects),a		; $7ab2

	ld a,ENEMYID_PLASMARINE		; $7ab5
	ld b,$00		; $7ab7
	call _enemyBoss_initializeRoom		; $7ab9
	jp objectSetVisible83		; $7abc


_plasmarine_state_switchHook:
	inc e			; $7abf
	ld a,(de)		; $7ac0
	rst_jumpTable			; $7ac1
	.dw @justLatched
	.dw @beforeSwitch
	.dw @afterSwitch
	.dw @released

@justLatched:
	xor a			; $7aca
	ld e,Enemy.var33		; $7acb
	ld (de),a		; $7acd
	call enemySetAnimation		; $7ace
	jp _ecom_incState2		; $7ad1

@afterSwitch:
	ld e,Enemy.var33		; $7ad4
	ld a,(de)		; $7ad6
	or a			; $7ad7
	ret nz			; $7ad8
	inc a			; $7ad9
	ld (de),a		; $7ada
	ld a,SND_MYSTERY_SEED		; $7adb
	call playSound		; $7add


; This is called from outside "plasmarine_state_switchHook" (ie. when sword slash occurs).
@swapColor:
	ld h,d			; $7ae0
	ld l,Enemy.var32		; $7ae1
	ld a,(hl)		; $7ae3
	xor $01			; $7ae4
	ld (hl),a		; $7ae6
	inc a			; $7ae7
	ld l,Enemy.oamFlagsBackup		; $7ae8
	ldi (hl),a		; $7aea
	ld (hl),a		; $7aeb


@beforeSwitch:
	ret			; $7aec


@released:
	ld b,$0a		; $7aed
	call _ecom_fallToGroundAndSetState		; $7aef
	ret nz			; $7af2
	ld l,Enemy.counter1		; $7af3
	ld (hl),60		; $7af5
	jp _plasmarine_decideNumberOfShockAttacks		; $7af7


_plasmarine_state_stub:
	ret			; $7afa


; Moving toward centre of room before starting fight
_plasmarine_state8:
	call _plasmarine_checkCloseToTargetPosition		; $7afb
	jr c,@reachedTarget	; $7afe

	call _ecom_decCounter1		; $7b00
	jr nz,++		; $7b03
	ld (hl),$04		; $7b05
	call objectGetRelativeAngleWithTempVars		; $7b07
	call objectNudgeAngleTowards		; $7b0a
++
	call objectApplySpeed		; $7b0d
	jr _plasmarine_animate		; $7b10

@reachedTarget:
	ld l,e			; $7b12
	inc (hl) ; [state] = 9

	ld l,Enemy.counter1		; $7b14
	ld (hl),60		; $7b16
	ld l,Enemy.yh		; $7b18
	ld (hl),b		; $7b1a
	ld l,Enemy.xh		; $7b1b
	ld (hl),c		; $7b1d
	jr _plasmarine_animate		; $7b1e


; 60 frame delay before starting fight
_plasmarine_state9:
	call _ecom_decCounter1		; $7b20
	jr nz,_plasmarine_animate	; $7b23

	ld (hl),60 ; [counter1]
	ld l,e			; $7b27
	inc (hl) ; [state] = $0a

	ld l,Enemy.collisionType		; $7b29
	set 7,(hl)		; $7b2b

	call _plasmarine_decideNumberOfShockAttacks		; $7b2d
	call _enemyBoss_beginBoss		; $7b30
	xor a			; $7b33
	jp enemySetAnimation		; $7b34


; Standing in place before charging
_plasmarine_stateA:
	call _ecom_decCounter1		; $7b37
	jr nz,_plasmarine_animate	; $7b3a

	inc (hl) ; [counter1] = 1

	ld l,Enemy.animParameter		; $7b3d
	bit 0,(hl)		; $7b3f
	jr z,_plasmarine_animate	; $7b41

	; Initialize stuff for state $0b (charge at Link)
	ld l,Enemy.counter1		; $7b43
	ld (hl),$0c		; $7b45
	ld l,e			; $7b47
	inc (hl) ; [state] = $0b
	ld l,Enemy.speed		; $7b49
	ld (hl),SPEED_300		; $7b4b

	ld l,Enemy.var30		; $7b4d
	ldh a,(<hEnemyTargetY)	; $7b4f
	ldi (hl),a		; $7b51
	ldh a,(<hEnemyTargetX)	; $7b52
	ld (hl),a		; $7b54

_plasmarine_animate:
	jp enemyAnimate		; $7b55


; Charging toward Link
_plasmarine_stateB:
	call _ecom_decCounter1		; $7b58
	jr nz,++		; $7b5b
	ld l,e			; $7b5d
	inc (hl) ; [state] = $0c
++
	ld l,Enemy.speed		; $7b5f
	ld a,(hl)		; $7b61
	sub SPEED_20			; $7b62
	ld (hl),a		; $7b64
	; Fall through

_plasmarine_stateC:
	call _plasmarine_checkCloseToTargetPosition		; $7b65
	jp nc,_ecom_moveTowardPosition		; $7b68

	; Reached target position.
	ld l,Enemy.counter2		; $7b6b
	dec (hl)		; $7b6d
	ld l,e			; $7b6e
	jr z,@fireProjectiles	; $7b6f

	; Do shock attack (state $0d)
	ld (hl),$0d ; [state]
	ld l,Enemy.counter1		; $7b73
	ld (hl),65		; $7b75

	ld l,Enemy.damage		; $7b77
	ld (hl),-8		; $7b79

	ld l,Enemy.var32		; $7b7b
	ld a,(hl)		; $7b7d
	add $04			; $7b7e
	ld l,Enemy.oamFlagsBackup		; $7b80
	ldi (hl),a		; $7b82
	ld (hl),a		; $7b83

	ld l,Enemy.enemyCollisionMode		; $7b84
	ld (hl),ENEMYCOLLISION_PLASMARINE_SHOCK		; $7b86
	ld a,$02		; $7b88
	jp enemySetAnimation		; $7b8a

@fireProjectiles:
	ld (hl),$0e ; [state]
	ld l,Enemy.health		; $7b8f
	ld a,(hl)		; $7b91
	dec a			; $7b92
	ld hl,@numProjectilesToFire		; $7b93
	rst_addAToHl			; $7b96
	ld e,Enemy.var34		; $7b97
	ld a,(hl)		; $7b99
	ld (de),a		; $7b9a

	ld a,$01		; $7b9b
	jp enemySetAnimation		; $7b9d

; Takes health value as index, returns number of projectiles to fire in one attack
@numProjectilesToFire:
	.db $03 $03 $02 $02 $02 $01 $01


; Shock attack
_plasmarine_stateD:
	call _ecom_decCounter1		; $7ba7
	jr z,@doneAttack	; $7baa

	ld a,(hl)		; $7bac
	and $0f			; $7bad
	ld a,SND_SHOCK		; $7baf
	call z,playSound		; $7bb1

	; Update oamFlags based on animParameter
	ld e,Enemy.animParameter		; $7bb4
	ld a,(de)		; $7bb6
	or a			; $7bb7
	ld b,$04		; $7bb8
	jr z,+			; $7bba
	ld b,$01		; $7bbc
+
	ld e,Enemy.var32		; $7bbe
	ld a,(de)		; $7bc0
	add b			; $7bc1
	ld h,d			; $7bc2
	ld l,Enemy.oamFlagsBackup		; $7bc3
	ldi (hl),a		; $7bc5
	ld (hl),a		; $7bc6
	jr _plasmarine_animate		; $7bc7

@doneAttack:
	ld (hl),60 ; [counter1]
	ld l,e			; $7bcb
	ld (hl),$0a ; [state]

	ld l,Enemy.collisionType		; $7bce
	set 7,(hl)		; $7bd0

	ld l,Enemy.damage		; $7bd2
	ld (hl),-4		; $7bd4

	ld l,Enemy.var32		; $7bd6
	ld a,(hl)		; $7bd8
	inc a			; $7bd9
	ld l,Enemy.oamFlagsBackup		; $7bda
	ldi (hl),a		; $7bdc
	ld (hl),a		; $7bdd

	ld l,Enemy.enemyCollisionMode		; $7bde
	ld (hl),ENEMYCOLLISION_PLASMARINE		; $7be0
	xor a			; $7be2
	jp enemySetAnimation		; $7be3


; Firing projectiles
_plasmarine_stateE:
	call enemyAnimate		; $7be6
	ld e,Enemy.animParameter		; $7be9
	ld a,(de)		; $7beb
	dec a			; $7bec
	jr z,@fire	; $7bed

	inc a			; $7bef
	ret z			; $7bf0

	call _ecom_incState		; $7bf1
	ld l,Enemy.counter1		; $7bf4
	ld (hl),60		; $7bf6
	xor a			; $7bf8
	jp enemySetAnimation		; $7bf9

@fire:
	ld (de),a ; [animParameter] = 0

	call getFreePartSlot		; $7bfd
	ret nz			; $7c00
	ld (hl),PARTID_PLASMARINE_PROJECTILE		; $7c01
	inc l			; $7c03
	ld e,Enemy.oamFlags		; $7c04
	ld a,(de)		; $7c06
	dec a			; $7c07
	ld (hl),a ; [projectile.var03]

	ld l,Part.relatedObj1+1		; $7c09
	ld (hl),d		; $7c0b
	dec l			; $7c0c
	ld (hl),Enemy.start		; $7c0d

	ld bc,$ec00		; $7c0f
	call objectCopyPositionWithOffset		; $7c12
	ld a,SND_VERAN_FAIRY_ATTACK		; $7c15
	jp playSound		; $7c17


; Decides whether to return to state $0e (fire another projectile) or charge at Link again
_plasmarine_stateF:
	call _ecom_decCounter1		; $7c1a
	jp nz,enemyAnimate		; $7c1d

	ld l,Enemy.var34		; $7c20
	dec (hl)		; $7c22
	ld l,e			; $7c23
	jr z,@chargeAtLink	; $7c24

	dec (hl) ; [state] = $0e
	ld a,$01		; $7c27
	jp enemySetAnimation		; $7c29

@chargeAtLink:
	ld (hl),$0a		; $7c2c
	ld l,Enemy.counter1		; $7c2e
	ld (hl),30		; $7c30

;;
; @addr{7c32}
_plasmarine_decideNumberOfShockAttacks:
	call getRandomNumber_noPreserveVars		; $7c32
	and $01			; $7c35
	inc a			; $7c37
	ld e,Enemy.counter2		; $7c38
	ld (de),a		; $7c3a
	ret			; $7c3b

;;
; @param[out]	cflag	c if close enough to target position
; @addr{7c3c}
_plasmarine_checkCloseToTargetPosition:
	ld h,d			; $7c3c
	ld l,Enemy.var30		; $7c3d
	call _ecom_readPositionVars		; $7c3f
	sub c			; $7c42
	add $04			; $7c43
	cp $09			; $7c45
	ret nc			; $7c47
	ldh a,(<hFF8F)	; $7c48
	sub b			; $7c4a
	add $04			; $7c4b
	cp $09			; $7c4d
	ret			; $7c4f

; TODO: what is this? Unused data?
.db $ec $ec $ec $14 $14 $14 $14 $ec
.db $00 $e8 $e8 $00 $00 $18 $18 $00


; ==============================================================================
; ENEMYID_KING_MOBLIN
;
; Variables:
;   counter2: ?
;   relatedObj2: Instance of PARTID_KING_MOBLIN_BOMB
;   var30/var31: Object indices for two ENEMYID_KING_MOBLIN_MINION instances
;   var32: Target x-position to walk toward to grab bomb
;   var33: Signal from ENEMYID_KING_MOBLIN_MINION to trigger warp to the outside
; ==============================================================================
enemyCode7f:
	jr z,@normalStatus	; $7c60
	sub ENEMYSTATUS_NO_HEALTH			; $7c62
	ret c			; $7c64
	jr z,@dead	; $7c65

	; Collision occurred

	ld e,Enemy.var2a		; $7c67
	ld a,(de)		; $7c69
	cp $80|ITEMCOLLISION_BOMB			; $7c6a
	jr nz,@normalStatus	; $7c6c

	ld a,SND_BOSS_DAMAGE		; $7c6e
	call playSound		; $7c70

	; Determine speed based on health
	ld e,Enemy.health		; $7c73
	ld a,(de)		; $7c75
	dec a			; $7c76
	ld hl,@speeds		; $7c77
	rst_addAToHl			; $7c7a
	ld e,Enemy.speed		; $7c7b
	ld a,(hl)		; $7c7d
	ld (de),a		; $7c7e

	jr @normalStatus		; $7c7f

; Indexed by current health value
@speeds:
	.db SPEED_1c0, SPEED_1c0
	.db SPEED_140, SPEED_140
	.db SPEED_0c0, SPEED_0c0

@dead:
	call checkLinkCollisionsEnabled		; $7c87
	ret nc			; $7c8a

	ld a,$01		; $7c8b
	ld (wDisabledObjects),a		; $7c8d
	ld (wMenuDisabled),a		; $7c90

	ld h,d			; $7c93
	ld l,Enemy.collisionType		; $7c94
	res 7,(hl)		; $7c96

	ld l,Enemy.health		; $7c98
	ld (hl),a ; [health] = $01

	ld l,Enemy.state		; $7c9b
	ld (hl),$12		; $7c9d

	ld l,Enemy.angle		; $7c9f
	ld (hl),$00		; $7ca1
	ld l,Enemy.speed		; $7ca3
	ld (hl),SPEED_300		; $7ca5

	ld l,Enemy.invincibilityCounter		; $7ca7
	ld (hl),$00		; $7ca9

	ld a,$06		; $7cab
	call enemySetAnimation		; $7cad

@normalStatus:
	ld e,Enemy.invincibilityCounter		; $7cb0
	ld a,(de)		; $7cb2
	or a			; $7cb3
	ret nz			; $7cb4

	ld e,Enemy.state		; $7cb5
	ld a,(de)		; $7cb7
	rst_jumpTable			; $7cb8
	.dw _kingMoblin_state_uninitialized
	.dw _kingMoblin_state_stub
	.dw _kingMoblin_state_stub
	.dw _kingMoblin_state_stub
	.dw _kingMoblin_state_stub
	.dw _kingMoblin_state_stub
	.dw _kingMoblin_state_stub
	.dw _kingMoblin_state_stub
	.dw _kingMoblin_state8
	.dw _kingMoblin_state9
	.dw _kingMoblin_stateA
	.dw _kingMoblin_stateB
	.dw _kingMoblin_stateC
	.dw _kingMoblin_stateD
	.dw _kingMoblin_stateE
	.dw _kingMoblin_stateF
	.dw _kingMoblin_state10
	.dw _kingMoblin_state11
	.dw _kingMoblin_state12
	.dw _kingMoblin_state13
	.dw _kingMoblin_state14
	.dw _kingMoblin_state15


_kingMoblin_state_uninitialized:
	ld a,ENEMYID_KING_MOBLIN		; $7ce5
	ld (wEnemyIDToLoadExtraGfx),a		; $7ce7

	ld a,PALH_8c		; $7cea
	call loadPaletteHeader		; $7cec

	ld a,SNDCTRL_STOPMUSIC		; $7cef
	call playSound		; $7cf1

	xor a			; $7cf4
	ld (wDisableLinkCollisionsAndMenu),a		; $7cf5
	dec a			; $7cf8
	ld (wActiveMusic),a		; $7cf9

	ld b,$02		; $7cfc
	call checkBEnemySlotsAvailable		; $7cfe
	ret nz			; $7d01

	call @spawnMinion		; $7d02
	ld e,Enemy.var30		; $7d05
	ld (de),a		; $7d07

	call @spawnMinion		; $7d08
	ld l,Enemy.subid		; $7d0b
	inc (hl)		; $7d0d
	ld e,Enemy.var31		; $7d0e
	ld (de),a		; $7d10
	ld a,SPEED_c0		; $7d11
	call _ecom_setSpeedAndState8		; $7d13
	call objectSetVisible83		; $7d16
	ld a,$02		; $7d19
	jp enemySetAnimation		; $7d1b

;;
; @param[out]	a,h	Object index
; @addr{7d1e}
@spawnMinion:
	call getFreeEnemySlot_uncounted		; $7d1e
	ld (hl),ENEMYID_KING_MOBLIN_MINION		; $7d21
	ld l,Enemy.relatedObj1		; $7d23
	ld a,Enemy.start		; $7d25
	ldi (hl),a		; $7d27
	ld (hl),d		; $7d28
	ld a,h			; $7d29
	ret			; $7d2a


_kingMoblin_state_stub:
	ret			; $7d2b


; Waiting for Link to move in to start the fight
_kingMoblin_state8:
	ld hl,w1Link.xh		; $7d2c
	ld a,(hl)		; $7d2f
	sub $40			; $7d30
	cp $20			; $7d32
	jr nc,_kingMoblin_animate	; $7d34

	ld l,<w1Link.zh		; $7d36
	ld a,(hl)		; $7d38
	or a			; $7d39
	jr nz,_kingMoblin_animate	; $7d3a

	ld l,<w1Link.direction		; $7d3c
	ld (hl),DIR_UP		; $7d3e

	call checkLinkVulnerable		; $7d40
	ret nc			; $7d43

	call clearAllParentItems		; $7d44
	ld a,$01		; $7d47
	ld (wDisabledObjects),a		; $7d49
	ld (wMenuDisabled),a		; $7d4c

	; Make stairs disappear
	ld c,$61		; $7d4f
	ld a,TILEINDEX_STANDARD_FLOOR		; $7d51
	call setTile		; $7d53

	; Poof at stairs
	call getFreeInteractionSlot		; $7d56
	jr nz,++		; $7d59
	ld (hl),INTERACID_PUFF		; $7d5b
	ld l,Interaction.yh		; $7d5d
	ld (hl),$68	; $7d5f
	ld l,Interaction.xh		; $7d61
	ld (hl),$18		; $7d63
++
	call _ecom_incState		; $7d65
	ld l,Enemy.counter1		; $7d68
	ld (hl),$18		; $7d6a

_kingMoblin_animate:
	jp enemyAnimate		; $7d6c


; Delay before showing text
_kingMoblin_state9:
	call _ecom_decCounter1		; $7d6f
	jr nz,_kingMoblin_animate	; $7d72

	ld l,e			; $7d74
	inc (hl) ; [state] = $0a

	call checkIsLinkedGame		; $7d76
	ld bc,TX_2f19		; $7d79
	jr z,+			; $7d7c
	ld bc,TX_2f1a		; $7d7e
+
	jp showText		; $7d81


; Starting fight
_kingMoblin_stateA:
	ld h,d			; $7d84
	ld l,e			; $7d85
	inc (hl) ; [state] = $0b

	ld l,Enemy.counter2		; $7d87
	ld (hl),30		; $7d89

	ld l,Enemy.var30		; $7d8b
	ld b,(hl)		; $7d8d
	ld c,e			; $7d8e
	ld a,$02		; $7d8f
	ld (bc),a ; [minion1.state] = $02
	inc l			; $7d92
	ld b,(hl)		; $7d93
	ld (bc),a ; [minion2.state] = $02

	call _enemyBoss_beginBoss		; $7d95
	xor a			; $7d98
	jp enemySetAnimation		; $7d99


; Facing backwards while picking up a bomb
_kingMoblin_stateB:
	call _ecom_decCounter2		; $7d9c
	jr nz,_kingMoblin_animate	; $7d9f

	ld b,PARTID_KING_MOBLIN_BOMB		; $7da1
	call _ecom_spawnProjectile		; $7da3
	ret nz			; $7da6

	call _ecom_incState		; $7da7

_kingMoblin_initBombPickupAnimation:
	ld e,Enemy.health		; $7daa
	ld a,(de)		; $7dac
	dec a			; $7dad
	ld hl,@counter2Vals		; $7dae
	rst_addAToHl			; $7db1
	ld e,Enemy.counter2		; $7db2
	ld a,(hl)		; $7db4
	ld (de),a		; $7db5

	ld a,$04		; $7db6
	jp enemySetAnimation		; $7db8

@counter2Vals:
	.db 10 20 28 45 45 45


; Will raise bomb over head in [counter2] frames?
_kingMoblin_stateC:
	call _kingMoblin_checkMoveToCentre		; $7dc1
	ret nz			; $7dc4

	call _ecom_decCounter2		; $7dc5
	ret nz			; $7dc8

	ld l,Enemy.state		; $7dc9
	inc (hl) ; [state] = $0d

	; Set counter2 based on health
	ld l,Enemy.health		; $7dcc
	ld a,(hl)		; $7dce
	dec a			; $7dcf
	ld hl,@counter2Vals		; $7dd0
	rst_addAToHl			; $7dd3
	ld e,Enemy.counter2		; $7dd4
	ld a,(hl)		; $7dd6
	ld (de),a		; $7dd7

	; Update bomb's position if it hasn't exploded
	ld a,Object.state		; $7dd8
	call objectGetRelatedObject2Var		; $7dda
	ld a,(hl)		; $7ddd
	cp $05			; $7dde
	jr z,+			; $7de0
	ld bc,$f0f2		; $7de2
	call objectCopyPositionWithOffset		; $7de5
+
	ld a,$02		; $7de8
	jp enemySetAnimation		; $7dea

; Indexed by [health]-1
@counter2Vals:
	.db 5, 10, 12, 15, 15, 15


; Delay before throwing bomb
_kingMoblin_stateD:
	call _kingMoblin_checkMoveToCentre		; $7df3
	ret nz			; $7df6

	call _ecom_decCounter2		; $7df7
	ret nz			; $7dfa

	ld (hl),30		; $7dfb
	ld l,Enemy.state		; $7dfd
	inc (hl) ; [state] = $0e

	; Decide angle of bomb's movement based on link's position
	call objectGetAngleTowardEnemyTarget		; $7e00
	ld b,a			; $7e03
	sub $0c			; $7e04
	cp $07			; $7e06
	jr c,++			; $7e08

	ld b,$0c		; $7e0a
	rlca			; $7e0c
	jr c,++			; $7e0d

	ld b,$13		; $7e0f
++
	ld a,Object.state		; $7e11
	call objectGetRelatedObject2Var		; $7e13
	ld a,(hl)		; $7e16
	cp $05			; $7e17
	jr z,++			; $7e19

	; Throw bomb
	ld (hl),$03 ; [bomb.state] = $03
	ld l,Part.angle		; $7e1d
	ld (hl),b		; $7e1f
	ld l,Part.speedZ		; $7e20
	ld (hl),<(-$180)		; $7e22
	inc l			; $7e24
	ld (hl),>(-$180)		; $7e25
++
	ld a,$05		; $7e27
	jp enemySetAnimation		; $7e29


; Delay after throwing bomb
_kingMoblin_stateE:
	call _ecom_decCounter2		; $7e2c
	ret nz			; $7e2f
	ld l,e			; $7e30
	inc (hl) ; [state] = $0f
	ld a,$02		; $7e32
	jp enemySetAnimation		; $7e34


; Waiting for something to do
_kingMoblin_stateF:
	ld a,Object.id		; $7e37
	call objectGetRelatedObject2Var		; $7e39
	ld a,(hl)		; $7e3c
	cp PARTID_KING_MOBLIN_BOMB			; $7e3d
	jp nz,_kingMoblin_moveToCentre		; $7e3f

	; Do several checks to see if king moblin can pick up the bomb.

	; Is the state ok?
	ld l,Part.state		; $7e42
	ld a,(hl)		; $7e44
	cp $04			; $7e45
	jr nz,_kingMoblin_animate2	; $7e47

	; Is it above the ledge?
	ld l,Part.yh		; $7e49
	ldi a,(hl)		; $7e4b
	cp $36			; $7e4c
	jr nc,_kingMoblin_animate2	; $7e4e

	; Is it reachable on the x axis?
	inc l			; $7e50
	ld a,(hl) ; [bomb.xh]
	sub $30			; $7e52
	cp $41			; $7e54
	jr nc,_kingMoblin_animate2	; $7e56

	; Bomb can be grabbed.

	; Is the bomb close enough to grab without walking?
	ld e,Enemy.xh		; $7e58
	ld a,(de)		; $7e5a
	ld b,a			; $7e5b
	sub (hl)		; $7e5c
	add $08			; $7e5d
	cp $11			; $7e5f
	jr c,_kingMoblin_grabBomb			; $7e61

	; No; must move toward it
	ld a,(hl)		; $7e63
	cp b			; $7e64
	ld h,d			; $7e65
	ld l,Enemy.var32		; $7e66
	ld (hl),a		; $7e68
	ld b,$11 ; state $11
	jp _kingMoblin_setAngleStateAndAnimation		; $7e6b

_kingMoblin_grabBomb:
	ld a,Object.state		; $7e6e
	call objectGetRelatedObject2Var		; $7e70
	ld a,(hl)		; $7e73
	cp $05			; $7e74
	jr z,++			; $7e76
	ld (hl),$01		; $7e78
	ld bc,$0800		; $7e7a
	call objectCopyPositionWithOffset		; $7e7d
++
	ld h,d			; $7e80
	ld l,Enemy.state		; $7e81
	ld (hl),$0c		; $7e83
	jp _kingMoblin_initBombPickupAnimation		; $7e85


; Moving to centre of screen
_kingMoblin_state10:
	ld e,Enemy.xh		; $7e88
	ld a,(de)		; $7e8a
	sub $4e			; $7e8b
	cp $05			; $7e8d
	jr nc,++		; $7e8f

	ld h,d			; $7e91
	ld l,Enemy.state		; $7e92
	ld (hl),$0b		; $7e94
	ld l,Enemy.counter2		; $7e96
	ld (hl),30		; $7e98
	xor a			; $7e9a
	jp enemySetAnimation		; $7e9b
++
	call objectApplySpeed		; $7e9e

_kingMoblin_animate2:
	jp enemyAnimate		; $7ea1


; Moving toward bomb
_kingMoblin_state11:
	call _kingMoblin_checkMoveToCentre		; $7ea4
	ret nz			; $7ea7

	call objectApplySpeed		; $7ea8
	ld h,d			; $7eab
	ld l,Enemy.xh		; $7eac
	ld e,Enemy.var32		; $7eae
	ld a,(de)		; $7eb0
	sub (hl)		; $7eb1
	add $08			; $7eb2
	cp $11			; $7eb4
	jr c,_kingMoblin_grabBomb	; $7eb6
	jp enemyAnimate		; $7eb8


; Just died
_kingMoblin_state12:
	call objectApplySpeed		; $7ebb
	ld e,Enemy.yh		; $7ebe
	ld a,(de)		; $7ec0
	cp $0c			; $7ec1
	ret nc			; $7ec3

	call _ecom_incState		; $7ec4

	ld l,Enemy.angle		; $7ec7
	ld (hl),$10		; $7ec9
	ld l,Enemy.speed		; $7ecb
	ld (hl),SPEED_80		; $7ecd

	ld l,Enemy.speedZ		; $7ecf
	ld a,<(-$160)		; $7ed1
	ldi (hl),a		; $7ed3
	ld (hl),>(-$160)		; $7ed4

	ld a,60		; $7ed6
	jp setScreenShakeCounter		; $7ed8


; Falling to ground
_kingMoblin_state13:
	ld c,$20		; $7edb
	call objectUpdateSpeedZAndBounce		; $7edd
	jp nc,objectApplySpeed		; $7ee0

	call _ecom_incState		; $7ee3
	ld l,Enemy.counter1		; $7ee6
	ld (hl),150		; $7ee8
	ld l,Enemy.yh		; $7eea
	ld (hl),$20		; $7eec
	ret			; $7eee


; Wait for signal from ENEMYID_KING_MOBLIN_MINION to go to state $15?
_kingMoblin_state14:
	ld e,Enemy.var33		; $7eef
	ld a,(de)		; $7ef1
	or a			; $7ef2
	jr nz,@gotoState15	; $7ef3

	ld a,(wFrameCounter)		; $7ef5
	rrca			; $7ef8
	ret c			; $7ef9

	call _ecom_decCounter1		; $7efa
	ret nz			; $7efd

	ld l,Enemy.state		; $7efe
	ld (hl),$0b		; $7f00
	ld l,Enemy.counter2		; $7f02
	ld (hl),30		; $7f04
	xor a			; $7f06
	jp enemySetAnimation		; $7f07

@gotoState15:
	call _ecom_incState		; $7f0a
	ld l,Enemy.counter2		; $7f0d
	ld (hl),98		; $7f0f
	ret			; $7f11


; All bombs at top of screen explode, then initiates warp outside
_kingMoblin_state15:
	call _ecom_decCounter2		; $7f12
	jr z,@warpOutside	; $7f15

	; Explosion every 32 frames
	ld a,(hl)		; $7f17
	dec a			; $7f18
	and $1f			; $7f19
	ret nz			; $7f1b

	ld a,(hl)		; $7f1c
	and $60			; $7f1d
	rrca			; $7f1f
	swap a			; $7f20
	ld hl,@explosionPositions		; $7f22
	rst_addAToHl			; $7f25

	ld c,(hl)		; $7f26
	ld b,$08		; $7f27
	call getFreeInteractionSlot		; $7f29
	ret nz			; $7f2c
	ld (hl),INTERACID_EXPLOSION		; $7f2d
	ld l,Interaction.yh		; $7f2f
	ld (hl),b		; $7f31
	ld l,Interaction.xh		; $7f32
	ld (hl),c		; $7f34

	call getTileAtPosition		; $7f35
	ld c,l			; $7f38
	ld a,$a1		; $7f39
	jp setTile		; $7f3b

@warpOutside:
	ld hl,wPresentRoomFlags+$09		; $7f3e
	set 0,(hl)		; $7f41

	ld a,GLOBALFLAG_MOBLINS_KEEP_DESTROYED		; $7f43
	call setGlobalFlag		; $7f45
	ld a,GLOBALFLAG_16		; $7f48
	call setGlobalFlag		; $7f4a

	ld hl,@warpDest		; $7f4d
	jp setWarpDestVariables		; $7f50

@explosionPositions:
	.db $68 $38 $58 $48

@warpDest:
	.db $80 $09 $00 $45 $03


;;
; Updates state and angle values to move king moblin to centre of screen, if there is no
; bomb on screen. Sets state to $10 while moving, $0b when reached centre.
;
; @param[out]	zflag	nz if state changed
; @addr{7f5c}
_kingMoblin_checkMoveToCentre:
	ld a,Object.id		; $7f5c
	call objectGetRelatedObject2Var		; $7f5e
	ld a,(hl)		; $7f61
	cp PARTID_KING_MOBLIN_BOMB			; $7f62
	ret z			; $7f64

;;
; @addr{7f65}
_kingMoblin_moveToCentre:
	ld h,d			; $7f65
	ld l,Enemy.xh		; $7f66
	ld a,(hl)		; $7f68
	sub $4e			; $7f69
	cp $05			; $7f6b
	jr nc,@moveTowardCentre	; $7f6d

	; Reached centre
	ld l,Enemy.counter2		; $7f6f
	ld (hl),30		; $7f71
	ld b,$0b		; $7f73
	xor a			; $7f75
	jr _kingMoblin_setStateAndAnimation		; $7f76

@moveTowardCentre:
	cp $b0			; $7f78
	ld b,$10		; $7f7a

_kingMoblin_setAngleStateAndAnimation:
	ld a,ANGLE_RIGHT		; $7f7c
	jr nc,+			; $7f7e
	ld a,ANGLE_LEFT		; $7f80
+
	ld e,Enemy.angle		; $7f82
	ld (de),a		; $7f84
	swap a			; $7f85
	rlca			; $7f87

_kingMoblin_setStateAndAnimation:
	ld l,Enemy.state		; $7f88
	ld (hl),b		; $7f8a
	call enemySetAnimation		; $7f8b
	or d			; $7f8e
	ret			; $7f8f

.ends

.BANK $10 SLOT 1
.ORG 0

 m_section_free Enemy_Code_Bank10 NAMESPACE bank10

	.include "code/enemyCommon.s"
	.include "code/enemyBossCommon.s"


; ==============================================================================
; ENEMYID_MERGED_TWINROVA
;
; Variables:
;   subid: 0 or 1 for lava or ice
;   var03: 0 or 1 for two different attacks
;   var30: Counter until room will be swapped
;   var31: ?
;   var32: Value from 0-7, determines what attack to use in lava phase
;   var33: Minimum # frames of movement before attacking?
;   var34: Nonzero if dead?
;   var36: Target position index (multiple of 2)
;   var37/var38: Target position to move to?
;   var39: Room swapping is disabled while this is nonzero.
;   var3a: Counter until twinrova's vulnerability ends and room will be swapped
;   var3b: # frames to wait in place before choosing new target position
; ==============================================================================
enemyCode01:
	jr z,@normalStatus	; $4594
	sub ENEMYSTATUS_NO_HEALTH			; $4596
	ret c			; $4598
	jr nz,@collisionOccurred	; $4599

	; Dead
	ld e,Enemy.var34		; $459b
	ld a,(de)		; $459d
	or a			; $459e
	jp z,_mergedTwinrova_deathCutscene		; $459f

	ld h,d			; $45a2
	ld l,Enemy.var3a		; $45a3
	ld (hl),120		; $45a5

	ld l,Enemy.health		; $45a7
	ld (hl),20		; $45a9

	ld l,Enemy.collisionType		; $45ab
	set 7,(hl)		; $45ad

	ld l,Enemy.oamFlagsBackup		; $45af
	xor a			; $45b1
	ldi (hl),a		; $45b2
	ld (hl),a		; $45b3

	ld l,Enemy.collisionType		; $45b4
	ld (hl),$ff		; $45b6

	ld a,$09		; $45b8
	jp enemySetAnimation		; $45ba

@collisionOccurred:
	ld e,Enemy.var3a		; $45bd
	ld a,(de)		; $45bf
	or a			; $45c0
	jr z,@normalStatus	; $45c1

	; Check that the collision was with a seed.
	ld e,Enemy.var2a		; $45c3
	ld a,(de)		; $45c5
	res 7,a			; $45c6
	sub ITEMCOLLISION_MYSTERY_SEED			; $45c8
	cp ITEMCOLLISION_GALE_SEED - ITEMCOLLISION_MYSTERY_SEED + 1
	jr nc,@normalStatus	; $45cc

	ld a,SND_BOSS_DAMAGE		; $45ce
	call playSound		; $45d0

	ld h,d			; $45d3
	ld l,Enemy.invincibilityCounter		; $45d4
	ld (hl),45		; $45d6

	ld l,Enemy.var34		; $45d8
	dec (hl)		; $45da
	jr nz,@normalStatus	; $45db

	; Dead?
	ld l,Enemy.health		; $45dd
	ld (hl),$00		; $45df

	ld l,Enemy.collisionType		; $45e1
	res 7,(hl)		; $45e3

	ld l,Enemy.state2		; $45e5
	ld (hl),$00		; $45e7
	inc l			; $45e9
	ld (hl),216 ; [counter1]
	ld a,SNDCTRL_STOPMUSIC		; $45ec
	jp playSound		; $45ee

@normalStatus:
	call _mergedTwinrova_checkTimeToSwapRoomFromDamage		; $45f1
	call _mergedTwinrova_checkTimeToSwapRoomFromTimer		; $45f4
	call _ecom_getSubidAndCpStateTo08		; $45f7
	cp $0c			; $45fa
	jr nc,@stateCOrHigher	; $45fc
	rst_jumpTable			; $45fe
	.dw _mergedTwinrova_state_uninitialized
	.dw _mergedTwinrova_state_stub
	.dw _mergedTwinrova_state_stub
	.dw _mergedTwinrova_state_stub
	.dw _mergedTwinrova_state_stub
	.dw _mergedTwinrova_state_stub
	.dw _mergedTwinrova_state_stub
	.dw _mergedTwinrova_state_stub
	.dw _mergedTwinrova_state8
	.dw _mergedTwinrova_state9
	.dw _mergedTwinrova_stateA
	.dw _mergedTwinrova_stateB

@stateCOrHigher:
	ld a,b			; $4617
	rst_jumpTable			; $4618
	.dw _mergedTwinrova_lavaRoom
	.dw _mergedTwinrova_iceRoom


; Fight just starting
_mergedTwinrova_state_uninitialized:
	ld a,ENEMYID_MERGED_TWINROVA		; $461d
	ld (wEnemyIDToLoadExtraGfx),a		; $461f

	ldh a,(<hActiveObject)	; $4622
	ld d,a			; $4624
	ld bc,$0012		; $4625
	call _enemyBoss_spawnShadow		; $4628
	ret nz			; $462b

	ld a,SPEED_180		; $462c
	call _ecom_setSpeedAndState8		; $462e

	ld l,Enemy.counter1		; $4631
	ld (hl),$08		; $4633
	ld l,Enemy.var30		; $4635
	ld (hl),210		; $4637
	ld l,Enemy.var34		; $4639
	ld (hl),$05		; $463b
	ld l,Enemy.zh		; $463d
	ld (hl),$ff		; $463f

	call objectSetVisible83		; $4641
	ld bc,TX_2f0b		; $4644
	jp showText		; $4647


_mergedTwinrova_state_stub:
	ret			; $464a


; Delay before moving to centre?
_mergedTwinrova_state8:
	call _ecom_decCounter1		; $464b
	ret nz			; $464e

	ld l,e			; $464f
	inc (hl) ; [state] = 9

	ld l,Enemy.collisionType		; $4651
	set 7,(hl)		; $4653

	call getRandomNumber_noPreserveVars		; $4655
	and $01			; $4658
	ld e,Enemy.subid		; $465a
	ld (de),a		; $465c
	ld b,a			; $465d

	xor $01			; $465e
	inc a			; $4660
	ld e,Enemy.oamFlagsBackup		; $4661
	ld (de),a		; $4663
	inc e			; $4664
	ld (de),a		; $4665

	ld a,b			; $4666
	inc a			; $4667
	call enemySetAnimation		; $4668

	xor a			; $466b
	ld (wDisabledObjects),a		; $466c
	ld (wDisableLinkCollisionsAndMenu),a		; $466f

	ld a,MUS_TWINROVA		; $4672
	ld (wActiveMusic),a		; $4674
	jp playSound		; $4677


; Moving toward centre of screen prior to swapping room
_mergedTwinrova_state9:
	ld bc,$4878		; $467a
	ld h,d			; $467d
	ld l,Enemy.yh		; $467e
	ldi a,(hl)		; $4680
	ldh (<hFF8F),a	; $4681
	inc l			; $4683
	ld a,(hl)		; $4684
	ldh (<hFF8E),a	; $4685
	call _mergedTwinrova_checkPositionsCloseEnough		; $4687
	jp nc,_ecom_moveTowardPosition		; $468a

	; Reached centre of screen.
	ld l,e			; $468d
	inc (hl) ; [state] = $0a
	inc l			; $468f
	ld (hl),$00 ; [state2]
	inc l			; $4692
	ld (hl),60 ; [counter1]

	ld l,Enemy.collisionType		; $4695
	ld (hl),$80|ENEMYID_BEAMOS		; $4697

	ld l,Enemy.var39		; $4699
	ld (hl),$01		; $469b
	ld l,Enemy.var3b		; $469d
	ld (hl),$00		; $469f
	ret			; $46a1


; In the process of converting the room to lava or ice
_mergedTwinrova_stateA:
	inc e			; $46a2
	ld a,(de) ; [state2]
	rst_jumpTable			; $46a4
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4

@substate0:
	call _ecom_decCounter1		; $46af
	jr z,++			; $46b2

	; Flicker palettes?
	ld l,Enemy.oamFlagsBackup		; $46b4
	ld a,(hl)		; $46b6
	xor $03			; $46b7
	ldi (hl),a		; $46b9
	ld (hl),a		; $46ba
	ret			; $46bb
++
	ld l,e			; $46bc
	inc (hl) ; [state2] = 1
	inc l			; $46be
	ld (hl),30 ; [counter1]

	; Swap subid
	ld l,Enemy.subid		; $46c1
	ld a,(hl)		; $46c3
	inc a			; $46c4
	and $01			; $46c5
	ld b,a			; $46c7
	ld (hl),a		; $46c8

	xor $01			; $46c9
	inc a			; $46cb
	ld l,Enemy.oamFlagsBackup		; $46cc
	ldi (hl),a		; $46ce
	ld (hl),a		; $46cf
	ld a,b			; $46d0
	inc a			; $46d1
	jp enemySetAnimation		; $46d2

@substate1:
	call _ecom_decCounter1		; $46d5
	jr z,++			; $46d8

	; Flicker palettes?
	ld l,Enemy.oamFlagsBackup		; $46da
	ld a,(hl)		; $46dc
	xor $03			; $46dd
	ldi (hl),a		; $46df
	ld (hl),a		; $46e0
	ret			; $46e1
++
	ld l,e			; $46e2
	inc (hl) ; [state2] = 2

	ld l,Enemy.subid		; $46e4
	ld a,(hl)		; $46e6
	xor $01			; $46e7
	inc a			; $46e9
	ld l,Enemy.oamFlagsBackup		; $46ea
	ldi (hl),a		; $46ec
	ld (hl),a		; $46ed

	ld a,$01		; $46ee
	ld (wDisableLinkCollisionsAndMenu),a		; $46f0

	call fastFadeoutToWhite		; $46f3
	ld a,SND_ENDLESS		; $46f6
	jp playSound		; $46f8

@substate2:
	ld a,$03		; $46fb
	ld (de),a ; [state2]

	call disableLcd		; $46fe

	ld e,Enemy.subid		; $4701
	ld a,(de)		; $4703
	inc a			; $4704
	ld (wTwinrovaTileReplacementMode),a		; $4705

	call func_131f		; $4708
	ld a,$02		; $470b
	call loadGfxRegisterStateIndex		; $470d
	ldh a,(<hActiveObject)	; $4710
	ld d,a			; $4712
	ret			; $4713

@substate3:
	ld a,$04		; $4714
	ld (de),a		; $4716
	jp fadeinFromWhiteWithDelay		; $4717

@substate4:
	ld a,(wPaletteThread_mode)		; $471a
	or a			; $471d
	ret nz			; $471e

	ld h,d			; $471f
	ld l,Enemy.state		; $4720
	inc (hl) ; [state] = $0b

	ld l,Enemy.collisionType		; $4723
	ld (hl),$80|ENEMYID_MERGED_TWINROVA		; $4725

	ld l,Enemy.counter1		; $4727
	ld (hl),30		; $4729
	ld l,Enemy.var30		; $472b
	ld (hl),210		; $472d

	ld l,Enemy.var39		; $472f
	xor a			; $4731
	ld (hl),a		; $4732
	ld (wDisableLinkCollisionsAndMenu),a		; $4733

	ld a,SNDCTRL_STOPSFX		; $4736
	jp playSound		; $4738


; Delay before attacking
_mergedTwinrova_stateB:
	call _ecom_decCounter1		; $473b
	ret nz			; $473e
	ld l,e			; $473f
	ld (hl),$0c ; [state]
	ret			; $4742


_mergedTwinrova_lavaRoom:
	ld a,(de)		; $4743
	sub $0c			; $4744
	rst_jumpTable			; $4746
	.dw _mergedTwinrova_lavaRoom_stateC
	.dw _mergedTwinrova_lavaRoom_stateD
	.dw _mergedTwinrova_lavaRoom_stateE


_mergedTwinrova_lavaRoom_stateC:
	call _mergedTwinrova_decVar3bIfNonzero		; $474d
	ret nz			; $4750

	ld l,Enemy.speed		; $4751
	ld (hl),SPEED_140		; $4753


_mergedTwinrova_chooseTargetPosition:
	ld l,e			; $4755
	inc (hl) ; [state]

	; Choose a target position distinct from the current position
@chooseTargetPositionIndex:
	call getRandomNumber		; $4757
	and $0e			; $475a
	ld l,Enemy.var36		; $475c
	cp (hl)			; $475e
	jr z,@chooseTargetPositionIndex	; $475f

	ld (hl),a		; $4761

	ld bc,@targetPositions		; $4762
	call addAToBc		; $4765
	ld e,Enemy.var37		; $4768
	ld a,(bc)		; $476a
	ld (de),a		; $476b
	inc e			; $476c
	inc bc			; $476d
	ld a,(bc)		; $476e
	ld (de),a		; $476f

	ld a,SND_CIRCLING		; $4770
	jp playSound		; $4772

@targetPositions: ; One of these positions in chosen randomly.
	.db $30 $40
	.db $58 $30
	.db $48 $40
	.db $30 $78
	.db $58 $78
	.db $30 $b0
	.db $58 $c0
	.db $78 $b0


; Moving toward target position
_mergedTwinrova_lavaRoom_stateD:
	ld h,d			; $4785
	ld l,Enemy.var33		; $4786
	ld a,(hl)		; $4788
	or a			; $4789
	jr z,+			; $478a
	dec (hl)		; $478c
+
	ld l,Enemy.var37		; $478d
	call _ecom_readPositionVars		; $478f
	call _mergedTwinrova_checkPositionsCloseEnough		; $4792
	jp nc,_ecom_moveTowardPosition		; $4795

	; Reached target position.

	; var33 must have reached 0 for twinrova to attack, otherwise she'll move again.
	ld l,Enemy.var33		; $4798
	ld a,(hl)		; $479a
	or a			; $479b
	ld l,Enemy.state		; $479c
	jr z,@attack			; $479e

	dec (hl) ; [state] = $0c
	ld l,Enemy.var3b		; $47a1
	ld (hl),30		; $47a3
	ret			; $47a5

@attack:
	inc (hl) ; [state] = $0e
	inc l			; $47a7
	ld (hl),$00 ; [state2]

	ld l,Enemy.var39		; $47aa
	ld (hl),$01		; $47ac

	ld l,Enemy.var32		; $47ae
	inc (hl)		; $47b0
	ld a,(hl)		; $47b1
	and $07			; $47b2
	ld (hl),a		; $47b4

	ld hl,@var03Vals		; $47b5
	rst_addAToHl			; $47b8
	ld e,Enemy.var03		; $47b9
	ld a,(hl)		; $47bb
	ld (de),a		; $47bc
	ret			; $47bd

@var03Vals:
	.db $00 $00 $01 $00 $01 $01 $00 $01


; Doing one of two attacks, depending on var03
_mergedTwinrova_lavaRoom_stateE:
	ld e,Enemy.var03		; $47c6
	ld a,(de)		; $47c8
	or a			; $47c9
	jp nz,@keeseAttack		; $47ca

	ld e,Enemy.state2		; $47cd
	ld a,(de)		; $47cf
	rst_jumpTable			; $47d0
	.dw @flameAttack_substate0
	.dw @flameAttack_substate1
	.dw @flameAttack_substate2

@flameAttack_substate0:
	ld h,d			; $47d7
	ld l,e			; $47d8
	inc (hl) ; [state2] = 1
	inc l			; $47da
	ld (hl),30 ; [counter1]

	ld a,$03		; $47dd
	call enemySetAnimation		; $47df

	call objectGetAngleTowardEnemyTarget		; $47e2
	ld b,a			; $47e5

	call getFreePartSlot		; $47e6
	ret nz			; $47e9
	ld (hl),PARTID_TWINROVA_FLAME		; $47ea
	ld l,Part.angle		; $47ec
	ld (hl),b		; $47ee
	ld bc,$1000		; $47ef
	jp objectCopyPositionWithOffset		; $47f2

@flameAttack_substate1:
	call _ecom_decCounter1		; $47f5
	jp nz,enemyAnimate		; $47f8

	ld (hl),16		; $47fb
	ld l,e			; $47fd
	inc (hl) ; [state2] = 2
	ld a,$04		; $47ff
	jp enemySetAnimation		; $4801

@flameAttack_substate2:
	call _ecom_decCounter1		; $4804
	ret nz			; $4807

@doneAttack:
	ld l,Enemy.state		; $4808
	ld (hl),$0c		; $480a
	ld l,Enemy.var3b		; $480c
	ld (hl),30		; $480e
	ld l,Enemy.var33		; $4810
	ld (hl),150		; $4812
	ld l,Enemy.var39		; $4814
	ld (hl),$00		; $4816
	ld a,$01		; $4818
	jp enemySetAnimation		; $481a


@keeseAttack:
	ld e,Enemy.state2		; $481d
	ld a,(de)		; $481f
	rst_jumpTable			; $4820
	.dw @keeseAttack_substate0
	.dw @keeseAttack_substate1
	.dw @keeseAttack_substate2

@keeseAttack_substate0:
	ld h,d			; $4827
	ld l,e			; $4828
	inc (hl) ; [state2] = 1
	inc l			; $482a
	ld (hl),$0a ; [counter1]
	inc l			; $482d
	ld (hl),$05 ; [counter2]
	ld a,$07		; $4830
	jp enemySetAnimation		; $4832

@keeseAttack_substate1:
	call _ecom_decCounter1		; $4835
	jp nz,enemyAnimate		; $4838

	ld (hl),20 ; [counter1]
	inc l			; $483d
	dec (hl) ; [counter2]
	jr z,@doneSpawningKeese	; $483f

	ld a,(hl)		; $4841
	dec a			; $4842
	ld hl,@keesePositions		; $4843
	rst_addDoubleIndex			; $4846
	ldi a,(hl)		; $4847
	ld b,a			; $4848
	ld c,(hl)		; $4849

	call getFreeEnemySlot_uncounted		; $484a
	ret nz			; $484d
	ld (hl),ENEMYID_TWINROVA_BAT		; $484e
	ld l,Enemy.relatedObj1+1		; $4850
	ld (hl),d		; $4852
	dec l			; $4853
	ld (hl),Enemy.start		; $4854

	jp objectCopyPositionWithOffset		; $4856

@doneSpawningKeese:
	dec l			; $4859
	ld (hl),180 ; [counter1]
	ld l,e			; $485c
	inc (hl) ; [state2] = 2
	ld a,$03		; $485e
	jp enemySetAnimation		; $4860

@keesePositions:
	.db $00 $20
	.db $e0 $00
	.db $00 $e0
	.db $20 $00

@keeseAttack_substate2:
	call _ecom_decCounter1		; $486b
	ret nz			; $486e
	jr @doneAttack		; $486f


_mergedTwinrova_iceRoom:
	ld a,(de)		; $4871
	sub $0c			; $4872
	rst_jumpTable			; $4874
	.dw _mergedTwinrova_iceRoom_stateC
	.dw _mergedTwinrova_iceRoom_stateD
	.dw _mergedTwinrova_iceRoom_stateE
	.dw _mergedTwinrova_iceRoom_stateF
	.dw _mergedTwinrova_iceRoom_state10


; About to start spawning ice projectiles
_mergedTwinrova_iceRoom_stateC:
	ld h,d			; $487f
	ld l,e			; $4880
	inc (hl) ; [state] = $0d
	inc l			; $4882
	ld (hl),$00 ; [state2]
	inc l			; $4885
	ld (hl),10 ; [counter1]

	ld l,Enemy.var39		; $4888
	ld (hl),$01		; $488a

	call getRandomNumber_noPreserveVars		; $488c
	and $01			; $488f
	ld e,Enemy.var35		; $4891
	ld (de),a		; $4893

	ld e,Enemy.var34		; $4894
	ld a,(de)		; $4896
	cp $02			; $4897
	ld a,$03		; $4899
	jr nc,+			; $489b
	inc a			; $489d
+
	ld e,Enemy.counter2		; $489e
	ld (de),a		; $48a0
	ld a,$05		; $48a1
	jp enemySetAnimation		; $48a3


; Spawning ice projectiles (ENEMYID_TWINROVA_ICE)
_mergedTwinrova_iceRoom_stateD:
	inc e			; $48a6
	ld a,(de) ; [state2]
	rst_jumpTable			; $48a8
	.dw @substate0
	.dw @substate1

@substate0:
	call _ecom_decCounter1		; $48ad
	jp nz,enemyAnimate		; $48b0

	ld (hl),30		; $48b3
	inc l			; $48b5
	dec (hl) ; [counter2]
	jr z,@doneSpawningProjectiles	; $48b7

	; Determine position & angle for projectile
	ld b,(hl)		; $48b9
	dec b			; $48ba
	ld l,Enemy.var34		; $48bb
	ld a,(hl)		; $48bd
	cp $02			; $48be
	ld hl,@positionData1		; $48c0
	jr nc,+			; $48c3
	ld hl,@positionData0		; $48c5
+
	ld a,b			; $48c8
	add a			; $48c9
	rst_addDoubleIndex			; $48ca
	ldi a,(hl)		; $48cb
	ld b,a			; $48cc
	ldi a,(hl)		; $48cd
	ld c,a			; $48ce
	ld e,Enemy.var35		; $48cf
	ld a,(de)		; $48d1
	or a			; $48d2
	jr z,+			; $48d3
	inc hl			; $48d5
+
	ld e,(hl)		; $48d6

	; Spawn ice projectile
	call getFreeEnemySlot_uncounted		; $48d7
	ret nz			; $48da
	ld (hl),ENEMYID_TWINROVA_ICE		; $48db
	ld l,Enemy.angle		; $48dd
	ld (hl),e		; $48df
	ld l,Enemy.relatedObj1		; $48e0
	ld (hl),Enemy.start		; $48e2
	inc l			; $48e4
	ld (hl),d		; $48e5

	jp objectCopyPositionWithOffset		; $48e6

@doneSpawningProjectiles:
	ld l,e			; $48e9
	inc (hl) ; [state2] = 1
	ld l,Enemy.counter1		; $48eb
	ld (hl),120		; $48ed
	ld l,Enemy.var39		; $48ef
	ld (hl),$00		; $48f1
	ld a,$06		; $48f3
	jp enemySetAnimation		; $48f5

@positionData0:
	.db $10 $f0 $12 $15
	.db $10 $10 $0a $0c
	.db $18 $00 $0e $12
@positionData1:
	.db $10 $e8 $16 $0d
	.db $10 $18 $0b $11

@substate1:
	call _ecom_decCounter1		; $490c
	ret nz			; $490f
	ld (hl),90		; $4910
	ld l,Enemy.state		; $4912
	inc (hl) ; [state] = $0e
	ld a,$02		; $4915
	jp enemySetAnimation		; $4917


; About to move to a position to do a snowball attack.
_mergedTwinrova_iceRoom_stateE:
	call _mergedTwinrova_decVar3bIfNonzero		; $491a
	ret nz			; $491d
	ld l,Enemy.speed		; $491e
	ld (hl),SPEED_180		; $4920
	jp _mergedTwinrova_chooseTargetPosition		; $4922


; Moving to position prior to snowball attack
_mergedTwinrova_iceRoom_stateF:
	ld h,d			; $4925
	ld l,Enemy.var37		; $4926
	call _ecom_readPositionVars		; $4928
	call _mergedTwinrova_checkPositionsCloseEnough		; $492b
	jp nc,_ecom_moveTowardPosition		; $492e

	; Reached target position. Begin charging attack.

	ld l,Enemy.state		; $4931
	inc (hl) ; [state] = $10
	inc l			; $4934
	ld (hl),$00 ; [state2]
	inc l			; $4937
	ld (hl),30 ; [counter1]

	ld l,Enemy.var39		; $493a
	ld (hl),$01		; $493c

	ld a,$08		; $493e
	call enemySetAnimation		; $4940

	call getFreePartSlot		; $4943
	ret nz			; $4946
	ld (hl),PARTID_TWINROVA_SNOWBALL		; $4947
	ld bc,$e800		; $4949
	jp objectCopyPositionWithOffset		; $494c


; Doing snowball attack?
_mergedTwinrova_iceRoom_state10:
	inc e			; $494f
	ld a,(de)		; $4950
	rst_jumpTable			; $4951
	.dw @substate0
	.dw @substate1

@substate0:
	call _ecom_decCounter1		; $4956
	jp nz,enemyAnimate		; $4959

	ld (hl),60		; $495c

	ld l,e			; $495e
	inc (hl) ; [state2] = 1

	ld a,$06		; $4960
	jp enemySetAnimation		; $4962

@substate1:
	call _ecom_decCounter1		; $4965
	ret nz			; $4968

	ld l,Enemy.state		; $4969
	ld (hl),$0e		; $496b
	ld l,Enemy.counter1		; $496d
	ld (hl),90		; $496f
	ld l,Enemy.var3b		; $4971
	ld (hl),30		; $4973
	ld l,Enemy.var39		; $4975
	ld (hl),$00		; $4977
	ld a,$02		; $4979
	jp enemySetAnimation		; $497b

;;
; @addr{497e}
_mergedTwinrova_checkTimeToSwapRoomFromTimer:
	ld a,(wFrameCounter)		; $497e
	and $03			; $4981
	ret nz			; $4983

	ld h,d			; $4984
	ld l,Enemy.var30		; $4985
	dec (hl)		; $4987
	ret nz			; $4988

	inc (hl)		; $4989
	ld e,Enemy.var39		; $498a
	ld a,(de)		; $498c
	or a			; $498d
	ret nz			; $498e

	ld (hl),210 ; [var39]
	ld l,Enemy.counter1		; $4991
	ld (hl),30		; $4993
	ld l,Enemy.state		; $4995
	ld (hl),$09		; $4997
	ret			; $4999


;;
; @param	a
; @param	bc
; @param	hFF8F
; @param[out]	cflag	c if within 2 pixels of position
; @addr{499a}
_mergedTwinrova_checkPositionsCloseEnough:
	sub c			; $499a
	add $02			; $499b
	cp $05			; $499d
	ret nc			; $499f
	ldh a,(<hFF8F)	; $49a0
	sub b			; $49a2
	add $02			; $49a3
	cp $05			; $49a5
	ret			; $49a7

;;
; Checks whether to begin changing the room. If so, it sets the state to 9 and returns
; from caller (pops return address).
; @addr{49a8}
_mergedTwinrova_checkTimeToSwapRoomFromDamage:
	ld h,d			; $49a8
	ld l,Enemy.var3a		; $49a9
	ld a,(hl)		; $49ab
	or a			; $49ac
	ret z			; $49ad

	dec (hl)		; $49ae
	jr z,++			; $49af
	pop hl			; $49b1
	ret			; $49b2
++
	ld l,Enemy.state		; $49b3
	ld (hl),$09		; $49b5

	ld e,Enemy.subid		; $49b7
	ld a,(de)		; $49b9
	ld b,a			; $49ba
	xor $01			; $49bb
	inc a			; $49bd
	ld l,Enemy.oamFlagsBackup		; $49be
	ldi (hl),a		; $49c0
	ld (hl),a		; $49c1
	ld a,b			; $49c2
	inc a			; $49c3
	jp enemySetAnimation		; $49c4


_mergedTwinrova_deathCutscene:
	ld e,Enemy.state2		; $49c7
	ld a,(de)		; $49c9
	rst_jumpTable			; $49ca
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate0:
	ld a,(wDisabledObjects)		; $49d3
	or a			; $49d6
	jr nz,++		; $49d7

	ld a,(wLinkDeathTrigger)		; $49d9
	or a			; $49dc
	ret nz			; $49dd

	inc a			; $49de
	ld (wDisableLinkCollisionsAndMenu),a		; $49df
	ld (wDisabledObjects),a		; $49e2
	call clearAllParentItems		; $49e5
++
	call _ecom_flickerVisibility		; $49e8
	call _ecom_decCounter1		; $49eb
	jr z,@doneExplosions	; $49ee

	ld a,(hl) ; [counter1]
	cp 97			; $49f1
	ret nc			; $49f3
	and $0f			; $49f4
	jp z,@createExplosion		; $49f6
	ret			; $49f9

@doneExplosions:
	ld (hl),25 ; [counter1]
	ld l,Enemy.state2		; $49fc
	inc (hl)		; $49fe

@substate1:
	call _ecom_decCounter1		; $49ff
	jp nz,_ecom_flickerVisibility		; $4a02

	ld l,e			; $4a05
	inc (hl) ; [statae2] = 2

	ld l,Enemy.oamFlagsBackup		; $4a07
	xor a			; $4a09
	ldi (hl),a		; $4a0a
	ld (hl),a		; $4a0b
	call enemySetAnimation		; $4a0c

	ld bc,TX_2f0c		; $4a0f
	jp showText		; $4a12

@substate2:
	ld a,$03		; $4a15
	ld (de),a ; [state2] = 3

	ld a,CUTSCENE_TWINROVA_SACRIFICE		; $4a18
	ld (wCutsceneTrigger),a		; $4a1a

	ld a,MUS_ROOM_OF_RITES		; $4a1d
	jp playSound		; $4a1f

@substate3:
	ret			; $4a22


@createExplosion:
	ld a,(hl)		; $4a23
	swap a			; $4a24
	dec a			; $4a26
	ld hl,@explosionPositions		; $4a27
	rst_addDoubleIndex			; $4a2a

	ld e,Enemy.yh		; $4a2b
	ld a,(de)		; $4a2d
	add (hl)		; $4a2e
	ld b,a			; $4a2f
	ld e,Enemy.xh		; $4a30
	inc hl			; $4a32
	ld a,(de)		; $4a33
	add (hl)		; $4a34
	ld c,a			; $4a35

	call getFreeInteractionSlot		; $4a36
	ret nz			; $4a39
	ld (hl),INTERACID_EXPLOSION		; $4a3a
	ld l,Interaction.yh		; $4a3c
	ld (hl),b		; $4a3e
	ld l,Interaction.xh		; $4a3f
	ld (hl),c		; $4a41
	ret			; $4a42

@explosionPositions:
	.db $f8 $f6
	.db $00 $06
	.db $02 $fe
	.db $06 $04
	.db $fc $05
	.db $fa $fc

;;
; @addr{4a4f}
_mergedTwinrova_decVar3bIfNonzero:
	ld h,d			; $4a4f
	ld l,Enemy.var3b		; $4a50
	ld a,(hl)		; $4a52
	or a			; $4a53
	ret z			; $4a54
	dec (hl)		; $4a55
	ret			; $4a56


; ==============================================================================
; ENEMYID_TWINROVA
;
; Variables:
;   var03: If bit 0 is unset, this acts as the "spawner" for the other twinrova object.
;          Bit 7: ?
;   relatedObj1: Reference to other twinrova object
;   relatedObj2: Reference to INTERACID_PUFF
;   var30: Anglular velocity (amount to add to angle)
;   var31: Counter used for z-position bobbing
;   var32: Bit 0: Nonzero while projectile is being fired?
;          Bit 1: Signal in merging cutscene
;          Bit 2: Signal to fire a projectile
;          Bit 3: Enable/disable z-position bobbing
;          Bit 4: Signal in merging cutscene
;          Bit 5: ?
;          Bit 6: Signal to do "death cutscene" if health is 0. Set by
;                 PARTID_RED_TWINROVA_PROJECTILE or PARTID_BLUE_TWINROVA_PROJECTILE.
;          Bit 7: If set, updates draw layer relative to Link
;   var33: Movement pattern (0-3)
;   var34: Position index (within the movement pattern)
;   var35/var36: Target position?
;   var37: Counter to update facing direction when it reaches 0?
;   var38: Index in "attack pattern"? (0-7)
;   var39: Some kind of counter?
; ==============================================================================
enemyCode03:
	jr z,@normalStatus	; $4a57
	sub ENEMYSTATUS_NO_HEALTH			; $4a59
	ret c			; $4a5b
	jr nz,@normalStatus	; $4a5c

	; Dead
	ld h,d			; $4a5e
	ld l,Enemy.var32		; $4a5f
	bit 6,(hl)		; $4a61
	jr z,@normalStatus	; $4a63

	ld l,Enemy.health		; $4a65
	ld (hl),$7f		; $4a67
	ld l,Enemy.collisionType		; $4a69
	res 7,(hl)		; $4a6b

	ld l,Enemy.state		; $4a6d
	ld (hl),$0d		; $4a6f

	; Set variables in relatedObj1 (other twinrova)
	ld a,Object.health		; $4a71
	call objectGetRelatedObject1Var		; $4a73
	ld (hl),$7f		; $4a76
	ld l,Enemy.collisionType		; $4a78
	res 7,(hl)		; $4a7a
	ld l,Enemy.state		; $4a7c
	ld (hl),$0f		; $4a7e

	ld a,SNDCTRL_STOPMUSIC		; $4a80
	call playSound		; $4a82

@normalStatus:
	call _twinrova_updateZPosition		; $4a85
	call @runState		; $4a88
	ld e,Enemy.var32		; $4a8b
	ld a,(de)		; $4a8d
	bit 7,a			; $4a8e
	jp nz,objectSetPriorityRelativeToLink_withTerrainEffects		; $4a90
	ret			; $4a93

@runState:
	call _twinrova_checkFireProjectile		; $4a94
	call _ecom_getSubidAndCpStateTo08		; $4a97
	jr nc,@state8OrHigher		; $4a9a
	rst_jumpTable			; $4a9c
	.dw _twinrova_state_uninitialized
	.dw _twinrova_state_spawner
	.dw _twinrova_state_stub
	.dw _twinrova_state_stub
	.dw _twinrova_state_stub
	.dw _twinrova_state_stub
	.dw _twinrova_state_stub
	.dw _twinrova_state_stub

@state8OrHigher:
	ld a,b			; $4aad
	rst_jumpTable		; $44ae
	.dw _twinrova_subid0
	.dw _twinrova_subid1


_twinrova_state_uninitialized:
	ld a,ENEMYID_TWINROVA		; $4ab3
	ld (wEnemyIDToLoadExtraGfx),a		; $4ab5
	ld a,$01		; $4ab8
	ld (wLoadedTreeGfxIndex),a		; $4aba

	ld h,d			; $4abd
	ld l,Enemy.var03		; $4abe
	bit 0,(hl)		; $4ac0
	ld a,SPEED_100		; $4ac2
	jp nz,_twinrova_initialize		; $4ac4

	ld l,e			; $4ac7
	inc (hl) ; [state] = 1

	xor a			; $4ac9
	ld (w1Link.direction),a		; $4aca
	inc a			; $4acd
	ld (wDisabledObjects),a		; $4ace
	ld (wMenuDisabled),a		; $4ad1


_twinrova_state_spawner:
	ld b,ENEMYID_TWINROVA		; $4ad4
	call _ecom_spawnUncountedEnemyWithSubid01		; $4ad6
	ret nz			; $4ad9

	; [child.var03] = [this.var03] + 1
	inc l			; $4ada
	ld e,l			; $4adb
	ld a,(de)		; $4adc
	inc a			; $4add
	ld (hl),a		; $4ade

	; [this.relatedObj1] = child
	; [child.relatedObj1] = this
	ld l,Enemy.relatedObj1		; $4adf
	ld e,l			; $4ae1
	ld a,Enemy.start		; $4ae2
	ld (de),a		; $4ae4
	ldi (hl),a		; $4ae5
	inc e			; $4ae6
	ld a,h			; $4ae7
	ld (de),a		; $4ae8
	ld (hl),d		; $4ae9

	ld a,h			; $4aea
	cp d			; $4aeb
	ld a,SPEED_100		; $4aec
	jp nc,_twinrova_initialize		; $4aee

	; Swap the twinrova objects; subid 0 must come before subid 1?
	ld l,Enemy.enabled		; $4af1
	ld e,l			; $4af3
	ld a,(de)		; $4af4
	ld (hl),a		; $4af5

	ld l,Enemy.subid		; $4af6
	dec (hl) ; [child.subid] = 0
	ld h,d			; $4af9
	inc (hl) ; [this.subid] = 1
	inc l			; $4afb
	inc (hl) ; [this.var03] = 1
	ld l,Enemy.state		; $4afd
	dec (hl) ; [this.state] = 0
	ret			; $4b00


_twinrova_state_stub:
	ret			; $4b01


_twinrova_subid0:
	ld a,(de)		; $4b02
	sub $08			; $4b03
	rst_jumpTable			; $4b05
	.dw _twinrova_state8
	.dw _twinrova_state9
	.dw _twinrova_subid0_stateA
	.dw _twinrova_subid0_stateB
	.dw _twinrova_subid0_stateC
	.dw _twinrova_stateD
	.dw _twinrova_stateE
	.dw _twinrova_stateF
	.dw _twinrova_state10


; Cutscene before fight
_twinrova_state8:
	ld h,d			; $4b18
	ld l,e			; $4b19
	inc (hl) ; [state] = 9

	ld l,Enemy.var32		; $4b1b
	set 3,(hl)		; $4b1d
	set 7,(hl)		; $4b1f

	ld l,Enemy.counter1		; $4b21
	ld (hl),106		; $4b23

	ld l,Enemy.yh		; $4b25
	ld (hl),$08		; $4b27

	; Set initial x-position, oam flags, angle, and var30 based on subid
	ld l,Enemy.subid		; $4b29
	ld a,(hl)		; $4b2b
	add a			; $4b2c
	ld hl,@data		; $4b2d
	rst_addDoubleIndex			; $4b30

	ld e,Enemy.xh		; $4b31
	ldi a,(hl)		; $4b33
	ld (de),a		; $4b34
	ld e,Enemy.oamFlagsBackup		; $4b35
	ldi a,(hl)		; $4b37
	ld (de),a		; $4b38
	inc e			; $4b39
	ld (de),a		; $4b3a

	ld e,Enemy.angle		; $4b3b
	ldi a,(hl)		; $4b3d
	ld (de),a		; $4b3e
	ld e,Enemy.var30		; $4b3f
	ld a,(hl)		; $4b41
	ld (de),a		; $4b42

	; Subid 0 only: show text
	ld e,Enemy.subid		; $4b43
	ld a,(de)		; $4b45
	or a			; $4b46
	ld bc,TX_2f04		; $4b47
	call z,showText		; $4b4a

	call getRandomNumber_noPreserveVars		; $4b4d
	ld e,Enemy.var31		; $4b50
	ld (de),a		; $4b52
	jp _twinrova_updateAnimationFromAngle		; $4b53

; Data per subid: x-position, oam flags, angle, var30
@data:
	.db $c0 $02 $11 $01 ; Subid 0
	.db $30 $01 $0f $ff ; Subid 1


; Moving down the screen in the pre-fight cutscene
_twinrova_state9:
	inc e			; $4b5e
	ld a,(de)		; $4b5f
	rst_jumpTable			; $4b60
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4

@substate0:
	call _ecom_decCounter1		; $4b6b
	jr nz,@applySpeed	; $4b6e

	ld (hl),$08 ; [counter1]
	inc l			; $4b72
	ld (hl),$12 ; [counter2]
	ld l,e			; $4b75
	inc (hl) ; [state2] = 1
	jr @animate		; $4b77

@substate1:
	call _ecom_decCounter1		; $4b79
	jr nz,@applySpeed	; $4b7c

	ld (hl),$08 ; [counter1]
	inc l			; $4b80
	dec (hl) ; [counter2]
	jr nz,@updateAngle	; $4b82

	ld l,e			; $4b84
	inc (hl) ; [state2] = 3
	inc l			; $4b86
	ld (hl),30 ; [counter1]

	call _ecom_updateAngleTowardTarget		; $4b89
	call _twinrova_calculateAnimationFromAngle		; $4b8c
	ld (hl),a		; $4b8f
	jp enemySetAnimation		; $4b90

@updateAngle:
	ld e,Enemy.angle		; $4b93
	ld l,Enemy.var30		; $4b95
	ld a,(de)		; $4b97
	add (hl)		; $4b98
	and $1f			; $4b99
	ld (de),a		; $4b9b
	call _twinrova_updateAnimationFromAngle		; $4b9c

@applySpeed:
	call objectApplySpeed		; $4b9f
@animate:
	jp enemyAnimate		; $4ba2

@substate2:
	call _ecom_decCounter1		; $4ba5
	jr nz,@animate	; $4ba8

	ld l,e			; $4baa
	inc (hl) ; [state2] = 3

	ld e,Enemy.subid		; $4bac
	ld a,(de)		; $4bae
	or a			; $4baf
	ret nz			; $4bb0
	ld bc,TX_2f05		; $4bb1
	jp showText		; $4bb4

@substate3:
	ldbc INTERACID_PUFF,$02		; $4bb7
	call objectCreateInteraction		; $4bba
	ret nz			; $4bbd
	ld a,h			; $4bbe
	ld h,d			; $4bbf
	ld l,Enemy.relatedObj2+1		; $4bc0
	ldd (hl),a		; $4bc2
	ld (hl),Interaction.start		; $4bc3

	ld l,Enemy.state2		; $4bc5
	inc (hl) ; [state2] = 4

	ld l,Enemy.var32		; $4bc8
	res 7,(hl)		; $4bca
	jp objectSetInvisible		; $4bcc

@substate4:
	; Wait for puff to finish
	ld a,Object.animParameter		; $4bcf
	call objectGetRelatedObject2Var		; $4bd1
	bit 7,(hl)		; $4bd4
	ret z			; $4bd6

	ld h,d			; $4bd7
	ld l,Enemy.var32		; $4bd8
	set 7,(hl)		; $4bda
	xor a			; $4bdc
	ld (wDisabledObjects),a		; $4bdd
	ld (wMenuDisabled),a		; $4be0

	ld a,CUTSCENE_FLAMES_FLICKERING		; $4be3
	ld (wCutsceneTrigger),a		; $4be5

	call _ecom_updateAngleTowardTarget		; $4be8
	call _twinrova_calculateAnimationFromAngle		; $4beb
	add $04			; $4bee
	ld (hl),a		; $4bf0
	jp enemySetAnimation		; $4bf1


; Fight just starting
_twinrova_subid0_stateA:
	ld h,d			; $4bf4
	ld l,e			; $4bf5
	inc (hl) ; [state] = $0b

	ld a,MUS_TWINROVA		; $4bf7
	ld (wActiveMusic),a		; $4bf9
	call playSound		; $4bfc
	jp _twinrova_subid0_updateTargetPosition		; $4bff


; Moving normally
_twinrova_subid0_stateB:
	ld a,(wFrameCounter)		; $4c02
	and $7f			; $4c05
	ld a,SND_FAIRYCUTSCENE		; $4c07
	call z,playSound		; $4c09

	call _twinrova_moveTowardTargetPosition		; $4c0c
	ret nc			; $4c0f
	call _twinrova_subid0_updateTargetPosition		; $4c10
	jr nz,@waypointChanged	; $4c13

	; Done this movement pattern
	call _ecom_incState ; [state] = $0c
	ld l,Enemy.counter1		; $4c18
	ld (hl),30		; $4c1a
	ret			; $4c1c

@waypointChanged:
	call _twinrova_checkAttackInProgress		; $4c1d
	ret nz			; $4c20

	ld e,Enemy.var38		; $4c21
	ld a,(de)		; $4c23
	inc a			; $4c24
	and $07			; $4c25
	ld (de),a		; $4c27
	ld hl,@attackPattern		; $4c28
	call checkFlag		; $4c2b
	jp nz,_twinrova_chooseObjectToAttack		; $4c2e
	ret			; $4c31

@attackPattern:
	.db %01110101


; Delay before choosing new movement pattern and returning to state $0b
_twinrova_subid0_stateC:
	call _ecom_decCounter1		; $4c33
	jp nz,enemyAnimate		; $4c36

	ld l,e			; $4c39
	dec (hl) ; [state] = $0b

	; Choose random movement pattern
	call getRandomNumber_noPreserveVars		; $4c3b
	and $03			; $4c3e
	ld e,Enemy.var33		; $4c40
	ld (de),a		; $4c42
	inc e			; $4c43
	xor a			; $4c44
	ld (de),a ; [var34]

	jp _twinrova_subid0_updateTargetPosition		; $4c46


; Health just reached 0
_twinrova_stateD:
	ld h,d			; $4c49
	ld l,e			; $4c4a
	inc (hl) ; [state] = $0e

	ld l,Enemy.zh		; $4c4c
	ld (hl),$00		; $4c4e
	ld l,Enemy.var32		; $4c50
	res 3,(hl)		; $4c52

	ld l,Enemy.angle		; $4c54
	bit 4,(hl)		; $4c56
	ld a,$0a		; $4c58
	jr z,+			; $4c5a
	inc a			; $4c5c
+
	jp enemySetAnimation		; $4c5d


; Delay before showing text
_twinrova_stateE:
	ld e,Enemy.animParameter		; $4c60
	ld a,(de)		; $4c62
	inc a			; $4c63
	jr nz,_twinrova_animate	; $4c64

	ld e,Enemy.direction		; $4c66
	ld a,(de)		; $4c68
	add $04			; $4c69
	call enemySetAnimation		; $4c6b

	call _ecom_incState		; $4c6e
	ld l,Enemy.zh		; $4c71
	dec (hl)		; $4c73
	ld bc,TX_2f09		; $4c74
	call showText		; $4c77
_twinrova_animate:
	jp enemyAnimate		; $4c7a


_twinrova_stateF:
	call _twinrova_rise2PixelsAboveGround		; $4c7d
	jr nz,_twinrova_animate	; $4c80

	; Wait for signal that twin has risen
	ld a,Object.var32		; $4c82
	call objectGetRelatedObject1Var		; $4c84
	bit 4,(hl)		; $4c87
	jr nz,@nextState	; $4c89

	call _ecom_updateAngleTowardTarget		; $4c8b
	call _twinrova_updateMovingAnimation		; $4c8e
	jr _twinrova_animate		; $4c91

@nextState:
	call _ecom_incState		; $4c93
	inc l			; $4c96
	ld (hl),$00 ; [state2] = 0

	ld l,Enemy.var32		; $4c99
	res 3,(hl)		; $4c9b
	jr _twinrova_animate		; $4c9d


; Merging into one
_twinrova_state10:
	inc e			; $4c9f
	ld a,(de)		; $4ca0
	rst_jumpTable			; $4ca1
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4
	.dw @substate5
	.dw @substate6
	.dw @substate7

; Showing more text
@substate0:
	ld h,d			; $4cb2
	ld l,e			; $4cb3
	inc (hl) ; [state2] = 1

	ld l,Enemy.var32		; $4cb5
	res 1,(hl)		; $4cb7
	res 0,(hl)		; $4cb9

	ld l,Enemy.direction		; $4cbb
	ld (hl),$00		; $4cbd

	ld bc,-$3e0		; $4cbf
	call objectSetSpeedZ		; $4cc2

	ld e,Enemy.subid		; $4cc5
	ld a,(de)		; $4cc7
	or a			; $4cc8
	ret nz			; $4cc9
	ld bc,TX_2f0a		; $4cca
	jp showText		; $4ccd

; Rising up above screen
@substate1:
	ld c,$08		; $4cd0
	call objectUpdateSpeedZ_paramC		; $4cd2
	ldh a,(<hCameraY)	; $4cd5
	ld b,a			; $4cd7
	ld l,Enemy.yh		; $4cd8
	ld a,(hl)		; $4cda
	sub b			; $4cdb
	jr nc,+			; $4cdc
	ld a,(hl)		; $4cde
+
	ld b,a			; $4cdf
	ld l,Enemy.zh		; $4ce0
	ld a,(hl)		; $4ce2
	cp $80			; $4ce3
	jr c,++			; $4ce5

	add b			; $4ce7
	cp $f0			; $4ce8
	jr c,@animate	; $4cea
++
	ld l,Enemy.state2		; $4cec
	inc (hl) ; [state2] = 2

	ld l,Enemy.var32		; $4cef
	set 1,(hl)		; $4cf1
	ld l,Enemy.var32		; $4cf3
	res 7,(hl)		; $4cf5

	ld l,Enemy.counter1		; $4cf7
	ld (hl),60		; $4cf9
	jp objectSetInvisible		; $4cfb

; Waiting for both twins to finish substate 1 (rise above screen)
@substate2:
	ld e,Enemy.subid		; $4cfe
	ld a,(de)		; $4d00
	or a			; $4d01
	ret nz			; $4d02

	; Subid 0 only: wait for twin to finish substate 1
	ld a,Object.var32		; $4d03
	call objectGetRelatedObject1Var		; $4d05
	bit 1,(hl)		; $4d08
	ret z			; $4d0a

	; Increment state2 for both (now synchronized)
	ld l,Enemy.state2		; $4d0b
	inc (hl)		; $4d0d
	ld h,d			; $4d0e
	inc (hl)		; $4d0f
	ret			; $4d10

; Delay before coming back down
@substate3:
	call _ecom_decCounter1		; $4d11
	ret nz			; $4d14

	ld (hl),48 ; [counter1]
	ld l,e			; $4d17
	inc (hl) ; [state2] = 4

	ld l,Enemy.zh		; $4d19
	ld (hl),$a0		; $4d1b

	ld l,Enemy.angle		; $4d1d
	ld e,Enemy.subid		; $4d1f
	ld a,(de)		; $4d21
	or a			; $4d22
	ld (hl),$08		; $4d23
	jr z,+			; $4d25
	ld (hl),$18		; $4d27
+
	ld l,Enemy.var32		; $4d29
	set 7,(hl)		; $4d2b
	call objectSetVisiblec2		; $4d2d
	ld a,SND_WIND		; $4d30
	call playSound		; $4d32

; Circling down to ground
@substate4:
	ld bc,$5878		; $4d35
	ld e,Enemy.counter1		; $4d38
	ld a,(de)		; $4d3a
	ld e,Enemy.angle		; $4d3b
	call objectSetPositionInCircleArc		; $4d3d

	ld e,Enemy.angle		; $4d40
	ld a,(de)		; $4d42
	add $08			; $4d43
	and $1f			; $4d45
	call _twinrova_updateMovingAnimationGivenAngle		; $4d47

	ld h,d			; $4d4a
	ld l,Enemy.zh		; $4d4b
	inc (hl)		; $4d4d
	ld a,(hl)		; $4d4e
	rrca			; $4d4f
	jr c,@animate	; $4d50

	; Every other frame, increment angle
	ld l,Enemy.angle		; $4d52
	ld a,(hl)		; $4d54
	inc a			; $4d55
	and $1f			; $4d56
	ld (hl),a		; $4d58
	ld l,Enemy.counter1		; $4d59
	dec (hl)		; $4d5b
	jr nz,@animate	; $4d5c

	dec l			; $4d5e
	inc (hl) ; [state2] = 5
@animate:
	jp enemyAnimate		; $4d60

; Reached ground
@substate5:
	; Delete subid 1 (subid 0 will remain)
	ld e,Enemy.subid		; $4d63
	ld a,(de)		; $4d65
	or a			; $4d66
	jp nz,enemyDelete		; $4d67

	ld a,(wLinkDeathTrigger)		; $4d6a
	or a			; $4d6d
	ret nz			; $4d6e

	inc a			; $4d6f
	ld (wDisabledObjects),a		; $4d70
	ld (wDisableLinkCollisionsAndMenu),a		; $4d73

	ld h,d			; $4d76
	ld l,Enemy.state2		; $4d77
	inc (hl) ; [state2] = 6

	ld l,Enemy.oamFlagsBackup		; $4d7a
	xor a			; $4d7c
	ldi (hl),a		; $4d7d
	ld (hl),a		; $4d7e

	ld a,$0c		; $4d7f
	call enemySetAnimation		; $4d81
	ld a,SND_TRANSFORM		; $4d84
	call playSound		; $4d86

	ld a,$02		; $4d89
	jp fadeinFromWhiteWithDelay		; $4d8b

; Waiting for screen to fade back in from white
@substate6:
	ld a,(wPaletteThread_mode)		; $4d8e
	or a			; $4d91
	ret nz			; $4d92

	ld h,d			; $4d93
	ld l,Enemy.state2		; $4d94
	inc (hl) ; [state2] = 7

	ld l,Enemy.var32		; $4d97
	res 0,(hl)		; $4d99

	ld a,$01		; $4d9b
	ld (wLoadedTreeGfxIndex),a		; $4d9d
	ret			; $4da0

; Initiating next phase of fight
@substate7:
	; Find a free enemy slot. (Why does it do this manually instead of using
	; "getFreeEnemySlot"?)
	ld h,d			; $4da1
	ld l,Enemy.enabled		; $4da2
	inc h			; $4da4
@nextEnemy:
	ld a,(hl)		; $4da5
	or a			; $4da6
	jr z,@foundFreeSlot	; $4da7
	inc h			; $4da9
	ld a,h			; $4daa
	cp LAST_ENEMY_INDEX+1			; $4dab
	jr c,@nextEnemy	; $4dad
	ret			; $4daf

@foundFreeSlot:
	ld e,l			; $4db0
	ld a,(de)		; $4db1
	ldi (hl),a ; [child.enabled] = [this.enabled]
	ld (hl),ENEMYID_MERGED_TWINROVA ; [child.id]
	call objectCopyPosition		; $4db5

	ld a,$01		; $4db8
	ld (wLoadedTreeGfxIndex),a		; $4dba

	jp enemyDelete		; $4dbd


; Subid 1 is nearly identical to subid 0, it just doesn't do a few things like playing
; sound effects.
_twinrova_subid1:
	ld a,(de)		; $4dc0
	sub $08			; $4dc1
	rst_jumpTable			; $4dc3
	.dw _twinrova_state8
	.dw _twinrova_state9
	.dw _twinrova_subid1_stateA
	.dw _twinrova_subid1_stateB
	.dw _twinrova_subid1_stateC
	.dw _twinrova_stateD
	.dw _twinrova_stateE
	.dw _twinrova_stateF
	.dw _twinrova_state10


; Fight just starting
_twinrova_subid1_stateA:
	ld a,$0b		; $4dd6
	ld (de),a ; [state] = $0b
	jp _twinrova_subid1_updateTargetPosition		; $4dd9


; Moving normally
_twinrova_subid1_stateB:
	call _twinrova_moveTowardTargetPosition		; $4ddc
	ret nc			; $4ddf
	call _twinrova_subid1_updateTargetPosition		; $4de0
	ret nz			; $4de3

	; Done this movement pattern
	call _ecom_incState		; $4de4
	ld l,Enemy.counter1		; $4de7
	ld (hl),30		; $4de9
	ret			; $4deb


; Delay before choosing new movement pattern and returning to state $0b
_twinrova_subid1_stateC:
	call _ecom_decCounter1		; $4dec
	jp nz,enemyAnimate		; $4def

	ld l,e			; $4df2
	dec (hl) ; [state] = $0b

	; Choose random movement pattern
	call getRandomNumber_noPreserveVars		; $4df4
	and $03			; $4df7
	ld e,Enemy.var33		; $4df9
	ld (de),a		; $4dfb
	inc e			; $4dfc
	xor a			; $4dfd
	ld (de),a ; [var34]

	jp _twinrova_subid1_updateTargetPosition		; $4dff


;;
; @param	a	Speed
; @addr{4e02}
_twinrova_initialize:
	ld h,d			; $4e02
	ld l,Enemy.var03		; $4e03
	bit 7,(hl)		; $4e05
	jp z,_ecom_setSpeedAndState8		; $4e07

	xor a			; $4e0a
	ld (wDisabledObjects),a		; $4e0b
	ld (wMenuDisabled),a		; $4e0e
	ld l,Enemy.yh		; $4e11
	ld (hl),$56		; $4e13
	ld l,Enemy.xh		; $4e15
	ld (hl),$60		; $4e17

	ld e,Enemy.subid		; $4e19
	ld a,(de)		; $4e1b
	or a			; $4e1c
	ld a,$02		; $4e1d
	jr z,++			; $4e1f
	ld (hl),$90 ; [xh]
	dec a			; $4e23
++
	ld l,Enemy.oamFlagsBackup		; $4e24
	ldi (hl),a		; $4e26
	ld (hl),a		; $4e27

	ld l,Enemy.state		; $4e28
	ld (hl),$0a		; $4e2a

	ld l,Enemy.direction		; $4e2c
	ld (hl),$ff		; $4e2e
	ld l,Enemy.speed		; $4e30
	ld (hl),SPEED_140		; $4e32

	ld l,Enemy.var32		; $4e34
	set 3,(hl)		; $4e36
	set 7,(hl)		; $4e38

	call _ecom_updateAngleTowardTarget		; $4e3a
	call _twinrova_calculateAnimationFromAngle		; $4e3d
	add $04			; $4e40
	ld (hl),a		; $4e42
	jp enemySetAnimation		; $4e43

;;
; @addr{4e46}
_twinrova_updateZPosition:
	ld h,d			; $4e46
	ld l,Enemy.var37		; $4e47
	ld a,(hl)		; $4e49
	or a			; $4e4a
	jr z,+			; $4e4b
	dec (hl)		; $4e4d
+
	ld l,Enemy.var32		; $4e4e
	bit 3,(hl)		; $4e50
	ret z			; $4e52

	ld l,Enemy.var31		; $4e53
	dec (hl)		; $4e55
	ld a,(hl)		; $4e56
	and $07			; $4e57
	ret nz			; $4e59

	ld a,(hl)		; $4e5a
	and $18			; $4e5b
	swap a			; $4e5d
	rlca			; $4e5f
	ld hl,@levitationZPositions		; $4e60
	rst_addAToHl			; $4e63
	ld e,Enemy.zh		; $4e64
	ld a,(hl)		; $4e66
	ld (de),a		; $4e67
	ret			; $4e68

@levitationZPositions:
	.db -3, -4, -5, -4

;;
; @addr{4e6d}
_twinrova_checkFireProjectile:
	ld h,d			; $4e6d
	ld l,Enemy.var32		; $4e6e
	bit 0,(hl)		; $4e70
	ret z			; $4e72

	bit 2,(hl)		; $4e73
	jr nz,@fireProjectile	; $4e75

	ld l,Enemy.collisionType		; $4e77
	bit 7,(hl)		; $4e79
	ret z			; $4e7b

	ld l,Enemy.var39		; $4e7c
	ld a,(hl)		; $4e7e
	or a			; $4e7f
	ld e,Enemy.animParameter		; $4e80
	jr z,@var39Zero	; $4e82

	dec (hl) ; [var39]
	ld a,(de) ; [animParameter]
	inc a			; $4e86
	ret nz			; $4e87

@var39Zero:
	dec a			; $4e88
	ld (de),a ; [animParameter] = $ff

	ld e,Enemy.angle		; $4e8a
	ld a,(de)		; $4e8c
	call _twinrova_calculateAnimationFromAngle		; $4e8d
	ld (hl),a		; $4e90
	add $04			; $4e91
	jp enemySetAnimation		; $4e93

@fireProjectile:
	res 2,(hl) ; [var32]

	ld l,Enemy.direction		; $4e98
	ld (hl),$ff		; $4e9a
	ld l,Enemy.var39		; $4e9c
	ld (hl),240		; $4e9e

	call @spawnProjectile		; $4ea0
	call objectGetAngleTowardEnemyTarget		; $4ea3
	cp $10			; $4ea6
	ld a,$00		; $4ea8
	jr c,+			; $4eaa
	inc a			; $4eac
+
	add $08			; $4ead
	jp enemySetAnimation		; $4eaf

;;
; @addr{4eb2}
@spawnProjectile:
	ld b,PARTID_RED_TWINROVA_PROJECTILE		; $4eb2
	ld e,Enemy.subid		; $4eb4
	ld a,(de)		; $4eb6
	or a			; $4eb7
	jr z,+			; $4eb8
	ld b,PARTID_BLUE_TWINROVA_PROJECTILE		; $4eba
+
	jp _ecom_spawnProjectile		; $4ebc

;;
; Unused?
;
; @param	h	Object to set target position to
; @addr{4ebf}
_twinrova_setTargetPositionToObject:
	ld l,Enemy.yh		; $4ebf
	ld e,l			; $4ec1
	ld b,(hl)		; $4ec2
	ld a,(de)		; $4ec3
	ldh (<hFF8F),a	; $4ec4
	ld l,Enemy.xh		; $4ec6
	ld e,l			; $4ec8
	ld c,(hl)		; $4ec9
	ld a,(de)		; $4eca
	ldh (<hFF8E),a	; $4ecb
	call _ecom_moveTowardPosition		; $4ecd
	jr _twinrova_updateMovingAnimation		; $4ed0


;;
; @addr{4ed2}
_twinrova_updateAnimationFromAngle:
	ld e,Enemy.angle		; $4ed2
	ld a,(de)		; $4ed4
	call _twinrova_calculateAnimationFromAngle		; $4ed5
	ret z			; $4ed8
	ld (hl),a		; $4ed9
	jp enemySetAnimation		; $4eda

;;
; @addr{4edd}
_twinrova_updateMovingAnimation:
	ld e,Enemy.angle		; $4edd
	ld a,(de)		; $4edf

;;
; @param	a	angle
; @addr{4ee0}
_twinrova_updateMovingAnimationGivenAngle:
	call _twinrova_calculateAnimationFromAngle		; $4ee0
	ret z			; $4ee3

	bit 7,(hl)		; $4ee4
	ret nz			; $4ee6

	ld b,a			; $4ee7
	ld e,Enemy.var37		; $4ee8
	ld a,(de)		; $4eea
	or a			; $4eeb
	ret nz			; $4eec

	ld a,30		; $4eed
	ld (de),a ; [var37]

	ld a,b			; $4ef0
	ld (hl),a ; [direction]
	add $04			; $4ef2
	jp enemySetAnimation		; $4ef4


;;
; @param	a	Angle value
; @param[out]	hl	Enemy.direction
; @param[out]	zflag	z if calculated animation is the same as current animation
; @addr{4ef7}
_twinrova_calculateAnimationFromAngle:
	ld c,a			; $4ef7
	add $04			; $4ef8
	and $18			; $4efa
	swap a			; $4efc
	rlca			; $4efe
	ld b,a			; $4eff
	ld h,d			; $4f00
	ld l,Enemy.direction		; $4f01
	ld a,c			; $4f03
	and $07			; $4f04
	cp $04			; $4f06
	ld a,b			; $4f08
	ret z			; $4f09
	cp (hl)			; $4f0a
	ret			; $4f0b

;;
; @param[out]	zflag	z if reached the end of the movement pattern
; @addr{4f0c}
_twinrova_subid0_updateTargetPosition:
	ld hl,_twinrova_subid0_targetPositions		; $4f0c
	jr ++			; $4f0f

;;
; @addr{4f11}
_twinrova_subid1_updateTargetPosition:
	ld hl,_twinrova_subid1_targetPositions		; $4f11
++
	ld e,Enemy.var37		; $4f14
	xor a			; $4f16
	ld (de),a		; $4f17

	ld e,Enemy.var34		; $4f18
	ld a,(de)		; $4f1a
	ld b,a			; $4f1b
	inc a			; $4f1c
	ld (de),a		; $4f1d

	dec e			; $4f1e
	ld a,(de) ; [var33]
	rst_addDoubleIndex			; $4f20
	ldi a,(hl)		; $4f21
	ld h,(hl)		; $4f22
	ld l,a			; $4f23

	ld a,b			; $4f24
	rst_addDoubleIndex			; $4f25
	ld e,Enemy.var35		; $4f26
	ldi a,(hl)		; $4f28
	or a			; $4f29
	ret z			; $4f2a

	ld (de),a		; $4f2b
	inc e			; $4f2c
	ld a,(hl)		; $4f2d
	ld (de),a		; $4f2e

;;
; @param[out]	cflag	c if reached target position
; @addr{4f2f}
_twinrova_moveTowardTargetPosition:
	ld h,d			; $4f2f
	ld l,Enemy.var35		; $4f30
	call _ecom_readPositionVars		; $4f32
	sub c			; $4f35
	inc a			; $4f36
	cp $03			; $4f37
	jr nc,@moveToward	; $4f39

	ldh a,(<hFF8F)	; $4f3b
	sub b			; $4f3d
	inc a			; $4f3e
	cp $03			; $4f3f
	ret c			; $4f41

@moveToward:
	call _ecom_moveTowardPosition		; $4f42
	call _twinrova_updateMovingAnimation		; $4f45
	call enemyAnimate		; $4f48
	or d			; $4f4b
	ret			; $4f4c

;;
; Randomly chooses either this object or its twin to begin an attack
; @addr{4f4d}
_twinrova_chooseObjectToAttack:
	call getRandomNumber_noPreserveVars		; $4f4d
	rrca			; $4f50
	ld h,d			; $4f51
	ld l,Enemy.var32		; $4f52
	jr nc,++		; $4f54

	ld a,Object.var32		; $4f56
	call objectGetRelatedObject1Var		; $4f58
++
	ld a,(hl)		; $4f5b
	or $05			; $4f5c
	ld (hl),a		; $4f5e
	ret			; $4f5f


;;
; Checks if an attack is in progress, unsets bit 0 of var32 when attack is done?
;
; @param[out]	zflag	nz if either twinrova is currently doing an attack
; @addr{4f60}
_twinrova_checkAttackInProgress:
	ld h,d			; $4f60
	ld l,Enemy.var32		; $4f61
	bit 0,(hl)		; $4f63
	jr nz,++		; $4f65

	ld a,Object.var32		; $4f67
	call objectGetRelatedObject1Var		; $4f69
	bit 0,(hl)		; $4f6c
	ret z			; $4f6e
++
	ld l,Enemy.direction		; $4f6f
	bit 7,(hl)		; $4f71
	ret nz			; $4f73

	ld l,Enemy.var32		; $4f74
	res 0,(hl)		; $4f76
	or d			; $4f78
	ret			; $4f79

;;
; @param[out]	zflag	z if Twinrova's risen to the desired height (-2)
; @addr{4f7a}
_twinrova_rise2PixelsAboveGround:
	ld h,d			; $4f7a
	ld l,Enemy.zh		; $4f7b
	ld a,(hl)		; $4f7d
	cp $fe			; $4f7e
	jr c,++			; $4f80
	dec (hl)		; $4f82
	ret			; $4f83
++
	ld l,Enemy.var32		; $4f84
	ld a,(hl)		; $4f86
	or $18			; $4f87
	ld (hl),a		; $4f89
	xor a			; $4f8a
	ret			; $4f8b

;;
; Unused?
; @addr{4f8c}
_twinrova_incState2ForSelfAndTwin:
	ld a,Object.state2		; $4f8c
	call objectGetRelatedObject1Var		; $4f8e
	inc (hl)		; $4f91
	ld h,d			; $4f92
	inc (hl)		; $4f93
	ret			; $4f94


_twinrova_subid0_targetPositions:
	.dw @pattern0
	.dw @pattern1
	.dw @pattern2
	.dw @pattern3

@pattern0:
	.db $50 $58
	.db $90 $a0
	.db $90 $b8
	.db $58 $d0
	.db $20 $b8
	.db $20 $a0
	.db $90 $40
	.db $90 $28
	.db $58 $18
	.db $20 $28
	.db $20 $40
	.db $00
@pattern1:
	.db $50 $58
	.db $70 $c0
	.db $80 $c0
	.db $90 $90
	.db $90 $60
	.db $80 $30
	.db $70 $30
	.db $40 $c0
	.db $30 $c0
	.db $20 $90
	.db $20 $60
	.db $30 $30
	.db $40 $30
	.db $00
@pattern2:
	.db $50 $58
	.db $80 $80
	.db $80 $a0
	.db $68 $c0
	.db $38 $c0
	.db $20 $a0
	.db $20 $50
	.db $30 $40
	.db $00
@pattern3:
	.db $50 $58
	.db $60 $70
	.db $80 $70
	.db $90 $40
	.db $60 $28
	.db $50 $58
	.db $50 $98
	.db $60 $c8
	.db $88 $b8
	.db $88 $a0
	.db $20 $80
	.db $20 $70
	.db $00


_twinrova_subid1_targetPositions:
	.dw @pattern0
	.dw @pattern1
	.dw @pattern2
	.dw @pattern3

@pattern0:
	.db $50 $98
	.db $90 $50
	.db $90 $38
	.db $58 $20
	.db $20 $38
	.db $20 $50
	.db $90 $b8
	.db $90 $c8
	.db $58 $d8
	.db $20 $c8
	.db $20 $b8
	.db $00
@pattern1:
	.db $50 $98
	.db $70 $30
	.db $80 $30
	.db $90 $60
	.db $90 $90
	.db $80 $c0
	.db $70 $c0
	.db $40 $30
	.db $30 $30
	.db $20 $60
	.db $20 $90
	.db $30 $c0
	.db $40 $c0
	.db $00
@pattern2:
	.db $50 $98
	.db $80 $70
	.db $80 $50
	.db $68 $30
	.db $38 $30
	.db $20 $50
	.db $20 $a0
	.db $30 $b0
	.db $00
@pattern3:
	.db $50 $98
	.db $50 $58
	.db $78 $48
	.db $90 $78
	.db $78 $a8
	.db $50 $20
	.db $30 $20
	.db $28 $40
	.db $60 $a0
	.db $50 $d0
	.db $30 $d0
	.db $28 $b0
	.db $00

; ==============================================================================
; ENEMYID_GANON
;
; Variables:
;   relatedObj1: ENEMYID_GANON_REVIVAL_CUTSCENE
;   relatedObj2: PARTID_SHADOW object
;   var30: Base x-position during teleport
;   var32: Related to animation for state A?
;   var35+: Pointer to sequence of attack states to iterate through
; ==============================================================================
enemyCode04:
	jr z,@normalStatus	; $505d
	sub ENEMYSTATUS_NO_HEALTH			; $505f
	ret c			; $5061
	jr nz,@normalStatus	; $5062

	; Dead
	call checkLinkVulnerable		; $5064
	ret nc			; $5067
	ld h,d			; $5068
	ld l,Enemy.health		; $5069
	ld (hl),$40		; $506b
	ld l,Enemy.state		; $506d
	ld (hl),$0e		; $506f
	inc l			; $5071
	ld (hl),$00 ; [state2]
	inc l			; $5074
	ld (hl),120 ; [counter1]

	ld a,$01		; $5077
	ld (wDisableLinkCollisionsAndMenu),a		; $5079

	ld a,SND_BOSS_DEAD		; $507c
	call playSound		; $507e

	ld a,GFXH_b4		; $5081
	call ganon_loadGfxHeader		; $5083

	ld a,$0e		; $5086
	call enemySetAnimation		; $5088

	call getThisRoomFlags		; $508b
	set 7,(hl)		; $508e
	ld l,<ROOM_5f1		; $5090
	set 7,(hl)		; $5092
	ld l,<ROOM_5f5		; $5094
	set 7,(hl)		; $5096

	ld a,SNDCTRL_STOPMUSIC		; $5098
	call playSound		; $509a
	ld bc,TX_2f0e		; $509d
	jp showText		; $50a0

@normalStatus:
	ld e,Enemy.state		; $50a3
	ld a,(de)		; $50a5
	rst_jumpTable			; $50a6
	.dw _ganon_state_uninitialized
	.dw _ganon_state1
	.dw _ganon_state2
	.dw _ganon_state3
	.dw _ganon_state4
	.dw _ganon_state5
	.dw _ganon_state6
	.dw _ganon_state7
	.dw _ganon_state8
	.dw _ganon_state9
	.dw _ganon_stateA
	.dw _ganon_stateB
	.dw _ganon_stateC
	.dw _ganon_stateD
	.dw _ganon_stateE


_ganon_state_uninitialized:
	ld h,d			; $50c5
	ld l,e			; $50c6
	inc (hl) ; [state] = 1

	ld l,Enemy.oamTileIndexBase		; $50c8
	ld (hl),$00		; $50ca
	ld l,Enemy.yh		; $50cc
	ld (hl),$48		; $50ce
	ld l,Enemy.xh		; $50d0
	ld (hl),$78		; $50d2
	ld l,Enemy.zh		; $50d4
	dec (hl)		; $50d6

	ld hl,w1Link.yh		; $50d7
	ld (hl),$88		; $50da
	ld l,<w1Link.xh		; $50dc
	ld (hl),$78		; $50de
	ld l,<w1Link.direction		; $50e0
	ld (hl),DIR_UP		; $50e2
	ld l,<w1Link.enabled		; $50e4
	ld (hl),$03		; $50e6

	; Load extra graphics for ganon
	ld hl,wLoadedObjectGfx		; $50e8
	ld a,$01		; $50eb
	ld (hl),OBJGFXH_16		; $50ed
	inc l			; $50ef
	ldi (hl),a		; $50f0
	ld (hl),OBJGFXH_18		; $50f1
	inc l			; $50f3
	ldi (hl),a		; $50f4
	ld (hl),OBJGFXH_19		; $50f5
	inc l			; $50f7
	ldi (hl),a		; $50f8
	ld (hl),OBJGFXH_1a		; $50f9
	inc l			; $50fb
	ldi (hl),a		; $50fc
	ld (hl),OBJGFXH_1b		; $50fd
	inc l			; $50ff
	ldi (hl),a		; $5100
	xor a			; $5101
	ldi (hl),a		; $5102
	ldi (hl),a		; $5103
	ldi (hl),a		; $5104
	ldi (hl),a		; $5105
	ldi (hl),a		; $5106
	ldi (hl),a		; $5107

	; Shadow as relatedObj2
	ld bc,$0012		; $5108
	call _enemyBoss_spawnShadow		; $510b
	ld e,Enemy.relatedObj2		; $510e
	ld a,Part.start		; $5110
	ld (de),a		; $5112
	inc e			; $5113
	ld a,h			; $5114
	ld (de),a		; $5115

	call disableLcd		; $5116
	ld a,<ROOM_5f5		; $5119
	ld (wActiveRoom),a		; $511b
	ld a,$03		; $511e
	ld (wTwinrovaTileReplacementMode),a		; $5120

	call loadScreenMusicAndSetRoomPack		; $5123
	call loadAreaData		; $5126
	call loadAreaGraphics		; $5129
	call func_131f		; $512c
	call resetCamera		; $512f
	call loadCommonGraphics		; $5132

	ld a,PALH_8b		; $5135
	call loadPaletteHeader		; $5137
	ld a,PALH_b1		; $513a
	ld (wExtraBgPaletteHeader),a		; $513c
	ld a,GFXH_b0		; $513f
	call loadGfxHeader		; $5141
	ld a,$02		; $5144
	call loadGfxRegisterStateIndex		; $5146

	ldh a,(<hActiveObject)	; $5149
	ld d,a			; $514b
	call objectSetVisible83		; $514c

	jp fadeinFromWhite		; $514f


; Spawning ENEMYID_GANON_REVIVAL_CUTSCENE
_ganon_state1:
	call getFreeEnemySlot_uncounted		; $5152
	ret nz			; $5155
	ld (hl),ENEMYID_GANON_REVIVAL_CUTSCENE		; $5156
	ld l,Enemy.relatedObj1		; $5158
	ld (hl),Enemy.start		; $515a
	inc l			; $515c
	ld (hl),d		; $515d

	call _ecom_incState		; $515e
	ld l,Enemy.counter2		; $5161
	ld (hl),60		; $5163
	ret			; $5165


_ganon_state2:
	; Wait for signal?
	ld e,Enemy.counter1		; $5166
	ld a,(de)		; $5168
	or a			; $5169
	ret z			; $516a
	call _ecom_decCounter2		; $516b
	jp nz,_ecom_flickerVisibility		; $516e

	dec l			; $5171
	ld (hl),193 ; [counter1]
	ld l,Enemy.state		; $5174
	inc (hl)		; $5176
	ld a,$0d		; $5177
	call enemySetAnimation		; $5179
	jp objectSetVisible83		; $517c


; Rumbling while "skull" is on-screen
_ganon_state3:
	call _ecom_decCounter1		; $517f
	jr z,@nextState	; $5182

	ld a,(hl) ; [counter1]
	and $3f			; $5185
	ld a,SND_RUMBLE2		; $5187
	call z,playSound		; $5189
	jp enemyAnimate		; $518c

@nextState:
	ld l,e			; $518f
	inc (hl)		; $5190
	ld l,$8f		; $5191
	ld (hl),$00		; $5193
	ld a,$02		; $5195
	call objectGetRelatedObject2Var		; $5197
	ld (hl),$02		; $519a
	ld a,$01		; $519c
	jp enemySetAnimation		; $519e


; "Ball-like" animation, then ganon himself appears
_ganon_state4:
	ld e,Enemy.animParameter		; $51a1
	ld a,(de)		; $51a3
	inc a			; $51a4
	jp nz,enemyAnimate		; $51a5

	call _ecom_incState		; $51a8
	ld l,Enemy.counter1		; $51ab
	ld (hl),15		; $51ad

	ld a,GFXH_b1		; $51af
	call loadGfxHeader		; $51b1
	ld a,UNCMP_GFXH_32		; $51b4
	call loadUncompressedGfxHeader		; $51b6

	ld hl,wLoadedObjectGfx+2		; $51b9
	ld (hl),OBJGFXH_17		; $51bc
	inc l			; $51be
	ld (hl),$01		; $51bf

	ldh a,(<hActiveObject)	; $51c1
	ld d,a			; $51c3
	ld a,$02		; $51c4
	jp enemySetAnimation		; $51c6


; Brief delay
_ganon_state5:
	call _ecom_decCounter1		; $51c9
	ret nz			; $51cc

	ld a,120		; $51cd
	ld (hl),a ; [counter1]
	ld (wScreenShakeCounterY),a		; $51d0

	ld l,e			; $51d3
	inc (hl) ; [state] = 6

	ld a,SND_BOSS_DEAD	; $51d5
	call playSound		; $51d7

	ld a,$03		; $51da
	call enemySetAnimation		; $51dc

	call showStatusBar		; $51df
	ldh a,(<hActiveObject)	; $51e2
	ld d,a			; $51e4
	jp clearPaletteFadeVariablesAndRefreshPalettes		; $51e5


; "Roaring" as fight is about to begin
_ganon_state6:
	call _ecom_decCounter1		; $51e8
	jp nz,enemyAnimate		; $51eb

	ld (hl),30 ; [counter1]		; $51ee
	ld l,e			; $51f0
	inc (hl) ; [state] = 7

	ld hl,wLoadedObjectGfx+6		; $51f2
	xor a			; $51f5
	ldi (hl),a		; $51f6
	ldi (hl),a		; $51f7
	ldi (hl),a		; $51f8
	ldi (hl),a		; $51f9

	ld (wDisableLinkCollisionsAndMenu),a		; $51fa
	ld (wDisabledObjects),a		; $51fd

	ld bc,TX_2f0d		; $5200
	call showText		; $5203

	ld a,$02		; $5206
	jp enemySetAnimation		; $5208


; Fight begins
_ganon_state7:
	ld a,MUS_GANON		; $520b
	ld (wActiveMusic),a		; $520d
	call playSound		; $5210
	jp _ganon_decideNextMove		; $5213


; 3-projectile attack
_ganon_state8:
	inc e			; $5216
	ld a,(de) ; [state2]
	rst_jumpTable			; $5218
	.dw _ganon_state8_substate0
	.dw _ganon_state8_substate1
	.dw _ganon_state8_substate2
	.dw _ganon_state8_substate3
	.dw _ganon_state8_substate4
	.dw _ganon_state8_substate5
	.dw _ganon_state8_substate6
	.dw _ganon_state8_substate7

; Also used by state D
_ganon_state8_substate0:
	call _ganon_updateTeleportVarsAndPlaySound		; $5229
	ld l,Enemy.state2		; $522c
	inc (hl)		; $522e
	ret			; $522f

; Disappearing. Also used by state D
_ganon_state8_substate1:
	call _ecom_decCounter1		; $5230
	jp nz,_ganon_updateTeleportAnimationGoingOut		; $5233
	ld l,e			; $5236
	inc (hl) ; [state2]
	call _ganon_decideTeleportLocationAndCounter		; $5238
	jp objectSetInvisible		; $523b

; Delay before reappearing. Also used by state 9, C, D
_ganon_state8_substate2:
	call _ecom_decCounter1		; $523e
	ret nz			; $5241
	ld l,e			; $5242
	inc (hl) ; [state2]
	jp _ganon_updateTeleportVarsAndPlaySound		; $5244

; Reappearing.
_ganon_state8_substate3:
	call _ecom_decCounter1		; $5247
	jp nz,_ganon_updateTeleportAnimationComingIn		; $524a

	; Done teleporting, he will become solid again
	ld (hl),$08 ; [counter1]
	ld l,e			; $524f
	inc (hl) ; [state2]

	ld l,Enemy.var30		; $5251
	ld a,(hl)		; $5253
	ld l,Enemy.xh		; $5254
	ld (hl),a		; $5256

	ld l,Enemy.collisionType		; $5257
	set 7,(hl)		; $5259
	jp objectSetVisible83		; $525b

_ganon_state8_substate4:
	call _ecom_decCounter1		; $525e
	ret nz			; $5261
	ld (hl),$02		; $5262
	ld l,e			; $5264
	inc (hl) ; [state2]
	ld a,GFXH_b3		; $5266
	jp ganon_loadGfxHeader		; $5268

_ganon_state8_substate5:
	call _ecom_decCounter1		; $526b
	ret nz			; $526e
	ld (hl),45		; $526f
	ld l,e			; $5271
	inc (hl)		; $5272
	ld a,$05		; $5273
	call enemySetAnimation		; $5275
	call _ecom_updateAngleTowardTarget		; $5278
	ldbc $00,SPEED_180		; $527b
	jr _ganon_state8_spawnProjectile		; $527e

_ganon_state8_substate6:
	call _ecom_decCounter1		; $5280
	jr nz,++		; $5283
	ld (hl),60		; $5285
	ld l,e			; $5287
	inc (hl) ; [state2]
	ld a,$02		; $5289
	jp enemySetAnimation		; $528b
++
	ld a,(hl)		; $528e
	cp $19			; $528f
	ret nz			; $5291

	ldbc $02,SPEED_280		; $5292
	call _ganon_state8_spawnProjectile		; $5295

	ldbc $fe,SPEED_280		; $5298

_ganon_state8_spawnProjectile:
	ld e,PARTID_52		; $529b
	call _ganon_spawnPart		; $529d
	ret nz			; $52a0
	ld l,Part.angle		; $52a1
	ld e,Enemy.angle		; $52a3
	ld a,(de)		; $52a5
	add b			; $52a6
	and $1f			; $52a7
	ld (hl),a		; $52a9
	ld l,Part.speed		; $52aa
	ld (hl),c		; $52ac
	jp objectCopyPosition		; $52ad

_ganon_state8_substate7:
	call _ecom_decCounter1		; $52b0
	ret nz			; $52b3
	jp _ganon_finishAttack		; $52b4


; Projectile attack (4 projectiles turn into 3 smaller ones each)
_ganon_state9:
	inc e			; $52b7
	ld a,(de)		; $52b8
	rst_jumpTable			; $52b9
	.dw _ganon_state9_substate0
	.dw _ganon_state9_substate1
	.dw _ganon_state8_substate2
	.dw _ganon_state9_substate3
	.dw _ganon_state9_substate4
	.dw _ganon_state9_substate5
	.dw _ganon_state9_substate6
	.dw _ganon_state9_substate7

; Also used by state A, B, C
_ganon_state9_substate0:
	call _ganon_updateTeleportVarsAndPlaySound		; $52ca
	ld l,Enemy.state2		; $52cd
	inc (hl)		; $52cf
	ret			; $52d0

_ganon_state9_substate1:
	call _ecom_decCounter1		; $52d1
	jp nz,_ganon_updateTeleportAnimationGoingOut		; $52d4
	ld (hl),120 ; [counter1]
	ld l,e			; $52d9
	inc (hl) ; [state2]
	ld l,Enemy.yh		; $52db
	ld (hl),$58		; $52dd
	ld l,Enemy.xh		; $52df
	ld (hl),$78		; $52e1
	jp objectSetInvisible		; $52e3

_ganon_state9_substate3:
	call _ecom_decCounter1		; $52e6
	jp nz,_ganon_updateTeleportAnimationComingIn		; $52e9
	ld (hl),$08 ; [counter1]
	ld l,e			; $52ee
	inc (hl) ; [state2]
	ld l,Enemy.collisionType		; $52f0
	set 7,(hl)		; $52f2
	jp objectSetVisible83		; $52f4

_ganon_state9_substate4:
	call _ecom_decCounter1		; $52f7
	ret nz			; $52fa
	ld (hl),40 ; [counter1]
	ld l,e			; $52fd
	inc (hl) ; [state2]
	ld a,GFXH_b6		; $52ff
	call ganon_loadGfxHeader		; $5301
	ld a,$09		; $5304
	call enemySetAnimation		; $5306

	ld b,$1c		; $5309
	call @spawnProjectile		; $530b
	ld b,$14		; $530e
	call @spawnProjectile		; $5310
	ld b,$0c		; $5313
	call @spawnProjectile		; $5315
	ld b,$04		; $5318

@spawnProjectile:
	ld e,PARTID_52		; $531a
	call _ganon_spawnPart		; $531c
	ld l,Part.subid		; $531f
	inc (hl) ; [subid] = 1
	ld l,Part.angle		; $5322
	ld (hl),b		; $5324
	ld l,Part.relatedObj1+1		; $5325
	ld (hl),d		; $5327
	dec l			; $5328
	ld (hl),Enemy.start		; $5329
	jp objectCopyPosition		; $532b

_ganon_state9_substate5:
	call _ecom_decCounter1		; $532e
	ret nz			; $5331
	ld (hl),40 ; [counter1]
	ld l,e			; $5334
	inc (hl)		; $5335
	ld a,GFXH_b2		; $5336
	call ganon_loadGfxHeader		; $5338
	ld a,$07		; $533b
	jp enemySetAnimation		; $533d

_ganon_state9_substate6:
	call _ecom_decCounter1		; $5340
	ret nz			; $5343
	ld (hl),80		; $5344
	ld l,e			; $5346
	inc (hl)		; $5347
	ld a,$02		; $5348
	jp enemySetAnimation		; $534a

_ganon_state9_substate7:
	call _ecom_decCounter1		; $534d
	ret nz			; $5350
	jp _ganon_finishAttack		; $5351


; "Slash" move
_ganon_stateA:
	inc e			; $5354
	ld a,(de) ; [state2]
	rst_jumpTable			; $5356
	.dw _ganon_state9_substate0
	.dw _ganon_stateA_substate1
	.dw _ganon_stateA_substate2
	.dw _ganon_stateA_substate3
	.dw _ganon_stateA_substate4
	.dw _ganon_stateA_substate5
	.dw _ganon_stateA_substate6
	.dw _ganon_stateA_substate7

; Teleporting out
_ganon_stateA_substate1:
	call _ecom_decCounter1		; $5367
	jp nz,_ganon_updateTeleportAnimationGoingOut		; $536a

	ld (hl),120		; $536d
	ld l,e			; $536f
	inc (hl) ; [state2]
	jp objectSetInvisible		; $5371

; Delay before reappearing
_ganon_stateA_substate2:
	call _ecom_decCounter1		; $5374
	ret nz			; $5377

	ld l,e			; $5378
	inc (hl) ; [state2]

	ldh a,(<hEnemyTargetX)	; $537a
	cp (LARGE_ROOM_WIDTH<<4)/2			; $537c
	ldbc $03,$28		; $537e
	jr c,+			; $5381
	ldbc $00,-$28		; $5383
+
	ld l,Enemy.var32		; $5386
	ld (hl),b		; $5388
	add c			; $5389
	ld l,Enemy.xh		; $538a
	ldd (hl),a		; $538c
	ldh a,(<hEnemyTargetY)	; $538d
	cp $30			; $538f
	jr c,+			; $5391
	sub $18			; $5393
+
	dec l			; $5395
	ld (hl),a ; [yh]

	ld a,GFXH_b2		; $5397
	call ganon_loadGfxHeader		; $5399
	ld e,Enemy.var32		; $539c
	ld a,(de)		; $539e
	add $07			; $539f
	call enemySetAnimation		; $53a1
	jp _ganon_updateTeleportVarsAndPlaySound		; $53a4

_ganon_stateA_substate3:
	call _ecom_decCounter1		; $53a7
	jp nz,_ganon_updateTeleportAnimationComingIn		; $53aa
	ld (hl),$02		; $53ad
	ld l,e			; $53af
	inc (hl) ; [state2]
	ld l,Enemy.collisionType		; $53b1
	set 7,(hl)		; $53b3
	ld l,Enemy.speed		; $53b5
	ld (hl),SPEED_300		; $53b7
	call _ecom_updateAngleTowardTarget		; $53b9
	ld e,PARTID_50		; $53bc
	call _ganon_spawnPart		; $53be
	jp objectSetVisible83		; $53c1

_ganon_stateA_substate4:
	call _ecom_decCounter1		; $53c4
	ret nz			; $53c7
	ld (hl),$04		; $53c8
	ld l,e			; $53ca
	inc (hl) ; [state2]
	ld a,Enemy.var37		; $53cc
	call ganon_loadGfxHeader		; $53ce
	ld e,Enemy.var32		; $53d1
	ld a,(de)		; $53d3
	add $08			; $53d4
	call enemySetAnimation		; $53d6

_ganon_stateA_substate5:
	call _ecom_decCounter1		; $53d9
	jr nz,+++		; $53dc
	ld (hl),16		; $53de
	ld l,e			; $53e0
	inc (hl) ; [state2]
	ld a,GFXH_b6		; $53e2
	call ganon_loadGfxHeader		; $53e4
	ld e,Enemy.var32		; $53e7
	ld a,(de)		; $53e9
	add $09			; $53ea
	jp enemySetAnimation		; $53ec

_ganon_stateA_substate6:
	call _ecom_decCounter1		; $53ef
	jr nz,+++		; $53f2
	ld l,e			; $53f4
	inc (hl) ; [state2]
	inc l			; $53f6
	ld (hl),30 ; [counter1]
	ret			; $53f9
+++
	ld e,Enemy.yh		; $53fa
	ld a,(de)		; $53fc
	sub $18			; $53fd
	cp $80			; $53ff
	ret nc			; $5401
	ld e,Enemy.xh		; $5402
	ld a,(de)		; $5404
	sub $18			; $5405
	cp $c0			; $5407
	ret nc			; $5409
	jp objectApplySpeed		; $540a

_ganon_stateA_substate7:
	call _ecom_decCounter1		; $540d
	ret nz			; $5410
	ld a,$02		; $5411
	call enemySetAnimation		; $5413
	jp _ganon_finishAttack		; $5416


; The attack with the big exploding ball
_ganon_stateB:
	inc e			; $5419
	ld a,(de)		; $541a
	rst_jumpTable			; $541b
	.dw _ganon_state9_substate0
	.dw _ganon_stateB_substate1
	.dw _ganon_stateB_substate2
	.dw _ganon_stateB_substate3
	.dw _ganon_stateB_substate4
	.dw _ganon_stateB_substate5
	.dw _ganon_stateB_substate6
	.dw _ganon_stateB_substate7
	.dw _ganon_stateB_substate8
	.dw _ganon_stateB_substate9
	.dw _ganon_stateB_substateA

_ganon_stateB_substate1:
	call _ecom_decCounter1		; $5432
	jp nz,_ganon_updateTeleportAnimationGoingOut		; $5435
	ld (hl),180		; $5438
	ld l,e			; $543a
	inc (hl) ; [state2]
	jp objectSetInvisible		; $543c

_ganon_stateB_substate2:
	call _ecom_decCounter1		; $543f
	ret nz			; $5442
	ld l,e			; $5443
	inc (hl) ; [state2]
	ld l,Enemy.yh		; $5445
	ld (hl),$28		; $5447
	ld l,Enemy.xh		; $5449
	ld (hl),$78		; $544b
	ld a,GFXH_b2		; $544d
	call ganon_loadGfxHeader		; $544f
	ld a,$04		; $5452
	call enemySetAnimation		; $5454
	jp _ganon_updateTeleportVarsAndPlaySound		; $5457

_ganon_stateB_substate3:
	call _ecom_decCounter1		; $545a
	jp nz,_ganon_updateTeleportAnimationComingIn		; $545d
	ld (hl),$40 ; [counter1]
	ld l,e			; $5462
	inc (hl) ; [state2]
	ld l,Enemy.collisionType		; $5464
	set 7,(hl)		; $5466
	call objectSetVisible83		; $5468
	ld e,PARTID_51		; $546b
	call _ganon_spawnPart		; $546d
	ret nz			; $5470
	ld bc,$f810		; $5471
	jp objectCopyPositionWithOffset		; $5474

_ganon_stateB_substate4:
	call _ecom_decCounter1		; $5477
	ret nz			; $547a
	ld l,e			; $547b
	inc (hl) ; [state2]
	ld l,Enemy.speedZ		; $547d
	ld a,<(-$1c0)		; $547f
	ldi (hl),a		; $5481
	ld (hl),>(-$1c0)		; $5482
	ld a,GFXH_b3		; $5484
	call ganon_loadGfxHeader		; $5486
	ld a,$05		; $5489
	jp enemySetAnimation		; $548b

_ganon_stateB_substate5:
	ld c,$20		; $548e
	call objectUpdateSpeedZ_paramC		; $5490
	jr z,++			; $5493
	ldd a,(hl)		; $5495
	or a			; $5496
	ret nz			; $5497
	ld a,(hl)		; $5498
	cp $c0			; $5499
	ret nz			; $549b
	ld a,GFXH_b5		; $549c
	call ganon_loadGfxHeader		; $549e
	ld a,$06		; $54a1
	jp enemySetAnimation		; $54a3
++
	ld l,Enemy.counter1		; $54a6
	ld a,120		; $54a8
	ld (hl),a		; $54aa
	ld (wScreenShakeCounterY),a		; $54ab
	ld l,Enemy.state2		; $54ae
	inc (hl)		; $54b0
	ld a,SND_EXPLOSION		; $54b1
	jp playSound		; $54b3

_ganon_stateB_substate6:
	call _ecom_decCounter1		; $54b6
	jr z,++			; $54b9
	ld a,(hl)		; $54bb
	cp 105			; $54bc
	ret c			; $54be
	ld a,(w1Link.zh)		; $54bf
	rlca			; $54c2
	ret c			; $54c3
	ld hl,wLinkForceState		; $54c4
	ld a,LINK_STATE_COLLAPSED		; $54c7
	ldi (hl),a		; $54c9
	ld (hl),$00 ; [wcc50]
	ret			; $54cc
++
	ld (hl),$04		; $54cd
	ld l,e			; $54cf
	inc (hl)		; $54d0
	ld a,GFXH_b2		; $54d1
	call ganon_loadGfxHeader		; $54d3
	ld a,$04		; $54d6
	jp enemySetAnimation		; $54d8

_ganon_stateB_substate7:
	call _ecom_decCounter1		; $54db
	ret nz			; $54de
	ld (hl),24 ; [counter1]
	ld l,e			; $54e1
	inc (hl) ; [state2]
	ld e,PARTID_51		; $54e3
	call _ganon_spawnPart		; $54e5
	ret nz			; $54e8
	ld l,Part.subid		; $54e9
	inc (hl)		; $54eb
	ld bc,$f810		; $54ec
	jp objectCopyPositionWithOffset		; $54ef

_ganon_stateB_substate8:
	call _ecom_decCounter1		; $54f2
	ret nz			; $54f5
	ld (hl),60		; $54f6
	ld l,e			; $54f8
	inc (hl) ; [state2]
	call objectCreatePuff		; $54fa
	ld a,GFXH_b3		; $54fd
	call ganon_loadGfxHeader		; $54ff
	ld a,$05		; $5502
	jp enemySetAnimation		; $5504

_ganon_stateB_substate9:
	call _ecom_decCounter1		; $5507
	ret nz			; $550a
	ld (hl),60		; $550b
	ld l,e			; $550d
	inc (hl)		; $550e
	ld a,$02		; $550f
	jp enemySetAnimation		; $5511

_ganon_stateB_substateA:
	call _ecom_decCounter1		; $5514
	ret nz			; $5517
	jp _ganon_finishAttack		; $5518


; Inverted controls
_ganon_stateC:
	inc e			; $551b
	ld a,(de)		; $551c
	rst_jumpTable			; $551d
	.dw _ganon_state9_substate0
	.dw _ganon_stateC_substate1
	.dw _ganon_state8_substate2
	.dw _ganon_stateC_substate3
	.dw _ganon_stateC_substate4
	.dw _ganon_stateC_substate5
	.dw _ganon_stateC_substate6
	.dw _ganon_stateC_substate7
	.dw _ganon_stateC_substate8
	.dw _ganon_stateC_substate9
	.dw _ganon_stateC_substateA

_ganon_stateC_substate1:
	call _ecom_decCounter1		; $5534
	jp nz,_ganon_updateTeleportAnimationGoingOut		; $5537
	ld (hl),90 ; [counter1]
	ld l,e			; $553c
	inc (hl) ; [state2]
	ld l,Enemy.yh		; $553e
	ld (hl),$58		; $5540
	ld l,Enemy.xh		; $5542
	ld (hl),$78		; $5544
	jp objectSetInvisible		; $5546

_ganon_stateC_substate3:
	call _ecom_decCounter1		; $5549
	jp nz,_ganon_updateTeleportAnimationComingIn		; $554c
	ld (hl),90 ; [counter1]
	ld l,e			; $5551
	inc (hl) ; [state2]
	ld l,Enemy.collisionType		; $5553
	set 7,(hl)		; $5555
	call objectSetVisible83		; $5557
	ld a,SND_FADEOUT		; $555a
	jp playSound		; $555c

_ganon_stateC_substate4:
	call _ecom_decCounter1		; $555f
	jr z,@nextSubstate	; $5562
	ld a,(hl) ; [counter1]
	cp 60			; $5565
	ret nc			; $5567

	and $03			; $5568
	ret nz			; $556a
	ld l,Enemy.oamFlagsBackup		; $556b
	ld a,(hl)		; $556d
	xor $05			; $556e
	ldi (hl),a		; $5570
	ld (hl),a		; $5571
	ret			; $5572

@nextSubstate:
	ld l,Enemy.health		; $5573
	ld a,(hl)		; $5575
	or a			; $5576
	ret z			; $5577

	ld l,e			; $5578
	inc (hl) ; [state2]
	ld l,Enemy.collisionType		; $557a
	res 7,(hl)		; $557c
	ld l,Enemy.oamFlagsBackup		; $557e
	ld a,$01		; $5580
	ldi (hl),a		; $5582
	ld (hl),a		; $5583
	ld a,$02		; $5584
	jp fadeoutToBlackWithDelay		; $5586

_ganon_stateC_substate5:
	ld a,(wPaletteThread_mode)		; $5589
	or a			; $558c
	ret nz			; $558d
	ld a,$06		; $558e
	ld (de),a ; [state2]
	ld a,$04		; $5591
	call _ganon_setTileReplacementMode		; $5593
	jp _ganon_makeRoomBoundarySolid		; $5596

_ganon_stateC_substate6:
	ld h,d			; $5599
	ld l,e			; $559a
	inc (hl) ; [state2]
	inc l			; $559c
	ld (hl),60 ; [counter1]

	ld l,Enemy.collisionType		; $559f
	set 7,(hl)		; $55a1
	ld l,Enemy.speed		; $55a3
	ld (hl),SPEED_80		; $55a5

	call getRandomNumber_noPreserveVars		; $55a7
	and $07			; $55aa
	ld hl,@counter2Vals		; $55ac
	rst_addAToHl			; $55af
	ld e,Enemy.counter2		; $55b0
	ld a,(hl)		; $55b2
	ld (de),a		; $55b3
	jp fadeinFromBlack		; $55b4

@counter2Vals:
	.db 50,80,80,90,90,90,90,150

_ganon_stateC_substate7:
	ld a,$02		; $55bf
	ld (wUseSimulatedInput),a		; $55c1
	ld a,(wFrameCounter)		; $55c4
	and $03			; $55c7
	jr nz,++		; $55c9
	call _ecom_decCounter2		; $55cb
	jr nz,++		; $55ce

	ld l,Enemy.state2		; $55d0
	inc (hl)		; $55d2
	inc (hl) ; [state2] = 9
	ld l,Enemy.collisionType		; $55d4
	res 7,(hl)		; $55d6
	jp fastFadeoutToWhite		; $55d8
++
	call _ecom_decCounter1		; $55db
	jr nz,++		; $55de
	ld l,e			; $55e0
	inc (hl) ; [state2] = 8
	ld l,Enemy.counter1		; $55e2
	ld (hl),80		; $55e4
	ld a,GFXH_b3		; $55e6
	jp ganon_loadGfxHeader		; $55e8
++
	call _ecom_updateAngleTowardTarget		; $55eb
	call _ecom_applyVelocityForSideviewEnemyNoHoles		; $55ee
	call enemyAnimate		; $55f1
	jp _ganon_updateSeizurePalette		; $55f4

_ganon_stateC_substate8:
	ld a,$02		; $55f7
	ld (wUseSimulatedInput),a		; $55f9
	call _ganon_updateSeizurePalette		; $55fc

	ld a,(wFrameCounter)		; $55ff
	and $03			; $5602
	call z,_ecom_decCounter2		; $5604
	call _ecom_decCounter1		; $5607
	jr z,@nextSubstate	; $560a

	ld a,(hl) ; [counter1]
	cp 60			; $560d
	ret nz			; $560f

	ld a,$05		; $5610
	call enemySetAnimation		; $5612
	ld e,PARTID_52		; $5615
	call _ganon_spawnPart		; $5617
	ret nz			; $561a
	ld l,Part.subid		; $561b
	ld (hl),$02		; $561d
	jp objectCopyPosition		; $561f

@nextSubstate:
	ld l,Enemy.state2		; $5622
	dec (hl)		; $5624
	inc l			; $5625
	ld (hl),60		; $5626
	ld a,$02		; $5628
	jp enemySetAnimation		; $562a

_ganon_stateC_substate9:
	ld a,(wPaletteThread_mode)		; $562d
	or a			; $5630
	ret nz			; $5631
	ld a,$0a		; $5632
	ld (de),a ; [state2]
	ld a,$03		; $5635
	call _ganon_setTileReplacementMode		; $5637
	ld a,PALH_b1		; $563a
	ld (wExtraBgPaletteHeader),a		; $563c
	jp loadPaletteHeader		; $563f

_ganon_stateC_substateA:
	ld h,d			; $5642
	ld l,Enemy.collisionType		; $5643
	set 7,(hl)		; $5645
	call clearPaletteFadeVariablesAndRefreshPalettes		; $5647
	jp _ganon_finishAttack		; $564a


; Teleports in an out without doing anything
_ganon_stateD:
	inc e			; $564d
	ld a,(de)		; $564e
	rst_jumpTable			; $564f
	.dw _ganon_state8_substate0
	.dw _ganon_state8_substate1
	.dw _ganon_state8_substate2
	.dw _ganon_stateD_substate3
	.dw _ganon_finishAttack

_ganon_stateD_substate3:
	call _ecom_decCounter1		; $565a
	jp nz,_ganon_updateTeleportAnimationComingIn		; $565d
	ld l,e			; $5660
	inc (hl) ; [state2]
	ld l,Enemy.var30		; $5662
	ld a,(hl)		; $5664
	ld l,Enemy.xh		; $5665
	ld (hl),a		; $5667
	jp objectSetVisible83		; $5668


; Just died
_ganon_stateE:
	inc e			; $566b
	ld a,(de) ; [state2]
	rst_jumpTable			; $566d
	.dw _ganon_stateE_substate0
	.dw _ganon_stateE_substate1
	.dw _ganon_stateE_substate2
	.dw _ganon_stateE_substate3

_ganon_stateE_substate0:
	call _ecom_decCounter1		; $5676
	jp nz,_ecom_flickerVisibility		; $5679

	inc (hl)		; $567c
	ld e,PARTID_04		; $567d
	call _ganon_spawnPart		; $567f
	ret nz			; $5682
	ld l,Part.subid		; $5683
	inc (hl) ; [subid] = 1
	call objectCopyPosition		; $5686
	ld e,Enemy.relatedObj2		; $5689
	ld a,Part.start		; $568b
	ld (de),a		; $568d
	inc e			; $568e
	ld a,h			; $568f
	ld (de),a		; $5690
	ld hl,wNumEnemies		; $5691
	inc (hl)		; $5694

	ld h,d			; $5695
	ld l,Enemy.state2		; $5696
	inc (hl)		; $5698
	ld l,Enemy.zh		; $5699
	ld (hl),$00		; $569b

	call objectSetInvisible		; $569d
	ld a,SND_BIG_EXPLOSION_2		; $56a0
	jp playSound		; $56a2

_ganon_stateE_substate1:
	ld a,Object.animParameter		; $56a5
	call objectGetRelatedObject2Var		; $56a7
	bit 7,(hl)		; $56aa
	ret z			; $56ac
	ld h,d			; $56ad
	ld l,Enemy.state2		; $56ae
	inc (hl)		; $56b0
	inc l			; $56b1
	ld (hl),$08 ; [counter1]
	jp fastFadeoutToWhite		; $56b4

_ganon_stateE_substate2:
	call _ecom_decCounter1		; $56b7
	ret nz			; $56ba
	ld (hl),30 ; [counter1]
	ld l,e			; $56bd
	inc (hl) ; [state2]
	xor a			; $56bf
	ld (wExtraBgPaletteHeader),a		; $56c0
	call _ganon_setTileReplacementMode		; $56c3
	ld a,$02		; $56c6
	jp fadeinFromWhiteWithDelay		; $56c8

_ganon_stateE_substate3:
	ld a,(wPaletteThread_mode)		; $56cb
	or a			; $56ce
	ret nz			; $56cf
	call _ecom_decCounter1		; $56d0
	ret nz			; $56d3
	xor a			; $56d4
	ld (wDisableLinkCollisionsAndMenu),a		; $56d5
	call decNumEnemies		; $56d8
	jp enemyDelete		; $56db

;;
; @addr{56de}
ganon_loadGfxHeader:
	push af			; $56de
	call loadGfxHeader		; $56df
	ld a,UNCMP_GFXH_33		; $56e2
	call loadUncompressedGfxHeader		; $56e4
	pop af			; $56e7
	sub GFXH_b2			; $56e8
	add OBJGFXH_1e			; $56ea
	ld hl,wLoadedObjectGfx+4		; $56ec
	ldi (hl),a		; $56ef
	ld (hl),$01		; $56f0
	ldh a,(<hActiveObject)	; $56f2
	ld d,a			; $56f4
	ret			; $56f5

;;
; X-position alternates left & right each frame while teleporting.
;
; @param	hl	counter1?
; @addr{56f6}
_ganon_updateTeleportAnimationGoingOut:
	ld a,(hl)		; $56f6
	and $3e			; $56f7
	rrca			; $56f9
	ld b,a			; $56fa
	ld a,$20		; $56fb
	sub b			; $56fd

_ganon_updateFlickeringXPosition:
	bit 1,(hl)		; $56fe
	jr z,+			; $5700
	cpl			; $5702
	inc a			; $5703
+
	ld l,Enemy.var30		; $5704
	add (hl)		; $5706
	ld l,Enemy.xh		; $5707
	ld (hl),a		; $5709
	jp _ecom_flickerVisibility		; $570a

;;
; @addr{570d}
_ganon_updateTeleportVarsAndPlaySound:
	ld a,SND_TELEPORT		; $570d
	call playSound		; $570f

	ld h,d			; $5712
	ld l,Enemy.collisionType		; $5713
	res 7,(hl)		; $5715

	ld l,Enemy.counter1		; $5717
	ld (hl),60		; $5719
	ld l,Enemy.xh		; $571b
	ld a,(hl)		; $571d
	ld l,Enemy.var30		; $571e
	ld (hl),a		; $5720
	ret			; $5721

;;
; @param	hl	counter1?
; @addr{5722}
_ganon_updateTeleportAnimationComingIn:
	ld a,(hl)		; $5722
	and $3e			; $5723
	rrca			; $5725
	jr _ganon_updateFlickeringXPosition		; $5726

;;
; @addr{5728}
_ganon_finishAttack:
	ld h,d			; $5728
	ld l,Enemy.var35		; $5729
	ldi a,(hl)		; $572b
	ld h,(hl)		; $572c
	ld l,a			; $572d
	ldi a,(hl)		; $572e
	or a			; $572f
	jr z,_ganon_decideNextMove	; $5730

_label_10_135:
	ld e,Enemy.state		; $5732
	ld (de),a		; $5734
	inc e			; $5735
	xor a			; $5736
	ld (de),a ; [state2]
	ld e,Enemy.var35		; $5738
	ld a,l			; $573a
	ld (de),a		; $573b
	inc e			; $573c
	ld a,h			; $573d
	ld (de),a		; $573e
	ret			; $573f


;;
; Sets state to something randomly?
; @addr{5740}
_ganon_decideNextMove:
	ld e,Enemy.health		; $5740
	ld a,(de)		; $5742
	cp $41			; $5743
	ld c,$00		; $5745
	jr nc,+			; $5747
	ld c,$04		; $5749
+
	call getRandomNumber		; $574b
	and $03			; $574e
	add c			; $5750
	ld hl,@stateTable		; $5751
	rst_addDoubleIndex			; $5754
	ldi a,(hl)		; $5755
	ld h,(hl)		; $5756
	ld l,a			; $5757
	ldi a,(hl)		; $5758
	jr _label_10_135		; $5759

@stateTable:
	.dw @choice0
	.dw @choice1
	.dw @choice2
	.dw @choice3
	.dw @choice4
	.dw @choice5
	.dw @choice6
	.dw @choice7

; This is a list of states (attack parts) to iterate through. When it reaches the 0 terminator, it
; calls the above function again to make a new choice.
;
; 0-3 are for Ganon at high health.
@choice0:
        .db $08 $0a $09
	.db $00
@choice1:
        .db $09
	.db $00
@choice2:
        .db $0a $08 $09 $0a
        .db $00
@choice3:
        .db $0a $08
        .db $00

; 4-7 are for Ganon at low health.
@choice4:
        .db $0c
	.db $00
@choice5:
        .db $0b $0d $08 $0a
        .db $00
@choice6:
        .db $0b $0c $09 $0a
        .db $00
@choice7:
        .db $0d
	.db $00


;;
; @addr{5787}
_ganon_decideTeleportLocationAndCounter:
	ld bc,$0e0f		; $5787
	call _ecom_randomBitwiseAndBCE		; $578a
	ld a,b			; $578d
	ld hl,@teleportTargetTable		; $578e
	rst_addAToHl			; $5791
	ld e,Enemy.yh		; $5792
	ldi a,(hl)		; $5794
	ld (de),a		; $5795
	ld e,Enemy.xh		; $5796
	ld a,(hl)		; $5798
	ld (de),a		; $5799

	ld a,c			; $579a
	ld hl,@counter1Vals		; $579b
	rst_addAToHl			; $579e
	ld e,Enemy.counter1		; $579f
	ld a,(hl)		; $57a1
	ld (de),a		; $57a2
	ret			; $57a3

; List of valid positions to teleport to
@teleportTargetTable:
	.db $30 $38
	.db $30 $78
	.db $30 $b8
	.db $58 $58
	.db $58 $98
	.db $80 $38
	.db $80 $78
	.db $80 $b8

@counter1Vals:
	.db 40 40 40 60 60 60 60 60
	.db 60 90 90 90 90 90 120 120


;;
; @param	e	Part ID
; @addr{57c4}
_ganon_spawnPart:
	call getFreePartSlot		; $57c4
	ret nz			; $57c7
	ld (hl),e		; $57c8
	ld l,Part.relatedObj1		; $57c9
	ld (hl),Enemy.start		; $57cb
	inc l			; $57cd
	ld (hl),d		; $57ce
	xor a			; $57cf
	ret			; $57d0

;;
; Sets the boundaries of the room to be solid when "reversed controls" happen; most likely because
; the wall tiles are removed when in this state, so collisions must be set manually.
; @addr{57d1}
_ganon_makeRoomBoundarySolid:
	ld hl,wRoomCollisions+$10		; $57d1
	ld b,LARGE_ROOM_HEIGHT-2		; $57d4
--
	ld (hl),$0f		; $57d6
	ld a,l			; $57d8
	add $10			; $57d9
	ld l,a			; $57db
	dec b			; $57dc
	jr nz,--

	ld l,$0f + LARGE_ROOM_WIDTH		; $57df
	ld b,LARGE_ROOM_HEIGHT-2		; $57e1
--
	ld (hl),$0f		; $57e3
	ld a,l			; $57e5
	add $10			; $57e6
	ld l,a			; $57e8
	dec b			; $57e9
	jr nz,--

	ld l,$00		; $57ec
	ld a,$0f		; $57ee
	ld b,a ; LARGE_ROOM_WIDTH
--
	ldi (hl),a		; $57f1
	dec b			; $57f2
	jr nz,--

	ld l,(LARGE_ROOM_HEIGHT-1)<<4		; $57f5
	ld b,a			; $57f7
--
	ldi (hl),a		; $57f8
	dec b			; $57f9
	jr nz,--		; $57fa
	ret			; $57fc

;;
; Updates palettes in reversed-control mode
; @addr{57fd}
_ganon_updateSeizurePalette:
	ld a,(wScrollMode)		; $57fd
	and $01			; $5800
	ret z			; $5802
	ld a,(wPaletteThread_mode)		; $5803
	or a			; $5806
	ret nz			; $5807
	ld a,(wFrameCounter)		; $5808
	rrca			; $580b
	ret c			; $580c
	ld h,d			; $580d
	ld l,$b7		; $580e
	ld a,(hl)		; $5810
	inc (hl)		; $5811
	and $07			; $5812
	add PALH_b1			; $5814
	ld (wExtraBgPaletteHeader),a		; $5816
	jp loadPaletteHeader		; $5819


;;
; @addr{581c}
_ganon_setTileReplacementMode:
	ld (wTwinrovaTileReplacementMode),a		; $581c
	call func_131f		; $581f
	ldh a,(<hActiveObject)	; $5822
	ld d,a			; $5824
	ret			; $5825

;;
; @addr{5826}
enemyCode00:
	ret			; $5826


; ==============================================================================
; ENEMYID_VERAN_FINAL_FORM
;
; Variables:
;   subid: 0 - turtle, 1 - spider, 2 - bee
;   var03: Attack type (for spider form); 0 - rush, 1 - jump, 2 - grab
;   var30: Current health for turtle form (saved here while in other forms)
;   var31: Spider form max health
;   var32: Bee form max health
;   var33: Nonzero if turtle form has been attacked (will transform)
;   var34: Number of times turtle has jumped (when var33 is nonzero)
;   var35: Used for deciding transformations. Value from 0-7.
;   var36/var37: Target position to move towards
;   var38: Used as a signal by "web" objects?
;   var39: Bee form: quadrant the bee entered the screen from
; ==============================================================================
enemyCode02:
	jr z,@normalStatus	; $5827
	sub ENEMYSTATUS_NO_HEALTH			; $5829
	ret c			; $582b
	jr z,@dead	; $582c
	dec a			; $582e
	jr z,@justHit	; $582f

	; ENEMYSTATUS_KNOCKBACK
	ld c,$20		; $5831
	call objectUpdateSpeedZ_paramC		; $5833
	jp _ecom_updateKnockback		; $5836

@justHit:
	ld h,d			; $5839
	ld l,Enemy.subid		; $583a
	ld a,(hl)		; $583c
	or a			; $583d
	jr nz,@notTurtleForm	; $583e

	ld l,Enemy.invincibilityCounter		; $5840
	ld a,(hl)		; $5842
	or a			; $5843
	jr z,@normalStatus	; $5844

	; Note that turtle veran's been hit and should transform soon
	ld l,Enemy.var33		; $5846
	ld (hl),$01		; $5848
	jr @normalStatus		; $584a

@notTurtleForm:
	ld l,Enemy.knockbackCounter		; $584c
	ld a,(hl)		; $584e
	or a			; $584f
	jr z,@normalStatus	; $5850

	; Only spider form takes knockback
	ld l,Enemy.state		; $5852
	ld (hl),$03		; $5854
	ld l,Enemy.counter1		; $5856
	ld (hl),105		; $5858
	ld l,Enemy.enemyCollisionMode		; $585a
	ld (hl),ENEMYCOLLISION_VERAN_SPIDER_FORM_VULNERABLE		; $585c

	ld a,(w1Link.state)		; $585e
	cp LINK_STATE_GRABBED			; $5861
	call z,_veranFinal_grabbingLink		; $5863

	ld a,$06		; $5866
	jp enemySetAnimation		; $5868

@dead:
	call _veranFinal_dead		; $586b

@normalStatus:
	ld e,Enemy.subid		; $586e
	ld a,(de)		; $5870
	ld e,Enemy.state		; $5871
	rst_jumpTable			; $5873
	.dw _veranFinal_turtleForm
	.dw _veranFinal_spiderForm
	.dw _veranFinal_beeForm


_veranFinal_turtleForm:
	ld a,(de)		; $587a
	rst_jumpTable			; $587b
	.dw _veranFinal_turtleForm_state0
	.dw _veranFinal_turtleForm_state1
	.dw _veranFinal_turtleForm_state2
	.dw _veranFinal_turtleForm_state3
	.dw _veranFinal_turtleForm_state4
	.dw _veranFinal_turtleForm_state5
	.dw _veranFinal_turtleForm_state6
	.dw _veranFinal_turtleForm_state7
	.dw _veranFinal_turtleForm_state8
	.dw _veranFinal_turtleForm_state9
	.dw _veranFinal_turtleForm_stateA


_veranFinal_turtleForm_state0:
	ld a,$02		; $5892
	ld (wEnemyIDToLoadExtraGfx),a		; $5894
	ld a,PALH_87		; $5897
	call loadPaletteHeader		; $5899
	ld a,SNDCTRL_STOPMUSIC		; $589c
	call playSound		; $589e
	ld a,$01		; $58a1
	ld (wDisabledObjects),a		; $58a3
	ld (wMenuDisabled),a		; $58a6

	ld bc,$0208		; $58a9
	call _enemyBoss_spawnShadow		; $58ac
	ret nz			; $58af
	call _ecom_incState		; $58b0

	call checkIsLinkedGame		; $58b3
	ld l,Enemy.health		; $58b6
	ld a,(hl)		; $58b8
	ld bc,$0c18		; $58b9
	jr nz,++		; $58bc

	; Unlinked: less health (for all forms)
	ld a,$14		; $58be
	ld (hl),a		; $58c0
	ld bc,$080f		; $58c1
++
	ld l,Enemy.var30		; $58c4
	ldi (hl),a		; $58c6
	ld (hl),b ; [var31]
	inc l			; $58c8
	ld (hl),c ; [var32]
	jp objectSetVisible83		; $58ca


; Showing text before fight starts
_veranFinal_turtleForm_state1:
	inc e			; $58cd
	ld a,(de) ; [state2]
	rst_jumpTable			; $58cf
	.dw @substate0
	.dw @substate1
	.dw @substate2

@substate0:
	ld a,(wPaletteThread_mode)		; $58d6
	or a			; $58d9
	ret nz			; $58da
	ld a,SND_LIGHTNING		; $58db
	call playSound		; $58dd
	ld bc,TX_5614		; $58e0
	call showText		; $58e3
	jp _ecom_incState2		; $58e6

@substate1:
	ld h,d			; $58e9
	ld l,e			; $58ea
	inc (hl) ; [state2]
	xor a			; $58ec
	ld (wDisabledObjects),a		; $58ed
	ld (wMenuDisabled),a		; $58f0
	ld a,$03		; $58f3
	call enemySetAnimation		; $58f5
	ld a,MUS_FINAL_BOSS		; $58f8
	ld (wActiveMusic),a		; $58fa
	jp playSound		; $58fd

@substate2:
	call enemyAnimate		; $5900
	ld e,Enemy.animParameter		; $5903
	ld a,(de)		; $5905
	inc a			; $5906
	ret nz			; $5907
	call _ecom_incState		; $5908
	ld l,Enemy.counter1		; $590b
	ld (hl),30		; $590d
	ld l,Enemy.speed		; $590f
	ld (hl),SPEED_1c0		; $5911
	inc a			; $5913
	jp enemySetAnimation		; $5914


; About to jump
_veranFinal_turtleForm_state2:
	ld e,Enemy.animParameter		; $5917
	ld a,(de)		; $5919
	or a			; $591a
	jp nz,enemyAnimate		; $591b

	call _ecom_decCounter1		; $591e
	ret nz			; $5921
	ld l,Enemy.state		; $5922
	inc (hl)		; $5924
	ld l,Enemy.speedZ		; $5925
	ld (hl),<(-$400)		; $5927
	inc l			; $5929
	ld (hl),>(-$400)		; $592a
	call _ecom_updateAngleTowardTarget		; $592c
	call objectSetVisible81		; $592f
	ld a,SND_UNKNOWN4		; $5932
	call playSound		; $5934
	ld a,$02		; $5937
	jp enemySetAnimation		; $5939


; Jumping (until starts moving down)
_veranFinal_turtleForm_state3:
	ld c,$20		; $593c
	call objectUpdateSpeedZ_paramC		; $593e
	ldd a,(hl)		; $5941
	or (hl)			; $5942
	jp nz,_ecom_applyVelocityForTopDownEnemyNoHoles		; $5943

	inc l			; $5946
	inc (hl) ; [speedZ] = $0100

	ld l,Enemy.state		; $5948
	inc (hl)		; $594a
	ld l,Enemy.speed		; $594b
	ld (hl),SPEED_300		; $594d
	ld l,Enemy.var36		; $594f
	ldh a,(<hEnemyTargetY)	; $5951
	and $f0			; $5953
	add $08			; $5955
	ldi (hl),a		; $5957
	ldh a,(<hEnemyTargetX)	; $5958
	and $f0			; $595a
	add $08			; $595c
	ld (hl),a ; [var37]
	ld a,$01		; $595f
	jp enemySetAnimation		; $5961


; Falling and homing in on a position
_veranFinal_turtleForm_state4:
	ld c,$10		; $5964
	call objectUpdateSpeedZ_paramC		; $5966
	jr z,@nextState	; $5969
	call _veranFinal_moveTowardTargetPosition		; $596b
	ret nc			; $596e
	ld l,Enemy.yh		; $596f
	ld (hl),b		; $5971
	ld l,Enemy.xh		; $5972
	ld (hl),c		; $5974
	ret			; $5975

@nextState:
	ld a,$10		; $5976
	call setScreenShakeCounter		; $5978
	call _ecom_incState		; $597b
	ld l,Enemy.counter1		; $597e
	ld (hl),$0c		; $5980
	call objectSetVisible83		; $5982
	ld a,SND_POOF		; $5985
	call playSound		; $5987
	ld b,PARTID_57		; $598a
	jp _ecom_spawnProjectile		; $598c


; Landed
_veranFinal_turtleForm_state5:
	call _ecom_decCounter1		; $598f
	ret nz			; $5992

	ld l,Enemy.speed		; $5993
	ld (hl),SPEED_1c0		; $5995
	ld l,Enemy.var33		; $5997
	bit 0,(hl)		; $5999
	ld l,Enemy.var34		; $599b
	jr z,+			; $599d
	inc (hl)		; $599f
+
	ld a,(hl)		; $59a0
	ld bc,@transformProbabilities		; $59a1
	call addAToBc		; $59a4
	ld a,(bc)		; $59a7
	ld b,a			; $59a8
	inc a			; $59a9
	ld l,e			; $59aa
	jr z,++			; $59ab

	call getRandomNumber		; $59ad
	and b			; $59b0
	jp z,_veranFinal_transformToBeeOrSpider		; $59b1

	ld e,Enemy.var33		; $59b4
	ld a,(de)		; $59b6
	rrca			; $59b7
	jr c,@jumpAgain		; $59b8
++
	call getRandomNumber		; $59ba
	cp 90			; $59bd
	jr nc,@jumpAgain		; $59bf

	; Open face
	inc (hl) ; [state2] = $06
	ld l,Enemy.counter1		; $59c2
	ld (hl),$08		; $59c4
	ld a,SND_GORON		; $59c6
	call playSound		; $59c8
	ld a,$04		; $59cb
	jp enemySetAnimation		; $59cd

@jumpAgain
	ld (hl),$02 ; [state]
	ld l,Enemy.counter1		; $59d2
	ld (hl),30		; $59d4
	ret			; $59d6

@transformProbabilities:
	.db $ff $03 $03 $01 $00


; Face is opening
_veranFinal_turtleForm_state6:
	call enemyAnimate		; $59dc
	ld h,d			; $59df
	ld l,Enemy.animParameter		; $59e0
	bit 7,(hl)		; $59e2
	jr nz,@nextState	; $59e4
	bit 0,(hl)		; $59e6
	ret z			; $59e8
	ld l,Enemy.enemyCollisionMode		; $59e9
	ld (hl),ENEMYCOLLISION_VERAN_TURTLE_FORM_VULNERABLE		; $59eb
	ret			; $59ed

@nextState:
	ld l,Enemy.state		; $59ee
	inc (hl)		; $59f0
	ld l,Enemy.counter1		; $59f1
	ld (hl),90		; $59f3
	xor a			; $59f5
	jp enemySetAnimation		; $59f6


_veranFinal_turtleForm_state7:
	call _ecom_decCounter1		; $59f9
	jp nz,enemyAnimate		; $59fc
	ld l,e			; $59ff
	inc (hl) ; [state]
	ld a,$03		; $5a01
	jp enemySetAnimation		; $5a03


_veranFinal_turtleForm_state8:
	call enemyAnimate		; $5a06
	ld h,d			; $5a09
	ld l,Enemy.animParameter		; $5a0a
	bit 7,(hl)		; $5a0c
	jr nz,@nextState	; $5a0e
	bit 0,(hl)		; $5a10
	ret z			; $5a12
	ld l,Enemy.enemyCollisionMode		; $5a13
	ld (hl),ENEMYCOLLISION_VERAN_TURTLE_FORM		; $5a15
	ret			; $5a17

@nextState:
	ld l,Enemy.state		; $5a18
	ld (hl),$02		; $5a1a
	ld l,Enemy.counter1		; $5a1c
	ld (hl),30		; $5a1e
	ld a,$01		; $5a20
	jp enemySetAnimation		; $5a22


; Just transformed back from being a spider or bee
_veranFinal_turtleForm_state9:
	call enemyAnimate		; $5a25
	ld e,Enemy.animParameter		; $5a28
	ld a,(de)		; $5a2a
	inc a			; $5a2b
	ret nz			; $5a2c

	ld h,d			; $5a2d
	ld l,Enemy.var33		; $5a2e
	ldi (hl),a ; [var33] = 0
	ld (hl),a  ; [var34] = 0

	ld l,Enemy.state		; $5a32
	dec (hl)		; $5a34
	ld l,Enemy.collisionType		; $5a35
	ld (hl),$80|ENEMYID_VERAN_FINAL_FORM
	inc l			; $5a39
	ld (hl),ENEMYCOLLISION_VERAN_TURTLE_FORM_VULNERABLE ; [enemyCollisionType]

	ld l,Enemy.oamFlagsBackup		; $5a3c
	ld a,$06		; $5a3e
	ldi (hl),a		; $5a40
	ld (hl),a		; $5a41
	ld a,$03		; $5a42
	jp enemySetAnimation		; $5a44


; Dead
_veranFinal_turtleForm_stateA:
	inc e			; $5a47
	ld a,(de)		; $5a48
	rst_jumpTable			; $5a49
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate0:
	ld e,Enemy.invincibilityCounter		; $5a52
	ld a,(de)		; $5a54
	or a			; $5a55
	ret nz			; $5a56
	call checkLinkVulnerable		; $5a57
	ret nc			; $5a5a

	ld a,$01		; $5a5b
	ld (wMenuDisabled),a		; $5a5d
	ld (wDisabledObjects),a		; $5a60

	call dropLinkHeldItem		; $5a63
	call clearAllParentItems		; $5a66
	call _ecom_incState2		; $5a69

	call checkIsLinkedGame		; $5a6c
	ld bc,TX_5615		; $5a6f
	jr z,+			; $5a72
	ld bc,TX_5616		; $5a74
+
	jp showText		; $5a77

@substate1:
	ld a,(wTextIsActive)		; $5a7a
	or a			; $5a7d
	ret nz			; $5a7e
	call _ecom_incState2		; $5a7f
	ld l,Enemy.counter2		; $5a82
	ld (hl),40		; $5a84
	ld l,Enemy.yh		; $5a86
	ld b,(hl)		; $5a88
	ld l,Enemy.xh		; $5a89
	ld c,(hl)		; $5a8b
	ld a,$ff		; $5a8c
	jp createEnergySwirlGoingOut		; $5a8e

@substate2:
	call _ecom_decCounter2		; $5a91
	ret nz			; $5a94
	ldbc INTERACID_MISC_PUZZLES, $21		; $5a95
	call objectCreateInteraction		; $5a98
	ret nz			; $5a9b
	jp _ecom_incState2		; $5a9c

@substate3:
	ld a,(wPaletteThread_mode)		; $5a9f
	or a			; $5aa2
	ret nz			; $5aa3
	ld hl,wGroup4Flags+(<ROOM_4fc)		; $5aa4
	set 7,(hl)		; $5aa7
	ld a,CUTSCENE_BLACK_TOWER_ESCAPE		; $5aa9
	ld (wCutsceneTrigger),a		; $5aab
	call incMakuTreeState		; $5aae
	jp enemyDelete		; $5ab1


_veranFinal_spiderForm:
	ld a,(de)		; $5ab4
	rst_jumpTable			; $5ab5
	.dw _veranFinal_spiderOrBeeForm_state0
	.dw _veranFinal_spiderForm_state1
	.dw _veranFinal_spiderForm_state2
	.dw _veranFinal_spiderForm_state3
	.dw _veranFinal_spiderForm_state4


_veranFinal_spiderOrBeeForm_state0:
	ret			; $5ac0


_veranFinal_spiderForm_state1:
	call enemyAnimate		; $5ac1
	ld e,Enemy.animParameter		; $5ac4
	ld a,(de)		; $5ac6
	inc a			; $5ac7
	ret nz			; $5ac8

	ld bc,$1010		; $5ac9
	ld e,ENEMYCOLLISION_VERAN_SPIDER_FORM		; $5acc
	ld l,Enemy.var31		; $5ace
	call _veranFinal_initializeForm		; $5ad0
	ld a,$05		; $5ad3
	call enemySetAnimation		; $5ad5

_veranFinal_spiderForm_setCounter2AndInitState2:
	ld e,Enemy.counter2		; $5ad8
	ld a,120		; $5ada
	ld (de),a		; $5adc

_veranFinal_spiderForm_initState2:
	ld h,d			; $5add
	ld l,Enemy.state		; $5ade
	ld (hl),$02		; $5ae0
	ld l,Enemy.speed		; $5ae2
	ld (hl),SPEED_c0		; $5ae4

	call getRandomNumber_noPreserveVars		; $5ae6
	and $03			; $5ae9
	ld hl,@counter1Vals		; $5aeb
	rst_addAToHl			; $5aee
	ld e,Enemy.counter1		; $5aef
	ld a,(hl)		; $5af1
	ld (de),a		; $5af2
	call _veranFinal_spiderForm_decideAngle		; $5af3
	jr _veranFinal_spiderForm_animate		; $5af6

@counter1Vals:
	.db 60,80,100,120


_veranFinal_spiderForm_state2:
	call _ecom_decCounter2		; $5afc
	jr nz,++		; $5aff
	ld (hl),120		; $5b01
	call _veranFinal_spiderForm_decideWhetherToAttack		; $5b03
	ret c			; $5b06
++
	call _ecom_decCounter1		; $5b07
	jr z,_veranFinal_spiderForm_initState2	; $5b0a

_veranFinal_spiderForm_updateMovement:
	call _ecom_bounceOffWallsAndHoles		; $5b0c
	call objectApplySpeed		; $5b0f

_veranFinal_spiderForm_animate:
	jp enemyAnimate		; $5b12


_veranFinal_spiderForm_state3:
	ld e,Enemy.zh		; $5b15
	ld a,(de)		; $5b17
	rlca			; $5b18
	ld c,$20		; $5b19
	jp c,objectUpdateSpeedZ_paramC		; $5b1b

	call _ecom_decCounter1		; $5b1e
	jr z,@gotoState2	; $5b21

	ld a,(hl)		; $5b23
	rrca			; $5b24
	ret c			; $5b25
	ld l,Enemy.zh		; $5b26
	ld a,(hl)		; $5b28
	xor $02			; $5b29
	ld (hl),a		; $5b2b
	ret			; $5b2c

@gotoState2:
	ld l,Enemy.zh		; $5b2d
	ld (hl),$00		; $5b2f
	call objectSetVisible83		; $5b31
	call _veranFinal_spiderForm_resetCollisionData		; $5b34
	jr _veranFinal_spiderForm_initState2		; $5b37


; Doing an attack
_veranFinal_spiderForm_state4:
	ld e,Enemy.var03		; $5b39
	ld a,(de)		; $5b3b
	ld e,Enemy.state2		; $5b3c
	rst_jumpTable			; $5b3e
	.dw _veranFinal_spiderForm_rushAttack
	.dw _veranFinal_spiderForm_jumpAttack
	.dw _veranFinal_spiderForm_webAttack


; Rush toward Link for 1 second
_veranFinal_spiderForm_rushAttack:
	ld a,(de)		; $5b45
	or a			; $5b46
	jr z,@substate0	; $5b47

@substate1:
	call _ecom_decCounter1		; $5b49
	jr z,_veranFinal_spiderForm_setCounter2AndInitState2	; $5b4c
	call _veranFinal_spiderForm_updateMovement		; $5b4e
	jp enemyAnimate		; $5b51

@substate0:
	call _ecom_incState2		; $5b54
	inc l			; $5b57
	ld (hl),60 ; [counter1]
	ld l,Enemy.speed		; $5b5a
	ld (hl),SPEED_180		; $5b5c

	call _ecom_updateAngleTowardTarget		; $5b5e
	and $18			; $5b61
	add $04			; $5b63
	ld (de),a		; $5b65
	jr _veranFinal_spiderForm_animate		; $5b66


; Jumps up and crashes back down onto the ground
_veranFinal_spiderForm_jumpAttack:
	ld a,(de)		; $5b68
	rst_jumpTable			; $5b69
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4

@substate0:
	ld b,PARTID_56		; $5b74
	call _ecom_spawnProjectile		; $5b76
	ret nz			; $5b79
	call _ecom_incState2		; $5b7a
	ld l,Enemy.var38		; $5b7d
	ld (hl),$00		; $5b7f
	call _veranFinal_spiderForm_setVulnerableCollisionData		; $5b81
	jp objectSetVisible81		; $5b84

@substate1:
	; Wait for signal from child object?
	ld e,Enemy.var38		; $5b87
	ld a,(de)		; $5b89
	or a			; $5b8a
	ret z			; $5b8b

	ld h,d			; $5b8c
	ld l,Enemy.zh		; $5b8d
	ld a,(hl)		; $5b8f
	sub $03			; $5b90
	ld (hl),a		; $5b92
	bit 7,a			; $5b93
	jr z,++			; $5b95

	cp $e0			; $5b97
	ret nc			; $5b99

	ldh a,(<hCameraY)	; $5b9a
	ld b,a			; $5b9c
	ld a,(hl)		; $5b9d
	ld l,Enemy.yh		; $5b9e
	add (hl)		; $5ba0
	sub b			; $5ba1
	cp $b0			; $5ba2
	ret c			; $5ba4
++
	ld l,Enemy.state2		; $5ba5
	inc (hl)		; $5ba7
	inc l			; $5ba8
	ld (hl),90 ; [counter1]
	ld l,Enemy.collisionType		; $5bab
	res 7,(hl)		; $5bad
	ld l,Enemy.zh		; $5baf
	ld (hl),$00		; $5bb1
	jp objectSetInvisible		; $5bb3

@substate2:
	call _ecom_decCounter1		; $5bb6
	ret nz			; $5bb9
	ld l,e			; $5bba
	inc (hl) ; [state2]
	ld l,Enemy.collisionType		; $5bbc
	set 7,(hl)		; $5bbe
	ld l,Enemy.speedZ		; $5bc0
	xor a			; $5bc2
	ldi (hl),a		; $5bc3
	ld (hl),$01		; $5bc4

	ld l,Enemy.yh		; $5bc6
	ldh a,(<hEnemyTargetY)	; $5bc8
	ldi (hl),a		; $5bca
	inc l			; $5bcb
	ldh a,(<hEnemyTargetX)	; $5bcc
	ld (hl),a		; $5bce
	ld c,$08		; $5bcf
	call _ecom_setZAboveScreen		; $5bd1
	call _veranFinal_spiderForm_resetCollisionData		; $5bd4
	jp objectSetVisible81		; $5bd7

@substate3:
	ld c,$20		; $5bda
	call objectUpdateSpeedZ_paramC		; $5bdc
	ret nz			; $5bdf

	; Landed
	ld l,Enemy.state2		; $5be0
	inc (hl)		; $5be2
	inc l			; $5be3
	ld (hl),120 ; [counter1]
	ld a,SND_STRONG_POUND		; $5be6
	call playSound		; $5be8
	ld a,90		; $5beb
	call setScreenShakeCounter		; $5bed
	jp objectSetVisible83		; $5bf0

@substate4:
	call _ecom_decCounter1		; $5bf3
	ret nz			; $5bf6
	jp _veranFinal_spiderForm_setCounter2AndInitState2		; $5bf7


; Shoots out web to try and catch Link
_veranFinal_spiderForm_webAttack:
	ld a,(de)		; $5bfa
	rst_jumpTable			; $5bfb
	.dw _veranFinal_spiderForm_webAttack_substate0
	.dw _veranFinal_spiderForm_webAttack_substate1
	.dw _veranFinal_spiderForm_webAttack_substate2
	.dw _veranFinal_spiderForm_webAttack_substate3
	.dw _veranFinal_spiderForm_webAttack_substate4
	.dw _veranFinal_spiderForm_webAttack_substate5
	.dw _veranFinal_spiderForm_webAttack_substate6
	.dw _veranFinal_spiderForm_webAttack_substate7


_veranFinal_spiderForm_webAttack_substate0:
	ld h,d			; $5c0c
	ld l,e			; $5c0d
	inc (hl) ; [state2]
	inc l			; $5c0f
	ld (hl),30 ; [counter1]
	ld l,Enemy.var38		; $5c12
	ld (hl),$00		; $5c14

_veranFinal_spiderForm_resetCollisionData:
	ld h,d			; $5c16
	ld l,Enemy.enemyCollisionMode		; $5c17
	ld (hl),ENEMYCOLLISION_VERAN_SPIDER_FORM		; $5c19
	ld l,Enemy.collisionRadiusY		; $5c1b
	ld (hl),$10		; $5c1d
	ld a,$05		; $5c1f
	jp enemySetAnimation		; $5c21


_veranFinal_spiderForm_webAttack_substate1:
	call _ecom_decCounter1		; $5c24
	ret nz			; $5c27
	inc l			; $5c28
	ld (hl),$08 ; [counter2]
	ld l,e			; $5c2b
	inc (hl) ; [state2]

_veranFinal_spiderForm_setVulnerableCollisionData:
	ld h,d			; $5c2d
	ld l,Enemy.enemyCollisionMode		; $5c2e
	ld (hl),ENEMYCOLLISION_VERAN_SPIDER_FORM_VULNERABLE		; $5c30
	ld l,Enemy.collisionRadiusY		; $5c32
	ld (hl),$08		; $5c34
	ld a,$06		; $5c36
	jp enemySetAnimation		; $5c38


_veranFinal_spiderForm_webAttack_substate2:
	call _ecom_decCounter2		; $5c3b
	ret nz			; $5c3e

	ld b,PARTID_56		; $5c3f
	call _ecom_spawnProjectile		; $5c41
	ret nz			; $5c44
	ld l,Part.subid		; $5c45
	inc (hl) ; [subid] = 1
	call _ecom_incState2		; $5c48
	inc l			; $5c4b
	ld (hl),90 ; [counter1]
	jr _veranFinal_spiderForm_resetCollisionData		; $5c4e


; Web coming back?
_veranFinal_spiderForm_webAttack_substate3:
	ld e,Enemy.var38		; $5c50
	ld a,(de)		; $5c52
	or a			; $5c53
	ret z			; $5c54

	call _ecom_decCounter1		; $5c55
	ret nz			; $5c58

	ld a,(w1Link.state)		; $5c59
	cp LINK_STATE_GRABBED			; $5c5c
	jp nz,_veranFinal_spiderForm_setCounter2AndInitState2		; $5c5e

	; Grabbed
	call _ecom_incState2		; $5c61
	inc l			; $5c64
	ld (hl),$10		; $5c65
	ld a,$06		; $5c67
	call enemySetAnimation		; $5c69
	ld b,$f8		; $5c6c

_veranFinal_spiderForm_webAttack_updateLinkPosition:
	ld hl,w1Link		; $5c6e
	ld c,$00		; $5c71
	jp objectCopyPositionWithOffset		; $5c73


_veranFinal_spiderForm_webAttack_substate4:
	call _ecom_decCounter1		; $5c76
	ret nz			; $5c79

	ld (hl),$04 ; [counter1]
	ld l,e			; $5c7c
	inc (hl) ; [state2]
	ld a,$05		; $5c7e
	call enemySetAnimation		; $5c80
	ld a,$04		; $5c83
	call setScreenShakeCounter		; $5c85
	ld b,$14		; $5c88
	call _veranFinal_spiderForm_webAttack_updateLinkPosition		; $5c8a
	ldbc -6,$08		; $5c8d

_veranFinal_spiderForm_webAttack_applyDamageToLink:
	ld l,<w1Link.damageToApply		; $5c90
	ld (hl),b		; $5c92
	ld l,<w1Link.invincibilityCounter		; $5c93
	ld (hl),c		; $5c95
	ld a,SND_STRONG_POUND		; $5c96
	jp playSound		; $5c98


_veranFinal_spiderForm_webAttack_substate5:
	call _ecom_decCounter1		; $5c9b
	ret nz			; $5c9e
	ld (hl),$08		; $5c9f
	ld l,e			; $5ca1
	inc (hl)		; $5ca2
	ld a,$06		; $5ca3
	call enemySetAnimation		; $5ca5
	ld b,$f6		; $5ca8
	jr _veranFinal_spiderForm_webAttack_updateLinkPosition		; $5caa


_veranFinal_spiderForm_webAttack_substate6:
	call _ecom_decCounter1		; $5cac
	ret nz			; $5caf
	ld (hl),$0f		; $5cb0
	ld l,e			; $5cb2
	inc (hl)		; $5cb3
	ld a,$05		; $5cb4
	call enemySetAnimation		; $5cb6
	ld a,$14		; $5cb9
	call setScreenShakeCounter		; $5cbb
	ld b,$14		; $5cbe
	call _veranFinal_spiderForm_webAttack_updateLinkPosition		; $5cc0
	ldbc -10,$18		; $5cc3
	jr _veranFinal_spiderForm_webAttack_applyDamageToLink		; $5cc6


_veranFinal_spiderForm_webAttack_substate7:
	call _ecom_decCounter1		; $5cc8
	ret nz			; $5ccb
	ld l,Enemy.collisionType		; $5ccc
	set 7,(hl)		; $5cce
	call _veranFinal_spiderForm_setCounter2AndInitState2		; $5cd0


_veranFinal_grabbingLink:
	ld hl,w1Link.state2		; $5cd3
	ld (hl),$02		; $5cd6
	ld l,<w1Link.collisionType		; $5cd8
	set 7,(hl)		; $5cda
	ret			; $5cdc


_veranFinal_beeForm:
	ld a,(de)		; $5cdd
	rst_jumpTable			; $5cde
	.dw _veranFinal_spiderOrBeeForm_state0
	.dw _veranFinal_beeForm_state1
	.dw _veranFinal_beeForm_state2
	.dw _veranFinal_beeForm_state3
	.dw _veranFinal_beeForm_state4
	.dw _veranFinal_beeForm_state5
	.dw _veranFinal_beeForm_state6
	.dw _veranFinal_beeForm_state7
	.dw _veranFinal_beeForm_state8
	.dw _veranFinal_beeForm_state9
	.dw _veranFinal_beeForm_stateA
	.dw _veranFinal_beeForm_stateB


_veranFinal_beeForm_state1:
	call enemyAnimate		; $5cf7
	ld e,Enemy.animParameter		; $5cfa
	ld a,(de)		; $5cfc
	inc a			; $5cfd
	ret nz			; $5cfe
	ld a,$07		; $5cff
	call enemySetAnimation		; $5d01
	call _ecom_incState		; $5d04
	ld l,Enemy.speed		; $5d07
	ld (hl),SPEED_200		; $5d09
	ld bc,$100c		; $5d0b
	ld e,ENEMYCOLLISION_VERAN_SPIDER_FORM_VULNERABLE		; $5d0e
	ld l,Enemy.var32		; $5d10


;;
; @param	bc	collisionRadiusY/X
; @param	e	enemyCollisionMode
; @param	l	Pointer to health value
; @addr{5d12}
_veranFinal_initializeForm:
	ld h,d			; $5d12
	ld a,(hl)		; $5d13
	ld l,Enemy.health		; $5d14
	ld (hl),a		; $5d16

	ld l,Enemy.collisionType		; $5d17
	ld (hl),$80|ENEMYID_VERAN_FINAL_FORM
	inc l			; $5d1b
	ld (hl),e		; $5d1c

	ld l,Enemy.collisionRadiusY		; $5d1d
	ld (hl),b		; $5d1f
	inc l			; $5d20
	ld (hl),c		; $5d21

	ld l,Enemy.oamFlagsBackup		; $5d22
	ld a,$06		; $5d24
	ldi (hl),a		; $5d26
	ld (hl),a		; $5d27
	ret			; $5d28


_veranFinal_beeForm_state2:
	ld e,Enemy.yh		; $5d29
	ld a,(de)		; $5d2b
	ldh (<hFF8F),a	; $5d2c
	ld e,Enemy.xh		; $5d2e
	ld a,(de)		; $5d30
	ldh (<hFF8E),a	; $5d31
	ldbc LARGE_ROOM_HEIGHT<<3, LARGE_ROOM_WIDTH<<3		; $5d33
	sub c			; $5d36
	add $02			; $5d37
	cp $05			; $5d39
	jr nc,@updateMovement	; $5d3b
	ldh a,(<hFF8F)	; $5d3d
	sub b			; $5d3f
	add $02			; $5d40
	cp $05			; $5d42
	jr nc,@updateMovement	; $5d44

	; In middle of room
	call _ecom_incState		; $5d46
	jp _veranFinal_beeForm_chooseRandomTargetPosition		; $5d49

@updateMovement:
	call _ecom_moveTowardPosition		; $5d4c

_veranFinal_beeForm_animate:
	jp enemyAnimate		; $5d4f


_veranFinal_beeForm_state3:
	call _veranFinal_moveTowardTargetPosition		; $5d52
	jr nc,_veranFinal_beeForm_animate	; $5d55

	ld l,Enemy.yh		; $5d57
	ld (hl),b		; $5d59
	ld l,Enemy.xh		; $5d5a
	ld (hl),c		; $5d5c
	call _veranFinal_beeForm_nextTargetPosition		; $5d5d
	call _ecom_decCounter2		; $5d60
	jr nz,_veranFinal_beeForm_animate	; $5d63

	; Time to move off screen
	ld l,Enemy.state		; $5d65
	inc (hl)		; $5d67
	ld l,Enemy.counter1		; $5d68
	ld (hl),$01		; $5d6a
	ld l,Enemy.xh		; $5d6c
	bit 7,(hl)		; $5d6e
	ld a,$00		; $5d70
	jr nz,+			; $5d72
	ld a,$f0		; $5d74
+
	ld l,Enemy.var37		; $5d76
	ldd (hl),a		; $5d78
	ld (hl),$e0		; $5d79
	jr _veranFinal_beeForm_animate		; $5d7b


; Moving off screen
_veranFinal_beeForm_state4:
	call _ecom_decCounter1		; $5d7d
	jr nz,++		; $5d80

	ld (hl),$06 ; [counter1]
	ld l,Enemy.var36		; $5d84
	call _ecom_readPositionVars		; $5d86
	call objectGetRelativeAngleWithTempVars		; $5d89
	call objectNudgeAngleTowards		; $5d8c
++
	call objectApplySpeed		; $5d8f
	ld e,Enemy.yh		; $5d92
	ld a,(de)		; $5d94
	cp (LARGE_ROOM_HEIGHT+1)<<4			; $5d95
	jr c,_veranFinal_beeForm_animate	; $5d97

	; Off screen
	call _ecom_incState		; $5d99
	ld l,Enemy.counter1		; $5d9c
	ld (hl),30		; $5d9e
	jp objectSetInvisible		; $5da0


; About to re-emerge on screen
_veranFinal_beeForm_state5:
	call _ecom_decCounter1		; $5da3
	ret nz			; $5da6

	ld (hl),$0f ; [counter1]
	ld l,e			; $5da9
	inc (hl) ; [state]
	ld l,Enemy.yh		; $5dab
	ld (hl),$20		; $5dad

	call getRandomNumber		; $5daf
	and $10			; $5db2
	ldbc $08,$e8		; $5db4
	jr z,++			; $5db7
	ld b,c			; $5db9
	ld c,$08		; $5dba
++
	add $08			; $5dbc
	ld l,Enemy.angle		; $5dbe
	ld (hl),a		; $5dc0
	ld l,Enemy.xh		; $5dc1
	ld (hl),b		; $5dc3
	ld l,Enemy.var37		; $5dc4
	ld (hl),c		; $5dc6
	jp objectSetVisible83		; $5dc7


; Moving horizontally across screen while attacking
_veranFinal_beeForm_state6:
	call _ecom_decCounter1		; $5dca
	jr nz,++		; $5dcd
	ld (hl),$0f ; [counter1]
	ld b,PARTID_58		; $5dd1
	call _ecom_spawnProjectile		; $5dd3
++
	call objectApplySpeed		; $5dd6
	ld e,Enemy.xh		; $5dd9
	ld a,(de)		; $5ddb
	ld h,d			; $5ddc
	ld l,Enemy.var37		; $5ddd
	sub (hl)		; $5ddf
	inc a			; $5de0
	cp $03			; $5de1
	jp nc,enemyAnimate		; $5de3

	; Reached other side
	call _ecom_incState		; $5de6
	ld l,Enemy.counter1		; $5de9
	ld (hl),60		; $5deb
	ld l,Enemy.collisionType		; $5ded
	res 7,(hl)		; $5def
	jp objectSetInvisible		; $5df1


; About to re-emerge from some corner of the screen
_veranFinal_beeForm_state7:
	call _ecom_decCounter1		; $5df4
	ret nz			; $5df7

	; Choose which corner to emerge from (not the current one)
	call _veranFinal_getQuadrant		; $5df8
--
	call getRandomNumber		; $5dfb
	ld c,a			; $5dfe
	and $03			; $5dff
	cp b			; $5e01
	jr z,--			; $5e02

	ld e,Enemy.var39		; $5e04
	ld (de),a		; $5e06
	add a			; $5e07
	ld hl,_veranFinal_beeForm_screenCornerEntrances		; $5e08
	rst_addDoubleIndex			; $5e0b
	ld e,Enemy.var36		; $5e0c
	ldi a,(hl)		; $5e0e
	ld (de),a		; $5e0f
	inc e			; $5e10
	ldi a,(hl)		; $5e11
	ld (de),a		; $5e12

	ld e,Enemy.yh		; $5e13
	ldi a,(hl)		; $5e15
	ld (de),a		; $5e16
	ld e,Enemy.xh		; $5e17
	ld a,(hl)		; $5e19
	ld (de),a		; $5e1a

	ld a,c			; $5e1b
	and $30			; $5e1c
	swap a			; $5e1e
	add $02			; $5e20
	ld e,Enemy.counter2		; $5e22
	ld (de),a		; $5e24

	call _ecom_incState		; $5e25
	ld l,Enemy.collisionType		; $5e28
	set 7,(hl)		; $5e2a
	jp objectSetVisible83		; $5e2c


_veranFinal_beeForm_state8:
	call _veranFinal_moveTowardTargetPosition		; $5e2f
	jr nc,_veranFinal_beeForm_animate2	; $5e32
	ld l,Enemy.yh		; $5e34
	ld (hl),b		; $5e36
	ld l,Enemy.xh		; $5e37
	ld (hl),c		; $5e39
	ld l,Enemy.state		; $5e3a
	inc (hl)		; $5e3c
	ld l,Enemy.counter1		; $5e3d
	ld (hl),30		; $5e3f
	jr _veranFinal_beeForm_animate2		; $5e41


_veranFinal_beeForm_state9:
	call _ecom_decCounter1		; $5e43
	jr nz,_veranFinal_beeForm_animate2	; $5e46
	ld (hl),25 ; [counter1]
	ld l,e			; $5e4a
	inc (hl) ; [state2]

_veranFinal_beeForm_animate2:
	jp enemyAnimate		; $5e4c


; Shooting out bees
_veranFinal_beeForm_stateA:
	call _ecom_decCounter1		; $5e4f
	jr z,_label_10_173	; $5e52

	ld a,(hl) ; [counter1]
	and $07			; $5e55
	jr nz,_veranFinal_beeForm_animate2	; $5e57

	; Spawn child bee
	ld a,(hl)		; $5e59
	and $18			; $5e5a
	swap a			; $5e5c
	rlca			; $5e5e
	dec a			; $5e5f
	ld b,a			; $5e60
	call getFreeEnemySlot		; $5e61
	jr nz,_veranFinal_beeForm_animate2	; $5e64

	ld (hl),ENEMYID_VERAN_CHILD_BEE		; $5e66
	inc l			; $5e68
	ld (hl),b ; [child.subid]
	call objectCopyPosition		; $5e6a
	ld a,SND_BEAM1		; $5e6d
	call playSound		; $5e6f
	jr _veranFinal_beeForm_animate2		; $5e72

_label_10_173:
	ld (hl),20 ; [counter1]
	inc l			; $5e76
	dec (hl) ; [counter2]
	ld l,e			; $5e78
	jr z,+			; $5e79
	inc (hl) ; [state] = $0b
	jr _veranFinal_beeForm_animate2		; $5e7c
+
	ld (hl),$02 ; [state] = $02
	jr _veranFinal_beeForm_animate2		; $5e80


_veranFinal_beeForm_stateB:
	call _ecom_decCounter1		; $5e82
	jr nz,_veranFinal_beeForm_animate2	; $5e85

	ld l,e			; $5e87
	ld (hl),$08 ; [state]

	call _veranFinal_getQuadrant		; $5e8a
@chooseQuadrant:
	call getRandomNumber		; $5e8d
	and $03			; $5e90
	cp b			; $5e92
	jr z,@chooseQuadrant	; $5e93
	ld h,d			; $5e95
	ld l,Enemy.var39		; $5e96
	cp (hl)			; $5e98
	jr z,@chooseQuadrant	; $5e99

	ld (hl),a ; [var39]
	add a			; $5e9c
	ld hl,_veranFinal_beeForm_screenCornerEntrances		; $5e9d
	rst_addDoubleIndex			; $5ea0
	ld e,Enemy.var36		; $5ea1
	ldi a,(hl)		; $5ea3
	ld (de),a		; $5ea4
	inc e			; $5ea5
	ld a,(hl)		; $5ea6
	ld (de),a		; $5ea7
	jr _veranFinal_beeForm_animate2		; $5ea8


_veranFinal_beeForm_screenCornerEntrances:
	.db $2c $3c $00 $00
	.db $2c $b4 $00 $f0
	.db $84 $3c $b0 $00
	.db $84 $b4 $b0 $f0


;;
; @param	hl	Enemy.state
; @addr{5eba}
_veranFinal_transformToBeeOrSpider:
	ld (hl),$01		; $5eba
	ld l,Enemy.collisionType		; $5ebc
	ld (hl),$80|ENEMYID_BEAMOS		; $5ebe

	ld l,Enemy.health		; $5ec0
	ld a,(hl)		; $5ec2
	ld l,Enemy.var30		; $5ec3
	ld (hl),a		; $5ec5

	ld l,Enemy.oamFlagsBackup		; $5ec6
	ld a,$07		; $5ec8
	ldi (hl),a		; $5eca
	ld (hl),a		; $5ecb

	call getRandomNumber_noPreserveVars		; $5ecc
	and $03			; $5ecf
	ld b,a			; $5ed1
	ld e,Enemy.var35		; $5ed2
	ld a,(de)		; $5ed4
	ld c,a			; $5ed5
	inc a			; $5ed6
	and $07			; $5ed7
	ld (de),a		; $5ed9

	ld a,c			; $5eda
	add a			; $5edb
	add a			; $5edc
	add b			; $5edd
	ld hl,@transformSequence		; $5ede
	call checkFlag		; $5ee1
	jr z,+			; $5ee4
	ld a,$01		; $5ee6
+
	inc a			; $5ee8
	ld e,Enemy.subid		; $5ee9
	ld (de),a		; $5eeb
	add $09			; $5eec
	call enemySetAnimation		; $5eee
	ld a,SND_TRANSFORM		; $5ef1
	jp playSound		; $5ef3

; Each 4 bits is a set of possible values (0=spider, 1=bee).
; [var35] determines which set of 4 bits is randomly chosen from.
; So, for instance, veran always turns into a spider in round 2 due to the 4 '0's?
@transformSequence:
	dbrev %11000000 %11111110 %11101100 %00001111


;;
; @param	b	Distance
; @param[out]	cflag	c if Link is within 'b' pixels of self
; @addr{5efa}
_veranFinal_spiderForm_checkLinkWithinDistance:
	ld a,b			; $5efa
	add a			; $5efb
	inc a			; $5efc
	ld c,a			; $5efd
	ld a,(w1Link.yh)		; $5efe
	ld h,d			; $5f01
	ld l,Enemy.yh		; $5f02
	sub (hl)		; $5f04
	add b			; $5f05
	cp c			; $5f06
	ret nc			; $5f07
	ld a,(w1Link.xh)		; $5f08
	ld l,Enemy.xh		; $5f0b
	sub (hl)		; $5f0d
	add b			; $5f0e
	cp c			; $5f0f
	ret			; $5f10


;;
; @param[out]	cflag	c if will do an attack (state changed to 4)
; @addr{5f11}
_veranFinal_spiderForm_decideWhetherToAttack:
	call objectGetAngleTowardLink		; $5f11
	ld e,a			; $5f14

@considerRushAttack:
	ld b,$60		; $5f15
	call _veranFinal_spiderForm_checkLinkWithinDistance		; $5f17
	jr nc,@considerJumpAttack	; $5f1a

	; BUG: is this supposed to 'ld a,e' first? This would check that Link is at a relatively
	; diagonal angle. Instead, this seems to compare their difference in x-positions modulo 8.
	and $07			; $5f1c
	sub $03			; $5f1e
	cp $03			; $5f20
	ld a,$00		; $5f22
	jr c,@doAttack	; $5f24

@considerJumpAttack:
	ld b,$50		; $5f26
	call _veranFinal_spiderForm_checkLinkWithinDistance		; $5f28
	jr c,@considerGrabAttack	; $5f2b

	; Check that Link is diagonal relative to the spider.
	; That shouldn't really matter for this attack, though...
	ld a,e			; $5f2d
	and $07			; $5f2e
	sub $03			; $5f30
	cp $03			; $5f32
	ccf			; $5f34
	ld a,$01		; $5f35
	jr c,@doAttack	; $5f37

@considerGrabAttack:
	; Check that Link is below the spider
	ld a,e			; $5f39
	sub $0c			; $5f3a
	cp $09			; $5f3c
	ret nc			; $5f3e

	; Grab attack
	ld a,$02		; $5f3f

@doAttack:
	ld e,Enemy.var03		; $5f41
	ld (de),a		; $5f43
	ld h,d			; $5f44
	ld l,Enemy.state		; $5f45
	ld (hl),$04		; $5f47
	inc l			; $5f49
	ld (hl),$00 ; [state2]
	scf			; $5f4c
	ret			; $5f4d


;;
; @addr{5f4e}
_veranFinal_dead:
	ld e,Enemy.subid		; $5f4e
	ld a,(de)		; $5f50
	or a			; $5f51
	jr nz,@transformed	; $5f52

	; Not transformed; dead for real
	ld h,d			; $5f54
	ld l,Enemy.state		; $5f55
	ld (hl),$0a		; $5f57
	inc l			; $5f59
	ld (hl),$00		; $5f5a
	ld l,Enemy.health		; $5f5c
	inc (hl)		; $5f5e
	ld a,SNDCTRL_STOPMUSIC		; $5f5f
	jp playSound		; $5f61

@transformed:
	ld b,a			; $5f64
	ld h,d			; $5f65
	ld l,e			; $5f66
	ld (hl),$00 ; [subid]
	ld l,Enemy.state		; $5f69
	ld (hl),$09		; $5f6b

	; Restore turtle health
	ld l,Enemy.var30		; $5f6d
	ld a,(hl)		; $5f6f
	ld l,Enemy.health		; $5f70
	ld (hl),a		; $5f72

	ld l,Enemy.collisionType		; $5f73
	ld (hl),$80|ENEMYID_BEAMOS		; $5f75

	ld l,Enemy.collisionRadiusY		; $5f77
	ld (hl),$08		; $5f79
	inc l			; $5f7b
	ld (hl),$0a ; [collisionRadiusX]

	ld l,Enemy.oamFlagsBackup		; $5f7e
	ld a,$07		; $5f80
	ldi (hl),a		; $5f82
	ld (hl),a		; $5f83

	ld a,b ; [subid]
	add $07			; $5f85
	call enemySetAnimation		; $5f87
	ld a,SND_TRANSFORM		; $5f8a
	jp playSound		; $5f8c


_veranFinal_spiderForm_decideAngle:
	ld b,$00		; $5f8f
	ld e,Enemy.yh		; $5f91
	ld a,(de)		; $5f93
	cp (LARGE_ROOM_HEIGHT<<4)/2
	jr c,+			; $5f96
	ld b,$10		; $5f98
+
	ld e,Enemy.xh		; $5f9a
	ld a,(de)		; $5f9c
	cp (LARGE_ROOM_WIDTH<<4)/2
	jr c,+			; $5f9f
	set 3,b			; $5fa1
+
	call getRandomNumber		; $5fa3
	and $07			; $5fa6
	add b			; $5fa8
	ld hl,@angles		; $5fa9
	rst_addAToHl			; $5fac
	ld e,Enemy.angle		; $5fad
	ld a,(hl)		; $5faf
	ld (de),a		; $5fb0
	ret			; $5fb1

@angles:
	.db $04 $04 $0c $0c $0c $14 $14 $1c
	.db $04 $0c $0c $14 $14 $14 $1c $1c
	.db $04 $04 $04 $0c $0c $14 $1c $1c
	.db $04 $04 $0c $14 $14 $1c $1c $1c

;;
; @addr{5fd2}
_veranFinal_beeForm_chooseRandomTargetPosition:
	ld bc,$0801		; $5fd2
	call _ecom_randomBitwiseAndBCE		; $5fd5
	ld e,Enemy.counter1		; $5fd8
	ld a,b			; $5fda
	ld (de),a		; $5fdb

	ld a,c			; $5fdc
	ld hl,_veranFinal_beeForm_counter2Vals		; $5fdd
	rst_addAToHl			; $5fe0
	ld e,Enemy.counter2		; $5fe1
	ld a,(hl)		; $5fe3
	ld (de),a		; $5fe4

;;
; @addr{5fe5}
_veranFinal_beeForm_nextTargetPosition:
	ld e,Enemy.counter1		; $5fe5
	ld a,(de)		; $5fe7
	ld b,a			; $5fe8
	inc a			; $5fe9
	and $0f			; $5fea
	ld (de),a		; $5fec
	ld a,b			; $5fed
	ld hl,_veranFinal_beeForm_targetPositions		; $5fee
	rst_addDoubleIndex			; $5ff1
	ld e,Enemy.var36		; $5ff2
	ldi a,(hl)		; $5ff4
	ld (de),a		; $5ff5
	inc e			; $5ff6
	ld a,(hl)		; $5ff7
	ld (de),a ; [var37]
	ret			; $5ff9

_veranFinal_beeForm_counter2Vals:
	.db $14 $24

_veranFinal_beeForm_targetPositions:
	.db $38 $80
	.db $20 $90
	.db $20 $b8
	.db $38 $c8
	.db $78 $c8
	.db $90 $b8
	.db $90 $90
	.db $78 $80
	.db $38 $70
	.db $20 $60
	.db $20 $38
	.db $38 $28
	.db $78 $28
	.db $90 $38
	.db $90 $60
	.db $78 $70


;;
; @addr{601c}
_veranFinal_moveTowardTargetPosition:
	ld h,d			; $601c
	ld l,Enemy.var36		; $601d
	call _ecom_readPositionVars		; $601f
	sub c			; $6022
	add $02			; $6023
	cp $05			; $6025
	jr nc,++		; $6027
	ldh a,(<hFF8F)	; $6029
	sub b			; $602b
	add $02			; $602c
	cp $05			; $602e
	ret c			; $6030
++
	call _ecom_moveTowardPosition		; $6031
	or d			; $6034
	ret			; $6035

;;
; @param[out]	b	Value from 0-3 corresponding to screen quadrant
; @addr{6036}
_veranFinal_getQuadrant:
	ld b,$00		; $6036
	ldh a,(<hEnemyTargetY)	; $6038
	cp LARGE_ROOM_HEIGHT*16/2			; $603a
	jr c,+			; $603c
	ld b,$02		; $603e
+
	ldh a,(<hEnemyTargetX)	; $6040
	cp LARGE_ROOM_WIDTH*16/2			; $6042
	ret c			; $6044
	inc b			; $6045
	ret			; $6046


; ==============================================================================
; ENEMYID_RAMROCK_ARMS
;
; Variables:
;   subid: ?
;   relatedObj1: ENEMYID_RAMROCK
;   var30: ?
;   var32: Shields (subid 4): x-position relative to ramrock
;   var35: Number of times he's been hit in current phase
;   var36: ?
;   var37: ?
;   var38: Used by bomb phase?
; ==============================================================================
enemyCode05:
	ld e,Enemy.state		; $6047
	ld a,(de)		; $6049
	rst_jumpTable			; $604a
	.dw _ramrockArm_state0
	.dw _ramrockArm_state_stub
	.dw _ramrockArm_state_stub
	.dw _ramrockArm_state_stub
	.dw _ramrockArm_state_stub
	.dw _ramrockArm_state_stub
	.dw _ramrockArm_state_stub
	.dw _ramrockArm_state_stub
	.dw _ramrockArm_state8

_ramrockArm_state0:
	ld e,Enemy.subid		; $605d
	ld a,(de)		; $605f
	and $7f			; $6060
	rst_jumpTable			; $6062
	.dw @initSubid0
	.dw @initSubid0
	.dw @initSubid2
	.dw @initSubid2
	.dw @initSubid4
	.dw @initSubid4

@initSubid0:
	ld a,(de)		; $606f
	ld b,a			; $6070

	ld hl,_ramrockArm_subid0And1XPositions		; $6071
	rst_addAToHl			; $6074
	ld a,(hl)		; $6075
	ld h,d			; $6076
	ld l,Enemy.xh		; $6077
	ld (hl),a		; $6079
	ld l,Enemy.yh		; $607a
	ld (hl),$10		; $607c
	ld l,Enemy.zh		; $607e
	ld (hl),$f9		; $6080

	ld l,Enemy.angle		; $6082
	ld (hl),ANGLE_DOWN		; $6084
	ld l,Enemy.counter1		; $6086
	ld (hl),$08		; $6088
	ld a,$00		; $608a
	add b			; $608c
	call enemySetAnimation		; $608d
	ld a,SPEED_180		; $6090

@commonInit:
	call _ecom_setSpeedAndState8		; $6092
	jp objectSetVisiblec0		; $6095

@initSubid2:
	ld a,(de)		; $6098
	add $02 ; [subid]
	call enemySetAnimation		; $609b
	call _ramrockArm_setRelativePosition		; $609e
	ld l,Enemy.zh		; $60a1
	ld (hl),$81		; $60a3
	jr @commonInit		; $60a5

@initSubid4:
	ld a,(de)		; $60a7
	sub $04			; $60a8
	ld b,a			; $60aa
	ld hl,_ramrockArm_subid4And5Angles		; $60ab
	rst_addAToHl			; $60ae
	ld c,(hl)		; $60af

	ld a,b			; $60b0
	ld hl,_ramrockArm_subid4And5XPositions		; $60b1
	rst_addAToHl			; $60b4
	ld a,(hl)		; $60b5
	ld h,d			; $60b6
	ld l,Enemy.xh		; $60b7
	ldd (hl),a		; $60b9
	dec l			; $60ba
	ld (hl),$4e ; [yh]

	ld l,Enemy.angle		; $60bd
	ld (hl),c		; $60bf
	ld l,Enemy.zh		; $60c0
	ld (hl),$81		; $60c2

	ld l,Enemy.var32		; $60c4
	ld (hl),$04		; $60c6

	ld a,(de) ; [subid]
	add $02			; $60c9
	call enemySetAnimation		; $60cb
	jr @commonInit		; $60ce


_ramrockArm_state_stub:
	ret			; $60d0


_ramrockArm_state8:
	ld e,Enemy.subid		; $60d1
	ld a,(de)		; $60d3
	and $7f			; $60d4
	rst_jumpTable			; $60d6
	.dw _ramrockArm_subid0
	.dw _ramrockArm_subid0
	.dw _ramrockArm_subid2
	.dw _ramrockArm_subid2
	.dw _ramrockArm_subid4
	.dw _ramrockArm_subid4


; "Shields" in first phase
_ramrockArm_subid0:
	ld a,Object.subid		; $60e3
	call objectGetRelatedObject1Var		; $60e5
	ld a,(hl)		; $60e8
	cp $04			; $60e9
	jr nz,@runStates	; $60eb

	ld e,Enemy.var31		; $60ed
	ld a,(de)		; $60ef
	or a			; $60f0
	jr nz,@runStates	; $60f1

	inc a			; $60f3
	ld (de),a		; $60f4
	ld e,Enemy.state2		; $60f5
	ld a,$06		; $60f7
	ld (de),a		; $60f9
	ld a,60		; $60fa
	ld e,Enemy.counter1		; $60fc
	ld (de),a		; $60fe

@runStates:
	ld e,Enemy.state2		; $60ff
	ld a,(de)		; $6101
	rst_jumpTable			; $6102
	.dw _ramrockArm_subid0_substate0
	.dw _ramrockArm_subid0_substate1
	.dw _ramrockArm_subid0_substate2
	.dw _ramrockArm_subid0_substate3
	.dw _ramrockArm_subid0_substate4
	.dw _ramrockArm_subid0_substate5
	.dw _ramrockArm_subid0_substate6


_ramrockArm_subid0_substate0:
	call enemyAnimate		; $6111
	call objectApplySpeed		; $6114
	call _ecom_decCounter1		; $6117
	ret nz			; $611a

	ld (hl),$08 ; [counter1]
	ld e,Enemy.subid		; $611d
	ld a,(de)		; $611f
	or a			; $6120
	jr nz,+			; $6121
	dec a			; $6123
+
	ld l,Enemy.angle		; $6124
	add (hl)		; $6126
	and $1f			; $6127
	ld (hl),a		; $6129
	and $0f			; $612a
	cp $08			; $612c
	ret nz			; $612e

	; Angle is now directly left or right
	ld l,Enemy.state2		; $612f
	inc (hl)		; $6131
	ld l,Enemy.subid		; $6132
	ld b,(hl)		; $6134
	ld l,Enemy.relatedObj1+1		; $6135
	ld h,(hl)		; $6137
	ld l,Enemy.subid		; $6138
	inc (hl)		; $613a
	ld a,$02		; $613b
	add b			; $613d
	jp enemySetAnimation		; $613e


_ramrockArm_subid0_substate1:
	call enemyAnimate		; $6141
	call _ramrockArm_setRelativePosition		; $6144
	ld l,Enemy.relatedObj1+1		; $6147
	ld h,(hl)		; $6149
	ld l,Enemy.subid		; $614a
	ld a,$03		; $614c
	cp (hl)			; $614e
	ret nz			; $614f
	jr _ramrockArm_subid0_moveBackToRamrock		; $6150


_ramrockArm_subid0_substate2:
	call enemyAnimate		; $6152
	call _ramrockArm_setRelativePosition		; $6155
	call _ecom_decCounter2		; $6158
	ret nz			; $615b

	ld b,$04		; $615c
	call objectCheckCenteredWithLink		; $615e
	ret nc			; $6161
	call objectGetAngleTowardLink		; $6162
	cp $10			; $6165
	ret nz			; $6167

	call _ecom_incState2		; $6168
	ld l,Enemy.angle		; $616b
	ld (hl),a		; $616d
	ld l,Enemy.counter1		; $616e
	ld (hl),$06		; $6170
	ld l,Enemy.var30		; $6172
	ld (hl),$00		; $6174
	ld l,Enemy.speed		; $6176
	ld (hl),SPEED_100		; $6178
	ld l,Enemy.subid		; $617a
	ld a,$00		; $617c
	add (hl)		; $617e
	call enemySetAnimation		; $617f
	ld a,SND_BIGSWORD		; $6182
	jp playSound		; $6184


_ramrockArm_subid0_substate3:
	call objectApplySpeed		; $6187
	ld e,Enemy.var2a		; $618a
	ld a,(de)		; $618c
	cp $80|ITEMCOLLISION_LINK
	jr z,_ramrockArm_subid0_moveBackToRamrock	; $618f
	cp $80|ITEMCOLLISION_L1_SWORD
	jr z,@sword	; $6193
	cp $80|ITEMCOLLISION_L2_SWORD
	jr z,@sword	; $6197
	cp $80|ITEMCOLLISION_L3_SWORD
	jr nz,@moveTowardLink	; $619b

@sword:
	ld e,Enemy.state2		; $619d
	ld a,$05		; $619f
	ld (de),a		; $61a1

	ld a,SPEED_200		; $61a2
	ld e,Enemy.speed		; $61a4
	ld (de),a		; $61a6
	ld e,Enemy.angle		; $61a7
	ld a,(de)		; $61a9
	xor $10			; $61aa
	ld (de),a		; $61ac
	ret			; $61ad

@moveTowardLink:
	call _ecom_getSideviewAdjacentWallsBitset		; $61ae
	jr nz,_ramrockArm_subid0_moveBackToRamrock	; $61b1
	call _ecom_decCounter1		; $61b3
	ret nz			; $61b6
	ld (hl),$06		; $61b7
	call objectGetAngleTowardLink		; $61b9
	jp objectNudgeAngleTowards		; $61bc


_ramrockArm_subid0_moveBackToRamrock:
	ld e,Enemy.state2		; $61bf
	ld a,$04		; $61c1
	ld (de),a		; $61c3
	ld e,Enemy.speed		; $61c4
	ld a,SPEED_180		; $61c6
	ld (de),a		; $61c8

_ramrockArm_subid0_setAngleTowardRamrock:
	call _ramrockArm_getRelativePosition		; $61c9
	call objectGetRelativeAngle		; $61cc
	ld e,Enemy.angle		; $61cf
	ld (de),a		; $61d1
	ret			; $61d2


; Moving back towards Ramrock
_ramrockArm_subid0_substate4:
	call objectApplySpeed		; $61d3
	call _ramrockArm_subid0_setAngleTowardRamrock		; $61d6
	call _ramrockArm_subid0_checkReachedRamrock		; $61d9
	ret nz			; $61dc
	ld a,SND_BOMB_LAND		; $61dd
	call playSound		; $61df
	ld e,Enemy.state2		; $61e2
	ld a,$02		; $61e4
	ld (de),a		; $61e6
	ld e,Enemy.counter2		; $61e7
	ld a,60		; $61e9
	ld (de),a		; $61eb
	ld e,Enemy.subid		; $61ec
	ld a,(de)		; $61ee
	add $02			; $61ef
	jp enemySetAnimation		; $61f1


; Being knocked back after hit by sword
_ramrockArm_subid0_substate5:
	call enemyAnimate		; $61f4
	ld e,Enemy.var30		; $61f7
	ld a,(de)		; $61f9
	or a			; $61fa
	jr nz,@noDamage	; $61fb
	ld a,Object.start		; $61fd
	call objectGetRelatedObject1Var		; $61ff
	call checkObjectsCollided		; $6202
	jr nc,@noDamage	; $6205

	ld e,Enemy.var30		; $6207
	ld a,$01		; $6209
	ld (de),a		; $620b

	ld l,Enemy.invincibilityCounter		; $620c
	ld a,(hl)		; $620e
	or a			; $620f
	jr nz,@noDamage	; $6210

	ld (hl),60		; $6212
	ld l,Enemy.var35		; $6214
	inc (hl)		; $6216
	ld a,SND_BOSS_DAMAGE		; $6217
	call playSound		; $6219

@noDamage:
	xor a			; $621c
	call _ecom_getSideviewAdjacentWallsBitset		; $621d
	jp z,objectApplySpeed		; $6220

	ld e,Enemy.animParameter		; $6223
	ld a,(de)		; $6225
	or a			; $6226
	ret z			; $6227
	jr _ramrockArm_subid0_moveBackToRamrock		; $6228


_ramrockArm_subid0_substate6:
	ld e,Enemy.subid		; $622a
	ld a,(de)		; $622c
	add $04			; $622d
	ld b,a			; $622f
	ld a,Object.subid		; $6230
	call objectGetRelatedObject1Var		; $6232
	ld a,(hl)		; $6235
	cp b			; $6236
	ret nz			; $6237
	call _ecom_decCounter1		; $6238
	ret nz			; $623b

	call objectCreatePuff		; $623c
	ld a,Object.subid		; $623f
	call objectGetRelatedObject1Var		; $6241
	inc (hl)		; $6244
	jp _ramrockArm_deleteSelf		; $6245


; Bomb grabber hands
_ramrockArm_subid2:
	ld e,Enemy.state2		; $6248
	ld a,(de)		; $624a
	rst_jumpTable			; $624b
	.dw _ramrockArm_subid2_substate0
	.dw _ramrockArm_subid2_substate1
	.dw _ramrockArm_subid2_substate2

_ramrockArm_subid2_substate0:
	ld c,$10		; $6252
	call objectUpdateSpeedZ_paramC		; $6254
	ret nz			; $6257

	ld a,Object.subid		; $6258
	call objectGetRelatedObject1Var		; $625a
	ld (hl),$07		; $625d

	ld a,SND_SCENT_SEED		; $625f
	call playSound		; $6261
	jp _ecom_incState2		; $6264

_ramrockArm_subid2_substate1:
	ld a,Object.subid		; $6267
	call objectGetRelatedObject1Var		; $6269
	ld a,(hl)		; $626c
	cp $08			; $626d
	ret nz			; $626f

	ld h,d			; $6270
	ld a,(hl)		; $6271
	rrca			; $6272
	jr c,_ramrockArm_deleteSelf	; $6273

	ld l,Enemy.visible		; $6275
	res 7,(hl)		; $6277
	jp _ecom_incState2		; $6279

_ramrockArm_subid2_substate2:
	call _ramrockArm_subid2_copyRamrockPosition		; $627c
	ld l,Enemy.collisionType		; $627f
	res 7,(hl)		; $6281

	ld a,Object.subid		; $6283
	call objectGetRelatedObject1Var		; $6285
	ld a,(hl)		; $6288
	cp $0a			; $6289
	jr z,@relatedSubid0a	; $628b
	cp $09			; $628d
	ret nz			; $628f

@relatedSubid09:
	ld h,d			; $6290
	ld l,Enemy.collisionType		; $6291
	set 7,(hl)		; $6293

	ld c,ITEMID_BOMB		; $6295
	call findItemWithID		; $6297
	ret nz			; $629a

	ld l,Item.yh		; $629b
	ld b,(hl)		; $629d
	ld l,Item.xh		; $629e
	ld c,(hl)		; $62a0
	push hl			; $62a1
	ld e,$06		; $62a2
	call _ramrockArm_checkPositionAtRamrock		; $62a4
	pop hl			; $62a7
	ret nz			; $62a8

	ld l,Item.zh		; $62a9
	ld a,(hl)		; $62ab
	or a			; $62ac
	jr z,++			; $62ad
	cp $fc			; $62af
	ret c			; $62b1
++
	; Bomb is close enough
	ld l,Item.var2f		; $62b2
	set 4,(hl) ; Delete bomb

	ld a,Object.invincibilityCounter		; $62b6
	call objectGetRelatedObject1Var		; $62b8
	ld a,(hl)		; $62bb
	or a			; $62bc
	ret nz			; $62bd
	ld (hl),60		; $62be
	ld l,Enemy.var35		; $62c0
	inc (hl)		; $62c2
	ret			; $62c3

; Time to die
@relatedSubid0a:
	ld e,Enemy.subid		; $62c4
	ld a,$01		; $62c6
	ld (de),a		; $62c8
@nextPuff:
	call getFreeInteractionSlot		; $62c9
	ld (hl),INTERACID_PUFF		; $62cc
	push hl			; $62ce
	call _ramrockArm_setRelativePosition		; $62cf
	pop hl			; $62d2
	call objectCopyPosition		; $62d3
	ld e,Enemy.subid		; $62d6
	ld a,(de)		; $62d8
	dec a			; $62d9
	ld (de),a		; $62da
	jr z,@nextPuff	; $62db

	ld a,$02		; $62dd
	ld (de),a ; [this.subid]

_ramrockArm_deleteSelf:
	call decNumEnemies		; $62e0
	jp enemyDelete		; $62e3


; Shield hands
_ramrockArm_subid4:
	ld e,Enemy.state2		; $62e6
	ld a,(de)		; $62e8
	rst_jumpTable			; $62e9
	.dw _ramrockArm_subid4_substate0
	.dw _ramrockArm_subid4_substate1
	.dw _ramrockArm_subid4_substate2
	.dw _ramrockArm_subid4_substate3


_ramrockArm_subid4_substate0:
	ld c,$10		; $62f2
	call objectUpdateSpeedZ_paramC		; $62f4
	ret nz			; $62f7
	ld a,$06		; $62f8
	call objectSetCollideRadius		; $62fa
	ld bc,-$80		; $62fd
	call objectSetSpeedZ		; $6300
	ld l,Enemy.speed		; $6303
	ld (hl),SPEED_100		; $6305
	ld l,Enemy.counter2		; $6307
	ld (hl),62		; $6309
	jp _ecom_incState2		; $630b


_ramrockArm_subid4_substate1:
	ld e,Enemy.zh		; $630e
	ld a,(de)		; $6310
	cp $f9			; $6311
	ld c,$00		; $6313
	jp nz,objectUpdateSpeedZ_paramC		; $6315
	call _ecom_decCounter2		; $6318
	jp nz,objectApplySpeed		; $631b

	call _ecom_incState2		; $631e
	ld e,Enemy.subid		; $6321
	ld a,(de)		; $6323
	rrca			; $6324
	ret nc			; $6325

	ld a,Object.subid		; $6326
	call objectGetRelatedObject1Var		; $6328
	ld (hl),$0c		; $632b

	ld a,PALH_84		; $632d
	jp loadPaletteHeader		; $632f


_ramrockArm_subid4_substate2:
	ld a,Object.state2		; $6332
	call objectGetRelatedObject1Var		; $6334
	ld a,(hl)		; $6337
	dec a			; $6338
	jr z,@updateXPosition	; $6339

	ld e,Enemy.var2a		; $633b
	ld a,(de)		; $633d
	rlca			; $633e
	jr c,_ramrockArm_subid4_collisionOccurred	; $633f

	ld a,$02		; $6341
	call objectGetRelatedObject1Var		; $6343
	ld a,(hl)		; $6346
	cp $0d			; $6347
	jr z,_ramrockArm_subid4_collisionOccurred	; $6349

	cp $10			; $634b
	jr nz,@updateXPosition	; $634d

	call objectCreatePuff		; $634f
	jr _ramrockArm_deleteSelf		; $6352

@updateXPosition:
	ld e,Enemy.var32		; $6354
	ld a,(de)		; $6356
	ld b,a			; $6357
	cp $0c			; $6358
	jr z,_ramrockArm_subid4_updateXPosition			; $635a
	inc a			; $635c
	ld (de),a		; $635d
	ld b,a			; $635e

; @param	b	X-offset
_ramrockArm_subid4_updateXPosition:
	ld e,Enemy.subid		; $635f
	ld a,(de)		; $6361
	rrca			; $6362
	jr c,++			; $6363
	ld a,b			; $6365
	cpl			; $6366
	inc a			; $6367
	ld b,a			; $6368
++
	ld a,Object.xh		; $6369
	call objectGetRelatedObject1Var		; $636b
	ld a,(hl)		; $636e
	add b			; $636f
	ld e,l			; $6370
	ld (de),a		; $6371
	ret			; $6372

_ramrockArm_subid4_collisionOccurred:
	ld a,Object.subid		; $6373
	call objectGetRelatedObject1Var		; $6375
	ld (hl),Object.xh		; $6378
	ld l,Enemy.var36		; $637a
	ld (hl),$10		; $637c
	jp _ecom_incState2		; $637e


_ramrockArm_subid4_substate3:
	ld e,Enemy.var2a		; $6381
	ld a,(de)		; $6383
	rlca			; $6384
	jr nc,++		; $6385

	ld a,Object.var36		; $6387
	call objectGetRelatedObject1Var		; $6389
	ld (hl),$10		; $638c
++
	ld e,Enemy.var32		; $638e
	ld a,(de)		; $6390
	sub $02			; $6391
	cp $04			; $6393
	jr nc,+			; $6395
	ld b,$04		; $6397
	jr ++			; $6399
+
	ld (de),a		; $639b
	ld b,a			; $639c
	jr _ramrockArm_subid4_updateXPosition		; $639d
++
	ld a,Object.subid		; $639f
	call objectGetRelatedObject1Var		; $63a1
	ld a,(hl)		; $63a4
	cp $0d			; $63a5
	jr z,_ramrockArm_subid4_updateXPosition	; $63a7

	ld e,Enemy.state2		; $63a9
	ld a,$02		; $63ab
	ld (de),a		; $63ad
	jr _ramrockArm_subid4_updateXPosition		; $63ae


;;
; @addr{63b0}
_ramrockArm_setRelativePosition:
	call _ramrockArm_getRelativePosition		; $63b0
	ld h,d			; $63b3
	ld l,Enemy.yh		; $63b4
	ld (hl),b		; $63b6
	ld l,Enemy.xh		; $63b7
	ld (hl),c		; $63b9
	ret			; $63ba

;;
; @param[out]	zflag
; @addr{63bb}
_ramrockArm_subid0_checkReachedRamrock:
	call _ramrockArm_getRelativePosition		; $63bb
	ld e,$02		; $63be

;;
; @param	bc	Position
; @param	e
; @addr{63c0}
_ramrockArm_checkPositionAtRamrock:
	ld h,d			; $63c0
	ld l,Enemy.yh		; $63c1
	ld a,e			; $63c3
	add b			; $63c4
	cp (hl)			; $63c5
	jr c,_label_10_212	; $63c6
	sub e			; $63c8
_label_10_211:
	sub e			; $63c9
	cp (hl)			; $63ca
	jr nc,_label_10_212	; $63cb
	ld l,Enemy.xh		; $63cd
	ld a,e			; $63cf
	add c			; $63d0
	cp (hl)			; $63d1
	jr c,_label_10_212	; $63d2
	sub e			; $63d4
	sub e			; $63d5
	cp (hl)			; $63d6
	jr nc,_label_10_212	; $63d7
	xor a			; $63d9
	ret			; $63da
_label_10_212:
	or d			; $63db
	ret			; $63dc

;;
; @param[out]	bc	Relative position
; @addr{63dd}
_ramrockArm_getRelativePosition:
	ld e,Enemy.subid		; $63dd
	ld a,(de)		; $63df
	ld c,$0e		; $63e0
	rrca			; $63e2
	jr nc,+			; $63e3
	ld c,-$0e		; $63e5
+
	ld a,Object.yh		; $63e7
	call objectGetRelatedObject1Var		; $63e9
	ldi a,(hl)		; $63ec
	add $08			; $63ed
	ld b,a			; $63ef
	inc l			; $63f0
	ld a,(hl) ; [object.xh]
	add c			; $63f2
	ld c,a			; $63f3
	ret			; $63f4

;;
; @addr{63f5}
_ramrockArm_subid2_copyRamrockPosition:
	ld a,Object.yh		; $63f5
	call objectGetRelatedObject1Var		; $63f7
	ldi a,(hl)		; $63fa
	add $08			; $63fb
	ld b,a			; $63fd
	inc l			; $63fe
	ld a,(hl)		; $63ff
	ld h,d			; $6400
	ld l,Enemy.xh		; $6401
	ldd (hl),a		; $6403
	dec l			; $6404
	ld (hl),b		; $6405
	ret			; $6406

_ramrockArm_subid0And1XPositions:
	.db $30 $c0

_ramrockArm_subid4And5XPositions:
	.db $37 $b9

_ramrockArm_subid4And5Angles:
	.db $08 $18


; ==============================================================================
; ENEMYID_VERAN_FAIRY
;
; Variables:
;   var03: Attack index
;   var30: Movement pattern index (0-3)
;   var31/var32: Pointer to movement pattern
;   var33/var34: Target position to move to
;   var35: Number from 0-2 based on health (lower means more health)
;   var36: ?
;   var38: Timer to stay still after doing a movement pattern
; ==============================================================================
enemyCode06:
	jr z,@normalStatus	; $640d
	sub ENEMYSTATUS_NO_HEALTH			; $640f
	ret c			; $6411
	jr nz,@justHit	; $6412

	; No health
	ld e,Enemy.invincibilityCounter		; $6414
	ld a,(de)		; $6416
	ret nz			; $6417
	call checkLinkCollisionsEnabled		; $6418
	ret nc			; $641b

	ld a,DISABLE_LINK		; $641c
	ld (wDisabledObjects),a		; $641e
	ld (wMenuDisabled),a		; $6421
	ld h,d			; $6424
	ld l,Enemy.health		; $6425
	inc (hl)		; $6427
	ld l,Enemy.state		; $6428
	ld (hl),$05		; $642a
	inc l			; $642c
	ld (hl),$00 ; [state2]
	ld l,Enemy.counter1		; $642f
	ld (hl),60		; $6431
	jr @normalStatus		; $6433

@justHit:
	call _veranFairy_updateVar35BasedOnHealth		; $6435
	ld hl,_veranFairy_speedTable		; $6438
	rst_addAToHl			; $643b
	ld e,Enemy.speed		; $643c
	ld a,(hl)		; $643e
	ld (de),a		; $643f

@normalStatus:
	ld e,Enemy.state		; $6440
	ld a,(de)		; $6442
	rst_jumpTable			; $6443
	.dw _veranFairy_state0
	.dw _veranFairy_state1
	.dw _veranFairy_state2
	.dw _veranFairy_state3
	.dw _veranFairy_state4
	.dw _veranFairy_state5

_veranFairy_state0:
	ld a,ENEMYID_VERAN_FAIRY		; $6450
	ld (wEnemyIDToLoadExtraGfx),a		; $6452
	call _ecom_incState		; $6455
	ld l,Enemy.counter1		; $6458
	ld (hl),60		; $645a
	ld l,Enemy.speed		; $645c
	ld (hl),SPEED_140		; $645e
	ld l,Enemy.var30		; $6460
	dec (hl)		; $6462
	ld a,$02		; $6463
	call enemySetAnimation		; $6465
	jp objectSetVisible82		; $6468

; Cutscene just prior to fairy form
_veranFairy_state1:
	inc e			; $646b
	ld a,(de)		; $646c
	rst_jumpTable			; $646d
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4
	.dw @substate5
	.dw @substate6
	.dw @substate7
	.dw @substate8
	.dw @substate9
	.dw @substateA
	.dw @substateB
	.dw @substateC

@substate0:
	call _ecom_decCounter1		; $6488
	jp nz,_ecom_flickerVisibility		; $648b
	ld (hl),$08		; $648e
	ld l,e			; $6490
	inc (hl) ; [state2]
	jp objectSetVisible83		; $6492

@substate1:
	call _ecom_decCounter1		; $6495
	ret nz			; $6498
	ld l,e			; $6499
	inc (hl) ; [state2]
	ld bc,TX_560f		; $649b
	jp showText		; $649e

@substate2:
	call _ecom_incState2		; $64a1
	ld l,Enemy.counter1		; $64a4
	ld (hl),30		; $64a6
	ld a,$04		; $64a8
	jp enemySetAnimation		; $64aa

@substate3:
	ld c,$33		; $64ad

@strikeLightningAfterCountdown:
	call _ecom_decCounter1		; $64af
	ret nz			; $64b2
	ld (hl),10 ; [counter1]
	ld l,e			; $64b5
	inc (hl) ; [state2]

@strikeLightning:
	call getFreePartSlot		; $64b7
	ret nz			; $64ba
	ld (hl),PARTID_LIGHTNING		; $64bb
	ld l,Part.yh		; $64bd
	jp setShortPosition_paramC		; $64bf

@substate4:
	ld c,$7b		; $64c2
	jr @strikeLightningAfterCountdown		; $64c4

@substate5:
	ld c,$55		; $64c6
	jr @strikeLightningAfterCountdown		; $64c8

@substate6:
	ld c,$3b		; $64ca
	jr @strikeLightningAfterCountdown		; $64cc

@substate7:
	ld c,$73		; $64ce
	jr @strikeLightningAfterCountdown		; $64d0

@substate8:
	call _ecom_decCounter1		; $64d2
	ret nz			; $64d5
	ld l,e			; $64d6
	inc (hl) ; [state2]
	ld c,$59		; $64d8
	call @strikeLightning		; $64da
	jp fadeoutToWhite		; $64dd

; Remove pillar tiles
@substate9:
	ld b,$0c		; $64e0
	ld hl,@pillarPositions		; $64e2
@loop
	push bc			; $64e5
	ldi a,(hl)		; $64e6
	ld c,a			; $64e7
	ld a,$a5		; $64e8
	push hl			; $64ea
	call setTile		; $64eb
	pop hl			; $64ee
	pop bc			; $64ef
	dec b			; $64f0
	jr nz,@loop	; $64f1
	jp _ecom_incState2		; $64f3

@pillarPositions:
	.db $23 $33 $63 $73 $45 $55 $49 $59
	.db $2b $3b $6b $7b

; Spawn mimics
@substateA:
	ld b,$04		; $6502
	ld hl,@mimicPositions		; $6504

@nextMimic:
	ldi a,(hl)		; $6507
	ld c,a			; $6508
	push hl			; $6509
	call getFreeEnemySlot		; $650a
	jr nz,++		; $650d
	ld (hl),ENEMYID_LINK_MIMIC		; $650f
	ld l,Enemy.yh		; $6511
	call setShortPosition_paramC		; $6513
++
	pop hl			; $6516
	dec b			; $6517
	jr nz,@nextMimic	; $6518

	call _ecom_incState2		; $651a
	ld l,Enemy.counter1		; $651d
	ld (hl),30		; $651f

	ld l,Enemy.oamFlagsBackup		; $6521
	xor a			; $6523
	ldi (hl),a		; $6524
	ld (hl),a		; $6525

	ld l,Enemy.zh		; $6526
	dec (hl)		; $6528
	call objectSetVisible83		; $6529
	ld a,$05		; $652c
	call enemySetAnimation		; $652e
	ld a,$04		; $6531
	jp fadeinFromWhiteWithDelay		; $6533

@mimicPositions:
	.db $33 $73 $3b $7b

@substateB:
	ld a,(wPaletteThread_mode)		; $653a
	or a			; $653d
	ret nz			; $653e
	call _ecom_decCounter1		; $653f
	ret nz			; $6542
	ld l,e			; $6543
	inc (hl)		; $6544
	ld bc,TX_5610		; $6545
	jp showText		; $6548

@substateC:
	ld h,d			; $654b
	ld l,Enemy.state		; $654c
	inc (hl)		; $654e
	ld l,Enemy.counter2		; $654f
	ld (hl),120		; $6551
	jp _enemyBoss_beginBoss		; $6553


; Choosing a movement pattern and attack
_veranFairy_state2:
	call getRandomNumber_noPreserveVars		; $6556
	and $07			; $6559
	ld b,a			; $655b
	ld e,Enemy.var35		; $655c
	ld a,(de)		; $655e
	swap a			; $655f
	rrca			; $6561
	add b			; $6562
	ld hl,_veranFairy_attackTable		; $6563
	rst_addAToHl			; $6566
	ld e,Enemy.var03		; $6567
	ld a,(hl)		; $6569
	ld (de),a		; $656a

	call _ecom_incState		; $656b
	ld l,Enemy.var38		; $656e
	ld (hl),60		; $6570
	ld l,Enemy.var36		; $6572
	ld (hl),$00		; $6574
--
	call getRandomNumber		; $6576
	and $03			; $6579
	ld l,Enemy.var30		; $657b
	cp (hl)			; $657d
	jr z,--			; $657e
	ld (hl),a		; $6580

	ld hl,_veranFairy_movementPatternTable		; $6581
	rst_addDoubleIndex			; $6584
	ldi a,(hl)		; $6585
	ld h,(hl)		; $6586
	ld l,a			; $6587
	ld e,Enemy.var33		; $6588
	ldi a,(hl)		; $658a
	ld (de),a		; $658b
	inc e			; $658c
	ldi a,(hl) ; [var34]
	ld (de),a		; $658e

_veranFairy_saveMovementPatternPointer:
	ld e,Enemy.var31		; $658f
	ld a,l			; $6591
	ld (de),a		; $6592
	inc e			; $6593
	ld a,h			; $6594
	ld (de),a		; $6595
	ret			; $6596


; Moving and attacking
_veranFairy_state3:
	call _veranFairy_66ed		; $6597

	ld h,d			; $659a
	ld l,Enemy.var33		; $659b
	call _ecom_readPositionVars		; $659d
	sub c			; $65a0
	add $02			; $65a1
	cp $05			; $65a3
	jr nc,@updateMovement	; $65a5
	ldh a,(<hFF8F)	; $65a7
	sub b			; $65a9
	add $02			; $65aa
	cp $05			; $65ac
	jr nc,@updateMovement	; $65ae

	; Reached target position
	ld l,Enemy.yh		; $65b0
	ld (hl),b		; $65b2
	ld l,Enemy.xh		; $65b3
	ld (hl),c		; $65b5
	call _veranFairy_checkLoopAroundScreen		; $65b6

	; Get next target position
	ld h,d			; $65b9
	ld l,Enemy.var31		; $65ba
	ldi a,(hl)		; $65bc
	ld h,(hl)		; $65bd
	ld l,a			; $65be
	ldi a,(hl)		; $65bf
	or a			; $65c0
	jr nz,++			; $65c1
	ld a,$05		; $65c3
	call enemySetAnimation		; $65c5
	jp _ecom_incState		; $65c8
++
	ld e,Enemy.var33		; $65cb
	ld (de),a		; $65cd
	ld b,a			; $65ce
	inc e			; $65cf
	ldi a,(hl)		; $65d0
	ld (de),a ; [var34]
	ld c,a			; $65d2
	call _veranFairy_saveMovementPatternPointer		; $65d3
@updateMovement:
	call _ecom_moveTowardPosition		; $65d6
_veranFairy_animate:
	jp enemyAnimate		; $65d9


_veranFairy_state4:
	ld h,d			; $65dc
	ld l,Enemy.var38		; $65dd
	dec (hl)		; $65df
	jr nz,_veranFairy_animate	; $65e0
	ld l,e			; $65e2
	ld (hl),$02 ; [state]
	jr _veranFairy_animate		; $65e5


; Dead
_veranFairy_state5:
	inc e			; $65e7
	ld a,(de)		; $65e8
	rst_jumpTable			; $65e9
	.dw @substate0
	.dw @substate1
	.dw @substate2

@substate0:
	call _ecom_decCounter1		; $65f0
	jp nz,_ecom_flickerVisibility		; $65f3
	ld l,e			; $65f6
	inc (hl)		; $65f7
	jp objectSetVisible82		; $65f8

@substate1:
	call _ecom_incState2		; $65fb
	ld l,Enemy.counter2		; $65fe
	ld (hl),65		; $6600
	ld bc,TX_5612		; $6602
	jp showText		; $6605

@substate2:
	call _ecom_decCounter2		; $6608
	jr z,@triggerCutscene	; $660b

	ld a,(hl) ; [counter2]
	and $0f			; $660e
	ret nz			; $6610
	ld a,(hl) ; [counter2]
	and $f0			; $6612
	swap a			; $6614
	dec a			; $6616
	push af			; $6617
	dec a			; $6618
	call z,fadeoutToWhite		; $6619
	pop af			; $661c
	ld hl,@explosionPositions		; $661d
	rst_addDoubleIndex			; $6620
	ldi a,(hl)		; $6621
	ld c,(hl)		; $6622
	ld b,a			; $6623
	call getFreeInteractionSlot		; $6624
	ret nz			; $6627
	ld (hl),INTERACID_EXPLOSION		; $6628
	ld l,Interaction.var03		; $662a
	inc (hl) ; [explosion.var03] = $01
	jp objectCopyPositionWithOffset		; $662d

@triggerCutscene:
	ld a,(wPaletteThread_mode)		; $6630
	or a			; $6633
	ret nz			; $6634
	call clearAllParentItems		; $6635
	call dropLinkHeldItem		; $6638
	ld a,CUTSCENE_BLACK_TOWER_ESCAPE_ATTEMPT		; $663b
	ld (wCutsceneTrigger),a		; $663d
	jp enemyDelete		; $6640

@explosionPositions:
	.db $f0 $f0
	.db $10 $08
	.db $f8 $04
	.db $08 $f8


; BUG(?): $00 acts as a terminator, but it's also used as a position value, meaning one movement
; pattern stops early? (Doesn't apply if $00 is in the first row.)
_veranFairy_movementPatternTable:
	.dw @pattern0
	.dw @pattern1
	.dw @pattern2
	.dw @pattern3

@pattern0:
	.db $00 $78
	.db $00 $f7 ; Terminates early here?
	.db $c0 $e0
	.db $58 $78
	.db $00
@pattern1:
	.db $00 $f7
	.db $58 $78
	.db $58 $f7
	.db $c0 $f7
	.db $58 $78
	.db $00
@pattern2:
	.db $58 $f7
	.db $30 $f7
	.db $c0 $38
	.db $c0 $b8
	.db $58 $78
	.db $00
@pattern3:
	.db $00 $f7
	.db $c0 $f7
	.db $10 $f7
	.db $90 $f7
	.db $58 $78
	.db $00


_veranFairy_attackTable:
	.db $00 $00 $00 $00 $00 $00 $01 $01 ; High health
	.db $00 $00 $00 $00 $00 $01 $01 $02 ; Mid health
	.db $00 $00 $01 $01 $01 $02 $02 $02 ; Low health


_veranFairy_speedTable:
	.db SPEED_140, SPEED_1c0, SPEED_200

;;
; @addr{6698}
_veranFairy_checkLoopAroundScreen:
	call objectGetShortPosition		; $6698
	ld e,a			; $669b
	ld hl,@data1		; $669c
	call lookupKey		; $669f
	ret nc			; $66a2

	ld hl,@data2		; $66a3
	rst_addAToHl			; $66a6
	ld e,Enemy.yh		; $66a7
	ldi a,(hl)		; $66a9
	ld (de),a		; $66aa
	ldh (<hFF8F),a	; $66ab
	ld e,Enemy.xh		; $66ad
	ld a,(hl)		; $66af
	ld (de),a		; $66b0
	ldh (<hFF8E),a	; $66b1
	ret			; $66b3

@data1:
	.db $07 $00
	.db $0f $02
	.db $1f $04
	.db $3f $06
	.db $5f $08
	.db $9f $0a
	.db $c3 $0c
	.db $cb $0a
	.db $ce $0e
	.db $cf $00
	.db $00

@data2:
	.db $c0 $00
	.db $00 $00
	.db $90 $00
	.db $00 $38
	.db $30 $00
	.db $58 $00
	.db $00 $b8
	.db $c0 $78

;;
; @param[out]	a	Value written to var35
; @addr{66d9}
_veranFairy_updateVar35BasedOnHealth:
	ld b,$00		; $66d9
	ld e,Enemy.health		; $66db
	ld a,(de)		; $66dd
	cp 20			; $66de
	jr nc,++		; $66e0
	inc b			; $66e2
	cp 10			; $66e3
	jr nc,++		; $66e5
	inc b			; $66e7
++
	ld e,Enemy.var35		; $66e8
	ld a,b			; $66ea
	ld (de),a		; $66eb
	ret			; $66ec

;;
; @addr{66ed}
_veranFairy_66ed:
	call _ecom_decCounter2		; $66ed
	ret nz			; $66f0
	ld e,Enemy.var03		; $66f1
	ld a,(de)		; $66f3
	rst_jumpTable			; $66f4
	.dw attack0
	.dw attack1
	.dw attack2

; Shooting occasional projectiles
attack0:
	ld e,Enemy.var36		; $66fb
	ld a,(de)		; $66fd
	or a			; $66fe
	jr nz,@label_10_227	; $66ff

	call getRandomNumber_noPreserveVars		; $6701
	and $0f			; $6704
	ld b,a			; $6706
	ld h,d			; $6707
	ld l,Enemy.var35		; $6708
	ld a,(hl)		; $670a
	add a			; $670b
	add $08			; $670c
	cp b			; $670e
	ld l,Enemy.counter2		; $670f
	ld (hl),60		; $6711
	ret nc			; $6713

	xor a			; $6714
	ldd (hl),a		; $6715
	inc a			; $6716
	ld (hl),a		; $6717
	ld l,Enemy.var36		; $6718
	ld (hl),a		; $671a
	ld l,Enemy.var37		; $671b
	ld (hl),$04		; $671d

@label_10_227:
	call _ecom_decCounter1		; $671f
	jr z,@label_10_228	; $6722
	ld a,(hl)		; $6724
	cp $0e			; $6725
	ret nz			; $6727
	ld a,$05		; $6728
	jp enemySetAnimation		; $672a

@label_10_228:
	call _veranFairy_checkWithinBoundary		; $672d
	ret nc			; $6730
	ld l,Enemy.var37		; $6731
	dec (hl)		; $6733
	jr z,@label_10_229	; $6734

	ld l,Enemy.counter1		; $6736
	ld (hl),30		; $6738

	ld b,PARTID_2d		; $673a
	call _ecom_spawnProjectile		; $673c
	ld a,$06		; $673f
	jp enemySetAnimation		; $6741

@label_10_229:
	ld l,Enemy.counter2		; $6744
	ld (hl),90		; $6746
	ld l,Enemy.var36		; $6748
	ld (hl),$00		; $674a
	ret			; $674c

; Circular projectile attack
attack1:
	ld e,Enemy.var36		; $674d
	ld a,(de)		; $674f
	or a			; $6750
	jr nz,@label_10_230	; $6751

	call _veranFairy_checkWithinBoundary		; $6753
	ret nc			; $6756

	call getRandomNumber_noPreserveVars		; $6757
	and $0f			; $675a
	ld b,a			; $675c
	ld h,d			; $675d
	ld l,Enemy.var35		; $675e
	ld a,(hl)		; $6760
	add a			; $6761
	add $06			; $6762
	cp b			; $6764
	ld l,Enemy.counter2		; $6765
	ld (hl),90		; $6767
	ret nc			; $6769

	ld (hl),$00 ; [counter2]
	dec l			; $676c
	ld (hl),180 ; [counter1]
	ld l,Enemy.var36		; $676f
	ld (hl),$01		; $6771

	ld b,PARTID_VERAN_PROJECTILE		; $6773
	call _ecom_spawnProjectile		; $6775
	ld a,$06		; $6778
	call enemySetAnimation		; $677a

@label_10_230:
	pop hl			; $677d
	call _ecom_decCounter1		; $677e
	jp nz,enemyAnimate		; $6781

	inc l			; $6784
	ld (hl),120 ; [counter2]
	ld l,Enemy.var36		; $6787
	ld (hl),$00		; $6789
	ld a,$05		; $678b
	jp enemySetAnimation		; $678d

; Baby ball attack
attack2:
	ld h,d			; $6790
	ld l,Enemy.var36		; $6791
	bit 0,(hl)		; $6793
	jr nz,@label_10_231	; $6795

	call _veranFairy_checkWithinBoundary		; $6797
	ret nc			; $679a

	ld (hl),$01		; $679b
	ld l,Enemy.counter1		; $679d
	ld (hl),30		; $679f
	ld b,PARTID_BABY_BALL		; $67a1
	call _ecom_spawnProjectile		; $67a3
	ld a,$06		; $67a6
	call enemySetAnimation		; $67a8

@label_10_231:
	pop hl			; $67ab
	call _ecom_decCounter1		; $67ac
	jp nz,enemyAnimate		; $67af

	inc l			; $67b2
	ld (hl),$f0		; $67b3
	ld l,Enemy.var36		; $67b5
	ld (hl),$00		; $67b7
	ld a,$05		; $67b9
	jp enemySetAnimation		; $67bb

;;
; @param[out]	cflag	nc if veran is outside the room boundary
; @addr{67be}
_veranFairy_checkWithinBoundary:
	ld e,Enemy.yh		; $67be
	ld a,(de)		; $67c0
	sub $10			; $67c1
	cp $90			; $67c3
	ret nc			; $67c5
	ld e,Enemy.xh		; $67c6
	ld a,(de)		; $67c8
	sub $10			; $67c9
	cp $d0			; $67cb
	ret			; $67cd


; ==============================================================================
; ENEMYID_RAMROCK
;
; Variables:
;   var30: Set to $01 by hands when they collide with ramrock
;   var35: Incremented by hands when hit by bomb?
;   var36: Written to by shield hands?
; ==============================================================================
enemyCode07:
	ld e,Enemy.state		; $67ce
	ld a,(de)		; $67d0
	rst_jumpTable			; $67d1
	.dw _ramrock_state0
	.dw _ramrock_state_stub
	.dw _ramrock_state_stub
	.dw _ramrock_state_stub
	.dw _ramrock_state_stub
	.dw _ramrock_state_stub
	.dw _ramrock_state_stub
	.dw _ramrock_state_stub
	.dw _ramrock_state8
	.dw _ramrock_swordPhase
	.dw _ramrock_bombPhase
	.dw _ramrock_seedPhase
	.dw _ramrock_glovePhase


_ramrock_state0:
	ld a,ENEMYID_RAMROCK		; $67ec
	ld b,PALH_83		; $67ee
	call _enemyBoss_initializeRoom		; $67f0
	ld a,SPEED_100		; $67f3
	call _ecom_setSpeedAndState8		; $67f5
	ld a,$04		; $67f8
	call enemySetAnimation		; $67fa
	ld b,$00		; $67fd
	ld c,$0c		; $67ff
	call _enemyBoss_spawnShadow		; $6801
	jp objectSetVisible81		; $6804


_ramrock_state_stub:
	ret			; $6807


; Cutscene before fight
_ramrock_state8:
	inc e			; $6808
	ld a,(de)		; $6809
	rst_jumpTable			; $680a
	.dw _ramrock_state8_substate0
	.dw _ramrock_state8_substate1
	.dw _ramrock_state8_substate2
	.dw _ramrock_state8_substate3
	.dw _ramrock_state8_substate4
	.dw _ramrock_state8_substate5

_ramrock_state8_substate0:
	ld a,DISABLE_LINK		; $6817
	ld (wDisabledObjects),a		; $6819
	ld (wMenuDisabled),a		; $681c
	ld a,($cc93)		; $681f
	or a			; $6822
	ret nz			; $6823

	ld e,Enemy.stunCounter		; $6824
	ld a,60		; $6826
	ld (de),a		; $6828
	jp _ecom_incState2		; $6829

_ramrock_state8_substate1:
	ld e,Enemy.stunCounter		; $682c
	ld a,(de)		; $682e
	or a			; $682f
	ret nz			; $6830

	ld bc,-$80		; $6831
	call objectSetSpeedZ		; $6834
	ld c,$00		; $6837
	call objectUpdateSpeedZ_paramC		; $6839
	ld e,Enemy.zh		; $683c
	ld a,(de)		; $683e
	cp $f9			; $683f
	ret nz			; $6841

	ld c,$01		; $6842
@spawnArm:
	ld b,ENEMYID_RAMROCK_ARMS		; $6844
	call _ecom_spawnEnemyWithSubid01		; $6846
	ld l,Enemy.subid		; $6849
	ld (hl),c		; $684b
	ld l,Enemy.relatedObj1		; $684c
	ld (hl),Enemy.start		; $684e
	inc l			; $6850
	ld (hl),d		; $6851
	dec c			; $6852
	jr z,@spawnArm	; $6853

	jp _ecom_incState2		; $6855

_ramrock_state8_substate2:
	ld e,Enemy.subid		; $6858
	ld a,(de)		; $685a
	cp $02			; $685b
	ret nz			; $685d
	ld e,Enemy.counter1		; $685e
	ld a,$02		; $6860
	ld (de),a		; $6862
	call _ecom_incState2		; $6863
	ld a,PALH_84		; $6866
	jp loadPaletteHeader		; $6868

_ramrock_state8_substate3:
	call _ecom_decCounter1		; $686b
	ret nz			; $686e
	call _ecom_incState2		; $686f
	ld a,SND_SWORD_OBTAINED		; $6872
	call playSound		; $6874
	ld l,Enemy.subid		; $6877
	inc (hl)		; $6879
	ld a,PALH_83		; $687a
	jp loadPaletteHeader		; $687c

_ramrock_state8_substate4:
	call enemyAnimate		; $687f
	ld e,Enemy.animParameter		; $6882
	ld a,(de)		; $6884
	or a			; $6885
	ret z			; $6886
	call _ecom_incState2		; $6887
	ld l,Enemy.angle		; $688a
	ld (hl),$00		; $688c
	ld a,$00		; $688e
	call enemySetAnimation		; $6890

_ramrock_state8_substate5:
	call enemyAnimate		; $6893
	call objectApplySpeed		; $6896
	ld e,Enemy.yh		; $6899
	ld a,(de)		; $689b
	cp $41			; $689c
	ret nc			; $689e

	; Fight begins
	xor a			; $689f
	ld (wDisabledObjects),a		; $68a0
	ld (wMenuDisabled),a		; $68a3
	call _ecom_incState		; $68a6
	ld l,$89		; $68a9
	ld (hl),$08		; $68ab
	ld l,$82		; $68ad
	ld (hl),$03		; $68af
	ld a,MUS_BOSS		; $68b1
	jp playSound		; $68b3


; "Fist" phase
_ramrock_swordPhase:
	call enemyAnimate		; $68b6
	ld e,Enemy.var35		; $68b9
	ld a,(de)		; $68bb
	cp $03			; $68bc
	jr nc,+			; $68be
	jp _ramrock_updateHorizontalMovement		; $68c0
+
	xor a			; $68c3
	ld (de),a		; $68c4
	ld bc,$0000		; $68c5
	call objectSetSpeedZ		; $68c8
	call _ecom_incState		; $68cb
	inc l			; $68ce
	ld (hl),$00		; $68cf
	ld l,Enemy.subid		; $68d1
	inc (hl)		; $68d3
	ld l,Enemy.counter2		; $68d4
	ld (hl),30		; $68d6
	ld a,$04		; $68d8
	jp enemySetAnimation		; $68da


; "Bomb" phase
_ramrock_bombPhase:
	call @func_68fe		; $68dd

	; Stop movement of any bombs that touch ramrock
	ld c,ITEMID_BOMB		; $68e0
	call findItemWithID		; $68e2
	ret nz			; $68e5
	call checkObjectsCollided		; $68e6
	jr nc,++		; $68e9
	ld l,Item.angle		; $68eb
	ld (hl),$ff		; $68ed
++
	ld c,ITEMID_BOMB		; $68ef
	call findItemWithID_startingAfterH		; $68f1
	ret nz			; $68f4
	call checkObjectsCollided		; $68f5
	ret nc			; $68f8
	ld l,Item.angle		; $68f9
	ld (hl),$ff		; $68fb
	ret			; $68fd

@func_68fe:
	inc e			; $68fe
	ld a,(de)		; $68ff
	rst_jumpTable			; $6900
	.dw _ramrock_bombPhase_substate0
	.dw _ramrock_bombPhase_substate1
	.dw _ramrock_bombPhase_substate2
	.dw _ramrock_bombPhase_substate3
	.dw _ramrock_bombPhase_substate4

_ramrock_bombPhase_substate0:
	ld c,$10		; $690b
	call objectUpdateSpeedZ_paramC		; $690d
	ld e,Enemy.subid		; $6910
	ld a,(de)		; $6912
	cp $06			; $6913
	ret nz			; $6915
	call _ecom_decCounter2		; $6916
	ret nz			; $6919

	; Spawn arms
	ld b,ENEMYID_RAMROCK_ARMS		; $691a
	call _ecom_spawnEnemyWithSubid01		; $691c
	ld l,Enemy.subid		; $691f
	ld (hl),$02		; $6921
	ld l,Enemy.relatedObj1		; $6923
	ld (hl),Enemy.start		; $6925
	inc l			; $6927
	ld (hl),d		; $6928

	ld b,ENEMYID_RAMROCK_ARMS		; $6929
	call _ecom_spawnEnemyWithSubid01		; $692b
	ld l,Enemy.subid		; $692e
	ld (hl),$03		; $6930
	ld l,Enemy.relatedObj1		; $6932
	ld (hl),Enemy.start		; $6934
	inc l			; $6936
	ld (hl),d		; $6937

	jp _ecom_incState2		; $6938

_ramrock_bombPhase_substate1:
	ld e,Enemy.subid		; $693b
	ld a,(de)		; $693d
	cp $07			; $693e
	ret nz			; $6940

	call enemyAnimate		; $6941
	ld e,Enemy.animParameter		; $6944
	ld a,(de)		; $6946
	or a			; $6947
	ret z			; $6948
	ld bc,-$80		; $6949
	call objectSetSpeedZ		; $694c
	ld l,Enemy.subid		; $694f
	ld (hl),$08		; $6951
	ld a,$01		; $6953
	call enemySetAnimation		; $6955
	jp _ecom_incState2		; $6958

_ramrock_bombPhase_substate2:
	ld c,$00		; $695b
	call objectUpdateSpeedZ_paramC		; $695d
	ld e,Enemy.zh		; $6960
	ld a,(de)		; $6962
	cp $f9			; $6963
	ret nz			; $6965

	ld a,SND_SWORD_OBTAINED		; $6966
	call playSound		; $6968

_ramrock_bombPhase_gotoSubstate3:
	ld h,d			; $696b
	ld l,Enemy.counter1		; $696c
	ld a,$04		; $696e
	ldi (hl),a		; $6970
	ld (hl),50 ; [counter2]
	ld l,Enemy.state2		; $6973
	ld (hl),$03		; $6975
	ret			; $6977

_ramrock_bombPhase_substate3:
	ld e,Enemy.var38		; $6978
	ld a,(de)		; $697a
	sub $01			; $697b
	ld (de),a		; $697d
	jr nc,++		; $697e
	ld a,30			; $6980
	ld (de),a		; $6982
	ld a,SND_BEAM1		; $6983
	call playSound		; $6985
++
	ld e,Enemy.var35		; $6988
	ld a,(de)		; $698a
	cp $03			; $698b
	jr nc,_label_10_237	; $698d

	call enemyAnimate		; $698f
	call _ecom_applyVelocityForSideviewEnemy		; $6992
	call _ecom_decCounter2		; $6995
	jr z,_label_10_236	; $6998

	call _ecom_decCounter1		; $699a
	ret nz			; $699d

	ld (hl),$04		; $699e
	call objectGetAngleTowardLink		; $69a0
	jp objectNudgeAngleTowards		; $69a3

_label_10_236:
	call _ecom_incState2		; $69a6
	ld a,$02		; $69a9
	jp enemySetAnimation		; $69ab

_label_10_237:
	call _ecom_incState		; $69ae
	inc l			; $69b1
	xor a			; $69b2
	ld (hl),a		; $69b3
	ld l,Enemy.var35		; $69b4
	ld (hl),a		; $69b6
	ld l,Enemy.subid		; $69b7
	ld (hl),$0a		; $69b9
	ld a,$04		; $69bb
	jp enemySetAnimation		; $69bd

_ramrock_bombPhase_substate4:
	call enemyAnimate		; $69c0
	ld h,d			; $69c3
	ld l,Enemy.subid		; $69c4
	ld (hl),$08		; $69c6
	ld e,Enemy.animParameter		; $69c8
	ld a,(de)		; $69ca
	cp $01			; $69cb
	jr nz,++		; $69cd
	ld l,Enemy.subid		; $69cf
	ld (hl),$09		; $69d1
	ld a,SND_STRONG_POUND		; $69d3
	jp playSound		; $69d5
++
	rla			; $69d8
	ret nc			; $69d9
	ld a,$01		; $69da
	call enemySetAnimation		; $69dc
	jp _ramrock_bombPhase_gotoSubstate3		; $69df


; "Seed" phase
_ramrock_seedPhase:
	ld h,d			; $69e2
	ld l,Enemy.state2		; $69e3
	ld a,(hl)		; $69e5
	or a			; $69e6
	jr z,@runSubstate	; $69e7
	dec a			; $69e9
	jr z,@runSubstate	; $69ea

	ld e,Enemy.var2a		; $69ec
	ld a,(de)		; $69ee
	cp $80|ITEMCOLLISION_MYSTERY_SEED			; $69ef
	jr c,@noSeedCollision	; $69f1
	cp $80|ITEMCOLLISION_GALE_SEED+1			; $69f3
	jr c,@seedCollision	; $69f5

@noSeedCollision:
	rlca			; $69f7
	jr nc,@noCollision	; $69f8

@otherCollision:
	ld l,Enemy.subid		; $69fa
	ld (hl),$0d		; $69fc
	ld l,Enemy.var36		; $69fe
	ld (hl),$10		; $6a00
	jr @runSubstate		; $6a02

@seedCollision:
	ld l,Enemy.invincibilityCounter		; $6a04
	ld a,(hl)		; $6a06
	or a			; $6a07
	jr nz,@otherCollision	; $6a08

	ld (hl),60 ; [invincibilityCounter]
	ld l,Enemy.var35		; $6a0c
	ld a,(hl)		; $6a0e
	cp $03			; $6a0f
	jr z,@seedPhaseEnd	; $6a11

	inc (hl)		; $6a13
	ld a,SND_BOSS_DAMAGE		; $6a14
	call playSound		; $6a16
	jr @runSubstate		; $6a19

@noCollision:
	ld l,Enemy.var36		; $6a1b
	ld a,(hl)		; $6a1d
	or a			; $6a1e
	jr z,@runSubstate	; $6a1f
	dec (hl)		; $6a21
	jr nz,@runSubstate	; $6a22

	ld l,Enemy.subid		; $6a24
	ld (hl),$0c		; $6a26

@runSubstate:
	ld e,Enemy.state2		; $6a28
	ld a,(de)		; $6a2a
	rst_jumpTable			; $6a2b
	.dw _ramrock_seedPhase_substate0
	.dw _ramrock_seedPhase_substate1
	.dw _ramrock_seedPhase_substate2
	.dw _ramrock_seedPhase_substate3
	.dw _ramrock_seedPhase_substate4
	.dw _ramrock_seedPhase_substate5
	.dw _ramrock_seedPhase_substate6

@seedPhaseEnd:
	ld l,Enemy.subid		; $6a3a
	ld (hl),$10		; $6a3c
	call _ecom_incState		; $6a3e
	inc l			; $6a41
	xor a			; $6a42
	ld (hl),a		; $6a43
	ld l,Enemy.var35		; $6a44
	ld (hl),a		; $6a46
	ret			; $6a47

_ramrock_seedPhase_substate0:
	ld h,d			; $6a48
	ld bc,$4878		; $6a49
	ld l,Enemy.yh		; $6a4c
	ldi a,(hl)		; $6a4e
	cp b			; $6a4f
	jr nz,@updateMovement	; $6a50

	inc l			; $6a52
	ld a,(hl)		; $6a53
	cp c			; $6a54
	jr nz,@updateMovement	; $6a55

	ld l,Enemy.subid		; $6a57
	inc (hl)		; $6a59
	ld l,Enemy.counter2		; $6a5a
	ld (hl),$02		; $6a5c

	ld c,$04		; $6a5e
@spawnArm:
	ld b,ENEMYID_RAMROCK_ARMS		; $6a60
	call _ecom_spawnEnemyWithSubid01		; $6a62
	ld l,Enemy.subid		; $6a65
	ld (hl),c		; $6a67
	ld l,Enemy.relatedObj1		; $6a68
	ld (hl),Enemy.start		; $6a6a
	inc l			; $6a6c
	ld (hl),d		; $6a6d
	inc c			; $6a6e
	ld a,c			; $6a6f
	cp $05			; $6a70
	jr z,@spawnArm	; $6a72

	jp _ecom_incState2		; $6a74

@updateMovement:
	call objectGetRelativeAngle		; $6a77
	ld e,Enemy.angle		; $6a7a
	ld (de),a		; $6a7c
	jp objectApplySpeed		; $6a7d

_ramrock_seedPhase_substate1:
	ld e,Enemy.subid		; $6a80
	ld a,(de)		; $6a82
	cp $0c			; $6a83
	ret nz			; $6a85

	ld e,Enemy.counter2		; $6a86
	ld a,(de)		; $6a88
	or a			; $6a89
	jr nz,_label_10_248	; $6a8a

	call enemyAnimate		; $6a8c
	ld e,Enemy.animParameter		; $6a8f
	ld a,(de)		; $6a91
	or a			; $6a92
	ret z			; $6a93

_ramrock_seedPhase_6a94:
	ld e,Enemy.subid		; $6a94
	ld a,$0c		; $6a96
	ld (de),a		; $6a98

_ramrock_seedPhase_resumeNormalMovement:
	ld h,d			; $6a99
	ld l,Enemy.state2		; $6a9a
	ld (hl),$02		; $6a9c
	ld l,Enemy.counter2		; $6a9e
	ld (hl),120		; $6aa0
	ld a,$00		; $6aa2
	jp enemySetAnimation		; $6aa4

_label_10_248:
	call _ecom_decCounter2		; $6aa7
	ret nz			; $6aaa
	ld l,Enemy.angle		; $6aab
	ld (hl),$08		; $6aad
	ld a,PALH_83		; $6aaf
	call loadPaletteHeader		; $6ab1
	ld a,SND_SWORD_OBTAINED		; $6ab4
	jp playSound		; $6ab6

; Moving normally
_ramrock_seedPhase_substate2:
	call enemyAnimate		; $6ab9
	call _ramrock_updateHorizontalMovement		; $6abc

	call getRandomNumber		; $6abf
	rrca			; $6ac2
	ret nc			; $6ac3
	call _ecom_decCounter2		; $6ac4
	ret nz			; $6ac7

	ld e,Enemy.subid		; $6ac8
	ld a,(de)		; $6aca
	cp $0c			; $6acb
	ret nz			; $6acd

	call getRandomNumber		; $6ace
	and $03			; $6ad1
	ld l,e			; $6ad3
	jr z,@gotoNextSubstate	; $6ad4

	ld (hl),$0f ; [counter2]
	ld l,Enemy.state2		; $6ad8
	ld (hl),$06		; $6ada
	ld l,Enemy.counter1		; $6adc
	ld (hl),60		; $6ade

	ld b,PARTID_4f		; $6ae0
	call _ecom_spawnProjectile		; $6ae2
	ld bc,$1000		; $6ae5
	call objectCopyPositionWithOffset		; $6ae8
	jr @setAnimation0		; $6aeb

@gotoNextSubstate:
	ld (hl),$0e		; $6aed
	ld l,Enemy.angle		; $6aef
	ld (hl),$18		; $6af1
	call _ecom_incState2		; $6af3

@setAnimation0:
	ld a,$00		; $6af6
	jp enemySetAnimation		; $6af8

_ramrock_seedPhase_substate3:
	ld e,Enemy.subid		; $6afb
	ld a,(de)		; $6afd
	cp $0e			; $6afe
	jr nz,_ramrock_seedPhase_resumeNormalMovement	; $6b00
	call _ramrock_updateHorizontalMovement		; $6b02
	ret nz			; $6b05

	call _ecom_incState2		; $6b06
	ld l,Enemy.counter1		; $6b09
	ld (hl),180		; $6b0b
	inc l			; $6b0d
	ld (hl),30 ; [counter2]

	ld b,PARTID_34		; $6b10
	call _ecom_spawnProjectile		; $6b12
	ld l,Part.subid		; $6b15
	ld (hl),$0e		; $6b17
	ld bc,$0400		; $6b19
	jp objectCopyPositionWithOffset		; $6b1c

; Firing energy beam
_ramrock_seedPhase_substate4:
	ld e,Enemy.subid		; $6b1f
	ld a,(de)		; $6b21
	cp $0e			; $6b22
	jp nz,_ramrock_seedPhase_resumeNormalMovement		; $6b24

	call _ecom_decCounter2		; $6b27
	ret nz			; $6b2a
	call _ecom_decCounter1		; $6b2b
	jr z,@gotoNextSubstate	; $6b2e

	ld a,(hl)		; $6b30
	and $07			; $6b31
	ld a,SND_SWORDBEAM		; $6b33
	call z,playSound		; $6b35
	jp _ramrock_updateHorizontalMovement		; $6b38

@gotoNextSubstate:
	call _ecom_incState2		; $6b3b
	ld l,Enemy.counter1		; $6b3e
	ld (hl),90		; $6b40
	ld l,Enemy.subid		; $6b42
	ld (hl),$0c		; $6b44

_ramrock_seedPhase_substate5:
	call _ecom_decCounter1		; $6b46
	ret nz			; $6b49
	jp _ramrock_seedPhase_resumeNormalMovement		; $6b4a

_ramrock_seedPhase_substate6:
	ld e,Enemy.subid		; $6b4d
	ld a,(de)		; $6b4f
	cp $0f			; $6b50
	jr nz,++		; $6b52
	call _ecom_decCounter1		; $6b54
	ret nz			; $6b57
++
	jp _ramrock_seedPhase_6a94		; $6b58


; "Bomb" phase
_ramrock_glovePhase:
	inc e			; $6b5b
	ld a,(de)		; $6b5c
	rst_jumpTable			; $6b5d
	.dw _ramrock_glovePhase_substate0
	.dw _ramrock_glovePhase_substate1
	.dw _ramrock_glovePhase_substate2
	.dw _ramrock_glovePhase_substate3
	.dw _ramrock_glovePhase_substate4

_ramrock_glovePhase_substate0:
	ld h,d			; $6b68
	ld bc,$4878		; $6b69
	ld l,Enemy.yh		; $6b6c
	ldi a,(hl)		; $6b6e
	cp b			; $6b6f
	jr nz,@updateMovement	; $6b70

	inc l			; $6b72
	ld a,(hl)		; $6b73
	cp c			; $6b74
	jr nz,@updateMovement	; $6b75
	call _ecom_incState2		; $6b77

	ld bc,$e001		; $6b7a
@spawnArm:
	push bc			; $6b7d
	ld b,PARTID_35		; $6b7e
	call _ecom_spawnProjectile		; $6b80
	ld l,Part.subid		; $6b83
	ld (hl),c		; $6b85
	pop bc			; $6b86
	push bc			; $6b87
	ld c,b			; $6b88
	ld b,$18		; $6b89
	call objectCopyPositionWithOffset		; $6b8b
	pop bc			; $6b8e
	dec c			; $6b8f
	ld a,$04		; $6b90
	jp nz,enemySetAnimation		; $6b92
	ld a,b			; $6b95
	cpl			; $6b96
	inc a			; $6b97
	ld b,a			; $6b98
	jr @spawnArm		; $6b99

@updateMovement:
	call objectGetRelativeAngle		; $6b9b
	ld e,Enemy.angle		; $6b9e
	ld (de),a		; $6ba0
	jp objectApplySpeed		; $6ba1

_ramrock_glovePhase_substate1:
	ld c,$10		; $6ba4
	call objectUpdateSpeedZ_paramC		; $6ba6
	ld e,Enemy.var37		; $6ba9
	ld a,(de)		; $6bab
	cp $03			; $6bac
	ret nz			; $6bae
	call _ecom_incState2		; $6baf
	ld l,Enemy.counter2		; $6bb2
	ld (hl),$02		; $6bb4
	ld a,PALH_84		; $6bb6
	jp loadPaletteHeader		; $6bb8

_ramrock_glovePhase_substate2:
	call _ecom_decCounter2		; $6bbb
	jr z,++			; $6bbe
	ld a,SND_SWORD_OBTAINED		; $6bc0
	call playSound		; $6bc2
	ld a,PALH_83		; $6bc5
	call loadPaletteHeader		; $6bc7
++
	call enemyAnimate		; $6bca
	ld e,Enemy.animParameter		; $6bcd
	ld a,(de)		; $6bcf
	or a			; $6bd0
	ret nz			; $6bd1
	ld a,$03		; $6bd2
	call enemySetAnimation		; $6bd4

_ramrock_glovePhase_gotoSubstate3:
	ld bc,-$80		; $6bd7
	call objectSetSpeedZ		; $6bda
	ld l,Enemy.subid		; $6bdd
	ld (hl),$11		; $6bdf
	ld l,Enemy.state2		; $6be1
	ld (hl),$03		; $6be3
	ld l,Enemy.angle		; $6be5
	ld (hl),$08		; $6be7
	ld l,Enemy.counter2		; $6be9
	ld (hl),120		; $6beb
	ret			; $6bed

_ramrock_glovePhase_substate3:
	call enemyAnimate		; $6bee
	ld e,Enemy.zh		; $6bf1
	ld a,(de)		; $6bf3
	cp $f9			; $6bf4
	ld c,$00		; $6bf6
	call nz,objectUpdateSpeedZ_paramC		; $6bf8

	call _ramrock_glovePhase_updateMovement		; $6bfb
	call _ecom_decCounter2		; $6bfe
	jr nz,_ramrock_glovePhase_reverseDirection	; $6c01

	ld c,$50		; $6c03
	call objectCheckLinkWithinDistance		; $6c05
	jr nc,_ramrock_glovePhase_reverseDirection	; $6c08

	ld h,d			; $6c0a
	ld l,Enemy.subid		; $6c0b
	ld a,$12		; $6c0d
	ldi (hl),a		; $6c0f
	call getRandomNumber		; $6c10
	and $01			; $6c13
	swap a			; $6c15
	ld (hl),a		; $6c17
	call getRandomNumber		; $6c18
	and $0f			; $6c1b
	jr nz,+			; $6c1d
	set 5,(hl)		; $6c1f
+
	ld l,Enemy.state2		; $6c21
	ld (hl),$04		; $6c23
	ret			; $6c25

_ramrock_glovePhase_substate4:
	ld e,Enemy.var35		; $6c26
	ld a,(de)		; $6c28
	cp $03			; $6c29
	jr z,@dead	; $6c2b

	call enemyAnimate		; $6c2d
	ld e,Enemy.var37		; $6c30
	ld a,(de)		; $6c32
	cp $03			; $6c33
	ret nz			; $6c35
	jr _ramrock_glovePhase_gotoSubstate3		; $6c36
		
@dead:
	ld e,Enemy.health		; $6c38
	xor a			; $6c3a
	ld (de),a		; $6c3b
	jp _enemyBoss_dead		; $6c3c

;;
; Moves from side to side of the screen
; @addr{6c3f}
_ramrock_updateHorizontalMovement:
	call _ecom_applyVelocityForSideviewEnemy		; $6c3f
	ret nz			; $6c42
	ld e,Enemy.angle		; $6c43
	ld a,(de)		; $6c45
	xor $10			; $6c46
	ld (de),a		; $6c48
	xor a			; $6c49
	ret			; $6c4a

_ramrock_glovePhase_reverseDirection:
	ld h,d			; $6c4b
	ld l,Enemy.xh		; $6c4c
	ld a,$c0		; $6c4e
	cp (hl)			; $6c50
	jr c,++			; $6c51
	ld a,$28		; $6c53
	cp (hl)			; $6c55
	jr c,@applySpeed	; $6c56
	inc a			; $6c58
++
	ld (hl),a ; [xh]
	ld e,Enemy.angle		; $6c5a
	ld a,(de)		; $6c5c
	xor $10			; $6c5d
	ld (de),a		; $6c5f
	xor a			; $6c60
@applySpeed:
	jp objectApplySpeed		; $6c61

;;
; @addr{6c64}
_ramrock_glovePhase_updateMovement:
	ld hl,w1Link.yh		; $6c64
	ld e,Enemy.yh		; $6c67
	ld a,(de)		; $6c69
	cp (hl)			; $6c6a
	jr nc,@label_10_262	; $6c6b

	ld c,a			; $6c6d
	ld a,(hl)		; $6c6e
	sub c			; $6c6f
	cp $40			; $6c70
	jr z,@ret	; $6c72
	jr c,@label_10_262	; $6c74

	ld a,(de)		; $6c76
	cp $50			; $6c77
	ld c,ANGLE_DOWN		; $6c79
	jr nc,@ret	; $6c7b
	jr @moveInDirection		; $6c7d

@label_10_262:
	ld a,(de) ; [yh]
	cp $41			; $6c80
	ld c,ANGLE_UP		; $6c82
	jr c,@ret	; $6c84

@moveInDirection:
	ld b,SPEED_80		; $6c86
	ld e,Enemy.angle		; $6c88
	call objectApplyGivenSpeed		; $6c8a
@ret:
	ret			; $6c8d


; ==============================================================================
; ENEMYID_KING_MOBLIN_MINION
;
; Variables:
;   relatedObj1: Instance of ENEMYID_KING_MOBLIN
;   relatedObj2: Instance of PARTID_BOMB (smaller bomb thrown by this object)
; ==============================================================================
enemyCode56_body:
	ld e,Enemy.state		; $6c8e
	ld a,(de)		; $6c90
	rst_jumpTable			; $6c91
	.dw _kingMoblinMinion_state0
	.dw enemyAnimate
	.dw _kingMoblinMinion_state2
	.dw _kingMoblinMinion_state3
	.dw _kingMoblinMinion_state4
	.dw _kingMoblinMinion_state5
	.dw _kingMoblinMinion_state6
	.dw _kingMoblinMinion_state7
	.dw _kingMoblinMinion_state8
	.dw _kingMoblinMinion_state9
	.dw _kingMoblinMinion_stateA


_kingMoblinMinion_state0:
	ld h,d			; $6ca8
	ld l,e			; $6ca9
	inc (hl) ; [state] = 1

	ld l,Enemy.speed		; $6cab
	ld (hl),SPEED_200		; $6cad

	ld e,Enemy.subid		; $6caf
	ld a,(de)		; $6cb1
	add a			; $6cb2
	ld hl,@data		; $6cb3
	rst_addDoubleIndex			; $6cb6

	ld e,Enemy.counter1		; $6cb7
	ldi a,(hl)		; $6cb9
	ld (de),a		; $6cba
	ld e,Enemy.direction		; $6cbb
	ldi a,(hl)		; $6cbd
	ld (de),a		; $6cbe
	ld e,Enemy.yh		; $6cbf
	ldi a,(hl)		; $6cc1
	ld (de),a		; $6cc2
	ld e,Enemy.xh		; $6cc3
	ld a,(hl)		; $6cc5
	ld (de),a		; $6cc6

	ld a,$02		; $6cc7
	call enemySetAnimation		; $6cc9
	jp objectSetVisiblec2		; $6ccc

; Data format: counter1, direction, yh, xh
@data:
	.db  30, $03, $08, $18
	.db 150, $01, $08, $88



; Fight just started
_kingMoblinMinion_state2:
	ld h,d			; $6cd7
	ld l,e			; $6cd8
	inc (hl) ; [state] = 3

	ld l,Enemy.counter2		; $6cda
	ld (hl),$0c		; $6cdc
	ld e,Enemy.direction		; $6cde
	ld a,(de)		; $6ce0
	jp enemySetAnimation		; $6ce1


; Delay before spawning bomb
_kingMoblinMinion_state3:
	call _ecom_decCounter2		; $6ce4
	jr nz,_kingMoblinMinion_animate	; $6ce7

	ld b,PARTID_BOMB		; $6ce9
	call _ecom_spawnProjectile		; $6ceb
	ret nz			; $6cee

	call _ecom_incState		; $6cef

	ld a,$02		; $6cf2
	jp enemySetAnimation		; $6cf4


; Holding bomb for a bit
_kingMoblinMinion_state4:
	call _ecom_decCounter1		; $6cf7
	ld l,e			; $6cfa
	jr z,@jump	; $6cfb

	ld a,(wScreenShakeCounterY)		; $6cfd
	or a			; $6d00
	jr z,_kingMoblinMinion_animate	; $6d01

	ld (hl),$07 ; [counter1]
	jr _kingMoblinMinion_animate		; $6d05

@jump:
	inc (hl) ; [state] = 5
	ld l,Enemy.speedZ		; $6d08
	ld a,<(-$180)		; $6d0a
	ldi (hl),a		; $6d0c
	ld (hl),>(-$180)		; $6d0d

_kingMoblinMinion_animate:
	jp enemyAnimate		; $6d0f


; Jumping in air
_kingMoblinMinion_state5:
	ld c,$20		; $6d12
	call objectUpdateSpeedZ_paramC		; $6d14
	jr z,@landed	; $6d17

	; Check for the peak of the jump
	ldd a,(hl)		; $6d19
	or (hl)			; $6d1a
	ret nz			; $6d1b

	call objectGetAngleTowardEnemyTarget		; $6d1c
	ld b,a			; $6d1f

	; [bomb.state]++
	ld a,Object.state		; $6d20
	call objectGetRelatedObject2Var		; $6d22
	inc (hl)		; $6d25

	; Set bomb to move toward Link
	ld l,Part.angle		; $6d26
	ld (hl),b		; $6d28
	ret			; $6d29

@landed:
	ld l,Enemy.state		; $6d2a
	inc (hl) ; [state] = 6

	ld l,Enemy.counter1		; $6d2d
	ld (hl),$10		; $6d2f
	jr _kingMoblinMinion_animate		; $6d31


; Delay before pulling out next bomb
_kingMoblinMinion_state6:
	call _ecom_decCounter1		; $6d33
	jr nz,_kingMoblinMinion_animate	; $6d36

	ld (hl),200 ; [counter1]
	ld l,e			; $6d3a
	ld (hl),$02 ; [state]

	jr _kingMoblinMinion_animate		; $6d3d


; ENEMYID_KING_MOBLIN sets this object's state to 7 when defeated.
_kingMoblinMinion_state7:
	ld h,d			; $6d3f
	ld l,e			; $6d40
	inc (hl) ; [state] = 8

	ld l,Enemy.counter1		; $6d42
	ld (hl),24		; $6d44

	; Calculate animation, store it in 'c'
	ld l,Enemy.subid		; $6d46
	ld a,(hl)		; $6d48
	add a			; $6d49
	inc a			; $6d4a
	ld c,a			; $6d4b

	; Get angle to throw bomb at
	ld a,(hl)		; $6d4c
	ld hl,@subidBombThrowAngles		; $6d4d
	rst_addAToHl			; $6d50
	ld b,(hl)		; $6d51

	ld a,Object.state		; $6d52
	call objectGetRelatedObject2Var		; $6d54
	inc (hl)		; $6d57

	ld l,Part.angle		; $6d58
	ld (hl),b		; $6d5a

	ld l,Part.speed		; $6d5b
	ld (hl),SPEED_160		; $6d5d

	ld l,Part.speedZ		; $6d5f
	ld a,<(-$100)		; $6d61
	ldi (hl),a		; $6d63
	ld (hl),>(-$100)		; $6d64

	ld l,Part.visible		; $6d66
	ld (hl),$81		; $6d68

	ld a,c			; $6d6a
	jp enemySetAnimation		; $6d6b

@subidBombThrowAngles:
	.db $0a $16


; Delay before hopping
_kingMoblinMinion_state8:
	call _ecom_decCounter1		; $6d70
	ret nz			; $6d73

	ld l,e			; $6d74
	inc (hl) ; [state] = 9

	ld l,Enemy.speedZ		; $6d76
	ld a,<(-$140)		; $6d78
	ldi (hl),a		; $6d7a
	ld (hl),>(-$140)		; $6d7b

	ld l,Enemy.subid		; $6d7d
	bit 0,(hl)		; $6d7f
	ld c,$f4		; $6d81
	jr z,+			; $6d83
	ld c,$0c		; $6d85
+
	ld b,$f8		; $6d87
	ld a,30		; $6d89
	call objectCreateExclamationMark		; $6d8b


; Waiting to land on ground
_kingMoblinMinion_state9:
	ld c,$20		; $6d8e
	call objectUpdateSpeedZ_paramC		; $6d90
	ret nz			; $6d93

	ld l,Enemy.state		; $6d94
	inc (hl) ; [state] = $0a

	ld l,Enemy.counter1		; $6d97
	ld (hl),12		; $6d99
	inc l			; $6d9b
	ld (hl),$08 ; [counter2]

	xor a			; $6d9e
	jp enemySetAnimation		; $6d9f


; Running away
_kingMoblinMinion_stateA:
	call _ecom_decCounter2		; $6da2
	jr nz,@animate	; $6da5

	call _ecom_decCounter1		; $6da7
	jr z,@delete	; $6daa

	call objectApplySpeed		; $6dac
@animate:
	jp enemyAnimate		; $6daf

@delete:
	; Write to var33 on ENEMYID_KING_MOBLIN to request the screen transition to begin
	ld a,Object.var33		; $6db2
	call objectGetRelatedObject1Var		; $6db4
	ld (hl),$01		; $6db7
	jp enemyDelete		; $6db9

	ld e,$c2		; $6dbc
	ld a,(de)		; $6dbe
	ld hl,@table		; $6dbf
	rst_addDoubleIndex			; $6dc2
	ldi a,(hl)		; $6dc3
	ld h,(hl)		; $6dc4
	ld l,a			; $6dc5
	ld e,$c7		; $6dc6
	ld a,(de)		; $6dc8
	rst_addAToHl			; $6dc9
	ld b,(hl)		; $6dca
	ld a,b			; $6dcb
	and $f0			; $6dcc
	add $08			; $6dce
	ld e,$f0		; $6dd0
	ld (de),a		; $6dd2
	inc e			; $6dd3
	ld a,b			; $6dd4
	and $0f			; $6dd5
	swap a			; $6dd7
	add $08			; $6dd9
	ld (de),a		; $6ddb
	ret			; $6ddc

; @addr{6ddd}
@table:
	.dw @data0
	.dw @data1
	.dw @data2
	.dw @data3

; @addr{6de5}
@data0:
	.db $51 $91 $93 $13 $19 $39 $3d $9d
	.db $97 $77 $7a $8a $00

; @addr{6df2}
@data1:
	.db $17 $13 $73 $7d $3d $39 $99 $91
	.db $61 $62 $00

; @addr{6dfd}
@data2:
	.db $5d $9d $95 $55 $51 $11 $1b $3b
	.db $35 $25 $26 $00

; @addr{6e09}
@data3:
	.db $97 $99 $79 $7d $9d $9b $3b $3d
	.db $1d $1b $3b $35 $55 $53 $93 $98
	.db $88 $00

.ends

; Some blank space here ($6e1f-$6eff)

.ORGA $6f00

interactionCodee0:
	ld e,$44		; $6f00
	ld a,(de)		; $6f02
	rst_jumpTable			; $6f03
.dw $6f0c
.dw $6f29
.dw $6f3a
.dw $6f45
	ld a,$01		; $6f0c
	ld (de),a		; $6f0e
	ld a,(wAreaFlags)		; $6f0f
	and $80			; $6f12
	rlca			; $6f14
	ld e,$42		; $6f15
	ld (de),a		; $6f17
	call interactionInitGraphics		; $6f18
	call interactionSetAlwaysUpdateBit		; $6f1b
	ld l,$4b		; $6f1e
	ld (hl),$0a		; $6f20
	ld l,$4d		; $6f22
	ld (hl),$b0		; $6f24
	jp objectSetVisible80		; $6f26
	ld h,d			; $6f29
	ld l,$4d		; $6f2a
	ld a,(hl)		; $6f2c
	sub $04			; $6f2d
	ld (hl),a		; $6f2f
	cp $10			; $6f30
	ret nz			; $6f32
	ld l,e			; $6f33
	inc (hl)		; $6f34
	ld l,$46		; $6f35
	ld (hl),$28		; $6f37
	ret			; $6f39
	call interactionDecCounter1		; $6f3a
	ret nz			; $6f3d
	ld l,e			; $6f3e
	inc (hl)		; $6f3f
	ld l,$46		; $6f40
	ld (hl),$06		; $6f42
	ret			; $6f44
	ld h,d			; $6f45
	ld l,$4d		; $6f46
	ld a,(hl)		; $6f48
	sub $06			; $6f49
	ld (hl),a		; $6f4b
	ld l,$46		; $6f4c
	dec (hl)		; $6f4e
	ret nz			; $6f4f
	jp interactionDelete		; $6f50

interactionCodee2:
	ld e,$42		; $6f53
	ld a,(de)		; $6f55
	rst_jumpTable			; $6f56
.dw $6f61
.dw $6fcc
.dw $6f7b
.dw $6ff3
.dw $700f
	call checkInteractionState		; $6f61
	jr z,_label_10_272	; $6f64
	ld a,(wScrollMode)		; $6f66
	and $01			; $6f69
	ret z			; $6f6b
	call $6fb0		; $6f6c
	jp interactionSetAnimation		; $6f6f
_label_10_272:
	ld a,$01		; $6f72
	ld (de),a		; $6f74
	call interactionInitGraphics		; $6f75
	jp objectSetVisible83		; $6f78
	call checkInteractionState		; $6f7b
	jr z,_label_10_272	; $6f7e
	ld a,(wScrollMode)		; $6f80
	and $01			; $6f83
	ret z			; $6f85
	call $6fad		; $6f86
	ld hl,$6f9d		; $6f89
	rst_addDoubleIndex			; $6f8c
	ld e,$4b		; $6f8d
	ld a,(de)		; $6f8f
	and $f0			; $6f90
	or (hl)			; $6f92
	ld (de),a		; $6f93
	inc hl			; $6f94
	ld e,$4d		; $6f95
	ld a,(de)		; $6f97
	and $f0			; $6f98
	or (hl)			; $6f9a
	ld (de),a		; $6f9b
	ret			; $6f9c
	dec b			; $6f9d
	ld ($0905),sp		; $6f9e
	ld b,$09		; $6fa1
	rlca			; $6fa3
	add hl,bc		; $6fa4
	rlca			; $6fa5
	ld ($0707),sp		; $6fa6
	ld b,$07		; $6fa9
	dec b			; $6fab
	rlca			; $6fac
	call objectCenterOnTile		; $6fad
	call objectGetAngleTowardLink		; $6fb0
	ld b,a			; $6fb3
	and $07			; $6fb4
	jr z,_label_10_273	; $6fb6
	cp $01			; $6fb8
	jr z,_label_10_273	; $6fba
	cp $07			; $6fbc
	jr z,_label_10_273	; $6fbe
	ld a,b			; $6fc0
	and $fc			; $6fc1
	or $04			; $6fc3
	ld b,a			; $6fc5
_label_10_273:
	ld a,b			; $6fc6
	rrca			; $6fc7
	rrca			; $6fc8
	and $07			; $6fc9
	ret			; $6fcb
	ld e,$02		; $6fcc
_label_10_274:
	ld bc,$cfae		; $6fce
_label_10_275:
	ld a,(bc)		; $6fd1
	cp $ee			; $6fd2
	call z,$6fdd		; $6fd4
	dec c			; $6fd7
	jr nz,_label_10_275	; $6fd8
	jp interactionDelete		; $6fda
	call getFreeInteractionSlot		; $6fdd
	ret nz			; $6fe0
	ld (hl),$e2		; $6fe1
	inc l			; $6fe3
	ld (hl),e		; $6fe4
	push bc			; $6fe5
	call convertShortToLongPosition_paramC		; $6fe6
	ld l,$4b		; $6fe9
	dec b			; $6feb
	dec b			; $6fec
	ld (hl),b		; $6fed
	inc l			; $6fee
	inc l			; $6fef
	ld (hl),c		; $6ff0
	pop bc			; $6ff1
	ret			; $6ff2
	call returnIfScrollMode01Unset		; $6ff3
	ld a,(wEyePuzzleTransitionCounter)		; $6ff6
	cp $06			; $6ff9
	ld a,$00		; $6ffb
	jr nc,_label_10_277	; $6ffd
_label_10_276:
	call getRandomNumber		; $6fff
	and $03			; $7002
	cp $02			; $7004
	jr z,_label_10_276	; $7006
_label_10_277:
	ld (wcca5),a		; $7008
	ld e,$04		; $700b
	jr _label_10_274		; $700d
	ld e,$44		; $700f
	ld a,(de)		; $7011
	rst_jumpTable			; $7012
.dw $6f72
.dw $7019
.dw objectSetVisible83
	call checkInteractionState2	; $7019
	jr z,_label_10_280	; $701c
	call interactionDecCounter1		; $701e
	jr nz,_label_10_279	; $7021
	call interactionIncState		; $7023
	ld a,(wcca5)		; $7026
	ld b,a			; $7029
_label_10_278:
	ld hl,wFrameCounter		; $702a
	inc (hl)		; $702d
	ld a,(hl)		; $702e
	and $03			; $702f
	cp b			; $7031
	jr z,_label_10_278	; $7032
	add a			; $7034
	jp $6f89		; $7035
_label_10_279:
	ld a,(wFrameCounter)		; $7038
	and $03			; $703b
	ret nz			; $703d
	call getRandomNumber		; $703e
	and $07			; $7041
	jp $6f89		; $7043
_label_10_280:
	ld a,$3c		; $7046
	ld (de),a		; $7048
	ld e,$46		; $7049
	ld (de),a		; $704b
	ret			; $704c

interactionCodee5:
	ld a,(wTextIsActive)		; $704d
	or a			; $7050
	jr nz,_label_10_281	; $7051
	ld a,$02		; $7053
	ld (wTextboxPosition),a		; $7055
	ld a,TEXTBOXFLAG_DONTCHECKPOSITION		; $7058
	ld (wTextboxFlags),a		; $705a
_label_10_281:
	call $7063		; $705d
	jp objectSetPriorityRelativeToLink_withTerrainEffects		; $7060
	ld e,$44		; $7063
	ld a,(de)		; $7065
	rst_jumpTable			; $7066
.dw $706b
.dw $7097
	call interactionInitGraphics		; $706b
	ld a,$30		; $706e
	call interactionSetHighTextIndex		; $7070
	call interactionSetAlwaysUpdateBit		; $7073
	call interactionIncState		; $7076
	ld a,$06		; $7079
	call objectSetCollideRadius		; $707b
	ld e,$42		; $707e
	ld a,(de)		; $7080
	ld hl,script4b44		; $7081
	or a			; $7084
	jr z,_label_10_282	; $7085
	ld e,$5c		; $7087
	ld a,(de)		; $7089
	inc a			; $708a
	ld (de),a		; $708b
	ld hl,script4b35		; $708c
_label_10_282:
	call interactionSetScript		; $708f
	ld e,$71		; $7092
	jp objectAddToAButtonSensitiveObjectList		; $7094
	jp interactionRunScript		; $7097

; Input values for the intro cutscene in the temple
templeIntro_simulatedInput:
	dwb   45  $00
	dwb   16  BTN_UP
	dwb   48  $00
	dwb   32  BTN_UP
	dwb   24  $00
	dwb   32  BTN_UP
	dwb   48  $00
	dwb   34  BTN_UP
	dwb  112  $00
	dwb    5  BTN_UP
	dwb   32  $00
	dwb    5  BTN_UP
	dwb   36  $00
	dwb    5  BTN_UP
	dwb   36  $00
	dwb    5  BTN_UP
	dwb   36  $00
	dwb   12  BTN_UP
	.dw $ffff

; Exiting tower
blackTowerEscape_simulatedInput1:
	dwb  96 $00
	; Fall though

; Leaving screen
blackTowerEscape_simulatedInput2:
	dwb  33 BTN_DOWN
	dwb 256 $00
	.dw $ffff

; Walking up to ambi's guards
blackTowerEscape_simulatedInput3:
	dwb  48 BTN_UP
	dwb   4 $00
	dwb  16 BTN_RIGHT
	dwb   1 BTN_UP
	dwb 256 $00
	.dw $ffff

; Same room as above
blackTowerEscape_simulatedInput4:
	dwb  16 BTN_UP
	dwb 256 $00
	.dw $ffff

	xor a			; $70f6
	ldh (<hOamTail),a	; $70f7
	ld de,$cbc2		; $70f9
	ld a,(de)		; $70fc
	rst_jumpTable			; $70fd
.dw $7110
.dw $7146
.dw $7156
.dw $719c
.dw $71b8
.dw $71c4
.dw $723d
.dw $7251
.dw $727f
	ld a,(wPaletteThread_mode)		; $7110
	or a			; $7113
	ret nz			; $7114
	call incCbc2		; $7115
	call disableLcd		; $7118
	call clearDynamicInteractions		; $711b
	call clearOam		; $711e
	xor a			; $7121
	ld ($cfde),a		; $7122
	ld a,$95		; $7125
	call loadGfxHeader		; $7127
	ld a,PALH_a0		; $712a
	call loadPaletteHeader		; $712c
	ld a,$09		; $712f
	call loadGfxRegisterStateIndex		; $7131
	call fadeinFromWhite		; $7134
	call getFreeInteractionSlot		; $7137
	ret nz			; $713a
	ld (hl),$af		; $713b
	ld l,$4b		; $713d
	ld (hl),$e8		; $713f
	inc l			; $7141
	inc l			; $7142
	ld (hl),$50		; $7143
	ret			; $7145
	ld a,($cfdf)		; $7146
	or a			; $7149
	ret z			; $714a
	ld hl,wTmpcbb3		; $714b
	ld (hl),$e0		; $714e
	inc hl			; $7150
	ld (hl),$01		; $7151
	jp incCbc2		; $7153
	ld hl,wTmpcbb3		; $7156
	call decHlRef16WithCap		; $7159
	ret nz			; $715c
	call checkIsLinkedGame		; $715d
	jr nz,_label_10_290	; $7160
	callab cutscene_clearTmpCBB3		; $7162
	ld a,$03		; $716a
	ld ($cbc1),a		; $716c
	ld a,$04		; $716f
	jp fadeoutToWhiteWithDelay		; $7171
_label_10_290:
	ld a,$04		; $7174
	ld (wTmpcbb3),a		; $7176
	ld a,(wGfxRegs1.SCY)		; $7179
	ldh (<hCameraY),a	; $717c
	ld a,UNCMP_GFXH_01		; $717e
	call loadUncompressedGfxHeader		; $7180
	ld a,PALH_0b		; $7183
	call loadPaletteHeader		; $7185
	ld b,$03		; $7188
_label_10_291:
	call getFreeInteractionSlot		; $718a
	jr nz,_label_10_292	; $718d
	ld (hl),$4a		; $718f
	inc l			; $7191
	ld (hl),$09		; $7192
	inc l			; $7194
	dec b			; $7195
	ld (hl),b		; $7196
	jr nz,_label_10_291	; $7197
_label_10_292:
	jp incCbc2		; $7199
	ld a,(wGfxRegs1.SCY)		; $719c
	or a			; $719f
	jr nz,_label_10_293	; $71a0
	ld a,$78		; $71a2
	ld (wTmpcbb3),a		; $71a4
	jp incCbc2		; $71a7
_label_10_293:
	call decCbb3		; $71aa
	ret nz			; $71ad
	ld (hl),$04		; $71ae
	ld hl,wGfxRegs1.SCY		; $71b0
	dec (hl)		; $71b3
	ld a,(hl)		; $71b4
	ldh (<hCameraY),a	; $71b5
	ret			; $71b7
	call decCbb3		; $71b8
	ret nz			; $71bb
	ld a,$ff		; $71bc
	ld (wTmpcbba),a		; $71be
	jp incCbc2		; $71c1
	ld hl,wTmpcbb3		; $71c4
	ld b,$01		; $71c7
	call flashScreen		; $71c9
	ret z			; $71cc
	call disableLcd		; $71cd
	ld a,$9a		; $71d0
	call loadGfxHeader		; $71d2
	ld a,PALH_9f		; $71d5
	call loadPaletteHeader		; $71d7
	call clearDynamicInteractions		; $71da
	ld b,$03		; $71dd
_label_10_294:
	call getFreeInteractionSlot		; $71df
	jr nz,_label_10_295	; $71e2
	ld (hl),$cf		; $71e4
	inc l			; $71e6
	dec b			; $71e7
	ld (hl),b		; $71e8
	jr nz,_label_10_294	; $71e9
_label_10_295:
	ld a,$04		; $71eb
	call loadGfxRegisterStateIndex		; $71ed
	ld a,$04		; $71f0
	call fadeinFromWhiteWithDelay		; $71f2
	call incCbc2		; $71f5
	ld a,$f0		; $71f8
	ld (wTmpcbb3),a		; $71fa
	xor a			; $71fd
	ldh (<hOamTail),a	; $71fe
	ld a,(wGfxRegs1.SCY)		; $7200
	cp $60			; $7203
	jr nc,_label_10_296	; $7205
	cpl			; $7207
	inc a			; $7208
	ld b,a			; $7209
	ld a,(wFrameCounter)		; $720a
	and $01			; $720d
	jr nz,_label_10_296	; $720f
	ld c,a			; $7211
	ld hl,$4ed8		; $7212
	ld e,$16		; $7215
	call addSpritesFromBankToOam_withOffset		; $7217
_label_10_296:
	ld a,(wGfxRegs1.SCY)		; $721a
	cpl			; $721d
	inc a			; $721e
	ld b,$c7		; $721f
	add b			; $7221
	ld b,a			; $7222
	ld c,$38		; $7223
	ld hl,$4f21		; $7225
	ld e,$16		; $7228
	push bc			; $722a
	call addSpritesFromBankToOam_withOffset		; $722b
	pop bc			; $722e
	ld a,(wGfxRegs1.SCY)		; $722f
	cp $60			; $7232
	ret c			; $7234
	ld hl,$4f56		; $7235
	ld e,$16		; $7238
	jp addSpritesFromBankToOam_withOffset		; $723a
	call $71fd		; $723d
	ld a,(wPaletteThread_mode)		; $7240
	or a			; $7243
	ret nz			; $7244
	call decCbb3		; $7245
	ret nz			; $7248
	ld a,$04		; $7249
	ld (wTmpcbb3),a		; $724b
	jp incCbc2		; $724e
	ld a,(wGfxRegs1.SCY)		; $7251
	cp $98			; $7254
	jr nz,_label_10_297	; $7256
	ld a,$f0		; $7258
	ld (wTmpcbb3),a		; $725a
	call incCbc2		; $725d
	jr _label_10_298		; $7260
_label_10_297:
	call decCbb3		; $7262
	jr nz,_label_10_298	; $7265
	ld (hl),$04		; $7267
	ld hl,wGfxRegs1.SCY		; $7269
	inc (hl)		; $726c
	ld a,(hl)		; $726d
	ldh (<hCameraY),a	; $726e
	cp $60			; $7270
	jr nz,_label_10_298	; $7272
	call clearDynamicInteractions		; $7274
	ld a,UNCMP_GFXH_2c		; $7277
	call loadUncompressedGfxHeader		; $7279
_label_10_298:
	jp $71fd		; $727c
	call $71fd		; $727f
	call decCbb3		; $7282
	ret nz			; $7285
	callab cutscene_clearTmpCBB3		; $7286
	ld a,$03		; $728e
	ld ($cbc1),a		; $7290
	ld a,$04		; $7293
	jp fadeoutToWhiteWithDelay		; $7295
	ld de,$cbc2		; $7298
	ld a,(de)		; $729b
	rst_jumpTable			; $729c
.dw $72b5
.dw $7313
.dw $7341
.dw $734b
.dw $7362
.dw $73c1
.dw $73dd
.dw $73f7
.dw $7417
.dw $7440
.dw $745e
.dw $7476
	call checkIsLinkedGame		; $72b5
	call nz,$71fd		; $72b8
	ld a,(wPaletteThread_mode)		; $72bb
	or a			; $72be
	ret nz			; $72bf
	call disableLcd		; $72c0
	call incCbc2		; $72c3
	callab func_60f1		; $72c6
	call clearDynamicInteractions		; $72ce
	call clearOam		; $72d1
	call checkIsLinkedGame		; $72d4
	jp z,$72ec		; $72d7
	ld a,$99		; $72da
	call loadGfxHeader		; $72dc
	ld a,PALH_aa		; $72df
	call loadPaletteHeader		; $72e1
	ld hl,objectData.objectData5574		; $72e4
	call parseGivenObjectData		; $72e7
	jr _label_10_299		; $72ea
	ld a,$98		; $72ec
	call loadGfxHeader		; $72ee
	ld a,PALH_a9		; $72f1
	call loadPaletteHeader		; $72f3
_label_10_299:
	ld a,$04		; $72f6
	call loadGfxRegisterStateIndex		; $72f8
	xor a			; $72fb
	ld hl,hCameraY		; $72fc
	ldi (hl),a		; $72ff
	ldi (hl),a		; $7300
	ldi (hl),a		; $7301
	ld (hl),a		; $7302
	ld hl,wTmpcbb3		; $7303
	ld (hl),$f0		; $7306
	ld (hl),a		; $7308
	ld a,SNDCTRL_MEDIUM_FADEOUT		; $7309
	call playSound		; $730b
	ld a,$04		; $730e
	jp fadeinFromWhiteWithDelay		; $7310
	ld a,(wPaletteThread_mode)		; $7313
	or a			; $7316
	ret nz			; $7317
	call incCbc2		; $7318
	call checkIsLinkedGame		; $731b
	ret z			; $731e
	ld hl,wTmpcbb4		; $731f
	ld a,(hl)		; $7322
	or a			; $7323
	jr z,playWaveSoundAtRandomIntervals_body	; $7324
	dec (hl)		; $7326
	ret			; $7327

;;
; Called from playWaveSoundAtRandomIntervals in bank 0.
;
; Part of the cutscene where tokays steal your stuff? "SND_WAVE" gets played at random
; intervals?
;
; @param	hl	Place to write a counter to (how many frames until calling this
;			again)
; @addr{7328}
playWaveSoundAtRandomIntervals_body:
	push hl			; $7328
	ld a,SND_WAVE		; $7329
	call playSound		; $732b
	pop hl			; $732e
	call getRandomNumber		; $732f
	and $03			; $7332
	ld bc,@data		; $7334
	call addAToBc		; $7337
	ld a,(bc)		; $733a
	ld (hl),a		; $733b
	ret			; $733c

@data:
	.db $a0 $c8 $10 $f0

	call $731b		; $7341
	call decCbb3		; $7344
	ret nz			; $7347
	call incCbc2		; $7348
	call $731b		; $734b
	ld hl,wFileIsLinkedGame		; $734e
	ldi a,(hl)		; $7351
	add (hl)		; $7352
	cp $02			; $7353
	ret z			; $7355
	ld a,(wKeysJustPressed)		; $7356
	and $0b			; $7359
	ret z			; $735b
	call incCbc2		; $735c
	jp fadeoutToWhite		; $735f
	ld a,(wPaletteThread_mode)		; $7362
	or a			; $7365
	ret nz			; $7366
	call incCbc2		; $7367
	call disableLcd		; $736a
	callab generateGameTransferSecret		; $736d
	ld a,$ff		; $7375
	ld (wTmpcbba),a		; $7377
	ld a,($ff00+R_SVBK)	; $737a
	push af			; $737c
	ld a,TEXT_BANK		; $737d
	ld ($ff00+R_SVBK),a	; $737f
	ld hl,w7SecretText1		; $7381
	ld de,$d800		; $7384
	ld bc,$1800		; $7387
_label_10_301:
	ldi a,(hl)		; $738a
	call copyTextCharacterGfx		; $738b
	dec b			; $738e
	jr nz,_label_10_301	; $738f
	pop af			; $7391
	ld ($ff00+R_SVBK),a	; $7392
	ld a,$97		; $7394
	call loadGfxHeader		; $7396
	ld a,PALH_05		; $7399
	call loadPaletteHeader		; $739b
	ld a,UNCMP_GFXH_2b		; $739e
	call loadUncompressedGfxHeader		; $73a0
	call checkIsLinkedGame		; $73a3
	ld a,$06		; $73a6
	call nz,loadGfxHeader		; $73a8
	call clearDynamicInteractions		; $73ab
	call clearOam		; $73ae
	ld a,$04		; $73b1
	call loadGfxRegisterStateIndex		; $73b3
	ld hl,wTmpcbb3		; $73b6
	ld (hl),$3c		; $73b9
	call fileSelect_redrawDecorations		; $73bb
	jp fadeinFromWhite		; $73be
	call fileSelect_redrawDecorations		; $73c1
	ld a,(wPaletteThread_mode)		; $73c4
	or a			; $73c7
	ret nz			; $73c8
	call decCbb3		; $73c9
	ret nz			; $73cc
	ld hl,wTmpcbb3		; $73cd
	ld b,$3c		; $73d0
	call checkIsLinkedGame		; $73d2
	jr z,_label_10_302	; $73d5
	ld b,$b4		; $73d7
_label_10_302:
	ld (hl),b		; $73d9
	jp incCbc2		; $73da
	call fileSelect_redrawDecorations		; $73dd
	call decCbb3		; $73e0
	ret nz			; $73e3
	call checkIsLinkedGame		; $73e4
	jr nz,_label_10_303	; $73e7
	call getFreeInteractionSlot		; $73e9
	jr nz,_label_10_303	; $73ec
	ld (hl),$d1		; $73ee
	xor a			; $73f0
	ld ($cfde),a		; $73f1
_label_10_303:
	jp incCbc2		; $73f4
	call fileSelect_redrawDecorations		; $73f7
	call checkIsLinkedGame		; $73fa
	jr z,_label_10_304	; $73fd
	ld a,(wKeysJustPressed)		; $73ff
	and $01			; $7402
	jr nz,_label_10_305	; $7404
	ret			; $7406
_label_10_304:
	ld a,($cfde)		; $7407
	or a			; $740a
	ret z			; $740b
_label_10_305:
	call incCbc2		; $740c
	ld a,SNDCTRL_FAST_FADEOUT		; $740f
	call playSound		; $7411
	jp fadeoutToWhite		; $7414
	call fileSelect_redrawDecorations		; $7417
	ld a,(wPaletteThread_mode)		; $741a
	or a			; $741d
	ret nz			; $741e
	call checkIsLinkedGame		; $741f
	jp nz,resetGame		; $7422
	call disableLcd		; $7425
	call clearOam		; $7428
	call incCbc2		; $742b
	ld a,$96		; $742e
	call loadGfxHeader		; $7430
	ld a,PALH_a7		; $7433
	call loadPaletteHeader		; $7435
	call fadeinFromWhite		; $7438
	ld a,$04		; $743b
	jp loadGfxRegisterStateIndex		; $743d
	call $7450		; $7440
	ld a,(wPaletteThread_mode)		; $7443
	or a			; $7446
	ret nz			; $7447
	ld hl,wTmpcbb3		; $7448
	ld (hl),$b4		; $744b
	jp incCbc2		; $744d
	ld hl,$4fec		; $7450
	ld e,$16		; $7453
	ld bc,$3038		; $7455
	xor a			; $7458
	ldh (<hOamTail),a	; $7459
	jp addSpritesFromBankToOam_withOffset		; $745b
	call $7450		; $745e
	ld hl,wTmpcbb3		; $7461
	ld a,(hl)		; $7464
	or a			; $7465
	jr z,_label_10_306	; $7466
	dec (hl)		; $7468
	ret			; $7469
_label_10_306:
	ld a,(wKeysJustPressed)		; $746a
	and $01			; $746d
	ret z			; $746f
	call incCbc2		; $7470
	jp fadeoutToWhite		; $7473
	call $7450		; $7476
	ld a,(wPaletteThread_mode)		; $7479
	or a			; $747c
	ret nz			; $747d
	jp resetGame		; $747e

interactionCodedc:
	ld e,$42		; $7481
	ld a,(de)		; $7483
	rst_jumpTable			; $7484
.dw $74fd
.dw $7517
.dw $7531
.dw $75b0
.dw $75e1
.dw $75f6
.dw $7659
.dw $74b5
.dw $74c9
.dw $7669
.dw $7741
.dw $776d
.dw $77ee
.dw $77ee
.dw $7830
.dw $78ad
.dw $78e1
.dw $7931
.dw $793f
.dw $796b
.dw $7980
.dw $798f
.dw $79ba
.dw $79c9
	call getThisRoomFlags		; $74b5
	and $20			; $74b8
	jp nz,interactionDelete		; $74ba
	ld bc,$2b00		; $74bd
	call createTreasure		; $74c0
	call objectCopyPosition		; $74c3
	jp interactionDelete		; $74c6
	call checkInteractionState		; $74c9
	jr z,_label_10_307	; $74cc
	ld e,$4b		; $74ce
	ld a,(de)		; $74d0
	ld c,a			; $74d1
	ld b,$cf		; $74d2
	ld a,(bc)		; $74d4
	ld l,a			; $74d5
	ld e,$43		; $74d6
	ld a,(de)		; $74d8
	cp l			; $74d9
	ret z			; $74da
	call getThisRoomFlags		; $74db
	ld e,$4d		; $74de
	ld a,(de)		; $74e0
	or (hl)			; $74e1
	ld (hl),a		; $74e2
	jp interactionDelete		; $74e3
_label_10_307:
	call getThisRoomFlags		; $74e6
	ld e,$4d		; $74e9
	ld a,(de)		; $74eb
	and (hl)		; $74ec
	jp nz,interactionDelete		; $74ed
	ld e,$4b		; $74f0
	ld a,(de)		; $74f2
	ld c,a			; $74f3
	ld b,$cf		; $74f4
	ld a,(bc)		; $74f6
	ld e,$43		; $74f7
	ld (de),a		; $74f9
	jp interactionIncState		; $74fa
	call getThisRoomFlags		; $74fd
	and $20			; $7500
	jp nz,interactionDelete		; $7502
	ld a,(wNumTorchesLit)		; $7505
	cp $02			; $7508
	ret nz			; $750a
	ld bc,$4200		; $750b
	call createTreasure		; $750e
	call objectCopyPosition		; $7511
	jp interactionDelete		; $7514
	call checkInteractionState		; $7517
	jp nz,interactionRunScript		; $751a
	call getThisRoomFlags		; $751d
	and $80			; $7520
	jp nz,interactionDelete		; $7522
	ld hl,script7f62		; $7525
	call interactionSetScript		; $7528
	call interactionSetAlwaysUpdateBit		; $752b
	jp interactionIncState		; $752e
	ld e,$44		; $7531
	ld a,(de)		; $7533
	rst_jumpTable			; $7534
.dw $753b
.dw $7559
.dw $7580
	call interactionDeleteAndRetIfEnabled02		; $753b
	call getThisRoomFlags		; $753e
	and $80			; $7541
	jp nz,interactionDelete		; $7543
	ld a,d			; $7546
	ld (wDiggingUpEnemiesForbidden),a		; $7547
	call objectGetTileAtPosition		; $754a
	cp $3a			; $754d
	ret nz			; $754f
	ld c,l			; $7550
	ld a,$1c		; $7551
	call setTile		; $7553
	jp interactionIncState		; $7556
	ld a,(wLinkGrabState)		; $7559
	cp $83			; $755c
	ret nz			; $755e
	ld a,$01		; $755f
	ld (w1Link.direction),a		; $7561
	ld e,$46		; $7564
	ld a,$1e		; $7566
	ld (de),a		; $7568
	call checkLinkCollisionsEnabled		; $7569
	ret nc			; $756c
	ld a,$01		; $756d
	ld (wDisabledObjects),a		; $756f
	ld (wMenuDisabled),a		; $7572
	call resetLinkInvincibility		; $7575
	ld a,SNDCTRL_STOPMUSIC		; $7578
	call playSound		; $757a
	jp interactionIncState		; $757d
	ld e,$45		; $7580
	ld a,(de)		; $7582
	rst_jumpTable			; $7583
.dw $7588
.dw $759f
	call interactionDecCounter1		; $7588
	ret nz			; $758b
	ld (hl),$3c		; $758c
	ld a,$3c		; $758e
	ld bc,$f800		; $7590
	call objectCreateExclamationMark		; $7593
	call clearAllParentItems		; $7596
	call dropLinkHeldItem		; $7599
	jp interactionIncState2		; $759c
	ld a,$28		; $759f
	call setScreenShakeCounter		; $75a1
	call interactionDecCounter1		; $75a4
	ret nz			; $75a7
	ld a,$1a		; $75a8
	ld (wCutsceneTrigger),a		; $75aa
	jp interactionDelete		; $75ad
	call checkInteractionState		; $75b0
	jr nz,_label_10_308	; $75b3
	call getThisRoomFlags		; $75b5
	and $02			; $75b8
	jp nz,interactionDelete		; $75ba
	ld e,$43		; $75bd
	ld a,$02		; $75bf
	ld (de),a		; $75c1
	jp interactionIncState		; $75c2
_label_10_308:
	call objectGetTileAtPosition		; $75c5
	cp $3a			; $75c8
	ret nz			; $75ca
	ld a,$d7		; $75cb
	ld c,l			; $75cd
	call setTile		; $75ce
	call getThisRoomFlags		; $75d1
	ld e,$43		; $75d4
	ld a,(de)		; $75d6
	or (hl)			; $75d7
	ld (hl),a		; $75d8
	ld a,SND_SOLVEPUZZLE		; $75d9
	call playSound		; $75db
	jp interactionDelete		; $75de
	call checkInteractionState		; $75e1
	jr nz,_label_10_308	; $75e4
	call getThisRoomFlags		; $75e6
	and $04			; $75e9
	jp nz,interactionDelete		; $75eb
	ld e,$43		; $75ee
	ld a,$04		; $75f0
	ld (de),a		; $75f2
	jp interactionIncState		; $75f3
	ld e,$44		; $75f6
	ld a,(de)		; $75f8
	rst_jumpTable			; $75f9
.dw $7600
.dw $7622
.dw $762d
	ld a,GLOBALFLAG_TUNI_NUT_PLACED		; $7600
	call checkGlobalFlag		; $7602
	jp nz,interactionDelete		; $7605
	call returnIfScrollMode01Unset		; $7608
	ld a,SNDCTRL_STOPSFX		; $760b
	call playSound		; $760d
	ld a,$01		; $7610
	ld (wScreenShakeMagnitude),a		; $7612
	call $7641		; $7615
	ld a,(wFrameCounter)		; $7618
	rrca			; $761b
	call c,interactionIncState		; $761c
	jp interactionIncState		; $761f
	xor a			; $7622
	call $764e		; $7623
	ret nz			; $7626
	call $7641		; $7627
	jp interactionIncState		; $762a
	ld a,(wFrameCounter)		; $762d
	and $0f			; $7630
	ld a,SND_RUMBLE		; $7632
	call z,playSound		; $7634
	ld a,$08		; $7637
	call $764e		; $7639
	ret nz			; $763c
	ld l,$44		; $763d
	ld (hl),$01		; $763f
	call getRandomNumber		; $7641
	and $7f			; $7644
	sub $40			; $7646
	add $60			; $7648
	ld e,$46		; $764a
	ld (de),a		; $764c
	ret			; $764d
	call setScreenShakeCounter		; $764e
	ld a,(wFrameCounter)		; $7651
	rrca			; $7654
	ret c			; $7655
	jp interactionDecCounter1		; $7656
	ld a,GLOBALFLAG_TUNI_NUT_PLACED		; $7659
	call checkGlobalFlag		; $765b
	jr nz,_label_10_309	; $765e
	ld bc,$b201		; $7660
	call objectCreateInteraction		; $7663
_label_10_309:
	jp interactionDelete		; $7666
	ld e,$44		; $7669
	ld a,(de)		; $766b
	rst_jumpTable			; $766c
.dw interactionIncState
.dw $7675
.dw $7693
.dw $76c0
	ld a,(wMenuDisabled)		; $7675
	or a			; $7678
	ret nz			; $7679
	ld a,(wFrameCounter)		; $767a
	and $07			; $767d
	ret nz			; $767f
	call getRandomNumber_noPreserveVars		; $7680
	and $07			; $7683
	ret nz			; $7685
	ld e,$45		; $7686
	xor a			; $7688
	ld (de),a		; $7689
	ldh a,(<hRng2)	; $768a
	rrca			; $768c
	call c,interactionIncState		; $768d
	jp interactionIncState		; $7690
	ld e,$45		; $7693
	ld a,(de)		; $7695
	rst_jumpTable			; $7696
.dw $769d
.dw $76ab
.dw $76b6
	ld e,$46		; $769d
	ld a,$08		; $769f
	ld (de),a		; $76a1
	ld hl,$76fc		; $76a2
_label_10_310:
	call $76f0		; $76a5
	jp interactionIncState2		; $76a8
	call interactionDecCounter1		; $76ab
	ret nz			; $76ae
	ld (hl),$08		; $76af
	ld hl,$7705		; $76b1
	jr _label_10_310		; $76b4
	call interactionDecCounter1		; $76b6
	ret nz			; $76b9
	ld e,$44		; $76ba
	ld a,$01		; $76bc
	ld (de),a		; $76be
	ret			; $76bf
	ld e,$45		; $76c0
	ld a,(de)		; $76c2
	rst_jumpTable			; $76c3
.dw $76cc
.dw $76da
.dw $76e5
.dw $76b6
	ld e,$46		; $76cc
	ld a,$0c		; $76ce
	ld (de),a		; $76d0
	ld hl,$770e		; $76d1
_label_10_311:
	call $76f0		; $76d4
	jp interactionIncState2		; $76d7
	call interactionDecCounter1		; $76da
	ret nz			; $76dd
	ld (hl),$0c		; $76de
	ld hl,$771f		; $76e0
	jr _label_10_311		; $76e3
	call interactionDecCounter1		; $76e5
	ret nz			; $76e8
	ld (hl),$0c		; $76e9
	ld hl,$7730		; $76eb
	jr _label_10_311		; $76ee
_label_10_312:
	ldi a,(hl)		; $76f0
	or a			; $76f1
	ret z			; $76f2
	ld c,a			; $76f3
	ldi a,(hl)		; $76f4
	push hl			; $76f5
	call setTile		; $76f6
	pop hl			; $76f9
	jr _label_10_312		; $76fa
	inc h			; $76fc
	add a			; $76fd
	dec h			; $76fe
	adc b			; $76ff
	inc (hl)		; $7700
	sub a			; $7701
	dec (hl)		; $7702
	sbc b			; $7703
	nop			; $7704
	inc h			; $7705
	sbc e			; $7706
	dec h			; $7707
	sbc h			; $7708
	inc (hl)		; $7709
	xor e			; $770a
	dec (hl)		; $770b
	xor h			; $770c
	nop			; $770d
	ldi (hl),a		; $770e
	ld c,$23		; $770f
	rrca			; $7711
	ldd (hl),a		; $7712
	ld e,$33		; $7713
	rra			; $7715
	ld h,$4e		; $7716
	daa			; $7718
	ld c,a			; $7719
	ld (hl),$5e		; $771a
	scf			; $771c
	ld e,a			; $771d
	nop			; $771e
	ldi (hl),a		; $771f
	ld l,$23		; $7720
	cpl			; $7722
	ldd (hl),a		; $7723
	ld a,$33		; $7724
	ccf			; $7726
	ld h,$6e		; $7727
	daa			; $7729
	ld l,a			; $772a
	ld (hl),$7e		; $772b
	scf			; $772d
	ld a,a			; $772e
	nop			; $772f
	ldi (hl),a		; $7730
	sbc c			; $7731
	inc hl			; $7732
	sbc d			; $7733
	ldd (hl),a		; $7734
	xor c			; $7735
	inc sp			; $7736
	xor d			; $7737
	ld h,$9d		; $7738
	daa			; $773a
	sbc (hl)		; $773b
	ld (hl),$ad		; $773c
	scf			; $773e
	xor (hl)		; $773f
	nop			; $7740
	call checkInteractionState		; $7741
	jr z,_label_10_313	; $7744
	ld a,GLOBALFLAG_GOT_PERMISSION_TO_ENTER_JABU		; $7746
	call checkGlobalFlag		; $7748
	jp z,interactionDelete		; $774b
	ld a,$81		; $774e
	ld (wDisabledObjects),a		; $7750
	ld (wMenuDisabled),a		; $7753
	xor a			; $7756
	ld (w1Link.direction),a		; $7757
	ld a,$1d		; $775a
	ld (wCutsceneTrigger),a		; $775c
	jp interactionDelete		; $775f
_label_10_313:
	call getThisRoomFlags		; $7762
	and $02			; $7765
	jp nz,interactionDelete		; $7767
	jp interactionIncState		; $776a
	ld e,$44		; $776d
	ld a,(de)		; $776f
	rst_jumpTable			; $7770
.dw $7779
.dw $7787
.dw $77ad
.dw $77ba
	ld a,$01		; $7779
	ld (de),a		; $777b
	ld a,$18		; $777c
	call objectSetCollideRadius		; $777e
	ld hl,miniScript77d2		; $7781
	jp interactionSetMiniScript		; $7784
	call objectCheckCollidedWithLink_ignoreZ		; $7787
	ret nc			; $778a
	call checkLinkCollisionsEnabled		; $778b
	ret nc			; $778e
	ld a,$01		; $778f
	ld (wDisabledObjects),a		; $7791
	ld a,SND_CLINK		; $7794
	call playSound		; $7796
	ld hl,$d000		; $7799
	call objectTakePosition		; $779c
	ld e,$46		; $779f
	ld a,$1e		; $77a1
	ld (de),a		; $77a3
	ld bc,$f808		; $77a4
	call objectCreateExclamationMark		; $77a7
	jp interactionIncState		; $77aa
	call interactionDecCounter1		; $77ad
	ret nz			; $77b0
	ld (hl),$1e		; $77b1
	xor a			; $77b3
	ld (wDisabledObjects),a		; $77b4
	jp interactionIncState		; $77b7
	call interactionDecCounter1		; $77ba
	ret nz			; $77bd
	ld (hl),$07		; $77be
	call interactionGetMiniScript		; $77c0
	ldi a,(hl)		; $77c3
	ld c,a			; $77c4
	call interactionSetMiniScript		; $77c5
	ld a,c			; $77c8
	or a			; $77c9
	jp z,interactionDelete		; $77ca
	ld a,$48		; $77cd
	jp breakCrackedFloor		; $77cf

; @addr{77d2}
miniScript77d2:
	.db $67 $66 $65 $64 $63 $62 $61 $51
	.db $41 $31 $21 $11 $12 $13 $23 $33
	.db $43 $44 $45 $46 $47 $48 $38 $28
	.db $18 $17 $16 $00

	call checkInteractionState		; $77ee
	jr z,_label_10_316	; $77f1
	ld a,(wActiveTriggers)		; $77f3
	or a			; $77f6
	ret z			; $77f7
	ld e,$42		; $77f8
	ld a,(de)		; $77fa
	sub $0c			; $77fb
	ld bc,$0801		; $77fd
	ld e,$56		; $7800
	jr z,_label_10_314	; $7802
	ld bc,$0603		; $7804
	ld e,$28		; $7807
_label_10_314:
	call getFreePartSlot		; $7809
	ret nz			; $780c
	ld (hl),$0c		; $780d
	ld l,$c7		; $780f
	ld (hl),b		; $7811
_label_10_315:
	ld l,$c9		; $7812
	ld (hl),c		; $7814
	ld l,$cb		; $7815
	ld (hl),e		; $7817
	call getThisRoomFlags		; $7818
	set 7,(hl)		; $781b
	ld a,SND_SOLVEPUZZLE		; $781d
	call playSound		; $781f
	jp interactionDelete		; $7822
_label_10_316:
	call getThisRoomFlags		; $7825
	and $80			; $7828
	jp nz,interactionDelete		; $782a
	jp interactionIncState		; $782d
	ld e,$44		; $7830
	ld a,(de)		; $7832
	rst_jumpTable			; $7833
.dw $783a
.dw $7845
.dw $7895
	call getThisRoomFlags		; $783a
	and $80			; $783d
	jp nz,interactionDelete		; $783f
	jp interactionIncState		; $7842
	call objectGetTileAtPosition		; $7845
	cp $02			; $7848
	ret nz			; $784a
	call checkLinkVulnerable		; $784b
	ret nc			; $784e
	ld a,$81		; $784f
	ld (wDisabledObjects),a		; $7851
	ld (wMenuDisabled),a		; $7854
	ld e,$46		; $7857
	ld a,$2d		; $7859
	ld (de),a		; $785b
	call interactionIncState		; $785c
	ld c,$04		; $785f
	ld a,$30		; $7861
	call setTile		; $7863
	inc c			; $7866
	ld a,$32		; $7867
	call setTile		; $7869
	ld c,$14		; $786c
	ld a,$3a		; $786e
	call setTile		; $7870
	inc c			; $7873
	ld a,$3a		; $7874
	call setTile		; $7876
	ld c,$04		; $7879
	call $788a		; $787b
	ld c,$05		; $787e
	call $788a		; $7880
	ld c,$14		; $7883
	call $788a		; $7885
	ld c,$15		; $7888
	call getFreeInteractionSlot		; $788a
	ret nz			; $788d
	ld (hl),$05		; $788e
	ld l,$4b		; $7890
	jp setShortPosition_paramC		; $7892
	call interactionDecCounter1		; $7895
	ret nz			; $7898
	ld a,SND_SOLVEPUZZLE		; $7899
	call playSound		; $789b
	call getThisRoomFlags		; $789e
	set 7,(hl)		; $78a1
	xor a			; $78a3
	ld (wDisabledObjects),a		; $78a4
	ld (wMenuDisabled),a		; $78a7
	jp interactionDelete		; $78aa
	call checkInteractionState		; $78ad
	jr z,_label_10_318	; $78b0
	call objectCheckCollidedWithLink_notDead		; $78b2
	ret nc			; $78b5
	ld bc,$120a		; $78b6
	ld a,(wActiveRoom)		; $78b9
	cp $d0			; $78bc
	jr nz,_label_10_317	; $78be
	ld bc,$0209		; $78c0
_label_10_317:
	call showText		; $78c3
	jp interactionDelete		; $78c6
_label_10_318:
	ld a,(wScrollMode)		; $78c9
	and $02			; $78cc
	jp z,interactionDelete		; $78ce
	ld a,(w1Link.yh)		; $78d1
	cp $78			; $78d4
	jp c,interactionDelete		; $78d6
	ld a,$08		; $78d9
	call objectSetCollideRadius		; $78db
	jp interactionIncState		; $78de
	ld e,$44		; $78e1
	ld a,(de)		; $78e3
	rst_jumpTable			; $78e4
.dw $78eb
.dw $7900
.dw $7907
	ld hl,$cf44		; $78eb
	xor a			; $78ee
	ldi (hl),a		; $78ef
	ld (hl),a		; $78f0
	ld bc,$0410		; $78f1
	call objectSetCollideRadii		; $78f4
	call objectCheckCollidedWithLink_notDeadAndNotGrabbing		; $78f7
	call nc,interactionIncState		; $78fa
	jp interactionIncState		; $78fd
	call objectCheckCollidedWithLink_notDeadAndNotGrabbing		; $7900
	ret c			; $7903
	jp interactionIncState		; $7904
	call objectCheckCollidedWithLink_notDeadAndNotGrabbing		; $7907
	ret nc			; $790a
	call checkLinkVulnerable		; $790b
	ret nc			; $790e
	call getThisRoomFlags		; $790f
	and $01			; $7912
	ld hl,$7927		; $7914
	jr z,_label_10_319	; $7917
	ld hl,$792c		; $7919
_label_10_319:
	call setWarpDestVariables		; $791c
	ld a,SND_ENTERCAVE		; $791f
	call playSound		; $7921
	jp interactionDelete		; $7924
	add h			; $7927
	rst $20			; $7928
	sub e			; $7929
	rst $38			; $792a
	ld bc,$f384		; $792b
	sub e			; $792e
	rst $38			; $792f
	ld bc,$7dcd		; $7930
	add hl,de		; $7933
	and $20			; $7934
	ret z			; $7936
	ld hl,wDungeonBossKeys		; $7937
	ld a,$0c		; $793a
	jp setFlag		; $793c
	call getThisRoomFlags		; $793f
	and $40			; $7942
	jp nz,interactionDelete		; $7944
	ld a,(wToggleBlocksState)		; $7947
	or a			; $794a
	ret z			; $794b
	call getFreePartSlot		; $794c
	ret nz			; $794f
	ld (hl),$0c		; $7950
	ld l,$c7		; $7952
	ld (hl),$0c		; $7954
	ld l,$c9		; $7956
	ld (hl),$01		; $7958
	ld l,$cb		; $795a
	ld (hl),$13		; $795c
	call getThisRoomFlags		; $795e
	set 6,(hl)		; $7961
	ld a,SND_SOLVEPUZZLE		; $7963
	call playSound		; $7965
	jp interactionDelete		; $7968
	call returnIfScrollMode01Unset		; $796b
	ld a,$e4		; $796e
	ld hl,$cf14		; $7970
	ldi (hl),a		; $7973
	ld (hl),a		; $7974
	ld l,$24		; $7975
	ldi (hl),a		; $7977
	ld (hl),a		; $7978
	ld l,$34		; $7979
	ldi (hl),a		; $797b
	ld (hl),a		; $797c
	jp interactionDelete		; $797d
	call objectGetTileAtPosition		; $7980
	cp $dc			; $7983
	jr nz,_label_10_320	; $7985
	ld b,$80		; $7987
	call objectCreateInteractionWithSubid00		; $7989
_label_10_320:
	jp interactionDelete		; $798c
	call checkInteractionState		; $798f
	jr z,_label_10_322	; $7992
	call checkIsLinkedGame		; $7994
	ld a,$01		; $7997
	jr nz,_label_10_321	; $7999
	dec a			; $799b
_label_10_321:
	ld hl,$79ab		; $799c
	rst_addDoubleIndex			; $799f
	ldi a,(hl)		; $79a0
	ld (wChestContentsOverride),a		; $79a1
	ld a,(hl)		; $79a4
	ld (wChestContentsOverride+1),a		; $79a5
	jp interactionDelete		; $79a8
	inc (hl)		; $79ab
	ld bc,$1e2d		; $79ac
_label_10_322:
	call getThisRoomFlags		; $79af
	and $20			; $79b2
	jp nz,interactionDelete		; $79b4
	jp interactionIncState		; $79b7
	call checkInteractionState		; $79ba
	jr z,_label_10_322	; $79bd
	call checkIsLinkedGame		; $79bf
	ld a,$00		; $79c2
	jr nz,_label_10_321	; $79c4
	inc a			; $79c6
	jr _label_10_321		; $79c7
	call checkInteractionState		; $79c9
	jp z,interactionIncState		; $79cc
	ld a,(w1Link.yh)		; $79cf
	ld b,a			; $79d2
	ld a,(w1Link.xh)		; $79d3
	ld c,a			; $79d6
	callab bank5.checkPositionSurroundedByWalls		; $79d7
	rl b			; $79df
	ret nc			; $79e1
	ld a,(w1Link.state)		; $79e2
	cp $01			; $79e5
	ret nz			; $79e7
	ld hl,wLinkForceState		; $79e8
	ld a,(hl)		; $79eb
	or a			; $79ec
	ret nz			; $79ed
	ld a,$11		; $79ee
	ldi (hl),a		; $79f0
	ld a,($cca6)		; $79f1
	and $08			; $79f4
	xor $08			; $79f6
	ld (hl),a		; $79f8
	ret			; $79f9

interactionCodedd:
	ld e,$42		; $79fa
	ld a,(de)		; $79fc
	rst_jumpTable			; $79fd
.dw $7a08
.dw $7ab6
.dw $7adc
.dw $7b1a
.dw $7b54
	ld e,$44		; $7a08
	ld a,(de)		; $7a0a
	rst_jumpTable			; $7a0b
.dw $7a14
.dw $7a28
.dw $7a50
.dw $7aaf
	call interactionInitGraphics		; $7a14
	call interactionIncState		; $7a17
	ld l,$4b		; $7a1a
	ldh a,(<hEnemyTargetY)	; $7a1c
	add $08			; $7a1e
	ldi (hl),a		; $7a20
	inc l			; $7a21
	ldh a,(<hEnemyTargetX)	; $7a22
	ld (hl),a		; $7a24
	jp objectSetVisible83		; $7a25
	call $7b60		; $7a28
	jp z,interactionIncState		; $7a2b
	dec a			; $7a2e
	jr nz,_label_10_323	; $7a2f
	ret			; $7a31
_label_10_323:
	xor a			; $7a32
	ld (de),a		; $7a33
	ld b,$03		; $7a34
	call getFreeInteractionSlot		; $7a36
	ret nz			; $7a39
	ld (hl),$dd		; $7a3a
	inc l			; $7a3c
	ld (hl),b		; $7a3d
	inc l			; $7a3e
	ld e,l			; $7a3f
	ld a,(de)		; $7a40
	ld (hl),a		; $7a41
	ld e,$58		; $7a42
	ld a,$40		; $7a44
	ld (de),a		; $7a46
	inc e			; $7a47
	ld a,h			; $7a48
	ld (de),a		; $7a49
	ld bc,$f800		; $7a4a
	jp objectCopyPositionWithOffset		; $7a4d
	call interactionDecCounter1		; $7a50
	jr z,_label_10_324	; $7a53
	ld a,(hl)		; $7a55
	cp $24			; $7a56
	ret c			; $7a58
	and $07			; $7a59
	ret nz			; $7a5b
	ld a,(hl)		; $7a5c
	and $38			; $7a5d
	rrca			; $7a5f
	ld hl,$7a8f		; $7a60
	rst_addAToHl			; $7a63
	ldi a,(hl)		; $7a64
	ld b,a			; $7a65
	ldi a,(hl)		; $7a66
	ld c,a			; $7a67
	ld e,(hl)		; $7a68
	call getFreePartSlot		; $7a69
	ret nz			; $7a6c
	ld (hl),$2b		; $7a6d
	inc l			; $7a6f
	ld (hl),e		; $7a70
	ld e,$59		; $7a71
	ld a,(de)		; $7a73
	ld l,$d7		; $7a74
	ldd (hl),a		; $7a76
	ld (hl),$40		; $7a77
	ld l,$d0		; $7a79
	ld (hl),b		; $7a7b
	ld b,$00		; $7a7c
	jp objectCopyPositionWithOffset		; $7a7e
_label_10_324:
	ld a,$01		; $7a81
	call interactionSetAnimation		; $7a83
	ld a,$04		; $7a86
	call objectGetRelatedObject2Var		; $7a88
	inc (hl)		; $7a8b
	jp interactionIncState		; $7a8c
	ld h,h			; $7a8f
.DB $fc				; $7a90
	nop			; $7a91
	nop			; $7a92
	ld l,(hl)		; $7a93
	add hl,bc		; $7a94
	inc bc			; $7a95
	nop			; $7a96
	ld e,d			; $7a97
	rst $30			; $7a98
	ld (bc),a		; $7a99
	nop			; $7a9a
	ld l,(hl)		; $7a9b
	inc b			; $7a9c
	ld bc,$5a00		; $7a9d
.DB $fc				; $7aa0
	nop			; $7aa1
	nop			; $7aa2
	ld h,h			; $7aa3
	inc b			; $7aa4
	ld bc,$6e00		; $7aa5
	rst $30			; $7aa8
	ld (bc),a		; $7aa9
	nop			; $7aaa
	ld e,d			; $7aab
	add hl,bc		; $7aac
	inc bc			; $7aad
	nop			; $7aae
	call $7b60		; $7aaf
	ret nz			; $7ab2
	jp interactionDelete		; $7ab3
	ld e,$44		; $7ab6
	ld a,(de)		; $7ab8
	rst_jumpTable			; $7ab9
.dw $7a14
.dw $7ac0
.dw $7aaf
	call $7b60		; $7ac0
	jr z,_label_10_325	; $7ac3
	dec a			; $7ac5
	ret z			; $7ac6
	xor a			; $7ac7
	ld (de),a		; $7ac8
	ld b,$04		; $7ac9
	jp $7a36		; $7acb
_label_10_325:
	ld a,$04		; $7ace
	call objectGetRelatedObject2Var		; $7ad0
	inc (hl)		; $7ad3
	call interactionIncState		; $7ad4
	ld a,$01		; $7ad7
	jp interactionSetAnimation		; $7ad9
	ld e,$44		; $7adc
	ld a,(de)		; $7ade
	rst_jumpTable			; $7adf
.dw $7ae6
.dw $7af7
.dw $7afe
	call interactionInitGraphics		; $7ae6
	call interactionIncState		; $7ae9
	ld l,$51		; $7aec
	ld (hl),$fc		; $7aee
	ld l,$46		; $7af0
	ld (hl),$06		; $7af2
	jp objectSetVisible81		; $7af4
	call $7b60		; $7af7
	ret nz			; $7afa
	jp interactionIncState		; $7afb
	call objectApplyComponentSpeed		; $7afe
	ld e,$4b		; $7b01
	ld a,(de)		; $7b03
	cp $f0			; $7b04
	jp nc,interactionDelete		; $7b06
	call interactionDecCounter1		; $7b09
	ret nz			; $7b0c
	ld (hl),$06		; $7b0d
	ld bc,$8401		; $7b0f
	call objectCreateInteraction		; $7b12
	ret nz			; $7b15
	ld l,$43		; $7b16
	inc (hl)		; $7b18
	ret			; $7b19
	ld e,$44		; $7b1a
	ld a,(de)		; $7b1c
	rst_jumpTable			; $7b1d
.dw $7b28
.dw $7b39
.dw interactionAnimate
.dw $7b45
.dw $7b4d
	ld e,$43		; $7b28
	ld a,(de)		; $7b2a
	add $c0			; $7b2b
	call loadPaletteHeader		; $7b2d
	call interactionInitGraphics		; $7b30
	call interactionIncState		; $7b33
	jp objectSetVisible82		; $7b36
	call $7b60		; $7b39
	ret nz			; $7b3c
	ld a,$03		; $7b3d
	call interactionSetAnimation		; $7b3f
	jp interactionIncState		; $7b42
	call interactionIncState		; $7b45
	ld a,$04		; $7b48
	jp interactionSetAnimation		; $7b4a
	call $7b60		; $7b4d
	ret nz			; $7b50
	jp interactionDelete		; $7b51
	ld e,$44		; $7b54
	ld a,(de)		; $7b56
	rst_jumpTable			; $7b57
.dw $7b28
.dw interactionAnimate
.dw $7b45
.dw $7b4d
	call interactionAnimate		; $7b60
	ld e,$61		; $7b63
	ld a,(de)		; $7b65
	inc a			; $7b66
	ret			; $7b67

interactionCodede:
	ld a,$02		; $7b68
	ld ($cddd),a		; $7b6a
	ld a,(wMenuDisabled)		; $7b6d
	or a			; $7b70
	jp nz,objectSetInvisible		; $7b71
	call objectSetVisible		; $7b74
	ld e,$44		; $7b77
	ld a,(de)		; $7b79
	rst_jumpTable			; $7b7a
.dw $7b81
.dw $7ba6
.dw $7bae
	ld c,INTERACID_TIMEPORTAL		; $7b81
	call objectFindSameTypeObjectWithID		; $7b83
	ld a,h			; $7b86
	cp d			; $7b87
	jp nz,interactionDelete		; $7b88
	ld a,$03		; $7b8b
	call objectSetCollideRadius		; $7b8d
	call objectGetShortPosition		; $7b90
	ld c,a			; $7b93
	call interactionIncState		; $7b94
	ld l,$43		; $7b97
	ld (hl),c		; $7b99
	call objectCheckCollidedWithLink_notDeadAndNotGrabbing		; $7b9a
	call nc,interactionIncState		; $7b9d
	call interactionInitGraphics		; $7ba0
	jp objectSetVisible83		; $7ba3
	call objectCheckCollidedWithLink_notDeadAndNotGrabbing		; $7ba6
	jp nc,interactionIncState		; $7ba9
	jr _label_10_326		; $7bac
	ld e,$43		; $7bae
	ld a,(de)		; $7bb0
	ld b,a			; $7bb1
	ld a,(wPortalPos)		; $7bb2
	cp b			; $7bb5
	jp nz,interactionDelete		; $7bb6
	call $7bff		; $7bb9
	ld a,(wLinkObjectIndex)		; $7bbc
	rrca			; $7bbf
	ret c			; $7bc0
	call objectCheckCollidedWithLink_notDeadAndNotGrabbing		; $7bc1
	ret nc			; $7bc4
	call checkLinkCollisionsEnabled		; $7bc5
	ret nc			; $7bc8
	ld a,$ff		; $7bc9
	ld (wPortalGroup),a		; $7bcb
	call resetLinkInvincibility		; $7bce
	ld hl,$d000		; $7bd1
	call objectCopyPosition		; $7bd4
	ld l,$08		; $7bd7
	ld (hl),$02		; $7bd9
	ld a,$81		; $7bdb
	ld (wDisabledObjects),a		; $7bdd
	ld (wDisableLinkCollisionsAndMenu),a		; $7be0
	call objectGetTileAtPosition		; $7be3
	ld (wActiveTileIndex),a		; $7be6
	ld a,l			; $7be9
	ld (wActiveTilePos),a		; $7bea
	inc a			; $7bed
	ld (wLinkTimeWarpTile),a		; $7bee
	ld (wcde0),a		; $7bf1
	ld a,$1b		; $7bf4
	ld (wCutsceneTrigger),a		; $7bf6
	call restartSound		; $7bf9
	jp interactionDelete		; $7bfc
_label_10_326:
	ld a,(wFrameCounter)		; $7bff
	and $01			; $7c02
	jr nz,_label_10_327	; $7c04
	ld e,$5c		; $7c06
	ld a,(de)		; $7c08
	inc a			; $7c09
	and $0b			; $7c0a
	ld (de),a		; $7c0c
_label_10_327:
	jp interactionAnimate		; $7c0d

interactionCodedf:
	ld e,$44		; $7c10
	ld a,(de)		; $7c12
	rst_jumpTable			; $7c13
.dw $7c18
.dw $7c35
	ld a,$01		; $7c18
	ld (de),a		; $7c1a
	call interactionInitGraphics		; $7c1b
	ld h,d			; $7c1e
	ld l,$50		; $7c1f
	ld (hl),$14		; $7c21
	ld l,$49		; $7c23
	ld (hl),$18		; $7c25
	ld l,$46		; $7c27
	ld (hl),$3c		; $7c29
	ld l,$42		; $7c2b
	ld a,(hl)		; $7c2d
	or a			; $7c2e
	jp z,objectSetVisiblec2		; $7c2f
	jp objectSetVisiblec0		; $7c32
	ld e,$45		; $7c35
	ld a,(de)		; $7c37
	rst_jumpTable			; $7c38
.dw $7c47
.dw $7c4e
.dw $7c68
.dw $7c7d
.dw $7ccd
.dw $7ce4
.dw $7cf2
	call interactionDecCounter1		; $7c47
	ret nz			; $7c4a
	call interactionIncState2		; $7c4b
	call interactionAnimate		; $7c4e
	call objectApplySpeed		; $7c51
	cp $68			; $7c54
	ret nz			; $7c56
	call interactionIncState2		; $7c57
	ld l,$46		; $7c5a
	ld (hl),$b4		; $7c5c
	ld l,$42		; $7c5e
	ld a,(hl)		; $7c60
	or a			; $7c61
	ret nz			; $7c62
	ld a,$05		; $7c63
	jp interactionSetAnimation		; $7c65
	call interactionDecCounter1		; $7c68
	ret nz			; $7c6b
	ld hl,$cfd0		; $7c6c
	ld (hl),$01		; $7c6f
	call interactionIncState2		; $7c71
	ld l,$46		; $7c74
	ld (hl),$04		; $7c76
	inc l			; $7c78
	ld (hl),$01		; $7c79
	jr _label_10_331		; $7c7b
	ld h,d			; $7c7d
	ld l,$46		; $7c7e
	call decHlRef16WithCap		; $7c80
	jr nz,_label_10_330	; $7c83
	call interactionIncState2		; $7c85
	ld l,$46		; $7c88
	ld (hl),$64		; $7c8a
	ld b,$14		; $7c8c
	ld c,$04		; $7c8e
	ld l,$42		; $7c90
_label_10_328:
	ld a,(hl)		; $7c92
	or a			; $7c93
	jr z,_label_10_329	; $7c94
	ld b,$3c		; $7c96
	ld c,$02		; $7c98
_label_10_329:
	ld l,$50		; $7c9a
	ld (hl),b		; $7c9c
	ld a,c			; $7c9d
	call interactionSetAnimation		; $7c9e
	ld hl,$cfd0		; $7ca1
	ld (hl),$02		; $7ca4
	ret			; $7ca6
_label_10_330:
	ld l,$42		; $7ca7
	ld a,(hl)		; $7ca9
	or a			; $7caa
	call z,interactionAnimate		; $7cab
	ld l,$78		; $7cae
	dec (hl)		; $7cb0
	ret nz			; $7cb1
	ld l,$48		; $7cb2
	ld a,(hl)		; $7cb4
	xor $01			; $7cb5
	ld (hl),a		; $7cb7
	ld e,$42		; $7cb8
	ld a,(de)		; $7cba
	add a			; $7cbb
	add (hl)		; $7cbc
	call interactionSetAnimation		; $7cbd
_label_10_331:
	call getRandomNumber_noPreserveVars		; $7cc0
	and $03			; $7cc3
	swap a			; $7cc5
	add $20			; $7cc7
	ld e,$78		; $7cc9
	ld (de),a		; $7ccb
	ret			; $7ccc
	call interactionDecCounter1		; $7ccd
	ret nz			; $7cd0
	ld b,$78		; $7cd1
	ld e,$42		; $7cd3
	ld a,(de)		; $7cd5
	or a			; $7cd6
	jr nz,_label_10_332	; $7cd7
	ld b,$a0		; $7cd9
_label_10_332:
	ld (hl),b		; $7cdb
	ld hl,$cfd0		; $7cdc
	ld (hl),$03		; $7cdf
	jp interactionIncState2		; $7ce1
	call interactionDecCounter1		; $7ce4
	ret nz			; $7ce7
	ld (hl),$3c		; $7ce8
	ld hl,$cfd0		; $7cea
	ld (hl),$04		; $7ced
	jp interactionIncState2		; $7cef
	call interactionAnimate		; $7cf2
	call objectApplySpeed		; $7cf5
	call interactionDecCounter1		; $7cf8
	ret nz			; $7cfb
	ld hl,$cfdf		; $7cfc
	ld (hl),$01		; $7cff
	ret			; $7d01

interactionCodee1:
	ld e,$44		; $7d02
	ld a,(de)		; $7d04
	rst_jumpTable			; $7d05
.dw $7d3d
.dw $7d88
.dw $7d96
.dw $7d0e
	call objectSetVisible83		; $7d0e
	ld b,$01		; $7d11
	call objectFlickerVisibility		; $7d13
	call interactionAnimate		; $7d16
	call $7d90		; $7d19
	ld a,(wLinkObjectIndex)		; $7d1c
	rrca			; $7d1f
	ret c			; $7d20
	call objectCheckCollidedWithLink_notDeadAndNotGrabbing		; $7d21
	ret nc			; $7d24
	call checkLinkCollisionsEnabled		; $7d25
	ret nc			; $7d28
	ld e,$42		; $7d29
	ld a,(de)		; $7d2b
	bit 6,a			; $7d2c
	jr z,_label_10_333	; $7d2e
	call getThisRoomFlags		; $7d30
	set 1,(hl)		; $7d33
_label_10_333:
	ld hl,$7bce		; $7d35
	ld e,$10		; $7d38
	jp interBankCall		; $7d3a
	ld e,$42		; $7d3d
	ld a,(de)		; $7d3f
	and $0f			; $7d40
	rst_jumpTable			; $7d42
.dw $7d5e
.dw $7d49
.dw $7d52
	ld a,GLOBALFLAG_MAKU_TREE_SAVED		; $7d49
	call checkGlobalFlag		; $7d4b
	jr nz,_label_10_335	; $7d4e
	jr _label_10_334		; $7d50
	ld a,TREASURE_SEED_SATCHEL		; $7d52
	call checkTreasureObtained		; $7d54
	jr c,_label_10_335	; $7d57
_label_10_334:
	ld h,d			; $7d59
	ld l,$42		; $7d5a
	set 7,(hl)		; $7d5c
_label_10_335:
	call objectGetTileAtPosition		; $7d5e
	cp $d7			; $7d61
	ret nz			; $7d63
	call interactionInitGraphics		; $7d64
	call interactionSetAlwaysUpdateBit		; $7d67
	ld a,$02		; $7d6a
	call objectSetCollideRadius		; $7d6c
	ld l,$42		; $7d6f
	ld b,(hl)		; $7d71
	bit 6,b			; $7d72
	jr z,_label_10_336	; $7d74
	call getThisRoomFlags		; $7d76
	and $02			; $7d79
	jr nz,_label_10_336	; $7d7b
	set 7,b			; $7d7d
_label_10_336:
	call interactionIncState		; $7d7f
	bit 7,b			; $7d82
	ret z			; $7d84
	ld (hl),$03		; $7d85
	ret			; $7d87
	ld a,(wLinkPlayingInstrument)		; $7d88
	dec a			; $7d8b
	ret nz			; $7d8c
	call interactionIncState		; $7d8d
	call getThisRoomFlags		; $7d90
	set 3,(hl)		; $7d93
	ret			; $7d95
	ld a,(wLinkPlayingInstrument)		; $7d96
	or a			; $7d99
	ret nz			; $7d9a
	ld a,SNDCTRL_STOPSFX		; $7d9b
	call playSound		; $7d9d
	ld a,SND_TELEPORT		; $7da0
	call playSound		; $7da2
	jp interactionIncState		; $7da5

interactionCodee3:
	call checkInteractionState		; $7da8
	jr nz,@state1		; $7dab

@state0:
	ld a,$01		; $7dad
	ld (de),a		; $7daf
	call interactionInitGraphics		; $7db0
	ld hl,script7f75		; $7db3
	call interactionSetScript		; $7db6
	call getRandomNumber_noPreserveVars		; $7db9
	and $01			; $7dbc
	ld e,$48		; $7dbe
	ld (de),a		; $7dc0
	call interactionSetAnimation		; $7dc1
	call interactionSetAlwaysUpdateBit		; $7dc4
	ld l,$76		; $7dc7
	ld (hl),$1e		; $7dc9
	call $7e4b		; $7dcb
	ld l,$42		; $7dce
	ld a,(hl)		; $7dd0
	ld l,$72		; $7dd1
	ld (hl),a		; $7dd3
	ld hl,$7de4		; $7dd4
	rst_addAToHl			; $7dd7
	ld a,(hl)		; $7dd8
	ld e,$5c		; $7dd9
	ld (de),a		; $7ddb
	ld a,$32		; $7ddc
	call interactionSetHighTextIndex		; $7dde
	jp objectSetVisible82		; $7de1
	.db $00 $01 $02 $03 $02 $03 $01 $00
	.db $00 $01

@state1:
	call interactionRunScript		; $7dee
	call checkInteractionState2		; $7df1
	jr nz,_label_10_339	; $7df4
	ld e,$77		; $7df6
	ld a,(de)		; $7df8
	or a			; $7df9
	jr z,_label_10_337	; $7dfa
	call interactionIncState2		; $7dfc
	ld l,$48		; $7dff
	ld a,(hl)		; $7e01
	add $02			; $7e02
	jp interactionSetAnimation		; $7e04
_label_10_337:
	call $7e3f		; $7e07
	jr nz,_label_10_338	; $7e0a
	ld l,$76		; $7e0c
	ld (hl),$1e		; $7e0e
	call getRandomNumber		; $7e10
	and $07			; $7e13
	jr nz,_label_10_338	; $7e15
	ld l,$48		; $7e17
	ld a,(hl)		; $7e19
	xor $01			; $7e1a
	ld (hl),a		; $7e1c
	jp interactionSetAnimation		; $7e1d
_label_10_338:
	jp interactionAnimateAsNpc		; $7e20
_label_10_339:
	call interactionAnimate		; $7e23
	ld h,d			; $7e26
	ld l,$77		; $7e27
	ld a,(hl)		; $7e29
	or a			; $7e2a
	jp nz,$7e44		; $7e2b
	ld l,$76		; $7e2e
	ld (hl),$3c		; $7e30
	ld l,$45		; $7e32
	ld (hl),a		; $7e34
	ld l,$4e		; $7e35
	ldi (hl),a		; $7e37
	ld (hl),a		; $7e38
	ld l,$48		; $7e39
	ld a,(hl)		; $7e3b
	jp interactionSetAnimation		; $7e3c
	ld h,d			; $7e3f
	ld l,$76		; $7e40
	dec (hl)		; $7e42
	ret			; $7e43
	ld c,$20		; $7e44
	call objectUpdateSpeedZ_paramC		; $7e46
	ret nz			; $7e49
	ld h,d			; $7e4a
	ld bc,$ff40		; $7e4b
	jp objectSetSpeedZ		; $7e4e

interactionCodee6:
	ld e,$44		; $7e51
	ld a,(de)		; $7e53
	rst_jumpTable			; $7e54
.dw @state0
.dw @state1
.dw interactionDelete

@state0:
	ld e,$42		; $7e5b
	ld a,(de)		; $7e5d
	rst_jumpTable			; $7e5e
.dw @subid0
.dw @subid1
.dw @subid2

@subid0:
	ld a,(wDimitriState)		; $7e65
	bit 6,a			; $7e68
	jp z,interactionDelete		; $7e6a

; Subid 1: A raft that's put there through the room's object list; it must check that
; there is no already-existing raft on the screen (either from a remembered position, or
; from Link riding it)
@subid1:
	ld a,GLOBALFLAG_RAFTON_CHANGED_ROOMS		; $7e6d
	call checkGlobalFlag		; $7e6f
	jp z,interactionDelete		; $7e72

	; Check if Link's riding a raft
	ld a,(w1Companion.id)		; $7e75
	cp SPECIALOBJECTID_RAFT			; $7e78
	jp z,interactionDelete		; $7e7a

	; Check if there's another raft interaction
	ld c,INTERACID_RAFT		; $7e7d
	call objectFindSameTypeObjectWithID		; $7e7f
	ld a,h			; $7e82
	cp d			; $7e83
	jp nz,interactionDelete		; $7e84

; Subid 2: when the raft's position was remembered
@subid2:
	push de			; $7e87
	ld a,UNCMP_GFXH_3b		; $7e88
	call loadUncompressedGfxHeader		; $7e8a
	pop de			; $7e8d
	call interactionInitGraphics		; $7e8e
	call interactionIncState		; $7e91
	ld e,$48		; $7e94
	ld a,(de)		; $7e96
	and $01			; $7e97
	call interactionSetAnimation		; $7e99
	jp objectSetVisible83		; $7e9c

@state1:
	call interactionAnimate		; $7e9f
	ld a,$09		; $7ea2
	call $7ee5		; $7ea4
	ret nc			; $7ea7
	ld a,(wLinkInAir)		; $7ea8
	or a			; $7eab
	jr z,_label_10_340	; $7eac
	ld hl,w1Link.zh		; $7eae
	ld a,(hl)		; $7eb1
	cp $fd			; $7eb2
	ret c			; $7eb4
	ld l,$15		; $7eb5
	bit 7,(hl)		; $7eb7
	ret nz			; $7eb9
_label_10_340:
	ld a,d			; $7eba
	ld (wLinkRidingObject),a		; $7ebb
	ld a,$05		; $7ebe
	ld (wInstrumentsDisabledCounter),a		; $7ec0
	call $7ee5		; $7ec3
	ret nc			; $7ec6
	ld a,($d001)		; $7ec7
	or a			; $7eca
	jr z,_label_10_341	; $7ecb
	xor a			; $7ecd
	call setLinkIDOverride		; $7ece
_label_10_341:
	ld hl,$d100		; $7ed1
	ld (hl),$03		; $7ed4
	inc l			; $7ed6
	ld (hl),$13		; $7ed7
	ld e,$48		; $7ed9
	ld l,$08		; $7edb
	ld a,(de)		; $7edd
	ldi (hl),a		; $7ede
	call objectCopyPosition		; $7edf
	jp interactionIncState		; $7ee2
	call objectSetCollideRadius		; $7ee5
	ld hl,w1Link.yh		; $7ee8
	ldi a,(hl)		; $7eeb
	add $05			; $7eec
	ld b,a			; $7eee
	inc l			; $7eef
	ld c,(hl)		; $7ef0
	jp interactionCheckContainsPoint		; $7ef1

.BANK $11 SLOT 1
.ORG 0

;;
; @param[out]	zflag	nz if there's a tile collision in the direction this part is
;			moving
; @addr{4000}
_partCommon_getTileCollisionInFront:
	ld e,Part.angle		; $4000
	ld a,(de)		; $4002
	add $02			; $4003
	and $1c			; $4005
	rrca			; $4007
	ld hl,_partCommon_anglePositionOffsets		; $4008
	rst_addAToHl			; $400b
	ld e,Part.yh		; $400c
	ld a,(de)		; $400e
	add (hl)		; $400f
	ld b,a			; $4010
	ld e,Part.xh		; $4011
	inc hl			; $4013
	ld a,(de)		; $4014
	add (hl)		; $4015
	ld c,a			; $4016
	jp getTileCollisionsAtPosition		; $4017


; Position offsets used by specific angle values to check when it should be considered
; "off-screen".
_partCommon_anglePositionOffsets:
	.db $fb $00 ; Up
	.db $fb $04 ; Up/right
	.db $00 $04 ; Right
	.db $04 $04 ; Down/right
	.db $04 $00 ; Down
	.db $04 $fb ; Down/left
	.db $00 $fb ; Left
	.db $fb $fb ; Up/left

	call $4003		; $402a
	ret z			; $402d
	jr _label_11_000		; $402e
	call _partCommon_getTileCollisionInFront		; $4030
	ret z			; $4033
_label_11_000:
	add $01			; $4034
	ret c			; $4036
	dec a			; $4037
	jp checkGivenCollision_allowHoles		; $4038

	ld h,d			; $403b
	ld l,Part.state		; $403c
	ld a,(hl)		; $403e
	or a			; $403f
	jr z,_label_11_003	; $4040
	ld l,$eb		; $4042
	ld a,(hl)		; $4044
	or a			; $4045
	jr z,_label_11_002	; $4046
	rlca			; $4048
	jr nc,_label_11_001	; $4049
	inc (hl)		; $404b
	jr _label_11_002		; $404c
_label_11_001:
	dec (hl)		; $404e
_label_11_002:
	dec l			; $404f
	bit 7,(hl)		; $4050
	jr nz,_label_11_004	; $4052
	dec l			; $4054
	ld a,(hl)		; $4055
	or a			; $4056
	jr z,_label_11_005	; $4057
	ld c,$00		; $4059
	ret			; $405b

_label_11_003:
	callab bank3f.partLoadGraphicsAndProperties		; $405c
	ld e,$fe		; $4064
	ld a,$08		; $4066
	ld (de),a		; $4068
	ld c,$00		; $4069
	ret			; $406b
_label_11_004:
	ld c,$01		; $406c
	ret			; $406e
_label_11_005:
	ld c,$02		; $406f
	ret			; $4071


;;
; Checks for collisions. Considers "screen boundaries" to be collisions
;
; @param[out]	zflag	z if collision occurred
; @addr{4072}
_partCommon_checkTileCollisionOrOutOfBounds:
	call objectGetTileCollisions		; $4072
	add $01 ; Check for SPECIALCOLLISION_SCREEN_BOUNDARY
	ret z			; $4077
	call checkTileCollision_allowHoles		; $4078
	ret c			; $407b
	or d			; $407c
	ret			; $407d

;;
; @param[out]	zflag	z if out of bounds
; @addr{407e}
_partCommon_checkOutOfBounds:
	ld h,d			; $407e
	ld l,Part.yh		; $407f
	ld b,(hl)		; $4081
	ld l,Part.xh		; $4082
	ld c,(hl)		; $4084

	call @roundAngleToDiagonal		; $4085
	ld a,e			; $4088
	rrca			; $4089
	ld hl,_partCommon_anglePositionOffsets		; $408a
	rst_addAToHl			; $408d

	ldi a,(hl)		; $408e
	add b			; $408f
	ld b,a			; $4090
	ld a,(hl)		; $4091
	add c			; $4092
	ld c,a			; $4093

	call getTileCollisionsAtPosition		; $4094
	inc a			; $4097
	ret			; $4098

@roundAngleToDiagonal:
	ld l,Part.angle		; $4099
	ld a,(hl)		; $409b
	ld e,a			; $409c
	and $07			; $409d
	ret z			; $409f
	ld a,e			; $40a0
	and $18			; $40a1
	add $04			; $40a3
	ld e,a			; $40a5
	ret			; $40a6

;;
; @param[out]	zflag	Set if counter1 is zero
; @addr{40a7}
_partDecCounter1IfNonzero:
	ld h,d			; $40a7
	ld l,Part.counter1		; $40a8
	ld a,(hl)		; $40aa
	or a			; $40ab
	ret z			; $40ac
	dec (hl)		; $40ad
	ret			; $40ae

	ld h,d			; $40af
	ld l,$e4		; $40b0
	bit 7,(hl)		; $40b2
	ret z			; $40b4
	res 7,(hl)		; $40b5
	call partSetAnimation		; $40b7
	ld bc,$ff20		; $40ba
	call objectSetSpeedZ		; $40bd
	ld l,$c6		; $40c0
	ld (hl),$20		; $40c2
	ld l,$d0		; $40c4
	ld (hl),$0a		; $40c6
	ld l,$c9		; $40c8
	ld a,(hl)		; $40ca
	xor $10			; $40cb
	ld (hl),a		; $40cd
	ret			; $40ce
	call _partDecCounter1IfNonzero		; $40cf
	jp z,partDelete		; $40d2
	ld c,$0e		; $40d5
	call objectUpdateSpeedZ_paramC		; $40d7
	call partAnimate		; $40da
	jp objectApplySpeed		; $40dd
	ld e,$c9		; $40e0
	ld a,(de)		; $40e2
	add $04			; $40e3
	and $18			; $40e5
	rrca			; $40e7
	ld hl,$40fe		; $40e8
	rst_addAToHl			; $40eb
	ld e,$cb		; $40ec
	ldi a,(hl)		; $40ee
	add b			; $40ef
	ld (de),a		; $40f0
	ld e,$cd		; $40f1
	ldi a,(hl)		; $40f3
	add c			; $40f4
	ld (de),a		; $40f5
	ld e,$e6		; $40f6
	ldi a,(hl)		; $40f8
	ld (de),a		; $40f9
	inc e			; $40fa
	ld a,(hl)		; $40fb
	ld (de),a		; $40fc
	ret			; $40fd
	ld hl,sp-$05		; $40fe
	ld b,$03		; $4100
	ld (bc),a		; $4102
	ld ($0603),sp		; $4103
	ld ($0605),sp		; $4106
	inc bc			; $4109
	ld (bc),a		; $410a
	ld hl,sp+$03		; $410b
	ld b,$62		; $410d
	ld l,$c5		; $410f
	inc (hl)		; $4111
	ret			; $4112

; ==============================================================================
; PARTID_ITEM_DROP
; ==============================================================================
partCode01:
	jr z,@normalStatus	; $4113
	cp PARTSTATUS_02			; $4115
	jp z,$4216		; $4117

	ld e,Part.state		; $411a
	ld a,$03		; $411c
	ld (de),a		; $411e

@normalStatus:
	call $420c		; $411f
	ld e,Part.state		; $4122
	ld a,(de)		; $4124
	rst_jumpTable			; $4125
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3

@state0:
	ld a,(wIsMaplePresent)		; $412e
	or a			; $4131
	jp nz,partDelete		; $4132

	ld e,Part.subid		; $4135
	ld a,(de)		; $4137
	cp ITEM_DROP_100_RUPEES_OR_ENEMY			; $4138
	jr nz,@normalItem	; $413a

	call getRandomNumber_noPreserveVars		; $413c
	cp $e0			; $413f
	jp c,@spawnEnemy		; $4141

@normalItem:
	call $428e		; $4144

	ld h,d			; $4147
	ld l,Part.speedZ		; $4148
	ld a,<(-$160)		; $414a
	ldi (hl),a		; $414c
	ld (hl),>(-$160)	; $414d

	ld l,$c4		; $414f
	inc (hl)		; $4151
	ld a,(wAreaFlags)		; $4152
	and $20			; $4155
	jr z,@label_11_008	; $4157
	inc (hl)		; $4159
	ld l,$e4		; $415a
	set 7,(hl)		; $415c
	ld l,$c6		; $415e
	ld (hl),$f0		; $4160
	call objectCheckIsOnHazard		; $4162
	jr nc,@label_11_008	; $4165
	rrca			; $4167
	jr nc,@label_11_008	; $4168
	ld e,$f4		; $416a
	ld a,$01		; $416c
	ld (de),a		; $416e
@label_11_008:
	ld e,$c2		; $416f
	ld a,(de)		; $4171
	call $42e8		; $4172
	ld e,$c2		; $4175
	ld a,(de)		; $4177
	jp partSetAnimation		; $4178

@state1:
	call $4030		; $417b
	call nc,$4302		; $417e
	ld c,$20		; $4181
	call objectUpdateSpeedZAndBounce		; $4183
	jr c,@label_11_009	; $4186
	call $4365		; $4188
	jr nc,@label_11_010	; $418b
@label_11_009:
	ld h,d			; $418d
	ld l,$c4		; $418e
	inc (hl)		; $4190
	ld l,$c6		; $4191
	ld (hl),$f0		; $4193
	call objectSetVisiblec3		; $4195
@label_11_010:
	call $4386		; $4198
	ret c			; $419b
	ld e,$cf		; $419c
	ld a,(de)		; $419e
	rlca			; $419f
	ret c			; $41a0
	ld bc,$0500		; $41a1
	call objectGetRelativeTile		; $41a4
	ld hl,$442c		; $41a7
	call lookupCollisionTable		; $41aa
	ret nc			; $41ad
	ld c,a			; $41ae
	ld b,$14		; $41af
	jp $441e		; $41b1

@state2:
	call $4332		; $41b4
	call $4401		; $41b7
	jp c,$41cc		; $41ba
	call $42c3		; $41bd
	jp c,partDelete		; $41c0
	ld e,$c2		; $41c3
	ld a,(de)		; $41c5
	or a			; $41c6
	jr nz,@label_11_010	; $41c7
	jp $43bf		; $41c9
	ld h,d			; $41cc
	ld l,$f1		; $41cd
	ldi a,(hl)		; $41cf
	ld c,(hl)		; $41d0
	ld l,$cb		; $41d1
	ldi (hl),a		; $41d3
	inc l			; $41d4
	ld (hl),c		; $41d5
	jp partDelete		; $41d6

@state3:
	ld e,$c5		; $41d9
	ld a,(de)		; $41db
	or a			; $41dc
	call z,$41f9		; $41dd
	call objectCheckCollidedWithLink_ignoreZ		; $41e0
	jp c,$4216		; $41e3
	ld a,$00		; $41e6
	call objectGetRelatedObject1Var		; $41e8
	ldi a,(hl)		; $41eb
	or a			; $41ec
	jr z,@label_11_011	; $41ed
	ld e,$f0		; $41ef
	ld a,(de)		; $41f1
	cp (hl)			; $41f2
	jp z,objectTakePosition		; $41f3
@label_11_011:
	jp partDelete		; $41f6
	ld h,d			; $41f9
	ld l,e			; $41fa
	inc (hl)		; $41fb
	ld l,$cf		; $41fc
	ld (hl),$00		; $41fe
	ld a,$01		; $4200
	call objectGetRelatedObject1Var		; $4202
	ld a,(hl)		; $4205
	ld e,$f0		; $4206
	ld (de),a		; $4208
	jp objectSetVisible80		; $4209

	ld e,$e4		; $420c
	ld a,(de)		; $420e
	rlca			; $420f
	ret nc			; $4210
	call objectCheckCollidedWithLink		; $4211
	ret nc			; $4214
	pop hl			; $4215
	ld a,(wLinkDeathTrigger)		; $4216
	or a			; $4219
	jr nz,@label_11_014	; $421a
	ld e,$c2		; $421c
	ld a,(de)		; $421e
	add a			; $421f
	ld hl,$424e		; $4220
	rst_addDoubleIndex			; $4223
	ldi a,(hl)		; $4224
	or a			; $4225
	jr z,@label_11_014	; $4226
	ld b,a			; $4228
	ld a,$26		; $4229
	call cpActiveRing		; $422b
	ldi a,(hl)		; $422e
	jr z,@label_11_012	; $422f
	or a			; $4231
	jr z,@label_11_013	; $4232
	call cpActiveRing		; $4234
	jr nz,@label_11_013	; $4237
@label_11_012:
	inc hl			; $4239
@label_11_013:
	ld c,(hl)		; $423a
	ld a,b			; $423b
	call giveTreasure		; $423c
	ld e,$c2		; $423f
	ld a,(de)		; $4241
	cp $0e			; $4242
	jr nz,@label_11_014	; $4244
	call getThisRoomFlags		; $4246
	set 5,(hl)		; $4249
@label_11_014:
	jp partDelete		; $424b
	add hl,hl		; $424e
	dec h			; $424f
	jr $30			; $4250
	add hl,hl		; $4252
	dec h			; $4253
	inc b			; $4254
	ld ($2428),sp		; $4255
	ld bc,$2802		; $4258
	inc h			; $425b
	inc bc			; $425c
	inc b			; $425d
	inc bc			; $425e
	nop			; $425f
	inc b			; $4260
	ld ($0020),sp		; $4261
	dec b			; $4264
	ld a,(bc)		; $4265
	ld hl,$0500		; $4266
	ld a,(bc)		; $4269
	ldi (hl),a		; $426a
	nop			; $426b
	dec b			; $426c
	ld a,(bc)		; $426d
	inc hl			; $426e
	nop			; $426f
	dec b			; $4270
	ld a,(bc)		; $4271
	inc h			; $4272
	nop			; $4273
	dec b			; $4274
	ld a,(bc)		; $4275
	nop			; $4276
	nop			; $4277
	nop			; $4278
	nop			; $4279
	nop			; $427a
	nop			; $427b
	nop			; $427c
	nop			; $427d
	scf			; $427e
	daa			; $427f
	ld bc,$3702		; $4280
	daa			; $4283
	inc b			; $4284
	dec b			; $4285
	scf			; $4286
	daa			; $4287
	dec bc			; $4288
	inc c			; $4289
	jr z,@label_11_015	; $428a
	inc c			; $428c
	dec c			; $428d
	ld e,$c2		; $428e
	ld a,(de)		; $4290
	ld hl,$42a3		; $4291
	rst_addDoubleIndex			; $4294
	ld e,$dd		; $4295
	ld a,(de)		; $4297
	add (hl)		; $4298
	ld (de),a		; $4299
	inc hl			; $429a
	dec e			; $429b
	ld a,(hl)		; $429c
	ld (de),a		; $429d
	dec e			; $429e
	ld (de),a		; $429f
	jp objectSetVisiblec1		; $42a0
	nop			; $42a3
	ld (bc),a		; $42a4
	ld (bc),a		; $42a5
	dec b			; $42a6
	inc b			; $42a7
	nop			; $42a8
	ld b,$05		; $42a9
	stop			; $42ab
	inc b			; $42ac
	ld (de),a		; $42ad
	ld (bc),a		; $42ae
	inc d			; $42af
@label_11_015:
	inc bc			; $42b0
	ld d,$01		; $42b1
	jr @label_11_016		; $42b3
	ld a,(de)		; $42b5
@label_11_016:
	nop			; $42b6
	inc e			; $42b7
	nop			; $42b8
	ld e,$00		; $42b9
	inc c			; $42bb
	ld bc,$020c		; $42bc
	inc c			; $42bf
	inc bc			; $42c0
	ld ($fa04),sp		; $42c1
	nop			; $42c4
	call z,$0faa		; $42c5
	ret nc			; $42c8
	ld h,d			; $42c9
	ld l,$f3		; $42ca
	ld a,(hl)		; $42cc
	or a			; $42cd
	jr z,@label_11_017	; $42ce
	dec (hl)		; $42d0
	ret nz			; $42d1
	ld l,$e4		; $42d2
	set 7,(hl)		; $42d4
@label_11_017:
	call _partDecCounter1IfNonzero		; $42d6
	jr z,@label_11_018	; $42d9
	ld a,(hl)		; $42db
	cp $3c			; $42dc
	ret nc			; $42de
	ld l,$da		; $42df
	ld a,(hl)		; $42e1
	xor $80			; $42e2
	ld (hl),a		; $42e4
	ret			; $42e5
@label_11_018:
	scf			; $42e6
	ret			; $42e7
	ld h,d			; $42e8
	or a			; $42e9
	jr z,@label_11_019	; $42ea
	ld e,$c3		; $42ec
	ld a,(de)		; $42ee
	rrca			; $42ef
	ret nc			; $42f0
	ld l,$d0		; $42f1
	ld (hl),$19		; $42f3
	ret			; $42f5
@label_11_019:
	ld l,$cf		; $42f6
	ld a,(hl)		; $42f8
	ld (hl),$00		; $42f9
	ld l,$cb		; $42fb
	add (hl)		; $42fd
	ld (hl),a		; $42fe
	jp $43cc		; $42ff
	call objectCheckTileCollision_allowHoles		; $4302
	ret c			; $4305
	jp objectApplySpeed		; $4306

@spawnEnemy:
	ld c,a			; $4309
	ld a,(wDiggingUpEnemiesForbidden)		; $430a
	or a			; $430d
	jr nz,@delete	; $430e

	ld a,c			; $4310
	and $07			; $4311
	ld hl,@enemiesToSpawn		; $4313
	rst_addAToHl			; $4316
	ld b,(hl)		; $4317
	call getFreeEnemySlot		; $4318
	jr nz,@delete	; $431b

	ld (hl),b		; $431d
	call objectCopyPosition		; $431e
	ld e,Part.var03		; $4321
	ld a,(de)		; $4323
	ld l,Enemy.subid		; $4324
	ld (hl),a		; $4326
@delete:
	jp partDelete		; $4327

@enemiesToSpawn:
	.db ENEMYID_ROPE,   ENEMYID_ROPE,   ENEMYID_ROPE,   ENEMYID_BEETLE
	.db ENEMYID_BEETLE, ENEMYID_BEETLE, ENEMYID_BEETLE, ENEMYID_BEETLE

	ld a,(wAreaFlags)		; $4332
	and $20			; $4335
	ret z			; $4337
	ld e,$c2		; $4338
	ld a,(de)		; $433a
	or a			; $433b
	ret z			; $433c
	ld a,$20		; $433d
	call objectUpdateSpeedZ_sidescroll		; $433f
	jr c,@label_11_022	; $4342
	ld e,$f4		; $4344
	ld a,(de)		; $4346
	rrca			; $4347
	jr nc,@label_11_022	; $4348
	ld b,$01		; $434a
	ld a,(hl)		; $434c
	bit 7,a			; $434d
	jr z,@label_11_021	; $434f
	ld b,$ff		; $4351
	inc a			; $4353
@label_11_021:
	cp $01			; $4354
	ret c			; $4356
	ld (hl),b		; $4357
	dec l			; $4358
	ld (hl),$00		; $4359
@label_11_022:
	ld e,$cb		; $435b
	ld a,(de)		; $435d
	cp $b0			; $435e
	ret c			; $4360
	pop hl			; $4361
	jp partDelete		; $4362
	ld e,$c2		; $4365
	ld a,(de)		; $4367
	or a			; $4368
	jr z,@label_11_023	; $4369
	ld e,$d5		; $436b
	ld a,(de)		; $436d
	and $80			; $436e
	ret nz			; $4370
	ld h,d			; $4371
	ld l,$e4		; $4372
	set 7,(hl)		; $4374
	ret			; $4376
@label_11_023:
	ld e,$cf		; $4377
	ld a,(de)		; $4379
	cp $fa			; $437a
	ret nc			; $437c
	ld h,d			; $437d
	ld l,e			; $437e
	ld (hl),$fa		; $437f
	ld l,$f3		; $4381
	ld (hl),$05		; $4383
	ret			; $4385
	call objectCheckIsOnHazard		; $4386
	jr c,@label_11_024	; $4389
	ld e,$f4		; $438b
	ld a,(de)		; $438d
	rrca			; $438e
	ret nc			; $438f
	ld b,$03		; $4390
	xor a			; $4392
	jr @label_11_028		; $4393
@label_11_024:
	rrca			; $4395
	jr c,@label_11_027	; $4396
	rrca			; $4398
	ld b,$04		; $4399
	jr nc,@label_11_025	; $439b
	call objectCreateFallingDownHoleInteraction		; $439d
	jr @label_11_026		; $43a0
@label_11_025:
	call objectCreateInteractionWithSubid00		; $43a2
@label_11_026:
	call partDelete		; $43a5
	scf			; $43a8
	ret			; $43a9
@label_11_027:
	ld b,$03		; $43aa
	ld a,(wAreaFlags)		; $43ac
	and $20			; $43af
	jr z,@label_11_025	; $43b1
	ld e,$f4		; $43b3
	ld a,(de)		; $43b5
	rrca			; $43b6
	ccf			; $43b7
	ret nc			; $43b8
	ld a,$01		; $43b9
@label_11_028:
	ld (de),a		; $43bb
	jp objectCreateInteractionWithSubid00		; $43bc
	ld h,d			; $43bf
	ld l,$c7		; $43c0
	dec (hl)		; $43c2
	jr z,@label_11_029	; $43c3
	call _partCommon_getTileCollisionInFront		; $43c5
	inc a			; $43c8
	jp nz,objectApplySpeed		; $43c9
@label_11_029:
	call getRandomNumber_noPreserveVars		; $43cc
	and $3e			; $43cf
	add $08			; $43d1
	ld e,$c7		; $43d3
	ld (de),a		; $43d5
	call getRandomNumber_noPreserveVars		; $43d6
	and $03			; $43d9
	ld hl,$43fd		; $43db
	rst_addAToHl			; $43de
	ld e,$d0		; $43df
	ld a,(hl)		; $43e1
	ld (de),a		; $43e2
	call getRandomNumber_noPreserveVars		; $43e3
	and $1e			; $43e6
	ld h,d			; $43e8
	ld l,$c9		; $43e9
	ld (hl),a		; $43eb
	and $0f			; $43ec
	ret z			; $43ee
	bit 4,(hl)		; $43ef
	ld l,$db		; $43f1
	ld a,(hl)		; $43f3
	res 5,a			; $43f4
	jr nz,@label_11_030	; $43f6
	set 5,a			; $43f8
@label_11_030:
	ldi (hl),a		; $43fa
	ld (hl),a		; $43fb
	ret			; $43fc
	ld a,(bc)		; $43fd
	inc d			; $43fe
	ld e,$28		; $43ff
	ld l,$f1		; $4401
	ld h,d			; $4403
	xor a			; $4404
	ld b,(hl)		; $4405
	ldi (hl),a		; $4406
	ld c,(hl)		; $4407
	ldi (hl),a		; $4408
	or b			; $4409
	ret z			; $440a
	push bc			; $440b
	call objectCheckContainsPoint		; $440c
	pop bc			; $440f
	ret c			; $4410
	call objectGetRelativeAngle		; $4411
	ld c,a			; $4414
	ld b,$0a		; $4415
	ld e,$c9		; $4417
	call objectApplyGivenSpeed		; $4419
	xor a			; $441c
	ret			; $441d
	push bc			; $441e
	ld a,c			; $441f
	call $402a		; $4420
	pop bc			; $4423
	ret c			; $4424
	ld e,$c9		; $4425
	call objectApplyGivenSpeed		; $4427
	scf			; $442a
	ret			; $442b
	.db $40 $44 $40 $44 $38 $44 $40 $44
	.db $40 $44 $38 $44 $54 $00 $55 $08
	.db $56 $10 $57 $18 $00

;;
; @addr{4441}
partCode02:
	ld e,$c4		; $4441
	ld a,(de)		; $4443
	or a			; $4444
	call z,$4470		; $4445
	call partAnimate		; $4448
	ld a,(wFrameCounter)		; $444b
	rrca			; $444e
	jr c,_label_11_032	; $444f
	ld e,$dc		; $4451
	ld a,(de)		; $4453
	xor $01			; $4454
	ld (de),a		; $4456
_label_11_032:
	ld e,$e1		; $4457
	ld a,(de)		; $4459
	or a			; $445a
	ret z			; $445b
	call $447e		; $445c
	ld a,(de)		; $445f
	rlca			; $4460
	jp c,partDelete		; $4461
	xor a			; $4464
	call func_16eb		; $4465
	jp z,partDelete		; $4468
	ld b,$01		; $446b
	jp objectReplaceWithID		; $446d
	inc a			; $4470
	ld (de),a		; $4471
	ld e,$ed		; $4472
	ld a,(de)		; $4474
	rlca			; $4475
	ld a,$01		; $4476
	call c,partSetAnimation		; $4478
	jp objectSetVisible82		; $447b
	ld e,$c7		; $447e
	ld a,(de)		; $4480
	rrca			; $4481
	ret nc			; $4482
	jp decNumEnemies		; $4483

;;
; @addr{4486}
partCode03:
	cp $01			; $4486
	jr nz,_label_11_034	; $4488
	ld a,(wToggleBlocksState)		; $448a
	ld h,d			; $448d
	ld l,$c3		; $448e
	xor (hl)		; $4490
	ld (wToggleBlocksState),a		; $4491
	ld l,$db		; $4494
	ld a,(hl)		; $4496
	and $01			; $4497
	inc a			; $4499
	ldi (hl),a		; $449a
	ld (hl),a		; $449b
	ld a,SND_SWITCH		; $449c
	jp playSound		; $449e
_label_11_034:
	ld e,$c4		; $44a1
	ld a,(de)		; $44a3
	or a			; $44a4
	ret nz			; $44a5
	inc a			; $44a6
	ld (de),a		; $44a7
	call objectMakeTileSolid		; $44a8
	ld h,$cf		; $44ab
	ld (hl),$0a		; $44ad
	ld h,d			; $44af
	ld l,$c2		; $44b0
	ldi a,(hl)		; $44b2
	and $07			; $44b3
	ld bc,bitTable		; $44b5
	add c			; $44b8
	ld c,a			; $44b9
	ld a,(bc)		; $44ba
	ld (hl),a		; $44bb
	ld a,(wToggleBlocksState)		; $44bc
	and (hl)		; $44bf
	ld a,$01		; $44c0
	jr z,_label_11_035	; $44c2
	inc a			; $44c4
_label_11_035:
	ld l,$db		; $44c5
	ldi (hl),a		; $44c7
	ld (hl),a		; $44c8
	jp objectSetVisible82		; $44c9

;;
; @addr{44cc}
partCode04:
	ld e,$c4		; $44cc
	ld a,(de)		; $44ce
	or a			; $44cf
	jr z,_label_11_037	; $44d0
	ld e,$e1		; $44d2
	ld a,(de)		; $44d4
	inc a			; $44d5
	jp nz,partAnimate		; $44d6
	call decNumEnemies		; $44d9
	jr nz,_label_11_036	; $44dc
	ld e,$c2		; $44de
	ld a,(de)		; $44e0
	or a			; $44e1
	jr z,_label_11_036	; $44e2
	xor a			; $44e4
	call func_16eb		; $44e5
	jr z,_label_11_036	; $44e8
	ld b,$01		; $44ea
	jp objectReplaceWithID		; $44ec
_label_11_036:
	jp partDelete		; $44ef
_label_11_037:
	inc a			; $44f2
	ld (de),a		; $44f3
	ld e,$c2		; $44f4
	ld a,(de)		; $44f6
	or a			; $44f7
	ld a,SND_BIG_EXPLOSION		; $44f8
	call nz,playSound		; $44fa
	jp objectSetVisible80		; $44fd

;;
; @addr{4500}
partCode05:
	jr z,_label_11_038	; $4500
	ld a,(wSwitchState)		; $4502
	ld h,d			; $4505
	ld l,$c2		; $4506
	xor (hl)		; $4508
	ld (wSwitchState),a		; $4509
	call $4527		; $450c
	ld a,SND_SWITCH		; $450f
	jp playSound		; $4511
_label_11_038:
	ld e,$c4		; $4514
	ld a,(de)		; $4516
	or a			; $4517
	ret nz			; $4518
	ld h,d			; $4519
	ld l,e			; $451a
	inc (hl)		; $451b
	ld l,$cf		; $451c
	ld (hl),$fa		; $451e
	call objectGetShortPosition		; $4520
	ld e,$f0		; $4523
	ld (de),a		; $4525
	ret			; $4526
	ld l,$f0		; $4527
	ld c,(hl)		; $4529
	ld a,(wActiveGroup)		; $452a
	or a			; $452d
	jr z,_label_11_040	; $452e
	ld hl,wSwitchState		; $4530
	ld e,$c2		; $4533
	ld a,(de)		; $4535
	and (hl)		; $4536
	ld a,$0a		; $4537
	jr z,_label_11_039	; $4539
	inc a			; $453b
_label_11_039:
	jp setTile		; $453c
_label_11_040:
	ld a,$9f		; $453f
	call setTile		; $4541
	ld b,$cf		; $4544
	xor a			; $4546
	ld (bc),a		; $4547
	call getThisRoomFlags		; $4548
	set 6,(hl)		; $454b
	jp partDelete		; $454d

;;
; @addr{4550}
partCode06:
	jr z,++			; $4550
	ld h,d			; $4552
	ld l,Part.subid		; $4553
	ld a,(hl)		; $4555
	cp $02			; $4556
	jr z,++			; $4558

	ld l,Part.counter2		; $455a
	ldd a,(hl)		; $455c
	ld (hl),a ; [counter1] = [counter2]
	ld l,Part.state		; $455e
	ld (hl),$02		; $4560
++
	ld e,Part.subid		; $4562
	ld a,(de)		; $4564
	rst_jumpTable			; $4565
	.dw @subid0
	.dw @subid1
	.dw @subid2


; Subid 0: Once the torch is lit, it stays lit.
@subid0:
	ld e,Part.state		; $456c
	ld a,(de)		; $456e
	rst_jumpTable			; $456f
	.dw @gotoState1
	.dw @ret
	.dw @subid0State2

@gotoState1:
	ld a,$01		; $4576
	ld (de),a		; $4578

@ret:
	ret			; $4579

@subid0State2:
	ld hl,wNumTorchesLit		; $457a
	inc (hl)		; $457d
	ld a,SND_LIGHTTORCH		; $457e
	call playSound		; $4580
	call objectGetShortPosition		; $4583
	ld c,a			; $4586
	ld a,(wActiveGroup)		; $4587
	or a			; $458a
	ld a,$a1		; $458b
	jr z,+			; $458d
	ld a,TILEINDEX_LIT_TORCH		; $458f
+
	call setTile		; $4591
	jp partDelete		; $4594


; Subid 1: Once lit, the torch stays lit for [counter2] frames.
@subid1:
	ld e,Part.state		; $4597
	ld a,(de)		; $4599
	rst_jumpTable			; $459a
	.dw @gotoState1
	.dw @ret
	.dw @subid1State2
	.dw @subid1State3

@subid1State2:
	ld h,d			; $45a3
	ld l,e			; $45a4
	inc (hl)		; $45a5

	ld l,Part.collisionType		; $45a6
	res 7,(hl)		; $45a8

	; [counter1] = [counter2]
	ld l,Part.counter2		; $45aa
	ldd a,(hl)		; $45ac
	ld (hl),a		; $45ad

	ld hl,wNumTorchesLit		; $45ae
	inc (hl)		; $45b1
	ld a,SND_LIGHTTORCH		; $45b2
	call playSound		; $45b4

	call objectGetShortPosition		; $45b7
	ld c,a			; $45ba
	ld a,TILEINDEX_LIT_TORCH		; $45bb
	jr @setTile		; $45bd

@subid1State3:
	ld a,(wFrameCounter)		; $45bf
	and $03			; $45c2
	ret nz			; $45c4
	call _partDecCounter1IfNonzero		; $45c5
	ret nz			; $45c8

	ld l,Part.collisionType		; $45c9
	set 7,(hl)		; $45cb
	ld l,Part.state		; $45cd
	ld (hl),$01		; $45cf

	ld hl,wNumTorchesLit		; $45d1
	dec (hl)		; $45d4

	call objectGetShortPosition		; $45d5
	ld c,a			; $45d8
	ld a,TILEINDEX_UNLIT_TORCH		; $45d9
	jr @setTile		; $45db

@subid2:
	ld e,Part.state		; $45dd
	ld a,(de)		; $45df
	rst_jumpTable			; $45e0
	.dw @gotoState1
	.dw @subid2State1
	.dw @subid2State2
	.dw @subid2State3
	.dw @subid2State4

@subid2State1:
	call @getTileAtRelatedObjYAndThisX		; $45eb
	cp TILEINDEX_LIT_TORCH			; $45ee
	ret z			; $45f0

	ld h,d			; $45f1
	ld l,Part.state		; $45f2
	inc (hl)		; $45f4
	ld l,Part.counter1		; $45f5
	ld (hl),$f0		; $45f7
	ret			; $45f9

@subid2State2:
	call _partDecCounter1IfNonzero		; $45fa
	jp nz,@gotoState1IfTileAtRelatedObjPositionIsNotLit		; $45fd

	; [state]=3
	ld l,e			; $4600
	inc (hl)		; $4601

	ld hl,wNumTorchesLit		; $4602
	dec (hl)		; $4605
	call objectGetShortPosition		; $4606
	ld c,a			; $4609
	ld a,TILEINDEX_UNLIT_TORCH		; $460a
@setTile:
	jp setTile		; $460c

@subid2State3:
	call @getTileAtRelatedObjYAndThisX		; $460f
	cp TILEINDEX_UNLIT_TORCH			; $4612
	ret z			; $4614
	ld e,Part.state		; $4615
	ld a,$04		; $4617
	ld (de),a		; $4619
	ret			; $461a

@subid2State4:
	ld a,$01		; $461b
	ld (de),a		; $461d
	ld hl,wNumTorchesLit		; $461e
	inc (hl)		; $4621
	call objectGetShortPosition		; $4622
	ld c,a			; $4625
	ld a,TILEINDEX_LIT_TORCH		; $4626
	jr @setTile		; $4628

;;
; Takes relatedObj2's Y position, this object's X position, and returns the tile there?
; @addr{4636}
@getTileAtRelatedObjYAndThisX:
	ld a,Object.yh		; $462a
	call objectGetRelatedObject2Var		; $462c
	ld b,(hl)		; $462f
	ld l,Part.xh		; $4630
	ld c,(hl)		; $4632
	jp getTileAtPosition		; $4633

@gotoState1IfTileAtRelatedObjPositionIsNotLit:
	call @getTileAtRelatedObjYAndThisX		; $4636
	cp TILEINDEX_LIT_TORCH			; $4639
	ret nz			; $463b
	ld e,Part.state		; $463c
	ld a,$01		; $463e
	ld (de),a		; $4640
	ret			; $4641


; ==============================================================================
; PARTID_SHADOW
;
; Variables:
;   relatedObj1: Object that this shadow is for
;   var30: ID of relatedObj1 (deletes self if it changes)
; ==============================================================================
partCode07:
	ld e,Part.state		; $4642
	ld a,(de)		; $4644
	or a			; $4645
	call z,@initialize		; $4646

	; If parent's ID changed, delete self
	ld a,Object.id		; $4649
	call objectGetRelatedObject1Var		; $464b
	ld e,Part.var30		; $464e
	ld a,(de)		; $4650
	cp (hl)			; $4651
	jp nz,partDelete		; $4652

	; Take parent's position, with offset
	ld a,Object.yh		; $4655
	call objectGetRelatedObject1Var		; $4657
	ld e,Part.var03		; $465a
	ld a,(de)		; $465c
	ld b,a			; $465d
	ld c,$00		; $465e
	call objectTakePositionWithOffset		; $4660

	xor a			; $4663
	ld (de),a ; [this.zh] = 0

	ld a,(hl) ; [parent.zh]
	or a			; $4666
	jp z,objectSetInvisible		; $4667

	; Flicker visibility
	ld e,Part.visible		; $466a
	ld a,(de)		; $466c
	xor $80			; $466d
	ld (de),a		; $466f

	ld e,Part.subid		; $4670
	ld a,(de)		; $4672
	add a			; $4673
	ld bc,@animationIndices		; $4674
	call addDoubleIndexToBc		; $4677

	; Set shadow size based on how close the parent is to the ground
	ld a,(hl) ; [parent.zh]
	cp $e0			; $467b
	jr nc,@setAnim	; $467d
	inc bc			; $467f
	cp $c0			; $4680
	jr nc,@setAnim	; $4682
	inc bc			; $4684
	cp $a0			; $4685
	jr nc,@setAnim	; $4687
	inc bc			; $4689

@setAnim:
	ld a,(bc)		; $468a
	jp partSetAnimation		; $468b

@animationIndices:
	.db $01 $01 $00 $00 ; Subid 0
	.db $02 $01 $01 $00 ; Subid 1
	.db $03 $02 $01 $00 ; Subid 2

@initialize:
	inc a			; $469a
	ld (de),a ; [state] = 1

	ld a,Object.id		; $469c
	call objectGetRelatedObject1Var		; $469e
	ld e,Part.var30		; $46a1
	ld a,(hl)		; $46a3
	ld (de),a		; $46a4

	jp objectSetVisible83		; $46a5

;;
; @addr{46a8}
partCode08:
	ld a,(wPaletteThread_mode)		; $46a8
	or a			; $46ab
	ret nz			; $46ac
	ld a,(wScrollMode)		; $46ad
	and $01			; $46b0
	ret z			; $46b2
	ld e,$c4		; $46b3
	ld a,(de)		; $46b5
	or a			; $46b6
	call z,$4704		; $46b7
	ld h,d			; $46ba
	ld l,$c7		; $46bb
	ld b,(hl)		; $46bd
	ld a,(wNumTorchesLit)		; $46be
	cp (hl)			; $46c1
	ret z			; $46c2
	ldd (hl),a		; $46c3
	or a			; $46c4
	jp z,darkenRoom		; $46c5
	cp (hl)			; $46c8
	jp z,brightenRoom		; $46c9
	ld a,(wPaletteThread_parameter)		; $46cc
	cp $f7			; $46cf
	ret z			; $46d1
	ld a,(wNumTorchesLit)		; $46d2
	cp b			; $46d5
	jp nc,brightenRoomLightly		; $46d6
	jp darkenRoomLightly		; $46d9
	push hl			; $46dc
	push bc			; $46dd
	ld c,l			; $46de
	call getFreePartSlot		; $46df
	jr nz,_label_11_045	; $46e2
	ld (hl),$06		; $46e4
	inc l			; $46e6
	ld e,l			; $46e7
	ld a,(de)		; $46e8
	ld (hl),a		; $46e9
	ld e,$cb		; $46ea
	ld a,(de)		; $46ec
	and $f0			; $46ed
	ld l,a			; $46ef
	ld e,$cd		; $46f0
	ld a,(de)		; $46f2
	and $f0			; $46f3
	swap a			; $46f5
	or l			; $46f7
	ld l,$c7		; $46f8
	ld (hl),a		; $46fa
	ld l,$cb		; $46fb
	call setShortPosition_paramC		; $46fd
_label_11_045:
	pop bc			; $4700
	pop hl			; $4701
	inc c			; $4702
	ret			; $4703
	inc a			; $4704
	ld (de),a		; $4705
	ld e,$c6		; $4706
	ld a,(de)		; $4708
	ld c,a			; $4709
	ld hl,wRoomLayout		; $470a
	ld b,$b0		; $470d
_label_11_046:
	ld a,(hl)		; $470f
	cp $08			; $4710
	call z,$46dc		; $4712
	inc l			; $4715
	dec b			; $4716
	jr nz,_label_11_046	; $4717
	ld e,$c6		; $4719
	ld a,c			; $471b
	ld (de),a		; $471c
	call objectGetShortPosition		; $471d
	ld e,$cb		; $4720
	ld (de),a		; $4722
	ret			; $4723

;;
; @addr{4724}
partCode09:
	ld e,$c4		; $4724
	ld a,(de)		; $4726
	or a			; $4727
	call z,$47c9		; $4728
	ld a,($ccb1)		; $472b
	or a			; $472e
	ret nz			; $472f
	ld hl,$d000		; $4730
	call checkObjectsCollided		; $4733
	jr c,_label_11_049	; $4736
	call objectGetTileAtPosition		; $4738
	sub $0c			; $473b
	cp $02			; $473d
	jr nc,_label_11_047	; $473f
	call _partDecCounter1IfNonzero		; $4741
	ret nz			; $4744
	ld l,$f0		; $4745
	bit 0,(hl)		; $4747
	ret z			; $4749
	ld e,$f0		; $474a
	ld a,(de)		; $474c
	or a			; $474d
	ret z			; $474e
	call objectGetShortPosition		; $474f
	ld c,a			; $4752
	ld a,$0c		; $4753
	call setTile		; $4755
	ld e,$c3		; $4758
	ld a,(de)		; $475a
	ld hl,wActiveTriggers		; $475b
	call unsetFlag		; $475e
	ld e,$f0		; $4761
	xor a			; $4763
	ld (de),a		; $4764
	ld a,SND_SPLASH		; $4765
	jp playSound		; $4767
_label_11_047:
	ld h,d			; $476a
	ld l,$c2		; $476b
	bit 7,(hl)		; $476d
	jr z,_label_11_048	; $476f
	ld l,$f0		; $4771
	bit 0,(hl)		; $4773
	ret nz			; $4775
	ld l,$c6		; $4776
	ld (hl),$1c		; $4778
	call objectGetShortPosition		; $477a
	ld c,a			; $477d
	ld b,$0d		; $477e
	call setTileInRoomLayoutBuffer		; $4780
	jr _label_11_051		; $4783
_label_11_048:
	call $47b7		; $4785
	jp partDelete		; $4788
_label_11_049:
	ld a,(w1Link.zh)		; $478b
	or a			; $478e
	ret nz			; $478f
	ld e,$c2		; $4790
	ld a,(de)		; $4792
	rlca			; $4793
	jr nc,_label_11_048	; $4794
_label_11_050:
	ld e,$f0		; $4796
	ld a,(de)		; $4798
	or a			; $4799
	ret nz			; $479a
	call objectGetShortPosition		; $479b
	ld c,a			; $479e
	ld a,$0d		; $479f
	call setTile		; $47a1
_label_11_051:
	ld e,$c3		; $47a4
	ld a,(de)		; $47a6
	ld hl,wActiveTriggers		; $47a7
	call setFlag		; $47aa
	ld e,$f0		; $47ad
	ld a,$01		; $47af
	ld (de),a		; $47b1
	ld a,SND_SPLASH		; $47b2
	jp playSound		; $47b4
	call objectGetShortPosition		; $47b7
	ld c,a			; $47ba
	ld b,$0d		; $47bb
	call setTileInRoomLayoutBuffer		; $47bd
	call objectGetTileAtPosition		; $47c0
	cp $0c			; $47c3
	jr z,_label_11_050	; $47c5
	jr _label_11_051		; $47c7
	ld h,d			; $47c9
	ld l,e			; $47ca
	inc (hl)		; $47cb
	ld l,$c2		; $47cc
	ldi a,(hl)		; $47ce
	and $07			; $47cf
	ldd (hl),a		; $47d1
	ret			; $47d2

;;
; @addr{47d3}
partCode0b:
	cp $01			; $47d3
	jr nz,_label_11_053	; $47d5
	ld h,d			; $47d7
	ld l,$db		; $47d8
	ldi a,(hl)		; $47da
	ld (hl),a		; $47db
	ld l,$c3		; $47dc
	ld a,(wToggleBlocksState)		; $47de
	xor (hl)		; $47e1
	ld (wToggleBlocksState),a		; $47e2
	ld l,$db		; $47e5
	ld a,(hl)		; $47e7
	dec a			; $47e8
	jr nz,_label_11_052	; $47e9
	ld a,$02		; $47eb
_label_11_052:
	ldi (hl),a		; $47ed
	ld (hl),a		; $47ee
	ld a,SND_SWITCH		; $47ef
	call playSound		; $47f1
_label_11_053:
	ld e,$c4		; $47f4
	ld a,(de)		; $47f6
	sub $08			; $47f7
	jr c,_label_11_054	; $47f9
	rst_jumpTable			; $47fb
.dw $4820
.dw $482c
.dw $4838
.dw $4844
.dw $4853

_label_11_054:
	ld hl,bank0e.data_6b22		; $4806
	call objectLoadMovementScript		; $4809
	ld h,d			; $480c
	ld l,$c3		; $480d
	ld b,$01		; $480f
	ld a,(wToggleBlocksState)		; $4811
	and (hl)		; $4814
	jr z,_label_11_055	; $4815
	inc b			; $4817
_label_11_055:
	ld a,b			; $4818
	ld l,$db		; $4819
	ldi (hl),a		; $481b
	ld (hl),a		; $481c
	jp objectSetVisible82		; $481d
	ld h,d			; $4820
	ld e,$f2		; $4821
	ld a,(de)		; $4823
	ld l,$cb		; $4824
	cp (hl)			; $4826
	jp c,objectApplySpeed		; $4827
	jr _label_11_057		; $482a
	ld h,d			; $482c
	ld e,$cd		; $482d
	ld a,(de)		; $482f
	ld l,$f3		; $4830
	cp (hl)			; $4832
	jp c,objectApplySpeed		; $4833
	jr _label_11_057		; $4836
	ld h,d			; $4838
	ld e,$cb		; $4839
	ld a,(de)		; $483b
	ld l,$f2		; $483c
	cp (hl)			; $483e
	jp c,objectApplySpeed		; $483f
	jr _label_11_057		; $4842
	ld h,d			; $4844
	ld e,$f3		; $4845
	ld a,(de)		; $4847
	ld l,$cd		; $4848
_label_11_056:
	cp (hl)			; $484a
	jp c,objectApplySpeed		; $484b
_label_11_057:
	ld a,(de)		; $484e
	ld (hl),a		; $484f
	jp objectRunMovementScript		; $4850
	ld h,d			; $4853
	ld l,$c6		; $4854
	dec (hl)		; $4856
	ret nz			; $4857
	jp objectRunMovementScript		; $4858

;;
; @addr{485b}
partCode0c:
	ld e,$c4		; $485b
	ld a,(de)		; $485d
	or a			; $485e
	call z,$48b0		; $485f
	call _partDecCounter1IfNonzero		; $4862
	ret nz			; $4865
	ld l,$c9		; $4866
	ld a,(hl)		; $4868
	ld hl,$48a4		; $4869
	rst_addDoubleIndex			; $486c
	ld e,$c7		; $486d
	ld a,(de)		; $486f
	rrca			; $4870
	ldi a,(hl)		; $4871
	jr nc,_label_11_058	; $4872
	ld a,(hl)		; $4874
_label_11_058:
	ld b,a			; $4875
	ld e,$cb		; $4876
	ld a,(de)		; $4878
	ld c,a			; $4879
	push bc			; $487a
	call setTileInRoomLayoutBuffer		; $487b
	pop bc			; $487e
	ld a,b			; $487f
	call setTile		; $4880
	ld a,SND_DOORCLOSE		; $4883
	call playSound		; $4885
	ld h,d			; $4888
	ld l,$c6		; $4889
	ld (hl),$08		; $488b
	inc l			; $488d
	dec (hl)		; $488e
	jp z,partDelete		; $488f
	ld a,(hl)		; $4892
	rrca			; $4893
	ret c			; $4894
	ld l,$c9		; $4895
	ld a,(hl)		; $4897
	ld bc,$48ac		; $4898
	call addAToBc		; $489b
	ld a,(bc)		; $489e
	ld l,$cb		; $489f
	add (hl)		; $48a1
	ld (hl),a		; $48a2
	ret			; $48a3
	ld l,e			; $48a4
	ld l,d			; $48a5
	ld l,(hl)		; $48a6
	ld l,l			; $48a7
	ld l,h			; $48a8
	ld l,d			; $48a9
	ld l,a			; $48aa
	ld l,l			; $48ab
	ld a,($ff00+R_SB)	; $48ac
	stop			; $48ae
	rst $38			; $48af
	ld h,d			; $48b0
	ld l,e			; $48b1
	inc (hl)		; $48b2
	ld l,$c6		; $48b3
	ld (hl),$08		; $48b5
	ret			; $48b7


; ==============================================================================
; PARTID_DETECTION_HELPER
;
; Variables (for subid 0, the "controller"):
;   counter1: Countdown until firing another detection projectile forward
;   counter2: Countdown until firing another detection projectile in an arbitrary
;             direction (for close-range detection)
; ==============================================================================
partCode0e:
	jp nz,partDelete		; $48b8
	ld e,Part.subid		; $48bb
	ld a,(de)		; $48bd
	ld e,Part.state		; $48be
	rst_jumpTable			; $48c0
	.dw @subid0
	.dw @subid1
	.dw @subid2
	.dw @subid3


; The "controller" (spawns other subids)
@subid0:
	ld a,(de)		; $48c9
	or a			; $48ca
	jr z,@subid0_state0	; $48cb

@subid0_state1:
	ld a,Object.enabled		; $48cd
	call objectGetRelatedObject1Var		; $48cf
	ld a,(hl)		; $48d2
	or a			; $48d3
	jp z,partDelete		; $48d4

	; Copy parent's angle and position
	ld e,Part.angle		; $48d7
	ld a,l			; $48d9
	or Object.angle			; $48da
	ld l,a			; $48dc
	ld a,(hl)		; $48dd
	ld (de),a		; $48de
	call objectTakePosition		; $48df

	; Countdown to spawn a "detection projectile" forward
	call _partDecCounter1IfNonzero		; $48e2
	jr nz,++		; $48e5

	ld (hl),$0f ; [counter1]
	ld e,Part.angle		; $48e9
	ld a,(de)		; $48eb
	ld b,a			; $48ec
	ld e,$01		; $48ed
	call @spawnCollisionHelper		; $48ef
++
	; Countdown to spawn "detection projectiles" to the sides, for nearby detection
	ld h,d			; $48f2
	ld l,Part.counter2		; $48f3
	dec (hl)		; $48f5
	ret nz			; $48f6

	ld (hl),$06 ; [counter2]

	ld l,Part.var03		; $48f9
	ld a,(hl)		; $48fb
	inc a			; $48fc
	and $03			; $48fd
	ld (hl),a		; $48ff

	ld c,a			; $4900
	ld l,Part.angle		; $4901
	ld b,(hl)		; $4903
	ld e,$02		; $4904
	call @spawnCollisionHelper		; $4906
	ld e,$03		; $4909


;;
; @param	b	Angle
; @param	c	var03
; @param	e	Subid
; @addr{490b}
@spawnCollisionHelper:
	call getFreePartSlot		; $490b
	ret nz			; $490e
	ld (hl),PARTID_DETECTION_HELPER		; $490f
	inc l			; $4911
	ld (hl),e		; $4912
	inc l			; $4913
	ld (hl),c		; $4914

	call objectCopyPosition		; $4915
	ld l,Part.angle		; $4918
	ld (hl),b		; $491a

	ld l,Part.relatedObj1		; $491b
	ld e,l			; $491d
	ld a,(de)		; $491e
	ldi (hl),a		; $491f
	inc e			; $4920
	ld a,(de)		; $4921
	ld (hl),a		; $4922
	ret			; $4923

@subid0_state0:
	ld h,d			; $4924
	ld l,e			; $4925
	inc (hl) ; [subid]

	ld l,Part.counter1		; $4927
	inc (hl)		; $4929
	inc l			; $492a
	inc (hl) ; [counter2]
	ret			; $492c


; This "moves" in a prescribed direction. If it hits Link, it triggers the guard; if it
; hits a wall, it deletes itself.
@subid1:
	ld a,(de)		; $492d
	or a			; $492e
	jr z,@subid1_state0	; $492f


@subid1_state1:
	call objectCheckCollidedWithLink_ignoreZ		; $4931
	jr c,@sawLink			; $4934

	; Move forward, delete self if hit a wall
	call objectApplyComponentSpeed		; $4936
	call objectCheckSimpleCollision		; $4939
	ret z			; $493c
	jr @delete		; $493d

@sawLink:
	ld a,Object.var3b		; $493f
	call objectGetRelatedObject1Var		; $4941
	ld (hl),$ff		; $4944
@delete:
	jp partDelete		; $4946


@subid1_state0:
	inc a			; $4949
	ld (de),a ; [state]

	; Determine collision radii depending on angle
	ld e,Part.angle		; $494b
	ld a,(de)		; $494d
	add $04			; $494e
	and $08			; $4950
	rrca			; $4952
	rrca			; $4953
	ld hl,@collisionRadii		; $4954
	rst_addAToHl			; $4957
	ld e,Part.collisionRadiusY		; $4958
	ldi a,(hl)		; $495a
	ld (de),a		; $495b
	inc e			; $495c
	ld a,(hl)		; $495d
	ld (de),a		; $495e

	jp @initSpeed		; $495f

@collisionRadii:
	.db $02 $01 ; Up/down
	.db $01 $02 ; Left/right


; Like subid 1, but this only lasts for 4 frames, and it detects Link at various angles
; relative to the guard (determined by var03). Used for close-range detection in any
; direction.
@subid2:
@subid3:
	ld a,(de)		; $4966
	or a			; $4967
	jr z,@subid2_state0	; $4968


@subid2_state1:
	call _partDecCounter1IfNonzero		; $496a
	jr nz,@subid1_state1	; $496d
	jr @delete		; $496f


@subid2_state0:
	ld h,d			; $4971
	ld l,e			; $4972
	inc (hl) ; [state]

	ld l,Part.counter1		; $4974
	ld (hl),$04		; $4976

	ld l,Part.var03		; $4978
	ld a,(hl)		; $497a
	inc a			; $497b
	add a			; $497c
	dec l			; $497d
	bit 0,(hl) ; [subid]
	jr nz,++		; $4980
	cpl			; $4982
	inc a			; $4983
++
	ld l,Part.angle		; $4984
	add (hl)		; $4986
	and $1f			; $4987
	ld (hl),a		; $4989

;;
; @addr{498a}
@initSpeed:
	ld h,d			; $498a
	ld l,Part.angle		; $498b
	ld c,(hl)		; $498d
	ld b,SPEED_280		; $498e
	ld a,$04		; $4990
	jp objectSetComponentSpeedByScaledVelocity		; $4992


;;
; @addr{4995}
partCode0f:
	jr z,_label_11_068	; $4995
	ld h,d			; $4997
	ld l,$c4		; $4998
	inc (hl)		; $499a
	ld l,$c6		; $499b
	ld (hl),$f0		; $499d
	ld l,$e4		; $499f
	res 7,(hl)		; $49a1
	ld a,$02		; $49a3
	call $49ef		; $49a5
	call getRandomNumber_noPreserveVars		; $49a8
	rrca			; $49ab
	jr nc,_label_11_067	; $49ac
	call getFreePartSlot		; $49ae
	jr nz,_label_11_067	; $49b1
	ld (hl),$01		; $49b3
	inc l			; $49b5
	ld e,l			; $49b6
	ld a,(de)		; $49b7
	ld (hl),a		; $49b8
	call objectCopyPosition		; $49b9
_label_11_067:
	ld b,$00		; $49bc
	call objectCreateInteractionWithSubid00		; $49be
_label_11_068:
	ld e,$c4		; $49c1
	ld a,(de)		; $49c3
	rst_jumpTable			; $49c4
.dw $49cf
.dw $49d3
.dw $49d4
.dw $49e5
.dw $49f8
	ld a,$01		; $49cf
	ld (de),a		; $49d1
	ret			; $49d2
	ret			; $49d3
	ld a,(wFrameCounter)		; $49d4
	rrca			; $49d7
	ret nc			; $49d8
	call _partDecCounter1IfNonzero		; $49d9
	ret nz			; $49dc
	ld (hl),$0c		; $49dd
	ld l,e			; $49df
	inc (hl)		; $49e0
	ld a,$03		; $49e1
	jr _label_11_069		; $49e3
	call _partDecCounter1IfNonzero		; $49e5
	ret nz			; $49e8
	ld (hl),$08		; $49e9
	ld l,e			; $49eb
	inc (hl)		; $49ec
	ld a,$04		; $49ed
_label_11_069:
	push af			; $49ef
	call objectGetShortPosition		; $49f0
	ld c,a			; $49f3
	pop af			; $49f4
	jp setTile		; $49f5
	call _partDecCounter1IfNonzero		; $49f8
	ret nz			; $49fb
	ld l,e			; $49fc
	ld (hl),$01		; $49fd
	ld l,$e4		; $49ff
	set 7,(hl)		; $4a01
	ret			; $4a03

;;
; @addr{4a04}
partCode10:
	jr z,_label_11_070	; $4a04
	cp $02			; $4a06
	jp z,$4aae		; $4a08
	ld e,$c4		; $4a0b
	ld a,$02		; $4a0d
	ld (de),a		; $4a0f
_label_11_070:
	ld e,$c4		; $4a10
	ld a,(de)		; $4a12
	rst_jumpTable			; $4a13
.dw $4a1e
.dw $4a45
.dw $4a46
.dw $4a47
.dw $4a5e
	ld a,$01		; $4a1e
	ld (de),a		; $4a20
	ld e,$c2		; $4a21
	ld a,(de)		; $4a23
	ld hl,$4a3b		; $4a24
	rst_addDoubleIndex			; $4a27
	ld e,$dd		; $4a28
	ld a,(de)		; $4a2a
	add (hl)		; $4a2b
	ld (de),a		; $4a2c
	inc hl			; $4a2d
	dec e			; $4a2e
	ld a,(hl)		; $4a2f
	ld (de),a		; $4a30
	dec e			; $4a31
	ld (de),a		; $4a32
	ld a,$01		; $4a33
	call partSetAnimation		; $4a35
	jp objectSetVisiblec3		; $4a38
	ld (de),a		; $4a3b
	ld (bc),a		; $4a3c
	inc d			; $4a3d
	inc bc			; $4a3e
	ld d,$01		; $4a3f
	jr _label_11_071		; $4a41
	ld a,(de)		; $4a43
_label_11_071:
	nop			; $4a44
	ret			; $4a45
	ret			; $4a46
	call objectCheckCollidedWithLink_notDeadAndNotGrabbing		; $4a47
	jr c,_label_11_072	; $4a4a
	call objectApplySpeed		; $4a4c
	ld c,$20		; $4a4f
	call objectUpdateSpeedZAndBounce		; $4a51
	ret nc			; $4a54
_label_11_072:
	ld h,d			; $4a55
	ld l,$c4		; $4a56
	ld (hl),$04		; $4a58
	inc l			; $4a5a
	ld (hl),$00		; $4a5b
	ret			; $4a5d
	ld e,$c5		; $4a5e
	ld a,(de)		; $4a60
	rst_jumpTable			; $4a61
.dw $4a66
.dw $4aa9
	ld e,$c2		; $4a66
	ld a,(de)		; $4a68
	ld l,a			; $4a69
	add TREASURE_EMBER_SEEDS			; $4a6a
	call checkTreasureObtained		; $4a6c
	jr c,_label_11_074	; $4a6f
	ld e,$c5		; $4a71
	ld a,$01		; $4a73
	ld (de),a		; $4a75
	ld a,l			; $4a76
	ld hl,$4a85		; $4a77
	rst_addAToHl			; $4a7a
	ld c,(hl)		; $4a7b
	ld b,$00		; $4a7c
	call showText		; $4a7e
	ld c,$06		; $4a81
	jr _label_11_073		; $4a83
	add hl,hl		; $4a85
	add hl,hl		; $4a86
	dec hl			; $4a87
	inc l			; $4a88
	ldi a,(hl)		; $4a89
_label_11_073:
	ld e,$c2		; $4a8a
	ld a,(de)		; $4a8c
	add $20			; $4a8d
	jp giveTreasure		; $4a8f
_label_11_074:
	ld c,$06		; $4a92
	call $4a8a		; $4a94
_label_11_075:
	ld a,$00		; $4a97
	call objectGetRelatedObject2Var		; $4a99
	ld a,(hl)		; $4a9c
	or a			; $4a9d
	jr z,_label_11_076	; $4a9e
	ld a,l			; $4aa0
	add $03			; $4aa1
	ld l,a			; $4aa3
	ld (hl),$01		; $4aa4
_label_11_076:
	jp partDelete		; $4aa6
	call retIfTextIsActive		; $4aa9
	jr _label_11_075		; $4aac
	ld h,d			; $4aae
	ld l,$e4		; $4aaf
	res 7,(hl)		; $4ab1
	ld a,($cfc0)		; $4ab3
	or a			; $4ab6
	ret nz			; $4ab7
	ld a,TREASURE_SEED_SATCHEL		; $4ab8
	call checkTreasureObtained		; $4aba
	jr c,_label_11_077	; $4abd
	ld a,d			; $4abf
	ld ($cfc0),a		; $4ac0
	ld bc,$0035		; $4ac3
	jp showText		; $4ac6
_label_11_077:
	ld bc,$fec0		; $4ac9
	call objectSetSpeedZ		; $4acc
	ld l,$e9		; $4acf
	ld a,$03		; $4ad1
	ld (hl),a		; $4ad3
	ld l,$c4		; $4ad4
	ldi (hl),a		; $4ad6
	ld (hl),$00		; $4ad7
	inc l			; $4ad9
	ld (hl),$02		; $4ada
	ld l,$d0		; $4adc
	ld (hl),$28		; $4ade
	call objectGetAngleTowardLink		; $4ae0
	ld e,$c9		; $4ae3
	ld (de),a		; $4ae5
	ret			; $4ae6

;;
; @addr{4ae7}
partCode11:
	ld e,$c2		; $4ae7
	ld a,(de)		; $4ae9
	ld e,$c4		; $4aea
	rst_jumpTable			; $4aec
.dw $4af3
.dw $4b2e
.dw $4bd1
	ld a,(de)		; $4af3
	or a			; $4af4
	jr z,_label_11_079	; $4af5
	ld c,$16		; $4af7
	call objectUpdateSpeedZAndBounce		; $4af9
	jp c,partDelete		; $4afc
	jp nz,objectApplySpeed		; $4aff
	call getRandomNumber_noPreserveVars		; $4b02
	and $03			; $4b05
	dec a			; $4b07
	ret z			; $4b08
	ld b,a			; $4b09
	ld e,$c9		; $4b0a
	ld a,(de)		; $4b0c
	add b			; $4b0d
	and $1f			; $4b0e
_label_11_078:
	ld (de),a		; $4b10
	jp $4c09		; $4b11
_label_11_079:
	ld bc,$fd80		; $4b14
	call objectSetSpeedZ		; $4b17
	ld l,e			; $4b1a
	inc (hl)		; $4b1b
	ld l,$e4		; $4b1c
	set 7,(hl)		; $4b1e
	call objectSetVisible80		; $4b20
	call getRandomNumber_noPreserveVars		; $4b23
	and $0f			; $4b26
	add $08			; $4b28
	ld e,$c9		; $4b2a
	jr _label_11_078		; $4b2c
	ld a,(de)		; $4b2e
	rst_jumpTable			; $4b2f
.dw $4b3c
.dw $4b66
.dw $4b82
.dw $4b8d
.dw $4ba8
.dw $4bc4
	ld h,d			; $4b3c
	ld l,e			; $4b3d
	inc (hl)		; $4b3e
	ld l,$e4		; $4b3f
	set 7,(hl)		; $4b41
	ld l,$e6		; $4b43
	ld a,(hl)		; $4b45
	add a			; $4b46
	ldi (hl),a		; $4b47
	ldi (hl),a		; $4b48
	sla (hl)		; $4b49
	ld l,$d0		; $4b4b
	ld (hl),$05		; $4b4d
	ld l,$d4		; $4b4f
	ld a,$00		; $4b51
	ldi (hl),a		; $4b53
	ld (hl),$fc		; $4b54
	call getRandomNumber_noPreserveVars		; $4b56
	and $1f			; $4b59
	ld e,$c9		; $4b5b
	ld (de),a		; $4b5d
	ld a,$01		; $4b5e
	call partSetAnimation		; $4b60
	jp objectSetVisible80		; $4b63
	ld h,d			; $4b66
	ld l,$cb		; $4b67
	ld e,$cf		; $4b69
	ld a,(de)		; $4b6b
	add (hl)		; $4b6c
	add $08			; $4b6d
	cp $f8			; $4b6f
	ld c,$10		; $4b71
	jp c,objectUpdateSpeedZ_paramC		; $4b73
	ld l,$c4		; $4b76
	inc (hl)		; $4b78
	ld l,$c6		; $4b79
	ld (hl),$1e		; $4b7b
	call objectSetInvisible		; $4b7d
	jr $5e			; $4b80
	call _partDecCounter1IfNonzero		; $4b82
	ret nz			; $4b85
	ld (hl),$10		; $4b86
	ld l,e			; $4b88
	inc (hl)		; $4b89
	jp objectSetVisiblec0		; $4b8a
	call partAnimate		; $4b8d
	ld h,d			; $4b90
	ld l,$cf		; $4b91
	inc (hl)		; $4b93
	inc (hl)		; $4b94
	ret nz			; $4b95
	call objectReplaceWithAnimationIfOnHazard		; $4b96
	jp c,partDelete		; $4b99
	ld h,d			; $4b9c
	ld l,$c4		; $4b9d
	inc (hl)		; $4b9f
	ld l,$d4		; $4ba0
	xor a			; $4ba2
	ldi (hl),a		; $4ba3
	ld (hl),a		; $4ba4
	jp objectSetVisible82		; $4ba5
	call partAnimate		; $4ba8
	ld c,$16		; $4bab
	call objectUpdateSpeedZ_paramC		; $4bad
	jp nz,objectApplySpeed		; $4bb0
	ld l,$c4		; $4bb3
	inc (hl)		; $4bb5
	ld l,$dd		; $4bb6
	ld (hl),$26		; $4bb8
	ld a,$03		; $4bba
	call partSetAnimation		; $4bbc
	ld a,SND_STRONG_POUND		; $4bbf
	jp playSound		; $4bc1
	ld e,$e1		; $4bc4
	ld a,(de)		; $4bc6
	inc a			; $4bc7
	jp z,partDelete		; $4bc8
	call $4c1c		; $4bcb
	jp partAnimate		; $4bce
	ld a,(de)		; $4bd1
	rst_jumpTable			; $4bd2
.dw $4bdd
.dw $4b82
.dw $4b8d
.dw $4ba8
.dw $4bc4
	ld a,$01		; $4bdd
	ld (de),a		; $4bdf
	call getRandomNumber_noPreserveVars		; $4be0
	ld b,a			; $4be3
	ld hl,hCameraY		; $4be4
	ld e,$cb		; $4be7
	and $70			; $4be9
	add $08			; $4beb
	add (hl)		; $4bed
	ld (de),a		; $4bee
	cpl			; $4bef
	inc a			; $4bf0
	and $fe			; $4bf1
	ld e,$cf		; $4bf3
	ld (de),a		; $4bf5
	ld l,$ac		; $4bf6
	ld e,$cd		; $4bf8
	ld a,b			; $4bfa
	and $07			; $4bfb
	inc a			; $4bfd
	swap a			; $4bfe
	add $08			; $4c00
	add (hl)		; $4c02
	ld (de),a		; $4c03
	ld a,$02		; $4c04
	jp partSetAnimation		; $4c06
	ld b,$14		; $4c09
	cp $0d			; $4c0b
	jr c,_label_11_080	; $4c0d
	ld b,$0a		; $4c0f
	cp $14			; $4c11
	jr c,_label_11_080	; $4c13
	ld b,$14		; $4c15
_label_11_080:
	ld a,b			; $4c17
	ld e,$d0		; $4c18
	ld (de),a		; $4c1a
	ret			; $4c1b
	dec a			; $4c1c
	ld hl,$4c29		; $4c1d
	rst_addAToHl			; $4c20
	ld e,$e6		; $4c21
	ldi a,(hl)		; $4c23
	ld (de),a		; $4c24
	inc e			; $4c25
	ld a,(hl)		; $4c26
	ld (de),a		; $4c27
	ret			; $4c28
	inc b			; $4c29
	add hl,bc		; $4c2a
	ld b,$0b		; $4c2b
	add hl,bc		; $4c2d
	inc c			; $4c2e
	ld a,(bc)		; $4c2f
	dec c			; $4c30
	dec bc			; $4c31
	.db $0e


;;
; @addr{4c33}
partCode12:
	ld e,$c4		; $4c33
	ld a,(de)		; $4c35
	or a			; $4c36
	call z,$4c76		; $4c37
	ld a,$01		; $4c3a
	call objectGetRelatedObject1Var		; $4c3c
	ld e,$f0		; $4c3f
	ld a,(de)		; $4c41
	cp (hl)			; $4c42
	jr nz,_label_11_082	; $4c43
	ld c,$10		; $4c45
	call objectUpdateSpeedZAndBounce		; $4c47
	ld a,$0f		; $4c4a
	call objectGetRelatedObject1Var		; $4c4c
	ld e,$cf		; $4c4f
	ld a,(de)		; $4c51
	ld (hl),a		; $4c52
	call objectTakePosition		; $4c53
	ld c,h			; $4c56
	call _partDecCounter1IfNonzero		; $4c57
	jp nz,partAnimate		; $4c5a
	ld h,c			; $4c5d
	ld l,$a9		; $4c5e
	ld e,$f1		; $4c60
	ld a,(de)		; $4c62
	ld (hl),a		; $4c63
	or a			; $4c64
	jr nz,_label_11_081	; $4c65
	ld l,$a4		; $4c67
	res 7,(hl)		; $4c69
_label_11_081:
	ld l,$ab		; $4c6b
	ld (hl),$00		; $4c6d
	ld l,$ae		; $4c6f
	ld (hl),$01		; $4c71
_label_11_082:
	jp partDelete		; $4c73
	ld h,d			; $4c76
	ld l,e			; $4c77
	inc (hl)		; $4c78
	ld l,$c6		; $4c79
	ld (hl),$3b		; $4c7b
	ld a,$01		; $4c7d
	call objectGetRelatedObject1Var		; $4c7f
	ld e,$f0		; $4c82
	ld a,(hl)		; $4c84
	ld (de),a		; $4c85
	ld e,$f1		; $4c86
	ld l,$a9		; $4c88
	ld a,(hl)		; $4c8a
	ld (de),a		; $4c8b
	ld (hl),$01		; $4c8c
	call objectTakePosition		; $4c8e
	jp objectSetVisible80		; $4c91

;;
; @addr{4c94}
partCode13:
	jr z,_label_11_083	; $4c94
	ld e,$ea		; $4c96
	ld a,(de)		; $4c98
	cp $9a			; $4c99
	jr nz,_label_11_083	; $4c9b
	ld h,d			; $4c9d
	ld l,$c4		; $4c9e
	ld a,(hl)		; $4ca0
	cp $02			; $4ca1
	jr nc,_label_11_083	; $4ca3
	inc (hl)		; $4ca5
	ld l,$c6		; $4ca6
	ld (hl),$32		; $4ca8
_label_11_083:
	ld e,$c4		; $4caa
	ld a,(de)		; $4cac
	rst_jumpTable			; $4cad
.dw $4cb6
.dw $4cc7
.dw $4cc8
.dw $4cfb
	ld h,d			; $4cb6
	ld l,e			; $4cb7
	inc (hl)		; $4cb8
	ld l,$ff		; $4cb9
	set 5,(hl)		; $4cbb
	call objectMakeTileSolid		; $4cbd
	ld h,$cf		; $4cc0
	ld (hl),$00		; $4cc2
	jp objectSetVisible83		; $4cc4
	ret			; $4cc7
	call _partDecCounter1IfNonzero		; $4cc8
	jr nz,_label_11_084	; $4ccb
	ld (hl),$1e		; $4ccd
	ld l,e			; $4ccf
	inc (hl)		; $4cd0
	ld a,$01		; $4cd1
	jp partSetAnimation		; $4cd3
_label_11_084:
	ld a,(hl)		; $4cd6
	and $07			; $4cd7
	ret nz			; $4cd9
	ld a,(hl)		; $4cda
	rrca			; $4cdb
	rrca			; $4cdc
	sub $02			; $4cdd
	ld hl,$4cef		; $4cdf
	rst_addAToHl			; $4ce2
	ldi a,(hl)		; $4ce3
	ld b,a			; $4ce4
	ld c,(hl)		; $4ce5
	call getFreeInteractionSlot		; $4ce6
	ret nz			; $4ce9
	ld (hl),$84		; $4cea
	jp objectCopyPositionWithOffset		; $4cec
	ld sp,hl		; $4cef
	dec b			; $4cf0
	ld b,$ff		; $4cf1
.DB $fc				; $4cf3
	ld a,($0702)		; $4cf4
	nop			; $4cf7
	ld a,($02ff)		; $4cf8
	call _partDecCounter1IfNonzero		; $4cfb
	jr nz,_label_11_085	; $4cfe
	ld l,e			; $4d00
	ld (hl),$01		; $4d01
	xor a			; $4d03
	jp partSetAnimation		; $4d04
_label_11_085:
	ld a,(hl)		; $4d07
	cp $16			; $4d08
	ret nz			; $4d0a
	ld l,$c2		; $4d0b
	ld c,(hl)		; $4d0d
	ld b,$39		; $4d0e
	jp showText		; $4d10

;;
; @addr{4d13}
partCode14:
partCode15:
	ld e,$c2		; $4d13
	jr z,_label_11_086	; $4d15
	cp $02			; $4d17
	jp z,$4e20		; $4d19
	ld h,d			; $4d1c
	ld l,$c2		; $4d1d
	set 7,(hl)		; $4d1f
	ld l,$c4		; $4d21
	ld (hl),$03		; $4d23
	inc l			; $4d25
	ld (hl),$00		; $4d26
_label_11_086:
	ld e,$c4		; $4d28
	ld a,(de)		; $4d2a
	rst_jumpTable			; $4d2b
.dw $4d36
.dw $4d83
.dw objectReplaceWithAnimationIfOnHazard
.dw $4d9b
.dw $4dcc

	ld h,d			; $4d36
	ld l,e			; $4d37
	inc (hl)		; $4d38
	ld l,$e6		; $4d39
	ld a,$06		; $4d3b
	ldi (hl),a		; $4d3d
	ld (hl),a		; $4d3e
	call getRandomNumber		; $4d3f
	ld b,a			; $4d42
	and $70			; $4d43
	swap a			; $4d45
	ld hl,$4d6b		; $4d47
	rst_addAToHl			; $4d4a
	ld e,$d0		; $4d4b
	ld a,(hl)		; $4d4d
	ld (de),a		; $4d4e
	ld a,b			; $4d4f
	and $0e			; $4d50
	ld hl,$4d73		; $4d52
	rst_addAToHl			; $4d55
	ld e,$d4		; $4d56
	ldi a,(hl)		; $4d58
	ld (de),a		; $4d59
	inc e			; $4d5a
	ldi a,(hl)		; $4d5b
	ld (de),a		; $4d5c
	call getRandomNumber		; $4d5d
	ld e,$c9		; $4d60
	and $1f			; $4d62
	ld (de),a		; $4d64
	call $4ec0		; $4d65
	jp objectSetVisiblec3		; $4d68
	inc d			; $4d6b
	ld e,$28		; $4d6c
	ldd (hl),a		; $4d6e
	inc a			; $4d6f
	ld b,(hl)		; $4d70
	ld d,b			; $4d71
	ld e,d			; $4d72
	add b			; $4d73
	cp $40			; $4d74
	cp $00			; $4d76
	cp $c0			; $4d78
.DB $fd				; $4d7a
	add b			; $4d7b
.DB $fd				; $4d7c
	ld b,b			; $4d7d
.DB $fd				; $4d7e
	nop			; $4d7f
.DB $fd				; $4d80
	ret nz			; $4d81
.DB $fc				; $4d82
	call objectApplySpeed		; $4d83
	call $4f03		; $4d86
	ld c,$20		; $4d89
	call objectUpdateSpeedZAndBounce		; $4d8b
	jr nc,_label_11_087	; $4d8e
	ld h,d			; $4d90
	ld l,$e4		; $4d91
	set 7,(hl)		; $4d93
	ld l,$c4		; $4d95
	inc (hl)		; $4d97
_label_11_087:
	jp objectReplaceWithAnimationIfOnHazard		; $4d98
	inc e			; $4d9b
	ld a,(de)		; $4d9c
	or a			; $4d9d
	jr nz,_label_11_088	; $4d9e
	ld h,d			; $4da0
	ld l,e			; $4da1
	inc (hl)		; $4da2
	ld l,$cf		; $4da3
	ld (hl),$00		; $4da5
	ld a,$01		; $4da7
	call objectGetRelatedObject1Var		; $4da9
	ld a,(hl)		; $4dac
	ld e,$f0		; $4dad
	ld (de),a		; $4daf
	call objectSetVisible80		; $4db0
_label_11_088:
	call objectCheckCollidedWithLink		; $4db3
	jp c,$4e20		; $4db6
	ld a,$00		; $4db9
	call objectGetRelatedObject1Var		; $4dbb
	ldi a,(hl)		; $4dbe
	or a			; $4dbf
	jr z,_label_11_089	; $4dc0
	ld e,$f0		; $4dc2
	ld a,(de)		; $4dc4
	cp (hl)			; $4dc5
	jp z,objectTakePosition		; $4dc6
_label_11_089:
	jp partDelete		; $4dc9
	inc e			; $4dcc
	ld a,(de)		; $4dcd
	rst_jumpTable			; $4dce
.dw $4dd7
.dw $4de6
.dw $4dfe
.dw $4e18
	ld h,d			; $4dd7
	ld l,e			; $4dd8
	inc (hl)		; $4dd9
	ld a,($d128)		; $4dda
	dec a			; $4ddd
	ld l,$d0		; $4dde
	ld (hl),$14		; $4de0
	jr z,_label_11_090	; $4de2
	ld (hl),$28		; $4de4
_label_11_090:
	ld hl,$d128		; $4de6
	ld a,(hl)		; $4de9
	or a			; $4dea
	jr z,_label_11_091	; $4deb
	call $4f2f		; $4ded
	ret nz			; $4df0
	ld l,$c5		; $4df1
	inc (hl)		; $4df3
	ld l,$e4		; $4df4
	res 7,(hl)		; $4df6
	ld bc,$ffc0		; $4df8
	jp objectSetSpeedZ		; $4dfb
	ld c,$00		; $4dfe
	call objectUpdateSpeedZ_paramC		; $4e00
	ld e,$cf		; $4e03
	ld a,(de)		; $4e05
	cp $f7			; $4e06
	ret nc			; $4e08
_label_11_091:
	ld a,$01		; $4e09
	ld ($d125),a		; $4e0b
	ld h,d			; $4e0e
	ld l,$c5		; $4e0f
	ld (hl),$03		; $4e11
	ld l,$c3		; $4e13
	ld (hl),$00		; $4e15
	ret			; $4e17
	ld e,$c3		; $4e18
	ld a,(de)		; $4e1a
	rlca			; $4e1b
	ret nc			; $4e1c
	jp partDelete		; $4e1d
	ld a,(wDisabledObjects)		; $4e20
	bit 0,a			; $4e23
	ret nz			; $4e25
	ld e,$c2		; $4e26
	ld a,(de)		; $4e28
	and $7f			; $4e29
	ld hl,$4f4a		; $4e2b
	rst_addAToHl			; $4e2e
	ld a,($d12a)		; $4e2f
	add (hl)		; $4e32
	ld ($d12a),a		; $4e33
	ld a,(de)		; $4e36
	and $7f			; $4e37
	jr z,_label_11_097	; $4e39
	add a			; $4e3b
	ld hl,$4e88		; $4e3c
	rst_addDoubleIndex			; $4e3f
	ldi a,(hl)		; $4e40
	ld b,a			; $4e41
	ld a,$26		; $4e42
	call cpActiveRing		; $4e44
	ldi a,(hl)		; $4e47
	jr z,_label_11_093	; $4e48
	cp $ff			; $4e4a
	jr z,_label_11_094	; $4e4c
	call cpActiveRing		; $4e4e
	jr nz,_label_11_094	; $4e51
_label_11_093:
	inc hl			; $4e53
_label_11_094:
	ld c,(hl)		; $4e54
	ld a,b			; $4e55
	cp TREASURE_RING			; $4e56
	jr nz,_label_11_095	; $4e58
	call getRandomRingOfGivenTier		; $4e5a
_label_11_095:
	cp TREASURE_POTION			; $4e5d
	jr nz,_label_11_096	; $4e5f
	ld a,SND_GETSEED		; $4e61
	call playSound		; $4e63
	ld a,TREASURE_POTION		; $4e66
_label_11_096:
	call giveTreasure		; $4e68
	jp partDelete		; $4e6b
_label_11_097:
	ld bc,$2b02		; $4e6e
	call createTreasure		; $4e71
	ret nz			; $4e74
	ld l,$4b		; $4e75
	ld a,(w1Link.yh)		; $4e77
	ldi (hl),a		; $4e7a
	inc l			; $4e7b
	ld a,(w1Link.xh)		; $4e7c
	ld (hl),a		; $4e7f
	ld hl,wMapleState		; $4e80
	set 7,(hl)		; $4e83
	jp partDelete		; $4e85
	dec hl			; $4e88
	rst $38			; $4e89
	ld bc,$3401		; $4e8a
	rst $38			; $4e8d
	ld bc,$2d01		; $4e8e
	rst $38			; $4e91
	ld bc,$2d01		; $4e92
	rst $38			; $4e95
	ld (bc),a		; $4e96
	ld (bc),a		; $4e97
	cpl			; $4e98
	rst $38			; $4e99
	ld bc,$2001		; $4e9a
	rst $38			; $4e9d
	dec b			; $4e9e
	ld a,(bc)		; $4e9f
	ld hl,$05ff		; $4ea0
	ld a,(bc)		; $4ea3
	ldi (hl),a		; $4ea4
	rst $38			; $4ea5
	dec b			; $4ea6
	ld a,(bc)		; $4ea7
	inc hl			; $4ea8
	rst $38			; $4ea9
	dec b			; $4eaa
	ld a,(bc)		; $4eab
	inc h			; $4eac
	rst $38			; $4ead
	dec b			; $4eae
	ld a,(bc)		; $4eaf
	inc bc			; $4eb0
	rst $38			; $4eb1
	inc b			; $4eb2
	ld ($2529),sp		; $4eb3
	inc b			; $4eb6
	ld ($2428),sp		; $4eb7
	inc bc			; $4eba
	inc b			; $4ebb
	jr z,_label_11_098	; $4ebc
	ld bc,$1e02		; $4ebe
	jp nz,$4f1a		; $4ec1
	add a			; $4ec4
	add c			; $4ec5
	ld hl,$4ed9		; $4ec6
	rst_addAToHl			; $4ec9
	ld e,$dd		; $4eca
	ld a,(de)		; $4ecc
	add (hl)		; $4ecd
	ld (de),a		; $4ece
	inc hl			; $4ecf
	dec e			; $4ed0
	ldi a,(hl)		; $4ed1
	ld (de),a		; $4ed2
	dec e			; $4ed3
	ld (de),a		; $4ed4
	ld a,(hl)		; $4ed5
	jp partSetAnimation		; $4ed6
	stop			; $4ed9
	ld (bc),a		; $4eda
	stop			; $4edb
	ld a,(bc)		; $4edc
	ld bc,$0800		; $4edd
	nop			; $4ee0
	nop			; $4ee1
_label_11_098:
	ld ($0000),sp		; $4ee2
	nop			; $4ee5
	ld (bc),a		; $4ee6
	rrca			; $4ee7
	ld (de),a		; $4ee8
	ld (bc),a		; $4ee9
	dec b			; $4eea
	inc d			; $4eeb
	inc bc			; $4eec
	ld b,$16		; $4eed
	ld bc,$1807		; $4eef
	ld bc,$1a08		; $4ef2
	nop			; $4ef5
	ld ($0410),sp		; $4ef6
	inc b			; $4ef9
	ld (bc),a		; $4efa
	dec b			; $4efb
	ld bc,$0506		; $4efc
	inc bc			; $4eff
	inc b			; $4f00
	nop			; $4f01
	ld (bc),a		; $4f02
	ld h,d			; $4f03
	ld l,$cb		; $4f04
	ld a,(hl)		; $4f06
	cp $f0			; $4f07
	jr c,_label_11_099	; $4f09
	xor a			; $4f0b
_label_11_099:
	cp $20			; $4f0c
	jr nc,_label_11_100	; $4f0e
	ld (hl),$20		; $4f10
	jr _label_11_101		; $4f12
_label_11_100:
	cp $78			; $4f14
	jr c,_label_11_101	; $4f16
	ld (hl),$78		; $4f18
_label_11_101:
	ld l,$cd		; $4f1a
	ld a,(hl)		; $4f1c
	cp $f0			; $4f1d
	jr c,_label_11_102	; $4f1f
	xor a			; $4f21
_label_11_102:
	cp $08			; $4f22
	jr nc,_label_11_103	; $4f24
	ld (hl),$08		; $4f26
	ret			; $4f28
_label_11_103:
	cp $98			; $4f29
	ret c			; $4f2b
	ld (hl),$98		; $4f2c
	ret			; $4f2e
	ld l,$0b		; $4f2f
	ld b,(hl)		; $4f31
	ld l,$0d		; $4f32
	ld c,(hl)		; $4f34
	push bc			; $4f35
	call objectGetRelativeAngle		; $4f36
	ld e,$c9		; $4f39
	ld (de),a		; $4f3b
	call objectApplySpeed		; $4f3c
	pop bc			; $4f3f
	ld h,d			; $4f40
	ld l,$cb		; $4f41
	ldi a,(hl)		; $4f43
	cp b			; $4f44
	ret nz			; $4f45
	inc l			; $4f46
	ld a,(hl)		; $4f47
	cp c			; $4f48
	ret			; $4f49
	inc a			; $4f4a
	rrca			; $4f4b
	ld a,(bc)		; $4f4c
	ld ($0506),sp		; $4f4d
	dec b			; $4f50
	dec b			; $4f51
	dec b			; $4f52
	dec b			; $4f53
	inc b			; $4f54
	inc bc			; $4f55
	ld (bc),a		; $4f56
.db $01 $00

;;
; @addr{4f59}
partCode17:
	jr z,_label_11_104	; $4f59
	ld e,$c2		; $4f5b
	ld a,(de)		; $4f5d
	add a			; $4f5e
	ld hl,$501e		; $4f5f
	rst_addDoubleIndex			; $4f62
	ld e,$ea		; $4f63
	ld a,(de)		; $4f65
	and $1f			; $4f66
	call checkFlag		; $4f68
	jr z,_label_11_104	; $4f6b
	call checkLinkVulnerable		; $4f6d
	jr nc,_label_11_104	; $4f70
	ld h,d			; $4f72
	ld l,$c4		; $4f73
	ld (hl),$02		; $4f75
	ld l,$e4		; $4f77
	res 7,(hl)		; $4f79
	ld l,$c2		; $4f7b
	ld a,(hl)		; $4f7d
	or a			; $4f7e
	jr z,_label_11_104	; $4f7f
	ld a,$2a		; $4f81
	call objectGetRelatedObject1Var		; $4f83
	ld (hl),$ff		; $4f86
_label_11_104:
	ld e,$c4		; $4f88
	ld a,(de)		; $4f8a
	rst_jumpTable			; $4f8b
.dw $4f92
.dw $4fab
.dw $4fbc
	ld a,$01		; $4f92
	ld (de),a		; $4f94
	ld a,$26		; $4f95
	call objectGetRelatedObject1Var		; $4f97
	ld e,$e6		; $4f9a
	ldi a,(hl)		; $4f9c
	ld (de),a		; $4f9d
	inc e			; $4f9e
	ld a,(hl)		; $4f9f
	ld (de),a		; $4fa0
	call objectTakePosition		; $4fa1
	ld e,$f0		; $4fa4
	ld l,$41		; $4fa6
	ld a,(hl)		; $4fa8
	ld (de),a		; $4fa9
	ret			; $4faa
	call $4fb2		; $4fab
	ret z			; $4fae
	jp partDelete		; $4faf
	ld a,$01		; $4fb2
	call objectGetRelatedObject1Var		; $4fb4
	ld e,$f0		; $4fb7
	ld a,(de)		; $4fb9
	cp (hl)			; $4fba
	ret			; $4fbb
	call $4fb2		; $4fbc
	jp nz,partDelete		; $4fbf
	ld e,$c5		; $4fc2
	ld a,(de)		; $4fc4
	rst_jumpTable			; $4fc5
.dw $4fcc
.dw $4fec
.dw $5003
	ld h,d			; $4fcc
	ld l,e			; $4fcd
	inc (hl)		; $4fce
	ld l,$d0		; $4fcf
	ld (hl),$28		; $4fd1
	ld a,$1a		; $4fd3
	call objectGetRelatedObject1Var		; $4fd5
	set 6,(hl)		; $4fd8
	ld e,$c2		; $4fda
	ld a,(de)		; $4fdc
	or a			; $4fdd
	ld a,$10		; $4fde
	call nz,objectGetAngleTowardLink		; $4fe0
	ld e,$c9		; $4fe3
	ld (de),a		; $4fe5
	ld bc,$fec0		; $4fe6
	jp objectSetSpeedZ		; $4fe9
	ld c,$18		; $4fec
	call objectUpdateSpeedZAndBounce		; $4fee
	jr z,_label_11_105	; $4ff1
	call objectApplySpeed		; $4ff3
	ld a,$00		; $4ff6
	call objectGetRelatedObject1Var		; $4ff8
	jp objectCopyPosition		; $4ffb
_label_11_105:
	ld e,$c5		; $4ffe
	ld a,$02		; $5000
	ld (de),a		; $5002
	ld c,$18		; $5003
	call objectUpdateSpeedZAndBounce		; $5005
	jr nc,_label_11_106	; $5008
	call $5010		; $500a
	jp partDelete		; $500d
_label_11_106:
	call objectCheckTileCollision_allowHoles		; $5010
	call nc,objectApplySpeed		; $5013
	ld a,$00		; $5016
	call objectGetRelatedObject1Var		; $5018
	jp objectCopyPosition		; $501b
	ld a,($ff00+$03)	; $501e
	nop			; $5020
	nop			; $5021
	ld a,($ff00+$03)	; $5022
	nop			; $5024
	nop			; $5025

;;
; @addr{5026}
partCode18:
	jr z,_label_11_107	; $5026
	ld e,$ea		; $5028
	ld a,(de)		; $502a
	cp $80			; $502b
	jp z,partDelete		; $502d
	ld h,d			; $5030
	ld l,$c4		; $5031
	ld a,(hl)		; $5033
	cp $02			; $5034
	jr nc,_label_11_107	; $5036
	ld (hl),$02		; $5038
_label_11_107:
	ld e,$c4		; $503a
	ld a,(de)		; $503c
	rst_jumpTable			; $503d
.dw $5046
.dw $5050
.dw $5066
.dw $40cf
	ld h,d			; $5046
	ld l,e			; $5047
	inc (hl)		; $5048
	ld l,$d0		; $5049
	ld (hl),$50		; $504b
	jp objectSetVisible81		; $504d
	call objectCheckWithinScreenBoundary		; $5050
	jp nc,partDelete		; $5053
	call _partCommon_checkTileCollisionOrOutOfBounds		; $5056
	jr nc,_label_11_108	; $5059
	jp z,partDelete		; $505b
	ld e,$c4		; $505e
	ld a,$02		; $5060
	ld (de),a		; $5062
_label_11_108:
	jp objectApplySpeed		; $5063
	ld a,$03		; $5066
	ld (de),a		; $5068
	xor a			; $5069
	jp $40af		; $506a

;;
; @addr{506d}
partCode19:
partCode31:
	jp nz,partDelete		; $506d
	ld e,$c4		; $5070
	ld a,(de)		; $5072
	rst_jumpTable			; $5073
.dw $507a
.dw $5088
.dw $50a8
	ld h,d			; $507a
	ld l,e			; $507b
	inc (hl)		; $507c
	ld l,$c6		; $507d
	ld (hl),$08		; $507f
	ld l,$d0		; $5081
	ld (hl),$3c		; $5083
	jp objectSetVisible81		; $5085
	call _partDecCounter1IfNonzero		; $5088
	ret nz			; $508b
	ld l,e			; $508c
	inc (hl)		; $508d
	ld l,$c2		; $508e
	bit 0,(hl)		; $5090
	jr z,_label_11_109	; $5092
	ldh a,(<hFFB2)	; $5094
	ld b,a			; $5096
	ldh a,(<hFFB3)	; $5097
	ld c,a			; $5099
	call objectGetRelativeAngle		; $509a
	ld e,$c9		; $509d
	ld (de),a		; $509f
	ret			; $50a0
_label_11_109:
	call objectGetAngleTowardEnemyTarget		; $50a1
	ld e,$c9		; $50a4
	ld (de),a		; $50a6
	ret			; $50a7
	ld a,(wFrameCounter)		; $50a8
	and $03			; $50ab
	jr nz,_label_11_110	; $50ad
	ld e,$dc		; $50af
	ld a,(de)		; $50b1
	xor $07			; $50b2
	ld (de),a		; $50b4
_label_11_110:
	call objectApplySpeed		; $50b5
	call objectCheckWithinScreenBoundary		; $50b8
	jp nc,partDelete		; $50bb
	jp partAnimate		; $50be

;;
; @addr{50c1}
partCode1a:
	jr z,_label_11_111	; $50c1
	ld e,$ea		; $50c3
	ld a,(de)		; $50c5
	cp $80			; $50c6
	jr z,_label_11_115	; $50c8
	jr _label_11_116		; $50ca
_label_11_111:
	ld e,$c2		; $50cc
	ld a,(de)		; $50ce
	rst_jumpTable			; $50cf
.dw $50d4
.dw $5103
	ld e,$c4		; $50d4
	ld a,(de)		; $50d6
	rst_jumpTable			; $50d7
.dw $50de
.dw $50fa
.dw $40cf
	ld h,d			; $50de
	ld l,e			; $50df
	inc (hl)		; $50e0
	ld l,$d0		; $50e1
	ld (hl),$50		; $50e3
	ld l,$cb		; $50e5
	ld b,(hl)		; $50e7
	ld l,$cd		; $50e8
	ld c,(hl)		; $50ea
	call $40e0		; $50eb
	ld e,$c9		; $50ee
	ld a,(de)		; $50f0
	swap a			; $50f1
	rlca			; $50f3
	call partSetAnimation		; $50f4
	jp objectSetVisible81		; $50f7
_label_11_112:
	call _partCommon_checkTileCollisionOrOutOfBounds		; $50fa
	jr nc,_label_11_114	; $50fd
	jr z,_label_11_115	; $50ff
	jr _label_11_116		; $5101
	ld e,$c4		; $5103
	ld a,(de)		; $5105
	rst_jumpTable			; $5106
.dw $510f
.dw $5126
	ld a,($cf50)		; $510b
	ld b,b			; $510e
	ld h,d			; $510f
	ld l,e			; $5110
	inc (hl)		; $5111
	ld l,$c6		; $5112
	ld (hl),$08		; $5114
	ld l,$d0		; $5116
	ld (hl),$50		; $5118
	ld e,$c9		; $511a
	ld a,(de)		; $511c
	swap a			; $511d
	rlca			; $511f
	call partSetAnimation		; $5120
	jp objectSetVisible81		; $5123
	call _partDecCounter1IfNonzero		; $5126
	jr nz,_label_11_113	; $5129
	ld l,e			; $512b
	inc (hl)		; $512c
	jr _label_11_112		; $512d
_label_11_113:
	call _partCommon_checkOutOfBounds		; $512f
	jr z,_label_11_115	; $5132
_label_11_114:
	jp objectApplySpeed		; $5134
_label_11_115:
	jp partDelete		; $5137
_label_11_116:
	ld e,$c2		; $513a
	ld a,(de)		; $513c
	or a			; $513d
	ld a,$02		; $513e
	jr z,_label_11_117	; $5140
	ld a,$03		; $5142
_label_11_117:
	ld e,$c4		; $5144
	ld (de),a		; $5146
	ld a,$04		; $5147
	jp $40af		; $5149

;;
; @addr{514c}
partCode1b:
	jr z,_label_11_118	; $514c
	ld e,$ea		; $514e
	ld a,(de)		; $5150
	res 7,a			; $5151
	cp $04			; $5153
	jp c,partDelete		; $5155
_label_11_118:
	ld e,$c4		; $5158
	ld a,(de)		; $515a
	or a			; $515b
	jr z,_label_11_119	; $515c
	call objectCheckWithinScreenBoundary		; $515e
	jp nc,partDelete		; $5161
	call objectApplySpeed		; $5164
	ld a,(wFrameCounter)		; $5167
	and $03			; $516a
	ret nz			; $516c
	ld e,$dc		; $516d
	ld a,(de)		; $516f
	xor $07			; $5170
	ld (de),a		; $5172
	ret			; $5173
_label_11_119:
	ld h,d			; $5174
	ld l,e			; $5175
	inc (hl)		; $5176
	ld l,$d0		; $5177
	ld (hl),$78		; $5179
	ld l,$cb		; $517b
	ld b,(hl)		; $517d
	ld l,$cd		; $517e
	ld c,(hl)		; $5180
	call $40e0		; $5181
	ld e,$c9		; $5184
	ld a,(de)		; $5186
	swap a			; $5187
	rlca			; $5189
	call partSetAnimation		; $518a
	jp objectSetVisible81		; $518d

;;
; @addr{5190}
partCode1c:
	jr z,_label_11_120	; $5190
	ld e,$ea		; $5192
	ld a,(de)		; $5194
	cp $80			; $5195
	jr z,_label_11_121	; $5197
	jr _label_11_123		; $5199
_label_11_120:
	ld e,$c4		; $519b
	ld a,(de)		; $519d
	rst_jumpTable			; $519e
.dw $51a5
.dw $51b5
.dw $51c6
	ld h,d			; $51a5
	ld l,e			; $51a6
	inc (hl)		; $51a7
	ld l,$d0		; $51a8
	ld (hl),$3c		; $51aa
	call objectGetAngleTowardEnemyTarget		; $51ac
	ld e,$c9		; $51af
	ld (de),a		; $51b1
	jp objectSetVisible81		; $51b2
	call _partCommon_checkTileCollisionOrOutOfBounds		; $51b5
	jr c,_label_11_122	; $51b8
	call objectApplySpeed		; $51ba
	call objectCheckWithinScreenBoundary		; $51bd
	jp c,partAnimate		; $51c0
_label_11_121:
	jp partDelete		; $51c3
	call _partDecCounter1IfNonzero		; $51c6
	jr z,_label_11_121	; $51c9
	ld c,$0e		; $51cb
	call objectUpdateSpeedZ_paramC		; $51cd
	call objectApplySpeed		; $51d0
	ld a,(wFrameCounter)		; $51d3
	rrca			; $51d6
	ret c			; $51d7
	jp partAnimate		; $51d8
_label_11_122:
	jr z,_label_11_121	; $51db
_label_11_123:
	ld e,$c4		; $51dd
	ld a,$02		; $51df
	ld (de),a		; $51e1
	xor a			; $51e2
	jp $40af		; $51e3

;;
; @addr{51e6}
partCode1d:
	jr z,_label_11_125	; $51e6
	ld e,$ea		; $51e8
	ld a,(de)		; $51ea
	cp $80			; $51eb
	jr z,_label_11_125	; $51ed
	cp $8a			; $51ef
	jr z,_label_11_125	; $51f1
	ld a,$2b		; $51f3
	call objectGetRelatedObject1Var		; $51f5
	ld a,(hl)		; $51f8
	or a			; $51f9
	jr nz,_label_11_124	; $51fa
	ld e,$eb		; $51fc
	ld a,(de)		; $51fe
	ld (hl),a		; $51ff
_label_11_124:
	ld e,$ec		; $5200
	ld a,(de)		; $5202
	inc l			; $5203
	ldi (hl),a		; $5204
	ld e,$ed		; $5205
	ld a,(de)		; $5207
	ld (hl),a		; $5208
_label_11_125:
	ld e,$c4		; $5209
	ld a,(de)		; $520b
	or a			; $520c
	jr z,_label_11_127	; $520d
	ld h,d			; $520f
	ld l,$e4		; $5210
	set 7,(hl)		; $5212
	call $5273		; $5214
	jp nz,partDelete		; $5217
_label_11_126:
	ld l,$8b		; $521a
	ld b,(hl)		; $521c
	ld l,$8d		; $521d
	ld c,(hl)		; $521f
	ld l,$89		; $5220
	ld a,(hl)		; $5222
	add $04			; $5223
	and $18			; $5225
	rrca			; $5227
	ldh (<hFF8B),a	; $5228
	ld l,$a1		; $522a
	add (hl)		; $522c
	add (hl)		; $522d
	ld hl,$524d		; $522e
	rst_addAToHl			; $5231
	ld e,$cb		; $5232
	ldi a,(hl)		; $5234
	add b			; $5235
	ld (de),a		; $5236
	ld e,$cd		; $5237
	ld a,(hl)		; $5239
	add c			; $523a
	ld (de),a		; $523b
	ldh a,(<hFF8B)	; $523c
	rrca			; $523e
	and $02			; $523f
	ld hl,$525d		; $5241
	rst_addAToHl			; $5244
	ld e,$e6		; $5245
	ldi a,(hl)		; $5247
	ld (de),a		; $5248
	inc e			; $5249
	ld a,(hl)		; $524a
	ld (de),a		; $524b
	ret			; $524c
	ld hl,sp+$04		; $524d
	or $04			; $524f
	inc b			; $5251
	rlca			; $5252
	inc b			; $5253
	add hl,bc		; $5254
	rlca			; $5255
.DB $fc				; $5256
	add hl,bc		; $5257
.DB $fc				; $5258
	inc b			; $5259
	ld sp,hl		; $525a
	inc b			; $525b
	rst $30			; $525c
	dec b			; $525d
	ld (bc),a		; $525e
	ld (bc),a		; $525f
	dec b			; $5260
_label_11_127:
	ld h,d			; $5261
	ld l,e			; $5262
	inc (hl)		; $5263
	ld l,$fe		; $5264
	ld (hl),$04		; $5266
	ld a,$01		; $5268
	call objectGetRelatedObject1Var		; $526a
	ld e,$f0		; $526d
	ld a,(hl)		; $526f
	ld (de),a		; $5270
	jr _label_11_126		; $5271
	ld a,$01		; $5273
	call objectGetRelatedObject1Var		; $5275
	ld e,$f0		; $5278
	ld a,(de)		; $527a
	cp (hl)			; $527b
	ret nz			; $527c
	ld l,$b0		; $527d
	bit 0,(hl)		; $527f
	jr nz,_label_11_128	; $5281
	ld l,$a9		; $5283
	ld a,(hl)		; $5285
	or a			; $5286
	jr z,_label_11_128	; $5287
	ld l,$ae		; $5289
	ld a,(hl)		; $528b
	or a			; $528c
	jr nz,_label_11_128	; $528d
	ld l,$bf		; $528f
	bit 1,(hl)		; $5291
	ret z			; $5293
_label_11_128:
	ld e,$e4		; $5294
	ld a,(de)		; $5296
	res 7,a			; $5297
	ld (de),a		; $5299
	xor a			; $529a
	ret			; $529b

;;
; @addr{529c}
partCode1e:
	jr z,_label_11_129	; $529c
	ld e,$ea		; $529e
	ld a,(de)		; $52a0
	cp $80			; $52a1
	jr z,_label_11_129	; $52a3
	call $52fd		; $52a5
	ld h,d			; $52a8
	ld l,$c4		; $52a9
	ld (hl),$03		; $52ab
	ld l,$e4		; $52ad
	res 7,(hl)		; $52af
_label_11_129:
	ld e,$c4		; $52b1
	ld a,(de)		; $52b3
	rst_jumpTable			; $52b4
.dw $52c1
.dw $52d4
.dw $52db
.dw $52ec
.dw $40cf
.dw $52f1
	ld h,d			; $52c1
	ld l,e			; $52c2
	inc (hl)		; $52c3
	ld l,$d0		; $52c4
	ld (hl),$50		; $52c6
	ld l,$c6		; $52c8
	ld (hl),$08		; $52ca
	ld a,SND_STRIKE		; $52cc
	call playSound		; $52ce
	jp objectSetVisible81		; $52d1
	call _partDecCounter1IfNonzero		; $52d4
	jr nz,_label_11_131	; $52d7
	ld l,e			; $52d9
	inc (hl)		; $52da
_label_11_130:
	call _partCommon_checkTileCollisionOrOutOfBounds		; $52db
	jr nc,_label_11_131	; $52de
	jr nz,_label_11_133	; $52e0
	jr _label_11_132		; $52e2
_label_11_131:
	call objectCheckWithinScreenBoundary		; $52e4
	jp c,objectApplySpeed		; $52e7
	jr _label_11_132		; $52ea
	call $5336		; $52ec
	jr _label_11_130		; $52ef
_label_11_132:
	jp partDelete		; $52f1
_label_11_133:
	ld e,$c4		; $52f4
	ld a,$04		; $52f6
	ld (de),a		; $52f8
	xor a			; $52f9
	jp $40af		; $52fa
	ld e,$c9		; $52fd
	ld a,(de)		; $52ff
	bit 2,a			; $5300
	jr nz,_label_11_134	; $5302
	sub $08			; $5304
	rrca			; $5306
	ld b,a			; $5307
	ld a,(w1Link.direction)		; $5308
	add b			; $530b
	ld hl,$532a		; $530c
	rst_addAToHl			; $530f
	ld a,(hl)		; $5310
	ld (de),a		; $5311
	ret			; $5312
_label_11_134:
	sub $0c			; $5313
	rrca			; $5315
	ld b,a			; $5316
	ld a,(w1Link.direction)		; $5317
	add b			; $531a
	ld hl,$5322		; $531b
	rst_addAToHl			; $531e
	ld a,(hl)		; $531f
	ld (de),a		; $5320
	ret			; $5321
	inc b			; $5322
	ld ($1410),sp		; $5323
	inc e			; $5326
	inc c			; $5327
	stop			; $5328
	jr _label_11_135		; $5329
	ld ($180c),sp		; $532b
	nop			; $532e
_label_11_135:
	inc c			; $532f
	stop			; $5330
	inc d			; $5331
	inc e			; $5332
	ld ($1814),sp		; $5333
	ld a,$24		; $5336
	call objectGetRelatedObject1Var		; $5338
	bit 7,(hl)		; $533b
	ret z			; $533d
	call checkObjectsCollided		; $533e
	ret nc			; $5341
	ld l,$aa		; $5342
	ld (hl),$82		; $5344
	ld l,$b0		; $5346
	dec (hl)		; $5348
	ld l,$ab		; $5349
	ld (hl),$0c		; $534b
	ld e,$c4		; $534d
	ld a,$04		; $534f
	ld (de),a		; $5351
	ret			; $5352

;;
; @addr{5353}
partCode1f:
	jr nz,_label_11_136	; $5353
	ld e,$c4		; $5355
	ld a,(de)		; $5357
	or a			; $5358
	jr z,_label_11_137	; $5359
	call objectCheckWithinScreenBoundary		; $535b
	jr nc,_label_11_136	; $535e
	call _partCommon_checkTileCollisionOrOutOfBounds		; $5360
	jp nc,objectApplySpeed		; $5363
_label_11_136:
	jp partDelete		; $5366
_label_11_137:
	ld h,d			; $5369
	ld l,e			; $536a
	inc (hl)		; $536b
	ld l,$d0		; $536c
	ld (hl),$50		; $536e
	ld e,$c9		; $5370
	ld a,(de)		; $5372
	swap a			; $5373
	rlca			; $5375
	call partSetAnimation		; $5376
	jp objectSetVisible81		; $5379

;;
; @addr{537c}
partCode20:
	ld e,$c4		; $537c
	ld a,(de)		; $537e
	or a			; $537f
	jr z,_label_11_138	; $5380
	call _partDecCounter1IfNonzero		; $5382
	jp z,partDelete		; $5385
	jp partAnimate		; $5388
_label_11_138:
	ld h,d			; $538b
	ld l,e			; $538c
	inc (hl)		; $538d
	ld l,$c6		; $538e
	ld (hl),$b4		; $5390
	jp objectSetVisible82		; $5392

;;
; @addr{5395}
partCode21:
	jr z,_label_11_139	; $5395
	ld e,$ea		; $5397
	ld a,(de)		; $5399
	res 7,a			; $539a
	sub $01			; $539c
	cp $03			; $539e
	jr nc,_label_11_139	; $53a0
	ld e,$c4		; $53a2
	ld a,$02		; $53a4
	ld (de),a		; $53a6
_label_11_139:
	ld e,$d7		; $53a7
	ld a,(de)		; $53a9
	inc a			; $53aa
	jr z,_label_11_142	; $53ab
	ld e,$c4		; $53ad
	ld a,(de)		; $53af
	rst_jumpTable			; $53b0
.dw $53b7
.dw $53c8
.dw $53db
	ld h,d			; $53b7
	ld l,e			; $53b8
	inc (hl)		; $53b9
	ld l,$c6		; $53ba
	ld (hl),$2d		; $53bc
	inc l			; $53be
	ld (hl),$06		; $53bf
	ld l,$d0		; $53c1
	ld (hl),$50		; $53c3
	jp objectSetVisible81		; $53c5
	call objectCheckSimpleCollision		; $53c8
	jr nz,_label_11_143	; $53cb
	call _partDecCounter1IfNonzero		; $53cd
	jr z,_label_11_143	; $53d0
	call $542a		; $53d2
_label_11_140:
	call objectApplySpeed		; $53d5
_label_11_141:
	jp partAnimate		; $53d8
	call $541a		; $53db
	call $53f5		; $53de
	jr nc,_label_11_140	; $53e1
	ld a,$18		; $53e3
	call objectGetRelatedObject1Var		; $53e5
	xor a			; $53e8
	ldi (hl),a		; $53e9
	ld (hl),a		; $53ea
_label_11_142:
	jp partDelete		; $53eb
_label_11_143:
	ld e,$c4		; $53ee
	ld a,$02		; $53f0
	ld (de),a		; $53f2
	jr _label_11_141		; $53f3
	ld a,$0b		; $53f5
	call objectGetRelatedObject1Var		; $53f7
	push hl			; $53fa
	ld b,(hl)		; $53fb
	ld l,$8d		; $53fc
	ld c,(hl)		; $53fe
	call objectGetRelativeAngle		; $53ff
	ld e,$c9		; $5402
	ld (de),a		; $5404
	pop hl			; $5405
	ld e,$cb		; $5406
	ld a,(de)		; $5408
	sub (hl)		; $5409
	add $04			; $540a
	cp $09			; $540c
	ret nc			; $540e
	ld l,$8d		; $540f
	ld e,$cd		; $5411
	ld a,(de)		; $5413
	sub (hl)		; $5414
	add $04			; $5415
	cp $09			; $5417
	ret			; $5419
	ld a,(wFrameCounter)		; $541a
	and $03			; $541d
	ret nz			; $541f
	ld e,$d0		; $5420
	ld a,(de)		; $5422
	add $05			; $5423
	cp $50			; $5425
	ret nc			; $5427
	ld (de),a		; $5428
	ret			; $5429
	ld h,d			; $542a
	ld l,$c7		; $542b
	dec (hl)		; $542d
	ret nz			; $542e
	ld (hl),$06		; $542f
	ld e,$d0		; $5431
	ld a,(de)		; $5433
	sub $05			; $5434
	ret c			; $5436
	ld (de),a		; $5437
	ret			; $5438


; ==============================================================================
; PARTID_CUCCO_ATTACKER
; ==============================================================================
partCode22:
	ld e,Part.state		; $5439
	ld a,(de)		; $543b
	rst_jumpTable			; $543c
	.dw @state0
	.dw @state1
	.dw @state2

@state0:
	ld h,d			; $5443
	ld l,e			; $5444
	inc (hl) ; [state]

	ld l,Part.counter1		; $5446
	ld (hl),$18		; $5448
	ld l,Part.zh		; $544a
	ld (hl),$fa		; $544c

	ld a,Object.var30		; $544e
	call objectGetRelatedObject1Var		; $5450
	ld a,(hl)		; $5453
	sub $10			; $5454
	and $1e			; $5456
	rrca			; $5458
	ld hl,@speedVals		; $5459
	rst_addAToHl			; $545c
	ld e,Part.speed		; $545d
	ld a,(hl)		; $545f
	ld (de),a		; $5460

	call objectSetVisiblec1		; $5461

	call getRandomNumber_noPreserveVars		; $5464
	ld c,a			; $5467
	and $30			; $5468
	ld b,a			; $546a
	swap b			; $546b
	and $10			; $546d
	ld hl,@xOrYVals		; $546f
	rst_addAToHl			; $5472
	ld a,c			; $5473
	and $0f			; $5474
	rst_addAToHl			; $5476
	bit 0,b			; $5477
	ld e,Part.yh		; $5479
	ld c,Part.xh		; $547b
	jr nz,+			; $547d
	ld e,c			; $547f
	ld c,Part.yh		; $5480
+
	ld a,(hl)		; $5482
	ld (de),a		; $5483

	ld a,b			; $5484
	ld hl,@screenEdgePositions		; $5485
	rst_addAToHl			; $5488
	ld e,c			; $5489
	ld a,(hl)		; $548a
	ld (de),a		; $548b
	call objectGetAngleTowardEnemyTarget		; $548c
	ld e,Part.angle		; $548f
	ld (de),a		; $5491

	; Decide animation based on angle
	cp $11			; $5492
	ld a,$00		; $5494
	jr nc,+			; $5496
	inc a			; $5498
+
	jp partSetAnimation		; $5499


@state1:
	call _partDecCounter1IfNonzero		; $549c
	jr nz,@applySpeedAndAnimate	; $549f
	ld l,e			; $54a1
	inc (hl)		; $54a2
	jr @applySpeedAndAnimate		; $54a3


@state2:
	call objectCheckWithinScreenBoundary		; $54a5
	jp nc,partDelete		; $54a8
@applySpeedAndAnimate:
	call objectApplySpeed		; $54ab
	jp partAnimate		; $54ae

@screenEdgePositions:
	.db $08 $98 $88 $08

@xOrYVals:
	.db $05 $0e $17 $20 $29 $32 $3b $44
	.db $4d $56 $5f $68 $71 $7a $83 $8c
	.db $05 $0f $19 $23 $2d $37 $41 $4b
	.db $55 $5f $69 $73 $7d $87 $91 $9b

@speedVals:
	.db SPEED_140 SPEED_180 SPEED_1c0 SPEED_200
	.db SPEED_240 SPEED_240 SPEED_280 SPEED_2c0
	.db SPEED_300

;;
; @addr{54de}
partCode23:
	ld e,$c2		; $54de
	ld a,(de)		; $54e0
	ld e,$c4		; $54e1
_label_11_147:
	rst_jumpTable			; $54e3
.dw $54ea
.dw $54f9
.dw $5515
	ld a,(de)		; $54ea
	or a			; $54eb
	jr z,_label_11_148	; $54ec
	call _partDecCounter1IfNonzero		; $54ee
	ret nz			; $54f1
	ld (hl),$78		; $54f2
	jr _label_11_149		; $54f4
_label_11_148:
	inc a			; $54f6
	ld (de),a		; $54f7
	ret			; $54f8
	ld a,(de)		; $54f9
	or a			; $54fa
	jr z,_label_11_148	; $54fb
	call _partDecCounter1IfNonzero		; $54fd
	ret nz			; $5500
	call $553f		; $5501
_label_11_149:
	call getFreePartSlot		; $5504
	ret nz			; $5507
	ld (hl),$23		; $5508
	inc l			; $550a
	ld (hl),$02		; $550b
	ld l,$f0		; $550d
	ld e,l			; $550f
	ld a,(de)		; $5510
	ld (hl),a		; $5511
	jp objectCopyPosition		; $5512
	ld a,(de)		; $5515
	or a			; $5516
	jr z,_label_11_150	; $5517
	ld h,d			; $5519
	ld l,$cb		; $551a
	ld a,(hl)		; $551c
	cp $b0			; $551d
	jp nc,partDelete		; $551f
	ld l,$d0		; $5522
	ld e,$ca		; $5524
	call add16BitRefs		; $5526
	dec l			; $5529
	ld a,(hl)		; $552a
	add $10			; $552b
	ldi (hl),a		; $552d
	ld a,(hl)		; $552e
	adc $00			; $552f
	ld (hl),a		; $5531
	jp partAnimate		; $5532
_label_11_150:
	ld h,d			; $5535
	ld l,e			; $5536
	inc (hl)		; $5537
	ld l,$e4		; $5538
	set 7,(hl)		; $553a
	jp objectSetVisible81		; $553c
	ld e,$87		; $553f
	ld a,(de)		; $5541
	inc a			; $5542
	and $03			; $5543
	ld (de),a		; $5545
	ld hl,$554f		; $5546
	rst_addAToHl			; $5549
	ld e,$c6		; $554a
	ld a,(hl)		; $554c
	ld (de),a		; $554d
	ret			; $554e
	ld a,b			; $554f
	ld a,b			; $5550
	ld e,$1e		; $5551

;;
; @addr{5553}
partCode27:
	ld e,$c4		; $5553
	ld a,(de)		; $5555
	rst_jumpTable			; $5556
.dw $555d
.dw $5580
.dw $558e
	ld a,$01		; $555d
	ld (de),a		; $555f
	call getRandomNumber_noPreserveVars		; $5560
	ld e,$f0		; $5563
	and $06			; $5565
	ld (de),a		; $5567
	ld h,d			; $5568
	ld l,$cf		; $5569
	ld (hl),$c0		; $556b
	ld l,$d7		; $556d
	ld a,(hl)		; $556f
	or a			; $5570
	ret z			; $5571
	ld l,$c6		; $5572
	ld (hl),$1e		; $5574
	ld l,$cb		; $5576
	ldh a,(<hEnemyTargetY)	; $5578
	ldi (hl),a		; $557a
	inc l			; $557b
	ldh a,(<hEnemyTargetX)	; $557c
	ld (hl),a		; $557e
	ret			; $557f
	call _partDecCounter1IfNonzero		; $5580
	ret nz			; $5583
	ld l,e			; $5584
	inc (hl)		; $5585
	ld a,SND_LIGHTNING		; $5586
	call playSound		; $5588
	jp objectSetVisible81		; $558b
	call partAnimate		; $558e
	ld e,$e1		; $5591
	ld a,(de)		; $5593
	inc a			; $5594
	jp z,partDelete		; $5595
	call $55a6		; $5598
	ld e,$c3		; $559b
	ld a,(de)		; $559d
	or a			; $559e
	ret z			; $559f
	ld a,$ff		; $55a0
	ld ($cfd2),a		; $55a2
	ret			; $55a5
	ld e,$e1		; $55a6
	ld a,(de)		; $55a8
	bit 7,a			; $55a9
	call nz,$55e7		; $55ab
	ld e,$e1		; $55ae
	ld a,(de)		; $55b0
	and $0e			; $55b1
	ld hl,$55da		; $55b3
	rst_addAToHl			; $55b6
	ld e,$e6		; $55b7
	ldi a,(hl)		; $55b9
	ld (de),a		; $55ba
	inc e			; $55bb
	ld a,(hl)		; $55bc
	ld (de),a		; $55bd
	ld e,$e1		; $55be
	ld a,(de)		; $55c0
	and $70			; $55c1
	swap a			; $55c3
	ld hl,$55e2		; $55c5
	rst_addAToHl			; $55c8
	ld e,$cf		; $55c9
	ld a,(hl)		; $55cb
	ld (de),a		; $55cc
	ld e,$e1		; $55cd
	ld a,(de)		; $55cf
	bit 0,a			; $55d0
	ret z			; $55d2
	dec a			; $55d3
	ld (de),a		; $55d4
	ld a,$06		; $55d5
	jp setScreenShakeCounter		; $55d7
	ld (bc),a		; $55da
	ld (bc),a		; $55db
	inc b			; $55dc
	ld b,$05		; $55dd
	add hl,bc		; $55df
	inc b			; $55e0
	dec b			; $55e1
	ret nz			; $55e2
	ret nc			; $55e3
	ld ($ff00+$f0),a	; $55e4
	nop			; $55e6
	res 7,a			; $55e7
	ld (de),a		; $55e9
	and $0e			; $55ea
	sub $02			; $55ec
	ld b,a			; $55ee
	ld e,$f0		; $55ef
	ld a,(de)		; $55f1
	add b			; $55f2
	ld hl,$5603		; $55f3
	rst_addAToHl			; $55f6
	ldi a,(hl)		; $55f7
	ld c,(hl)		; $55f8
	ld b,a			; $55f9
	call getFreeInteractionSlot		; $55fa
	ret nz			; $55fd
	ld (hl),$08		; $55fe
	jp objectCopyPositionWithOffset		; $5600
	ld (bc),a		; $5603
	ld b,$00		; $5604
	ei			; $5606
	rst $38			; $5607
	rlca			; $5608
.DB $fd				; $5609
.DB $fc				; $560a
	nop			; $560b
	dec b			; $560c

;;
; @addr{560d}
partCode28:
	jr z,_label_11_151	; $560d
	cp $02			; $560f
	jp z,$569c		; $5611
	ld e,$c4		; $5614
	ld a,$02		; $5616
	ld (de),a		; $5618
_label_11_151:
	ld e,$c4		; $5619
	ld a,(de)		; $561b
	rst_jumpTable			; $561c
.dw $5623
.dw $5638
.dw $566a
	ld h,d			; $5623
	ld l,$c4		; $5624
	inc (hl)		; $5626
	ld l,$cf		; $5627
	ld (hl),$fa		; $5629
	ld l,$f1		; $562b
	ld e,$cb		; $562d
	ld a,(de)		; $562f
	ldi (hl),a		; $5630
	ld e,$cd		; $5631
	ld a,(de)		; $5633
	ld (hl),a		; $5634
	jp objectSetVisiblec2		; $5635
	call _partDecCounter1IfNonzero		; $5638
	jr z,_label_11_152	; $563b
	call $56cd		; $563d
	jp c,objectApplySpeed		; $5640
_label_11_152:
	call getRandomNumber_noPreserveVars		; $5643
	and $3e			; $5646
	add $08			; $5648
	ld e,$c6		; $564a
	ld (de),a		; $564c
	call getRandomNumber_noPreserveVars		; $564d
	and $03			; $5650
	ld hl,$5666		; $5652
	rst_addAToHl			; $5655
	ld e,$d0		; $5656
	ld a,(hl)		; $5658
	ld (de),a		; $5659
	call getRandomNumber_noPreserveVars		; $565a
	and $1e			; $565d
	ld h,d			; $565f
	ld l,$c9		; $5660
	ld (hl),a		; $5662
	jp $56b6		; $5663
	ld a,(bc)		; $5666
	inc d			; $5667
	ld e,$28		; $5668
	ld e,$c5		; $566a
	ld a,(de)		; $566c
	or a			; $566d
	jr nz,_label_11_154	; $566e
	ld h,d			; $5670
	ld l,e			; $5671
	inc (hl)		; $5672
	ld l,$cf		; $5673
	ld (hl),$00		; $5675
	ld a,$01		; $5677
	call objectGetRelatedObject1Var		; $5679
	ld a,(hl)		; $567c
	ld e,$f0		; $567d
	ld (de),a		; $567f
	call objectSetVisible80		; $5680
_label_11_154:
	call objectCheckCollidedWithLink		; $5683
	jp c,$569c		; $5686
	ld a,$00		; $5689
	call objectGetRelatedObject1Var		; $568b
	ldi a,(hl)		; $568e
	or a			; $568f
	jr z,_label_11_155	; $5690
	ld e,$f0		; $5692
	ld a,(de)		; $5694
	cp (hl)			; $5695
	jp z,objectTakePosition		; $5696
_label_11_155:
	jp partDelete		; $5699
	ld a,$26		; $569c
	call cpActiveRing		; $569e
	ld c,$18		; $56a1
	jr z,_label_11_156	; $56a3
	ld a,$25		; $56a5
	call cpActiveRing		; $56a7
	jr nz,_label_11_157	; $56aa
_label_11_156:
	ld c,$30		; $56ac
_label_11_157:
	ld a,$29		; $56ae
	call giveTreasure		; $56b0
	jp partDelete		; $56b3
	ld e,$c9		; $56b6
	ld a,(de)		; $56b8
	and $0f			; $56b9
	ret z			; $56bb
	ld a,(de)		; $56bc
	cp $10			; $56bd
	ld a,$00		; $56bf
	jr nc,_label_11_158	; $56c1
	inc a			; $56c3
_label_11_158:
	ld h,d			; $56c4
	ld l,$c8		; $56c5
	cp (hl)			; $56c7
	ret z			; $56c8
	ld (hl),a		; $56c9
	jp partSetAnimation		; $56ca
	ld e,$c9		; $56cd
	ld a,(de)		; $56cf
	and $07			; $56d0
	ld a,(de)		; $56d2
	jr z,_label_11_159	; $56d3
	and $18			; $56d5
	add $04			; $56d7
_label_11_159:
	and $1c			; $56d9
	rrca			; $56db
	ld hl,$56f5		; $56dc
	rst_addAToHl			; $56df
	ld e,$cb		; $56e0
	ld a,(de)		; $56e2
	add (hl)		; $56e3
	ld b,a			; $56e4
	ld e,$cd		; $56e5
	inc hl			; $56e7
	ld a,(de)		; $56e8
	add (hl)		; $56e9
	sub $38			; $56ea
	cp $80			; $56ec
	ret nc			; $56ee
	ld a,b			; $56ef
	sub $18			; $56f0
	cp $50			; $56f2
	ret			; $56f4
.DB $fc				; $56f5
	nop			; $56f6
.DB $fc				; $56f7
	inc b			; $56f8
	nop			; $56f9
	inc b			; $56fa
	inc b			; $56fb
	inc b			; $56fc
	inc b			; $56fd
	nop			; $56fe
	inc b			; $56ff
.DB $fc				; $5700
	nop			; $5701
.DB $fc				; $5702
.DB $fc				; $5703
.DB $fc				; $5704
;;
; @addr{5705}
partCode29:
	jr z,_label_11_160	; $5705
	ld e,$ea		; $5707
	ld a,(de)		; $5709
	cp $83			; $570a
	jp z,partDelete		; $570c
_label_11_160:
	ld e,$c4		; $570f
	ld a,(de)		; $5711
	rst_jumpTable			; $5712
.dw $5719
.dw $5747
.dw $574e
	ld h,d			; $5719
	ld l,e			; $571a
	inc (hl)		; $571b
	ld l,$c6		; $571c
	ld (hl),$02		; $571e
	ld l,$c9		; $5720
	ld c,(hl)		; $5722
	ld b,$50		; $5723
	ld a,$04		; $5725
	call objectSetComponentSpeedByScaledVelocity		; $5727
	ld e,$c9		; $572a
	ld a,(de)		; $572c
	and $0f			; $572d
	ld hl,$5737		; $572f
	rst_addAToHl			; $5732
	ld a,(hl)		; $5733
	jp partSetAnimation		; $5734
	nop			; $5737
	nop			; $5738
	ld bc,$0202		; $5739
	ld (bc),a		; $573c
	inc bc			; $573d
	inc b			; $573e
	inc b			; $573f
	inc b			; $5740
	dec b			; $5741
	ld b,$06		; $5742
	ld b,$07		; $5744
	nop			; $5746
	call _partDecCounter1IfNonzero		; $5747
	jr nz,_label_11_161	; $574a
	ld l,e			; $574c
	inc (hl)		; $574d
	call $5758		; $574e
	call _partCommon_checkTileCollisionOrOutOfBounds		; $5751
	jp c,partDelete		; $5754
	ret			; $5757
_label_11_161:
	call objectApplyComponentSpeed		; $5758
	ld e,$c2		; $575b
	ld a,(de)		; $575d
	ld b,a			; $575e
	ld a,(wFrameCounter)		; $575f
	and b			; $5762
	jp z,objectSetVisible81		; $5763
	jp objectSetInvisible		; $5766


; ==============================================================================
; PARTID_SPIKED_BALL
;
; Variables:
;   speed: Nonstandard usage; it's a 16-bit variable which gets added to var30 (distance
;          away from origin).
;   relatedObj1: ENEMYID_BALL_AND_CHAIN_SOLDIER (for the head / subid 0),
;                or PARTID_SPIKED_BALL (the head; for subids 1-3).
;   var30: Distance away from origin point
; ==============================================================================
partCode2a:
	jr z,@normalStatus	; $5769

	; Check for sword or shield collision
	ld e,Part.var2a		; $576b
	ld a,(de)		; $576d
	res 7,a			; $576e
	sub ITEMCOLLISION_L1_SHIELD			; $5770
	cp ITEMCOLLISION_SWORD_HELD-ITEMCOLLISION_L1_SHIELD + 1
	jr nc,@normalStatus	; $5774

	; Make "parent" immune since the ball blocked the attack
	ld a,Object.invincibilityCounter		; $5776
	call objectGetRelatedObject1Var		; $5778
	ld a,(hl)		; $577b
	or a			; $577c
	jr nz,+			; $577d
	ld (hl),$f4		; $577f
+
	; If speedZ is positive, make it 0?
	ld h,d			; $5781
	ld l,Part.speedZ+1		; $5782
	ld a,(hl)		; $5784
	rlca			; $5785
	jr c,@normalStatus	; $5786
	xor a			; $5788
	ldd (hl),a		; $5789
	ld (hl),a		; $578a

@normalStatus:
	ld e,Part.subid		; $578b
	ld a,(de)		; $578d
	ld b,a			; $578e
	ld e,Part.state		; $578f
	ld a,b			; $5791
	rst_jumpTable			; $5792
	.dw _spikedBall_head
	.dw _spikedBall_chain
	.dw _spikedBall_chain
	.dw _spikedBall_chain


; The main part of the spiked ball (actually has collisions, etc)
_spikedBall_head:
	; Check if parent was deleted
	ld a,Object.id		; $579b
	call objectGetRelatedObject1Var		; $579d
	ld a,(hl)		; $57a0
	cp ENEMYID_BALL_AND_CHAIN_SOLDIER			; $57a1
	jp nz,partDelete		; $57a3

	ld b,h			; $57a6
	call _spikedBall_updateStateFromParent		; $57a7
	ld e,Part.state		; $57aa
	ld a,(de)		; $57ac
	rst_jumpTable			; $57ad
	.dw _spikedBall_head_state0
	.dw _spikedBall_head_state1
	.dw _spikedBall_head_state2
	.dw _spikedBall_head_state3
	.dw _spikedBall_head_state4
	.dw _spikedBall_head_state5


; Initialization
_spikedBall_head_state0:
	ld h,d			; $57ba
	ld l,e			; $57bb
	inc (hl) ; [state]

	ld l,Part.collisionType		; $57bd
	set 7,(hl)		; $57bf
	call objectSetVisible81		; $57c1


; Rotating slowly
_spikedBall_head_state1:
	ld e,Part.angle		; $57c4
	ld a,(de)		; $57c6
	inc a			; $57c7
	and $1f			; $57c8
	ld (de),a		; $57ca
	jr _spikedBall_head_setDefaultDistanceAway		; $57cb


; Rotating faster
_spikedBall_head_state2:
	ld e,Part.angle		; $57cd
	ld a,(de)		; $57cf
	add $02			; $57d0
	and $1f			; $57d2
	ld (de),a		; $57d4

_spikedBall_head_setDefaultDistanceAway:
	ld e,Part.var30		; $57d5
	ld a,$0a		; $57d7
	ld (de),a		; $57d9

;;
; @param	b	Enemy object
; @addr{57da}
_spikedBall_updatePosition:
	call _spikedBall_copyParentPosition		; $57da
	ld e,Part.var30		; $57dd
	ld a,(de)		; $57df
	ld e,Part.angle		; $57e0
	jp objectSetPositionInCircleArc		; $57e2


; About to throw the ball; waiting for it to rotate into a good position for throwing.
_spikedBall_head_state3:
	call _spikedBall_copyParentPosition		; $57e5

	; Compare the ball's angle with Link; must keep rotating it until it's aligned
	; perfectly.
	ldh a,(<hEnemyTargetY)	; $57e8
	ldh (<hFF8F),a	; $57ea
	ldh a,(<hEnemyTargetX)	; $57ec
	ldh (<hFF8E),a	; $57ee
	push hl			; $57f0
	call objectGetRelativeAngleWithTempVars		; $57f1
	pop bc			; $57f4
	xor $10			; $57f5
	ld e,a			; $57f7
	sub $06			; $57f8
	and $1f			; $57fa
	ld h,d			; $57fc
	ld l,Part.angle		; $57fd
	sub (hl)		; $57ff
	inc a			; $5800
	and $1f			; $5801
	cp $03			; $5803
	jr nc,_spikedBall_head_state2 ; keep rotating

	; It's aligned perfectly; begin throwing it.
	ld a,e			; $5807
	sub $03			; $5808
	and $1f			; $580a
	ld (hl),a ; [angle]

	ld l,Part.state		; $580d
	inc (hl)		; $580f

	ld l,Part.var30		; $5810
	ld (hl),$0d		; $5812
	jp _spikedBall_updatePosition		; $5814


; Ball has just been released
_spikedBall_head_state4:
	ld h,d			; $5817
	ld l,e			; $5818
	inc (hl) ; [state]

	ld l,Part.counter1		; $581a
	ld (hl),$00		; $581c

	ld l,Part.angle		; $581e
	ld a,(hl)		; $5820
	add $03			; $5821
	and $1f			; $5823
	ld (hl),a		; $5825

	; Distance from origin
	ld l,Part.var30		; $5826
	ld (hl),$12		; $5828

	; speed variable is used in a nonstandard way (added to var30, aka distance from
	; origin)
	ld l,Part.speed		; $582a
	ld a,<($0340)		; $582c
	ldi (hl),a		; $582e
	ld (hl),>($0340)		; $582f

	jp _spikedBall_updatePosition		; $5831


_spikedBall_head_state5:
	call _spikedBall_checkCollisionWithItem		; $5834
	call _spikedBall_head_updateDistanceFromOrigin		; $5837
	jp _spikedBall_updatePosition		; $583a


; The chain part of the ball (just decorative)
_spikedBall_chain:
	ld a,(de)		; $583d
	or a			; $583e
	jr nz,@state1	; $583f

@state0:
	inc a			; $5841
	ld (de),a ; [state]
	call partSetAnimation		; $5843
	call objectSetVisible81		; $5846

@state1:
	ld a,Object.id		; $5849
	call objectGetRelatedObject1Var		; $584b
	ld a,(hl)		; $584e
	cp PARTID_SPIKED_BALL			; $584f
	jp nz,partDelete		; $5851

	; Copy parent's angle
	ld l,Part.angle		; $5854
	ld e,l			; $5856
	ld a,(hl)		; $5857
	ld (de),a		; $5858

	call _spikedBall_chain_updateDistanceFromOrigin		; $5859
	ld l,Part.relatedObj1+1		; $585c
	ld b,(hl)		; $585e
	jp _spikedBall_updatePosition		; $585f


;;
; @param	b	Enemy object
; @addr{5862}
_spikedBall_copyParentPosition:
	ld h,b			; $5862
	ld l,Enemy.yh		; $5863
	ldi a,(hl)		; $5865
	sub $05			; $5866
	ld b,a			; $5868
	inc l			; $5869
	ldi a,(hl)		; $586a
	sub $05			; $586b
	ld c,a			; $586d
	inc l			; $586e
	ld a,(hl)		; $586f
	ld e,Part.zh		; $5870
	ld (de),a		; $5872
	ret			; $5873


;;
; If the ball collides with any item other than Link, this sets its speed to 0 (begins
; retracting earlier).
; @addr{5874}
_spikedBall_checkCollisionWithItem:
	; Check for collision with any item other than Link himself
	ld h,d			; $5874
	ld l,Part.var2a		; $5875
	bit 7,(hl)		; $5877
	ret z			; $5879
	ld a,(hl)		; $587a
	cp $80|ITEMCOLLISION_LINK			; $587b
	ret z			; $587d

	ld l,Part.speed+1		; $587e
	bit 7,(hl)		; $5880
	ret nz			; $5882
	xor a			; $5883
	ldd (hl),a		; $5884
	ld (hl),a		; $5885
	ret			; $5886


;;
; @addr{5887}
_spikedBall_head_updateDistanceFromOrigin:
	ld h,d			; $5887
	ld e,Part.var30		; $5888
	ld l,Part.speed+1		; $588a
	ld a,(de)		; $588c
	add (hl)		; $588d
	cp $0a			; $588e
	jr c,@fullyRetracted	; $5890

	ld (de),a		; $5892

	; Deceleration
	dec l			; $5893
	ld a,(hl)		; $5894
	sub <($0020)			; $5895
	ldi (hl),a		; $5897
	ld a,(hl)		; $5898
	sbc >($0020)			; $5899
	ld (hl),a		; $589b
	ret			; $589c

@fullyRetracted:
	; Tell parent (ENEMYID_BALL_AND_CHAIN_SOLDIER) we're fully retracted
	ld a,Object.counter1		; $589d
	call objectGetRelatedObject1Var		; $589f
	ld (hl),$00		; $58a2
	ret			; $58a4


;;
; Reads parent's var30 to decide whether to update state>
; @addr{58a5}
_spikedBall_updateStateFromParent:
	ld l,Enemy.var30		; $58a5

	; Check state between 1-3
	ld e,Part.state		; $58a7
	ld a,(de)		; $58a9
	dec a			; $58aa
	cp $03			; $58ab
	jr c,++			; $58ad

	; If uninitialized (state 0), return
	inc a			; $58af
	ret z			; $58b0

	; State is 4 or above (ball is being thrown).
	; Continue if [parent.var30] != 2 (signal to throw ball)
	ld a,(hl)		; $58b1
	cp $02			; $58b2
	ret z			; $58b4
++
	; Set state to:
	; * 1 if [parent.var30] == 0 (ball rotates slowly)
	; * 2 if [parent.var30] == 1 (ball rotates quickly)
	; * 3 if [parent.var30] >= 2 (ball should be thrown)
	ld a,(hl)		; $58b5
	or a			; $58b6
	ld c,$01		; $58b7
	jr z,++			; $58b9
	inc c			; $58bb
	dec a			; $58bc
	jr z,++			; $58bd
	inc c			; $58bf
++
	ld e,Part.state		; $58c0
	ld a,c			; $58c2
	ld (de),a		; $58c3
	ret			; $58c4

;;
; @param	h	Parent object (the actual ball)
; @addr{58c5}
_spikedBall_chain_updateDistanceFromOrigin:
	ld l,Part.var30		; $58c5
	push hl			; $58c7
	ld e,Part.subid		; $58c8
	ld a,(de)		; $58ca
	dec a			; $58cb
	rst_jumpTable			; $58cc
	.dw @subid1
	.dw @subid2
	.dw @subid3

@subid1:
	; [var30] = [parent.var30] * 3/4
	pop hl			; $58d3
	ld e,l			; $58d4
	ld a,(hl)		; $58d5
	srl a			; $58d6
	srl a			; $58d8
	ld b,a			; $58da
	add a			; $58db
	add b			; $58dc
	inc a			; $58dd
	ld (de),a		; $58de
	ret			; $58df

@subid2:
	; [var30] = [parent.var30] * 2/4
	pop hl			; $58e0
	ld e,l			; $58e1
	ld a,(hl)		; $58e2
	srl a			; $58e3
	srl a			; $58e5
	add a			; $58e7
	ld (de),a		; $58e8
	ret			; $58e9

@subid3:
	; [var30] = [parent.var30] * 1/4
	pop hl			; $58ea
	ld e,l			; $58eb
	ld a,(hl)		; $58ec
	srl a			; $58ed
	srl a			; $58ef
	ld (de),a		; $58f1
	ret			; $58f2

;;
; @addr{58f3}
partCode30:
	ld e,$c4		; $58f3
	ld a,(de)		; $58f5
	or a			; $58f6
	jr nz,_label_11_170	; $58f7
	ld h,d			; $58f9
	ld l,e			; $58fa
	inc (hl)		; $58fb
	ld l,$c6		; $58fc
	ld (hl),$03		; $58fe
	call objectSetVisible81		; $5900
_label_11_170:
	ldh a,(<hEnemyTargetY)	; $5903
	ld b,a			; $5905
	ldh a,(<hEnemyTargetX)	; $5906
	ld c,a			; $5908
	ld a,$20		; $5909
	ld e,$c9		; $590b
	call objectSetPositionInCircleArc		; $590d
	call _partDecCounter1IfNonzero		; $5910
	ret nz			; $5913
	ld (hl),$03		; $5914
	ld l,$c9		; $5916
	ld a,(hl)		; $5918
	dec a			; $5919
	and $1f			; $591a
	ld (hl),a		; $591c
	ret nz			; $591d
	ld hl,wLinkMaxHealth		; $591e
	ld a,(wDisplayedHearts)		; $5921
	cp (hl)			; $5924
	ret nz			; $5925
	ld a,$31		; $5926
	call objectGetRelatedObject1Var		; $5928
	dec (hl)		; $592b
	jp partDelete		; $592c


; ==============================================================================
; PARTID_RED_TWINROVA_PROJECTILE
; PARTID_BLUE_TWINROVA_PROJECTILE
;
; Variables:
;   relatedObj1: Instance of ENEMYID_TWINROVA that fired the projectile
;   relatedObj2: Instance of ENEMYID_TWINROVA that could be hit by the projectile
; ==============================================================================
partCode4b:
partCode4d:
	jr z,@normalStatus	; $592f

	ld e,Part.var2a		; $5931
	ld a,(de)		; $5933
	cp $80|ITEMCOLLISION_L3_SHIELD			; $5934
	jp z,partDelete		; $5936

	cp $80|ITEMCOLLISION_LINK			; $5939
	jr z,@normalStatus	; $593b

	; Gets reflected
	call objectGetAngleTowardEnemyTarget		; $593d
	xor $10			; $5940
	ld h,d			; $5942
	ld l,Part.angle		; $5943
	ld (hl),a		; $5945
	ld l,Part.state		; $5946
	ld (hl),$03		; $5948
	ld l,Part.speed		; $594a
	ld (hl),SPEED_280		; $594c

@normalStatus:
	; Check if twinrova is dead
	ld a,Object.state		; $594e
	call objectGetRelatedObject1Var		; $5950
	ld a,(hl)		; $5953
	cp $0d			; $5954
	jp nc,@deleteWithPoof		; $5956

	ld e,Part.state		; $5959
	ld a,(de)		; $595b
	rst_jumpTable			; $595c
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3

@state0:
	ld h,d			; $5965
	ld l,e			; $5966
	inc (hl) ; [state] = 1

	ld l,Part.counter1		; $5968
	ld (hl),30		; $596a
	ld l,Part.speed		; $596c
	ld (hl),SPEED_200		; $596e

	; Transfer z-position to y-position
	ld l,Part.zh		; $5970
	ld a,(hl)		; $5972
	ld (hl),$00		; $5973
	ld l,Part.yh		; $5975
	add (hl)		; $5977
	ld (hl),a		; $5978

	; Get the other twinrova object, put it in relatedObj2
	ld a,Object.relatedObj1		; $5979
	call objectGetRelatedObject1Var		; $597b
	ld e,Part.relatedObj2		; $597e
	ldi a,(hl)		; $5980
	ld (de),a		; $5981
	inc e			; $5982
	ld a,(hl)		; $5983
	ld (de),a		; $5984

	; Play sound depending which one it is
	ld e,Part.id		; $5985
	ld a,(de)		; $5987
	cp PARTID_RED_TWINROVA_PROJECTILE			; $5988
	ld a,SND_BEAM1		; $598a
	jr z,+			; $598c
	ld a,SND_BEAM2		; $598e
+
	call playSound		; $5990
	call objectSetVisible81		; $5993

; Being charged up
@state1:
	call _partDecCounter1IfNonzero		; $5996
	jr z,@fire	; $5999

	; Copy parent's position
	ld a,Object.yh		; $599b
	call objectGetRelatedObject1Var		; $599d
	ld bc,$ea00		; $59a0
	call objectTakePositionWithOffset		; $59a3
	xor a			; $59a6
	ld (de),a ; [zh] = 0
	jr @animate		; $59a8

@fire:
	call objectGetAngleTowardEnemyTarget		; $59aa
	ld e,Part.angle		; $59ad
	ld (de),a		; $59af

	ld h,d			; $59b0
	ld l,Part.state		; $59b1
	inc (hl) ; [state] = 2

	ld l,Part.collisionType		; $59b4
	set 7,(hl)		; $59b6

; Moving
@state2:
	call objectApplySpeed		; $59b8
	call _partCommon_checkOutOfBounds		; $59bb
	jr z,@delete	; $59be
@animate:
	jp partAnimate		; $59c0

@state3:
	ld a,$00		; $59c3
	call objectGetRelatedObject2Var		; $59c5
	call checkObjectsCollided		; $59c8
	jr nc,@state2	; $59cb

	; Collided with opposite-color twinrova
	ld l,Enemy.invincibilityCounter		; $59cd
	ld (hl),20		; $59cf
	ld l,Enemy.health		; $59d1
	dec (hl)		; $59d3
	jr nz,++		; $59d4

	; Other twinrova's health is 0; set a signal.
	ld l,Enemy.var32		; $59d6
	set 6,(hl)		; $59d8
++
	; Decrement health of same-color twinrova as well
	ld a,Object.health		; $59da
	call objectGetRelatedObject1Var		; $59dc
	dec (hl)		; $59df

	ld a,SND_BOSS_DAMAGE		; $59e0
	call playSound		; $59e2
@delete:
	jp partDelete		; $59e5

@deleteWithPoof:
	call objectCreatePuff		; $59e8
	jp partDelete		; $59eb

;;
; @addr{59ee}
partCode4c:
	jr z,_label_11_178	; $59ee
	ld e,$ea		; $59f0
	ld a,(de)		; $59f2
	cp $80			; $59f3
	jp nz,partDelete		; $59f5
_label_11_178:
	ld e,$c2		; $59f8
	ld a,(de)		; $59fa
	or a			; $59fb
	ld e,$c4		; $59fc
	ld a,(de)		; $59fe
	jr z,_label_11_180	; $59ff
	or a			; $5a01
	jr z,_label_11_179	; $5a02
	call partAnimate		; $5a04
	call objectApplySpeed		; $5a07
	call _partCommon_checkTileCollisionOrOutOfBounds		; $5a0a
	ret nz			; $5a0d
	jp partDelete		; $5a0e
_label_11_179:
	ld h,d			; $5a11
	ld l,e			; $5a12
	inc (hl)		; $5a13
	ld l,$d0		; $5a14
	ld (hl),$50		; $5a16
	ld l,$db		; $5a18
	ld a,$05		; $5a1a
	ldi (hl),a		; $5a1c
	ld (hl),a		; $5a1d
	ld l,$e6		; $5a1e
	ld a,$02		; $5a20
	ldi (hl),a		; $5a22
	ld (hl),a		; $5a23
	ld a,SND_BEAM2		; $5a24
	call playSound		; $5a26
	ld a,$01		; $5a29
	call partSetAnimation		; $5a2b
	jp objectSetVisible82		; $5a2e
_label_11_180:
	rst_jumpTable			; $5a31
.dw $5a38
.dw $5a46
.dw $5a54
	ld h,d			; $5a38
	ld l,e			; $5a39
	inc (hl)		; $5a3a
	ld l,$d0		; $5a3b
	ld (hl),$46		; $5a3d
	ld l,$c6		; $5a3f
	ld (hl),$1e		; $5a41
	jp objectSetVisible82		; $5a43
	call _partDecCounter1IfNonzero		; $5a46
	jp nz,partAnimate		; $5a49
	ld l,e			; $5a4c
	inc (hl)		; $5a4d
	call objectGetAngleTowardEnemyTarget		; $5a4e
	ld e,$c9		; $5a51
	ld (de),a		; $5a53
	call partAnimate		; $5a54
	call objectApplySpeed		; $5a57
	call _partCommon_checkTileCollisionOrOutOfBounds		; $5a5a
	ret nc			; $5a5d
	call objectGetAngleTowardEnemyTarget		; $5a5e
	sub $02			; $5a61
	and $1f			; $5a63
	ld c,a			; $5a65
	ld b,$03		; $5a66
_label_11_181:
	call getFreePartSlot		; $5a68
	jr nz,_label_11_182	; $5a6b
	ld (hl),$4c		; $5a6d
	inc l			; $5a6f
	inc (hl)		; $5a70
	ld l,$c9		; $5a71
	ld (hl),c		; $5a73
	call objectCopyPosition		; $5a74
_label_11_182:
	ld a,c			; $5a77
	add $02			; $5a78
	and $1f			; $5a7a
	ld c,a			; $5a7c
	dec b			; $5a7d
	jr nz,_label_11_181	; $5a7e
	call objectCreatePuff		; $5a80
	jp partDelete		; $5a83


; ==============================================================================
; PARTID_TWINROVA_SNOWBALL
; ==============================================================================
partCode4e:
	jr z,@normalStatus	; $5a86

	; Hit something
	ld e,Part.var2a		; $5a88
	ld a,(de)		; $5a8a
	cp $80|ITEMCOLLISION_L3_SHIELD			; $5a8b
	jr z,@destroy	; $5a8d

	res 7,a			; $5a8f
	sub ITEMCOLLISION_L2_SWORD			; $5a91
	cp ITEMCOLLISION_SWORDSPIN - ITEMCOLLISION_L2_SWORD + 1			; $5a93
	jp c,@destroy		; $5a95

@normalStatus:
	ld e,Part.state		; $5a98
	ld a,(de)		; $5a9a
	rst_jumpTable			; $5a9b
	.dw @state0
	.dw @state1
	.dw @state2

@state0:
	ld h,d			; $5aa2
	ld l,e			; $5aa3
	inc (hl) ; [state] = 1

	ld l,Part.counter1		; $5aa5
	ld (hl),30		; $5aa7

	ld l,Part.speed		; $5aa9
	ld (hl),SPEED_240		; $5aab

	ld a,SND_TELEPORT		; $5aad
	call playSound		; $5aaf
	jp objectSetVisible82		; $5ab2


; Spawning in, not moving yet
@state1:
	call _partDecCounter1IfNonzero		; $5ab5
	jr z,@beginMoving	; $5ab8

	ld l,Part.animParameter		; $5aba
	bit 0,(hl)		; $5abc
	jr z,@animate	; $5abe

	ld (hl),$00		; $5ac0
	ld l,Part.collisionType		; $5ac2
	set 7,(hl)		; $5ac4
@animate:
	jp partAnimate		; $5ac6

@beginMoving:
	ld l,e			; $5ac9
	inc (hl) ; [state] = 2

	call objectGetAngleTowardEnemyTarget		; $5acb
	ld e,Part.angle		; $5ace
	ld (de),a		; $5ad0


; Moving toward Link
@state2:
	call objectApplySpeed		; $5ad1
	call _partCommon_checkTileCollisionOrOutOfBounds		; $5ad4
	ret nc			; $5ad7

@destroy:
	ld b,INTERACID_SNOWDEBRIS		; $5ad8
	call objectCreateInteractionWithSubid00		; $5ada
	jp partDelete		; $5add

;;
; @addr{5ae0}
partCode50:
	ld a,$04		; $5ae0
	call objectGetRelatedObject1Var		; $5ae2
	ld a,(hl)		; $5ae5
	cp $0e			; $5ae6
	jp z,partDelete		; $5ae8
	push hl			; $5aeb
	ld e,$c4		; $5aec
	ld a,(de)		; $5aee
	rst_jumpTable			; $5aef
.dw $5af6
.dw $5b08
.dw $5b1e
	ld a,$01		; $5af6
	ld (de),a		; $5af8
	pop hl			; $5af9
	call objectTakePosition		; $5afa
	ld l,$b2		; $5afd
	ld a,(hl)		; $5aff
	or a			; $5b00
	jr z,_label_11_187	; $5b01
	ld a,$01		; $5b03
_label_11_187:
	jp partSetAnimation		; $5b05
	call partAnimate		; $5b08
	ld e,$e1		; $5b0b
	ld a,(de)		; $5b0d
	inc a			; $5b0e
	jr nz,_label_11_188	; $5b0f
	ld h,d			; $5b11
	ld l,$c4		; $5b12
	inc (hl)		; $5b14
	ld l,$e6		; $5b15
	ld a,$07		; $5b17
	ldi (hl),a		; $5b19
	ld (hl),a		; $5b1a
	call objectSetInvisible		; $5b1b
	pop hl			; $5b1e
	inc l			; $5b1f
	ld a,(hl)		; $5b20
	or a			; $5b21
	jp z,partDelete		; $5b22
	ld bc,$2000		; $5b25
	jp objectTakePositionWithOffset		; $5b28
_label_11_188:
	ld h,d			; $5b2b
	ld l,e			; $5b2c
	bit 7,(hl)		; $5b2d
	jr z,_label_11_189	; $5b2f
	res 7,(hl)		; $5b31
	call objectSetVisible82		; $5b33
	ld a,SND_BIGSWORD		; $5b36
	call playSound		; $5b38
	ld h,d			; $5b3b
	ld l,$e1		; $5b3c
_label_11_189:
	ld a,(hl)		; $5b3e
	ld hl,$5b5b		; $5b3f
	rst_addAToHl			; $5b42
	ld e,$e6		; $5b43
	ldi a,(hl)		; $5b45
	ld (de),a		; $5b46
	inc e			; $5b47
	ldi a,(hl)		; $5b48
	ld (de),a		; $5b49
	ldi a,(hl)		; $5b4a
	ld b,a			; $5b4b
	ld c,(hl)		; $5b4c
	pop hl			; $5b4d
	ld l,$b2		; $5b4e
	ld a,(hl)		; $5b50
	or a			; $5b51
	jr z,_label_11_190	; $5b52
	ld a,c			; $5b54
	cpl			; $5b55
	inc a			; $5b56
	ld c,a			; $5b57
_label_11_190:
	jp objectTakePositionWithOffset		; $5b58
	rlca			; $5b5b
	rlca			; $5b5c
	ret c			; $5b5d
	pop af			; $5b5e
	dec bc			; $5b5f
	rlca			; $5b60
	rst $20			; $5b61
	ld a,(de)		; $5b62
	jr nz,$0c		; $5b63
	rst $30			; $5b65
	add hl,de		; $5b66

;;
; @addr{5b67}
partCode51:
	ld a,$04		; $5b67
	call objectGetRelatedObject1Var		; $5b69
	ld a,(hl)		; $5b6c
	cp $0e			; $5b6d
	jp z,partDelete		; $5b6f
	ld e,$c2		; $5b72
	ld a,(de)		; $5b74
	ld e,$c4		; $5b75
	rst_jumpTable			; $5b77
.dw $5b7e
.dw $5be2
.dw $5b9e
	ld a,(de)		; $5b7e
	or a			; $5b7f
	jr nz,_label_11_191	; $5b80
	ld h,d			; $5b82
	ld l,e			; $5b83
	inc (hl)		; $5b84
	ld l,$c6		; $5b85
	ld (hl),$40		; $5b87
	ld l,$e8		; $5b89
	ld (hl),$f0		; $5b8b
	ld l,$da		; $5b8d
	ld (hl),$02		; $5b8f
	ld a,SND_ENERGYTHING		; $5b91
	call playSound		; $5b93
_label_11_191:
	call _partDecCounter1IfNonzero		; $5b96
	jp z,partDelete		; $5b99
	jr _label_11_192		; $5b9c
	ld a,(de)		; $5b9e
	or a			; $5b9f
	jr z,_label_11_193	; $5ba0
	ld e,$e1		; $5ba2
	ld a,(de)		; $5ba4
	rlca			; $5ba5
	jp c,partDelete		; $5ba6
_label_11_192:
	ld e,$da		; $5ba9
	ld a,(de)		; $5bab
	xor $80			; $5bac
	ld (de),a		; $5bae
	jp partAnimate		; $5baf
_label_11_193:
	ld h,d			; $5bb2
	ld l,e			; $5bb3
	inc (hl)		; $5bb4
	ld l,$e4		; $5bb5
	set 7,(hl)		; $5bb7
	ld l,$c9		; $5bb9
	ld a,(hl)		; $5bbb
	ld b,$01		; $5bbc
	cp $0c			; $5bbe
	jr c,_label_11_194	; $5bc0
	inc b			; $5bc2
	cp $19			; $5bc3
	jr c,_label_11_194	; $5bc5
	inc b			; $5bc7
_label_11_194:
	ld a,b			; $5bc8
	dec a			; $5bc9
	and $01			; $5bca
	ld hl,$5bde		; $5bcc
	rst_addDoubleIndex			; $5bcf
	ld e,$e6		; $5bd0
	ldi a,(hl)		; $5bd2
	ld (de),a		; $5bd3
	inc e			; $5bd4
	ld a,(hl)		; $5bd5
	ld (de),a		; $5bd6
	ld a,b			; $5bd7
	call partSetAnimation		; $5bd8
	jp objectSetVisible83		; $5bdb
	ld ($0a0a),sp		; $5bde
	ld a,(bc)		; $5be1
	ld a,(de)		; $5be2
	rst_jumpTable			; $5be3
.dw $5bea
.dw $5bff
.dw $5c2a
	ld h,d			; $5bea
	ld l,e			; $5beb
	inc (hl)		; $5bec
	ld l,$dd		; $5bed
	ld a,(hl)		; $5bef
	add $0e			; $5bf0
	ld (hl),a		; $5bf2
	ld l,$c6		; $5bf3
	ld (hl),$18		; $5bf5
	ld a,$04		; $5bf7
	call partSetAnimation		; $5bf9
	jp objectSetVisible82		; $5bfc
	call _partDecCounter1IfNonzero		; $5bff
	jr nz,_label_11_197	; $5c02
	dec (hl)		; $5c04
	ld l,e			; $5c05
	inc (hl)		; $5c06
	ld l,$e4		; $5c07
	set 7,(hl)		; $5c09
	ld l,$db		; $5c0b
	ld a,$05		; $5c0d
	ldi (hl),a		; $5c0f
	ld (hl),a		; $5c10
	ld l,$cb		; $5c11
	ld a,(hl)		; $5c13
	add $08			; $5c14
	ldi (hl),a		; $5c16
	inc l			; $5c17
	ld a,(hl)		; $5c18
	sub $10			; $5c19
	ld (hl),a		; $5c1b
	call objectGetAngleTowardLink		; $5c1c
	ld e,$c9		; $5c1f
	ld (de),a		; $5c21
	ld c,a			; $5c22
	ld b,$50		; $5c23
	ld a,$02		; $5c25
	jp objectSetComponentSpeedByScaledVelocity		; $5c27
	call _partCommon_checkTileCollisionOrOutOfBounds		; $5c2a
	jr nc,_label_11_195	; $5c2d
	ld b,$56		; $5c2f
	call objectCreateInteractionWithSubid00		; $5c31
	ld a,$3c		; $5c34
	call z,setScreenShakeCounter		; $5c36
	jp partDelete		; $5c39
_label_11_195:
	call _partDecCounter1IfNonzero		; $5c3c
	ld a,(hl)		; $5c3f
	and $07			; $5c40
	jr nz,_label_11_196	; $5c42
	call getFreePartSlot		; $5c44
	jr nz,_label_11_196	; $5c47
	ld (hl),$51		; $5c49
	inc l			; $5c4b
	ld (hl),$02		; $5c4c
	ld l,$c9		; $5c4e
	ld e,l			; $5c50
	ld a,(de)		; $5c51
	ld (hl),a		; $5c52
	call objectCopyPosition		; $5c53
_label_11_196:
	call objectApplyComponentSpeed		; $5c56
_label_11_197:
	jp partAnimate		; $5c59

;;
; @addr{5c5c}
partCode52:
	ld a,$04		; $5c5c
	call objectGetRelatedObject1Var		; $5c5e
	ld a,(hl)		; $5c61
	cp $0e			; $5c62
	jp z,partDelete		; $5c64
	ld e,$c2		; $5c67
	ld a,(de)		; $5c69
	ld e,$c4		; $5c6a
	rst_jumpTable			; $5c6c
.dw $5c73
.dw $5ca2
.dw $5d46
	ld a,(de)		; $5c73
	rst_jumpTable			; $5c74
.dw $5c7b
.dw $5c85
.dw $5c96
	ld h,d			; $5c7b
	ld l,e			; $5c7c
	inc (hl)		; $5c7d
	ld l,$c6		; $5c7e
	ld (hl),$0a		; $5c80
	jp objectSetVisible82		; $5c82
	call _partDecCounter1IfNonzero		; $5c85
	jr nz,_label_11_198	; $5c88
	ld l,e			; $5c8a
	inc (hl)		; $5c8b
	ld a,SND_BEAM		; $5c8c
	call playSound		; $5c8e
	ld a,$02		; $5c91
	call partSetAnimation		; $5c93
	call _partCommon_checkOutOfBounds		; $5c96
	jp z,partDelete		; $5c99
	call objectApplySpeed		; $5c9c
_label_11_198:
	jp partAnimate		; $5c9f
	ld a,(de)		; $5ca2
	rst_jumpTable			; $5ca3
.dw $5cac
.dw $5ce0
.dw $5d11
.dw $5c96
	ld h,d			; $5cac
	ld l,$d0		; $5cad
	ld (hl),$50		; $5caf
	ld l,e			; $5cb1
	call objectSetVisible82		; $5cb2
	ld e,$c3		; $5cb5
	ld a,(de)		; $5cb7
	or a			; $5cb8
	jr z,_label_11_199	; $5cb9
	ld (hl),$03		; $5cbb
	ld l,$e6		; $5cbd
	ld a,$02		; $5cbf
	ldi (hl),a		; $5cc1
	ld (hl),a		; $5cc2
	ret			; $5cc3
_label_11_199:
	inc (hl)		; $5cc4
	ld l,$c6		; $5cc5
	ld (hl),$28		; $5cc7
	ld l,$e6		; $5cc9
	ld a,$04		; $5ccb
	ldi (hl),a		; $5ccd
	ld (hl),a		; $5cce
	ld e,$cb		; $5ccf
	ld l,$f0		; $5cd1
	ld a,(de)		; $5cd3
	add $20			; $5cd4
	ldi (hl),a		; $5cd6
	ld e,$cd		; $5cd7
	ld a,(de)		; $5cd9
	ld (hl),a		; $5cda
	ld a,$01		; $5cdb
	call partSetAnimation		; $5cdd
	call _partDecCounter1IfNonzero		; $5ce0
	jr z,_label_11_201	; $5ce3
	ld a,(hl)		; $5ce5
	rrca			; $5ce6
	ld e,$c9		; $5ce7
	jr c,_label_11_200	; $5ce9
	ld a,(de)		; $5ceb
	inc a			; $5cec
	and $1f			; $5ced
	ld (de),a		; $5cef
_label_11_200:
	ld l,$da		; $5cf0
	ld a,(hl)		; $5cf2
	xor $80			; $5cf3
	ld (hl),a		; $5cf5
	ld l,$f0		; $5cf6
	ld b,(hl)		; $5cf8
	inc l			; $5cf9
	ld c,(hl)		; $5cfa
	ld a,$08		; $5cfb
	call objectSetPositionInCircleArc		; $5cfd
	jr _label_11_202		; $5d00
_label_11_201:
	ld (hl),$0a		; $5d02
	ld l,e			; $5d04
	inc (hl)		; $5d05
	ld a,SND_VERAN_PROJECTILE		; $5d06
	call playSound		; $5d08
	call objectSetVisible82		; $5d0b
_label_11_202:
	jp partAnimate		; $5d0e
	call _partDecCounter1IfNonzero		; $5d11
	jr z,_label_11_203	; $5d14
	call objectApplySpeed		; $5d16
	jr _label_11_202		; $5d19
_label_11_203:
	ld l,e			; $5d1b
	inc (hl)		; $5d1c
	ld l,$e6		; $5d1d
	ld a,$02		; $5d1f
	ldi (hl),a		; $5d21
	ld (hl),a		; $5d22
	xor a			; $5d23
	call partSetAnimation		; $5d24
	call objectCreatePuff		; $5d27
	ld b,$fd		; $5d2a
	call $5d31		; $5d2c
	ld b,$03		; $5d2f
	call getFreePartSlot		; $5d31
	ret nz			; $5d34
	ld (hl),$52		; $5d35
	inc l			; $5d37
	inc (hl)		; $5d38
	inc l			; $5d39
	inc (hl)		; $5d3a
	ld l,$c9		; $5d3b
	ld e,l			; $5d3d
	ld a,(de)		; $5d3e
	add b			; $5d3f
	and $1f			; $5d40
	ld (hl),a		; $5d42
	jp objectCopyPosition		; $5d43
	ld a,(de)		; $5d46
	rst_jumpTable			; $5d47
.dw $5d50
.dw $5d5a
.dw $5d6e
.dw $5c96
	ld h,d			; $5d50
	ld l,e			; $5d51
	inc (hl)		; $5d52
	ld l,$c6		; $5d53
	ld (hl),$0f		; $5d55
	jp objectSetVisible82		; $5d57
	call _partDecCounter1IfNonzero		; $5d5a
	jp nz,partAnimate		; $5d5d
	ld (hl),$0f		; $5d60
	ld l,e			; $5d62
	inc (hl)		; $5d63
	ld a,SND_VERAN_FAIRY_ATTACK		; $5d64
	call playSound		; $5d66
	ld a,$01		; $5d69
	jp partSetAnimation		; $5d6b
	call _partDecCounter1IfNonzero		; $5d6e
	jp nz,partAnimate		; $5d71
	ld l,e			; $5d74
	inc (hl)		; $5d75
	ld l,$d0		; $5d76
	ld (hl),$5a		; $5d78
	call objectGetAngleTowardLink		; $5d7a
	ld e,$c9		; $5d7d
	ld (de),a		; $5d7f
	ld a,$02		; $5d80
	jp partSetAnimation		; $5d82

;;
; @addr{5d85}
partCode53:
	ld e,$c4		; $5d85
	ld a,(de)		; $5d87
	or a			; $5d88
	jr z,_label_11_206	; $5d89
	ld a,(wDeleteEnergyBeads)		; $5d8b
	or a			; $5d8e
	jp nz,partDelete		; $5d8f
	ld h,d			; $5d92
	ld l,$c6		; $5d93
	ld a,(hl)		; $5d95
	inc a			; $5d96
	jr z,_label_11_204	; $5d97
	dec (hl)		; $5d99
	jp z,partDelete		; $5d9a
_label_11_204:
	inc e			; $5d9d
	ld a,(de)		; $5d9e
	or a			; $5d9f
	jr nz,_label_11_205	; $5da0
	inc l			; $5da2
	dec (hl)		; $5da3
	ret nz			; $5da4
	ld l,e			; $5da5
	inc (hl)		; $5da6
	ld l,$f2		; $5da7
	ld a,(hl)		; $5da9
	swap a			; $5daa
	rrca			; $5dac
	ld l,$c3		; $5dad
	add (hl)		; $5daf
	call partSetAnimation		; $5db0
	call $5e1a		; $5db3
	jp objectSetVisible		; $5db6
_label_11_205:
	call objectApplySpeed		; $5db9
	call partAnimate		; $5dbc
	ld e,$e1		; $5dbf
	ld a,(de)		; $5dc1
	inc a			; $5dc2
	ret nz			; $5dc3
	ld h,d			; $5dc4
	ld l,$c5		; $5dc5
	dec (hl)		; $5dc7
	call objectSetInvisible		; $5dc8
	jr _label_11_207		; $5dcb
_label_11_206:
	ld h,d			; $5dcd
	ld l,e			; $5dce
	inc (hl)		; $5dcf
	ld l,$c0		; $5dd0
	set 7,(hl)		; $5dd2
	ld l,$d0		; $5dd4
	ld (hl),$78		; $5dd6
	ld l,$c3		; $5dd8
	ld a,(hl)		; $5dda
	add a			; $5ddb
	add a			; $5ddc
	xor $10			; $5ddd
	ld l,$c9		; $5ddf
	ld (hl),a		; $5de1
	xor a			; $5de2
	ld (wDeleteEnergyBeads),a		; $5de3
_label_11_207:
	call getRandomNumber_noPreserveVars		; $5de6
	and $07			; $5de9
	inc a			; $5deb
	ld e,$c7		; $5dec
	ld (de),a		; $5dee
	ret			; $5def

;;
; @addr{5df0}
createEnergySwirlGoingOut_body:
	ld a,$01		; $5df0
	jr ++			; $5df2

;;
; @param	bc	Center of the swirl
; @param	l	Duration of swirl ($ff and $00 are infinite)?
; @addr{5df4}
func_11_5df4:
createEnergySwirlGoingIn_body:
	xor a			; $5df4
++
	ldh (<hFF8B),a	; $5df5
	push de			; $5df7
	ld e,l			; $5df8
	ld d,$08		; $5df9
--
	call getFreePartSlot		; $5dfb
	jr nz,@end		; $5dfe

	; Part.id
	ld (hl),PARTID_BLUE_ENERGY_BEAD		; $5e00

	; Set duration
	ld l,Part.counter1		; $5e02
	ld (hl),e		; $5e04

	; Set center of swirl
	ld l,Part.var30		; $5e05
	ld (hl),b		; $5e07
	inc l			; $5e08
	ld (hl),c		; $5e09
	inc l			; $5e0a

	; [Part.var32] = whether it's going in or out
	ldh a,(<hFF8B)	; $5e0b
	ld (hl),a		; $5e0d

	; Give each Part a unique index
	ld l,Part.var03		; $5e0e
	dec d			; $5e10
	ld (hl),d		; $5e11
	jr nz,--		; $5e12

@end:
	pop de			; $5e14
	ld a,SND_ENERGYTHING		; $5e15
	jp playSound		; $5e17

	ld h,d			; $5e1a
	ld l,$f2		; $5e1b
	ldd a,(hl)		; $5e1d
	or a			; $5e1e
	jr nz,_label_11_211	; $5e1f
	ld e,$c3		; $5e21
	ld a,(de)		; $5e23
	add a			; $5e24
	add a			; $5e25
	ld e,$c8		; $5e26
	ld (de),a		; $5e28
	ld c,(hl)		; $5e29
	dec l			; $5e2a
	ld b,(hl)		; $5e2b
	ld a,$38		; $5e2c
	jp objectSetPositionInCircleArc		; $5e2e
_label_11_211:
	ld e,$cd		; $5e31
	ldd a,(hl)		; $5e33
	ld (de),a		; $5e34
	ld e,$cb		; $5e35
	ld a,(hl)		; $5e37
	ld (de),a		; $5e38
	ret			; $5e39
_label_11_212:
	ld d,$d0		; $5e3a
	ld a,d			; $5e3c
_label_11_213:
	ldh (<hActiveObject),a	; $5e3d
	ld e,$c0		; $5e3f
	ld a,(de)		; $5e41
	or a			; $5e42
	jr z,_label_11_215	; $5e43
	rlca			; $5e45
	jr c,_label_11_214	; $5e46
	ld e,$c4		; $5e48
	ld a,(de)		; $5e4a
	or a			; $5e4b
	jr nz,_label_11_215	; $5e4c
_label_11_214:
	call _func_11_5e8a		; $5e4e
_label_11_215:
	inc d			; $5e51
	ld a,d			; $5e52
	cp $e0			; $5e53
	jr c,_label_11_213	; $5e55
	ret			; $5e57

;;
; @addr{5e58}
updateParts:
	ld a,$c0		; $5e58
	ldh (<hActiveObjectType),a	; $5e5a
	ld a,(wScrollMode)		; $5e5c
	cp $08			; $5e5f
	jr z,_label_11_212	; $5e61
	ld a,(wTextIsActive)		; $5e63
	or a			; $5e66
	jr nz,_label_11_212	; $5e67

	ld a,(wDisabledObjects)		; $5e69
	and $88			; $5e6c
	jr nz,_label_11_212	; $5e6e

	ld d,FIRST_PART_INDEX	; $5e70
	ld a,d			; $5e72
-
	ldh (<hActiveObject),a	; $5e73
	ld e,Part.enabled	; $5e75
	ld a,(de)		; $5e77
	or a			; $5e78
	jr z,+			; $5e79

	call _func_11_5e8a		; $5e7b
	ld h,d			; $5e7e
	ld l,Part.var2a		; $5e7f
	res 7,(hl)		; $5e81
+
	inc d			; $5e83
	ld a,d			; $5e84
	cp LAST_PART_INDEX+1			; $5e85
	jr c,-			; $5e87
	ret			; $5e89

;;
; @addr{5e8a}
_func_11_5e8a:
	call $403b		; $5e8a

	; hl = partCodeTable + [Part.id] * 2
	ld e,Part.id		; $5e8d
	ld a,(de)		; $5e8f
	add a			; $5e90
	add <partCodeTable	; $5e91
	ld l,a			; $5e93
	ld a,$00		; $5e94
	adc >partCodeTable	; $5e96
	ld h,a			; $5e98

	ldi a,(hl)		; $5e99
	ld h,(hl)		; $5e9a
	ld l,a			; $5e9b

	ld a,c			; $5e9c
	or a			; $5e9d
	jp hl			; $5e9e

partCodeTable:
	.dw partCode00 ; 0x00
	.dw partCode01 ; 0x01
	.dw partCode02 ; 0x02
	.dw partCode03 ; 0x03
	.dw partCode04 ; 0x04
	.dw partCode05 ; 0x05
	.dw partCode06 ; 0x06
	.dw partCode07 ; 0x07
	.dw partCode08 ; 0x08
	.dw partCode09 ; 0x09
	.dw partCodeNil ; 0x0a
	.dw partCode0b ; 0x0b
	.dw partCode0c ; 0x0c
	.dw partCodeNil ; 0x0d
	.dw partCode0e ; 0x0e
	.dw partCode0f ; 0x0f
	.dw partCode10 ; 0x10
	.dw partCode11 ; 0x11
	.dw partCode12 ; 0x12
	.dw partCode13 ; 0x13
	.dw partCode14 ; 0x14
	.dw partCode15 ; 0x15
	.dw partCode16 ; 0x16
	.dw partCode17 ; 0x17
	.dw partCode18 ; 0x18
	.dw partCode19 ; 0x19
	.dw partCode1a ; 0x1a
	.dw partCode1b ; 0x1b
	.dw partCode1c ; 0x1c
	.dw partCode1d ; 0x1d
	.dw partCode1e ; 0x1e
	.dw partCode1f ; 0x1f
	.dw partCode20 ; 0x20
	.dw partCode21 ; 0x21
	.dw partCode22 ; 0x22
	.dw partCode23 ; 0x23
	.dw partCode24 ; 0x24
	.dw partCode25 ; 0x25
	.dw partCode26 ; 0x26
	.dw partCode27 ; 0x27
	.dw partCode28 ; 0x28
	.dw partCode29 ; 0x29
	.dw partCode2a ; 0x2a
	.dw partCode2b ; 0x2b
	.dw partCode2c ; 0x2c
	.dw partCode2d ; 0x2d
	.dw partCode2e ; 0x2e
	.dw partCode2f ; 0x2f
	.dw partCode30 ; 0x30
	.dw partCode31 ; 0x31
	.dw partCode32 ; 0x32
	.dw partCode33 ; 0x33
	.dw partCode34 ; 0x34
	.dw partCode35 ; 0x35
	.dw partCode36 ; 0x36
	.dw partCode37 ; 0x37
	.dw partCode38 ; 0x38
	.dw partCode39 ; 0x39
	.dw partCode3a ; 0x3a
	.dw partCode3b ; 0x3b
	.dw partCode3c ; 0x3c
	.dw partCode3d ; 0x3d
	.dw partCode3e ; 0x3e
	.dw partCode3f ; 0x3f
	.dw partCode40 ; 0x40
	.dw partCode41 ; 0x41
	.dw partCode42 ; 0x42
	.dw partCode43 ; 0x43
	.dw partCode44 ; 0x44
	.dw partCode45 ; 0x45
	.dw partCode46 ; 0x46
	.dw partCode47 ; 0x47
	.dw partCode48 ; 0x48
	.dw partCode49 ; 0x49
	.dw partCode4a ; 0x4a
	.dw partCode4b ; 0x4b
	.dw partCode4c ; 0x4c
	.dw partCode4d ; 0x4d
	.dw partCode4e ; 0x4e
	.dw partCode4f ; 0x4f
	.dw partCode50 ; 0x50
	.dw partCode51 ; 0x51
	.dw partCode52 ; 0x52
	.dw partCode53 ; 0x53
	.dw partCode54 ; 0x54
	.dw partCode55 ; 0x55
	.dw partCode56 ; 0x56
	.dw partCode57 ; 0x57
	.dw partCode58 ; 0x58
	.dw partCode59 ; 0x59
	.dw partCode5a ; 0x5a

;;
; @addr{5f55}
partCodeNil:
	ret			; $5f55

;;
; @addr{5f56}
partCode00:
	jp partDelete		; $5f56

;;
; @addr{5f59}
partCode16:
	ld e,$c4		; $5f59
	ld a,(de)		; $5f5b
	rst_jumpTable			; $5f5c
.dw $5f65
.dw $5fab
.dw $5fbc
.dw $5fd4
	ld h,d			; $5f65
	ld l,e			; $5f66
	inc (hl)		; $5f67
	ld l,$c0		; $5f68
	set 7,(hl)		; $5f6a
	ld l,$cd		; $5f6c
	ld a,(hl)		; $5f6e
	cp $50			; $5f6f
	ld bc,$ff80		; $5f71
	jr c,_label_11_218	; $5f74
	ld bc,$0080		; $5f76
_label_11_218:
	ld l,$d2		; $5f79
	ld (hl),c		; $5f7b
	inc l			; $5f7c
	ld (hl),b		; $5f7d
	call getRandomNumber_noPreserveVars		; $5f7e
	ld b,a			; $5f81
	and $07			; $5f82
	ld e,$c6		; $5f84
	ld (de),a		; $5f86
	ld a,b			; $5f87
	and $18			; $5f88
	swap a			; $5f8a
	rlca			; $5f8c
	ld hl,$5fa7		; $5f8d
	rst_addAToHl			; $5f90
	ld e,$d0		; $5f91
	ld a,(hl)		; $5f93
	ld (de),a		; $5f94
	ld a,b			; $5f95
_label_11_219:
	and $e0			; $5f96
	swap a			; $5f98
	add a			; $5f9a
	ld e,$c7		; $5f9b
	ld (de),a		; $5f9d
	ld e,$c2		; $5f9e
_label_11_220:
	ld a,(de)		; $5fa0
	call partSetAnimation		; $5fa1
	jp objectSetVisible82		; $5fa4
	ld e,$28		; $5fa7
	ldd (hl),a		; $5fa9
	inc a			; $5faa
	call _partDecCounter1IfNonzero		; $5fab
	jr nz,_label_11_221	; $5fae
	inc l			; $5fb0
	ldd a,(hl)		; $5fb1
	ld (hl),a		; $5fb2
	ld l,e			; $5fb3
	inc (hl)		; $5fb4
_label_11_221:
	ld l,$da		; $5fb5
	ld a,(hl)		; $5fb7
	xor $80			; $5fb8
	ld (hl),a		; $5fba
	ret			; $5fbb
	call _partDecCounter1IfNonzero		; $5fbc
	jr nz,_label_11_222	; $5fbf
	ld l,e			; $5fc1
	inc (hl)		; $5fc2
_label_11_222:
	ld l,$d2		; $5fc3
	ldi a,(hl)		; $5fc5
	ld b,(hl)		; $5fc6
	ld c,a			; $5fc7
	ld l,$cc		; $5fc8
	ld e,l			; $5fca
	ldi a,(hl)		; $5fcb
	ld h,(hl)		; $5fcc
	ld l,a			; $5fcd
	add hl,bc		; $5fce
	ld a,l			; $5fcf
	ld (de),a		; $5fd0
	inc e			; $5fd1
	ld a,h			; $5fd2
	ld (de),a		; $5fd3
	call objectApplySpeed		; $5fd4
	ld e,$cb		; $5fd7
	ld a,(de)		; $5fd9
	cp $f0			; $5fda
	jp nc,partDelete		; $5fdc
	ld h,d			; $5fdf
	ld l,$da		; $5fe0
	ld a,(hl)		; $5fe2
	xor $80			; $5fe3
	ld (hl),a		; $5fe5
	ld l,$c7		; $5fe6
	dec (hl)		; $5fe8
	and $0f			; $5fe9
	ret nz			; $5feb
	ld l,$d0		; $5fec
	ld a,(hl)		; $5fee
	sub $05			; $5fef
	cp $13			; $5ff1
	ret c			; $5ff3
	ld (hl),a		; $5ff4
	ret			; $5ff5

;;
; @addr{5ff6}
partCode24:
	jr z,_label_11_223	; $5ff6
	ld a,(wSwitchState)		; $5ff8
	ld h,d			; $5ffb
	ld l,$c2		; $5ffc
	xor (hl)		; $5ffe
	ld (wSwitchState),a		; $5fff
	ld l,$e4		; $6002
	res 7,(hl)		; $6004
	ld a,$01		; $6006
	call partSetAnimation		; $6008
	ld bc,$8280		; $600b
	jp objectCreateInteraction		; $600e
_label_11_223:
	ld e,$c4		; $6011
	ld a,(de)		; $6013
	or a			; $6014
	ret nz			; $6015
	inc a			; $6016
	ld (de),a		; $6017
	call getThisRoomFlags		; $6018
	bit 6,(hl)		; $601b
	jr z,_label_11_224	; $601d
	ld h,d			; $601f
	ld l,$e4		; $6020
	res 7,(hl)		; $6022
	ld a,$01		; $6024
	call partSetAnimation		; $6026
_label_11_224:
	call objectMakeTileSolid		; $6029
	ld h,$cf		; $602c
	ld (hl),$0a		; $602e
	jp objectSetVisible83		; $6030

;;
; @addr{6033}
partCode25:
	ld e,$c4		; $6033
	ld a,(de)		; $6035
	or a			; $6036
	jr nz,_label_11_225	; $6037
	ld h,d			; $6039
	ld l,e			; $603a
	inc (hl)		; $603b
	ld l,$c2		; $603c
	ld a,(hl)		; $603e
	swap a			; $603f
	rrca			; $6041
	ld l,$c9		; $6042
	ld (hl),a		; $6044
_label_11_225:
	call _partDecCounter1IfNonzero		; $6045
	ret nz			; $6048
	ld e,$c2		; $6049
	ld a,(de)		; $604b
	bit 0,a			; $604c
	ld e,$cd		; $604e
	ldh a,(<hEnemyTargetX)	; $6050
	jr z,_label_11_226	; $6052
	ld e,$cb		; $6054
	ldh a,(<hEnemyTargetY)	; $6056
_label_11_226:
	ld b,a			; $6058
	ld a,(de)		; $6059
	sub b			; $605a
	add $10			; $605b
	cp $21			; $605d
	ret nc			; $605f
	ld e,$c6		; $6060
	ld a,$21		; $6062
	ld (de),a		; $6064
	ld hl,$6080		; $6065
	ld e,$c2		; $6068
	ld a,(de)		; $606a
	rst_addDoubleIndex			; $606b
	ldi a,(hl)		; $606c
	ld b,a			; $606d
	ld c,(hl)		; $606e
	call getFreePartSlot		; $606f
	ret nz			; $6072
	ld (hl),$1a		; $6073
	inc l			; $6075
	inc (hl)		; $6076
	call objectCopyPositionWithOffset		; $6077
	ld l,$c9		; $607a
	ld e,l			; $607c
	ld a,(de)		; $607d
	ld (hl),a		; $607e
	ret			; $607f
.DB $fc				; $6080
	nop			; $6081
	nop			; $6082
	inc b			; $6083
	inc b			; $6084
	nop			; $6085
	nop			; $6086
.DB $fc				; $6087
;;
; @addr{6088}
partCode26:
	ld e,$c4		; $6088
	ld a,(de)		; $608a
	or a			; $608b
	jr z,_label_11_229	; $608c
	call _partDecCounter1IfNonzero		; $608e
	jr nz,_label_11_227	; $6091
	inc l			; $6093
	ldd a,(hl)		; $6094
	ld (hl),a		; $6095
	ld l,$f0		; $6096
	ld a,(hl)		; $6098
	cpl			; $6099
	add $01			; $609a
	ldi (hl),a		; $609c
	ld a,(hl)		; $609d
	cpl			; $609e
	adc $00			; $609f
	ld (hl),a		; $60a1
_label_11_227:
	ld e,$cd		; $60a2
	ld a,(de)		; $60a4
	ld b,a			; $60a5
	dec e			; $60a6
	ld a,(de)		; $60a7
	ld c,a			; $60a8
	ld l,$d2		; $60a9
	ldi a,(hl)		; $60ab
	ld h,(hl)		; $60ac
	ld l,a			; $60ad
	add hl,bc		; $60ae
	ld a,l			; $60af
	ld (de),a		; $60b0
	inc e			; $60b1
	ld a,h			; $60b2
	ld (de),a		; $60b3
	ld e,$f0		; $60b4
	ld a,(de)		; $60b6
	ld c,a			; $60b7
	inc e			; $60b8
	ld a,(de)		; $60b9
	ld b,a			; $60ba
	ld e,$d3		; $60bb
	ld a,(de)		; $60bd
	ld h,a			; $60be
	dec e			; $60bf
	ld a,(de)		; $60c0
	ld l,a			; $60c1
	add hl,bc		; $60c2
	ld a,l			; $60c3
	ld (de),a		; $60c4
	inc e			; $60c5
	ld a,h			; $60c6
	ld (de),a		; $60c7
	ld h,d			; $60c8
	ld l,$ce		; $60c9
	ld e,$d4		; $60cb
	ld a,(de)		; $60cd
	add (hl)		; $60ce
	ldi (hl),a		; $60cf
	ld a,(hl)		; $60d0
	adc $00			; $60d1
	jp z,partDelete		; $60d3
	ld (hl),a		; $60d6
	cp $e8			; $60d7
	jr c,_label_11_228	; $60d9
	ld l,$da		; $60db
	ld a,(hl)		; $60dd
	xor $80			; $60de
	ld (hl),a		; $60e0
_label_11_228:
	jp partAnimate		; $60e1
_label_11_229:
	ld h,d			; $60e4
	ld l,e			; $60e5
	inc (hl)		; $60e6
	call objectGetZAboveScreen		; $60e7
	ld l,$cf		; $60ea
	ld (hl),a		; $60ec
	ld e,$c3		; $60ed
	ld a,(de)		; $60ef
	or a			; $60f0
	jr z,_label_11_230	; $60f1
	ld (hl),$f0		; $60f3
_label_11_230:
	call getRandomNumber_noPreserveVars		; $60f5
	and $0c			; $60f8
	ld hl,$6114		; $60fa
	rst_addAToHl			; $60fd
	ld e,$f0		; $60fe
	ldi a,(hl)		; $6100
	ld (de),a		; $6101
	inc e			; $6102
	ldi a,(hl)		; $6103
	ld (de),a		; $6104
	ld e,$d4		; $6105
	ldi a,(hl)		; $6107
	ld (de),a		; $6108
	ld e,$c6		; $6109
	ld a,(hl)		; $610b
	ld (de),a		; $610c
	inc e			; $610d
	dec a			; $610e
	add a			; $610f
	ld (de),a		; $6110
	jp objectSetVisible81		; $6111
	ld a,($56ff)		; $6114
	inc c			; $6117
	rst $30			; $6118
	rst $38			; $6119
	ld d,h			; $611a
	ld a,(bc)		; $611b
	ld a,($ff00+c)		; $611c
	rst $38			; $611d
	ld e,h			; $611e
	ld c,$f5		; $611f
	rst $38			; $6121
	ld e,b			; $6122
	stop			; $6123

;;
; @addr{6124}
partCode2b:
	ld e,$c4		; $6124
	ld a,(de)		; $6126
	or a			; $6127
	jr nz,_label_11_231	; $6128
	inc a			; $612a
	ld (de),a		; $612b
	ld h,d			; $612c
	ld l,$c0		; $612d
	set 7,(hl)		; $612f
_label_11_231:
	call objectApplySpeed		; $6131
	ld e,$cb		; $6134
	ld a,(de)		; $6136
	add $04			; $6137
	cp $f4			; $6139
	jp nc,partDelete		; $613b
	ld a,$04		; $613e
	call objectGetRelatedObject1Var		; $6140
	ld a,(hl)		; $6143
	cp $03			; $6144
	ld e,$c2		; $6146
	ld a,(de)		; $6148
	jr c,_label_11_232	; $6149
	bit 1,a			; $614b
	jp nz,partDelete		; $614d
_label_11_232:
	ld l,$61		; $6150
	xor (hl)		; $6152
	rrca			; $6153
	jp c,objectSetInvisible		; $6154
	jp objectSetVisible83		; $6157

;;
; @addr{615a}
partCode2c:
	jp nz,partDelete		; $615a
	ld a,($cfd0)		; $615d
	or a			; $6160
	jr z,_label_11_233	; $6161
	call objectCreatePuff		; $6163
	jp partDelete		; $6166
_label_11_233:
	ld e,$c4		; $6169
	ld a,(de)		; $616b
	rst_jumpTable			; $616c
.dw $6177
.dw $61ac
.dw $61c2
.dw $61d2
.dw $61ff
	ld h,d			; $6177
	ld l,e			; $6178
	inc (hl)		; $6179
	ld l,$d0		; $617a
	ld (hl),$1e		; $617c
	ld e,$c2		; $617e
	ld a,(de)		; $6180
	swap a			; $6181
	add $08			; $6183
	ld l,$c9		; $6185
	ld (hl),a		; $6187
	bit 4,a			; $6188
	jr z,_label_11_234	; $618a
	ld l,$cb		; $618c
	ld (hl),$fe		; $618e
	call getRandomNumber_noPreserveVars		; $6190
	and $07			; $6193
	ld hl,$629f		; $6195
	rst_addAToHl			; $6198
	ld a,(hl)		; $6199
	ld hl,$61aa		; $619a
	rst_addAToHl			; $619d
	ld e,$cd		; $619e
	ld a,(hl)		; $61a0
	ld (de),a		; $61a1
	ld a,$01		; $61a2
	call partSetAnimation		; $61a4
_label_11_234:
	jp objectSetVisible82		; $61a7
	ret c			; $61aa
	cp b			; $61ab
	ld a,$20		; $61ac
	call objectUpdateSpeedZ_sidescroll		; $61ae
	jr nc,_label_11_235	; $61b1
	ld h,d			; $61b3
	ld l,$c4		; $61b4
	inc (hl)		; $61b6
	ld l,$f1		; $61b7
	ld (hl),$04		; $61b9
	ld l,$d4		; $61bb
	xor a			; $61bd
	ldi (hl),a		; $61be
	ld (hl),a		; $61bf
	jr _label_11_235		; $61c0
	ld h,d			; $61c2
	ld l,$f1		; $61c3
	dec (hl)		; $61c5
	jr nz,_label_11_235	; $61c6
	ld (hl),$04		; $61c8
	ld l,e			; $61ca
	inc (hl)		; $61cb
	inc l			; $61cc
	ld (hl),$00		; $61cd
_label_11_235:
	jp partAnimate		; $61cf
	ld e,$c5		; $61d2
	ld a,(de)		; $61d4
	rst_jumpTable			; $61d5
.dw $61da
.dw $61e6

_label_11_236:
	call $6248		; $61da
	call $6270		; $61dd
	ret c			; $61e0
	ld h,d			; $61e1
	ld l,$c4		; $61e2
	inc (hl)		; $61e4
	ret			; $61e5
	ld bc,$1000		; $61e6
	call objectGetRelativeTile		; $61e9
	cp $19			; $61ec
	jp z,$6248		; $61ee
	ld h,d			; $61f1
	ld l,$c5		; $61f2
	dec (hl)		; $61f4
	ld l,$c6		; $61f5
	xor a			; $61f7
	ld (hl),a		; $61f8
	ld l,$d4		; $61f9
	ldi (hl),a		; $61fb
	ld (hl),a		; $61fc
	jr _label_11_236		; $61fd
	ld e,$cb		; $61ff
	ld a,(de)		; $6201
	cp $b0			; $6202
	jp nc,partDelete		; $6204
	call $6248		; $6207
	call $6270		; $620a
	ret nc			; $620d
	ld h,d			; $620e
	ld l,$c4		; $620f
	ld (hl),$02		; $6211
	xor a			; $6213
	ld l,$d4		; $6214
_label_11_237:
	ldi (hl),a		; $6216
	ld (hl),a		; $6217
	ld l,$c6		; $6218
	ld (hl),a		; $621a
	ld e,$c2		; $621b
	ld a,(de)		; $621d
	swap a			; $621e
	rrca			; $6220
	inc l			; $6221
	add (hl)		; $6222
	inc (hl)		; $6223
	ld bc,$6238		; $6224
	call addAToBc		; $6227
	ld l,$c9		; $622a
	ld a,(bc)		; $622c
	ldd (hl),a		; $622d
	and $10			; $622e
	swap a			; $6230
	cp (hl)			; $6232
	ret z			; $6233
	ld (hl),a		; $6234
	jp partSetAnimation		; $6235
	ld ($1818),sp		; $6238
	ld ($ff08),sp		; $623b
	rst $38			; $623e
	rst $38			; $623f
	jr $18			; $6240
	ld ($1808),sp		; $6242
	jr $18			; $6245
	jr _label_11_237		; $6247
	sub (hl)		; $6249
_label_11_238:
	jr nz,_label_11_238	; $624a
	sub c			; $624c
	jr nz,_label_11_239	; $624d
	pop hl			; $624f
	call objectCreatePuff		; $6250
	jp partDelete		; $6253
_label_11_239:
	call _partCommon_getTileCollisionInFront		; $6256
	jr nz,_label_11_240	; $6259
	call objectApplySpeed		; $625b
	jp partAnimate		; $625e
_label_11_240:
	ld e,$c9		; $6261
	ld a,(de)		; $6263
	xor $10			; $6264
	ld (de),a		; $6266
	ld e,$c8		; $6267
	ld a,(de)		; $6269
	xor $01			; $626a
	ld (de),a		; $626c
	jp partSetAnimation		; $626d
	ld a,$20		; $6270
	call objectUpdateSpeedZ_sidescroll		; $6272
	ret c			; $6275
	ld a,(hl)		; $6276
	cp $02			; $6277
	jr c,_label_11_241	; $6279
	ld (hl),$02		; $627b
	dec l			; $627d
	ld (hl),$00		; $627e
_label_11_241:
	call _partDecCounter1IfNonzero		; $6280
	ret nz			; $6283
	ld (hl),$10		; $6284
	ld bc,$1000		; $6286
	call objectGetRelativeTile		; $6289
	sub $19			; $628c
	or a			; $628e
	ret nz			; $628f
	call getRandomNumber		; $6290
	and $07			; $6293
	ld hl,$629f		; $6295
	rst_addAToHl			; $6298
	ld e,$c5		; $6299
	ld a,(hl)		; $629b
	ld (de),a		; $629c
	rrca			; $629d
	ret			; $629e
	nop			; $629f
	nop			; $62a0
	ld bc,$0100		; $62a1
	nop			; $62a4
	.db $01 $00

;;
; @addr{62a7}
partCode2d:
	jr nz,_label_11_244	; $42a7
	ld a,$29		; $62a9
	call objectGetRelatedObject1Var		; $62ab
	ld a,(hl)		; $62ae
	or a			; $62af
	jr z,_label_11_243	; $62b0
	ld e,$c4		; $62b2
	ld a,(de)		; $62b4
	or a			; $62b5
	jr z,_label_11_242	; $62b6
	call _partCommon_checkOutOfBounds		; $62b8
	jr z,_label_11_244	; $62bb
	call objectApplySpeed		; $62bd
	jp partAnimate		; $62c0
_label_11_242:
	ld h,d			; $62c3
	ld l,e			; $62c4
	inc (hl)		; $62c5
	ld l,$d0		; $62c6
	ld (hl),$3c		; $62c8
	call objectGetAngleTowardEnemyTarget		; $62ca
	ld e,$c9		; $62cd
	ld (de),a		; $62cf
	call objectSetVisible82		; $62d0
	ld a,SND_VERAN_FAIRY_ATTACK		; $62d3
	jp playSound		; $62d5
_label_11_243:
	call objectCreatePuff		; $62d8
_label_11_244:
	jp partDelete		; $62db

;;
; @addr{62de}
partCode2e:
	ld e,Part.state		; $62de
	ld a,(de)		; $62e0
	or a			; $62e1
	jr nz,@initialized	; $62e2

	inc a			; $62e4
	ld (de),a		; $62e5
	jp $6361		; $62e6

@initialized:
	ld a,(w1Link.state)		; $62e9
	sub LINK_STATE_NORMAL			; $62ec
	ret nz			; $62ee

	ld (wDisableScreenTransitions),a		; $62ef
	call checkLinkCollisionsEnabled		; $62f2
	jr c,+			; $62f5

	; Check if diving underwater
	ld a,(wLinkSwimmingState)		; $62f7
	rlca			; $62fa
	ret nc			; $62fb
+
	ld a,(wLinkObjectIndex)		; $62fc
	ld h,a			; $62ff
	ld l,SpecialObject.start		; $6300
	call objectTakePosition		; $6302

	ld l,SpecialObject.id		; $6305
	ld a,(hl)		; $6307
	cp SPECIALOBJECTID_RAFT			; $6308
	ld a,$05		; $630a
	jr nz,+			; $630c
	add a			; $630e
+
	ld h,d			; $630f
	ld l,Part.counter2		; $6310
	ld (hl),a		; $6312

	; Get position in bc
	ld l,Part.yh		; $6313
	ldi a,(hl)		; $6315
	ld b,a			; $6316
	inc l			; $6317
	ld c,(hl)		; $6318

	ld hl,hFF8B		; $6319
	ld (hl),$06		; $631c
--
	ld hl,hFF8B		; $631e
	dec (hl)		; $6321
	jr z,_label_11_249	; $6322
	ld h,d			; $6324
	ld l,$c7		; $6325
	dec (hl)		; $6327
	ld a,(hl)		; $6328
	ld hl,$63fc		; $6329
	rst_addDoubleIndex			; $632c
	ldi a,(hl)		; $632d
	add b			; $632e
	ld b,a			; $632f
	ld a,(hl)		; $6330
	add c			; $6331
	ld c,a			; $6332
	call getTileAtPosition		; $6333
	ld e,a			; $6336
	ld a,l			; $6337
	ldh (<hFF8A),a	; $6338
	ld hl,$6418		; $633a
	call lookupCollisionTable_paramE		; $633d
	jr nc,--		; $6340

	rst_jumpTable			; $6342
.dw $6367
.dw $6398
.dw $63a3

_label_11_249:
	ld a,(wAreaFlags)		; $6349
	and $01			; $634c
	jr z,_label_11_250	; $634e
	call objectGetTileAtPosition		; $6350
	ld hl,$6437		; $6353
	call lookupCollisionTable		; $6356
	jr nc,_label_11_250	; $6359
	ld c,a			; $635b
	ld b,$3c		; $635c
	call updateLinkPositionGivenVelocity		; $635e
_label_11_250:
	ld e,$c6		; $6361
	ld a,$20		; $6363
	ld (de),a		; $6365
	ret			; $6366
	ldh a,(<hFF8A)	; $6367
	call convertShortToLongPosition		; $6369
	ld e,$cb		; $636c
	ld a,(de)		; $636e
	ldh (<hFF8F),a	; $636f
	ld e,$cd		; $6371
	ld a,(de)		; $6373
	ldh (<hFF8E),a	; $6374
	call objectGetRelativeAngleWithTempVars		; $6376
	xor $10			; $6379
	ld b,a			; $637b
	ld a,(wLinkObjectIndex)		; $637c
	ld h,a			; $637f
	ld l,$2b		; $6380
	ldd a,(hl)		; $6382
	or (hl)			; $6383
	ret nz			; $6384
	ld (hl),$01		; $6385
	inc l			; $6387
	ld (hl),$18		; $6388
	inc l			; $638a
	ld (hl),b		; $638b
	inc l			; $638c
	ld (hl),$0c		; $638d
	ld l,$25		; $638f
	ld (hl),$fe		; $6391
	ld a,SND_DAMAGE_LINK		; $6393
	jp playSound		; $6395
	ld a,(wLinkObjectIndex)		; $6398
	rrca			; $639b
	jr c,_label_11_251	; $639c
	ld a,(wLinkSwimmingState)		; $639e
	or a			; $63a1
	ret z			; $63a2
_label_11_251:
	ldh a,(<hFF8A)	; $63a3
	call convertShortToLongPosition		; $63a5
	ld e,$cb		; $63a8
	ld a,(de)		; $63aa
	ldh (<hFF8F),a	; $63ab
	ld e,$cd		; $63ad
	ld a,(de)		; $63af
	ldh (<hFF8E),a	; $63b0
	sub c			; $63b2
	inc a			; $63b3
	cp $03			; $63b4
	jr nc,_label_11_252	; $63b6
	ldh a,(<hFF8F)	; $63b8
	sub b			; $63ba
	inc a			; $63bb
	cp $03			; $63bc
	jr nc,_label_11_252	; $63be
	ld a,(wLinkObjectIndex)		; $63c0
	ld h,a			; $63c3
	ld l,$0b		; $63c4
	ld (hl),b		; $63c6
	ld l,$0d		; $63c7
	ld (hl),c		; $63c9
	ld a,$02		; $63ca
	ld (wLinkForceState),a		; $63cc
	xor a			; $63cf
	ld (wLinkStateParameter),a		; $63d0
	jp clearAllParentItems		; $63d3
_label_11_252:
	ld a,$ff		; $63d6
	ld (wDisableScreenTransitions),a		; $63d8
	call objectGetRelativeAngleWithTempVars		; $63db
	ld c,a			; $63de
	call _partDecCounter1IfNonzero		; $63df
	ld a,(hl)		; $63e2
	and $1c			; $63e3
	rrca			; $63e5
	rrca			; $63e6
	ld hl,$6410		; $63e7
	rst_addAToHl			; $63ea
	ld a,(hl)		; $63eb
	ld b,a			; $63ec
	cp $19			; $63ed
	jr c,_label_11_253	; $63ef
	ld a,(wLinkObjectIndex)		; $63f1
	ld h,a			; $63f4
	ld l,$10		; $63f5
	ld (hl),$00		; $63f7
_label_11_253:
	jp updateLinkPositionGivenVelocity		; $63f9
	nop			; $63fc
	rst $30			; $63fd
	ld a,(bc)		; $63fe
	nop			; $63ff
	nop			; $6400
	add hl,bc		; $6401
.DB $fd				; $6402
	ei			; $6403
	nop			; $6404
	nop			; $6405
	nop			; $6406
	push af			; $6407
	dec bc			; $6408
	nop			; $6409
	nop			; $640a
	dec bc			; $640b
	ld a,($00fa)		; $640c
	nop			; $640f
	inc a			; $6410
	ldd (hl),a		; $6411
	jr z,_label_11_254	; $6412
	add hl,de		; $6414
	inc d			; $6415
	rrca			; $6416
	ld a,(bc)		; $6417
	inc h			; $6418
	ld h,h			; $6419
	jr z,$64		; $641a
	ld l,$64		; $641c
	jr z,_label_11_257	; $641e
	add hl,hl		; $6420
	ld h,h			; $6421
	ld l,$64		; $6422
.DB $eb				; $6424
	nop			; $6425
	jp hl			; $6426
	ld bc,$eb00		; $6427
	nop			; $642a
	jp hl			; $642b
	ld (bc),a		; $642c
	nop			; $642d
	inc a			; $642e
	ld (bc),a		; $642f
	dec a			; $6430
	ld (bc),a		; $6431
_label_11_254:
	ld a,$02		; $6432
	ccf			; $6434
	ld (bc),a		; $6435
_label_11_255:
	nop			; $6436
	ld c,h			; $6437
	ld h,h			; $6438
	ld d,h			; $6439
	ld h,h			; $643a
	ld b,e			; $643b
	ld h,h			; $643c
	ld d,h			; $643d
	ld h,h			; $643e
	ld d,h			; $643f
	ld h,h			; $6440
	ld b,e			; $6441
	ld h,h			; $6442
	ld d,h			; $6443
	nop			; $6444
	ld d,l			; $6445
	ld ($1056),sp		; $6446
	ld d,a			; $6449
	jr _label_11_256		; $644a
_label_11_256:
	ld ($ff00+R_P1),a	; $644c
	pop hl			; $644e
	stop			; $644f
	ld ($ff00+c),a		; $6450
	jr _label_11_255		; $6451
	.db $08 $00

;;
; @addr{6455}
partCode2f:
	jp nz,partDelete		; $6455
	ld a,$29 		; $6458
	call objectGetRelatedObject1Var		; $645a
	ld a,(hl)		; $645d
	or a			; $645e
	jr z,_label_11_260	; $645f
	ld b,h			; $6461
	ld e,$c4		; $6462
	ld a,(de)		; $6464
	rst_jumpTable			; $6465
.dw $646c
.dw $647f
.dw $6493
	ld h,d			; $646c
	ld l,e			; $646d
	inc (hl)		; $646e
	ld l,$d0		; $646f
	ld (hl),$14		; $6471
	ld l,$c6		; $6473
	ld (hl),$1e		; $6475
	ld a,SND_CHARGE		; $6477
	call playSound		; $6479
	jp objectSetVisible82		; $647c
	call _partDecCounter1IfNonzero		; $647f
	jr nz,_label_11_259	; $6482
_label_11_257:
	ld l,e			; $6484
	inc (hl)		; $6485
	call objectGetAngleTowardEnemyTarget		; $6486
	ld e,$c9		; $6489
	ld (de),a		; $648b
	ld a,SND_BEAM2		; $648c
	call playSound		; $648e
	jr _label_11_259		; $6491
	ld c,$84		; $6493
	ld a,(bc)		; $6495
	cp $03			; $6496
	jr nz,_label_11_258	; $6498
	ld c,$83		; $649a
	ld a,(bc)		; $649c
	cp $02			; $649d
	jr nz,_label_11_258	; $649f
	ld a,(wFrameCounter)		; $64a1
	and $0f			; $64a4
	jr nz,_label_11_258	; $64a6
	call objectGetAngleTowardEnemyTarget		; $64a8
	call objectNudgeAngleTowards		; $64ab
_label_11_258:
	call _partCommon_checkOutOfBounds		; $64ae
	jr z,_label_11_261	; $64b1
	call objectApplySpeed		; $64b3
_label_11_259:
	jp partAnimate		; $64b6
_label_11_260:
	call objectCreatePuff		; $64b9
_label_11_261:
	jp partDelete		; $64bc

;;
; @addr{64bf}
partCode32:
	ld e,$c4		; $64bf
	ld a,(de)		; $64c1
	rst_jumpTable			; $64c2
.dw $64c7
.dw $64cf
	ld a,$01		; $64c7
	ld (de),a		; $64c9
	ld a,SND_DIG		; $64ca
	call playSound		; $64cc
	call partAnimate		; $64cf
	ld e,$e1		; $64d2
	ld a,(de)		; $64d4
	ld e,$da		; $64d5
	ld (de),a		; $64d7
	or a			; $64d8
	ret nz			; $64d9
	jp partDelete		; $64da

;;
; @addr{64dd}
partCode33:
	ld e,$c2		; $64dd
	ld a,(de)		; $64df
	ld b,a			; $64e0
	and $03			; $64e1
	ld e,$c4		; $64e3
	rst_jumpTable			; $64e5
.dw $64ee
.dw $653e
.dw $6566
.dw $65c0
	ld a,(de)		; $64ee
	or a			; $64ef
	jr z,_label_11_263	; $64f0
_label_11_262:
	call _partDecCounter1IfNonzero		; $64f2
	ret nz			; $64f5
	ld e,$f0		; $64f6
	ld a,(de)		; $64f8
	ld (hl),a		; $64f9
	jp $657e		; $64fa
_label_11_263:
	ld c,b			; $64fd
	rlc c			; $64fe
	ld a,$01		; $6500
	jr nc,_label_11_264	; $6502
	ld a,$ff		; $6504
_label_11_264:
	ld h,d			; $6506
	ld l,$f1		; $6507
	ldd (hl),a		; $6509
	rlc c			; $650a
	ld a,$3c		; $650c
	jr nc,_label_11_265	; $650e
	add a			; $6510
_label_11_265:
	ld (hl),a		; $6511
	ld l,$c6		; $6512
	ld (hl),a		; $6514
	ld a,b			; $6515
	rrca			; $6516
	rrca			; $6517
	and $03			; $6518
	ld e,$c8		; $651a
	ld (de),a		; $651c
	call $6588		; $651d
	call objectMakeTileSolid		; $6520
	ld h,$cf		; $6523
	ld (hl),$0a		; $6525
	call objectSetVisible83		; $6527
	call getFreePartSlot		; $652a
	ret nz			; $652d
	ld (hl),$33		; $652e
	inc l			; $6530
	ld (hl),$03		; $6531
	ld l,$d6		; $6533
	ld a,$c0		; $6535
	ldi (hl),a		; $6537
	ld (hl),d		; $6538
	ld h,d			; $6539
	ld l,$c4		; $653a
	inc (hl)		; $653c
	ret			; $653d
	ld a,(de)		; $653e
	jr z,_label_11_266	; $653f
	ld h,d			; $6541
	ld l,$c3		; $6542
	ld a,(hl)		; $6544
	ld l,$d8		; $6545
	ldi a,(hl)		; $6547
	ld h,(hl)		; $6548
	ld l,a			; $6549
	and (hl)		; $654a
	ret z			; $654b
	jr _label_11_262		; $654c
_label_11_266:
	call $64fd		; $654e
	ld e,$c2		; $6551
	ld a,(de)		; $6553
	bit 4,a			; $6554
	ld hl,wToggleBlocksState		; $6556
	jr z,_label_11_267	; $6559
	ld hl,wActiveTriggers		; $655b
_label_11_267:
	ld e,$d8		; $655e
	ld a,l			; $6560
	ld (de),a		; $6561
	inc e			; $6562
	ld a,h			; $6563
	ld (de),a		; $6564
	ret			; $6565
	ld a,(de)		; $6566
	or a			; $6567
	jr z,_label_11_268	; $6568
	ld h,d			; $656a
	ld l,$f2		; $656b
	ld e,l			; $656d
	ld b,(hl)		; $656e
	ld l,$c3		; $656f
	ld c,(hl)		; $6571
	ld l,$d8		; $6572
	ldi a,(hl)		; $6574
	ld h,(hl)		; $6575
	ld l,a			; $6576
	ld a,(hl)		; $6577
	and c			; $6578
	ld c,a			; $6579
	xor b			; $657a
	ret z			; $657b
	ld a,c			; $657c
	ld (de),a		; $657d
	ld h,d			; $657e
	ld l,$f1		; $657f
	ld e,$c8		; $6581
	ld a,(de)		; $6583
	add (hl)		; $6584
	and $03			; $6585
	ld (de),a		; $6587
	ld b,a			; $6588
	ld hl,$6598		; $6589
	rst_addDoubleIndex			; $658c
	ld e,$e6		; $658d
	ldi a,(hl)		; $658f
	ld (de),a		; $6590
	inc e			; $6591
	ld a,(hl)		; $6592
	ld (de),a		; $6593
	ld a,b			; $6594
	jp partSetAnimation		; $6595
	ld b,$04		; $6598
	inc b			; $659a
	inc b			; $659b
	inc b			; $659c
	ld b,$04		; $659d
	inc b			; $659f
_label_11_268:
	ld c,b			; $65a0
	rlc c			; $65a1
	ld a,$01		; $65a3
	jr nc,_label_11_269	; $65a5
	ld a,$ff		; $65a7
_label_11_269:
	rlc c			; $65a9
	jr nc,_label_11_270	; $65ab
	add a			; $65ad
_label_11_270:
	ld h,d			; $65ae
	ld l,$f1		; $65af
	ld (hl),a		; $65b1
	call $6515		; $65b2
	call $6551		; $65b5
	ld e,$c3		; $65b8
	ld a,(de)		; $65ba
	and (hl)		; $65bb
	ld e,$f2		; $65bc
	ld (de),a		; $65be
	ret			; $65bf
	ld a,(de)		; $65c0
	or a			; $65c1
	jr z,_label_11_271	; $65c2
	ld a,$21		; $65c4
	call objectGetRelatedObject1Var		; $65c6
	ld e,l			; $65c9
	ld a,(hl)		; $65ca
	ld (de),a		; $65cb
	ld l,$e6		; $65cc
	ld e,l			; $65ce
	ldi a,(hl)		; $65cf
	ld (de),a		; $65d0
	inc e			; $65d1
	ld a,(hl)		; $65d2
	ld (de),a		; $65d3
	ret			; $65d4
_label_11_271:
	ld a,$0b		; $65d5
	call objectGetRelatedObject1Var		; $65d7
	ld bc,$0c00		; $65da
	call objectTakePositionWithOffset		; $65dd
	ld h,d			; $65e0
	ld l,$c4		; $65e1
	inc (hl)		; $65e3
	ld l,$cf		; $65e4
	ld (hl),$f2		; $65e6
	ret			; $65e8

;;
; @addr{65e9}
partCode34:
	ld e,$c4		; $65e9
	ld a,(de)		; $65eb
	cp $03			; $65ec
	jr nc,_label_11_272	; $65ee
	ld a,$0d		; $65f0
	call objectGetRelatedObject1Var		; $65f2
	ld a,(hl)		; $65f5
	ld e,$cd		; $65f6
	ld (de),a		; $65f8
_label_11_272:
	ld e,$c7		; $65f9
	ld a,(de)		; $65fb
	dec a			; $65fc
	ld (de),a		; $65fd
	and $03			; $65fe
	jr nz,_label_11_273	; $6600
	ld e,$dc		; $6602
	ld a,(de)		; $6604
	xor $01			; $6605
	ld (de),a		; $6607
_label_11_273:
	ld e,$c4		; $6608
	ld a,(de)		; $660a
	rst_jumpTable			; $660b
.dw $6616
.dw $662c
.dw $665c
.dw $666f
.dw partDelete
	ld a,$01		; $6616
	ld (de),a		; $6618
	ld h,d			; $6619
	ld l,$d0		; $661a
	ld (hl),$6e		; $661c
	ld l,$c9		; $661e
	ld (hl),$10		; $6620
	ld l,$c6		; $6622
	ld a,$07		; $6624
	ldi (hl),a		; $6626
	ld (hl),$03		; $6627
	call objectSetVisible80		; $6629
	ld e,$c3		; $662c
	ld a,(de)		; $662e
	or a			; $662f
	jr z,_label_11_274	; $6630
	call _partDecCounter1IfNonzero		; $6632
	jp nz,objectApplySpeed		; $6635
_label_11_274:
	ld e,$c3		; $6638
	ld a,(de)		; $663a
	cp $06			; $663b
	jr z,_label_11_275	; $663d
	call getFreePartSlot		; $663f
	ret nz			; $6642
	ld (hl),$34		; $6643
	inc l			; $6645
	ld (hl),$0e		; $6646
	ld l,e			; $6648
	ld a,(de)		; $6649
	inc a			; $664a
	ld (hl),a		; $664b
	ld e,$d6		; $664c
	ld l,e			; $664e
	ld a,$c0		; $664f
	ldi (hl),a		; $6651
	ld a,d			; $6652
	ld (hl),a		; $6653
	call objectCopyPosition		; $6654
_label_11_275:
	ld e,$c4		; $6657
	ld a,$02		; $6659
	ld (de),a		; $665b
	ld a,$02		; $665c
	call objectGetRelatedObject1Var		; $665e
	ld a,(hl)		; $6661
	cp $0e			; $6662
	ret z			; $6664
	ld e,$c4		; $6665
	ld a,$03		; $6667
	ld (de),a		; $6669
	ld e,$c6		; $666a
	ld a,$07		; $666c
	ld (de),a		; $666e
	ld e,$c3		; $666f
	ld a,(de)		; $6671
	cp $06			; $6672
	jp z,partDelete		; $6674
	call _partDecCounter1IfNonzero		; $6677
	jp nz,objectApplySpeed		; $667a
	ld e,$c2		; $667d
	ld (de),a		; $667f
	ld e,$c4		; $6680
	ld a,$04		; $6682
	ld (de),a		; $6684
	ret			; $6685

;;
; @addr{6686}
partCode35:
	ld a,$29		; $6686
	call objectGetRelatedObject1Var		; $6688
	ld a,(hl)		; $668b
	or a			; $668c
	jp z,partDelete		; $668d
	ld e,$c2		; $6690
	ld a,(de)		; $6692
	rlca			; $6693
	jr c,_label_11_276	; $6694
	ld a,(wLinkGrabState)		; $6696
	or a			; $6699
	call z,objectPushLinkAwayOnCollision		; $669a
	ld e,$c4		; $669d
	ld a,(de)		; $669f
	rst_jumpTable			; $66a0
.dw $66d2
.dw $673a
.dw $677c
.dw $680f
.dw $686d
.dw $68e2
.dw $6924

_label_11_276:
	ld e,$c6		; $66af
	ld a,(de)		; $66b1
	or a			; $66b2
	jr nz,_label_11_277	; $66b3
	ld e,$c4		; $66b5
	ld a,(de)		; $66b7
	cp $04			; $66b8
	jr z,_label_11_277	; $66ba
	ld e,$da		; $66bc
	ld a,(de)		; $66be
	xor $80			; $66bf
	ld (de),a		; $66c1
_label_11_277:
	ld e,$c4		; $66c2
	ld a,(de)		; $66c4
	rst_jumpTable			; $66c5
.dw $6705
.dw $6747
.dw $67f1
.dw $680f
.dw $68c3
.dw $690c
	call $6731		; $66d2
	ld e,$d7		; $66d5
	ld a,(de)		; $66d7
	ld e,$f0		; $66d8
	ld (de),a		; $66da
	call $6956		; $66db
	ld a,(de)		; $66de
	swap a			; $66df
	ld (de),a		; $66e1
	or $80			; $66e2
	ld (hl),a		; $66e4
	call $6992		; $66e5
	ld l,$d6		; $66e8
	ld a,$c0		; $66ea
	ldi (hl),a		; $66ec
	ld (hl),d		; $66ed
	ld e,$c2		; $66ee
	ld a,(de)		; $66f0
	swap a			; $66f1
	ld hl,$6703		; $66f3
	rst_addAToHl			; $66f6
	ld a,(hl)		; $66f7
	ld e,$c9		; $66f8
	ld (de),a		; $66fa
	ld a,SND_THROW		; $66fb
	call playSound		; $66fd
	jp objectSetVisiblec0		; $6700
	jr $08			; $6703
	call $6731		; $6705
	call $6956		; $6708
	call $6992		; $670b
	ld l,$d6		; $670e
	ld a,$c0		; $6710
	ldi (hl),a		; $6712
	ld (hl),d		; $6713
	ld l,$f0		; $6714
	ld e,l			; $6716
	ld a,(de)		; $6717
	ld (hl),a		; $6718
	ld a,$01		; $6719
	call partSetAnimation		; $671b
	ld e,$c2		; $671e
	ld a,(de)		; $6720
	and $0f			; $6721
	add $0a			; $6723
	ld e,$c6		; $6725
	ld (de),a		; $6727
	ld e,$e4		; $6728
	ld a,(de)		; $672a
	res 7,a			; $672b
	ld (de),a		; $672d
	jp objectSetVisiblec1		; $672e
	ld a,$01		; $6731
	ld (de),a		; $6733
	ld e,$cf		; $6734
	ld a,$81		; $6736
	ld (de),a		; $6738
	ret			; $6739
	ld c,$10		; $673a
	call objectUpdateSpeedZ_paramC		; $673c
	ret nz			; $673f
	ld e,$f1		; $6740
	ld a,(de)		; $6742
	or a			; $6743
	jr nz,_label_11_278	; $6744
	ret			; $6746
	call _partDecCounter1IfNonzero		; $6747
	ret nz			; $674a
	ld c,$10		; $674b
	call objectUpdateSpeedZ_paramC		; $674d
	ret nz			; $6750
	ld l,$c7		; $6751
	ld a,(hl)		; $6753
	or a			; $6754
	jr nz,_label_11_278	; $6755
	inc (hl)		; $6757
	ld bc,$fe80		; $6758
	jp objectSetSpeedZ		; $675b
_label_11_278:
	ld a,$78		; $675e
	jr _label_11_279		; $6760
	ld a,$14		; $6762
_label_11_279:
	ld e,$d0		; $6764
	ld (de),a		; $6766
	ld a,$31		; $6767
	call objectGetRelatedObject1Var		; $6769
	inc (hl)		; $676c
	ld e,$c4		; $676d
	ld a,$03		; $676f
	ld (de),a		; $6771
	call $693b		; $6772
	call objectGetRelativeAngle		; $6775
	ld e,$c9		; $6778
	ld (de),a		; $677a
	ret			; $677b
	inc e			; $677c
	ld a,(de)		; $677d
	rst_jumpTable			; $677e
.dw $6787
.dw $67b7
.dw $67b0
.dw $67b0
	ld h,d			; $6787
	ld l,e			; $6788
	inc (hl)		; $6789
	ld a,$90		; $678a
	ld (wLinkGrabState2),a		; $678c
	xor a			; $678f
	ld l,$ca		; $6790
	ldd (hl),a		; $6792
	ld ($d00a),a		; $6793
	ld (hl),$10		; $6796
	ld l,$d0		; $6798
	ld (hl),$14		; $679a
	ld l,$c7		; $679c
	ld (hl),$60		; $679e
	call $69a5		; $67a0
	ld l,$b7		; $67a3
	ld e,$c2		; $67a5
	ld a,(de)		; $67a7
	swap a			; $67a8
	jp unsetFlag		; $67aa
_label_11_280:
	call dropLinkHeldItem		; $67ad
	ld a,SND_BIGSWORD		; $67b0
	call playSound		; $67b2
	jr _label_11_278		; $67b5
	call $69a5		; $67b7
	ldi a,(hl)		; $67ba
	cp $11			; $67bb
	jr z,_label_11_280	; $67bd
	ld a,($d221)		; $67bf
	or a			; $67c2
	jr nz,_label_11_281	; $67c3
	ld e,$f3		; $67c5
	ld (de),a		; $67c7
	ret			; $67c8
_label_11_281:
	ld h,d			; $67c9
	ld l,$c7		; $67ca
	ld a,(hl)		; $67cc
	or a			; $67cd
	ret z			; $67ce
	dec (hl)		; $67cf
	jr nz,_label_11_282	; $67d0
	dec l			; $67d2
	ld (hl),$14		; $67d3
	ld l,$f2		; $67d5
	inc (hl)		; $67d7
_label_11_282:
	ld l,$f3		; $67d8
	ld a,(hl)		; $67da
	or a			; $67db
	jr nz,_label_11_283	; $67dc
	ld a,SND_MOVEBLOCK		; $67de
	ld (hl),a		; $67e0
	call playSound		; $67e1
_label_11_283:
	ld h,d			; $67e4
	ld l,$c9		; $67e5
	ld c,(hl)		; $67e7
	ld l,$d0		; $67e8
	ld b,(hl)		; $67ea
	call updateLinkPositionGivenVelocity		; $67eb
	jp objectApplySpeed		; $67ee
	ld a,$0b		; $67f1
	call objectGetRelatedObject1Var		; $67f3
	ld e,$cb		; $67f6
	ld a,(de)		; $67f8
	sub (hl)		; $67f9
	cpl			; $67fa
	inc a			; $67fb
	cp $10			; $67fc
	jr c,_label_11_284	; $67fe
	ld a,(de)		; $6800
	inc a			; $6801
	ld (de),a		; $6802
_label_11_284:
	ld a,$04		; $6803
	call objectGetRelatedObject1Var		; $6805
	ld a,(hl)		; $6808
	cp $02			; $6809
	ret z			; $680b
	jp $675e		; $680c
	ld e,$c6		; $680f
	ld a,(de)		; $6811
	or a			; $6812
	jr z,_label_11_285	; $6813
	dec a			; $6815
	ld (de),a		; $6816
	jp objectApplySpeed		; $6817
_label_11_285:
	call $693b		; $681a
	call objectGetRelativeAngle		; $681d
	ld e,$c9		; $6820
	ld (de),a		; $6822
	call objectApplySpeed		; $6823
	call $6970		; $6826
	ret nz			; $6829
	ld e,$c2		; $682a
	ld a,(de)		; $682c
	rlca			; $682d
	jr c,_label_11_287	; $682e
	ld h,d			; $6830
	ld l,$e4		; $6831
	set 7,(hl)		; $6833
	ld e,$f2		; $6835
	ld a,(de)		; $6837
	or a			; $6838
	jr z,_label_11_286	; $6839
	xor a			; $683b
	ld (de),a		; $683c
	call $69a5		; $683d
	ld l,$ab		; $6840
	ld a,(hl)		; $6842
	or a			; $6843
	jr nz,_label_11_286	; $6844
	ld (hl),$3c		; $6846
	ld l,$b5		; $6848
	inc (hl)		; $684a
	ld a,SND_BOSS_DAMAGE		; $684b
	call playSound		; $684d
_label_11_286:
	ld e,$c6		; $6850
	ld a,$3c		; $6852
	ld (de),a		; $6854
	call $69a5		; $6855
	ld l,$b7		; $6858
	ld e,$c2		; $685a
	ld a,(de)		; $685c
	swap a			; $685d
	call setFlag		; $685f
	jr _label_11_288		; $6862
_label_11_287:
	call objectSetInvisible		; $6864
_label_11_288:
	ld e,$c4		; $6867
	ld a,$04		; $6869
	ld (de),a		; $686b
	ret			; $686c
	ld h,d			; $686d
	ld l,$e4		; $686e
	set 7,(hl)		; $6870
	call $68d7		; $6872
	call _partDecCounter1IfNonzero		; $6875
	ret nz			; $6878
	call $69a5		; $6879
	ldi a,(hl)		; $687c
	cp $12			; $687d
	ret nz			; $687f
	ld a,(hl)		; $6880
	bit 5,a			; $6881
	jr nz,_label_11_289	; $6883
	ld e,$c2		; $6885
	ld a,(de)		; $6887
	cp (hl)			; $6888
	jr z,_label_11_289	; $6889
	call objectGetAngleTowardLink		; $688b
	cp $10			; $688e
	ret nz			; $6890
	ld a,(w1Link.direction)		; $6891
	or a			; $6894
	ret nz			; $6895
	ld h,d			; $6896
	ld l,$e4		; $6897
	res 7,(hl)		; $6899
	jp objectAddToGrabbableObjectBuffer		; $689b
_label_11_289:
	ld a,SND_EXPLOSION		; $689e
	call playSound		; $68a0
	call objectGetAngleTowardLink		; $68a3
	ld h,d			; $68a6
	ld l,$c9		; $68a7
	ld (hl),a		; $68a9
	ld l,$c4		; $68aa
	ld (hl),$05		; $68ac
	ld l,$c6		; $68ae
	ld (hl),$02		; $68b0
	ld l,$d0		; $68b2
	ld (hl),$78		; $68b4
	call $69a5		; $68b6
	ld l,$b7		; $68b9
	ld e,$c2		; $68bb
	ld a,(de)		; $68bd
	swap a			; $68be
	jp unsetFlag		; $68c0
	ld a,$04		; $68c3
	call objectGetRelatedObject1Var		; $68c5
	ld a,(hl)		; $68c8
	cp $04			; $68c9
	jr z,_label_11_290	; $68cb
	ld e,l			; $68cd
	ld (de),a		; $68ce
	ld l,$c9		; $68cf
	ld e,l			; $68d1
	ld a,(hl)		; $68d2
	ld (de),a		; $68d3
	jp objectSetVisible		; $68d4
_label_11_290:
	call $693b		; $68d7
	ld h,d			; $68da
	ld l,$cb		; $68db
	ld (hl),b		; $68dd
	ld l,$cd		; $68de
	ld (hl),c		; $68e0
	ret			; $68e1
	call _partCommon_getTileCollisionInFront		; $68e2
	jr nz,_label_11_292	; $68e5
	call objectApplySpeed		; $68e7
	call _partDecCounter1IfNonzero		; $68ea
	ret nz			; $68ed
	ld (hl),$03		; $68ee
	ld e,$d0		; $68f0
	ld a,(de)		; $68f2
	or a			; $68f3
	jp z,$68fe		; $68f4
	sub $0a			; $68f7
	jr nc,_label_11_291	; $68f9
	xor a			; $68fb
_label_11_291:
	ld (de),a		; $68fc
	ret			; $68fd
_label_11_292:
	ld h,d			; $68fe
	ld l,$c4		; $68ff
	ld (hl),$06		; $6901
	ld l,$c6		; $6903
	ld (hl),$3c		; $6905
	ld l,$d0		; $6907
	ld (hl),$00		; $6909
	ret			; $690b
	ld a,$10		; $690c
	call objectGetRelatedObject1Var		; $690e
	ld e,l			; $6911
	ld a,(hl)		; $6912
	sub $19			; $6913
	jr nc,_label_11_293	; $6915
	xor a			; $6917
_label_11_293:
	ld (de),a		; $6918
	ld l,$c4		; $6919
	ld a,(hl)		; $691b
	cp $03			; $691c
	jp nz,objectApplySpeed		; $691e
	jp $6762		; $6921
	call _partDecCounter1IfNonzero		; $6924
	ret nz			; $6927
	ld l,$e4		; $6928
	res 7,(hl)		; $692a
	call $69a5		; $692c
	inc l			; $692f
	ld a,(hl)		; $6930
	bit 5,a			; $6931
	jr z,_label_11_294	; $6933
	ld a,$80		; $6935
	ld (hl),a		; $6937
_label_11_294:
	jp $6762		; $6938
	ld e,$c2		; $693b
	ld a,(de)		; $693d
	swap a			; $693e
	ld c,$0c		; $6940
	rrca			; $6942
	jr nc,_label_11_295	; $6943
	ld c,$f4		; $6945
_label_11_295:
	ld e,$f0		; $6947
	ld a,(de)		; $6949
	ld h,a			; $694a
	ld l,$8b		; $694b
	ldi a,(hl)		; $694d
	add $0c			; $694e
	ld b,a			; $6950
	inc l			; $6951
	ld a,(hl)		; $6952
	add c			; $6953
	ld c,a			; $6954
	ret			; $6955
	ld e,$c2		; $6956
	ld a,(de)		; $6958
	and $0f			; $6959
	cp $02			; $695b
	ret z			; $695d
	call getFreePartSlot		; $695e
	ld a,$35		; $6961
	ldi (hl),a		; $6963
	ld a,(de)		; $6964
	inc a			; $6965
	ld (hl),a		; $6966
	ld e,$f0		; $6967
	ld l,e			; $6969
	ld a,(de)		; $696a
	ld (hl),a		; $696b
	ld l,$c2		; $696c
	ld e,l			; $696e
	ret			; $696f
	call $693b		; $6970
	ld e,$03		; $6973
	ld h,d			; $6975
	ld l,$cb		; $6976
	ld a,e			; $6978
	add b			; $6979
	cp (hl)			; $697a
	jr c,_label_11_296	; $697b
	sub e			; $697d
	sub e			; $697e
	cp (hl)			; $697f
	jr nc,_label_11_296	; $6980
	ld l,$cd		; $6982
	ld a,e			; $6984
	add c			; $6985
	cp (hl)			; $6986
	jr c,_label_11_296	; $6987
	sub e			; $6989
	sub e			; $698a
	cp (hl)			; $698b
	jr nc,_label_11_296	; $698c
	xor a			; $698e
	ret			; $698f
_label_11_296:
	or d			; $6990
	ret			; $6991
	push hl			; $6992
	ld a,(hl)		; $6993
	and $10			; $6994
	swap a			; $6996
	ld hl,$69a3		; $6998
	rst_addAToHl			; $699b
	ld c,(hl)		; $699c
	ld b,$fc		; $699d
	pop hl			; $699f
	jp objectCopyPositionWithOffset		; $69a0
	ld hl,sp+$08		; $69a3
	ld e,$f0		; $69a5
	ld a,(de)		; $69a7
	ld h,a			; $69a8
	ld l,$82		; $69a9
	ret			; $69ab


; ==============================================================================
; PARTID_CANDLE_FLAME
; ==============================================================================
partCode36:
	ld a,Object.id		; $69ac
	call objectGetRelatedObject1Var		; $69ae
	ld a,(hl)		; $69b1
	cp ENEMYID_CANDLE			; $69b2
	jp nz,partDelete		; $69b4

	ld b,h			; $69b7
	ld e,Part.state		; $69b8
	ld a,(de)		; $69ba
	rst_jumpTable			; $69bb
	.dw @state0
	.dw @state1
	.dw @state2


@state0:
	ld h,d			; $69c2
	ld l,e			; $69c3
	inc (hl) ; [state]
	call objectSetVisible81		; $69c5

@state1:
	; Check parent's speed
	ld h,b			; $69c8
	ld l,Enemy.speed		; $69c9
	ld a,(hl)		; $69cb
	cp SPEED_100			; $69cc
	jr z,@state2	; $69ce

	ld a,$02		; $69d0
	ld (de),a ; [state]

	push bc			; $69d3
	dec a			; $69d4
	call partSetAnimation		; $69d5
	pop bc			; $69d8

@state2:
	ld h,b			; $69d9
	ld l,Enemy.enemyCollisionMode		; $69da
	ld a,(hl)		; $69dc
	cp ENEMYCOLLISION_PODOBOO			; $69dd
	jp z,partDelete		; $69df

	call objectTakePosition		; $69e2
	ld e,Part.zh		; $69e5
	ld a,$f3		; $69e7
	ld (de),a		; $69e9
	jp partAnimate		; $69ea


; ==============================================================================
; PARTID_VERAN_PROJECTILE
; ==============================================================================
partCode37:
	jp nz,partDelete		; $69ed

	ld e,Part.subid		; $69f0
	ld a,(de)		; $69f2
	or a			; $69f3
	jp nz,_veranProjectile_subid1		; $69f4


; The "core" projectile spawner
_veranProjectile_subid0:
	ld a,Object.collisionType		; $69f7
	call objectGetRelatedObject1Var		; $69f9
	bit 7,(hl)		; $69fc
	jr z,@delete	; $69fe

	ld e,Part.state		; $6a00
	ld a,(de)		; $6a02
	rst_jumpTable			; $6a03
	.dw @state0
	.dw @state1
	.dw @state2


; Initialization
@state0:
	ld h,d			; $6a0a
	ld l,e			; $6a0b
	inc (hl) ; [state]

	ld l,Part.zh		; $6a0d
	ld (hl),$fc		; $6a0f
	jp objectSetVisible81		; $6a11


; Moving upward
@state1:
	ld h,d			; $6a14
	ld l,Part.zh		; $6a15
	dec (hl)		; $6a17

	ld a,(hl)		; $6a18
	cp $f0			; $6a19
	jr nz,@animate	; $6a1b

	; Moved high enough to go to next state

	ld l,e			; $6a1d
	inc (hl) ; [state]

	ld l,Part.counter1		; $6a1f
	ld (hl),129		; $6a21
	jr @animate		; $6a23


; Firing projectiles every 8 frames until counter1 reaches 0
@state2:
	call _partDecCounter1IfNonzero		; $6a25
	jr z,@delete	; $6a28

	ld a,(hl)		; $6a2a
	and $07			; $6a2b
	jr nz,@animate	; $6a2d

	; Calculate angle in 'b' based on counter1
	ld a,(hl)		; $6a2f
	rrca			; $6a30
	rrca			; $6a31
	and $1f			; $6a32
	ld b,a			; $6a34

	; Create a projectile
	call getFreePartSlot		; $6a35
	jr nz,@animate	; $6a38
	ld (hl),PARTID_VERAN_PROJECTILE		; $6a3a
	inc l			; $6a3c
	inc (hl) ; [subid] = 1

	ld l,Part.angle		; $6a3e
	ld (hl),b		; $6a40

	call objectCopyPosition		; $6a41

@animate:
	jp partAnimate		; $6a44

@delete:
	ldbc INTERACID_PUFF,$80		; $6a47
	call objectCreateInteraction		; $6a4a
	jp partDelete		; $6a4d


; An individiual projectile
_veranProjectile_subid1:
	ld e,Part.state		; $6a50
	ld a,(de)		; $6a52
	rst_jumpTable			; $6a53
	.dw @state0
	.dw @state1
	.dw @state2


; Initialization
@state0:
	ld h,d			; $6a5a
	ld l,e			; $6a5b
	inc (hl) ; [state]

	ld l,Part.speed		; $6a5d
	ld (hl),SPEED_280		; $6a5f

	ld l,Part.collisionRadiusY		; $6a61
	ld a,$04		; $6a63
	ldi (hl),a		; $6a65
	ld (hl),a		; $6a66

	call objectSetVisible81		; $6a67

	ld a,SND_VERAN_PROJECTILE		; $6a6a
	call playSound		; $6a6c

	ld a,$01		; $6a6f
	jp partSetAnimation		; $6a71


; Moving to ground as well as in normal direction
@state1:
	ld h,d			; $6a74
	ld l,Part.zh		; $6a75
	inc (hl)		; $6a77
	jr nz,@state2	; $6a78

	ld l,e			; $6a7a
	inc (hl) ; [state]


; Just moving normally
@state2:
	call objectApplySpeed		; $6a7c
	call _partCommon_checkTileCollisionOrOutOfBounds		; $6a7f
	ret nz			; $6a82
	jp partDelete		; $6a83

;;
; @addr{6a86}
partCode38:
	jr z,_label_11_301	; $6a86
	ld e,$ea		; $6a88
	ld a,(de)		; $6a8a
	cp $80			; $6a8b
	jp z,partDelete		; $6a8d
	ld h,d			; $6a90
	ld l,$c4		; $6a91
	ld a,(hl)		; $6a93
	cp $02			; $6a94
	jr nc,_label_11_301	; $6a96
	ld (hl),$02		; $6a98
_label_11_301:
	ld h,d			; $6a9a
	ld l,$c6		; $6a9b
	ld a,(hl)		; $6a9d
	or a			; $6a9e
	jr z,_label_11_302	; $6a9f
	dec (hl)		; $6aa1
	ret			; $6aa2
_label_11_302:
	ld e,$c4		; $6aa3
	ld a,(de)		; $6aa5
	rst_jumpTable			; $6aa6
.dw $6aaf
.dw $6ae7
.dw $6b0c
.dw $6b24
	ld h,d			; $6aaf
	ld l,e			; $6ab0
	inc (hl)		; $6ab1
	ld l,$c9		; $6ab2
	ld (hl),$10		; $6ab4
	call objectSetVisible81		; $6ab6
	call getRandomNumber		; $6ab9
	and $0f			; $6abc
	ld hl,$6ad7		; $6abe
	rst_addAToHl			; $6ac1
	ld a,(hl)		; $6ac2
	ld h,d			; $6ac3
	ld l,$d0		; $6ac4
	or a			; $6ac6
	jr nz,_label_11_303	; $6ac7
	ld (hl),$64		; $6ac9
	ld a,SND_THROW		; $6acb
	jp playSound		; $6acd
_label_11_303:
	ld (hl),$3c		; $6ad0
	ld a,SND_FALLINHOLE		; $6ad2
	jp playSound		; $6ad4
	ld bc,$0101		; $6ad7
	ld bc,$0000		; $6ada
	nop			; $6add
	nop			; $6ade
	nop			; $6adf
	nop			; $6ae0
	nop			; $6ae1
	nop			; $6ae2
	nop			; $6ae3
	nop			; $6ae4
	nop			; $6ae5
	nop			; $6ae6
	call objectCheckWithinScreenBoundary		; $6ae7
	jp nc,$6c17		; $6aea
	call _partCommon_checkTileCollisionOrOutOfBounds		; $6aed
	jr nc,_label_11_304	; $6af0
	call $6b00		; $6af2
	jr nc,_label_11_304	; $6af5
	jp z,$6c17		; $6af7
	jp $6bf6		; $6afa
_label_11_304:
	jp objectApplySpeed		; $6afd
	scf			; $6b00
	push af			; $6b01
	ld a,(hl)		; $6b02
	cp $0f			; $6b03
	jr z,_label_11_305	; $6b05
	pop af			; $6b07
	ccf			; $6b08
	ret			; $6b09
_label_11_305:
	pop af			; $6b0a
	ret			; $6b0b
	ld a,$03		; $6b0c
	ld (de),a		; $6b0e
	ld a,SND_CLINK		; $6b0f
	call playSound		; $6b11
	ld h,d			; $6b14
	ld l,$c6		; $6b15
	ld (hl),$00		; $6b17
	ld l,$d0		; $6b19
	ld (hl),$78		; $6b1b
	ld l,$ec		; $6b1d
	ld a,(hl)		; $6b1f
	ld l,$c9		; $6b20
	ld (hl),a		; $6b22
	ret			; $6b23
	call objectCheckWithinScreenBoundary		; $6b24
	jp nc,$6c17		; $6b27
	ld b,$ff		; $6b2a
	call $6b5f		; $6b2c
	call _partCommon_checkTileCollisionOrOutOfBounds		; $6b2f
	jr nc,_label_11_306	; $6b32
	call $6b00		; $6b34
	jr nc,_label_11_306	; $6b37
	jp z,$6c17		; $6b39
	call $6c02		; $6b3c
_label_11_306:
	ld b,$02		; $6b3f
	call $6b5f		; $6b41
	call _partCommon_checkTileCollisionOrOutOfBounds		; $6b44
	jr nc,_label_11_307	; $6b47
	call $6b00		; $6b49
	jr nc,_label_11_307	; $6b4c
	jp z,$6c17		; $6b4e
	call $6c08		; $6b51
_label_11_307:
	ld b,$ff		; $6b54
	call $6b5f		; $6b56
	call partAnimate		; $6b59
	jp objectApplySpeed		; $6b5c
	ld e,$cd		; $6b5f
	ld a,(de)		; $6b61
	add b			; $6b62
	ld (de),a		; $6b63
	ret			; $6b64
	call objectGetTileAtPosition		; $6b65
	ld a,l			; $6b68
	ldh (<hFF8C),a	; $6b69
	ld c,(hl)		; $6b6b
	call $6b71		; $6b6c
	jr _label_11_311		; $6b6f
	ld a,$ff		; $6b71
	ld ($cfd5),a		; $6b73
	xor a			; $6b76
_label_11_308:
	ldh (<hFF8B),a	; $6b77
	ld hl,$6bab		; $6b79
	rst_addAToHl			; $6b7c
	ld a,(hl)		; $6b7d
	cp c			; $6b7e
	jr nz,_label_11_310	; $6b7f
	ld a,($ccd6)		; $6b81
	and $7f			; $6b84
	cp $01			; $6b86
	ldh a,(<hFF8B)	; $6b88
	ld ($cfd5),a		; $6b8a
	jr z,_label_11_309	; $6b8d
	add $04			; $6b8f
_label_11_309:
	ld hl,bitTable		; $6b91
	add l			; $6b94
	ld l,a			; $6b95
	ld a,($ccd4)		; $6b96
	or (hl)			; $6b99
	ld ($ccd4),a		; $6b9a
	jr $10			; $6b9d
_label_11_310:
	ldh a,(<hFF8B)	; $6b9f
	inc a			; $6ba1
	cp $04			; $6ba2
	jr nz,_label_11_308	; $6ba4
	ld hl,$ccd6		; $6ba6
	dec (hl)		; $6ba9
	ret			; $6baa
	reti			; $6bab
	rst_addAToHl			; $6bac
	call c,$cdd8		; $6bad
	sub (hl)		; $6bb0
	jr nz,_label_11_315	; $6bb1
	ld a,$a0		; $6bb3
	call setTile		; $6bb5
	ld h,d			; $6bb8
	ld l,$c6		; $6bb9
	ld (hl),$03		; $6bbb
	ld a,($ccd6)		; $6bbd
	and $7f			; $6bc0
	cp $01			; $6bc2
	ret nz			; $6bc4
	ld a,SND_SWITCH		; $6bc5
	jp playSound		; $6bc7
_label_11_311:
	ld a,($cfd5)		; $6bca
	cp $ff			; $6bcd
	ret z			; $6bcf
	ld a,$04		; $6bd0
_label_11_312:
	ldh (<hFF8B),a	; $6bd2
	ld bc,$9204		; $6bd4
	ld a,($cfd5)		; $6bd7
	cp $02			; $6bda
	jr c,_label_11_313	; $6bdc
	ld bc,$9205		; $6bde
_label_11_313:
	call objectCreateInteraction		; $6be1
	jr nz,_label_11_314	; $6be4
	ld l,$4b		; $6be6
	ldh a,(<hFF8C)	; $6be8
	call setShortPosition		; $6bea
	ld l,$49		; $6bed
	ldh a,(<hFF8B)	; $6bef
	dec a			; $6bf1
	ld (hl),a		; $6bf2
	jr nz,_label_11_312	; $6bf3
_label_11_314:
	ret			; $6bf5
	ld a,SND_STRIKE		; $6bf6
	call playSound		; $6bf8
	ld a,$01		; $6bfb
	ld ($cfd6),a		; $6bfd
	jr _label_11_316		; $6c00
_label_11_315:
	call $6c0e		; $6c02
	jp $6b65		; $6c05
	call $6c0e		; $6c08
	jp $6b65		; $6c0b
	xor a			; $6c0e
	ld ($cfd6),a		; $6c0f
	ld hl,$ccd6		; $6c12
	inc (hl)		; $6c15
	ret			; $6c16
	xor a			; $6c17
	ld ($cfd6),a		; $6c18
	ld a,($ccd6)		; $6c1b
	and $7f			; $6c1e
	jr nz,_label_11_316	; $6c20
	ld a,SND_ERROR		; $6c22
	call playSound		; $6c24
_label_11_316:
	ld hl,$ccd6		; $6c27
	set 7,(hl)		; $6c2a
	jp partDelete		; $6c2c

;;
; @addr{6c2f}
partCode39:
	ld e,$c4		; $6c2f
	ld a,(de)		; $6c31
	rst_jumpTable			; $6c32
.dw $6c39
.dw $6c6a
.dw $6caa
	ld h,d			; $6c39
	ld l,e			; $6c3a
	inc (hl)		; $6c3b
	ld l,$c6		; $6c3c
	ld (hl),$1e		; $6c3e
	ld l,$d4		; $6c40
	ld a,$20		; $6c42
	ldi (hl),a		; $6c44
	ld (hl),$fc		; $6c45
	call getRandomNumber_noPreserveVars		; $6c47
	and $10			; $6c4a
	add $08			; $6c4c
	ld e,$c9		; $6c4e
	ld (de),a		; $6c50
	call getRandomNumber_noPreserveVars		; $6c51
	and $03			; $6c54
	ld hl,$6c66		; $6c56
	rst_addAToHl			; $6c59
	ld e,$d0		; $6c5a
	ld a,(hl)		; $6c5c
	ld (de),a		; $6c5d
	call objectSetVisible82		; $6c5e
	ld a,SND_FALLINHOLE		; $6c61
	jp playSound		; $6c63
	rrca			; $6c66
	add hl,de		; $6c67
	inc hl			; $6c68
	dec l			; $6c69
	call objectApplySpeed		; $6c6a
	ld h,d			; $6c6d
	ld l,$d4		; $6c6e
	ld e,$ca		; $6c70
	call add16BitRefs		; $6c72
	dec l			; $6c75
	ld a,(hl)		; $6c76
	add $20			; $6c77
	ldi (hl),a		; $6c79
	ld a,(hl)		; $6c7a
	adc $00			; $6c7b
	ld (hl),a		; $6c7d
	call _partDecCounter1IfNonzero		; $6c7e
	jr nz,_label_11_317	; $6c81
	ld a,(de)		; $6c83
	cp $b0			; $6c84
	jp nc,partDelete		; $6c86
	add $06			; $6c89
	ld b,a			; $6c8b
	ld l,$cd		; $6c8c
	ld c,(hl)		; $6c8e
	call checkTileCollisionAt_allowHoles		; $6c8f
	jr nc,_label_11_317	; $6c92
	ld h,d			; $6c94
	ld l,$c4		; $6c95
	inc (hl)		; $6c97
	ld l,$db		; $6c98
	ld a,$0b		; $6c9a
	ldi (hl),a		; $6c9c
	ldi (hl),a		; $6c9d
	ld (hl),$26		; $6c9e
	ld a,$01		; $6ca0
	call partSetAnimation		; $6ca2
	ld a,SND_BREAK_ROCK		; $6ca5
	jp playSound		; $6ca7
	ld e,$e1		; $6caa
	ld a,(de)		; $6cac
	bit 7,a			; $6cad
	jp nz,partDelete		; $6caf
	ld hl,$6cc0		; $6cb2
	rst_addAToHl			; $6cb5
	ld e,$e6		; $6cb6
	ldi a,(hl)		; $6cb8
	ld (de),a		; $6cb9
	inc e			; $6cba
	ld a,(hl)		; $6cbb
	ld (de),a		; $6cbc
_label_11_317:
	jp partAnimate		; $6cbd
	inc b			; $6cc0
	add hl,bc		; $6cc1
	ld b,$0b		; $6cc2
	add hl,bc		; $6cc4
	inc c			; $6cc5
	ld a,(bc)		; $6cc6
	dec c			; $6cc7
	dec bc			; $6cc8
	.db $0e

;;
; @addr{6cca}
partCode3a:
	jr z,+	 		; $6cca
	ld e,$ea		; $6ccc
	ld a,(de)		; $6cce
	res 7,a			; $6ccf
	cp $04			; $6cd1
	jp c,partDelete		; $6cd3
	jp $6e4a		; $6cd6
+
	ld e,$c2		; $6cd9
	ld a,(de)		; $6cdb
	ld e,$c4		; $6cdc
	rst_jumpTable			; $6cde
.dw $6ce7
.dw $6d06
.dw $6d39
.dw $6dfd
	ld a,(de)		; $6ce7
	or a			; $6ce8
	jr z,_label_11_319	; $6ce9
_label_11_318:
	call _partCommon_checkOutOfBounds		; $6ceb
	jp z,partDelete		; $6cee
	call objectApplySpeed		; $6cf1
	jp partAnimate		; $6cf4
_label_11_319:
	call $6e50		; $6cf7
	call objectGetAngleTowardEnemyTarget		; $6cfa
	ld e,$c9		; $6cfd
	ld (de),a		; $6cff
	call $6e5d		; $6d00
	jp objectSetVisible80		; $6d03
	ld a,(de)		; $6d06
	or a			; $6d07
	jr nz,_label_11_318	; $6d08
	call $6e50		; $6d0a
	call $6e2f		; $6d0d
	ld e,$c3		; $6d10
	ld a,(de)		; $6d12
	or a			; $6d13
	ret nz			; $6d14
	call objectGetAngleTowardEnemyTarget		; $6d15
	ld e,$c9		; $6d18
	ld (de),a		; $6d1a
	sub $02			; $6d1b
	and $1f			; $6d1d
	ld b,a			; $6d1f
	ld e,$01		; $6d20
	call getFreePartSlot		; $6d22
	ld (hl),$3a		; $6d25
	inc l			; $6d27
	ld (hl),e		; $6d28
	inc l			; $6d29
	inc (hl)		; $6d2a
	ld l,$c9		; $6d2b
	ld (hl),b		; $6d2d
	ld l,$d6		; $6d2e
	ld e,l			; $6d30
	ld a,(de)		; $6d31
	ldi (hl),a		; $6d32
	inc e			; $6d33
	ld a,(de)		; $6d34
	ld (hl),a		; $6d35
	jp objectCopyPosition		; $6d36
	ld a,(de)		; $6d39
	rst_jumpTable			; $6d3a
.dw $6d43
.dw $6d84
.dw $6dc6
.dw $6ceb
	ld h,d			; $6d43
	ld l,$db		; $6d44
	ld a,$03		; $6d46
	ldi (hl),a		; $6d48
	ld (hl),a		; $6d49
	ld l,$c3		; $6d4a
	ld a,(hl)		; $6d4c
	or a			; $6d4d
	jr z,_label_11_320	; $6d4e
	ld l,e			; $6d50
	ld (hl),$03		; $6d51
	call $6e5d		; $6d53
	ld a,$01		; $6d56
	call partSetAnimation		; $6d58
	jp objectSetVisible82		; $6d5b
_label_11_320:
	call $6e50		; $6d5e
	ld l,$f0		; $6d61
	ldh a,(<hEnemyTargetY)	; $6d63
	ldi (hl),a		; $6d65
	ldh a,(<hEnemyTargetX)	; $6d66
	ld (hl),a		; $6d68
	ld a,$29		; $6d69
	call objectGetRelatedObject1Var		; $6d6b
	ld a,(hl)		; $6d6e
	ld b,$19		; $6d6f
	cp $10			; $6d71
	jr nc,_label_11_321	; $6d73
	ld b,$2d		; $6d75
	cp $0a			; $6d77
	jr nc,_label_11_321	; $6d79
	ld b,$41		; $6d7b
_label_11_321:
	ld e,$d0		; $6d7d
	ld a,b			; $6d7f
	ld (de),a		; $6d80
	jp objectSetVisible80		; $6d81
	ld h,d			; $6d84
	ld l,$f0		; $6d85
	ld b,(hl)		; $6d87
	inc l			; $6d88
	ld c,(hl)		; $6d89
	ld l,$cb		; $6d8a
	ldi a,(hl)		; $6d8c
	ldh (<hFF8F),a	; $6d8d
	inc l			; $6d8f
	ld a,(hl)		; $6d90
	ldh (<hFF8E),a	; $6d91
	sub c			; $6d93
	add $02			; $6d94
	cp $05			; $6d96
	jr nc,_label_11_322	; $6d98
	ldh a,(<hFF8F)	; $6d9a
	sub b			; $6d9c
	add $02			; $6d9d
	cp $05			; $6d9f
	jr nc,_label_11_322	; $6da1
	ld bc,$0502		; $6da3
	call objectCreateInteraction		; $6da6
	ret nz			; $6da9
	ld e,$d8		; $6daa
	ld a,$40		; $6dac
	ld (de),a		; $6dae
	inc e			; $6daf
	ld a,h			; $6db0
	ld (de),a		; $6db1
	ld e,$c4		; $6db2
	ld a,$02		; $6db4
	ld (de),a		; $6db6
	jp objectSetInvisible		; $6db7
_label_11_322:
	call objectGetRelativeAngleWithTempVars		; $6dba
	ld e,$c9		; $6dbd
	ld (de),a		; $6dbf
	call objectApplySpeed		; $6dc0
	jp partAnimate		; $6dc3
	ld a,$21		; $6dc6
	call objectGetRelatedObject2Var		; $6dc8
	bit 7,(hl)		; $6dcb
	ret z			; $6dcd
	ld b,$05		; $6dce
	call checkBPartSlotsAvailable		; $6dd0
	ret nz			; $6dd3
	ld c,$05		; $6dd4
_label_11_323:
	ld a,c			; $6dd6
	dec a			; $6dd7
	ld hl,$6df8		; $6dd8
	rst_addAToHl			; $6ddb
	ld b,(hl)		; $6ddc
	ld e,$02		; $6ddd
	call $6d22		; $6ddf
	dec c			; $6de2
	jr nz,_label_11_323	; $6de3
	ld h,d			; $6de5
	ld l,$c4		; $6de6
	inc (hl)		; $6de8
	ld l,$c9		; $6de9
	ld (hl),$1d		; $6deb
	call $6e5d		; $6ded
	ld a,$01		; $6df0
	call partSetAnimation		; $6df2
	jp objectSetVisible82		; $6df5
	inc bc			; $6df8
	ld ($130d),sp		; $6df9
	jr $1a			; $6dfc
	or a			; $6dfe
	jr z,_label_11_325	; $6dff
	call _partDecCounter1IfNonzero		; $6e01
	jp z,$6e4a		; $6e04
	inc l			; $6e07
	dec (hl)		; $6e08
	jr nz,_label_11_324	; $6e09
	ld (hl),$07		; $6e0b
	call objectGetAngleTowardEnemyTarget		; $6e0d
	call objectNudgeAngleTowards		; $6e10
_label_11_324:
	call objectApplySpeed		; $6e13
	jp partAnimate		; $6e16
_label_11_325:
	call $6e50		; $6e19
	ld l,$c6		; $6e1c
	ld (hl),$f0		; $6e1e
	inc l			; $6e20
	ld (hl),$07		; $6e21
	ld l,$db		; $6e23
	ld a,$02		; $6e25
	ldi (hl),a		; $6e27
	ld (hl),a		; $6e28
	call objectGetAngleTowardEnemyTarget		; $6e29
	ld e,$c9		; $6e2c
	ld (de),a		; $6e2e
	ld a,$29		; $6e2f
	call objectGetRelatedObject1Var		; $6e31
	ld a,(hl)		; $6e34
	ld b,$1e		; $6e35
	cp $10			; $6e37
	jr nc,_label_11_326	; $6e39
	ld b,$2d		; $6e3b
	cp $0a			; $6e3d
	jr nc,_label_11_326	; $6e3f
	ld b,$3c		; $6e41
_label_11_326:
	ld e,$d0		; $6e43
	ld a,b			; $6e45
	ld (de),a		; $6e46
	jp objectSetVisible80		; $6e47
	call objectCreatePuff		; $6e4a
	jp partDelete		; $6e4d
	ld h,d			; $6e50
	ld l,e			; $6e51
	inc (hl)		; $6e52
	ld l,$cf		; $6e53
	ld a,(hl)		; $6e55
	ld (hl),$00		; $6e56
	ld l,$cb		; $6e58
	add (hl)		; $6e5a
	ld (hl),a		; $6e5b
	ret			; $6e5c
	ld a,$29		; $6e5d
	call objectGetRelatedObject1Var		; $6e5f
	ld a,(hl)		; $6e62
	ld b,$3c		; $6e63
	cp $10			; $6e65
	jr nc,_label_11_327	; $6e67
	ld b,$5a		; $6e69
	cp $0a			; $6e6b
	jr nc,_label_11_327	; $6e6d
	ld b,$78		; $6e6f
_label_11_327:
	ld e,$d0		; $6e71
	ld a,b			; $6e73
	ld (de),a		; $6e74
	ret			; $6e75

;;
; @addr{6e76}
partCode3b:
	ld e,$c2		; $6e76
	ld a,(de)		; $6e78
	ld e,$c4		; $6e79
	or a			; $6e7b
	jr z,_label_11_328	; $6e7c
	jp $6ef3		; $6e7e
_label_11_328:
	ld a,(de)		; $6e81
	rst_jumpTable			; $6e82
.dw $6e89
.dw $6eae
.dw $6ed3
	ld h,d			; $6e89
	ld l,e			; $6e8a
	inc (hl)		; $6e8b
	ld l,$d5		; $6e8c
	ld (hl),$02		; $6e8e
	ld l,$cb		; $6e90
	ldh a,(<hCameraY)	; $6e92
	ldi (hl),a		; $6e94
	inc l			; $6e95
	ld a,(hl)		; $6e96
	or a			; $6e97
	jr nz,_label_11_329	; $6e98
	call getRandomNumber_noPreserveVars		; $6e9a
	and $7c			; $6e9d
	ld b,a			; $6e9f
	ldh a,(<hCameraX)	; $6ea0
	add b			; $6ea2
	ld e,$cd		; $6ea3
	ld (de),a		; $6ea5
_label_11_329:
	call objectSetVisible82		; $6ea6
	ld a,SND_FALLINHOLE		; $6ea9
	jp playSound		; $6eab
	ld a,$20		; $6eae
	call objectUpdateSpeedZ_sidescroll		; $6eb0
	jr c,_label_11_330	; $6eb3
	ld a,(de)		; $6eb5
	cp $b0			; $6eb6
	jr c,_label_11_331	; $6eb8
	jp partDelete		; $6eba
_label_11_330:
	ld h,d			; $6ebd
	ld l,$c4		; $6ebe
	inc (hl)		; $6ec0
	ld l,$db		; $6ec1
	ld a,$0b		; $6ec3
	ldi (hl),a		; $6ec5
	ldi (hl),a		; $6ec6
	ld (hl),$02		; $6ec7
	ld a,$01		; $6ec9
	call partSetAnimation		; $6ecb
	ld a,SND_BREAK_ROCK		; $6ece
	jp playSound		; $6ed0
	ld e,$e1		; $6ed3
	ld a,(de)		; $6ed5
	bit 7,a			; $6ed6
	jp nz,partDelete		; $6ed8
	ld hl,$6ee9		; $6edb
	rst_addAToHl			; $6ede
	ld e,$e6		; $6edf
	ldi a,(hl)		; $6ee1
	ld (de),a		; $6ee2
	inc e			; $6ee3
	ld a,(hl)		; $6ee4
	ld (de),a		; $6ee5
_label_11_331:
	jp partAnimate		; $6ee6
	inc b			; $6ee9
	add hl,bc		; $6eea
	ld b,$0b		; $6eeb
	add hl,bc		; $6eed
	inc c			; $6eee
	ld a,(bc)		; $6eef
	dec c			; $6ef0
	dec bc			; $6ef1
	ld c,$1a		; $6ef2
	rst_jumpTable			; $6ef4
.dw $6efb
.dw $6f23
.dw $6ed3
	ld h,d			; $6efb
	ld l,e			; $6efc
	inc (hl)		; $6efd
	ld l,$d5		; $6efe
	ld (hl),$02		; $6f00
	ld l,$cb		; $6f02
	ldi a,(hl)		; $6f04
	inc l			; $6f05
	or (hl)			; $6f06
	jr nz,_label_11_332	; $6f07
	call getRandomNumber_noPreserveVars		; $6f09
	and $7c			; $6f0c
	ld b,a			; $6f0e
	ldh a,(<hRng2)	; $6f0f
	and $7c			; $6f11
	ld c,a			; $6f13
	ld e,$cb		; $6f14
	ldh a,(<hCameraY)	; $6f16
	add b			; $6f18
	ld (de),a		; $6f19
	ld e,$cd		; $6f1a
	ldh a,(<hCameraX)	; $6f1c
	add c			; $6f1e
	ld (de),a		; $6f1f
_label_11_332:
	jp objectSetVisiblec2		; $6f20
	ld c,$20		; $6f23
	call objectUpdateSpeedZ_paramC		; $6f25
	jr nz,_label_11_331	; $6f28
	jr _label_11_330		; $6f2a

;;
; @addr{6f2c}
partCode3c:
	jp nz,partDelete		; $6f2c
	ld e,$c4		; $6f2f
	ld a,(de)		; $6f31
	or a			; $6f32
	jr z,_label_11_334	; $6f33
	call _partCommon_checkOutOfBounds		; $6f35
	jp z,partDelete		; $6f38
	call _partDecCounter1IfNonzero		; $6f3b
	jr nz,_label_11_333	; $6f3e
	inc l			; $6f40
	ld e,$f0		; $6f41
	ld a,(de)		; $6f43
	inc a			; $6f44
	and $01			; $6f45
	ld (de),a		; $6f47
	add (hl)		; $6f48
	ldd (hl),a		; $6f49
	ld (hl),a		; $6f4a
	ld l,$c9		; $6f4b
	ld e,$c2		; $6f4d
	ld a,(de)		; $6f4f
	add (hl)		; $6f50
	and $1f			; $6f51
	ld (hl),a		; $6f53
_label_11_333:
	call objectApplySpeed		; $6f54
	jp partAnimate		; $6f57
_label_11_334:
	ld h,d			; $6f5a
	ld l,e			; $6f5b
	inc (hl)		; $6f5c
	ld l,$c6		; $6f5d
	ld a,$02		; $6f5f
	ldi (hl),a		; $6f61
	ld (hl),a		; $6f62
	ld l,$d0		; $6f63
	ld (hl),$64		; $6f65
	call objectSetVisible82		; $6f67
	ld a,SND_BEAM		; $6f6a
	jp playSound		; $6f6c


; ==============================================================================
; PARTID_BLUE_STALFOS_PROJECTILE
;
; Variables:
;   var03: 0 for reflectable ball type, 1 otherwise
;   relatedObj1: Instance of ENEMYID_BLUE_STALFOS
; ==============================================================================
partCode3d:
	jr z,@normalStatus	; $6f6f

	ld h,d			; $6f71
	ld l,Part.subid		; $6f72
	ldi a,(hl)		; $6f74
	or (hl)			; $6f75
	jr nz,@normalStatus	; $6f76

	; Check if hit Link
	ld l,Part.var2a		; $6f78
	ld a,(hl)		; $6f7a
	res 7,a			; $6f7b
	or a ; ITEMCOLLISION_LINK
	jp z,_blueStalfosProjectile_hitLink		; $6f7e

	; Check if hit Link's sword
	sub ITEMCOLLISION_L1_SWORD			; $6f81
	cp ITEMCOLLISION_SWORDSPIN - ITEMCOLLISION_L1_SWORD + 1			; $6f83
	jr nc,@normalStatus	; $6f85

	; Reflect the ball if not already reflected
	ld l,Part.state		; $6f87
	ld a,(hl)		; $6f89
	cp $04			; $6f8a
	jr nc,@normalStatus	; $6f8c

	ld (hl),$04		; $6f8e
	ld l,Part.speed		; $6f90
	ld (hl),SPEED_200		; $6f92
	ld a,SND_UNKNOWN3		; $6f94
	call playSound		; $6f96

@normalStatus:
	ld e,Part.subid		; $6f99
	ld a,(de)		; $6f9b
	rst_jumpTable			; $6f9c
	.dw _blueStalfosProjectile_subid0
	.dw _blueStalfosProjectile_subid1


_blueStalfosProjectile_subid0:
	ld e,Part.state		; $6fa1
	ld a,(de)		; $6fa3
	rst_jumpTable			; $6fa4
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3
	.dw @state4
	.dw @state5
	.dw @state6

; Initialization, deciding which ball type this should be
@state0:
	ld h,d			; $6fb3
	ld l,e			; $6fb4
	inc (hl) ; [state]

	ld l,Part.counter1		; $6fb6
	ld (hl),40		; $6fb8

	ld l,Part.yh		; $6fba
	ld a,(hl)		; $6fbc
	sub $18			; $6fbd
	ld (hl),a		; $6fbf

	ld l,Part.speed		; $6fc0
	ld (hl),SPEED_180		; $6fc2

	push hl			; $6fc4
	ld a,Object.var32		; $6fc5
	call objectGetRelatedObject1Var		; $6fc7
	ld a,(hl)		; $6fca
	inc a			; $6fcb
	and $07			; $6fcc
	ld (hl),a		; $6fce

	ld hl,@ballPatterns		; $6fcf
	call checkFlag		; $6fd2
	pop hl			; $6fd5
	jr z,++			; $6fd6

	; Non-reflectable ball
	ld (hl),SPEED_200		; $6fd8
	ld l,Part.enemyCollisionMode		; $6fda
	ld (hl),ENEMYCOLLISION_PODOBOO		; $6fdc
	ld l,Part.var03		; $6fde
	inc (hl)		; $6fe0
++
	ld a,SND_CHARGE		; $6fe1
	call playSound		; $6fe3
	jp objectSetVisible81		; $6fe6

; A bit being 0 means the ball will be reflectable. Cycles through the next bit every time
; a projectile is created.
@ballPatterns:
	.db %10101101


; Charging
@state1:
	call _partDecCounter1IfNonzero		; $6fea
	jr nz,@animate	; $6fed

	ld (hl),40 ; [counter1]
	inc l			; $6ff1
	inc (hl) ; [counter2]
	ld a,(hl)		; $6ff3
	cp $03			; $6ff4
	jp c,partSetAnimation		; $6ff6

	; Done charging
	ld (hl),20 ; [counter2]
	dec l			; $6ffb
	ld (hl),$00 ; [counter1]

	ld l,e			; $6ffe
	inc (hl) ; [state]

	ld l,Part.collisionType		; $7000
	set 7,(hl)		; $7002

	call objectGetAngleTowardEnemyTarget		; $7004
	ld e,Part.angle		; $7007
	ld (de),a		; $7009

	ld e,Part.var03		; $700a
	ld a,(de)		; $700c
	add $02			; $700d
	call partSetAnimation		; $700f
	ld a,SND_BEAM1		; $7012
	call playSound		; $7014
	jr @animate		; $7017


; Ball is moving (either version)
@state2:
	ld h,d			; $7019
	ld l,Part.counter2		; $701a
	dec (hl)		; $701c
	jr nz,+			; $701d
	ld l,e			; $701f
	inc (hl) ; [state]
+
	call _blueStalfosProjectile_checkShouldExplode		; $7021
	jr _blueStalfosProjectile_applySpeed		; $7024


; Ball is moving (baby ball only)
@state3:
	call _blueStalfosProjectile_checkShouldExplode		; $7026
	jr _blueStalfosProjectile_applySpeedAndDeleteIfOffScreen		; $7029


; Ball was just reflected (baby ball only)
@state4:
	ld h,d			; $702b
	ld l,e			; $702c
	inc (hl) ; [state]

	call objectGetAngleTowardEnemyTarget		; $702e
	xor $10			; $7031
	ld e,Part.angle		; $7033
	ld (de),a		; $7035
@animate:
	jp partAnimate		; $7036


; Ball is moving after being reflected (baby ball only)
@state5:
	call _blueStalfosProjectile_checkCollidedWithStalfos		; $7039
	jp c,partDelete		; $703c
	jr _blueStalfosProjectile_applySpeedAndDeleteIfOffScreen		; $703f


; Splits into 6 smaller projectiles (subid 1)
@state6:
	ld b,$06		; $7041
	call checkBPartSlotsAvailable		; $7043
	ret nz			; $7046
	call _blueStalfosProjectile_explode		; $7047
	ld a,SND_BEAM		; $704a
	call playSound		; $704c
	jp partDelete		; $704f


; Smaller projectile created from the explosion of the larger one
_blueStalfosProjectile_subid1:
	ld e,Part.state		; $7052
	ld a,(de)		; $7054
	or a			; $7055
	jr z,_blueStalfosProjectile_subid1_uninitialized	; $7056

_blueStalfosProjectile_applySpeedAndDeleteIfOffScreen:
	call _partCommon_checkOutOfBounds		; $7058
	jp z,partDelete		; $705b

_blueStalfosProjectile_applySpeed:
	call objectApplySpeed		; $705e
	jp partAnimate		; $7061


_blueStalfosProjectile_subid1_uninitialized:
	ld h,d			; $7064
	ld l,e			; $7065
	inc (hl) ; [state]

	ld l,Part.collisionType		; $7067
	set 7,(hl)		; $7069
	ld l,Part.enemyCollisionMode		; $706b
	ld (hl),ENEMYCOLLISION_PODOBOO		; $706d

	ld l,Part.speed		; $706f
	ld (hl),SPEED_1c0		; $7071

	ld l,Part.damage		; $7073
	ld (hl),-4		; $7075

	ld l,Part.collisionRadiusY		; $7077
	ld a,$02		; $7079
	ldi (hl),a		; $707b
	ld (hl),a		; $707c

	add a ; a = 4
	call partSetAnimation		; $707e
	jp objectSetVisible81		; $7081


;;
; Explodes the projectile (sets state to 6) if it's the correct type and is close to Link.
; Returns from caller if so.
; @addr{7084}
_blueStalfosProjectile_checkShouldExplode:
	ld a,(wFrameCounter)		; $7084
	and $07			; $7087
	ret nz			; $7089

	call _partDecCounter1IfNonzero		; $708a
	ret nz			; $708d

	ld c,$28		; $708e
	call objectCheckLinkWithinDistance		; $7090
	ret nc			; $7093

	ld h,d			; $7094
	ld l,Part.counter1		; $7095
	dec (hl)		; $7097
	ld e,Part.var03		; $7098
	ld a,(de)		; $709a
	or a			; $709b
	ret z			; $709c

	pop bc ; Discard return address

	ld l,Part.collisionType		; $709e
	res 7,(hl)		; $70a0
	ld l,Part.state		; $70a2
	ld (hl),$06		; $70a4
	ret			; $70a6


;;
; @param[out]	cflag	c on collision
; @addr{70a7}
_blueStalfosProjectile_checkCollidedWithStalfos:
	ld a,Object.enabled		; $70a7
	call objectGetRelatedObject1Var		; $70a9
	call checkObjectsCollided		; $70ac
	ret nc			; $70af

	ld l,Enemy.invincibilityCounter		; $70b0
	ld (hl),30		; $70b2
	ld l,Enemy.state		; $70b4
	ld (hl),$14		; $70b6
	ret			; $70b8


;;
; Explodes into six parts
; @addr{70b9}
_blueStalfosProjectile_explode:
	ld c,$06		; $70b9
@next:
	call getFreePartSlot		; $70bb
	ld (hl),PARTID_BLUE_STALFOS_PROJECTILE		; $70be
	inc l			; $70c0
	inc (hl) ; [subid] = 1

	call objectCopyPosition		; $70c2

	; Copy ENEMYID_BLUE_STALFOS reference to new projectile
	ld l,Part.relatedObj1		; $70c5
	ld e,l			; $70c7
	ld a,(de)		; $70c8
	ldi (hl),a		; $70c9
	ld e,l			; $70ca
	ld a,(de)		; $70cb
	ld (hl),a		; $70cc

	; Set angle
	ld b,h			; $70cd
	ld a,c			; $70ce
	ld hl,@angleVals		; $70cf
	rst_addAToHl			; $70d2
	ld a,(hl)		; $70d3
	ld h,b			; $70d4
	ld l,Part.angle		; $70d5
	ld (hl),a		; $70d7

	dec c			; $70d8
	jr nz,@next	; $70d9
	ret			; $70db

@angleVals:
	.db $00 $00 $05 $0b $10 $15 $1b

_blueStalfosProjectile_hitLink:
	; [blueStalfos.state] = $10
	ld a,Object.state		; $70e3
	call objectGetRelatedObject1Var		; $70e5
	ld (hl),$10		; $70e8

	jp partDelete		; $70ea

;;
; @addr{70ed}
partCode3e:
	ld e,$c4		; $70ed
	ld a,(de)		; $70ef
	rst_jumpTable			; $70f0
.dw $70f9
.dw $7110
.dw $7129
.dw $714b
	ld h,d			; $70f9
	ld l,e			; $70fa
	inc (hl)		; $70fb
	ld e,$f0		; $70fc
	ld hl,$d081		; $70fe
_label_11_343:
	ld a,(hl)		; $7101
	cp $54			; $7102
	jr nz,_label_11_344	; $7104
	ld a,h			; $7106
	ld (de),a		; $7107
	inc e			; $7108
_label_11_344:
	inc h			; $7109
	ld a,h			; $710a
	cp $e0			; $710b
	jr c,_label_11_343	; $710d
	ret			; $710f
	ld hl,$d700		; $7110
_label_11_345:
	ld l,$24		; $7113
	ld a,(hl)		; $7115
	cp $98			; $7116
	jr z,_label_11_346	; $7118
	inc h			; $711a
	ld a,h			; $711b
	cp $dc			; $711c
	jr c,_label_11_345	; $711e
	ret			; $7120
_label_11_346:
	ld a,$02		; $7121
	ld (de),a		; $7123
	ld e,$d9		; $7124
	ld a,h			; $7126
	ld (de),a		; $7127
	ret			; $7128
	ld h,d			; $7129
	ld l,$c4		; $712a
	inc (hl)		; $712c
	ld l,$c6		; $712d
	ld (hl),$3c		; $712f
	ld l,$d9		; $7131
	ld b,(hl)		; $7133
	ld e,$f0		; $7134
_label_11_347:
	ld a,(de)		; $7136
	or a			; $7137
	ret z			; $7138
	ld h,a			; $7139
	ld l,$ba		; $713a
	ld (hl),$ff		; $713c
	ld l,$98		; $713e
	ld (hl),$00		; $7140
	inc l			; $7142
	ld (hl),b		; $7143
	inc e			; $7144
	ld a,e			; $7145
	cp $f4			; $7146
	jr c,_label_11_347	; $7148
	ret			; $714a
	call _partDecCounter1IfNonzero		; $714b
	ret nz			; $714e
	ld l,e			; $714f
	ld (hl),$01		; $7150
	ret			; $7152


; ==============================================================================
; PARTID_KING_MOBLIN_BOMB
;
; Variables:
;   relatedObj1: Instance of ENEMYID_KING_MOBLIN
;   var30: If nonzero, damage has been applied to Link
;   var31: Number of red flashes before it explodes
; ==============================================================================
partCode3f:
	ld e,Part.state		; $7153
	ld a,(de)		; $7155
	rst_jumpTable			; $7156
	.dw _kingMoblinBomb_state0
	.dw _kingMoblinBomb_state1
	.dw _kingMoblinBomb_state2
	.dw _kingMoblinBomb_state3
	.dw _kingMoblinBomb_state4
	.dw _kingMoblinBomb_state5
	.dw _kingMoblinBomb_state6
	.dw _kingMoblinBomb_state7
	.dw _kingMoblinBomb_state8


_kingMoblinBomb_state0:
	ld h,d			; $7169
	ld l,e			; $716a
	inc (hl) ; [state] = 1

	ld l,Part.speed		; $716c
	ld (hl),SPEED_220		; $716e

	ld l,Part.yh		; $7170
	ld a,(hl)		; $7172
	add $08			; $7173
	ld (hl),a		; $7175

	call getRandomNumber_noPreserveVars		; $7176
	and $03			; $7179
	ld hl,@counter1Values		; $717b
	rst_addAToHl			; $717e
	ld e,Part.counter1		; $717f
	ld a,(hl)		; $7181
	ld (de),a		; $7182

	ld a,Object.health		; $7183
	call objectGetRelatedObject1Var		; $7185
	ld a,(hl)		; $7188
	dec a			; $7189
	ld hl,@numRedFlashes		; $718a
	rst_addAToHl			; $718d
	ld e,Part.var31		; $718e
	ld a,(hl)		; $7190
	ld (de),a		; $7191

	jp objectSetVisiblec2		; $7192

@counter1Values: ; One of these is chosen randomly.
	.db 120, 135, 160, 180

@numRedFlashes: ; Indexed by [kingMoblin.health] - 1.
	.db $06 $07 $08 $09 $0a $0c


; Bomb isn't doing anything except waiting to explode.
; This state's code is called by other states (2-4).
_kingMoblinBomb_state1:
	ld e,Part.counter1		; $719f
	ld a,(de)		; $71a1
	or a			; $71a2
	jr z,++			; $71a3
	ld a,(wFrameCounter)		; $71a5
	rrca			; $71a8
	ret c			; $71a9
++
	call _partDecCounter1IfNonzero		; $71aa
	ret nz			; $71ad

	ld l,Part.animParameter		; $71ae
	bit 0,(hl)		; $71b0
	jr z,@animate	; $71b2

	ld (hl),$00		; $71b4
	ld l,Part.counter2		; $71b6
	inc (hl)		; $71b8

	ld a,(hl)		; $71b9
	ld l,Part.var31		; $71ba
	cp (hl)			; $71bc
	jr nc,_kingMoblinBomb_explode	; $71bd

@animate:
	jp partAnimate		; $71bf

	; Unused code snippet?
	or d			; $71c2
	ret			; $71c3

_kingMoblinBomb_explode:
	ld l,Part.state		; $71c4
	ld (hl),$05		; $71c6

	ld l,Part.oamFlagsBackup		; $71c8
	ld a,$0a		; $71ca
	ldi (hl),a		; $71cc
	ldi (hl),a		; $71cd
	ld (hl),$0c ; [oamTileIndexBase]

	ld a,$01		; $71d0
	call partSetAnimation		; $71d2
	call objectSetVisible82		; $71d5
	ld a,SND_EXPLOSION		; $71d8
	call playSound		; $71da
	xor a			; $71dd
	ret			; $71de


; Being held by Link
_kingMoblinBomb_state2:
	inc e			; $71df
	ld a,(de)		; $71e0
	rst_jumpTable			; $71e1
	.dw @justGrabbed
	.dw @beingHeld
	.dw @released
	.dw @atRest

@justGrabbed:
	ld a,$01		; $71ea
	ld (de),a ; [state2] = 1
	xor a			; $71ed
	ld (wLinkGrabState2),a		; $71ee
	call objectSetVisiblec1		; $71f1

@beingHeld:
	call _kingMoblinBomb_state1		; $71f4
	ret nz			; $71f7
	jp dropLinkHeldItem		; $71f8

@released:
	; Drastically reduce speed when Y < $30 (on moblin's platform), Z = 0,
	; and subid = 0.
	ld e,Part.yh		; $71fb
	ld a,(de)		; $71fd
	cp $30			; $71fe
	jr nc,@beingHeld	; $7200

	ld h,d			; $7202
	ld l,Part.zh		; $7203
	ld e,Part.subid		; $7205
	ld a,(de)		; $7207
	or (hl)			; $7208
	jr nz,@beingHeld	; $7209

	; Reduce speed
	ld hl,w1ReservedItemC.speedZ+1		; $720b
	sra (hl)		; $720e
	dec l			; $7210
	rr (hl)			; $7211
	ld l,Item.speed		; $7213
	ld (hl),SPEED_40		; $7215

	jp _kingMoblinBomb_state1		; $7217

@atRest:
	ld e,Part.state		; $721a
	ld a,$04		; $721c
	ld (de),a		; $721e

	call objectSetVisiblec2		; $721f
	jr _kingMoblinBomb_state4		; $7222


; Being thrown. (King moblin sets the state to this.)
_kingMoblinBomb_state3:
	call _kingMoblinBomb_state1		; $7224
	ret z			; $7227

	ld c,$20		; $7228
	call objectUpdateSpeedZAndBounce		; $722a
	jr c,@doneBouncing	; $722d

	ld a,SND_BOMB_LAND		; $722f
	call z,playSound		; $7231
	jp objectApplySpeed		; $7234

@doneBouncing:
	ld a,SND_BOMB_LAND		; $7237
	call playSound		; $7239
	ld h,d			; $723c
	ld l,Part.state		; $723d
	inc (hl) ; [state] = 4


; Waiting to be picked up (by link or king moblin)
_kingMoblinBomb_state4:
	call _kingMoblinBomb_state1		; $7240
	ret z			; $7243
	jp objectAddToGrabbableObjectBuffer		; $7244


; Exploding
_kingMoblinBomb_state5:
	ld h,d			; $7247
	ld l,Part.animParameter		; $7248
	ld a,(hl)		; $724a
	inc a			; $724b
	jp z,partDelete		; $724c

	dec a			; $724f
	jr z,@animate	; $7250

	ld l,Part.collisionRadiusY		; $7252
	ldi (hl),a		; $7254
	ld (hl),a		; $7255
	call _kingMoblinBomb_checkCollisionWithLink		; $7256
	call _kingMoblinBomb_checkCollisionWithKingMoblin		; $7259
@animate:
	jp partAnimate		; $725c


; States 6-8 might be unused? Bomb is chucked way upward, then explodes on the ground.
_kingMoblinBomb_state6:
	ld bc,-$240		; $725f
	call objectSetSpeedZ		; $7262

	ld l,e			; $7265
	inc (hl) ; [state] = 7

	ld l,Part.speed		; $7267
	ld (hl),SPEED_c0		; $7269

	ld l,Part.counter1		; $726b
	ld (hl),$07		; $726d

	; Decide angle to throw at based on king moblin's position
	ld a,Object.xh		; $726f
	call objectGetRelatedObject1Var		; $7271
	ld a,(hl)		; $7274
	cp $50			; $7275
	ld a,$07		; $7277
	jr c,+			; $7279
	ld a,$19		; $727b
+
	ld e,Part.angle		; $727d
	ld (de),a		; $727f
	ret			; $7280


_kingMoblinBomb_state7:
	call _partDecCounter1IfNonzero		; $7281
	ret nz			; $7284

	ld l,e			; $7285
	inc (hl) ; [state] = 8


_kingMoblinBomb_state8:
	ld c,$20		; $7287
	call objectUpdateSpeedZAndBounce		; $7289
	jp nc,objectApplySpeed		; $728c

	ld h,d			; $728f
	jp _kingMoblinBomb_explode		; $7290

;;
; @addr{7293}
_kingMoblinBomb_checkCollisionWithLink:
	ld e,Part.var30		; $7293
	ld a,(de)		; $7295
	or a			; $7296
	ret nz			; $7297

	call checkLinkVulnerable		; $7298
	ret nc			; $729b

	call objectCheckCollidedWithLink_ignoreZ		; $729c
	ret nc			; $729f

	call objectGetAngleTowardEnemyTarget		; $72a0

	ld hl,w1Link.knockbackCounter		; $72a3
	ld (hl),$10		; $72a6
	dec l			; $72a8
	ldd (hl),a ; [w1Link.knockbackAngle]
	ld (hl),20 ; [w1Link.invincibilityCounter]
	dec l			; $72ac
	ld (hl),$01 ; [w1Link.var2a] (TODO: what does this mean?)

	ld e,Part.damage		; $72af
	ld l,<w1Link.damageToApply		; $72b1
	ld a,(de)		; $72b3
	ld (hl),a		; $72b4

	ld e,Part.var30		; $72b5
	ld a,$01		; $72b7
	ld (de),a		; $72b9
	ret			; $72ba

;;
; @addr{72bb}
_kingMoblinBomb_checkCollisionWithKingMoblin:
	ld e,Part.relatedObj1+1		; $72bb
	ld a,(de)		; $72bd
	or a			; $72be
	ret z			; $72bf

	; Check king moblin's collisions are enabled
	ld a,Object.collisionType		; $72c0
	call objectGetRelatedObject1Var		; $72c2
	bit 7,(hl)		; $72c5
	ret z			; $72c7

	ld l,Enemy.invincibilityCounter		; $72c8
	ld a,(hl)		; $72ca
	or a			; $72cb
	ret nz			; $72cc

	call checkObjectsCollided		; $72cd
	ret nc			; $72d0

	ld l,Enemy.var2a		; $72d1
	ld (hl),$80|ITEMCOLLISION_BOMB		; $72d3
	ld l,Enemy.invincibilityCounter		; $72d5
	ld (hl),30		; $72d7

	ld l,Enemy.health		; $72d9
	dec (hl)		; $72db
	ret			; $72dc

;;
; @addr{72dd}
partCode40:
	ld a,$01		; $72dd
	call objectGetRelatedObject1Var		; $72df
	ld a,(hl)		; $72e2
	cp $01			; $72e3
	jp nz,partDelete		; $72e5
	ld e,$c4		; $72e8
	ld a,(de)		; $72ea
	or a			; $72eb
	jr z,_label_11_356	; $72ec
	ld a,$20		; $72ee
	call objectUpdateSpeedZ_sidescroll		; $72f0
	jp c,partDelete		; $72f3
	call objectApplySpeed		; $72f6
	ld a,$00		; $72f9
	call objectGetRelatedObject1Var		; $72fb
	jp objectCopyPosition		; $72fe
_label_11_356:
	ld h,d			; $7301
	ld l,e			; $7302
	inc (hl)		; $7303
	call getRandomNumber_noPreserveVars		; $7304
	ld b,a			; $7307
	and $03			; $7308
	ld hl,$732c		; $730a
	rst_addAToHl			; $730d
	ld e,$d0		; $730e
	ld a,(hl)		; $7310
	ld (de),a		; $7311
	ld a,b			; $7312
	and $60			; $7313
	swap a			; $7315
	ld hl,$7330		; $7317
	rst_addAToHl			; $731a
	ld e,$d4		; $731b
	ldi a,(hl)		; $731d
	ld (de),a		; $731e
	inc e			; $731f
	ld a,(hl)		; $7320
	ld (de),a		; $7321
	ldh a,(<hRng2)	; $7322
	and $10			; $7324
	add $08			; $7326
	ld e,$c9		; $7328
	ld (de),a		; $732a
	ret			; $732b
	inc d			; $732c
	add hl,de		; $732d
	ld e,$23		; $732e
	nop			; $7330
.DB $fd				; $7331
	ld ($ff00+$fc),a	; $7332
	ret nz			; $7334
.DB $fc				; $7335
	and b			; $7336
.DB $fc				; $7337


; ==============================================================================
; PARTID_SHADOW_HAG_SHADOW
; ==============================================================================
partCode41:
	ld e,Part.state		; $7338
	ld a,(de)		; $733a
	rst_jumpTable			; $733b
	.dw @state0
	.dw @state1
	.dw @state2
	.dw partDelete

; Initialization
@state0:
	ld h,d			; $7344
	ld l,e			; $7345
	inc (hl) ; [state]

	ld l,Part.counter1		; $7347
	ld (hl),$08		; $7349

	ld l,Part.speed		; $734b
	ld (hl),SPEED_100		; $734d

	ld e,Part.angle		; $734f
	ld a,(de)		; $7351
	ld hl,@angles		; $7352
	rst_addAToHl			; $7355
	ld a,(hl)		; $7356
	ld (de),a		; $7357

	call objectSetVisible82		; $7358
	ld a,$01		; $735b
	jp partSetAnimation		; $735d

@angles:
	.db $04 $0c $14 $1c


; Shadows chasing Link
@state1:
	; If [shadowHag.counter1] == $ff, the shadows should converge to her position.
	ld a,Object.counter1		; $7364
	call objectGetRelatedObject1Var		; $7366
	ld a,(hl)		; $7369
	inc a			; $736a
	jr nz,++		; $736b

	ld e,Part.state		; $736d
	ld a,$02		; $736f
	ld (de),a		; $7371
++
	call _partDecCounter1IfNonzero		; $7372
	jr nz,++		; $7375

	ld (hl),$08		; $7377
	call objectGetAngleTowardEnemyTarget		; $7379
	call objectNudgeAngleTowards		; $737c
++
	jp objectApplySpeed		; $737f


; Shadows converging back to shadow hag
@state2:
	ld a,Object.yh		; $7382
	call objectGetRelatedObject1Var		; $7384
	ld b,(hl)		; $7387
	ld l,Enemy.xh		; $7388
	ld c,(hl)		; $738a

	ld e,Part.yh		; $738b
	ld a,(de)		; $738d
	ldh (<hFF8F),a	; $738e
	ld e,Part.xh		; $7390
	ld a,(de)		; $7392
	ldh (<hFF8E),a	; $7393

	; Check if already close enough
	sub c			; $7395
	add $04			; $7396
	cp $09			; $7398
	jr nc,@updateAngleAndApplySpeed	; $739a
	ldh a,(<hFF8F)	; $739c
	sub b			; $739e
	add $04			; $739f
	cp $09			; $73a1
	jr nc,@updateAngleAndApplySpeed	; $73a3

	; We're close enough.

	; [shadowHag.counter2]--
	ld l,Enemy.counter2		; $73a5
	dec (hl)		; $73a7
	; [shadowHag.visible] = true
	ld l,Enemy.visible		; $73a8
	set 7,(hl)		; $73aa

	ld e,Part.state		; $73ac
	ld a,$03		; $73ae
	ld (de),a		; $73b0

@updateAngleAndApplySpeed:
	call objectGetRelativeAngleWithTempVars		; $73b1
	ld e,Part.angle		; $73b4
	ld (de),a		; $73b6
	jp objectApplySpeed		; $73b7

;;
; @addr{73ba}
partCode42:
	jp nz,partDelete		; $73ba
	ld e,$c4		; $73bd
	ld a,(de)		; $73bf
	rst_jumpTable			; $73c0
.dw $73c7
.dw $742c
.dw $7436
	ld h,d			; $73c7
	ld l,e			; $73c8
	inc (hl)		; $73c9
	ld l,$c6		; $73ca
	ld (hl),$08		; $73cc
	ld l,$d0		; $73ce
	ld (hl),$3c		; $73d0
	ld e,$cb		; $73d2
	ld l,$cf		; $73d4
	ld a,(de)		; $73d6
	add (hl)		; $73d7
	ld (de),a		; $73d8
	ld (hl),$00		; $73d9
	ld e,$c2		; $73db
	ld a,(de)		; $73dd
	ld bc,$7421		; $73de
	call addAToBc		; $73e1
	ld l,$c9		; $73e4
	ld a,(bc)		; $73e6
	add (hl)		; $73e7
	and $1f			; $73e8
	ld (hl),a		; $73ea
	ld a,(de)		; $73eb
	or a			; $73ec
	jr nz,_label_11_361	; $73ed
	ld a,(hl)		; $73ef
	rrca			; $73f0
	rrca			; $73f1
	ld hl,$7424		; $73f2
	rst_addAToHl			; $73f5
	ld e,$cb		; $73f6
	ld a,(de)		; $73f8
	add (hl)		; $73f9
	ld (de),a		; $73fa
	ld e,$cd		; $73fb
	inc hl			; $73fd
	ld a,(de)		; $73fe
	add (hl)		; $73ff
	ld (de),a		; $7400
	ld b,$02		; $7401
_label_11_360:
	call getFreePartSlot		; $7403
	jr nz,_label_11_361	; $7406
	ld (hl),$42		; $7408
	inc l			; $740a
	ld (hl),b		; $740b
	ld l,$c9		; $740c
	ld e,l			; $740e
	ld a,(de)		; $740f
	ld (hl),a		; $7410
	call objectCopyPosition		; $7411
	dec b			; $7414
	jr nz,_label_11_360	; $7415
_label_11_361:
	ld e,$c9		; $7417
	ld a,(de)		; $7419
	or a			; $741a
	jp z,objectSetVisible82		; $741b
	jp objectSetVisible81		; $741e
	nop			; $7421
	ld (bc),a		; $7422
	cp $fc			; $7423
	nop			; $7425
	ld (bc),a		; $7426
	inc b			; $7427
	inc b			; $7428
	nop			; $7429
	ld (bc),a		; $742a
.DB $fc				; $742b
	call _partDecCounter1IfNonzero		; $742c
	jr nz,_label_11_362	; $742f
	ld l,e			; $7431
	inc (hl)		; $7432
	call objectSetVisible82		; $7433
_label_11_362:
	call partAnimate		; $7436
	call objectApplySpeed		; $7439
	call _partCommon_checkTileCollisionOrOutOfBounds		; $743c
	ret nc			; $743f
	jp partDelete		; $7440


; ==============================================================================
; PARTID_PLASMARINE_PROJECTILE
; ==============================================================================
partCode43:
	jr nz,@delete	; $7443

	ld a,Object.id		; $7445
	call objectGetRelatedObject1Var		; $7447
	ld a,(hl)		; $744a
	cp ENEMYID_PLASMARINE			; $744b
	jr nz,@delete	; $744d

	ld e,Part.state		; $744f
	ld a,(de)		; $7451
	or a			; $7452
	jr z,@state0	; $7453

@state1:
	; If projectile's color is different from plasmarine's color...
	ld l,Enemy.var32		; $7455
	ld e,Part.subid		; $7457
	ld a,(de)		; $7459
	cp (hl)			; $745a
	jr z,@noCollision		; $745b

	; Check for collision.
	call checkObjectsCollided		; $745d
	jr c,@collidedWithPlasmarine	; $7460

@noCollision:
	ld a,(wFrameCounter)		; $7462
	rrca			; $7465
	jr c,@updateMovement	; $7466

	call _partDecCounter1IfNonzero		; $7468
	jp z,partDelete		; $746b

	; Flicker visibility for 30 frames or less remaining
	ld a,(hl)		; $746e
	cp 30			; $746f
	jr nc,++		; $7471
	ld e,Part.visible		; $7473
	ld a,(de)		; $7475
	xor $80			; $7476
	ld (de),a		; $7478
++
	; Slowly home in on Link
	inc l			; $7479
	dec (hl) ; [this.counter2]--
	jr nz,@updateMovement	; $747b
	ld (hl),$10		; $747d
	call objectGetAngleTowardEnemyTarget		; $747f
	call objectNudgeAngleTowards		; $7482

@updateMovement:
	call objectApplySpeed		; $7485
	call _partCommon_checkOutOfBounds		; $7488
	jp nz,partAnimate		; $748b
	jr @delete		; $748e

@collidedWithPlasmarine:
	ld l,Enemy.invincibilityCounter		; $7490
	ld a,(hl)		; $7492
	or a			; $7493
	jr nz,@noCollision	; $7494

	ld (hl),24
	ld l,Enemy.health		; $7498
	dec (hl)		; $749a
	jr nz,++		; $749b

	; Plasmarine is dead
	ld l,Enemy.collisionType		; $749d
	res 7,(hl)		; $749f
++
	ld a,SND_BOSS_DAMAGE		; $74a1
	call playSound		; $74a3
@delete:
	jp partDelete		; $74a6


@state0:
	ld l,Enemy.health		; $74a9
	ld a,(hl)		; $74ab
	cp $03			; $74ac
	ld a,SPEED_80		; $74ae
	jr nc,+			; $74b0
	ld a,SPEED_e0		; $74b2
+
	ld h,d			; $74b4
	ld l,e			; $74b5
	inc (hl) ; [state] = 1

	ld l,Part.speed		; $74b7
	ld (hl),a		; $74b9

	ld l,Part.counter1		; $74ba
	ld (hl),150 ; [counter1] (lifetime counter)
	inc l			; $74be
	ld (hl),$08 ; [counter2]

	; Set color & animation
	ld l,Part.subid		; $74c1
	ld a,(hl)		; $74c3
	inc a			; $74c4
	ld l,Part.oamFlags		; $74c5
	ldd (hl),a		; $74c7
	ld (hl),a		; $74c8
	dec a			; $74c9
	call partSetAnimation		; $74ca

	; Move toward Link
	call objectGetAngleTowardEnemyTarget		; $74cd
	ld e,Part.angle		; $74d0
	ld (de),a		; $74d2

	jp objectSetVisible82		; $74d3

;;
; @addr{74d6}
partCode44:
	jr nz,_label_11_373	; $74d6
	ld e,$c4		; $74d8
	ld a,(de)		; $74da
	or a			; $74db
	jr nz,_label_11_371	; $74dc
	ld h,d			; $74de
	ld l,e			; $74df
	inc (hl)		; $74e0
	ld l,$c6		; $74e1
	ld (hl),$38		; $74e3
	inc l			; $74e5
	ld (hl),$ff		; $74e6
	ld l,$cf		; $74e8
	ld (hl),$f1		; $74ea
	ld bc,$fff0		; $74ec
	call objectSetSpeedZ		; $74ef
	xor a			; $74f2
	call partSetAnimation		; $74f3
	call objectSetVisible81		; $74f6
_label_11_371:
	call _partDecCounter1IfNonzero		; $74f9
	jr nz,_label_11_372	; $74fc
	ld (hl),$38		; $74fe
	ld l,$d4		; $7500
	ld a,(hl)		; $7502
	cpl			; $7503
	inc a			; $7504
	ldi (hl),a		; $7505
	ld a,(hl)		; $7506
	cpl			; $7507
	ld (hl),a		; $7508
_label_11_372:
	ld c,$00		; $7509
	call objectUpdateSpeedZ_paramC		; $750b
	ld a,$0f		; $750e
	call objectGetRelatedObject1Var		; $7510
	ld e,$cf		; $7513
	ld a,(de)		; $7515
	ld (hl),a		; $7516
	ret			; $7517
_label_11_373:
	ld a,$04		; $7518
	call objectGetRelatedObject1Var		; $751a
	inc (hl)		; $751d
	call getFreeInteractionSlot		; $751e
	ld (hl),$56		; $7521
	ld l,$43		; $7523
	ld (hl),$01		; $7525
	ld bc,$f000		; $7527
	call objectCopyPositionWithOffset		; $752a
	jp partDelete		; $752d

;;
; @addr{7530}
partCode45:
	ld e,$c4		; $7530
	ld a,(de)		; $7532
	rst_jumpTable			; $7533
.dw $753a
.dw $7562
.dw $758b
	ld h,d			; $753a
	ld l,e			; $753b
	inc (hl)		; $753c
	ld l,$d0		; $753d
	ld (hl),$32		; $753f
	ld l,$cb		; $7541
	ld a,(hl)		; $7543
	sub $08			; $7544
	jr z,_label_11_374	; $7546
	add $04			; $7548
_label_11_374:
	ldi (hl),a		; $754a
	ld e,$f0		; $754b
	ld (de),a		; $754d
	inc e			; $754e
	inc l			; $754f
	ld a,(hl)		; $7550
	ld (de),a		; $7551
	ld e,$c2		; $7552
	ld a,(de)		; $7554
	ld hl,$755e		; $7555
	rst_addAToHl			; $7558
	ld e,$c6		; $7559
	ld a,(hl)		; $755b
	ld (de),a		; $755c
	ret			; $755d
	dec l			; $755e
	ld e,d			; $755f
	add a			; $7560
	or h			; $7561
	call _partDecCounter1IfNonzero		; $7562
	ret nz			; $7565
	ld l,e			; $7566
	inc (hl)		; $7567
	ld l,$e4		; $7568
	set 7,(hl)		; $756a
	ld l,$d4		; $756c
	ld a,$60		; $756e
	ldi (hl),a		; $7570
	ld (hl),$fe		; $7571
_label_11_375:
	call getRandomNumber_noPreserveVars		; $7573
	and $07			; $7576
	cp $07			; $7578
	jr nc,_label_11_375	; $757a
	sub $03			; $757c
	add $10			; $757e
	ld e,$c9		; $7580
	ld (de),a		; $7582
	call objectSetVisiblec1		; $7583
	ld a,SND_RUMBLE		; $7586
	jp playSound		; $7588
	ld c,$20		; $758b
	call objectUpdateSpeedZ_paramC		; $758d
	call z,$756c		; $7590
	call objectApplySpeed		; $7593
	ld e,$cb		; $7596
	ld a,(de)		; $7598
	cp $88			; $7599
	jp c,partAnimate		; $759b
	ld h,d			; $759e
	ld l,$c4		; $759f
	dec (hl)		; $75a1
	ld l,$e4		; $75a2
	res 7,(hl)		; $75a4
	ld l,$c6		; $75a6
	ld (hl),$b4		; $75a8
	ld e,$f0		; $75aa
	ld l,$cb		; $75ac
	ld a,(de)		; $75ae
	ldi (hl),a		; $75af
	inc e			; $75b0
	inc l			; $75b1
	ld a,(de)		; $75b2
	ld (hl),a		; $75b3
	jp objectSetInvisible		; $75b4

;;
; @addr{75b7}
partCode46:
	jr z,_label_11_376	; $75b7
	ld h,d			; $75b9
	ld l,$c6		; $75ba
	ld (hl),$2d		; $75bc
	ld l,$c2		; $75be
	ld a,(hl)		; $75c0
	and $07			; $75c1
	ld hl,wActiveTriggers		; $75c3
	call setFlag		; $75c6
	call objectSetVisible83		; $75c9
_label_11_376:
	ld e,$c4		; $75cc
	ld a,(de)		; $75ce
	or a			; $75cf
	jr z,_label_11_377	; $75d0
	call _partDecCounter1IfNonzero		; $75d2
	ret nz			; $75d5
	ld e,$c2		; $75d6
	ld a,(de)		; $75d8
	ld hl,wActiveTriggers		; $75d9
	call unsetFlag		; $75dc
	jp objectSetInvisible		; $75df
_label_11_377:
	inc a			; $75e2
	ld (de),a		; $75e3
	ret			; $75e4


; ==============================================================================
; PARTID_BOMB
; ==============================================================================
partCode47:
	ld e,Part.state		; $75e5
	ld a,(de)		; $75e7
	rst_jumpTable			; $75e8
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3

@state0:
	ld h,d			; $75f1
	ld l,e			; $75f2
	inc (hl) ; [state] = 1

	ld l,Part.speed		; $75f4
	ld (hl),SPEED_200		; $75f6

	ld l,Part.speedZ		; $75f8
	ld a,<(-$280)		; $75fa
	ldi (hl),a		; $75fc
	ld (hl),>(-$280)		; $75fd

	call objectSetVisiblec1		; $75ff

; Waiting to be thrown
@state1:
	ld a,$00		; $7602
	call objectGetRelatedObject1Var		; $7604
	jp objectTakePosition		; $7607

; Being thrown
@state2:
	call objectApplySpeed		; $760a
	ld c,$20		; $760d
	call objectUpdateSpeedZ_paramC		; $760f
	jp nz,partAnimate		; $7612

	; Landed on ground; time to explode

	ld l,Part.state		; $7615
	inc (hl) ; [state] = 4

	ld l,Part.collisionType		; $7618
	set 7,(hl)		; $761a

	ld l,Part.oamFlagsBackup		; $761c
	ld a,$0a		; $761e
	ldi (hl),a		; $7620
	ldi (hl),a		; $7621
	ld (hl),$0c ; [oamTileIndexBase]

	ld a,$01		; $7624
	call partSetAnimation		; $7626

	ld a,SND_EXPLOSION		; $7629
	call playSound		; $762b

	jp objectSetVisible83		; $762e

; Exploding
@state3:
	call partAnimate		; $7631
	ld e,Part.animParameter		; $7634
	ld a,(de)		; $7636
	inc a			; $7637
	jp z,partDelete		; $7638

	dec a			; $763b
	ld e,Part.collisionRadiusY		; $763c
	ld (de),a		; $763e
	inc e			; $763f
	ld (de),a		; $7640
	ret			; $7641


; ==============================================================================
; PARTID_OCTOGON_DEPTH_CHARGE
;
; Variables:
;   var30: gravity
; ==============================================================================
partCode48:
	jr z,@normalStatus	; $7642

	; For subid 1 only, delete self on collision with anything?
	ld e,Part.subid		; $7644
	ld a,(de)		; $7646
	or a			; $7647
	jp nz,partDelete		; $7648

@normalStatus:
	ld e,Part.subid		; $764b
	ld a,(de)		; $764d
	or a			; $764e
	ld e,Part.state		; $764f
	jr z,_octogonDepthCharge_subid0	; $7651


; Small (split) projectile
_octogonDepthCharge_subid1:
	ld a,(de)		; $7653
	or a			; $7654
	jr z,@state0	; $7655

@state1:
	call objectApplySpeed		; $7657
	call _partCommon_checkTileCollisionOrOutOfBounds		; $765a
	jp nz,partAnimate		; $765d
	jp partDelete		; $7660

@state0:
	ld h,d			; $7663
	ld l,e			; $7664
	inc (hl) ; [state] = 1

	ld l,Part.collisionRadiusY		; $7666
	ld a,$02		; $7668
	ldi (hl),a		; $766a
	ld (hl),a		; $766b

	ld l,Part.speed		; $766c
	ld (hl),SPEED_180		; $766e
	ld a,$01		; $7670
	call partSetAnimation		; $7672
	jp objectSetVisible82		; $7675


; Large projectile, before being split into 4 smaller ones (subid 1)
_octogonDepthCharge_subid0:
	ld a,(de)		; $7678
	rst_jumpTable			; $7679
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3

@state0:
	ld a,Object.visible		; $7682
	call objectGetRelatedObject1Var		; $7684
	ld a,(hl)		; $7687

	ld h,d			; $7688
	ld l,Part.state		; $7689
	inc (hl)		; $768b

	rlca			; $768c
	jr c,@aboveWater		; $768d

@belowWater:
	inc (hl) ; [state] = 2 (skips the "moving up" part)
	ld l,Part.counter1		; $7690
	inc (hl)		; $7692

	ld l,Part.zh		; $7693
	ld (hl),$b8		; $7695
	ld l,Part.var30		; $7697
	ld (hl),$10		; $7699

	; Choose random position to spawn at
	call getRandomNumber_noPreserveVars		; $769b
	and $06			; $769e
	ld hl,@positionCandidates		; $76a0
	rst_addAToHl			; $76a3
	ld e,Part.yh		; $76a4
	ldi a,(hl)		; $76a6
	ld (de),a		; $76a7
	ld e,Part.xh		; $76a8
	ld a,(hl)		; $76aa
	ld (de),a		; $76ab

	ld a,SND_SPLASH		; $76ac
	call playSound		; $76ae
	jr @setVisible81		; $76b1

@positionCandidates:
	.db $38 $48
	.db $38 $a8
	.db $78 $48
	.db $78 $a8

@aboveWater:
	; Is shot up before coming back down
	ld l,Part.var30		; $76bb
	ld (hl),$20		; $76bd

	ld l,Part.yh		; $76bf
	ld a,(hl)		; $76c1
	sub $10			; $76c2
	ld (hl),a		; $76c4

	ld a,SND_SCENT_SEED		; $76c5
	call playSound		; $76c7

@setVisible81:
	jp objectSetVisible81		; $76ca


; Above water: being shot up
@state1:
	ld h,d			; $76cd
	ld l,Part.zh		; $76ce
	dec (hl)		; $76d0
	dec (hl)		; $76d1

	ld a,(hl)		; $76d2
	cp $d0			; $76d3
	jr nc,@animate	; $76d5

	cp $b8			; $76d7
	jr nc,@flickerVisibility	; $76d9

	ld l,e			; $76db
	inc (hl) ; [state] = 2

	ld l,Part.counter1		; $76dd
	ld (hl),30		; $76df

	ld l,Part.collisionType		; $76e1
	res 7,(hl)		; $76e3

	ld l,Part.yh		; $76e5
	ldh a,(<hEnemyTargetY)	; $76e7
	ldi (hl),a		; $76e9
	inc l			; $76ea
	ldh a,(<hEnemyTargetX)	; $76eb
	ld (hl),a		; $76ed

	jp objectSetInvisible		; $76ee

@flickerVisibility:
	ld l,Part.visible		; $76f1
	ld a,(hl)		; $76f3
	xor $80			; $76f4
	ld (hl),a		; $76f6

@animate:
	jp partAnimate		; $76f7


; Delay before falling to ground
@state2:
	call _partDecCounter1IfNonzero		; $76fa
	ret nz			; $76fd

	ld l,e			; $76fe
	inc (hl) ; [state] = 3

	ld l,Part.collisionType		; $7700
	set 7,(hl)		; $7702
	jp objectSetVisiblec1		; $7704


; Falling to ground
@state3:
	ld e,Part.var30		; $7707
	ld a,(de)		; $7709
	call objectUpdateSpeedZ		; $770a
	jr nz,@animate	; $770d

	; Hit ground; split into four, then delete self.
	call getRandomNumber_noPreserveVars		; $770f
	and $04			; $7712
	ld b,a			; $7714
	ld c,$04		; $7715

@spawnNext:
	call getFreePartSlot		; $7717
	jr nz,++		; $771a
	ld (hl),PARTID_OCTOGON_DEPTH_CHARGE		; $771c
	inc l			; $771e
	inc (hl) ; [subid] = 1
	ld l,Part.angle		; $7720
	ld (hl),b		; $7722
	call objectCopyPosition		; $7723
	ld a,b			; $7726
	add $08			; $7727
	ld b,a			; $7729
++
	dec c			; $772a
	jr nz,@spawnNext	; $772b

	ld a,SND_UNKNOWN3		; $772d
	call playSound		; $772f
	jp partDelete		; $7732

;;
; @addr{7735}
partCode49:
	ld e,$c4		; $7735
	ld a,(de)		; $7737
	rst_jumpTable			; $7738
.dw $7745
.dw $7765
.dw $7788
.dw $77a2
.dw $77cf
.dw $77e0
	ld h,d			; $7745
	ld l,$c2		; $7746
	ld a,(hl)		; $7748
	cp $ff			; $7749
	jr nz,_label_11_388	; $774b
	ld l,$c4		; $774d
	ld (hl),$05		; $774f
	jp $77f0		; $7751
_label_11_388:
	ld l,$c4		; $7754
	inc (hl)		; $7756
	call $78e3		; $7757
	call $793b		; $775a
	ld a,SND_POOF		; $775d
	call playSound		; $775f
	call objectSetVisiblec1		; $7762
	call objectApplySpeed		; $7765
	ld h,d			; $7768
	ld l,$f1		; $7769
	ld c,(hl)		; $776b
	call objectUpdateSpeedZAndBounce		; $776c
	jr c,_label_11_390	; $776f
	jr nz,_label_11_389	; $7771
	ld e,$d0		; $7773
	ld a,(de)		; $7775
	srl a			; $7776
	ld (de),a		; $7778
_label_11_389:
	jp partAnimate		; $7779
_label_11_390:
	ld h,d			; $777c
	ld l,$c4		; $777d
	ld (hl),$03		; $777f
	ld l,$c6		; $7781
	ld (hl),$14		; $7783
	jp partAnimate		; $7785
	inc e			; $7788
	ld a,(de)		; $7789
	rst_jumpTable			; $778a
.dw $7793
.dw $779c
.dw $779c
.dw $779d
	xor a			; $7793
	ld (wLinkGrabState2),a		; $7794
	inc a			; $7797
	ld (de),a		; $7798
	jp objectSetVisiblec1		; $7799
	ret			; $779c
	call objectSetVisiblec2		; $779d
	jr _label_11_391		; $77a0
	ld h,d			; $77a2
	ld l,$c6		; $77a3
	dec (hl)		; $77a5
	jr z,_label_11_391	; $77a6
	call partAnimate		; $77a8
	call $79ab		; $77ab
	jp objectAddToGrabbableObjectBuffer		; $77ae
_label_11_391:
	ld h,d			; $77b1
	ld l,$c4		; $77b2
	ld (hl),$04		; $77b4
	ld l,$e4		; $77b6
	set 7,(hl)		; $77b8
	ld l,$db		; $77ba
	ld a,$0a		; $77bc
	ldi (hl),a		; $77be
	ldi (hl),a		; $77bf
	ld (hl),$0c		; $77c0
	ld a,$01		; $77c2
	call partSetAnimation		; $77c4
	ld a,SND_EXPLOSION		; $77c7
	call playSound		; $77c9
	jp objectSetVisible83		; $77cc
	call partAnimate		; $77cf
	ld e,$e1		; $77d2
	ld a,(de)		; $77d4
	inc a			; $77d5
	jp z,partDelete		; $77d6
	dec a			; $77d9
	ld e,$e6		; $77da
	ld (de),a		; $77dc
	inc e			; $77dd
	ld (de),a		; $77de
	ret			; $77df
	ld h,d			; $77e0
	ld l,$f0		; $77e1
	dec (hl)		; $77e3
	ret nz			; $77e4
	ld l,$c6		; $77e5
	inc (hl)		; $77e7
	call $77f0		; $77e8
	jp z,partDelete		; $77eb
	jr _label_11_393		; $77ee
	ld h,d			; $77f0
	ld l,$c6		; $77f1
	ld a,(hl)		; $77f3
	ld bc,$780f		; $77f4
	call addDoubleIndexToBc		; $77f7
	ld a,(bc)		; $77fa
	cp $ff			; $77fb
	jr nz,_label_11_392	; $77fd
	ld a,$01		; $77ff
	ld ($cfc0),a		; $7801
	ret			; $7804
_label_11_392:
	ld l,$f0		; $7805
	ld (hl),a		; $7807
	inc bc			; $7808
	ld a,(bc)		; $7809
	ld l,$f5		; $780a
	ld (hl),a		; $780c
	or d			; $780d
	ret			; $780e
	inc a			; $780f
	ld bc,$013c		; $7810
	inc a			; $7813
	ld bc,$013c		; $7814
	inc a			; $7817
	ld bc,$013c		; $7818
	jr z,$01		; $781b
	jr z,$01		; $781d
	jr z,$01		; $781f
	jr z,$01		; $7821
	jr z,$01		; $7823
	ld e,$01		; $7825
	ld e,$01		; $7827
	ld e,$01		; $7829
	ld e,$01		; $782b
	ld e,$01		; $782d
	inc d			; $782f
	ld bc,$0114		; $7830
	inc d			; $7833
	ld bc,$0114		; $7834
	inc d			; $7837
	ld bc,$0214		; $7838
	inc d			; $783b
	ld (bc),a		; $783c
	inc d			; $783d
	ld (bc),a		; $783e
	inc d			; $783f
	ld (bc),a		; $7840
	inc d			; $7841
	ld (bc),a		; $7842
	inc d			; $7843
	ld (bc),a		; $7844
	inc d			; $7845
	ld (bc),a		; $7846
	inc d			; $7847
	ld (bc),a		; $7848
	inc d			; $7849
	ld (bc),a		; $784a
	inc d			; $784b
	ld (bc),a		; $784c
	inc d			; $784d
	ld (bc),a		; $784e
	inc d			; $784f
	ld (bc),a		; $7850
	inc d			; $7851
	ld (bc),a		; $7852
	inc d			; $7853
	ld (bc),a		; $7854
	or h			; $7855
	ld (bc),a		; $7856
	rst $38			; $7857
_label_11_393:
	xor a			; $7858
	ld e,$f2		; $7859
	ld (de),a		; $785b
	inc e			; $785c
	ld (de),a		; $785d
	call $78bd		; $785e
	ld e,$f5		; $7861
	ld a,(de)		; $7863
_label_11_394:
	ldh (<hFF92),a	; $7864
	call $786f		; $7866
	ldh a,(<hFF92)	; $7869
	dec a			; $786b
	jr nz,_label_11_394	; $786c
	ret			; $786e
_label_11_395:
	ld e,$f4		; $786f
	ld a,(de)		; $7871
	add a			; $7872
	add a			; $7873
	ld bc,$789d		; $7874
	call addDoubleIndexToBc		; $7877
	call getRandomNumber		; $787a
	and $07			; $787d
	call addAToBc		; $787f
	ld a,(bc)		; $7882
	ldh (<hFF8B),a	; $7883
	ld h,d			; $7885
	ld l,$f2		; $7886
	call checkFlag		; $7888
	jr nz,_label_11_395	; $788b
	call getFreePartSlot		; $788d
	ret nz			; $7890
	ld (hl),$49		; $7891
	inc l			; $7893
	ldh a,(<hFF8B)	; $7894
	ld (hl),a		; $7896
	ld h,d			; $7897
	ld l,$f2		; $7898
	jp setFlag		; $789a
	nop			; $789d
	ld bc,$0605		; $789e
	ld a,(bc)		; $78a1
	dec bc			; $78a2
	rrca			; $78a3
	nop			; $78a4
	ld bc,$0602		; $78a5
	rlca			; $78a8
	dec bc			; $78a9
	inc c			; $78aa
	dec c			; $78ab
	ld bc,$0403		; $78ac
	dec b			; $78af
	add hl,bc		; $78b0
	ld a,(bc)		; $78b1
	ld c,$0f		; $78b2
_label_11_396:
	inc bc			; $78b4
	ld (bc),a		; $78b5
	inc bc			; $78b6
	rlca			; $78b7
	ld ($0d09),sp		; $78b8
	ld c,$02		; $78bb
	ld a,(w1Link.xh)		; $78bd
	cp $50			; $78c0
	jr nc,_label_11_399	; $78c2
	ld a,(w1Link.yh)		; $78c4
_label_11_397:
	cp $40			; $78c7
	jr nc,_label_11_398	; $78c9
	xor a			; $78cb
	jr _label_11_401		; $78cc
_label_11_398:
	ld a,$01		; $78ce
	jr _label_11_401		; $78d0
_label_11_399:
	ld a,(w1Link.yh)		; $78d2
	cp $40			; $78d5
	jr nc,_label_11_400	; $78d7
	ld a,$02		; $78d9
	jr _label_11_401		; $78db
_label_11_400:
	ld a,$03		; $78dd
_label_11_401:
	ld e,$f4		; $78df
	ld (de),a		; $78e1
	ret			; $78e2
	ld h,d			; $78e3
	ld l,$c2		; $78e4
	ld a,(hl)		; $78e6
	ld hl,$791b		; $78e7
	rst_addDoubleIndex			; $78ea
	ld e,$cb		; $78eb
	ldi a,(hl)		; $78ed
	ld (de),a		; $78ee
	ld e,$cd		; $78ef
	ldi a,(hl)		; $78f1
	ld (de),a		; $78f2
	call objectGetAngleTowardLink		; $78f3
	ld e,$c9		; $78f6
	ld (de),a		; $78f8
	call getRandomNumber		; $78f9
	and $0f			; $78fc
	ld hl,$790b		; $78fe
	rst_addAToHl			; $7901
	ld b,(hl)		; $7902
	ld e,$c9		; $7903
	ld a,(de)		; $7905
	add b			; $7906
	and $1f			; $7907
	ld (de),a		; $7909
	ret			; $790a
	ld bc,$0302		; $790b
	rst $38			; $790e
	cp $fd			; $790f
	nop			; $7911
	nop			; $7912
	ld bc,$0202		; $7913
	rst $38			; $7916
	cp $00			; $7917
	nop			; $7919
	nop			; $791a
	nop			; $791b
	nop			; $791c
	nop			; $791d
	jr z,_label_11_402	; $791e
_label_11_402:
	ld d,b			; $7920
	nop			; $7921
	ld a,b			; $7922
	nop			; $7923
	and b			; $7924
	jr nz,_label_11_397	; $7925
	ld b,b			; $7927
	and b			; $7928
	ld h,b			; $7929
	and b			; $792a
	add b			; $792b
	and b			; $792c
	add b			; $792d
	ld a,b			; $792e
	add b			; $792f
	ld d,b			; $7930
	add b			; $7931
	jr z,_label_11_396	; $7932
	nop			; $7934
	ld h,b			; $7935
	nop			; $7936
	ld b,b			; $7937
	nop			; $7938
	jr nz,_label_11_403	; $7939
_label_11_403:
	call $78bd		; $793b
	ld e,$c2		; $793e
	ld a,(de)		; $7940
	add a			; $7941
	ld hl,$7962		; $7942
	rst_addDoubleIndex			; $7945
	ld e,$f4		; $7946
	ld a,(de)		; $7948
	rst_addAToHl			; $7949
	ld a,(hl)		; $794a
	ld bc,$79a2		; $794b
	call addAToBc		; $794e
	ld a,(bc)		; $7951
	ld h,d			; $7952
	ld l,$d0		; $7953
	ld (hl),a		; $7955
	ld l,$f1		; $7956
	ld (hl),$20		; $7958
	ld l,$d4		; $795a
	ld (hl),$80		; $795c
	inc l			; $795e
	ld (hl),$fd		; $795f
	ret			; $7961
	ld bc,$0504		; $7962
	ld ($0300),sp		; $7965
	inc b			; $7968
	dec b			; $7969
	nop			; $796a
	inc b			; $796b
	nop			; $796c
	inc b			; $796d
	inc bc			; $796e
	dec b			; $796f
	nop			; $7970
	inc b			; $7971
	dec b			; $7972
	ld ($0401),sp		; $7973
	dec b			; $7976
	ld b,$00		; $7977
	ld (bc),a		; $7979
	dec b			; $797a
	dec b			; $797b
	nop			; $797c
	nop			; $797d
	ld b,$05		; $797e
	ld (bc),a		; $7980
	nop			; $7981
	ld ($0405),sp		; $7982
	ld bc,$0305		; $7985
	inc b			; $7988
	nop			; $7989
	inc b			; $798a
	nop			; $798b
	inc b			; $798c
	nop			; $798d
	inc b			; $798e
	nop			; $798f
	dec b			; $7990
	inc bc			; $7991
	inc b			; $7992
	ld bc,$0508		; $7993
	ld (bc),a		; $7996
	nop			; $7997
	ld b,$05		; $7998
	nop			; $799a
	nop			; $799b
	inc b			; $799c
	inc b			; $799d
	nop			; $799e
	ld (bc),a		; $799f
	dec b			; $79a0
	ld b,$28		; $79a1
	ldd (hl),a		; $79a3
	inc a			; $79a4
	ld b,(hl)		; $79a5
	ld d,b			; $79a6
	ld e,d			; $79a7
	ld h,h			; $79a8
	ld l,(hl)		; $79a9
	ld a,b			; $79aa
	call objectGetShortPosition		; $79ab
	ld hl,wRoomLayout		; $79ae
	rst_addAToHl			; $79b1
	ld a,(hl)		; $79b2
	cp $54			; $79b3
	jr z,_label_11_404	; $79b5
	cp $55			; $79b7
	jr z,_label_11_405	; $79b9
	cp $56			; $79bb
	jr z,_label_11_406	; $79bd
	cp $57			; $79bf
	jr z,_label_11_407	; $79c1
	ret			; $79c3
_label_11_404:
	ld hl,$79e3		; $79c4
	ld e,$ca		; $79c7
	jr _label_11_408		; $79c9
_label_11_405:
	ld hl,$79e1		; $79cb
	ld e,$cc		; $79ce
	jr _label_11_408		; $79d0
_label_11_406:
	ld hl,$79e1		; $79d2
	ld e,$ca		; $79d5
	jr _label_11_408		; $79d7
_label_11_407:
	ld hl,$79e3		; $79d9
	ld e,$cc		; $79dc
_label_11_408:
	jp add16BitRefs		; $79de
	nop			; $79e1
	ld bc,$ff00		; $79e2


; ==============================================================================
; PARTID_SMOG_PROJECTILE
; ==============================================================================
partCode4a:
	ld e,Part.state		; $79e5
	ld a,(de)		; $79e7
	rst_jumpTable			; $79e8
	.dw @state0
	.dw @state1
	.dw @state2

@state0:
	ld a,$01		; $79ef
	ld (de),a ; [state] = 1

	call objectSetVisible81		; $79f2

	call objectGetAngleTowardLink		; $79f5
	ld e,Part.angle		; $79f8
	ld (de),a		; $79fa
	ld c,a			; $79fb

	ld a,SPEED_c0		; $79fc
	ld e,Part.speed		; $79fe
	ld (de),a		; $7a00

	; Check if this is a projectile from a large smog or a small smog
	ld e,Part.subid		; $7a01
	ld a,(de)		; $7a03
	or a			; $7a04
	jr z,@setAnimation	; $7a05

	; If from a large smog, change some properties
	ld a,SPEED_100		; $7a07
	ld e,Part.speed		; $7a09
	ld (de),a		; $7a0b

	ld a,$05		; $7a0c
	ld e,Part.oamFlags		; $7a0e
	ld (de),a		; $7a10

	ld e,Part.enemyCollisionMode		; $7a11
	ld a,ENEMYCOLLISION_PODOBOO		; $7a13
	ld (de),a		; $7a15

	ld a,c			; $7a16
	call convertAngleToDirection		; $7a17
	and $01			; $7a1a
	add $02			; $7a1c

@setAnimation:
	call partSetAnimation		; $7a1e

@state1:
	; Delete self if boss defeated
	call getThisRoomFlags		; $7a21
	bit 6,a			; $7a24
	jr nz,@delete	; $7a26

	ld a,(wNumEnemies)		; $7a28
	dec a			; $7a2b
	jr z,@delete	; $7a2c

	call objectCheckWithinScreenBoundary		; $7a2e
	jr nc,@delete	; $7a31

	call objectApplySpeed		; $7a33

	; If large smog's projectile, return (it passes through everything)
	ld e,Part.subid		; $7a36
	ld a,(de)		; $7a38
	or a			; $7a39
	ret nz			; $7a3a

	; Check for collision with items
	ld e,Part.var2a		; $7a3b
	ld a,(de)		; $7a3d
	or a			; $7a3e
	jr nz,@beginDestroyAnimation	; $7a3f

	; Check for collision with wall
	call _partCommon_getTileCollisionInFront		; $7a41
	jr z,@state2	; $7a44

@beginDestroyAnimation:
	ld h,d			; $7a46
	ld l,Part.collisionType		; $7a47
	res 7,(hl)		; $7a49

	ld a,$02		; $7a4b
	ld l,Part.state		; $7a4d
	ld (hl),a		; $7a4f

	dec a			; $7a50
	call partSetAnimation		; $7a51


@state2:
	call partAnimate		; $7a54
	ld e,Part.animParameter		; $7a57
	ld a,(de)		; $7a59
	or a			; $7a5a
	ret z			; $7a5b
@delete:
	jp partDelete		; $7a5c

;;
; @addr{7a5f}
partCode4f:
	ld e,$c4		; $7a5f
	ld a,(de)		; $7a61
	rst_jumpTable			; $7a62
.dw $7a69
.dw $7a78
.dw $7a99
	ld a,$01		; $7a69
	ld (de),a		; $7a6b
	inc a			; $7a6c
	call partSetAnimation		; $7a6d
	ld e,$c6		; $7a70
	ld a,$28		; $7a72
	ld (de),a		; $7a74
	jp objectSetVisible80		; $7a75
	call partAnimate		; $7a78
	ld a,$02		; $7a7b
	call objectGetRelatedObject1Var		; $7a7d
	ld a,(hl)		; $7a80
	cp $0f			; $7a81
	jr nz,_label_11_414	; $7a83
	call _partDecCounter1IfNonzero		; $7a85
	ret nz			; $7a88
	call objectGetAngleTowardLink		; $7a89
	ld e,$c9		; $7a8c
	ld (de),a		; $7a8e
	ld a,$50		; $7a8f
	ld e,$d0		; $7a91
	ld (de),a		; $7a93
	ld e,$c4		; $7a94
	ld a,$02		; $7a96
	ld (de),a		; $7a98
	call partAnimate		; $7a99
	call _partDecCounter1IfNonzero		; $7a9c
	jr nz,_label_11_413	; $7a9f
	ld (hl),$0a		; $7aa1
	call objectGetAngleTowardLink		; $7aa3
	jp objectNudgeAngleTowards		; $7aa6
_label_11_413:
	call objectApplySpeed		; $7aa9
	call objectCheckWithinScreenBoundary		; $7aac
	ret c			; $7aaf
_label_11_414:
	jp partDelete		; $7ab0

;;
; @addr{7ab3}
partCode54:
	ld e,$c2		; $7ab3
	ld a,(de)		; $7ab5
	or a			; $7ab6
	ld e,$c4		; $7ab7
	jp nz,$7adb		; $7ab9
	ld a,(de)		; $7abc
	or a			; $7abd
	jr z,_label_11_415	; $7abe
	call _partDecCounter1IfNonzero		; $7ac0
	jp z,partDelete		; $7ac3
	ld a,(hl)		; $7ac6
	and $0f			; $7ac7
	ret nz			; $7ac9
	call getFreePartSlot		; $7aca
	ret nz			; $7acd
	ld (hl),$54		; $7ace
	inc l			; $7ad0
	inc (hl)		; $7ad1
	ret			; $7ad2
_label_11_415:
	ld h,d			; $7ad3
	ld l,e			; $7ad4
	inc (hl)		; $7ad5
	ld l,$c6		; $7ad6
	ld (hl),$96		; $7ad8
	ret			; $7ada
	ld a,(de)		; $7adb
	or a			; $7adc
	jr nz,_label_11_416	; $7add
	inc a			; $7adf
	ld (de),a		; $7ae0
	ldh a,(<hCameraY)	; $7ae1
	ld b,a			; $7ae3
	ldh a,(<hCameraX)	; $7ae4
	ld c,a			; $7ae6
	call getRandomNumber		; $7ae7
	ld l,a			; $7aea
	and $07			; $7aeb
	swap a			; $7aed
	add $28			; $7aef
	add c			; $7af1
	ld e,$cd		; $7af2
	ld (de),a		; $7af4
	ld a,l			; $7af5
	and $70			; $7af6
	add $08			; $7af8
	ld l,a			; $7afa
	add b			; $7afb
	ld e,$cb		; $7afc
	ld (de),a		; $7afe
	ld a,l			; $7aff
	cpl			; $7b00
	inc a			; $7b01
	sub $07			; $7b02
	ld e,$cf		; $7b04
	ld (de),a		; $7b06
	jp objectSetVisiblec1		; $7b07
_label_11_416:
	ld c,$20		; $7b0a
	call objectUpdateSpeedZ_paramC		; $7b0c
	jp nz,partAnimate		; $7b0f
	call objectReplaceWithAnimationIfOnHazard		; $7b12
	jr c,_label_11_417	; $7b15
	ld b,$06		; $7b17
	call objectCreateInteractionWithSubid00		; $7b19
_label_11_417:
	jp partDelete		; $7b1c


; ==============================================================================
; PARTID_OCTOGON_BUBBLE
; ==============================================================================
partCode55:
	jr z,@normalStatus	; $7b1f

	; Collision occured with something. Check if it was Link.
	ld e,Part.var2a		; $7b21
	ld a,(de)		; $7b23
	cp $80|ITEMCOLLISION_LINK			; $7b24
	jp nz,@gotoState2		; $7b26

	call checkLinkVulnerable		; $7b29
	jr nc,@normalStatus	; $7b2c

	; Immobilize Link
	ld hl,wLinkForceState		; $7b2e
	ld a,LINK_STATE_COLLAPSED		; $7b31
	ldi (hl),a		; $7b33
	ld (hl),$01 ; [wcc50]

	ld h,d			; $7b36
	ld l,Part.state		; $7b37
	ld (hl),$03		; $7b39

	ld l,Part.zh		; $7b3b
	ld (hl),$00		; $7b3d

	ld l,Part.collisionType		; $7b3f
	res 7,(hl)		; $7b41
	call objectSetVisible81		; $7b43

@normalStatus:
	ld e,Part.state		; $7b46
	ld a,(de)		; $7b48
	rst_jumpTable			; $7b49
	.dw @state0
	.dw @state1
	.dw @state2
	.dw @state3


; Uninitialized
@state0:
	ld h,d			; $7b52
	ld l,e			; $7b53
	inc (hl) ; [state] = 1

	ld l,Part.speed		; $7b55
	ld (hl),SPEED_80		; $7b57

	ld l,Part.counter1		; $7b59
	ld (hl),180		; $7b5b
	jp objectSetVisible82		; $7b5d


; Moving forward
@state1:
	call _partDecCounter1IfNonzero		; $7b60
	jr z,@gotoState2	; $7b63

	ld a,(wFrameCounter)		; $7b65
	and $18			; $7b68
	rlca			; $7b6a
	swap a			; $7b6b
	ld hl,@zPositions		; $7b6d
	rst_addAToHl			; $7b70
	ld e,Part.zh		; $7b71
	ld a,(hl)		; $7b73
	ld (de),a		; $7b74
	call objectApplySpeed		; $7b75
@animate:
	jp partAnimate		; $7b78

@zPositions:
	.db $ff $fe $ff $00


; Stopped in place, waiting for signal from animation to delete self
@state2:
	call partAnimate		; $7b7f
	ld e,Part.animParameter		; $7b82
	ld a,(de)		; $7b84
	inc a			; $7b85
	ret nz			; $7b86
	jp partDelete		; $7b87


; Collided with Link
@state3:
	ld hl,w1Link		; $7b8a
	call objectTakePosition		; $7b8d

	ld a,(wLinkForceState)		; $7b90
	cp LINK_STATE_COLLAPSED			; $7b93
	ret z			; $7b95

	ld l,<w1Link.state		; $7b96
	ldi a,(hl)		; $7b98
	cp LINK_STATE_COLLAPSED			; $7b99
	jr z,@animate	; $7b9b

@gotoState2:
	ld h,d			; $7b9d
	ld l,Part.state		; $7b9e
	ld (hl),$02		; $7ba0

	ld l,Part.collisionType		; $7ba2
	res 7,(hl)		; $7ba4

	ld a,$01		; $7ba6
	jp partSetAnimation		; $7ba8

;;
; @addr{7bab}
partCode56:
	jr z,_label_11_421	; $7bab
	ld e,$ea		; $7bad
	ld a,(de)		; $7baf
	cp $80			; $7bb0
	jr nz,_label_11_421	; $7bb2
	ld hl,$d031		; $7bb4
	ld (hl),$10		; $7bb7
	ld l,$30		; $7bb9
	ld (hl),$00		; $7bbb
	ld l,$24		; $7bbd
	res 7,(hl)		; $7bbf
	ld bc,$fa00		; $7bc1
	call objectCopyPositionWithOffset		; $7bc4
	ld h,d			; $7bc7
	ld l,$f0		; $7bc8
	ld (hl),$01		; $7bca
	ld l,$c4		; $7bcc
	ldi a,(hl)		; $7bce
	dec a			; $7bcf
	jr nz,_label_11_421	; $7bd0
	inc l			; $7bd2
	ld a,$01		; $7bd3
	ldi (hl),a		; $7bd5
	ld (hl),a		; $7bd6
_label_11_421:
	ld e,$c2		; $7bd7
	ld a,(de)		; $7bd9
	ld e,$c4		; $7bda
	rst_jumpTable			; $7bdc
.dw $7be5
.dw $7c3c
.dw $7d1f
.dw $7d42
	ld a,(de)		; $7be5
	or a			; $7be6
	jr z,_label_11_424	; $7be7
	call _partDecCounter1IfNonzero		; $7be9
	jr nz,_label_11_422	; $7bec
	ld (hl),$04		; $7bee
	call getFreePartSlot		; $7bf0
	jr nz,_label_11_422	; $7bf3
	ld (hl),$56		; $7bf5
	inc l			; $7bf7
	ld (hl),$02		; $7bf8
	ld l,$d6		; $7bfa
	ld e,l			; $7bfc
	ld a,(de)		; $7bfd
	ldi (hl),a		; $7bfe
	inc e			; $7bff
	ld a,(de)		; $7c00
	ld (hl),a		; $7c01
	call objectCopyPosition		; $7c02
_label_11_422:
	ld a,$02		; $7c05
	call objectGetRelatedObject1Var		; $7c07
	ld a,(hl)		; $7c0a
	dec a			; $7c0b
	jp nz,$7c28		; $7c0c
	ld c,h			; $7c0f
	ldh a,(<hCameraY)	; $7c10
	ld b,a			; $7c12
	ld e,$cf		; $7c13
	ld a,(de)		; $7c15
	sub $04			; $7c16
	ld (de),a		; $7c18
	ld h,d			; $7c19
	ld l,$cb		; $7c1a
	add (hl)		; $7c1c
	sub b			; $7c1d
	cp $b0			; $7c1e
	ret c			; $7c20
	ld h,c			; $7c21
	ld l,$b8		; $7c22
	inc (hl)		; $7c24
	jp partDelete		; $7c25
_label_11_423:
	call objectCreatePuff		; $7c28
	jp partDelete		; $7c2b
_label_11_424:
	ld h,d			; $7c2e
	ld l,e			; $7c2f
	inc (hl)		; $7c30
	ld l,$c6		; $7c31
	inc (hl)		; $7c33
	call objectSetVisible80		; $7c34
_label_11_425:
	ld a,SND_BEAM2		; $7c37
	jp playSound		; $7c39
	ld a,$02		; $7c3c
	call objectGetRelatedObject1Var		; $7c3e
	ld a,(hl)		; $7c41
	dec a			; $7c42
	jr nz,_label_11_423	; $7c43
	ld l,$ad		; $7c45
	ld a,(hl)		; $7c47
	or a			; $7c48
	jr nz,_label_11_423	; $7c49
	ld e,$c4		; $7c4b
	ld a,(de)		; $7c4d
	rst_jumpTable			; $7c4e
.dw $7c59
.dw $7c92
.dw $7cc9
.dw $7cd1
.dw $7d10
	ld h,d			; $7c59
	ld l,e			; $7c5a
	inc (hl)		; $7c5b
	ld l,$c6		; $7c5c
	ld (hl),$01		; $7c5e
	inc l			; $7c60
	ld (hl),$05		; $7c61
	ld l,$e4		; $7c63
	set 7,(hl)		; $7c65
	ld l,$d0		; $7c67
	ld (hl),$50		; $7c69
	ld l,$f1		; $7c6b
	ld e,$cb		; $7c6d
	ld a,(de)		; $7c6f
	add $10			; $7c70
	ldi (hl),a		; $7c72
	ld (de),a		; $7c73
	ld e,$cd		; $7c74
	ld a,(de)		; $7c76
	ld (hl),a		; $7c77
	call objectGetAngleTowardLink		; $7c78
	cp $0e			; $7c7b
	ld b,$0c		; $7c7d
	jr c,_label_11_426	; $7c7f
	ld b,$10		; $7c81
	cp $13			; $7c83
	jr c,_label_11_426	; $7c85
	ld b,$14		; $7c87
_label_11_426:
	ld e,$c9		; $7c89
	ld a,b			; $7c8b
	ld (de),a		; $7c8c
	call objectSetVisible81		; $7c8d
	jr _label_11_425		; $7c90
	call _partDecCounter1IfNonzero		; $7c92
	jr nz,_label_11_427	; $7c95
	ld (hl),$08		; $7c97
	inc l			; $7c99
	dec (hl)		; $7c9a
	jr z,_label_11_428	; $7c9b
	call getFreePartSlot		; $7c9d
	jr nz,_label_11_427	; $7ca0
	ld (hl),$56		; $7ca2
	inc l			; $7ca4
	ld (hl),$03		; $7ca5
	ld l,$d6		; $7ca7
	ld a,$c0		; $7ca9
	ldi (hl),a		; $7cab
	ld (hl),d		; $7cac
	call objectCopyPosition		; $7cad
_label_11_427:
	call _partCommon_checkTileCollisionOrOutOfBounds		; $7cb0
	jp nc,objectApplySpeed		; $7cb3
_label_11_428:
	ld h,d			; $7cb6
	ld l,$c4		; $7cb7
	inc (hl)		; $7cb9
	ld l,$c6		; $7cba
	ld (hl),$1e		; $7cbc
	ld l,$d0		; $7cbe
	ld (hl),$3c		; $7cc0
	ld l,$c9		; $7cc2
	ld a,(hl)		; $7cc4
	xor $10			; $7cc5
	ld (hl),a		; $7cc7
	ret			; $7cc8
	call _partDecCounter1IfNonzero		; $7cc9
	ret nz			; $7ccc
	ld l,$c4		; $7ccd
	inc (hl)		; $7ccf
	ret			; $7cd0
	call objectApplySpeed		; $7cd1
	ld e,$f0		; $7cd4
	ld a,(de)		; $7cd6
	or a			; $7cd7
	jr z,_label_11_429	; $7cd8
	ld bc,$fa00		; $7cda
	ld hl,$d000		; $7cdd
	call objectCopyPositionWithOffset		; $7ce0
_label_11_429:
	ld h,d			; $7ce3
	ld l,$f1		; $7ce4
	ld e,$cb		; $7ce6
	ld a,(de)		; $7ce8
	sub (hl)		; $7ce9
	add $02			; $7cea
	cp $05			; $7cec
	ret nc			; $7cee
	ld l,$f2		; $7cef
	ld e,$cd		; $7cf1
	ld a,(de)		; $7cf3
	sub (hl)		; $7cf4
	add $02			; $7cf5
	cp $05			; $7cf7
	ret nc			; $7cf9
	ld a,$38		; $7cfa
	call objectGetRelatedObject1Var		; $7cfc
	inc (hl)		; $7cff
	ld e,$f0		; $7d00
	ld a,(de)		; $7d02
	or a			; $7d03
	jp z,partDelete		; $7d04
	ld l,$86		; $7d07
	ld (hl),$08		; $7d09
	ld h,d			; $7d0b
	ld l,$c4		; $7d0c
	inc (hl)		; $7d0e
	ret			; $7d0f
	ld hl,$d005		; $7d10
	ld a,(hl)		; $7d13
	cp $02			; $7d14
	jp z,partDelete		; $7d16
	ld bc,$0600		; $7d19
	jp objectTakePositionWithOffset		; $7d1c
	ld a,(de)		; $7d1f
	or a			; $7d20
	jr z,_label_11_431	; $7d21
	ld a,$1a		; $7d23
	call objectGetRelatedObject1Var		; $7d25
	bit 7,(hl)		; $7d28
	jr z,_label_11_430	; $7d2a
	ld l,$8f		; $7d2c
	ld b,(hl)		; $7d2e
	dec b			; $7d2f
	ld e,$cf		; $7d30
	ld a,(de)		; $7d32
	dec a			; $7d33
	cp b			; $7d34
	ret c			; $7d35
_label_11_430:
	jp partDelete		; $7d36
_label_11_431:
	inc a			; $7d39
	ld (de),a		; $7d3a
	inc a			; $7d3b
	call partSetAnimation		; $7d3c
	jp objectSetVisible80		; $7d3f
	ld a,(de)		; $7d42
	or a			; $7d43
	jr z,_label_11_433	; $7d44
	ld a,$01		; $7d46
	call objectGetRelatedObject1Var		; $7d48
	ld a,(hl)		; $7d4b
	cp $56			; $7d4c
	jr nz,_label_11_432	; $7d4e
	ld l,$cb		; $7d50
	ld e,l			; $7d52
	ld a,(de)		; $7d53
	cp (hl)			; $7d54
	ret c			; $7d55
_label_11_432:
	jp partDelete		; $7d56
_label_11_433:
	inc a			; $7d59
	ld (de),a		; $7d5a
	ld a,$09		; $7d5b
	call objectGetRelatedObject1Var		; $7d5d
	ld a,(hl)		; $7d60
	sub $0c			; $7d61
	rrca			; $7d63
	rrca			; $7d64
	inc a			; $7d65
	call partSetAnimation		; $7d66
	jp objectSetVisible83		; $7d69

;;
; @addr{7d6c}
partCode57:
	ld e,$c4		; $7d6c
	ld a,(de)		; $7d6e
	rst_jumpTable			; $7d6f
.dw $7d7e
.dw $7d9c
.dw $7dad
.dw $7dc7
.dw $7dcf
.dw $7dd6
.dw $7e10
	call objectCenterOnTile		; $7d7e
	call objectGetShortPosition		; $7d81
	ld e,$f0		; $7d84
	ld (de),a		; $7d86
	ld e,$c6		; $7d87
	ld a,$04		; $7d89
	ld (de),a		; $7d8b
	ld a,SND_UNKNOWN3		; $7d8c
	call playSound		; $7d8e
	ld hl,$7d98		; $7d91
	ld a,$60		; $7d94
	jr _label_11_434		; $7d96
	ld a,($ff00+R_IE)	; $7d98
	ld bc,wScreenScrollRow		; $7d9a
	and a			; $7d9d
	ld b,b			; $7d9e
	ret nz			; $7d9f
	ld (hl),$04		; $7da0
	ld hl,$7da9		; $7da2
	ld a,$60		; $7da5
	jr _label_11_434		; $7da7
	rst $28			; $7da9
	pop af			; $7daa
	rrca			; $7dab
	ld de,$a7cd		; $7dac
	ld b,b			; $7daf
	ret nz			; $7db0
	ld (hl),$2d		; $7db1
	ld l,e			; $7db3
	inc (hl)		; $7db4
	ld l,$60		; $7db5
	ld e,$f0		; $7db7
	ld a,(de)		; $7db9
	ld c,a			; $7dba
	ld b,$cf		; $7dbb
	ld a,(bc)		; $7dbd
	sub $02			; $7dbe
	cp $03			; $7dc0
	ret c			; $7dc2
	ld a,l			; $7dc3
	jp setTile		; $7dc4
	call _partDecCounter1IfNonzero		; $7dc7
	ret nz			; $7dca
	ld (hl),$04		; $7dcb
	ld l,e			; $7dcd
	inc (hl)		; $7dce
	ld hl,$7da9		; $7dcf
	ld a,$a0		; $7dd2
	jr _label_11_434		; $7dd4
	call _partDecCounter1IfNonzero		; $7dd6
	ret nz			; $7dd9
	ld (hl),$04		; $7dda
	ld hl,$7d98		; $7ddc
	ld a,$a0		; $7ddf
_label_11_434:
	ldh (<hFF8B),a	; $7de1
	ld e,$f0		; $7de3
	ld a,(de)		; $7de5
	ld c,a			; $7de6
	ld b,$04		; $7de7
_label_11_435:
	push bc			; $7de9
	ldi a,(hl)		; $7dea
	add c			; $7deb
	ld c,a			; $7dec
	ld b,$cf		; $7ded
	ld a,(bc)		; $7def
	cp $da			; $7df0
	jr z,_label_11_436	; $7df2
	sub $02			; $7df4
	cp $03			; $7df6
	jr c,_label_11_437	; $7df8
	ld b,$ce		; $7dfa
	ld a,(bc)		; $7dfc
	or a			; $7dfd
	jr nz,_label_11_437	; $7dfe
_label_11_436:
	ldh a,(<hFF8B)	; $7e00
	push hl			; $7e02
	call setTile		; $7e03
	pop hl			; $7e06
_label_11_437:
	pop bc			; $7e07
	dec b			; $7e08
	jr nz,_label_11_435	; $7e09
	ld h,d			; $7e0b
	ld l,$c4		; $7e0c
	inc (hl)		; $7e0e
	ret			; $7e0f
	call _partDecCounter1IfNonzero		; $7e10
	ret nz			; $7e13
	ld l,$a0		; $7e14
	call $7db7		; $7e16
	jp partDelete		; $7e19

;;
; @addr{7e1c}
partCode58:
	jr z,_label_11_438	; $7e1c
	ld e,$ea		; $7e1e
	ld a,(de)		; $7e20
	cp $80			; $7e21
	jr nz,_label_11_438	; $7e23
	ld h,d			; $7e25
	ld l,$e4		; $7e26
	res 7,(hl)		; $7e28
	ld l,$c4		; $7e2a
	ld (hl),$03		; $7e2c
	ld l,$c6		; $7e2e
	ld (hl),$f0		; $7e30
	call objectSetInvisible		; $7e32
_label_11_438:
	ld e,$c4		; $7e35
	ld a,(de)		; $7e37
	rst_jumpTable			; $7e38
.dw $7e41
.dw $7e58
.dw $7e6a
.dw $7e76
	ld h,d			; $7e41
	ld l,e			; $7e42
	inc (hl)		; $7e43
	ld l,$c9		; $7e44
	ld (hl),$10		; $7e46
	ld l,$d0		; $7e48
	ld (hl),$78		; $7e4a
	ld l,$c6		; $7e4c
	ld (hl),$09		; $7e4e
	ld a,SND_BEAM		; $7e50
	call playSound		; $7e52
	call objectSetVisible83		; $7e55
	call _partDecCounter1IfNonzero		; $7e58
	jr z,_label_11_439	; $7e5b
	ld a,$0b		; $7e5d
	call objectGetRelatedObject1Var		; $7e5f
	ld bc,$1400		; $7e62
	jp objectTakePositionWithOffset		; $7e65
_label_11_439:
	ld l,e			; $7e68
	inc (hl)		; $7e69
	call objectApplySpeed		; $7e6a
	ld e,$cb		; $7e6d
	ld a,(de)		; $7e6f
	cp $b0			; $7e70
	ret c			; $7e72
	jp partDelete		; $7e73
	call _partDecCounter1IfNonzero		; $7e76
	jp z,partDelete		; $7e79
	ld a,(wGameKeysJustPressed)		; $7e7c
	or a			; $7e7f
	jr z,_label_11_441	; $7e80
	ld a,(hl)		; $7e82
	sub $0a			; $7e83
	jr nc,_label_11_440	; $7e85
	ld a,$01		; $7e87
_label_11_440:
	ld (hl),a		; $7e89
_label_11_441:
	ld hl,wccd8		; $7e8a
	set 5,(hl)		; $7e8d
	ld a,(wFrameCounter)		; $7e8f
	rrca			; $7e92
	ret nc			; $7e93
	ld hl,wLinkImmobilized		; $7e94
	set 5,(hl)		; $7e97
	ret			; $7e99

;;
; @addr{7e9a}
partCode59:
	ld e,$c4		; $7e9a
	ld a,(de)		; $7e9c
	rst_jumpTable			; $7e9d
.dw $7eaa
.dw $7ec1
.dw $7edc
.dw $7ee7
.dw $7f03
.dw $7f30
	ld h,d			; $7eaa
	ld l,e			; $7eab
	inc (hl)		; $7eac
	ld l,$d0		; $7ead
	ld (hl),$14		; $7eaf
	ld l,$c2		; $7eb1
	ld a,(hl)		; $7eb3
	ld hl,$7ebd		; $7eb4
	rst_addAToHl			; $7eb7
	ld e,$c6		; $7eb8
	ld a,(hl)		; $7eba
	ld (de),a		; $7ebb
	ret			; $7ebc
	ld bc,$2814		; $7ebd
	inc a			; $7ec0
	call _partDecCounter1IfNonzero		; $7ec1
	ret nz			; $7ec4
	ld l,e			; $7ec5
	inc (hl)		; $7ec6
	ld l,$c2		; $7ec7
	ld a,(hl)		; $7ec9
	xor $03			; $7eca
	ld hl,$7ebd		; $7ecc
	rst_addAToHl			; $7ecf
	ld e,$c6		; $7ed0
	ld a,(hl)		; $7ed2
	ld (de),a		; $7ed3
	ld a,SND_LIGHTTORCH		; $7ed4
	call playSound		; $7ed6
	jp objectSetVisible83		; $7ed9
	call _partDecCounter1IfNonzero		; $7edc
	jr nz,_label_11_444	; $7edf
	ld (hl),$14		; $7ee1
	ld l,e			; $7ee3
	inc (hl)		; $7ee4
	jr _label_11_444		; $7ee5
	call _partDecCounter1IfNonzero		; $7ee7
	jr nz,_label_11_444	; $7eea
	ld hl,$6dbc		; $7eec
	ld e,$10		; $7eef
	call interBankCall		; $7ef1
	ld h,d			; $7ef4
	ld l,$c4		; $7ef5
	inc (hl)		; $7ef7
	ld a,b			; $7ef8
	or a			; $7ef9
	jr nz,_label_11_444	; $7efa
	inc (hl)		; $7efc
	ld l,$c6		; $7efd
	ld (hl),$10		; $7eff
	jr _label_11_444		; $7f01
	ld h,d			; $7f03
	ld l,$f0		; $7f04
	ldi a,(hl)		; $7f06
	ld b,a			; $7f07
	ld c,(hl)		; $7f08
	ld l,$cb		; $7f09
	ldi a,(hl)		; $7f0b
	ldh (<hFF8F),a	; $7f0c
	inc l			; $7f0e
	ld a,(hl)		; $7f0f
	ldh (<hFF8E),a	; $7f10
	cp c			; $7f12
	jr nz,_label_11_442	; $7f13
	ldh a,(<hFF8F)	; $7f15
	cp b			; $7f17
	jr nz,_label_11_442	; $7f18
	ld l,e			; $7f1a
	dec (hl)		; $7f1b
	ld l,$c6		; $7f1c
	ld (hl),$10		; $7f1e
	inc l			; $7f20
	inc (hl)		; $7f21
	jr _label_11_444		; $7f22
_label_11_442:
	call objectGetRelativeAngleWithTempVars		; $7f24
	ld e,$c9		; $7f27
	ld (de),a		; $7f29
	call objectApplySpeed		; $7f2a
_label_11_444:
	jp partAnimate		; $7f2d
	call _partDecCounter1IfNonzero		; $7f30
	jr nz,_label_11_444	; $7f33
	call objectCreatePuff		; $7f35
	jp partDelete		; $7f38

;;
; Stone blocking path to Nayru at the start of the game (only after being moved)
; @addr{7f3b}
partCode5a:
	ld e,Part.state		; $7f3b
	ld a,(de)		; $7f3d
	or a			; $7f3e
	ret nz			; $7f3f

	inc a			; $7f40
	ld (de),a		; $7f41

	call getThisRoomFlags		; $7f42
	and $c0			; $7f45
	jp z,partDelete		; $7f47

	and $40			; $7f4a
	ld a,$28		; $7f4c
	jr nz,+			; $7f4e
	ld a,$48		; $7f50
+
	ld e,Part.xh		; $7f52
	ld (de),a		; $7f54
	call objectMakeTileSolid		; $7f55
	ld h,>wRoomLayout		; $7f58
	ld (hl),$00		; $7f5a
	ld a,PALH_98		; $7f5c
	call loadPaletteHeader		; $7f5e
	jp objectSetVisible83		; $7f61


.ifdef BUILD_VANILLA

; Garbage function follows (partial repeat of the last function)

;;
; @addr{7f64}
func_11_7f64:
	call $20ef		; $7f64
	ld h,$cf		; $7f67
	ld (hl),$00		; $7f69
	ld a,$98		; $7f6b
	call $0510		; $7f6d
	jp $1eaf		; $7f70

.endif

.BANK $12 SLOT 1
.ORG 0

.include "code/objectLoading.s"

 m_section_superfree "Room_Code" namespace "roomSpecificCode"

;;
; @addr{5872}
runRoomSpecificCode: ; 5872
	ld a,(wActiveRoom)		; $5872
	ld hl, _roomSpecificCodeGroupTable
	call findRoomSpecificData		; $5878
	ret nc			; $587b
	rst_jumpTable			; $587c
.dw _roomSpecificCode0
.dw _roomSpecificCode1
.dw _roomSpecificCode2
.dw _roomSpecificCode3
.dw _roomSpecificCode4
.dw _roomSpecificCode5
.dw setDeathRespawnPoint
.dw _roomSpecificCode7
.dw _roomSpecificCode8
.dw _roomSpecificCode9
.dw _roomSpecificCodeA
.dw _roomSpecificCodeB
.dw _roomSpecificCodeC

	; Random stub not called by anything?
	ret			; 5897

_roomSpecificCodeGroupTable: ; 5898
	.dw _roomSpecificCodeGroup0Table
	.dw _roomSpecificCodeGroup1Table
	.dw _roomSpecificCodeGroup2Table
	.dw _roomSpecificCodeGroup3Table
	.dw _roomSpecificCodeGroup4Table
	.dw _roomSpecificCodeGroup5Table
	.dw _roomSpecificCodeGroup6Table
	.dw _roomSpecificCodeGroup7Table

; Format: room index

_roomSpecificCodeGroup0Table: ; 58a8
	.db $93 $00
	.db $38 $06
	.db $39 $08
	.db $3a $09
	.db $00
_roomSpecificCodeGroup1Table: ; 58b1
	.db $81 $03
	.db $38 $06
	.db $97 $07
	.db $0e $0a
	.db $00
_roomSpecificCodeGroup2Table: ; 58ba
	.db $0e $05
	.db $00
_roomSpecificCodeGroup3Table: ; 58bd
	.db $0f $0b
	.db $00
_roomSpecificCodeGroup4Table: ; 58c0
	.db $60 $01
	.db $52 $02
	.db $e6 $0c
	.db $00
_roomSpecificCodeGroup5Table: ; 58c7
	.db $d2 $04
_roomSpecificCodeGroup6Table:
_roomSpecificCodeGroup7Table: ; 58c9
	.db $00

;;
; @addr{58ca}
_roomSpecificCode0: ; 58ca
	ld a,GLOBALFLAG_WON_FAIRY_HIDING_GAME		; $58ca
	call checkGlobalFlag		; $58cc
	ret nz			; $58cf
	ld hl,$cfd0		; $58d0
	ld b,$10		; $58d3
	jp clearMemory		; $58d5

;;
; @addr{5cd8}
_roomSpecificCode1: ; 5cd8
	ld a, GLOBALFLAG_D3_CRYSTALS	; $5cd8
	call checkGlobalFlag		; $58da
	ret nz			; $58dd
---
	; Create spinner object
	call getFreeInteractionSlot		; $58de
	ret nz			; $58e1
	ld (hl),$7d		; $58e2
	ld l,Interaction.yh
	ld (hl),$57		; $58e6
	ld l,Interaction.xh
	ld (hl),$01		; $58ea
	ret			; $58ec

;;
; @addr{58ed}
_roomSpecificCode2: ; 58ed
	ld a,GLOBALFLAG_D3_CRYSTALS	; $58ed
	call checkGlobalFlag		; $58ef
	ret z			; $58f2
	; Create spinner if the flag is UNset
	jr ---

;;
; @addr{58f5}
_roomSpecificCode3: ; 58f5
	call getThisRoomFlags		; $58f5
	bit 6,a			; $58f8
	ret nz			; $58fa
	ld a,TREASURE_MYSTERY_SEEDS		; $58fb
	call checkTreasureObtained		; $58fd
	ret nc			; $5900
	ld hl,wcc05		; $5901
	res 1,(hl)		; $5904
	call getFreeInteractionSlot		; $5906
	ret nz			; $5909
	ld (hl),$40		; $590a
	inc l			; $590c
	ld (hl),$0a		; $590d
	ld a,$01		; $590f
	ld (wDiggingUpEnemiesForbidden),a		; $5911
	ret			; $5914

;;
; @addr{5915}
_roomSpecificCode7: ; 5915
	ld a,GLOBALFLAG_GAVE_ROPE_TO_RAFTON	; $5915
	call checkGlobalFlag		; $5917
	ret z			; $591a
	call getThisRoomFlags		; $591b
	bit 6,a			; $591e
	ret nz			; $5920
.ifdef ROM_AGES
	ld a,MUS_RALPH
.else
	ld a,$35
.endif
	ld (wActiveMusic2),a		; $5923
	ret			; $5926

;;
; @addr{5927}
_roomSpecificCode5: ; 5927
	ld a,GLOBALFLAG_SAVED_NAYRU	; $5927
	call checkGlobalFlag		; $5929
	ret nz			; $592c
	ld a,MUS_SADNESS
	ld (wActiveMusic2),a		; $592f
	ret			; $5932

;;
; Something in ambi's palace
; @addr{5933}
_roomSpecificCode4: ; 5933
	ld a,$06		; $5933
	ld (wMinimapRoom),a		; $5935
	ld hl,wPastRoomFlags+$06
	set 4,(hl)		; $593b
	ret			; $593d

;;
; Check to play ralph music for ralph entering portal cutscene
; @addr{593e}
_roomSpecificCode8: ; 593e
	ld a,(wScreenTransitionDirection)		; $593e
	cp DIR_RIGHT			; $5941
	ret nz			; $5943
	ld a, GLOBALFLAG_RALPH_ENTERED_PORTAL
	call checkGlobalFlag		; $5946
	ret nz			; $5949
.ifdef ROM_AGES
	ld a, MUS_RALPH
.else
	ld a,$35
.endif
	ld (wActiveMusic2),a		; $594c
	ret			; $594f

;;
; Play nayru music on impa's house screen, for some reason
; @addr{5950}
_roomSpecificCode9: ; 5950
	ld a,GLOBALFLAG_FINISHEDGAME		; $5950
	call checkGlobalFlag		; $5952
	ret z			; $5955
.ifdef ROM_AGES
	ld a, MUS_NAYRU
.else
	ld a,$08
.endif
	ld (wActiveMusic2),a		; $5958
	ret			; $595b

;;
; Correct minimap in mermaid's cave present
; @addr{595c}
_roomSpecificCodeA: ; 595c
	ld hl,wMinimapGroup		; $595c
	ld (hl),$00		; $595f
	inc l			; $5961
	ld (hl),$3c		; $5962
	ret			; $5964

;;
; Correct minimap in mermaid's cave past
; @addr{5965}
_roomSpecificCodeB: ; 5965
	ld hl,wMinimapGroup		; $5965
	ld (hl),$01		; $5968
	inc l			; $596a
	ld (hl),$3c		; $596b
	ret			; $596d

;;
; Something happening on vire black tower screen
; @addr{596e}
_roomSpecificCodeC: ; 596e
	ld hl,wActiveMusic		; $596e
	ld a,(hl)		; $5971
	or a			; $5972
	ret nz			; $5973
	ld (hl),$ff		; $5974
	ret			; $5976


.ends

 m_section_free "Objects_2" namespace "objectData"

.include "objects/ages/mainData.s"
.include "objects/ages/helperData2.s"

.ends


 m_section_superfree "Underwater Surface Data"

;;
; Sets carry (bit 0 of c) if link is allowed to surface
; @addr{78e4}
checkLinkCanSurface_isUnderwater: ; 78e4
	ld a,(wActiveGroup)		; $78e4
	ld hl, underWaterSurfaceTable
	rst_addDoubleIndex			; $78ea
	ldi a,(hl)		; $78eb
	ld h,(hl)		; $78ec
	ld l,a			; $78ed
	ld a,(wActiveRoom)		; $78ee
	ld b,a			; $78f1
-
	ldi a,(hl)		; $78f2
	or a			; $78f3
	jr z,+++
	cp b			; $78f6
	jr z,+
	inc hl			; $78f9
	inc hl			; $78fa
	jr -
+
	ldi a,(hl)		; $78fd
	ld h,(hl)		; $78fe
	ld l,a			; $78ff
	ld a,(wAreaFlags)		; $7900
	and $01			; $7903
	jr z, +
	ld b,(hl)		; $7907
	ld a,b			; $7908
	and $03			; $7909
	jr z, ++
	push hl			; $790d
	ld a,GLOBALFLAG_WATER_POLLUTION_FIXED		; $790e
	call checkGlobalFlag		; $7910
	pop hl			; $7913
	jr z, ++
	bit 0,b			; $7916
	jr nz, +++
	ld a,$08		; $791a
	rst_addDoubleIndex			; $791c
	jr ++
+
	ld a,(wDungeonIndex)		; $791f
	cp $07			; $7922
	jr nz, ++
	ld a,(wJabuWaterLevel)		; $7926
	and $03			; $7929
	cp $02			; $792b
	jr nz, ++
	ld a,(wActiveRoom)		; $792f
	cp $4c			; $7932
	jr z, +
	cp $4d			; $7936
	jr nz, ++
+
	ld a,$0b		; $793a
	rst_addDoubleIndex			; $793c
++
	ld a,(wActiveTilePos)		; $793d
	ld b,a			; $7940
	swap a			; $7941
	and $0f			; $7943
	rst_addDoubleIndex			; $7945
	ld a,b			; $7946
	and $0f			; $7947
	xor $0f			; $7949
	call checkFlag		; $794b
	jr nz,++++
	scf			; $7950
	jr ++++
+++
	ld a,(wAreaFlags)		; $7953
	and $01			; $7956
	jr z, ++++
	scf			; $795a
++++
	rl c			; $795b
	ret			; $795d

underWaterSurfaceTable: ; 795e
	.dw underWaterSurfaceTableGroup0
	.dw underWaterSurfaceTableGroup1
	.dw underWaterSurfaceTableGroup2
	.dw underWaterSurfaceTableGroup3
	.dw underWaterSurfaceTableGroup4
	.dw underWaterSurfaceTableGroup5
	.dw underWaterSurfaceTableGroup6
	.dw underWaterSurfaceTableGroup7

; Format: room pointer

underWaterSurfaceTableGroup0: ; 796e
underWaterSurfaceTableGroup1:
underWaterSurfaceTableGroup2:
underWaterSurfaceTableGroup6:
underWaterSurfaceTableGroup7:
	.db $90
	.dw underWaterSurfaceData_7a47

	.db $a0
	.dw underWaterSurfaceData_7a47

	.db $ac
	.dw underWaterSurfaceData_7a47

	.db $ba
	.dw underWaterSurfaceData_7a47

	.db $bb
	.dw underWaterSurfaceData_7a47

	.db $bc
	.dw underWaterSurfaceData_7a47

	.db $ca
	.dw underWaterSurfaceData_7a47

	.db $cb
	.dw underWaterSurfaceData_7a47

	.db $cc
	.dw underWaterSurfaceData_7a47

	.db $da
	.dw underWaterSurfaceData_7a47

	.db $db
	.dw underWaterSurfaceData_7a47

	.db $9c
	.dw underWaterSurfaceData_7a57

	.db $a1
	.dw underWaterSurfaceData_7a67

	.db $a2
	.dw underWaterSurfaceData_7a87

	.db $a3
	.dw underWaterSurfaceData_7a97

	.db $a4
	.dw underWaterSurfaceData_7aa7

	.db $ab
	.dw underWaterSurfaceData_7ab7

	.db $b0
	.dw underWaterSurfaceData_7ac7

	.db $b1
	.dw underWaterSurfaceData_7ad7

	.db $b2
	.dw underWaterSurfaceData_7ae7

	.db $b3
	.dw underWaterSurfaceData_7af7

	.db $b4
	.dw underWaterSurfaceData_7b07

	.db $b5
	.dw underWaterSurfaceData_7b27

	.db $b6
	.dw underWaterSurfaceData_7b37

	.db $b7
	.dw underWaterSurfaceData_7b47

	.db $bd
	.dw underWaterSurfaceData_7b57

	.db $c1
	.dw underWaterSurfaceData_7b67

	.db $c2
	.dw underWaterSurfaceData_7b77

	.db $c4
	.dw underWaterSurfaceData_7b87

	.db $c7
	.dw underWaterSurfaceData_7b97

	.db $d0
	.dw underWaterSurfaceData_7ba7

	.db $d1
	.dw underWaterSurfaceData_7bb7

	.db $d2
	.dw underWaterSurfaceData_7bd7

	.db $d4
	.dw underWaterSurfaceData_7bf7

	.db $d5
	.dw underWaterSurfaceData_7c07

	.db $d7
	.dw underWaterSurfaceData_7c27

	.db $d8
	.dw underWaterSurfaceData_7c37

	.db $00

underWaterSurfaceTableGroup3: ; 79de
	.db $90
	.dw underWaterSurfaceData_7a47

	.db $a0
	.dw underWaterSurfaceData_7a47

	.db $e1
	.dw underWaterSurfaceData_7a47

	.db $0e
	.dw underWaterSurfaceData_7c47

	.db $a1
	.dw underWaterSurfaceData_7a67

	.db $a2
	.dw underWaterSurfaceData_7c67

	.db $b0
	.dw underWaterSurfaceData_7c77

	.db $b1
	.dw underWaterSurfaceData_7c87

	.db $b5
	.dw underWaterSurfaceData_7c97

	.db $b6
	.dw underWaterSurfaceData_7ca7

	.db $c1
	.dw underWaterSurfaceData_7b67

	.db $c2
	.dw underWaterSurfaceData_7cb7

	.db $c4
	.dw underWaterSurfaceData_7cc7

	.db $c5
	.dw underWaterSurfaceData_7cd7

	.db $c7
	.dw underWaterSurfaceData_7ce7

	.db $d0
	.dw underWaterSurfaceData_7ba7

	.db $d1
	.dw underWaterSurfaceData_7bb7

	.db $d2
	.dw underWaterSurfaceData_7cf7

	.db $d4
	.dw underWaterSurfaceData_7d17

	.db $d5
	.dw underWaterSurfaceData_7d27

	.db $d9
	.dw underWaterSurfaceData_7d47

	.db $e0
	.dw underWaterSurfaceData_7d57

	.db $e2
	.dw underWaterSurfaceData_7d67

	.db $8c
	.dw underWaterSurfaceData_7c57

	.db $d6
	.dw underWaterSurfaceData_7d37

	.db $00

underWaterSurfaceTableGroup4: ; 7a2a
	.db $c1
	.dw underWaterSurfaceData_7e53

	.db $00

underWaterSurfaceTableGroup5: ; 7a2e
	.db $4c
	.dw underWaterSurfaceData_7d77

	.db $4d
	.dw underWaterSurfaceData_7da3

	.db $4f
	.dw underWaterSurfaceData_7dcf

	.db $52
	.dw underWaterSurfaceData_7de5

	.db $53
	.dw underWaterSurfaceData_7dfb

	.db $2d
	.dw underWaterSurfaceData_7e3d

	.db $30
	.dw underWaterSurfaceData_7e11

	.db $35
	.dw underWaterSurfaceData_7e27

	.db $00

underWaterSurfaceData_7a47:
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
underWaterSurfaceData_7a57:
	.dw %1111111111000000
	.dw %0000000000000000
	.dw %0000000000000000
	.dw %0000000000000000
	.dw %0000000000000000
	.dw %0000000000000000
	.dw %0000000000000000
	.dw %1111111111000000
underWaterSurfaceData_7a67:
	.dw %1111111111000010
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
underWaterSurfaceData_7a77:
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111110000000
	.dw %1111111111000000
underWaterSurfaceData_7a87:
	.dw %1111111111000001
	.dw %1111000001000000
	.dw %1110000001000000
	.dw %1110000001000000
	.dw %1100000111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
underWaterSurfaceData_7a97:
	.dw %1111111111000001
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111110000000
	.dw %1111111110000000
	.dw %1111111111000000
	.dw %1111100001000000
	.dw %1111111111000000
underWaterSurfaceData_7aa7:
	.dw %1111111111000001
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %0000111111000000
	.dw %0000111111000000
	.dw %1000111111000000
	.dw %1000000001000000
	.dw %1111111111000000
underWaterSurfaceData_7ab7:
	.dw %0000000011000000
	.dw %0000000011000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
underWaterSurfaceData_7ac7:
	.dw %1111111111000000
	.dw %1101111011000000
	.dw %0000000000000000
	.dw %0000000000000000
	.dw %0000000000000000
	.dw %0000000000000000
	.dw %0011000000000000
	.dw %1111111111000000
underWaterSurfaceData_7ad7:
	.dw %1101111011000000
	.dw %1000110001000000
	.dw %0000000001000000
	.dw %0000010001000000
	.dw %0000000001000000
	.dw %0000000001000000
	.dw %0001111111000000
	.dw %1001111111000000
underWaterSurfaceData_7ae7:
	.dw %1111111111000001
	.dw %1111111111000000
	.dw %1111110111000000
	.dw %1111110111000000
	.dw %1111110011000000
	.dw %1111110000000000
	.dw %1111110000000000
	.dw %1111111111000000
underWaterSurfaceData_7af7:
	.dw %1111111111000001
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111110001000000
	.dw %0011110001000000
	.dw %0011110001000000
	.dw %1011110001000000
underWaterSurfaceData_7b07:
	.dw %1111111111000010
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111110001000000
	.dw %1111111111000000
underWaterSurfaceData_7b17:
	.dw %0000000000000000
	.dw %0000000000000000
	.dw %0000011111000000
	.dw %1000011111000000
	.dw %1000011111000000
	.dw %1000011111000000
	.dw %1000010001000000
	.dw %1110000001000000
underWaterSurfaceData_7b27:
	.dw %1111111111000001
	.dw %1001111111000000
	.dw %1000011111000000
	.dw %1000001111000000
	.dw %1000000111000000
	.dw %1000000111000000
	.dw %1000000111000000
	.dw %1111111111000000
underWaterSurfaceData_7b37:
	.dw %1000000000000001
	.dw %1000000000000000
	.dw %1000001111000000
	.dw %1000001111000000
	.dw %1000001000000000
	.dw %1000001000000000
	.dw %1000001000000000
	.dw %1100011000000000
underWaterSurfaceData_7b47:
	.dw %0000000000000000
	.dw %0000000000000000
	.dw %0000000000000000
	.dw %0001000000000000
	.dw %0000000000000000
	.dw %0000000000000000
	.dw %0000000000000000
	.dw %0000000000000000
underWaterSurfaceData_7b57:
	.dw %1111111001000000
	.dw %1111111001000000
	.dw %1111111001000000
	.dw %1111111101000000
	.dw %1111111101000000
	.dw %1111111101000000
	.dw %1111111101000000
	.dw %1111111101000000
underWaterSurfaceData_7b67:
	.dw %1001111111000000
	.dw %1001111111000000
	.dw %1001111111000000
	.dw %0001111111000000
	.dw %0001111111000000
	.dw %0000000000000000
	.dw %0000000000000000
	.dw %1111100000000000
underWaterSurfaceData_7b77:
	.dw %1111111111000001
	.dw %1000000001000000
	.dw %1000000001000000
	.dw %1000000001000000
	.dw %1000000001000000
	.dw %1111100001000000
	.dw %1111100001000000
	.dw %1111111111000000
underWaterSurfaceData_7b87:
	.dw %1111111111000000
	.dw %1000000001000000
	.dw %1000000001000000
	.dw %0000000111000000
	.dw %0000100111000000
	.dw %0000000111000000
	.dw %0000000001000000
	.dw %1111111111000000
underWaterSurfaceData_7b97:
	.dw %0011111111000000
	.dw %0011001111000000
	.dw %0011001111000000
	.dw %1110001111000000
	.dw %1110000011000000
	.dw %1111111111000000
	.dw %0011111111000000
	.dw %0011111111000000
underWaterSurfaceData_7ba7:
	.dw %1111111001000000
	.dw %1111111000000000
	.dw %1111111000000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
underWaterSurfaceData_7bb7:
	.dw %1111100001000010
	.dw %0000000001000000
	.dw %0000000001000000
	.dw %1111000011000000
	.dw %1111000001000000
	.dw %1111000001000000
	.dw %1111000001000000
	.dw %1111111111000000
underWaterSurfaceData_7bc7:
	.dw %1111100001000000
	.dw %0000000001000000
	.dw %0000000001000000
	.dw %1111000011000000
	.dw %1111000001000000
	.dw %1111000000000000
	.dw %1111000000000000
	.dw %1111111111000000
underWaterSurfaceData_7bd7:
	.dw %1111111111000010
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
underWaterSurfaceData_7be7:
	.dw %1111100001000000
	.dw %1111100001000000
	.dw %1111100001000000
	.dw %1111100001000000
	.dw %1000000000000000
	.dw %0000000100000000
	.dw %0000000000000000
	.dw %1111111111000000
underWaterSurfaceData_7bf7:
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1011100111000000
	.dw %1011100111000000
	.dw %1010000111000000
	.dw %0001111000000000
	.dw %0000000000000000
	.dw %1111111111000000
underWaterSurfaceData_7c07:
	.dw %1111111111000010
	.dw %1111111111000000
	.dw %1100111101000000
	.dw %1100111101000000
	.dw %1110001100000000
	.dw %0001111000000000
	.dw %0000001000000000
	.dw %1111111111000000
underWaterSurfaceData_7c17:
	.dw %1111111111000010
	.dw %1111111111000000
	.dw %1100111001000000
	.dw %1100111001000000
	.dw %1110001000000000
	.dw %0001110000000000
	.dw %0000000000000000
	.dw %1111111111000000
underWaterSurfaceData_7c27:
	.dw %0011111111000000
	.dw %0011111100000000
	.dw %0011111100000000
	.dw %1111111100000000
	.dw %1111111111000000
	.dw %0000000000000000
	.dw %0000000000000000
	.dw %0000000000000000
underWaterSurfaceData_7c37:
	.dw %1110001000000000
	.dw %0010001000000000
	.dw %0010001000000000
	.dw %0011111000000000
	.dw %1111111000000000
	.dw %0000000000000000
	.dw %0000000000000000
	.dw %0000000000000000
underWaterSurfaceData_7c47:
	.dw %1111111111000000
	.dw %1001111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
underWaterSurfaceData_7c57:
	.dw %0000000000000000
	.dw %0000000000000000
	.dw %0000000000000000
	.dw %0000000000000000
	.dw %0000010000000000
	.dw %0000000000000000
	.dw %0000000000000000
	.dw %0000000000000000
underWaterSurfaceData_7c67:
	.dw %1111111111000001
	.dw %1100011000000000
	.dw %1100000000000000
	.dw %1110000000000000
	.dw %1111000001000000
	.dw %1111100011000000
	.dw %1111111111000000
	.dw %1111111111000000
underWaterSurfaceData_7c77:
	.dw %1111111111000000
	.dw %1101111011000000
	.dw %1000000000000000
	.dw %1000000000000000
	.dw %1000000000000000
	.dw %1000000000000000
	.dw %1001000000000000
	.dw %1111111111000000
underWaterSurfaceData_7c87:
	.dw %1101111011000000
	.dw %1000110001000000
	.dw %0000000001000000
	.dw %0000010001000000
	.dw %0000000001000000
	.dw %0000000001000000
	.dw %0001111111000000
	.dw %1001111111000000
underWaterSurfaceData_7c97:
	.dw %1111111111000001
	.dw %1111100001000000
	.dw %1111100001000000
	.dw %1111100001000000
	.dw %1111100001000000
	.dw %1111100001000000
	.dw %1000000001000000
	.dw %1111111111000000
underWaterSurfaceData_7ca7:
	.dw %1000000000000001
	.dw %1000000000000000
	.dw %1001111111000000
	.dw %1001000000000000
	.dw %1001000000000000
	.dw %1001000000000000
	.dw %1001000000000000
	.dw %1101000000000000
underWaterSurfaceData_7cb7:
	.dw %1000001111000000
	.dw %1000000001000000
	.dw %1000000001000000
	.dw %1000000001000000
	.dw %1000000001000000
	.dw %1000011111000000
	.dw %1000011111000000
	.dw %1111111111000000
underWaterSurfaceData_7cc7:
	.dw %1110000001000000
	.dw %1000000001000000
	.dw %1000000001000000
	.dw %0000000000000000
	.dw %0000100000000000
	.dw %0000000000000000
	.dw %0000000001000000
	.dw %1111111111000000
underWaterSurfaceData_7cd7:
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1000001111000000
	.dw %0011111111000000
	.dw %0011111111000000
	.dw %0011111111000000
	.dw %1000000001000000
	.dw %1111111111000000
underWaterSurfaceData_7ce7:
	.dw %0000000000000000
	.dw %0000000000000000
	.dw %0000000000000000
	.dw %0000000000000000
	.dw %0000001000000000
	.dw %0000000000000000
	.dw %0000000000000000
	.dw %0000000000000000
underWaterSurfaceData_7cf7:
	.dw %1111111111000010
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
underWaterSurfaceData_7d07:
	.dw %1000011111000000
	.dw %1000011111000000
	.dw %1000011111000000
	.dw %1000011111000000
	.dw %1000000000000000
	.dw %0000000100000000
	.dw %0000000000000000
	.dw %1111111111000000
underWaterSurfaceData_7d17:
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1010011111000000
	.dw %1000011111000000
	.dw %1010000011000000
	.dw %0011011000000000
	.dw %0000000000000000
	.dw %1111111111000000
underWaterSurfaceData_7d27:
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1100001111000000
	.dw %1100001111000000
	.dw %1110001000000000
	.dw %0001110000000000
	.dw %0000000000000000
	.dw %1111111111000000
underWaterSurfaceData_7d37:
	.dw %0000000000000000
	.dw %0000000000000000
	.dw %0000000000000000
	.dw %0000000000000000
	.dw %0000000000000000
	.dw %0000010000000000
	.dw %0000000000000000
	.dw %0000000000000000
underWaterSurfaceData_7d47:
	.dw %1001111111000000
	.dw %1001111111000000
	.dw %0100111111000000
	.dw %1001111111000000
	.dw %0101111111000000
	.dw %1001111001000000
	.dw %1100010011000000
	.dw %0111111100000000
underWaterSurfaceData_7d57:
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1100111111000000
	.dw %1100111111000000
	.dw %1111111111000000
underWaterSurfaceData_7d67:
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111001000000
	.dw %1111111001000000
	.dw %1111111111000000
	.dw %1111111111000000
	.dw %1111111111000000


underWaterSurfaceData_7d77:
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111111110111
	.dw %1111111111110111
	.dw %1111111111110111
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111111111111

	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111100000111111
	.dw %1111100000111111
	.dw %1111100000110111
	.dw %1111100000110111
	.dw %1111100000110111
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111111111111

underWaterSurfaceData_7da3:
	.dw %1111111111111111
	.dw %1111111111100111
	.dw %1111111111100111
	.dw %1111111111100111
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111111111111

	.dw %1111111111111111
	.dw %1100000111100111
	.dw %1100000111100111
	.dw %1100000111100111
	.dw %1100000111111111
	.dw %1100000111111111
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111111111111


underWaterSurfaceData_7dcf:
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1001111111110011
	.dw %1000000000000011
	.dw %1100000000000111
	.dw %1100001110000111
	.dw %1100000000000111
	.dw %1000000000000011
	.dw %1001111111110011
	.dw %1111111111111111
	.dw %1111111111111111

underWaterSurfaceData_7de5:
	.dw %1111111111111111
	.dw %1111111111100111
	.dw %1111111111100111
	.dw %1111111111100111
	.dw %1110000000000111
	.dw %1110000000000111
	.dw %1110000000000111
	.dw %1110000000000111
	.dw %1110000000000111
	.dw %1111111111111111
	.dw %1111111111111111


underWaterSurfaceData_7dfb:
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1100011111111111
	.dw %1100011111111111
	.dw %1100011111111111
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111111111111

underWaterSurfaceData_7e11:
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1000000111111111
	.dw %1000000111111111
	.dw %1111111111111111

underWaterSurfaceData_7e27:
	.dw %1111111111111111
	.dw %1111111111110011
	.dw %1111111111110011
	.dw %1111111111110011
	.dw %1111111111110011
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111111111111

underWaterSurfaceData_7e3d:
	.dw %1111111111111111
	.dw %1000000000000011
	.dw %1000000000000011
	.dw %1000000000000011
	.dw %1000010101000011
	.dw %1000011111000011
	.dw %1000010101000011
	.dw %1000000000000011
	.dw %1000000000000011
	.dw %1000000000000011
	.dw %1111111111111111

underWaterSurfaceData_7e53:
	.dw %1111111111111111
	.dw %1111111001111111
	.dw %1111111001111111
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111111111111
	.dw %1111111001111111
	.dw %1001111001110001
	.dw %1001111111110001
	.dw %1111111111111111

.ENDS

 m_section_free "Objects_3" namespace "objectData"

.include "objects/ages/helperData3.s"

.ends


.BANK $13 SLOT 1
.ORG 0

	.define BASE_OAM_DATA_BANK $13
	.export BASE_OAM_DATA_BANK

	.include "build/data/specialObjectOamData.s"
	.include "data/itemOamData.s"
	.include "build/data/enemyOamData.s"

.BANK $14 SLOT 1
.ORG 0

 m_section_superfree "Terrain_Effects" NAMESPACE "terrainEffects"

; @addr{4000}
shadowAnimation:
	.db $01
	.db $13 $04 $20 $08

; @addr{4005}
greenGrassAnimationFrame0:
	.db $02
	.db $11 $01 $24 $08
	.db $11 $07 $24 $08

; @addr{400e}
blueGrassAnimationFrame0:
	.db $02
	.db $11 $01 $24 $09
	.db $11 $07 $24 $09

; @addr{4017}
_puddleAnimationFrame0:
	.db $02
	.db $16 $03 $22 $08
	.db $16 $05 $22 $28

; @addr{4020}
orangeGrassAnimationFrame0:
	.db $02
	.db $11 $01 $24 $0b
	.db $11 $07 $24 $0b

; @addr{4029}
greenGrassAnimationFrame1:
	.db $02
	.db $11 $01 $24 $28
	.db $11 $07 $24 $28

; @addr{4032}
blueGrassAnimationFrame1:
	.db $02
	.db $11 $01 $24 $29
	.db $11 $07 $24 $29

; @addr{403b}
_puddleAnimationFrame1:
	.db $02
	.db $16 $02 $22 $08
	.db $16 $06 $22 $28

; @addr{4044}
orangeGrassAnimationFrame1:
	.db $02
	.db $11 $01 $24 $2b
	.db $11 $07 $24 $2b

; @addr{404d}
_puddleAnimationFrame2:
	.db $02
	.db $17 $01 $22 $08
	.db $17 $07 $22 $28

; @addr{4056}
_puddleAnimationFrame3:
	.db $02
	.db $18 $00 $22 $08
	.db $18 $08 $22 $28

; @addr{405f}
puddleAnimationFrames:
	.dw _puddleAnimationFrame0
	.dw _puddleAnimationFrame1
	.dw _puddleAnimationFrame2
	.dw _puddleAnimationFrame3

.ends

.include "build/data/interactionOamData.s"
.include "build/data/partOamData.s"


.include "code/bank15.s"


.BANK $16 SLOT 1
.ORG 0

 m_section_force Bank16 NAMESPACE bank16

;;
; @addr{4000}
func_4000:
	ldh a,(<hSerialInterruptBehaviour)	; $4000
	or a			; $4002
	ret z			; $4003
	ld a,($ff00+R_SVBK)	; $4004
	push af			; $4006
	ld a,$04		; $4007
	ld ($ff00+R_SVBK),a	; $4009
	push de			; $400b
	call $4036		; $400c
	pop de			; $400f
	ld a,($ff00+R_SC)	; $4010
	rlca			; $4012
	jr c,_label_16_001	; $4013
	ldh a,(<hSerialInterruptBehaviour)	; $4015
	cp $e0			; $4017
	jr z,_label_16_000	; $4019
	ld a,($d98b)		; $401b
	or a			; $401e
	jr nz,_label_16_001	; $401f
	ld a,($d983)		; $4021
	xor $01			; $4024
	ld ($d983),a		; $4026
	jr z,_label_16_001	; $4029
	ldh a,(<hSerialInterruptBehaviour)	; $402b
_label_16_000:
	and $81			; $402d
	call writeToSC		; $402f
_label_16_001:
	pop af			; $4032
	ld ($ff00+R_SVBK),a	; $4033
	ret			; $4035
	ldh a,(<hFFBE)	; $4036
	rst_jumpTable			; $4038
.dw $420d
.dw $420d
.dw $421e
.dw $4143
.dw $410e
	call $41dc		; $4043
	cp $80			; $4046
	ret z			; $4048
	ld a,($d981)		; $4049
	ld hl,$d9e5		; $404c
	rst_addAToHl			; $404f
	ld a,($d981)		; $4050
	or a			; $4053
	jr nz,_label_16_003	; $4054
	ld a,(hl)		; $4056
	or a			; $4057
	jr nz,_label_16_002	; $4058
	inc a			; $405a
	ld ($d98b),a		; $405b
	ret			; $405e
_label_16_002:
	ld ($d987),a		; $405f
	xor a			; $4062
	ld ($d982),a		; $4063
_label_16_003:
	inc a			; $4066
	ld ($d981),a		; $4067
	ld a,($d987)		; $406a
	dec a			; $406d
	ld ($d987),a		; $406e
	ldi a,(hl)		; $4071
	jr nz,_label_16_004	; $4072
	xor a			; $4074
	ld ($d988),a		; $4075
	ld a,($d982)		; $4078
_label_16_004:
	ld ($ff00+R_SB),a	; $407b
	ld hl,$d982		; $407d
	add (hl)		; $4080
	ld (hl),a		; $4081
	xor a			; $4082
	ld ($d98b),a		; $4083
	ret			; $4086
	ldh a,(<hSerialRead)	; $4087
	or a			; $4089
	ret z			; $408a
	ld a,$01		; $408b
	ld ($d98b),a		; $408d
	xor a			; $4090
	ld ($ff00+R_SB),a	; $4091
	ldh (<hSerialRead),a	; $4093
	ret			; $4095
	call $41dc		; $4096
	cp $80			; $4099
	jp z,serialFunc_0c7e		; $409b
	jp $4269		; $409e
	call $41dc		; $40a1
	jp serialFunc_0c7e		; $40a4
	xor a			; $40a7
	ld ($d98b),a		; $40a8
	call $41dc		; $40ab
	cp $80			; $40ae
	ret z			; $40b0
	ld a,($d981)		; $40b1
	ld b,a			; $40b4
	or a			; $40b5
	jr nz,_label_16_007	; $40b6
	ldh a,(<hSerialByte)	; $40b8
	cp $ff			; $40ba
	jr z,_label_16_005	; $40bc
	or a			; $40be
	jr nz,_label_16_006	; $40bf
_label_16_005:
	ld a,($d985)		; $40c1
	or a			; $40c4
	ret nz			; $40c5
	ld hl,$d984		; $40c6
	inc (hl)		; $40c9
	ret nz			; $40ca
	ld a,$86		; $40cb
	ldh (<hFFBD),a	; $40cd
	xor a			; $40cf
	ld ($d988),a		; $40d0
	ret			; $40d3
_label_16_006:
	ld ($d987),a		; $40d4
_label_16_007:
	ld hl,$d987		; $40d7
	dec (hl)		; $40da
	jr nz,_label_16_009	; $40db
	ldh a,(<hSerialByte)	; $40dd
	ld hl,$d982		; $40df
	cp (hl)			; $40e2
	jr z,_label_16_008	; $40e3
	ld a,$81		; $40e5
	ldh (<hFFBD),a	; $40e7
_label_16_008:
	xor a			; $40e9
	ld ($d988),a		; $40ea
	ld ($d984),a		; $40ed
	ld ($ff00+R_SB),a	; $40f0
	ret			; $40f2
_label_16_009:
	ld a,b			; $40f3
	ld de,$d9e5		; $40f4
	call addAToDe		; $40f7
	ld a,b			; $40fa
	inc a			; $40fb
	ld ($d981),a		; $40fc
	ldh a,(<hSerialByte)	; $40ff
	ld (de),a		; $4101
	ld hl,$d982		; $4102
	add (hl)		; $4105
	ld (hl),a		; $4106
	xor a			; $4107
	ld ($ff00+R_SB),a	; $4108
	ld ($d984),a		; $410a
	ret			; $410d
	ldh a,(<hFFBF)	; $410e
	rst_jumpTable			; $4110
.dw $440d
.dw $4280
.dw $4411
.dw $4280
.dw $4415
.dw $4280
.dw $438e
.dw $4087
.dw $42ee
.dw $4305
.dw $438e
.dw $4370
.dw $43c5
.dw $4305
.dw $438e
.dw $4329
.dw $4280
.dw $4096
.dw $434d
.dw $4280
.dw $438e
.dw $43f5
.dw $4280
.dw $4096
.dw $437b
	ldh a,(<hFFBF)	; $4143
	rst_jumpTable			; $4145
.dw $4176
.dw $4280
.dw $438e
.dw $4179
.dw $4280
.dw $438e
.dw $417d
.dw $4280
.dw $438e
.dw $43f5
.dw $4280
.dw $42a7
.dw $4280
.dw $40a1
.dw $4280
.dw $4096
.dw $42de
.dw $4280
.dw $438e
.dw $430e
.dw $43f5
.dw $4280
.dw $438e
.dw $437b
	xor a			; $4176
	jr _label_16_010		; $4177
	ld a,$01		; $4179
	jr _label_16_010		; $417b
	ld a,$02		; $417d
_label_16_010:
	ldh (<hActiveFileSlot),a	; $417f
	call loadFile		; $4181
	ldh (<hFF8B),a	; $4184
	call $4269		; $4186
	ld hl,$d9e5		; $4189
	ld a,$21		; $418c
	ldi (hl),a		; $418e
	ld c,a			; $418f
	ldh a,(<hFF8B)	; $4190
	ldi (hl),a		; $4192
	ldi (hl),a		; $4193
	add a			; $4194
	add c			; $4195
	ld c,a			; $4196
	ld a,(wLinkMaxHealth)		; $4197
	ldi (hl),a		; $419a
	ldi (hl),a		; $419b
	add a			; $419c
	add c			; $419d
	ld c,a			; $419e
	ld a,(wDeathCounter)		; $419f
	ldi (hl),a		; $41a2
	add c			; $41a3
	ld c,a			; $41a4
	ld a,(wDeathCounter+1)		; $41a5
	ldi (hl),a		; $41a8
	add c			; $41a9
	ld c,a			; $41aa
	ld a,(wFileIsLinkedGame)		; $41ab
	ldi (hl),a		; $41ae
	add c			; $41af
	ld c,a			; $41b0
	ld a,(wFileIsHeroGame)		; $41b1
	add a			; $41b4
	ld e,a			; $41b5
	ld a,($c614)		; $41b6
	or e			; $41b9
	ldi (hl),a		; $41ba
	add c			; $41bb
	ld c,a			; $41bc
	ld de,wGameID		; $41bd
	ld b,$16		; $41c0
_label_16_011:
	ld a,(de)		; $41c2
	ldi (hl),a		; $41c3
	add c			; $41c4
	ld c,a			; $41c5
	inc e			; $41c6
	dec b			; $41c7
	jr nz,_label_16_011	; $41c8
	ld a,$a1		; $41ca
	ldi (hl),a		; $41cc
	add c			; $41cd
	ld c,a			; $41ce
	ldh a,(<hActiveFileSlot)	; $41cf
	ld (hl),a		; $41d1
	add c			; $41d2
	ldi (hl),a		; $41d3
	ld a,$01		; $41d4
	ld ($d988),a		; $41d6
	jp $4049		; $41d9
	ldh a,(<hSerialRead)	; $41dc
	or a			; $41de
	jr nz,_label_16_014	; $41df
	ld a,($d985)		; $41e1
	or a			; $41e4
	jr nz,_label_16_012	; $41e5
	ld hl,$d989		; $41e7
	call decHlRef16WithCap		; $41ea
	jr z,_label_16_013	; $41ed
_label_16_012:
	pop af			; $41ef
	ret			; $41f0
_label_16_013:
	xor a			; $41f1
	ld ($d988),a		; $41f2
	ld a,$80		; $41f5
	ldh (<hFFBD),a	; $41f7
	ret			; $41f9
_label_16_014:
	ld ($d988),a		; $41fa
	xor a			; $41fd
	ldh (<hSerialRead),a	; $41fe
	ldh (<hFFBD),a	; $4200
_label_16_015:
	ld a,$b4		; $4202
	ld ($d989),a		; $4204
	ld a,$00		; $4207
	ld ($d98a),a		; $4209
	ret			; $420c
	ldh a,(<hFFBF)	; $420d
	rst_jumpTable			; $420f
.dw $4186
.dw $4280
.dw $438e
.dw $4293
.dw $4280
.dw $4096
.dw $422f
	ldh a,(<hFFBF)	; $421e
	rst_jumpTable			; $4220
.dw $4293
.dw $4280
.dw $4096
.dw $4186
.dw $4280
.dw $438e
.dw $422f
	call serialFunc_0c7e		; $422f
	xor a			; $4232
	ldh (<hFFBD),a	; $4233
	call $44ec		; $4235
	jr z,_label_16_017	; $4238
	ld hl,wGameID		; $423a
	ld a,(w4RingFortuneStuff)		; $423d
	add (hl)		; $4240
	and $7f			; $4241
	ld b,$00		; $4243
	and $7c			; $4245
	jr z,_label_16_016	; $4247
	inc b			; $4249
	and $60			; $424a
	jr z,_label_16_016	; $424c
	inc b			; $424e
_label_16_016:
	inc l			; $424f
	ld c,(hl)		; $4250
	ld a,b			; $4251
	ld hl,$4503		; $4252
	rst_addAToHl			; $4255
	ld a,(hl)		; $4256
	rst_addAToHl			; $4257
	ld a,($d98e)		; $4258
	add c			; $425b
	and $07			; $425c
	rst_addAToHl			; $425e
	ld a,(hl)		; $425f
	ld (w4RingFortuneStuff),a		; $4260
	ret			; $4263
_label_16_017:
	ld a,$84		; $4264
	ldh (<hFFBD),a	; $4266
	ret			; $4268
_label_16_018:
	ldh a,(<hFFBF)	; $4269
	inc a			; $426b
	ldh (<hFFBF),a	; $426c
_label_16_019:
	xor a			; $426e
	ld ($d981),a		; $426f
	ldh (<hFFBD),a	; $4272
	ld ($d982),a		; $4274
	ld ($d984),a		; $4277
	inc a			; $427a
	ld ($d988),a		; $427b
	jr _label_16_015		; $427e
	call $4043		; $4280
	call $44d7		; $4283
	ld a,($d986)		; $4286
	or a			; $4289
	jr z,_label_16_018	; $428a
	ldh a,(<hFFBF)	; $428c
	dec a			; $428e
	ldh (<hFFBF),a	; $428f
	jr _label_16_019		; $4291
	call $40a7		; $4293
	call $44d7		; $4296
	ld hl,w4RingFortuneStuff		; $4299
	ld de,$d9ee		; $429c
	ld b,$07		; $429f
	call copyMemoryReverse		; $42a1
	jp $43f5		; $42a4
	ld a,($d981)		; $42a7
	or a			; $42aa
	ld a,$00		; $42ab
	jr nz,_label_16_020	; $42ad
	inc a			; $42af
_label_16_020:
	ld ($d985),a		; $42b0
	call $40a7		; $42b3
	ld a,($d988)		; $42b6
	or a			; $42b9
	ret nz			; $42ba
	ld a,($d9e6)		; $42bb
	cp $c0			; $42be
	jr nz,_label_16_021	; $42c0
	jp $43f5		; $42c2
_label_16_021:
	cp $b0			; $42c5
	jp nz,$43e0		; $42c7
	ld a,($d9e7)		; $42ca
	ldh (<hActiveFileSlot),a	; $42cd
	cp $03			; $42cf
	jp nc,serialFunc_0c7e		; $42d1
	call loadFile		; $42d4
	ld a,$0d		; $42d7
	ldh (<hFFBF),a	; $42d9
	jp $43f5		; $42db
	call $4269		; $42de
	ld hl,w4RingFortuneStuff		; $42e1
	ld de,wRingsObtained		; $42e4
	ld b,$08		; $42e7
	call copyMemoryReverse		; $42e9
	jr _label_16_023		; $42ec
	call $4269		; $42ee
	ld hl,$d9e5		; $42f1
	ld a,$03		; $42f4
	ldi (hl),a		; $42f6
	ld a,$c0		; $42f7
	ldi (hl),a		; $42f9
	ld a,$c3		; $42fa
	ld (hl),a		; $42fc
	ld a,$01		; $42fd
	ld ($d988),a		; $42ff
	jp $4049		; $4302
	call $4043		; $4305
	call $44d7		; $4308
	jp $4269		; $430b
	call $40a7		; $430e
	call $44d7		; $4311
	ldh a,(<hFFBD)	; $4314
	cp $81			; $4316
	jp z,$4269		; $4318
	ld hl,w4RingFortuneStuff		; $431b
	ld de,$d9e6		; $431e
	ld b,$08		; $4321
	call copyMemoryReverse		; $4323
	jp $4269		; $4326
	call $40a7		; $4329
	call $44d7		; $432c
	ld hl,wRingsObtained		; $432f
	ld de,$d9e6		; $4332
	ld b,$08		; $4335
_label_16_022:
	ld a,(de)		; $4337
	or (hl)			; $4338
	ld (de),a		; $4339
	inc hl			; $433a
	inc de			; $433b
	dec b			; $433c
	jr nz,_label_16_022	; $433d
	ld hl,w4RingFortuneStuff		; $433f
	ld de,$d9e6		; $4342
	ld b,$08		; $4345
	call copyMemoryReverse		; $4347
	jp $43f5		; $434a
	call $4269		; $434d
_label_16_023:
	ld a,$0a		; $4350
	ld c,a			; $4352
	ld ($d9e5),a		; $4353
	ld de,$d9e6		; $4356
	ld hl,w4RingFortuneStuff		; $4359
	ld b,$08		; $435c
_label_16_024:
	ldi a,(hl)		; $435e
	ld (de),a		; $435f
	inc de			; $4360
	add c			; $4361
	ld c,a			; $4362
	dec b			; $4363
	jr nz,_label_16_024	; $4364
	ld a,c			; $4366
	ld (de),a		; $4367
	ld a,$01		; $4368
	ld ($d988),a		; $436a
	jp $4049		; $436d
	call $41dc		; $4370
	cp $80			; $4373
	jp z,serialFunc_0c7e		; $4375
	jp serialFunc_0c7e		; $4378
	call serialFunc_0c7e		; $437b
	ldh (<hFFBD),a	; $437e
	ld de,w4RingFortuneStuff		; $4380
	ld hl,wRingsObtained		; $4383
	ld b,$08		; $4386
	call copyMemoryReverse		; $4388
	jp saveFile		; $438b
	call $439a		; $438e
	call $44d7		; $4391
	call $4269		; $4394
	jp $4036		; $4397
	call $40a7		; $439a
	ld a,($d988)		; $439d
	or a			; $43a0
	ret nz			; $43a1
	ldh a,(<hFFBD)	; $43a2
	or a			; $43a4
	jr z,_label_16_025	; $43a5
	pop af			; $43a7
	jp serialFunc_0c7e		; $43a8
_label_16_025:
	ld a,($d9e6)		; $43ab
	cp $b1			; $43ae
	jr nz,_label_16_026	; $43b0
	xor a			; $43b2
	ld ($d986),a		; $43b3
	ldh a,(<hFFBF)	; $43b6
	sub $02			; $43b8
	ldh (<hFFBF),a	; $43ba
	ret			; $43bc
_label_16_026:
	cp $b0			; $43bd
	ret z			; $43bf
	ld a,$82		; $43c0
	ldh (<hFFBD),a	; $43c2
	ret			; $43c4
	call $4269		; $43c5
	ld hl,$d9e5		; $43c8
	ld a,$04		; $43cb
	ldi (hl),a		; $43cd
	ld a,$b0		; $43ce
	ldi (hl),a		; $43d0
	ld a,(wTmpcbbc)		; $43d1
	ldi (hl),a		; $43d4
	add $b4			; $43d5
	ldi (hl),a		; $43d7
	ld a,$01		; $43d8
	ld ($d988),a		; $43da
	jp $4049		; $43dd
_label_16_027:
	ld hl,$4500		; $43e0
	ld a,($d986)		; $43e3
	inc a			; $43e6
	ld ($d986),a		; $43e7
	cp $05			; $43ea
	jr c,_label_16_028	; $43ec
	ld a,$80		; $43ee
	ldh (<hFFBD),a	; $43f0
	jp serialFunc_0c7e		; $43f2
	xor a			; $43f5
	ld ($d986),a		; $43f6
	ld hl,$44fd		; $43f9
_label_16_028:
	call $4269		; $43fc
	ld a,(hl)		; $43ff
	ld b,a			; $4400
	ld de,$d9e5		; $4401
_label_16_029:
	ldi a,(hl)		; $4404
	ld (de),a		; $4405
	inc de			; $4406
	dec b			; $4407
	jr nz,_label_16_029	; $4408
	jp $4049		; $440a
	ld a,$00		; $440d
	jr _label_16_030		; $440f
	ld a,$01		; $4411
	jr _label_16_030		; $4413
	ld a,$02		; $4415
_label_16_030:
	ldh (<hFF8B),a	; $4417
	call $40a7		; $4419
	call $44d7		; $441c
	ldh a,(<hFF8B)	; $441f
	ld hl,$da05		; $4421
	jr nz,_label_16_027	; $4424
	swap a			; $4426
	rrca			; $4428
	ld hl,$d780		; $4429
	rst_addAToHl			; $442c
	ld de,$d9e6		; $442d
	ld b,$08		; $4430
_label_16_031:
	ld a,(de)		; $4432
	ldi (hl),a		; $4433
	inc de			; $4434
	dec b			; $4435
	jr nz,_label_16_031	; $4436
	ldh a,(<hFF8B)	; $4438
	add a			; $443a
	ld e,a			; $443b
	add a			; $443c
	add e			; $443d
	ld hl,w4NameBuffer		; $443e
	rst_addAToHl			; $4441
	ld de,$d9f0		; $4442
	ld b,$06		; $4445
	call copyMemoryReverse		; $4447
	ldh a,(<hFF8B)	; $444a
	inc a			; $444c
	ld hl,w4RingFortuneStuff		; $444d
	ld bc,$0016		; $4450
_label_16_032:
	dec a			; $4453
	jr z,_label_16_033	; $4454
	add hl,bc		; $4456
	jr _label_16_032		; $4457
_label_16_033:
	ld b,$16		; $4459
	ld de,$d9ee		; $445b
	call copyMemoryReverse		; $445e
	ld a,(wOpenedMenuType)		; $4461
	cp $08			; $4464
	jr nz,_label_16_034	; $4466
	ld de,$d9ee		; $4468
	call $44ef		; $446b
	jr nz,_label_16_035	; $446e
	ld hl,$da00		; $4470
	ldi a,(hl)		; $4473
	or (hl)			; $4474
	inc l			; $4475
	or (hl)			; $4476
	jr z,_label_16_035	; $4477
	jp $43f5		; $4479
_label_16_034:
	ld a,($da04)		; $447c
	cp $a0			; $447f
	jr nz,_label_16_035	; $4481
	ld a,($da02)		; $4483
	or a			; $4486
	jr z,_label_16_035	; $4487
	jp $43f5		; $4489
_label_16_035:
	ldh a,(<hFF8B)	; $448c
	ld d,$00		; $448e
	swap a			; $4490
	rrca			; $4492
	add d			; $4493
	ld hl,$d780		; $4494
	rst_addAToHl			; $4497
	set 7,(hl)		; $4498
	ldh a,(<hFF8B)	; $449a
	add a			; $449c
	ld e,a			; $449d
	add a			; $449e
	add e			; $449f
	ld hl,w4NameBuffer		; $44a0
	rst_addAToHl			; $44a3
	ld b,$06		; $44a4
	call clearMemory		; $44a6
	jp $43f5		; $44a9

;;
; @addr{44ac}
func_44ac:
	ld a,($ff00+R_SVBK)	; $44ac
	push af			; $44ae
	ld a,$04		; $44af
	ld ($ff00+R_SVBK),a	; $44b1
	xor a			; $44b3
	ld hl,$d980		; $44b4
	ldi (hl),a		; $44b7
	ldi (hl),a		; $44b8
	ldi (hl),a		; $44b9
	ldi (hl),a		; $44ba
	ldi (hl),a		; $44bb
	ldi (hl),a		; $44bc
	ldi (hl),a		; $44bd
	ldh (<hFFBE),a	; $44be
	ldh (<hFFBF),a	; $44c0
	ldh (<hFFBD),a	; $44c2
	call $4202		; $44c4
	ld a,$e1		; $44c7
	ld ($ff00+R_SB),a	; $44c9
	ld a,$80		; $44cb
	ld ($d988),a		; $44cd
	call writeToSC		; $44d0
	pop af			; $44d3
	ld ($ff00+R_SVBK),a	; $44d4
	ret			; $44d6

	ld a,($d988)		; $44d7
	or a			; $44da
	jr z,_label_16_036	; $44db
	pop af			; $44dd
	ret			; $44de
_label_16_036:
	ldh a,(<hFFBD)	; $44df
	or a			; $44e1
	ret z			; $44e2
	cp $81			; $44e3
	jp z,$43e0		; $44e5
	pop af			; $44e8
	jp serialFunc_0c7e		; $44e9
	ld de,w4RingFortuneStuff		; $44ec
	ld hl,wGameID		; $44ef
	ld b,$07		; $44f2
_label_16_037:
	ld a,(de)		; $44f4
	cp (hl)			; $44f5
	ret nz			; $44f6
	inc de			; $44f7
	inc l			; $44f8
	dec b			; $44f9
	jr nz,_label_16_037	; $44fa
	ret			; $44fc
	inc bc			; $44fd
	or b			; $44fe
	or e			; $44ff
	inc bc			; $4500
	or c			; $4501
	or h			; $4502
	inc bc			; $4503
	ld a,(bc)		; $4504
	ld de,$2e0f		; $4505
	ld l,$30		; $4508
	ld sp,$0f32		; $450a
	dec e			; $450d
	dec sp			; $450e
	inc d			; $450f
	inc h			; $4510
	inc h			; $4511
	ldd a,(hl)		; $4512
	dec sp			; $4513
	ld (de),a		; $4514
	inc a			; $4515
	ld a,(bc)		; $4516
	ld a,(de)		; $4517
	dec de			; $4518
	ld e,$1f		; $4519
	.db $20 $0a
	add hl,sp		; $451d

;;
; @param	d	Interaction index (should be of type INTERACID_TREASURE)
; @addr{451e}
interactionLoadTreasureData:
	ld e,Interaction.subid	; $451e
	ld a,(de)		; $4520
	ld e,Interaction.var30		; $4521
	ld (de),a		; $4523
	ld hl,treasureObjectData		; $4524
--
	call multiplyABy4		; $4527
	add hl,bc		; $452a
	bit 7,(hl)		; $452b
	jr z,+			; $452d

	inc hl			; $452f
	ldi a,(hl)		; $4530
	ld h,(hl)		; $4531
	ld l,a			; $4532
	ld e,Interaction.var03		; $4533
	ld a,(de)		; $4535
	jr --			; $4536
+
	; var31 = spawn mode
	ldi a,(hl)		; $4538
	ld b,a			; $4539
	swap a			; $453a
	and $07			; $453c
	ld e,Interaction.var31		; $453e
	ld (de),a		; $4540

	; var32 = collect mode
	ld a,b			; $4541
	and $07			; $4542
	inc e			; $4544
	ld (de),a		; $4545

	; var33 = ?
	ld a,b			; $4546
	and $08			; $4547
	inc e			; $4549
	ld (de),a		; $454a

	; var34 = parameter (value of 'c' for "giveTreasure")
	ldi a,(hl)		; $454b
	inc e			; $454c
	ld (de),a		; $454d

	; var35 = low text ID
	ldi a,(hl)		; $454e
	inc e			; $454f
	ld (de),a		; $4550

	; subid = graphics to use
	ldi a,(hl)		; $4551
	ld e,Interaction.subid		; $4552
	ld (de),a		; $4554
	ret			; $4555

; @addr{4556}
data_4556:
	.db $78 $45 $b9 $45 $26 $46 $97 $46
	.db $b2 $49 $f8 $48 $59 $49 $5a $4b
	.db $fb $4b $64 $4c $14 $47 $1b $4a
	.db $98 $4a $25 $4b $79 $47 $da $47
	.db $77 $48 $10 $ab $e0 $40 $01 $ab
	.db $ea $42 $01 $ab $f4 $44 $01 $ab
	.db $fe $46 $01 $ab $1c $48 $01 $ab
	.db $08 $4c $01 $ab $12 $4e $01 $ab
	.db $27 $56 $01 $d0 $e9 $0a $00 $d0
	.db $f1 $16 $00 $d0 $f9 $00 $00 $d0
	.db $01 $0c $00 $d0 $09 $24 $00 $d0
	.db $11 $0e $00 $d0 $17 $10 $00 $d0
	.db $1d $1e $00 $1b $a8 $e9 $4a $01
	.db $a8 $f2 $4c $01 $a8 $fc $4e $01
	.db $a8 $04 $4c $01 $a8 $16 $50 $01
	.db $a8 $20 $52 $01 $a8 $29 $4e $01
	.db $b8 $ee $6a $01 $b8 $f8 $6c $01
	.db $b8 $01 $6e $01 $b8 $09 $70 $01
	.db $b8 $13 $72 $01 $b8 $1c $74 $01
	.db $a8 $e0 $42 $01 $a8 $0e $42 $01
	.db $d0 $dc $30 $00 $d0 $e4 $28 $00
	.db $d0 $ec $24 $00 $d0 $f4 $28 $00
	.db $d0 $fc $14 $00 $d0 $04 $08 $00
	.db $e0 $04 $1a $00 $e0 $0c $00 $00
	.db $e0 $14 $14 $00 $e0 $1c $00 $00
	.db $e0 $23 $1a $00 $e0 $2b $1c $00
	.db $1c $a8 $e0 $52 $01 $a8 $e8 $54
	.db $01 $a8 $fa $50 $01 $a8 $04 $56
	.db $01 $a8 $0d $4e $01 $a8 $1e $4c
	.db $01 $a8 $28 $58 $01 $b8 $ee $6a
	.db $01 $b8 $f8 $6c $01 $b8 $01 $6e
	.db $01 $b8 $09 $70 $01 $b8 $13 $72
	.db $01 $b8 $1c $74 $01 $a8 $f1 $48
	.db $01 $a8 $15 $48 $01 $d0 $f4 $00
	.db $00 $d0 $fc $28 $00 $d0 $04 $0c
	.db $00 $d0 $0c $08 $00 $d0 $13 $1a
	.db $00 $f0 $e9 $30 $00 $f0 $f1 $34
	.db $00 $f0 $f9 $26 $00 $f0 $00 $00
	.db $00 $f0 $07 $1a $00 $f0 $0f $00
	.db $00 $f0 $17 $14 $00 $f0 $1f $00
	.db $00 $1f $d2 $f9 $0e $00 $d2 $01
	.db $1c $00 $d2 $09 $26 $00 $d2 $11
	.db $26 $00 $d2 $18 $00 $00 $06 $f4
	.db $26 $00 $06 $fc $08 $00 $06 $04
	.db $32 $00 $06 $0c $28 $00 $06 $14
	.db $14 $00 $06 $1c $00 $00 $d2 $f0
	.db $70 $08 $06 $ec $70 $08 $ec $ec
	.db $72 $08 $ec $f6 $30 $00 $ec $fe
	.db $00 $00 $ec $06 $18 $00 $ec $0e
	.db $00 $00 $ec $16 $06 $00 $ec $1e
	.db $00 $00 $a8 $03 $5a $01 $a8 $0b
	.db $52 $01 $a8 $14 $4e $01 $b0 $ee
	.db $5c $01 $a8 $f3 $40 $01 $b0 $fb
	.db $60 $01 $b8 $18 $6e $01 $b8 $ff
	.db $6e $01 $b8 $f7 $70 $01 $b8 $07
	.db $64 $01 $b8 $0f $68 $01 $19 $b0
	.db $e8 $4c $09 $b0 $f0 $4e $09 $b0
	.db $f8 $50 $09 $b0 $00 $52 $09 $b0
	.db $08 $54 $09 $b0 $10 $56 $09 $b0
	.db $18 $58 $09 $b0 $20 $5a $09 $d0
	.db $ed $00 $00 $d0 $f5 $30 $00 $d0
	.db $fd $00 $00 $d0 $05 $1a $00 $d0
	.db $0d $00 $00 $d0 $15 $0c $00 $d0
	.db $1d $10 $00 $ea $f4 $18 $00 $ea
	.db $fc $10 $00 $ea $04 $16 $00 $ea
	.db $0c $14 $00 $ea $14 $30 $00 $04
	.db $f4 $10 $00 $04 $fc $32 $00 $04
	.db $04 $28 $00 $04 $0c $18 $00 $04
	.db $14 $10 $00 $18 $ac $e0 $5a $01
	.db $ac $ea $4e $01 $ac $f5 $56 $01
	.db $ac $ff $54 $01 $ac $1e $52 $01
	.db $ac $29 $4e $01 $b4 $0a $60 $01
	.db $ac $14 $42 $01 $d0 $d0 $1a $00
	.db $d0 $d8 $1c $00 $d0 $e0 $22 $00
	.db $d0 $e6 $10 $00 $d0 $ec $26 $00
	.db $d0 $f3 $00 $00 $d0 $fb $14 $00
	.db $e0 $03 $0a $00 $e0 $0b $28 $00
	.db $e0 $12 $1a $00 $e0 $1b $00 $00
	.db $e0 $23 $18 $00 $e0 $29 $10 $00
	.db $e0 $2f $32 $00 $e0 $37 $28 $00
	.db $d0 $03 $00 $00 $27 $d0 $d4 $24
	.db $00 $d0 $dc $0e $00 $d0 $e2 $10
	.db $00 $d0 $e8 $0c $00 $d0 $f0 $08
	.db $00 $d0 $f8 $22 $00 $d0 $00 $28
	.db $00 $e0 $00 $18 $00 $e0 $0c $30
	.db $00 $e0 $06 $10 $00 $e0 $13 $00
	.db $00 $e0 $1b $18 $00 $e0 $23 $1c
	.db $00 $e0 $2b $26 $00 $e0 $33 $1c
	.db $00 $f8 $d7 $30 $00 $f8 $df $1c
	.db $00 $f8 $e7 $24 $00 $f8 $ef $0e
	.db $00 $f8 $f5 $10 $00 $f8 $fb $14
	.db $00 $f8 $01 $10 $00 $08 $01 $1c
	.db $00 $08 $09 $14 $00 $08 $11 $00
	.db $00 $08 $19 $18 $00 $08 $21 $1c
	.db $00 $08 $29 $26 $00 $08 $31 $1c
	.db $00 $b0 $e0 $12 $09 $b0 $e8 $14
	.db $09 $b0 $f0 $16 $09 $b0 $f8 $18
	.db $09 $b0 $00 $1a $09 $b0 $08 $1c
	.db $09 $b0 $10 $1e $09 $b0 $18 $20
	.db $09 $b0 $20 $22 $09 $b0 $28 $24
	.db $09 $20 $a8 $df $52 $01 $b0 $e8
	.db $7e $01 $a8 $f1 $52 $01 $a8 $0c
	.db $50 $01 $a8 $1f $5c $01 $a8 $29
	.db $52 $01 $b8 $fe $6a $01 $b8 $1b
	.db $6c $01 $a8 $fa $42 $01 $b0 $04
	.db $60 $01 $a8 $16 $48 $01 $b8 $08
	.db $60 $01 $d0 $d5 $0e $00 $d0 $db
	.db $10 $00 $d0 $e1 $22 $00 $d0 $e9
	.db $1c $00 $d0 $f1 $24 $00 $d0 $f9
	.db $0e $00 $d0 $ff $10 $00 $e0 $ff
	.db $30 $00 $e0 $06 $00 $00 $e0 $0e
	.db $18 $00 $e0 $16 $00 $00 $e0 $1e
	.db $28 $00 $e0 $26 $04 $00 $e0 $2e
	.db $0e $00 $e0 $34 $10 $00 $b8 $e3
	.db $62 $01 $b8 $ec $68 $01 $b8 $f6
	.db $64 $01 $b8 $11 $66 $01 $b8 $24
	.db $68 $01 $18 $d8 $ec $14 $00 $d8
	.db $f4 $34 $00 $d8 $fc $14 $00 $d8
	.db $04 $1c $00 $d8 $0c $1a $00 $d8
	.db $14 $06 $00 $d8 $1c $1c $00 $a8
	.db $e0 $38 $09 $a8 $e8 $3a $09 $a8
	.db $f0 $3c $09 $a8 $f8 $3e $09 $b0
	.db $00 $40 $09 $b0 $08 $42 $09 $a8
	.db $10 $44 $09 $a8 $18 $46 $09 $a8
	.db $20 $48 $09 $a8 $28 $4a $09 $c0
	.db $ec $7a $01 $c0 $f4 $6a $01 $b8
	.db $fc $5c $01 $c0 $04 $70 $01 $c0
	.db $0c $6e $01 $c0 $14 $6c $01 $c0
	.db $1c $68 $01 $16 $a8 $ec $5a $01
	.db $a8 $f4 $58 $01 $a8 $fc $4c $01
	.db $a8 $04 $46 $01 $a8 $0c $46 $01
	.db $a8 $14 $44 $01 $a8 $1c $4e $01
	.db $b8 $ec $6e $01 $b8 $f4 $60 $01
	.db $b8 $fc $62 $01 $b8 $04 $62 $01
	.db $b8 $0c $64 $01 $b8 $14 $68 $01
	.db $b8 $1c $76 $01 $d0 $e8 $1a $00
	.db $d0 $f0 $1c $00 $d0 $f8 $24 $00
	.db $d0 $00 $08 $00 $d0 $08 $26 $00
	.db $d0 $10 $00 $00 $d0 $18 $14 $00
	.db $d0 $20 $08 $00 $1a $d0 $e8 $18
	.db $00 $d0 $f0 $34 $00 $d0 $f8 $1a
	.db $00 $d0 $00 $00 $00 $d0 $08 $22
	.db $00 $d0 $10 $10 $00 $d0 $18 $26
	.db $00 $d0 $20 $00 $00 $e8 $e8 $14
	.db $00 $e8 $f0 $34 $00 $e8 $f8 $18
	.db $00 $e8 $00 $10 $00 $e8 $08 $32
	.db $00 $e8 $10 $28 $00 $e8 $18 $14
	.db $00 $e8 $20 $10 $00 $00 $ec $30
	.db $00 $00 $f3 $00 $00 $00 $fb $18
	.db $00 $00 $03 $00 $00 $00 $0b $24
	.db $00 $00 $13 $0e $00 $00 $19 $10
	.db $00 $00 $1f $26 $00 $00 $25 $00
	.db $00 $00 $e4 $72 $08 $1f $b4 $f8
	.db $08 $00 $b4 $00 $0c $00 $b4 $08
	.db $28 $00 $b4 $10 $04 $00 $b4 $18
	.db $0e $00 $b4 $20 $10 $00 $b4 $f0
	.db $34 $00 $b4 $e8 $18 $00 $ce $d8
	.db $18 $00 $ce $e0 $10 $00 $ce $e7
	.db $1a $00 $ce $f0 $1c $00 $ce $f8
	.db $22 $00 $ce $00 $28 $00 $de $00
	.db $00 $00 $de $08 $22 $00 $de $10
	.db $00 $00 $de $18 $14 $00 $de $20
	.db $00 $00 $de $28 $2c $00 $de $30
	.db $00 $00 $f4 $e4 $18 $00 $f4 $ec
	.db $10 $00 $f4 $f4 $14 $00 $f4 $fc
	.db $08 $00 $04 $fc $0a $00 $04 $04
	.db $28 $00 $04 $0c $14 $00 $04 $14
	.db $28 $00 $04 $1c $06 $00 $04 $24
	.db $00 $00 $23 $cc $e8 $1c $00 $cc
	.db $f0 $22 $00 $cc $f8 $10 $00 $cc
	.db $00 $0c $00 $cc $08 $10 $00 $cc
	.db $10 $1a $00 $cc $18 $00 $00 $cc
	.db $20 $16 $00 $f4 $f4 $24 $00 $f4
	.db $04 $1e $00 $f4 $fc $28 $00 $f4
	.db $0c $08 $00 $f4 $14 $22 $00 $04
	.db $e2 $18 $00 $04 $f2 $22 $00 $04
	.db $ea $00 $00 $04 $fa $10 $00 $04
	.db $02 $1c $00 $04 $0e $04 $00 $04
	.db $16 $16 $00 $04 $1e $28 $00 $04
	.db $26 $02 $00 $dc $de $5c $08 $dc
	.db $e6 $5e $08 $dc $ee $60 $08 $dc
	.db $f6 $62 $08 $dc $fe $64 $08 $dc
	.db $06 $66 $08 $dc $0e $68 $08 $dc
	.db $16 $6a $08 $dc $1e $6c $08 $dc
	.db $26 $6e $08 $b4 $fc $00 $00 $b4
	.db $04 $02 $00 $b4 $0c $28 $00 $0d
	.db $b8 $fc $1a $00 $b8 $04 $1c $00
	.db $b8 $0c $00 $00 $c8 $dd $06 $00
	.db $c8 $e5 $08 $00 $c8 $ed $02 $00
	.db $c8 $f5 $28 $00 $c8 $fd $0c $00
	.db $c8 $0c $24 $00 $c8 $14 $26 $00
	.db $c8 $1c $00 $00 $c8 $24 $0a $00
	.db $c8 $2c $0a $00 $28 $b0 $e0 $c0
	.db $09 $b0 $e8 $c2 $09 $b0 $f0 $c4
	.db $09 $b0 $f8 $c6 $09 $b0 $00 $c8
	.db $09 $b0 $08 $ca $09 $b0 $10 $cc
	.db $09 $b0 $18 $ce $09 $b0 $20 $d0
	.db $09 $b0 $28 $d2 $09 $ce $e0 $d4
	.db $09 $ce $e8 $d6 $09 $ce $f0 $d8
	.db $09 $ce $f8 $da $09 $ce $00 $dc
	.db $09 $ce $08 $de $09 $ce $10 $e0
	.db $09 $ce $18 $e2 $09 $ce $20 $e4
	.db $09 $de $e0 $e6 $09 $de $e8 $e8
	.db $09 $de $f0 $ea $09 $de $f8 $ec
	.db $09 $de $00 $ee $09 $de $08 $f0
	.db $09 $de $10 $f2 $09 $de $18 $f4
	.db $09 $de $20 $f6 $09 $de $28 $f8
	.db $09 $ce $28 $f8 $09 $f8 $e5 $02
	.db $00 $f8 $ed $10 $00 $f8 $f5 $16
	.db $00 $f8 $fd $16 $00 $08 $fd $26
	.db $00 $08 $05 $22 $00 $08 $0d $10
	.db $00 $08 $15 $1a $00 $08 $1d $08
	.db $00 $08 $24 $1a $00 $1a $a8 $f8
	.db $50 $01 $a8 $00 $52 $01 $b0 $08
	.db $7e $01 $a8 $10 $50 $01 $b8 $ec
	.db $6c $01 $b8 $f4 $6a $01 $b8 $fc
	.db $70 $01 $b8 $04 $76 $01 $b8 $0c
	.db $64 $01 $b8 $1c $6e $01 $b8 $14
	.db $68 $01 $d8 $d8 $26 $00 $d8 $e0
	.db $08 $00 $d8 $e8 $22 $00 $d8 $f0
	.db $08 $00 $d8 $f8 $24 $00 $d8 $00
	.db $00 $00 $e8 $fa $16 $00 $e8 $01
	.db $10 $00 $e8 $08 $16 $00 $e8 $10
	.db $16 $00 $e8 $18 $30 $00 $e8 $20
	.db $0c $00 $e8 $28 $22 $00 $e8 $30
	.db $08 $00 $e8 $37 $1a $00 $28 $a8
	.db $e0 $e6 $09 $a8 $e8 $e8 $09 $a8
	.db $f0 $ea $09 $a8 $f8 $ec $09 $a8
	.db $10 $f2 $09 $a8 $18 $f4 $09 $a8
	.db $20 $f6 $09 $a8 $28 $f8 $09 $a8
	.db $00 $fa $09 $a8 $08 $fc $09 $b8
	.db $e8 $7a $01 $b8 $f0 $74 $01 $b8
	.db $f8 $7a $01 $b8 $00 $72 $01 $b8
	.db $08 $6c $01 $b8 $20 $74 $01 $b8
	.db $28 $76 $01 $d0 $dc $16 $00 $d0
	.db $e4 $08 $00 $d0 $ec $24 $00 $d0
	.db $f4 $16 $00 $d0 $fc $10 $00 $d0
	.db $04 $08 $00 $d0 $14 $24 $00 $d0
	.db $1c $2c $00 $d0 $24 $00 $00 $d0
	.db $2c $1a $00 $f0 $dc $12 $00 $f0
	.db $e4 $08 $00 $f0 $ec $0a $00 $f0
	.db $f4 $0a $00 $f0 $04 $18 $00 $f0
	.db $0c $10 $00 $f0 $14 $16 $00 $f0
	.db $1c $16 $00 $f0 $24 $08 $00 $f0
	.db $2c $22 $00 $b8 $18 $6c $01 $b8
	.db $10 $fe $09 $b8 $e0 $fe $09 $26
	.db $e0 $10 $02 $01 $e0 $18 $04 $01
	.db $e0 $20 $06 $01 $e0 $28 $08 $01
	.db $f0 $08 $14 $01 $f0 $10 $16 $01
	.db $f0 $18 $18 $01 $f0 $20 $1a $01
	.db $f0 $28 $1c $01 $00 $08 $28 $01
	.db $00 $10 $2a $01 $00 $18 $2c $01
	.db $00 $20 $2e $01 $00 $28 $30 $01
	.db $10 $08 $3a $01 $10 $10 $3c $01
	.db $10 $18 $3e $01 $10 $20 $40 $01
	.db $10 $28 $42 $01 $20 $08 $00 $01
	.db $20 $10 $0a $01 $20 $18 $0c $01
	.db $20 $20 $0e $01 $20 $28 $10 $01
	.db $30 $08 $1e $01 $30 $10 $20 $01
	.db $30 $18 $22 $01 $30 $20 $24 $01
	.db $30 $28 $26 $01 $40 $08 $32 $01
	.db $40 $10 $34 $01 $40 $18 $36 $01
	.db $50 $08 $44 $01 $50 $10 $46 $01
	.db $50 $18 $48 $01 $40 $20 $38 $01
	.db $60 $08 $00 $01 $60 $10 $12 $01
	.db $26 $e0 $f8 $02 $21 $e0 $f0 $04
	.db $21 $e0 $e8 $06 $21 $e0 $e0 $08
	.db $21 $f0 $00 $14 $21 $f0 $f8 $16
	.db $21 $f0 $f0 $18 $21 $f0 $e8 $1a
	.db $21 $f0 $e0 $1c $21 $00 $00 $28
	.db $21 $00 $f8 $2a $21 $00 $f0 $2c
	.db $21 $00 $e8 $2e $21 $00 $e0 $30
	.db $21 $10 $00 $3a $21 $10 $f8 $3c
	.db $21 $10 $f0 $3e $21 $10 $e8 $40
	.db $21 $10 $e0 $42 $21 $20 $00 $00
	.db $21 $20 $f8 $0a $21 $20 $f0 $0c
	.db $21 $20 $e8 $0e $21 $20 $e0 $10
	.db $21 $30 $00 $1e $21 $30 $f8 $20
	.db $21 $30 $f0 $22 $21 $30 $e8 $24
	.db $21 $30 $e0 $26 $21 $40 $00 $32
	.db $21 $40 $f8 $34 $21 $40 $f0 $36
	.db $21 $50 $00 $44 $21 $50 $f8 $46
	.db $21 $50 $f0 $48 $21 $40 $e8 $38
	.db $21 $60 $00 $00 $21 $60 $f8 $12
	.db $21 $28 $44 $21 $00 $00 $44 $29
	.db $02 $00 $54 $29 $04 $00 $34 $1b
	.db $06 $00 $50 $d9 $08 $00 $08 $e0
	.db $0a $00 $30 $d8 $0c $01 $20 $d1
	.db $0e $00 $fb $ee $10 $02 $fb $f6
	.db $12 $02 $0b $e6 $14 $02 $0b $ee
	.db $16 $02 $1b $e6 $18 $02 $1b $ee
	.db $1a $02 $00 $48 $1c $01 $58 $40
	.db $1e $00 $10 $58 $22 $01 $00 $50
	.db $20 $01 $38 $50 $24 $01 $28 $50
	.db $26 $03 $28 $58 $28 $03 $16 $4a
	.db $2a $04 $16 $52 $2c $04 $e8 $d0
	.db $2e $01 $f8 $d0 $30 $04 $f8 $d8
	.db $32 $04 $00 $da $34 $02 $e8 $e5
	.db $36 $01 $20 $0f $38 $04 $20 $20
	.db $3a $04 $db $38 $40 $07 $db $40
	.db $42 $07 $e8 $35 $44 $07 $e8 $3d
	.db $46 $07 $fc $30 $48 $07 $f8 $38
	.db $4a $07 $00 $40 $4c $07 $18 $38
	.db $4e $07 $10 $40 $50 $07 $20 $40
	.db $52 $07 $12 $10 $08 $00 $0c $10
	.db $10 $02 $0c $10 $18 $04 $0c $20
	.db $08 $0c $0c $20 $10 $0e $0c $20
	.db $18 $10 $0c $31 $23 $06 $0d $31
	.db $2b $08 $0d $31 $3b $06 $2d $31
	.db $33 $08 $2d $41 $23 $06 $4d $41
	.db $2b $08 $4d $41 $3b $06 $6d $41
	.db $33 $08 $6d $2c $1d $0a $0d $2c
	.db $25 $0a $2d $4c $3a $0a $0d $4c
	.db $42 $0a $2d $0d $38 $d3 $02 $03
	.db $32 $f8 $0c $01 $f8 $d8 $10 $07
	.db $f8 $e0 $12 $07 $f8 $e8 $14 $07
	.db $f7 $f7 $16 $07 $22 $f8 $1a $03
	.db $1a $00 $1c $03 $11 $e2 $1e $00
	.db $11 $ea $20 $00 $01 $ea $22 $00
	.db $11 $f2 $26 $00 $01 $f2 $24 $00
	.db $07 $60 $f8 $00 $02 $48 $d3 $04
	.db $03 $40 $e0 $06 $07 $40 $e8 $08
	.db $07 $40 $f0 $0a $07 $42 $f8 $0e
	.db $01 $68 $e0 $18 $02 $1e $e8 $e8
	.db $00 $06 $e8 $f0 $02 $06 $f8 $e0
	.db $04 $06 $00 $d8 $06 $06 $08 $e8
	.db $08 $06 $08 $f0 $0a $06 $f8 $f6
	.db $0c $06 $10 $e0 $0e $06 $18 $e8
	.db $10 $07 $18 $da $12 $04 $18 $e2
	.db $14 $04 $08 $d0 $16 $06 $40 $d8
	.db $18 $06 $30 $f8 $1a $04 $28 $d3
	.db $1c $00 $f0 $f8 $1e $00 $48 $f8
	.db $20 $04 $36 $f5 $22 $04 $58 $00
	.db $24 $05 $3b $18 $26 $05 $3b $20
	.db $28 $05 $38 $3c $2a $03 $14 $38
	.db $2c $05 $28 $48 $2e $00 $30 $51
	.db $30 $00 $30 $60 $32 $00 $28 $68
	.db $34 $04 $f8 $40 $36 $00 $00 $48
	.db $38 $00 $00 $50 $3a $05 $0a $48
	.db $4d $88 $05 $48 $55 $8a $05 $47
	.db $45 $84 $03 $47 $4d $86 $03 $39
	.db $4e $90 $03 $43 $59 $8c $03 $39
	.db $46 $8e $03 $3b $3c $92 $03 $49
	.db $4c $80 $02 $49 $54 $82 $02

;;
; Reads the static object buffer and creates the objects for the room.
; @addr{5015}
parseStaticObjects:
	ld de,wStaticObjects		; $5015
@next:
	ld c,e			; $5018
	ld a,(de)		; $5019
	or a			; $501a
	jr z,@noMatch		; $501b

	inc e			; $501d
	ld a,(de)		; $501e
	ld b,a			; $501f
	ld a,(wActiveRoom)		; $5020
	cp b			; $5023
	jr z,@foundRoom		; $5024
@noMatch:
	ld a,c			; $5026
	add $08			; $5027
	ld e,a			; $5029
	cp <(wStaticObjects+_sizeof_wStaticObjects)	; $502a
	jr c,@next		; $502c
	ret			; $502e

@foundRoom:
	dec e			; $502f
	ld a,(de)		; $5030
	bit 7,a			; $5031
	jr nz,@noMatch		; $5033

	and $7f			; $5035
	rst_jumpTable			; $5037
.dw @end
.dw @end
.dw @end
.dw @interaction
.dw @enemy
.dw @part

@end:
	ld a,e			; $5044
	add $08			; $5045
	ld e,a			; $5047
	jr @next		; $5048

@interaction:
	call getFreeInteractionSlot		; $504a
	jr nz,@end		; $504d
	jr ++			; $504f

@enemy:
	call getFreeEnemySlot		; $5051
	jr nz,@end		; $5054
	jr ++			; $5056

@part:
	call getFreePartSlot		; $5058
	jr nz,@end		; $505b
++
	inc e			; $505d
	inc e			; $505e
	ld a,(de)		; $505f
	bit 7,a			; $5060
	jr z,+			; $5062

	dec l			; $5064
	set 1,(hl)		; $5065
	inc l			; $5067
+
	; B2: ID
	and $7f			; $5068
	ldi (hl),a		; $506a

	; B3: Sub ID
	inc e			; $506b
	ld a,(de)		; $506c
	ld (hl),a		; $506d

	; B4: Y
	ld a,l			; $506e
	add Object.yh-Object.subid	; $506f
	ld l,a			; $5071
	inc e			; $5072
	ld a,(de)		; $5073
	ldi (hl),a		; $5074

	; B5: X
	inc l			; $5075
	inc e			; $5076
	ld a,(de)		; $5077
	ld (hl),a		; $5078

	; Set RelatedObj1 (actually a pointer to its position in wStaticObjects)
	ld a,l			; $5079
	add Object.relatedObj1-Object.xh		; $507a
	ld l,a			; $507c
	ld a,e			; $507d
	and $f8			; $507e
	ld e,a			; $5080
	ldi (hl),a		; $5081
	ld (hl),d		; $5082
	jr @end		; $5083

;;
; This function is called from "loadStaticObjects" in bank 0.
; Loads the static objects for the current dungeon. (Doesn't check whether you're actually
; in a dungeon.)
; @addr{5085}
loadStaticObjects_body:
	call clearStaticObjects		; $5085
	ld a,(wDungeonIndex)		; $5088
	ld hl,staticDungeonObjects	; $508b
	rst_addDoubleIndex			; $508e
	ldi a,(hl)		; $508f
	ld h,(hl)		; $5090
	ld l,a			; $5091
	ld de,wStaticObjects		; $5092
@next:
	ldi a,(hl)		; $5095
	cp $ff			; $5096
	ret z			; $5098
	ld (de),a		; $5099
	ld b,$05		; $509a
@copyLoop:
	ldi a,(hl)		; $509c
	inc e			; $509d
	ld (de),a		; $509e
	dec b			; $509f
	jr nz,@copyLoop		; $50a0

	inc e			; $50a2
	inc e			; $50a3
	inc e			; $50a4
	jr @next		; $50a5


.include "build/data/staticDungeonObjects.s"
.include "build/data/chestData.s"
.include "build/data/treasureObjectData.s"

;;
; Used in the room in present Mermaid's Cave with the changing floor
;
; @param	b	Floor state (0/1)
; @addr{5766}
loadD6ChangingFloorPatternToBigBuffer:
	ld a,b			; $5766
	add a			; $5767
	ld hl,@changingFloorData		; $5768
	rst_addDoubleIndex			; $576b
	push hl			; $576c
	ldi a,(hl)		; $576d
	ld d,(hl)		; $576e
	ld e,a			; $576f
	ld b,$41		; $5770
	ld hl,wBigBuffer		; $5772
	call copyMemoryReverse		; $5775

	pop hl			; $5778
	inc hl			; $5779
	inc hl			; $577a
	ldi a,(hl)		; $577b
	ld d,(hl)		; $577c
	ld e,a			; $577d
	ld b,$41		; $577e
	ld hl,wBigBuffer+$80		; $5780
	call copyMemoryReverse		; $5783

	ldh a,(<hActiveObject)	; $5786
	ld d,a			; $5788
	ret			; $5789

@changingFloorData:
	.dw @tiles0_bottomHalf
	.dw @tiles0_topHalf

	.dw @tiles1
	.dw @tiles1

@tiles0_bottomHalf:
	.db $a0 $a0 $a0 $1d $a0 $1d $f4 $f4 $f4 $ff
	.db $f4 $f4 $f4 $f4 $a0 $a0 $a0 $a0 $a0 $ff
	.db $a0 $a0 $a0 $f4 $f4 $f4 $f4 $f4 $f4 $ff
	.db $f4 $f4 $f4 $f4 $f4 $f4 $f4 $a0 $a0 $ff
	.db $a0 $f4 $f4 $f4 $f4 $f4 $f4 $f4 $f4 $ff
	.db $f4 $f4 $f4 $f4 $f4 $f4 $f4 $f4 $f4 $ff
	.db $f4 $f4 $f4 $f4
	.db $00

@tiles0_topHalf:
	.db $a0 $a0 $a0 $1d $a0 $1d $f4 $f4 $f4 $ff
	.db $a0 $f4 $f4 $f4 $a0 $a0 $a0 $a0 $a0 $ff
	.db $a0 $a0 $a0 $a0 $f4 $f4 $f4 $f4 $a0 $ff
	.db $a0 $f4 $f4 $f4 $f4 $f4 $a0 $a0 $a0 $ff
	.db $a0 $a0 $f4 $f4 $f4 $f4 $f4 $f4 $f4 $ff
	.db $f4 $f4 $f4 $f4 $f4 $f4 $f4 $f4 $a0 $ff
	.db $f4 $f4 $f4 $f4
	.db $00

@tiles1:
	.db $a0 $a0 $f4 $1d $a0 $1d $f4 $f4 $f4 $ff
	.db $a0 $f4 $f4 $f4 $f4 $f4 $f4 $a0 $a0 $ff
	.db $a0 $f4 $f4 $f4 $f4 $f4 $f4 $a0 $a0 $ff
	.db $a0 $a0 $a0 $f4 $f4 $f4 $f4 $f4 $a0 $ff
	.db $a0 $f4 $f4 $f4 $f4 $a0 $a0 $a0 $a0 $ff
	.db $a0 $a0 $a0 $a0 $a0 $a0 $f4 $f4 $a0 $ff
	.db $a0 $a0 $f4 $a0
	.db $00

.ends

.include "build/data/interactionAnimations.s"
.include "build/data/partAnimations.s"

.BANK $17 SLOT 1 ; Seasons: should be bank $16
.ORG 0

	.include "build/data/paletteData.s"
	.include "build/data/tilesetCollisions.s"
	.include "build/data/smallRoomLayoutTables.s"


.ifdef ROM_AGES
.ifdef BUILD_VANILLA

	; Leftovers from seasons. No clue what it actually is though.
	; @addr{6ee3}

	.db     $dc $56 $57 $cc $dc $dc $57
	.db $cc $47 $dc $57 $46 $47 $47 $dc
	.db $6b $30 $7b $22 $31 $6b $22 $7b
	.db $46 $47 $34 $34 $34 $34 $24 $25
	.db $cc $cc $6b $6b $4a $4b $3a $3b
	.db $67 $67 $77 $77 $76 $66 $67 $70
	.db $66 $76 $70 $67 $77 $71 $62 $62
	.db $71 $77 $62 $62 $21 $21 $31 $30
	.db $21 $21 $30 $31 $27 $26 $37 $36
	.db $2d $2c $3d $3c $2b $2a $3b $3a
	.db $44 $44 $54 $54 $45 $45 $55 $55
	.db $4c $4d $5c $5d $2e $2f $2e $2f
	.db $2f $2e $2f $2e $53 $53 $53 $53
	.db $6e $6c $67 $70 $6c $6e $70 $67
	.db $76 $76 $76 $76 $72 $73 $64 $65
	.db $60 $68 $70 $78 $4a $4b $80 $80
	.db $5a $5b $80 $80 $2e $2e $3e $3e
	.db $71 $71 $61 $61 $71 $71 $53 $53
	.db $74 $75 $63 $63 $71 $71 $62 $62
	.db $cc $cc $2a $2b $5c $5c $5c $5c
	.db $68 $6f $7e $5f $6f $6e $4f $4e
	.db $7d $7c $4c $4d $6e $6f $4e $4f
	.db $3c $3d $3e $3f $5e $5e $65 $66
	.db $65 $66 $5e $5e $5c $5c $6c $6c
	.db $64 $6f $7e $7f $34 $35 $36 $37
	.db $35 $34 $37 $36 $38 $39 $3a $3b
	.db $39 $38 $3b $3a $0b $0b $0b $0b
	.db $6f $7c $52 $51 $7d $7c $55 $56
	.db $7d $7c $7c $7d $6e $6f $51 $52
	.db $40 $41 $43 $44 $42 $74 $45 $75
	.db $46 $47 $49 $4a $48 $50 $4b $59
	.db $74 $42 $75 $45 $41 $40 $44 $43
	.db $50 $48 $59 $4b $47 $46 $4a $49
	.db $78 $69 $7a $7b $69 $78 $7b $7a
	.db $6f $57 $5f $7e $58 $7c $53 $56
	.db $7d $67 $55 $54 $31 $32 $33 $33
	.db $32 $31 $33 $33 $03 $07 $12 $07
	.db $06 $19 $11 $02 $79 $78 $7b $7a
	.db $77 $76 $7a $7b $76 $77 $7b $7a
	.db $78 $79 $7a $7b $5e $5e $5e $5e
	.db $6f $64 $7f $7e $6f $6e $5f $7e
	.db $6e $6f $7e $5f $71 $71 $71 $71
	.db $72 $72 $72 $72 $73 $73 $73 $73
	.db $5d $5d $6d $6d $18 $11 $15 $16
	.db $11 $18 $17 $15 $33 $83 $8e $8f
	.db $83 $33 $8e $8f $18 $18 $07 $03
	.db $6f $6e $52 $51 $18 $19 $15 $11
	.db $19 $18 $11 $15 $38 $38 $38 $38
	.db $39 $39 $39 $39 $3a $3a $3a $3a
	.db $3b $3b $3b $3b $39 $3a $3b $3b
	.db $3a $39 $3b $3b $da $0d $0d $db
	.db $fc $fc $fc $fc $ed $ed $ed $ed
	.db $ec $ec $ec $ec $80 $a3 $a3 $1f
	.db $80 $a3 $1f $80 $0b $0c $1c $1d
	.db $0c $0b $1d $1c $0c $0c $1d $1d
	.db $1b $1b $1b $1b $9a $9a $9a $9a
	.db $98 $98 $9b $9b $99 $98 $9a $ed
	.db $98 $98 $ed $ed $98 $99 $ed $9a
	.db $9a $ed $9a $ed $ed $9a $ed $9a
	.db $9a $ed $9c $9b $ed $ed $9b $9b
	.db $ed $9a $9b $9c $5f $5e $cb $cc
	.db $aa $aa $aa $aa $05 $c4 $25 $c4
	.db $a8 $a8 $a8 $a8 $c7 $c6 $d7 $d6
	.db $c4 $05 $c4 $25 $46 $30 $46 $2a
	.db $31 $32 $2b $2b $33 $46 $2c $46
	.db $44 $45 $46 $20 $45 $45 $21 $22
	.db $45 $44 $23 $46 $d5 $d5 $78 $78
	.db $e4 $e5 $b2 $b3 $e5 $e4 $b2 $b3
	.db $e7 $e6 $f7 $f6 $49 $49 $49 $49
	.db $46 $3a $54 $55 $3b $3b $55 $55
	.db $3c $46 $55 $54 $46 $30 $46 $40
	.db $31 $32 $41 $42 $33 $46 $43 $46
	.db $46 $30 $46 $60 $31 $32 $61 $62
	.db $33 $46 $63 $46 $dd $b0 $d8 $c0
	.db $b1 $d9 $c1 $de $07 $06 $17 $16
	.db $e1 $d9 $d9 $de $46 $30 $46 $2d
	.db $31 $32 $2e $2e $33 $46 $2f $46
	.db $46 $50 $54 $55 $51 $52 $55 $55
	.db $53 $46 $55 $54 $46 $70 $54 $55
	.db $71 $72 $55 $55 $73 $46 $55 $54
	.db $26 $27 $d8 $d9 $28 $28 $dd $de
	.db $de $d0 $d9 $e0 $d1 $dd $e1 $d8
	.db $f1 $f2 $f3 $f4 $27 $26 $dc $dd
	.db $de $e0 $dd $dc $46 $3d $54 $55
	.db $3e $3e $55 $55 $3f $46 $55 $54
	.db $64 $6d $74 $7d $6d $64 $7d $74
	.db $35 $36 $37 $38 $e5 $e5 $b2 $24
	.db $e5 $e5 $04 $b3 $47 $65 $57 $75
	.db $6f $48 $7f $58 $47 $48 $47 $48
	.db $5f $5e $5a $5a $4a $4a $4f $4e
	.db $4b $5b $5c $5d $4a $4d $5a $5d
	.db $47 $49 $47 $49 $d8 $d9 $dd $de
	.db $dd $de $d8 $d9 $d9 $d8 $de $dd
	.db $de $dd $d9 $d8 $de $d9 $dc $de
	.db $c2 $34 $d2 $d3 $14 $c3 $d2 $d3
	.db $e2 $e3 $de $dd $a9 $a9 $a9 $a9
	.db $5f $5b $4f $5b $4b $5e $4b $4e
	.db $4c $4d $4b $5b $4c $4a $5c $5a
	.db $47 $49 $57 $59 $4b $5e $5c $5a
	.db $5f $5b $5a $5d $49 $48 $49 $48
	.db $49 $65 $59 $75 $6f $49 $7f $59
	.db $6a $69 $02 $02 $6a $6c $01 $7b
	.db $13 $7a $00 $02 $6a $7c $01 $7b
	.db $6b $7b $7b $6b $7b $6b $6b $7b
	.db $7a $69 $6b $7a $6a $69 $69 $6a
	.db $6c $6b $69 $7c $6b $6c $7c $69
	.db $03 $6b $13 $7b $13 $6b $13 $7b
	.db $02 $01 $7a $13 $5c $5d $57 $58
	.db $7a $7b $69 $7a $02 $02 $69 $6a
	.db $01 $6b $69 $6c $00 $02 $13 $7a
	.db $6c $69 $7b $01 $6b $13 $7b $13
	.db $7b $7a $7a $6a $6a $7c $6c $7b
	.db $7c $69 $7b $6c $13 $6b $12 $7b
	.db $6a $7a $7a $6b $7a $13 $02 $01
	.db $b4 $b5 $c4 $a8 $b5 $b6 $a8 $c6
	.db $b7 $4c $c7 $4b $4d $b7 $5b $c7
	.db $b6 $b5 $c6 $a8 $b5 $b4 $a8 $c4
	.db $c4 $a8 $d4 $d5 $a8 $d6 $d5 $d5
	.db $dc $77 $dd $56 $77 $d8 $56 $de
	.db $dd $44 $50 $51 $d8 $d9 $dc $47
	.db $dc $dd $48 $48 $de $d8 $46 $d9
	.db $dd $de $d8 $5b $dd $60 $d9 $70
	.db $de $63 $d8 $73 $d9 $dd $d8 $5e
	.db $de $d9 $5f $5f $d8 $de $5e $de
	.db $d8 $de $5b $d9 $60 $d9 $70 $dd
	.db $63 $de $73 $dc $ac $ac $ac $ac
	.db $ad $ad $ad $ad $4c $4a $4b $4e
	.db $4b $5b $4b $5b $4a $4d $4f $5b
	.db $d7 $5c $d5 $d5 $5d $d7 $d5 $d5
	.db $d6 $a8 $d5 $d5 $a8 $c4 $d5 $d4
	.db $96 $97 $a6 $a7 $ab $ab $ab $ab
	.db $be $be $a0 $a1 $ed $ed $17 $16
	.db $80 $80 $17 $16 $ea $ea $fa $fa
	.db $e5 $e5 $83 $83 $9d $9d $c8 $c8
	.db $b8 $b8 $c8 $c8 $8c $8e $8d $8f
	.db $f3 $f4 $f1 $f2 $f1 $f2 $f1 $f2
	.db $df $df $f0 $f0 $df $df $df $df
	.db $07 $01 $c4 $17 $01 $07 $16 $c4
	.db $04 $04 $fd $fd $fd $fd $14 $14
	.db $05 $17 $c4 $16 $16 $05 $17 $c4
	.db $02 $01 $09 $13 $01 $02 $13 $09
	.db $0a $1a $1a $0a $06 $19 $07 $11
	.db $19 $06 $11 $07 $05 $05 $c4 $c4
	.db $b4 $b1 $c0 $c1 $b2 $b7 $c2 $c3
	.db $9e $9f $ae $af $d0 $d1 $e0 $e1
	.db $d2 $d3 $e2 $e3 $61 $62 $71 $72
	.db $62 $61 $72 $71 $02 $11 $69 $6a
	.db $11 $02 $69 $6a $6a $69 $02 $11
	.db $6a $69 $11 $02 $d9 $dd $df $df
	.db $16 $92 $17 $93 $92 $17 $93 $16
	.db $66 $76 $5c $5d $d9 $d8 $df $df
	.db $76 $66 $5d $5c $dd $b5 $c7 $c5
	.db $b6 $de $c6 $c7 $d4 $d5 $e4 $e5
	.db $d6 $d7 $e6 $e7 $09 $13 $02 $01
	.db $94 $95 $a4 $a5 $99 $98 $9c $9b
	.db $99 $99 $9c $9c $98 $99 $9b $9c
	.db $9a $9a $9c $9c $99 $99 $9a $9a
	.db $eb $eb $fb $fb $90 $90 $91 $91
	.db $45 $45 $52 $4c $4f $4e $4d $4b
	.db $53 $54 $56 $57 $54 $53 $57 $56
	.db $69 $6a $7b $81 $6a $69 $81 $7b
	.db $7b $81 $79 $7a $81 $81 $7a $7a
	.db $81 $7b $7a $79 $55 $55 $58 $58
	.db $54 $60 $5d $70 $65 $54 $75 $5d
	.db $5d $79 $58 $57 $56 $59 $57 $57
	.db $59 $59 $57 $57 $59 $56 $57 $57
	.db $5d $50 $5d $5a $4d $4e $dd $de
	.db $4f $5d $55 $5d $6f $7c $6f $7c
	.db $55 $5d $55 $5d $51 $4c $5b $5c
	.db $5d $55 $5d $55 $4d $4e $d8 $d9
	.db $dc $52 $dd $55 $56 $5d $81 $5d
	.db $6f $6c $6f $6c $7c $7c $06 $03
	.db $d9 $de $59 $59 $d9 $55 $59 $6a
	.db $81 $5d $57 $58 $5d $56 $5d $69
	.db $52 $5f $55 $dd $5e $55 $de $55
	.db $69 $5d $79 $5d $6f $66 $7f $76
	.db $5e $5f $dd $de $5e $5f $d8 $d9
	.db $19 $4e $02 $5e $4e $19 $5e $02
	.db $78 $48 $57 $58 $4d $4d $5d $5d
	.db $4c $4b $5c $5b $50 $66 $60 $51
	.db $67 $68 $52 $53 $68 $67 $53 $52
	.db $66 $50 $51 $60 $63 $62 $74 $75
	.db $61 $60 $76 $70 $55 $54 $65 $64
	.db $6a $6b $6a $7b $75 $5a $57 $56
	.db $79 $79 $56 $56 $5a $75 $56 $57
	.db $6b $6a $7b $6a $bb $bc $58 $73
	.db $bb $bc $72 $71 $bb $bc $70 $70
	.db $bb $bc $71 $72 $bb $bc $73 $58
	.db $59 $51 $6a $5d $63 $62 $5c $5b
	.db $4a $4b $5b $5b $62 $63 $5b $5c
	.db $51 $59 $5d $6a $dd $b5 $c4 $c5
	.db $7a $6b $6a $7b $53 $52 $55 $54
	.db $52 $53 $54 $55 $6b $7a $7b $6a
	.db $f6 $f6 $f7 $f7 $61 $60 $6a $7b
	.db $60 $60 $65 $5a $60 $60 $69 $69
	.db $60 $60 $5a $65 $60 $61 $7b $7a
	.db $6a $5e $6e $cc $5f $6a $cb $6f
	.db $50 $50 $4c $4d $83 $83 $e8 $e9
	.db $d2 $d3 $94 $95 $d5 $d4 $d6 $d7
	.db $d4 $d5 $d7 $d6 $83 $d7 $83 $83
	.db $d7 $83 $83 $83 $83 $83 $83 $d5
	.db $d6 $d6 $d4 $d4 $83 $83 $d5 $83
	.db $d6 $d6 $83 $83 $d8 $d9 $d8 $d9
	.db $da $db $d8 $d9 $dc $dd $d8 $d9
	.db $50 $51 $52 $53 $f2 $f2 $02 $02
	.db $f3 $f3 $03 $03 $1a $1b $1c $1d
	.db $16 $17 $18 $19 $24 $25 $26 $27
	.db $20 $21 $22 $23 $90 $91 $90 $91
	.db $92 $93 $92 $93 $08 $09 $08 $09
	.db $d1 $d1 $82 $82 $0c $0d $0e $0f
	.db $82 $82 $0e $0f $0f $0e $0e $0f
	.db $45 $46 $46 $45 $47 $48 $49 $4a
	.db $4b $4c $4d $4e $8e $8f $9e $9f
	.db $96 $97 $98 $99 $04 $05 $98 $99
	.db $f4 $f5 $98 $99 $98 $99 $98 $99
	.db $a3 $a2 $a7 $a6 $a1 $a0 $a5 $a4
	.db $a0 $a1 $a4 $a5 $a2 $a3 $a6 $a7
	.db $a9 $a8 $ae $bc $a8 $a9 $bc $bd
	.db $a8 $a9 $bc $be $12 $13 $ae $bc
	.db $12 $13 $bc $bd $13 $12 $bc $be
	.db $a8 $a9 $b8 $b9 $12 $13 $14 $15
	.db $a8 $a8 $be $be $12 $12 $be $be
	.db $f0 $f1 $00 $01 $aa $ab $ba $bb
	.db $ba $bb $aa $ab $28 $29 $2a $2b
	.db $be $ac $ae $bc $ad $ae $bd $af
	.db $be $ac $ae $be $ac $ac $bc $be
	.db $ad $ad $be $bd $ad $ae $be $be
	.db $be $ad $bc $bd $ac $be $bc $bd
	.db $be $be $bc $bd $b2 $41 $ac $ad
	.db $40 $41 $ac $ad $b0 $f7 $ac $ad
	.db $f6 $f7 $ac $ad $96 $97 $54 $54
	.db $be $ac $b9 $b8 $ad $ac $b8 $b9
	.db $ad $bf $b8 $b9 $be $bf $b8 $b8
	.db $be $bf $14 $14 $be $ac $15 $14
	.db $ad $ac $14 $15 $ad $bf $14 $15
	.db $ea $eb $fa $fb $55 $eb $fa $fb
	.db $8c $8d $9c $9d $83 $83 $9c $9d
	.db $b4 $b5 $c4 $c5 $b5 $b4 $c5 $c4
	.db $58 $59 $56 $57 $59 $58 $57 $56
	.db $b2 $b3 $e2 $c7 $b2 $b3 $c6 $e3
	.db $b2 $b3 $c6 $c7 $b2 $b3 $e2 $e3
	.db $e0 $b7 $e2 $c7 $b7 $b6 $c7 $c6
	.db $b6 $b7 $c6 $c7 $b6 $e1 $c6 $e3
	.db $e0 $e1 $c2 $c3 $e0 $e1 $e2 $e3
	.db $e0 $b7 $c6 $c7 $b6 $e1 $c6 $c7
	.db $1e $1f $10 $11 $2c $2d $2e $2f
	.db $30 $31 $34 $35 $32 $33 $36 $37
	.db $42 $43 $44 $35 $0e $0e $0e $0e
	.db $28 $28 $28 $28 $4c $6c $0c $2c
	.db $0c $0c $0c $0c $08 $28 $08 $28
	.db $28 $28 $08 $28 $2d $2d $0d $2d
	.db $0d $0d $0d $2d $0c $2c $0c $2c
	.db $0e $2e $0e $2e $0a $0a $0a $0a
	.db $2a $0a $2a $0a $0f $0f $0f $0f
	.db $0d $0d $0d $0d $0b $0b $0b $0b
	.db $2b $2b $2b $2b $4b $4b $4b $4b
	.db $0b $2b $0b $2b $6b $6b $2b $2b
	.db $4b $6b $4b $6b $4b $4b $0b $0b
	.db $0c $0a $0c $0a $0a $0c $0a $0c
	.db $4c $4c $4c $4c $0a $2a $4a $6a
	.db $2c $2c $2c $2c $2c $0c $2c $0c
	.db $08 $08 $0c $2c $0c $2c $08 $08
	.db $2c $08 $2c $08 $08 $2c $08 $2c
	.db $0d $2d $0d $2d $6d $6d $2d $2d
	.db $4d $6d $4d $6d $4d $4d $0d $0d
	.db $2d $2d $6d $6d $0d $0d $4d $4d
	.db $6d $2d $2d $6d $0d $4d $4d $0d
	.db $2d $0a $0a $0a $0a $2a $0a $2a
	.db $2a $2d $2a $2a $0a $0a $4a $4a
	.db $2a $2a $6a $6a $4a $4a $2d $4a
	.db $4a $6a $4a $6a $6a $6a $6a $2d
	.db $0a $6a $0a $2a $4e $6e $4e $6e
	.db $08 $08 $08 $08 $0e $0e $0c $0e
	.db $0e $0e $0e $0c $0c $0c $0e $0e
	.db $0c $0c $0e $0c $0c $0e $0c $0e
	.db $0e $0c $0e $0c $0e $0e $0c $0c
	.db $0e $0c $0c $0c $0c $0c $0c $0e
	.db $0c $0e $0c $0c $0c $0e $0e $0e
	.db $0e $0c $0e $0e $0d $2d $4d $6d
	.db $0e $2e $4e $6e $6b $6b $6b $6b
	.db $08 $08 $0e $0e $0e $08 $0e $08
	.db $4e $4e $08 $08 $08 $2e $08 $2e
	.db $0b $0c $0b $0c $2c $2c $2b $2b
	.db $4b $4c $4b $4c $0c $0c $0b $0b
	.db $0e $0e $0e $0d $0e $0e $0d $2d
	.db $0e $0e $2d $0e $0e $0d $0c $0c
	.db $2d $0e $2c $2c $2c $2c $08 $08
	.db $08 $08 $2c $2c $0f $2f $0f $2f
	.db $4a $4a $4a $4a $2a $2a $2a $2a
	.db $4e $6e $0e $2e $2b $0c $2b $0c
	.db $0e $2a $0e $0a $0a $2e $2a $2e
	.db $0e $2a $0e $0e $0a $2e $0e $2e
	.db $0a $2a $0e $0e $0a $2a $2a $0a
	.db $4d $4d $4d $4d $2d $2d $2d $2d
	.db $0e $6e $0e $2e $0c $2c $4c $6c
	.db $08 $08 $0c $0c $0c $08 $0c $08
	.db $4c $4c $08 $08 $0d $2e $0d $0e
	.db $0e $2d $2e $2d $0d $2e $0d $0d
	.db $0e $2d $0d $2d $0e $2e $0d $0d
	.db $0e $2e $2e $0e $2c $2c $0c $0c
	.db $0c $0c $2c $2c $0d $0d $0c $0d
	.db $0d $0d $0d $0c $0c $0c $0d $0d
	.db $0c $0c $0d $0c $0c $0d $0c $0d
	.db $0d $0c $0d $0c $0d $0d $0c $0c
	.db $0d $0c $0c $0c $0c $0c $0c $0d
	.db $0c $0d $0c $0c $0c $0d $0d $0d
	.db $0d $0c $0d $0d $08 $08 $0b $2b
	.db $0b $2b $08 $08 $2b $08 $2b $08
	.db $08 $2b $08 $2b $0b $2b $4b $6b
	.db $2d $0c $0c $0c $2c $2d $2c $2c
	.db $0c $0c $4c $4c $2c $2c $6c $6c
	.db $4c $4c $2d $4c $4c $6c $4c $6c
	.db $6c $6c $6c $2d $0d $6d $0d $2d
	.db $4b $6b $0b $2b $0b $0b $0d $0d
	.db $08 $08 $0b $0b $0b $08 $0b $08
	.db $4b $4b $08 $08 $0e $4d $0c $0c
	.db $0c $2c $0c $0c $68 $68 $0c $0c
	.db $0c $68 $0c $68 $4c $4c $68 $68
	.db $68 $6c $68 $6c $0c $28 $0c $28
	.db $0c $0c $0c $08 $0c $0c $08 $08
	.db $0c $2c $28 $2c $0c $48 $0c $0c
	.db $0c $28 $08 $28 $08 $2c $08 $08
	.db $2d $2d $4d $4d $0d $2d $4d $4d
	.db $0d $0d $4d $6d $68 $2c $0c $2c
	.db $0d $2d $0d $0d $0d $0e $0d $0e
	.db $0e $0d $0e $0d $0d $0e $0d $0d
	.db $0e $0d $0d $0d $0e $0e $0d $0d
	.db $08 $08 $0e $2e $0e $2e $08 $08
	.db $2e $2e $2e $2e $2e $08 $2e $08
	.db $0f $2f $4f $6f $0d $2c $0d $0c
	.db $0c $2d $2c $2d $0d $2c $0d $0d
	.db $0c $2d $0d $2d $0c $2c $0d $0d
	.db $0c $2c $2c $0c $0b $0b $0c $0b
	.db $0b $0b $0b $0c $0c $0c $0b $0c
	.db $0c $0b $0c $0b $0b $0b $0c $0c
	.db $0b $0c $0c $0c $0c $0c $0c $0b
	.db $0b $28 $0b $2b $2b $0b $2b $0b
	.db $28 $2b $2b $2b $2f $6f $0f $4f
	.db $0b $2b $0c $2c $4c $6c $4b $6b
	.db $0e $0e $0e $2e $0e $2e $2e $2e
	.db $0d $2d $08 $08 $2d $0c $2d $0c
	.db $0c $0c $0e $2e $0c $0c $2e $2e
	.db $4b $6b $4b $68 $6b $4b $6b $4b
	.db $6b $6b $68 $6b $2f $2f $2f $2f
	.db $4b $0c $4b $0c $08 $28 $0e $2e
	.db $28 $28 $0e $2e $2c $0f $2c $0f
	.db $0f $2c $0f $2c $4a $2a $4a $2a
	.db $0a $0a $0c $0c $2a $2a $2c $2c
	.db $0b $0b $0f $0f $2f $0f $0f $2f
	.db $2b $0b $0b $0b $0a $2a $0c $0c
	.db $0b $0b $0a $2a $0c $0c $6b $4b
	.db $2d $2d $2c $2d $4d $4c $4d $4d
	.db $6c $6d $6d $6d $0c $0c $4f $4f
	.db $0f $0f $0c $0c $0c $0c $0f $4f
	.db $0c $0c $4f $2f $4f $0f $0c $0c
	.db $0f $6f $0c $0c $0b $2c $0b $0b
	.db $2c $2b $0b $2b $4b $0b $4b $0b
	.db $2b $4b $2b $4b $0c $4b $0c $4b
	.db $0b $2b $0b $4b $2b $2b $4b $4b
	.db $2b $2b $4b $2b $4b $0b $0b $0b
	.db $6c $2c $2c $0c $08 $08 $08 $28
	.db $2d $0d $2d $0d $0c $0d $0d $0c
	.db $2e $0e $2e $0e $0e $2d $2d $2d
	.db $2e $2d $2e $2d $0d $0c $0c $0d
	.db $28 $28 $0d $0d $0d $28 $0d $28
	.db $4d $4d $28 $28 $28 $6d $28 $6d
	.db $8d $8d $8d $8d $2d $2c $0d $2c
	.db $2c $4b $2c $4b $0c $0c $0c $0a
	.db $0c $2c $0a $2c $0c $0c $0a $0a
	.db $2c $2c $0c $2c $0c $0c $0c $2c
	.db $4e $4e $4e $4e $08 $08 $2e $0e
	.db $6e $4e $08 $08 $0b $0b $4b $4b
	.db $0c $0b $2c $2c $2b $2b $2c $2b
	.db $2c $2e $2e $2e $0b $0f $0b $0f
	.db $0f $2b $0f $2b $0b $0b $0b $0f
	.db $2b $2b $0f $2b $0b $0c $0b $0b
	.db $2b $2b $2b $0b $2b $0b $4b $4b
	.db $0c $0c $4b $6b $0b $2c $0b $0c
	.db $2c $2b $0c $2b $0b $0a $0b $0c
	.db $0a $2b $0c $2b $0a $2a $0a $0a
	.db $0a $2a $4a $4a $4a $4a $0a $0a
	.db $0a $0a $4a $6a $2a $2a $4a $4a
	.db $0a $6a $6a $0a $2a $2a $2a $0a
	.db $2a $2c $2a $2c $2a $2a $0c $0c
	.db $0c $0c $2a $2c $0a $0b $0b $0b
	.db $0b $0b $0f $0b $2b $2b $2b $0f
	.db $0c $0b $2a $2c $0b $2b $0f $0f
	.db $0f $2b $2b $2b $0c $0a $0c $0c
	.db $2a $2c $0c $2c $0c $0b $0c $0c
	.db $0c $4a $0c $2c $6a $2c $0c $2c
	.db $0f $2f $0f $0f $0f $0f $2f $0f
	.db $2f $2f $2f $0f $2b $0a $2b $2b
	.db $0d $0d $0a $0d $0f $0e $0f $0f
	.db $0e $0e $0f $0e $2f $2f $0f $0f
	.db $0a $0a $0d $0c $0e $0e $0e $0f
	.db $0e $0f $0f $0f $0d $2d $0c $0c
	.db $0a $0a $0d $0d $0a $0d $2a $0d
	.db $0b $0a $0a $2a $2a $2a $0a $0a
	.db $0f $08 $0b $0a $0c $0b $0d $0d
	.db $0a $0a $2a $0a $0a $0c $0c $0c
	.db $0c $2a $0c $0c $0e $0a $0e $0a
	.db $0a $0c $0d $0c $0c $0a $0c $0d
	.db $0a $2a $0d $0d $0a $0d $0a $0d
	.db $2a $0d $2a $0d $0e $0c $0d $0c
	.db $0c $0d $0c $0e $0a $0d $0a $0a
	.db $0d $0d $0a $0a $0c $0e $0d $0e
	.db $0e $0e $0a $0a $0e $2a $0a $0a
	.db $0c $0d $0e $0e $0c $0b $0e $0e
	.db $0a $08 $0a $0a $08 $2a $0a $2a
	.db $0a $0a $0a $08 $0a $2a $08 $2a
	.db $0d $0d $2d $0d $2d $2d $2d $0d
	.db $2c $2d $0c $0d $0c $2d $0d $0d
	.db $4c $0c $4c $0c $4c $2d $4c $0d
	.db $0d $2c $0d $2c $0d $2d $0a $0a
	.db $0c $08 $08 $28 $08 $28 $0c $2c
	.db $4c $08 $0c $08 $08 $2c $28 $2c
	.db $28 $28 $0c $0c $28 $08 $2c $08
	.db $28 $28 $08 $0c $0c $08 $4c $08
	.db $0c $08 $0c $0c $28 $2c $2c $2c
	.db $0c $0c $2c $0c $08 $28 $0c $0c
	.db $08 $2c $0c $2c $0c $08 $0c $2c
	.db $0c $2c $08 $28 $68 $2c $2c $2c
	.db $0c $0c $08 $28 $2c $08 $4c $08
	.db $08 $0c $08 $2c $2c $0c $4c $4c
	.db $0c $0c $4c $6c $8c $0c $8c $0c
	.db $0f $0f $0f $0d $0f $0f $0d $0d
	.db $0b $0a $0c $0c $0a $2b $0c $0c
	.db $0f $0d $0f $0d $0d $2f $0d $2f
	.db $0f $2f $0d $2f $0f $2f $2f $2f
	.db $0d $8c $0d $8c $0f $0f $0f $2f
	.db $0e $2e $0c $2e $0a $2a $0c $2c
	.db $08 $28 $08 $08 $0d $2d $0a $2a
	.db $0a $0a $0a $2a $0c $2c $2c $2c
	.db $2a $0a $2a $2a $0a $6a $0a $0a
	.db $4a $0a $0a $0a $0e $0e $2e $2e
	.db $2c $0c $0f $0f $0a $0a $0e $0e
	.db $2a $2a $2e $2e $0d $2d $0c $0d
	.db $0c $2d $0d $0c $2c $0c $0c $0c
	.db $0b $2b $0c $0c $8c $8c $0d $8c
	.db $2e $2e $0e $2e $2e $2e $2e $0e
	.db $0b $0b $0b $0a $2b $2b $2a $2b
	.db $2e $0e $0e $2e $2b $2c $2c $2c
	.db $0c $0d $0b $0b $0d $0d $0b $0b
	.db $0d $2c $0b $0b $0c $2c $0f $0f
	.db $0e $2e $0e $0e $0e $0e $4e $4e
	.db $0d $0d $0e $2e $2d $0d $2d $2d
	.db $0d $0b $0b $0b $2a $0b $2b $2b
	.db $0b $0b $0b $2b $0b $2d $0b $2b
	.db $0d $0d $0d $0b $0b $0b $0a $0a
	.db $2b $2b $2a $2a $2d $2d $0b $2d
	.db $0b $0b $0a $0b $2b $0b $2b $2b
	.db $0b $0b $2b $2b $2b $2b $2b $2a
	.db $2d $0d $2b $2d $0b $0a $0b $0b
	.db $0a $0a $0b $0b $0a $0f $0a $0a
	.db $0f $0f $0a $0a $2f $2f $2a $2a
	.db $2f $2a $2a $2a $2a $2a $2b $2b
	.db $28 $08 $28 $08 $0a $2b $2c $2c
	.db $0a $2b $0c $2c $28 $28 $2c $2c
	.db $28 $2c $28 $2c $0c $2c $08 $2c
	.db $2b $2c $4b $2c $0c $2c $2b $2c
	.db $2b $2c $2b $2c $6b $2c $2c $2c
	.db $0c $4b $0c $0c $0c $0c $4b $4b
	.db $2b $0c $2c $0c $0c $8c $8c $8c
	.db $8c $ac $8c $ac $ac $0c $ac $ac
	.db $0c $8c $0c $0c $8c $8c $0c $2c
	.db $ac $ac $0c $2c $ac $0c $2c $0c
	.db $0b $2d $0b $0b $6c $4c $2c $6c
	.db $4c $4c $4c $0c $0d $2b $2b $2b
	.db $2c $2c $2c $0c $0c $0c $28 $28
	.db $08 $2c $68 $08 $2f $0f $2f $2f
	.db $0d $2d $2d $0d $68 $2c $0c $6c
	.db $2d $0d $0d $2d $0d $0d $2d $2d
	.db $0f $2f $0c $0c $0c $0f $0f $0f
	.db $0f $0c $0f $0f $2e $0e $2e $2e
	.db $2b $0b $0d $2d $0b $0b $0d $2d
	.db $0d $0d $2b $0b $0d $2d $0b $0b
	.db $eb $8b $eb $8b $8b $8b $8b $8b
	.db $ab $ab $ab $8b $8b $8b $2d $2d
	.db $8b $8b $0d $0d $8b $8b $0d $2d
	.db $ab $8b $0d $2d $0c $0c $0f $0f
	.db $2d $28 $2d $2d $08 $0d $0d $0d
	.db $0f $2f $2f $0f $28 $2c $0c $2c
	.db $0d $0d $0e $0e $0d $2c $0e $0e
	.db $0c $2c $0c $08 $0c $2a $0c $0a
	.db $0a $2c $0a $2c $0a $2c $2c $2c
	.db $2a $2a $0a $2a $0a $2a $0a $2c
	.db $0a $2a $0c $0a $0b $0d $0b $0d
	.db $0d $0b $0d $0b $2d $2d $0b $0b
	.db $0b $0d $0b $0b $8d $ad $8d $ad
	.db $ad $ad $ad $ad $2d $2d $2a $2a
	.db $0d $0d $2b $2b $4c $4c $28 $0c
	.db $08 $4c $68 $08 $08 $0c $08 $0c
	.db $28 $28 $2c $28 $6c $2c $4c $6c
	.db $68 $0c $2c $0c $28 $08 $08 $0c
	.db $6c $4c $2c $08 $0c $4c $4c $4c
	.db $6c $08 $08 $68 $28 $0b $28 $0b
	.db $0b $0c $0d $0c $0b $0b $0b $0d
	.db $0b $0b $2d $0b $2d $0b $2d $0b
	.db $0d $2d $2d $2d $2c $0c $6c $4c
	.db $4c $4c $0c $0c $28 $28 $2c $08
	.db $08 $28 $08 $0c $08 $2c $2c $2c
	.db $08 $68 $0c $2c $08 $28 $2c $2c
	.db $4c $4c $28 $28 $4c $4c $08 $28
	.db $0c $2e $0c $2e $0b $0d $2d $0d
	.db $0d $0b $0d $0d $2c $2c $2c $2d
	.db $08 $08 $28 $28 $08 $28 $28 $28
	.db $08 $08 $28 $08 $0b $28 $0b $28
	.db $28 $08 $08 $08 $2c $2c $0c $08
	.db $0b $0b $08 $08 $0b $08 $08 $28
	.db $28 $08 $28 $28 $08 $08 $08 $0b
	.db $08 $28 $0b $28 $0c $0d $08 $0d
	.db $2d $0c $2d $08 $28 $28 $08 $08
	.db $08 $08 $08 $0c $0e $0e $2e $0e
	.db $2e $2f $2e $2e $0f $0e $0e $0e
	.db $0b $0d $0d $0d $2e $0e $0e $0e
	.db $2e $2e $0e $0e $09 $09 $09 $09
	.db $0f $0f $0b $0b $0f $0f $2f $2f
	.db $6f $6f $0f $6f $6f $4f $6f $4f
	.db $4f $4f $4f $0f $8e $8e $8e $8e
	.db $8c $8c $8c $8c $2a $0a $0a $0a
	.db $0a $0a $2a $2a $ac $ac $ac $ac

.endif
.endif

.BANK $18 SLOT 1 ; Seasons: should be bank $17
.ORG 0

 m_section_superfree Tile_Mappings

	tileMappingIndexDataPointer:
		.dw tileMappingIndexData
	tileMappingAttributeDataPointer:
		.dw tileMappingAttributeData

	tileMappingTable:
		.incbin "build/tilesets/tileMappingTable.bin"
	tileMappingIndexData:
		.incbin "build/tilesets/tileMappingIndexData.bin"
	tileMappingAttributeData:
		.incbin "build/tilesets/tileMappingAttributeData.bin"

.ifdef ROM_AGES
.ifdef BUILD_VANILLA
	; Leftovers from seasons
	; @addr{799e}
	.incbin "build/gfx/gfx_credits_sprites_2.cmp" SKIP 1+$1e
.endif
.endif

.ends


.BANK $19 SLOT 1
.ORG 0

 m_section_superfree "Gfx_19_1" ALIGN $10
	.include "data/ages/gfxDataBank19_1.s"
.ends

 m_section_superfree "Tile_mappings"
	.include "build/data/tilesetMappings.s"
.ends

 m_section_superfree "Gfx_19_2" ALIGN $10
	.include "data/ages/gfxDataBank19_2.s"
.ends


.BANK $1a SLOT 1
.ORG 0


 m_section_free "Gfx_1a" ALIGN $20
	.include "data/gfxDataBank1a.s"
.ends


.BANK $1b SLOT 1
.ORG 0

 m_section_free "Gfx_1b" ALIGN $20
	.include "data/gfxDataBank1b.s"
.ends


.BANK $1c SLOT 1
.ORG 0

	; The first $e characters of gfx_font are blank, so they aren't
	; included in the rom. In order to get the offsets correct, use
	; gfx_font_start as the label instead of gfx_font.

	.define gfx_font_start gfx_font-$e0
	.export gfx_font_start

	m_GfxDataSimple gfx_font_jp ; $70000
	m_GfxDataSimple gfx_font_tradeitems ; $70600
	m_GfxDataSimple gfx_font $e0 ; $70800
	m_GfxDataSimple gfx_font_heartpiece ; $71720

	m_GfxDataSimple map_rings ; $717a0

	.include "build/data/largeRoomLayoutTables.s" ; $719c0

.ifdef ROM_AGES
.ifdef BUILD_VANILLA

	; Leftovers from seasons - part of its text dictionary
	; $73dc0

	.db $62 $65 $66 $6f $72 $65 $00 $53
	.db $70 $69 $72 $69 $74 $00 $57 $65
	.db $27 $72 $65 $20 $00 $48 $6d $6d
	.db $2e $2e $2e $00 $61 $6c $77 $61
	.db $79 $73 $00 $65 $72 $68 $61 $70
	.db $73 $00 $20 $63 $61 $6e $20 $00
	.db $43 $6c $69 $6d $62 $20 $61 $74
	.db $6f $70 $20 $61 $01 $00 $70 $6f
	.db $77 $65 $72 $00 $20 $79 $6f $75
	.db $2e $00 $54 $68 $69 $73 $20 $00
	.db $20 $79 $6f $75 $21 $00 $20 $74
	.db $6f $20 $73 $65 $65 $00 $63 $6f
	.db $75 $72 $61 $67 $65 $00 $77 $61
	.db $6e $74 $20 $74 $6f $00 $20 $74
	.db $68 $61 $6e $6b $73 $00 $75 $73
	.db $68 $72 $6f $6f $6d $00 $20 $4c
	.db $65 $76 $65 $6c $20 $00 $41 $64
	.db $76 $61 $6e $63 $65 $00 $74 $65
	.db $6c $6c $20 $6d $65 $00 $72 $69
	.db $6e $63 $65 $73 $73 $00 $20 $4f
	.db $72 $61 $63 $6c $65 $00 $59 $6f
	.db $75 $27 $6c $6c $20 $00 $61 $6e
	.db $79 $74 $69 $6d $65 $00 $53 $6e
	.db $61 $6b $65 $09 $00 $00 $20 $69
	.db $73 $20 $61 $00 $57 $68 $61 $74
	.db $20 $00 $20 $6d $6f $72 $65 $00
	.db $20 $74 $68 $65 $6d $00 $20 $73
	.db $6f $6d $65 $00 $73 $73 $65 $6e
	.db $63 $65 $00 $63 $68 $61 $6e $67
	.db $65 $00 $72 $65 $74 $75 $72 $6e
	.db $00 $20 $49 $74 $27 $73 $01 $00
	.db $61 $6b $65 $20 $69 $74 $00 $20
	.db $64 $61 $6e $63 $65 $00 $65 $6e
	.db $6f $75 $67 $68 $00 $68 $69 $64
	.db $64 $65 $6e $00 $6f $72 $74 $75
	.db $6e $65 $00 $09 $01 $42 $6f $6d
	.db $62 $00 $09 $00 $21 $0c $18 $01
	.db $00 $74 $68 $69 $6e $67 $00 $74
	.db $68 $69 $73 $20 $00 $73 $20 $6f
	.db $66 $01 $00 $54 $68 $65 $6e $20
	.db $00 $20 $68 $65 $72 $6f $00 $72
	.db $69 $6e $67 $20 $00 $61 $74 $75
	.db $72 $65 $00 $20 $67 $65 $74 $20
	.db $00 $20 $61 $72 $65 $01 $00 $66
	.db $72 $6f $6d $20 $00 $46 $65 $72
	.db $74 $69 $6c $65 $20 $53 $6f $69
	.db $6c $00 $4b $6e $6f $77 $2d $49
	.db $74 $2d $41 $6c $6c $01 $00 $4d
	.db $61 $67 $69 $63 $20 $50 $6f $74
	.db $69 $6f $6e $00 $61 $68 $2c $20
	.db $68 $61 $68 $2c $20 $68 $61 $68
	.db $00 $65 $67 $65 $6e $64 $61 $72
	.db $79 $00 $79 $6f $75 $72 $73 $65
	.db $6c $66 $00 $73 $74 $72 $65 $6e
	.db $67 $74 $68 $00 $70 $72 $65 $63
	.db $69 $6f $75 $73 $00 $20 $79 $6f
	.db $75 $27 $6c $6c $01 $00 $42 $77
	.db $65 $65 $2d $68 $65 $65 $00 $66
	.db $69 $6e $69 $73 $68 $65 $64 $00
	.db $09 $01 $47 $61 $73 $68 $61 $01
	.db $00 $09 $03 $48 $6f $72 $6f $6e
	.db $01 $00 $54 $68 $61 $74 $20 $00
	.db $20 $67 $6f $6f $64 $00 $20 $68
	.db $61 $73 $01 $00 $20 $69 $74 $20
	.db $74 $6f $00 $65 $61 $74 $68 $65
	.db $72 $00 $73 $68 $6f $75 $6c $64
	.db $00 $6d $61 $73 $74 $65 $72 $00
	.db $20 $6d $75 $73 $74 $20 $00 $54
	.db $68 $61 $6e $6b $73 $00 $62 $65
	.db $61 $73 $74 $73 $00 $63 $61 $6c
	.db $6c $65 $64 $00 $62 $65 $74 $74
	.db $65 $72 $00 $74 $72 $61 $76 $65

.endif
.endif

; "build/textData.s" will determine where this data starts.
;   Ages:    1d:4000
;   Seasons: 1c:5c00

	.include "build/textData.s"

	.REDEFINE DATA_ADDR TEXT_END_ADDR
	.REDEFINE DATA_BANK TEXT_END_BANK

	.include "build/data/roomLayoutData.s"
	.include "build/data/gfxDataMain.s"



.BANK $3f SLOT 1
.ORG 0

 m_section_force Bank3f NAMESPACE bank3f

.define BANK_3f $3f

;;
; @addr{4000}
initGbaModePaletteData:
	ld a,($ff00+R_SVBK)	; $4000
	push af			; $4002
	ld a,:w2GbaModePaletteData		; $4003
	ld ($ff00+R_SVBK),a	; $4005

	ld hl,_gbaModePaletteData	; $4007
	ld de,w2GbaModePaletteData		; $400a
	ld b,$80		; $400d
	call copyMemory		; $400f

	pop af			; $4012
	ld ($ff00+R_SVBK),a	; $4013
	ret			; $4015

;;
; Redraw dirty palettes
; @addr{4016}
refreshDirtyPalettes:
	ld a,$02		; $4016
	ld ($ff00+R_SVBK),a	; $4018

	ldh a,(<hDirtyBgPalettes)	; $401a
	ld d,a			; $401c
	ldh a,(<hBgPaletteSources)	; $401d
	ld e,a			; $401f
	ld l,<w2AreaBgPalettes	; $4020
	call @refresh		; $4022

	ldh a,(<hDirtySprPalettes)	; $4025
	ld d,a			; $4027
	ldh a,(<hSprPaletteSources)	; $4028
	ld e,a			; $402a
	ld l,<w2AreaSprPalettes	; $402b
;;
; @param d Bitset of dirty palettes
; @param e Bitset of where to get the palettes from
; @param l $80 for background, $c0 for sprites
; @addr{402d}
@refresh:
	ld a,d			; $402d
	or a			; $402e
	ret z			; $402f

	srl d			; $4030
	jr nc,@nextPalette	; $4032

	ld h,>w2AreaBgPalettes	; $4034
	srl e			; $4036
	jr nc,+			; $4038

	; h = >w2FadingBgPalettes (or equivalently, >w2FadingSprPalettes)
	inc h			; $403a
+
	ldh a,(<hGameboyType)	; $403b
	inc a			; $403d
	jr nz,@gbcMode			; $403e

@gbaMode:
	call @gbaBrightenPalette		; $4040
	call @gbaBrightenPalette		; $4043
	call @gbaBrightenPalette		; $4046
	call @gbaBrightenPalette		; $4049
	jr @refresh	; $404c

@gbcMode:
	push de			; $404e
	ld b,>w2BgPalettesBuffer	; $404f
	ld c,l			; $4051
	res 7,c			; $4052
	ld e,$08		; $4054
-
	ldi a,(hl)		; $4056
	ld (bc),a		; $4057
	inc c			; $4058
	dec e			; $4059
	jr nz,-			; $405a

	pop de			; $405c
	jr @refresh	; $405d

@nextPalette:
	ld a,l			; $405f
	add $08			; $4060
	ld l,a			; $4062
	srl e			; $4063
	jr @refresh	; $4065

;;
; @addr{4067}
@gbaBrightenPalette:
	ldi a,(hl)		; $4067
	ld c,a			; $4068
	and $e0			; $4069
	ld b,a			; $406b
	ld a,(hl)		; $406c
	and $03			; $406d
	or b			; $406f
	swap a			; $4070
	ld b,a			; $4072
	ldd a,(hl)		; $4073
	and $7c			; $4074
	rrca			; $4076
	rrca			; $4077
	push hl			; $4078
	ld hl,w2GbaModePaletteData+$60		; $4079
	rst_addAToHl			; $407c
	ld a,b			; $407d
	ld b,(hl)		; $407e
	ld hl,w2GbaModePaletteData+$21		; $407f
	rst_addAToHl			; $4082
	ldd a,(hl)		; $4083
	or b			; $4084
	ld b,a			; $4085
	ld a,c			; $4086
	and $1f			; $4087
	ld c,(hl)		; $4089
	ld hl,w2GbaModePaletteData		; $408a
	rst_addAToHl			; $408d
	ld a,(hl)		; $408e
	or c			; $408f
	pop hl			; $4090
	ld c,h			; $4091
	res 7,l			; $4092
	ld h,$df		; $4094
	ldi (hl),a		; $4096
	ld a,b			; $4097
	ldi (hl),a		; $4098
	set 7,l			; $4099
	ld h,c			; $409b
	ret			; $409c

; @addr{409d}
_gbaModePaletteData:
	.db $00 $05 $07 $08 $0a $0b $0c $0e
	.db $10 $11 $12 $13 $14 $15 $16 $17
	.db $18 $19 $1a $1b $1b $1c $1c $1d
	.db $1d $1e $1e $1e $1f $1f $1f $1f
	.db $00 $00 $a0 $00 $e0 $00 $00 $01
	.db $40 $01 $60 $01 $80 $01 $c0 $01
	.db $00 $02 $20 $02 $40 $02 $60 $02
	.db $80 $02 $a0 $02 $c0 $02 $e0 $02
	.db $00 $03 $20 $03 $40 $03 $60 $03
	.db $60 $03 $80 $03 $80 $03 $a0 $03
	.db $a0 $03 $c0 $03 $c0 $03 $c0 $03
	.db $e0 $03 $e0 $03 $e0 $03 $e0 $03
	.db $00 $14 $1c $20 $28 $2c $30 $38
	.db $40 $44 $48 $4c $50 $54 $58 $5c
	.db $60 $64 $68 $6c $6c $70 $70 $74
	.db $74 $78 $78 $78 $7c $7c $7c $7c

;;
; @addr{411d}
_resumeThreadNextFrameIfLcdIsOn:
	ld a,($ff00+R_LCDC)	; $411d
	rlca			; $411f
	ret nc			; $4120

	call resumeThreadNextFrameAndSaveBank		; $4121
	ret			; $4124

;;
; Goes through wLoadedObjectGfx, and reloads each entry. This is called when closing
; the inventory screen and things like that.
; @addr{4125}
reloadObjectGfx:
	ld a,(wLoadedItemGraphic1)		; $4125
	or a			; $4128
	call nz,loadUncompressedGfxHeader		; $4129

	ld a,(wLoadedItemGraphic2)		; $412c
	or a			; $412f
	call nz,loadUncompressedGfxHeader		; $4130

	ld hl,wLoadedObjectGfx		; $4133
--
	ldi a,(hl)		; $4136
	ld e,a			; $4137
	ld d,(hl)		; $4138
	dec l			; $4139
	or a			; $413a
	jr z,+			; $413b

	call _insertIndexIntoLoadedObjectGfx		; $413d
	call _resumeThreadNextFrameIfLcdIsOn		; $4140
+
	inc l			; $4143
	ld (hl),d		; $4144
	inc l			; $4145
	ld a,l			; $4146
	cp <wLoadedObjectGfxEnd			; $4147
	jr c,--			; $4149

	; Also reload the tree graphics

	ld hl,wLoadedTreeGfxActive	; $414b
	ld e,(hl)		; $414e
	ld (hl),$00		; $414f
	jp loadTreeGfx_body		; $4151

;;
; @addr{4154}
refreshObjectGfx_body:
	call _markAllLoadedObjectGfxUnused		; $4154

	; Re-check which object gfx indices are in use by checking all objects of
	; all types.

	; Check enemies
	ld d,FIRST_ENEMY_INDEX		; $4157
@nextEnemy:
	call _enemyGetObjectGfxIndex		; $4159
	call _markLoadedObjectGfxUsed		; $415c
	inc d			; $415f
	ld a,d			; $4160
	cp LAST_ENEMY_INDEX+1			; $4161
	jr c,@nextEnemy			; $4163

	; Check parts
	ld d,FIRST_PART_INDEX		; $4165
@nextPart:
	call _partGetObjectGfxIndex		; $4167
	call _markLoadedObjectGfxUsed		; $416a
	inc d			; $416d
	ld a,d			; $416e
	cp LAST_PART_INDEX+1			; $416f
	jr c,@nextPart			; $4171

	; Check interactions
	ld d,FIRST_INTERACTION_INDEX		; $4173
@nextInteraction:
	call _interactionGetObjectGfxIndex		; $4175
	call _markLoadedObjectGfxUsed		; $4178
	inc d			; $417b
	ld a,d			; $417c
	cp LAST_INTERACTION_INDEX+1			; $417d
	jr c,@nextInteraction			; $417f

	; Check items
	ld d,FIRST_ITEM_INDEX	; $4181
@nextItem:
	call _itemGetObjectGfxIndex		; $4183
	call _markLoadedObjectGfxUsed		; $4186
	inc d			; $4189
	ld a,d			; $418a
	cp LAST_ITEM_INDEX+1			; $418b
	jr c,@nextItem			; $418d

; Now check whether to load extra gfx for an interaction or enemy.

	ld a,(wEnemyIDToLoadExtraGfx)		; $418f
	or a			; $4192
	jr z,+			; $4193

	call _getObjectGfxIndexForEnemy		; $4195
	jr ++			; $4198
+
	ld hl,wInteractionIDToLoadExtraGfx		; $419a
	ldi a,(hl)		; $419d
	or a			; $419e
	ret z			; $419f
	ld e,(hl)		; $41a0
	ld (hl),$00		; $41a1
	call _getDataForInteraction		; $41a3
	ld a,(hl)		; $41a6
++
	call _addIndexToLoadedObjectGfx		; $41a7
	call _resumeThreadNextFrameIfLcdIsOn		; $41aa
	ld a,e			; $41ad
	call _findIndexInLoadedObjectGfx		; $41ae
	ld a,l			; $41b1
	sub <wLoadedObjectGfx			; $41b2
	srl a			; $41b4

@nextExtraGfxIndex:
	inc a			; $41b6
	and $07			; $41b7
	ld b,a			; $41b9
	ld hl,wLoadedObjectGfx+1		; $41ba
	rst_addDoubleIndex			; $41bd

	; Remember old values, they may need to be moved to another spot
	ldd a,(hl)		; $41be
	ld d,a			; $41bf
	ld c,(hl)		; $41c0
	inc e			; $41c1

	; Load the next gfx index
	call _insertIndexIntoLoadedObjectGfx		; $41c2

	; If there was something here before, reload it into another slot
	ld a,d			; $41c5
	or a			; $41c6
	jr z,+			; $41c7
	ld a,c			; $41c9
	push de			; $41ca
	call _addIndexToLoadedObjectGfx		; $41cb
	pop de			; $41ce
+
	call _updateTileIndexBaseForAllObjects		; $41cf

	; Check if bit 7 in the second parameter of objectGfxHeaderTable is set (indicating
	; the end of the data)
	ld d,$00		; $41d2
	ld hl,objectGfxHeaderTable+1		; $41d4
	add hl,de		; $41d7
	add hl,de		; $41d8
	add hl,de		; $41d9
	bit 7,(hl)		; $41da
	ld a,b			; $41dc
	jr z,@nextExtraGfxIndex			; $41dd

	ld (wLoadedObjectGfxIndex),a		; $41df
	xor a			; $41e2
	ld (wEnemyIDToLoadExtraGfx),a		; $41e3
	ld (wInteractionIDToLoadExtraGfx),a		; $41e6
	jp _incLoadedObjectGfxIndex		; $41e9

;;
; Forces an object gfx header to be loaded into slot 4 (address 0:8800). Handy way to load
; extra graphics, but uses up object slots. Used by the pirate ship and various things in
; seasons, but apparently unused in ages.
;
; @param	e	Object gfx header (minus 1)
; @addr{41ec}
loadObjectGfxHeaderToSlot4_body:
	push de			; $41ec
	call refreshObjectGfx_body		; $41ed
	pop de			; $41f0
	ld a,$03		; $41f1
	jr refreshObjectGfx_body@nextExtraGfxIndex			; $41f3

;;
; @param	e	Tree gfx index
; @addr{41f5}
loadTreeGfx_body:
	ld hl,wLoadedTreeGfxActive		; $41f5
	ld a,e			; $41f8
	cp (hl)			; $41f9
	ret z			; $41fa

	call _insertIndexIntoLoadedObjectGfx		; $41fb
	jp _resumeThreadNextFrameIfLcdIsOn		; $41fe

;;
; @addr{4201}
_updateTileIndexBaseForAllObjects:
	push bc			; $4201
	push de			; $4202
	push hl			; $4203

	; Enemies
	ld a,Enemy.enabled		; $4204
	ldh (<hActiveObjectType),a	; $4206
	ld d,FIRST_ENEMY_INDEX		; $4208
@nextEnemy:
	call _enemyGetObjectGfxIndex		; $420a
	call @updateTileIndexBase		; $420d
	inc d			; $4210
	ld a,d			; $4211
	cp LAST_ENEMY_INDEX+1			; $4212
	jr c,@nextEnemy	; $4214

	; Parts
	ld a,Part.enabled		; $4216
	ldh (<hActiveObjectType),a	; $4218
	ld d,FIRST_PART_INDEX		; $421a
@nextPart:
	call _partGetObjectGfxIndex		; $421c
	call @updateTileIndexBase		; $421f
	inc d			; $4222
	ld a,d			; $4223
	cp LAST_PART_INDEX+1			; $4224
	jr c,@nextPart	; $4226

	; Interactions
	ld a,Interaction.enabled		; $4228
	ldh (<hActiveObjectType),a	; $422a
	ld d,FIRST_DYNAMIC_INTERACTION_INDEX		; $422c
@nextInteraction:
	call _interactionGetObjectGfxIndex		; $422e
	call @updateTileIndexBase		; $4231
	inc d			; $4234
	ld a,d			; $4235
	cp LAST_INTERACTION_INDEX+1			; $4236
	jr c,@nextInteraction	; $4238

	; Items
	ld a,Item.enabled		; $423a
	ldh (<hActiveObjectType),a	; $423c
	ld d,FIRST_ITEM_INDEX		; $423e
@nextItem:
	call _itemGetObjectGfxIndex		; $4240
	call @updateTileIndexBase		; $4243
	inc d			; $4246
	ld a,d			; $4247
	cp LAST_ITEM_INDEX+1			; $4248
	jr c,@nextItem	; $424a

	call drawAllSpritesUnconditionally		; $424c
	call _resumeThreadNextFrameIfLcdIsOn		; $424f
	pop hl			; $4252
	pop de			; $4253
	pop bc			; $4254
	ret			; $4255

;;
; Updates the oamTileIndexBase for an object (after graphics may have changed places).
;
; @param	a	Object gfx index
; @param	d	Object index
; @addr{4256}
@updateTileIndexBase:
	or a			; $4256
	ret z			; $4257

	call _findIndexInLoadedObjectGfx		; $4258
	ldh a,(<hActiveObjectType)	; $425b
	ld e,a			; $425d
	ld a,(de)		; $425e
	or a			; $425f
	ret z			; $4260

	; If sprite uses vram bank 1, don't readjust oamTileIndexBase
	ld a,e			; $4261
	add Object.oamFlags			; $4262
	ld e,a			; $4264
	ld a,(de)		; $4265
	bit 3,a			; $4266
	ret nz			; $4268

	; e = Object.oamTileIndexBase
	inc e			; $4269
	ld a,(de)		; $426a
	and $1f			; $426b
	add c			; $426d
	ld (de),a		; $426e
	ret			; $426f

;;
; Finds the given object gfx index in wLoadedObjectGfx and marks it as in use, or
; sets the carry flag if it's not found.
;
; @param	a	Object gfx index
; @param[out]	c
; @param[out]	hl	Address where gfx is loaded (if it is loaded)
; @param[out]	cflag	nc if index is loaded
; @addr{4270}
_findIndexInLoadedObjectGfx:
	or a			; $4270
	ret z			; $4271

	ld hl,wLoadedObjectGfx		; $4272
	ld b,$08		; $4275
	ld c,a			; $4277
--
	ldi a,(hl)		; $4278
	cp c			; $4279
	jr z,+			; $427a

	inc l			; $427c
	dec b			; $427d
	jr nz,--		; $427e

	ld c,$01		; $4280
	scf			; $4282
	ret			; $4283
+
	ld (hl),$01		; $4284
	dec l			; $4286
	ld a,l			; $4287
	sub <wLoadedObjectGfx	; $4288
	swap a			; $428a
	ld c,a			; $428c
	ret			; $428d

;;
; Gets the first unused entry of wLoadedObjectGfx it finds?
; @param[out]	c	Relative position in wLoadedObjectGfx which is free
; @param[out]	hl
; @param[out]	cflag	Set on failure.
; @addr{428e}
_findUnusedIndexInLoadedObjectGfx:
	ld b,$08		; $428e
--
	call _getAddressOfLoadedObjectGfxIndex		; $4290
	inc l			; $4293
	ldd a,(hl)		; $4294
	or a			; $4295
	jr z,+			; $4296

	call _incLoadedObjectGfxIndex		; $4298
	dec b			; $429b
	jr nz,--		; $429c

	ld c,$01		; $429e
	scf			; $42a0
	ret			; $42a1
+
	ld a,l			; $42a2
	sub <wLoadedObjectGfx	; $42a3
	swap a			; $42a5
	ld c,a			; $42a7
	ret			; $42a8

;;
; @addr{42a9}
_incLoadedObjectGfxIndex:
	ld a,(wLoadedObjectGfxIndex)		; $42a9
	inc a			; $42ac
	and $07			; $42ad
	ld (wLoadedObjectGfxIndex),a		; $42af
	ret			; $42b2

;;
; Gets an address in wLoadedObjectGfx based on wLoadedObjectGfxIndex.
; @addr{42b3}
_getAddressOfLoadedObjectGfxIndex:
	ld a,(wLoadedObjectGfxIndex)		; $42b3
	ld hl,wLoadedObjectGfx		; $42b6
	rst_addDoubleIndex			; $42b9
	ret			; $42ba

;;
; Adds the given index into wLoadedObjectGfx if it's not in there already.
;
; @param	a	Object gfx index
; @param[out]	a	Relative position where it's placed in wLoadedObjectGfx
; @param[out]	cflag	Set if graphics were queued to be loaded and lcd is
;			currently on
; @addr{42bb}
_addIndexToLoadedObjectGfx:
	or a			; $42bb
	ret z			; $42bc

	push hl			; $42bd
	push bc			; $42be
	ld e,a			; $42bf
	call _findIndexInLoadedObjectGfx		; $42c0
	jr nc,+			; $42c3

	call _findUnusedIndexInLoadedObjectGfx		; $42c5
	call nc,_insertIndexIntoLoadedObjectGfx		; $42c8
+
	ld a,c			; $42cb
	pop bc			; $42cc
	pop hl			; $42cd
	ret			; $42ce

;;
; Adds index "e" into the wLoadedObjectGfx buffer at the specified position, or into
; wLoadedTreeGfx if that's what hl is pointing to.
;
; Also performs the actual loading of the gfx, and removes any duplicates in
; the list.
;
; @param	e	Object gfx index
; @param	hl	Address in wLoadedObjectGfx?
; @addr{42cf}
_insertIndexIntoLoadedObjectGfx:
	ld a,l			; $42cf
	cp <wLoadedTreeGfxActive		; $42d0
	jr nc,++		; $42d2

	; First, remove any references to it if it's already loaded (to prevent
	; redundancy)
	push hl			; $42d4
	ld hl,wLoadedObjectGfx		; $42d5
-
	ldi a,(hl)		; $42d8
	cp e			; $42d9
	jr nz,+			; $42da

	xor a			; $42dc
	ldd (hl),a		; $42dd
	ldi (hl),a		; $42de
+
	inc l			; $42df
	ld a,l			; $42e0
	cp <wLoadedObjectGfxEnd		; $42e1
	jr c,-			; $42e3

	pop hl			; $42e5
++
	push bc			; $42e6
	push de			; $42e7
	push hl			; $42e8
	ld (hl),e		; $42e9
	inc l			; $42ea
	ld (hl),$01		; $42eb
	dec l			; $42ed
	ld a,l			; $42ee
	cp <wLoadedTreeGfxActive	; $42ef
	jr c,@object		; $42f1

@tree:
	ld b,$92		; $42f3
	ld hl,treeGfxHeaderTable
	jr ++			; $42f8

@object:
	sub <wLoadedObjectGfx	; $42fa
	or $80			; $42fc
	ld b,a			; $42fe
	ld hl,objectGfxHeaderTable
++
	ld d,$00		; $4302
	add hl,de		; $4304
	add hl,de		; $4305
	add hl,de		; $4306
	call loadObjectGfx
	pop hl			; $430a
	pop de			; $430b
	pop bc			; $430c
	ret			; $430d

;;
; Mark a particular object gfx index as used. This doesn't insert the index into
; wLoadedObjectGfx if it's not found, though.
; @param a Object gfx index to mark as used
; @addr{430e}
_markLoadedObjectGfxUsed:
	or a			; $430e
	ret z			; $430f

	push bc			; $4310
	push hl			; $4311
	ld hl,wLoadedObjectGfx		; $4312
	ld c,a			; $4315
-
	ldi a,(hl)		; $4316
	cp c			; $4317
	jr z,@found		; $4318

	inc l			; $431a
	ld a,l			; $431b
	cp <wLoadedObjectGfxEnd	; $431c
	jr c,-		; $431e

	jr @end			; $4320

@found:
	ld (hl),$01		; $4322
@end:
	pop hl			; $4324
	pop bc			; $4325
	ret			; $4326

;;
; Sets the 2nd byte of every entry in the wLoadedObjectGfx buffer to $00,
; indicating that they are not being used.
; @addr{4327}
_markAllLoadedObjectGfxUnused:
	push bc			; $4327
	push hl			; $4328
	ld hl,wLoadedObjectGfx		; $4329
	ld b,$08		; $432c
	xor a			; $432e
-
	inc l			; $432f
	ldi (hl),a		; $4330
	dec b			; $4331
	jr nz,-			; $4332

	pop hl			; $4334
	pop bc			; $4335
	ret			; $4336

;;
; Get an enemy's gfx index, as well as a pointer to the rest of its data.
; @param[out]	a	Object gfx index
; @param[out]	hl	Pointer to 3 more bytes of enemy data
; @addr{4337}
_enemyGetObjectGfxIndex:
	ld e,Enemy.id		; $4337
	ld a,(de)		; $4339

;;
; @param	a	Enemy ID
; @addr{433a}
_getObjectGfxIndexForEnemy:
	push bc			; $433a
	add a			; $433b
	ld c,a			; $433c
	ld b,$00		; $433d
	ld hl,enemyData		; $433f
	add hl,bc		; $4342
	add hl,bc		; $4343
	pop bc			; $4344
	ldi a,(hl)		; $4345
	ret			; $4346

;;
; @param[out]	a	Object gfx index
; @param[out]	hl	Pointer to 7 more bytes of part data
; @addr{4347}
_partGetObjectGfxIndex:
	push bc			; $4347
	ld e,Part.id		; $4348
	ld a,(de)		; $434a
	call multiplyABy8		; $434b
	ld hl,partData		; $434e
	add hl,bc		; $4351
	pop bc			; $4352
	ldi a,(hl)		; $4353
	ret			; $4354

;;
; @addr{4355}
_interactionGetObjectGfxIndex:
	push bc			; $4355
	call _interactionGetData		; $4356
	pop bc			; $4359
	ldi a,(hl)		; $435a
	ret			; $435b

;;
; @addr{435c}
_itemGetObjectGfxIndex:
	ld e,Item.id		; $435c
	ld a,(de)		; $435e

	; a *= 3
	ld l,a			; $435f
	add a			; $4360
	add l			; $4361

	ld hl,itemData		; $4362
	rst_addAToHl			; $4365
	ldi a,(hl)		; $4366
	ret			; $4367

;;
; Loading an enemy?
; @addr{4368}
enemyLoadGraphicsAndProperties:
	call _enemyGetObjectGfxIndex		; $4368
	call _addIndexToLoadedObjectGfx		; $436b
	ld c,a			; $436e
	call c,_resumeThreadNextFrameIfLcdIsOn		; $436f
	ld e,Enemy.id		; $4372
	ld a,(de)		; $4374
	ld e,Enemy.collisionType		; $4375
	bit 7,(hl)		; $4377
	jr z,+			; $4379
	set 7,a			; $437b
+
	ld (de),a		; $437d

	; e = Enemy.enemyCollisionMode
	inc e			; $437e
	ldi a,(hl)		; $437f
	and $7f			; $4380
	ld (de),a		; $4382
	bit 7,(hl)		; $4383
	jr z,+			; $4385

	; If bit 7 is set, read the next 2 bytes as the address of a table.
	; Each entry in the table is for a particular subID. hl will be set to
	; [the table's start address] + (subID*2), or the first entry without
	; bit 7 set, whichever comes first.
	ldi a,(hl)		; $4387
	and $7f			; $4388
	ld l,(hl)		; $438a
	ld h,a			; $438b
	ld e,Enemy.subid	; $438c
	ld a,(de)		; $438e
	ld b,a			; $438f
	ld e,$00		; $4390
-
	bit 7,(hl)		; $4392
	jr z,+			; $4394

	ld a,e			; $4396
	cp b			; $4397
	jr z,+			; $4398

	inc hl			; $439a
	inc hl			; $439b
	inc e			; $439c
	jr -			; $439d
+
	ldi a,(hl)		; $439f
	push hl			; $43a0
	add a			; $43a1
	ld hl,extraEnemyData	; $43a2
	rst_addDoubleIndex			; $43a5
	ld e,$a6		; $43a6
	ldi a,(hl)		; $43a8
	ld (de),a		; $43a9
	inc e			; $43aa
	ldi a,(hl)		; $43ab
	ld (de),a		; $43ac
	inc e			; $43ad
	ldi a,(hl)		; $43ae
	ld (de),a		; $43af
	inc e			; $43b0
	ldi a,(hl)		; $43b1
	ld (de),a		; $43b2
	pop hl			; $43b3
	ld a,(hl)		; $43b4
	and $0f			; $43b5
	add a			; $43b7
	add c			; $43b8
	ld e,Enemy.oamTileIndexBase		; $43b9
	ld (de),a		; $43bb
	ld a,(hl)		; $43bc
	swap a			; $43bd
	and $0f			; $43bf
	dec e			; $43c1
	ld (de),a		; $43c2
	dec e			; $43c3
	ld (de),a		; $43c4
	xor a			; $43c5
	jp enemySetAnimation		; $43c6

;;
; Loading a part?
; @addr{43c9}
partLoadGraphicsAndProperties:
	call _partGetObjectGfxIndex		; $43c9
	call _addIndexToLoadedObjectGfx		; $43cc
	ld c,a			; $43cf
	call c,_resumeThreadNextFrameIfLcdIsOn		; $43d0
	ld e,Part.id		; $43d3
	ld a,(de)		; $43d5
	bit 7,(hl)		; $43d6
	jr z,+			; $43d8
	set 7,a			; $43da
+
	ld e,Part.collisionType		; $43dc
	ld (de),a		; $43de

	; e = Part.enemyCollisionMode
	inc e			; $43df
	ldi a,(hl)		; $43e0
	and $7f			; $43e1
	ld (de),a		; $43e3

	; e = Part.collisionRadiusY
	inc e			; $43e4
	ld a,(hl)		; $43e5
	swap a			; $43e6
	and $0f			; $43e8
	ld (de),a		; $43ea

	; e = Part.collisionRadiusX
	inc e			; $43eb
	ldi a,(hl)		; $43ec
	and $0f			; $43ed
	ld (de),a		; $43ef

	; e = Part.damage
	inc e			; $43f0
	ldi a,(hl)		; $43f1
	ld (de),a		; $43f2

	; e = Part.health
	inc e			; $43f3
	ldi a,(hl)		; $43f4
	ld (de),a		; $43f5

	ld e,Part.oamTileIndexBase		; $43f6
	ldi a,(hl)		; $43f8
	add c			; $43f9
	ld (de),a		; $43fa

	; e = Part.oamFlags
	dec e			; $43fb
	ldi a,(hl)		; $43fc
	ld (de),a		; $43fd

	; Also write to Part.oamFlagsBackup
	dec e			; $43fe
	ld (de),a		; $43ff

	xor a			; $4400
	jp partSetAnimation		; $4401

;;
; Load the object gfx index for an interaction, and get the values for the
; Interaction.oam variables.
;
; @param	d	Interaction index
; @param[out]	a	Initial animation index to use
; @addr{4404}
interactionLoadGraphics:
	call _interactionGetObjectGfxIndex		; $4404
	call _addIndexToLoadedObjectGfx		; $4407
	ld c,a			; $440a

	; If LCD is on and graphics are queued, wait until they're loaded
	call c,_resumeThreadNextFrameIfLcdIsOn		; $440b

	; Calculate Interaction.oamTileIndexBase, which is the offset to add to
	; the tile index of all sprites in its animation. "c" currently
	; contains the offset where the graphics are loaded.
	ldi a,(hl)		; $440e
	and $7f			; $440f
	add c			; $4411
	ld e,Interaction.oamTileIndexBase		; $4412
	ld (de),a		; $4414

	; Write palette into Interaction.oamFlags
	ld a,(hl)		; $4415
	swap a			; $4416
	and $0f			; $4418
	dec e			; $441a
	ld (de),a		; $441b

	; Also write it into Interaction.oamFlagsBackup
	dec e			; $441c
	ld (de),a		; $441d

	; Return the animation index to start on
	ld a,(hl)		; $441e
	and $0f			; $441f
	ret			; $4421

;;
; Same as above function, but for items.
; @param d Item index
; @addr{4422}
itemLoadGraphics:
	call _itemGetObjectGfxIndex		; $4422
	call _addIndexToLoadedObjectGfx		; $4425
	ld c,a			; $4428

	; If LCD is on and graphics are queued, wait until they're loaded
	call c,_resumeThreadNextFrameIfLcdIsOn		; $4429

	; Calculate Item.oamTileIndexBase
	ldi a,(hl)		; $442c
	add c			; $442d
	ld e,Item.oamTileIndexBase		; $442e
	ld (de),a		; $4430

	; Write palette / flags into Item.oamFlags
	ld a,(hl)		; $4431
	dec e			; $4432
	ld (de),a		; $4433

	; Also write it into Item.oamFlagsBackup
	dec e			; $4434
	ld (de),a		; $4435
	ret			; $4436

;;
; @addr{4437}
_interactionGetData:
	ld h,d			; $4437
	ld l,Interaction.id		; $4438
	ldi a,(hl)		; $443a
	ld e,(hl)		; $443b

;;
; @param	a	Interaction ID
; @param	e	Interaction subID
; @addr{443c}
_getDataForInteraction:
	ld c,a			; $443c
	ld b,$00		; $443d
	ld hl,interactionData+1	; $443f
	add hl,bc		; $4442
	add hl,bc		; $4443
	add hl,bc		; $4444
	ldd a,(hl)		; $4445
	rlca			; $4446
	ret nc			; $4447

	ldi a,(hl)		; $4448
	inc hl			; $4449
	ld h,(hl)		; $444a
	ld l,a			; $444b
	ld c,$03		; $444c

	; a = subID
	ld a,e			; $444e
	or a			; $444f
	ret z			; $4450
-
	inc hl			; $4451
	bit 7,(hl)		; $4452
	dec hl			; $4454
	ret nz			; $4455

	add hl,bc		; $4456
	dec a			; $4457
	jr nz,-			; $4458
	ret			; $445a

;;
; @param e Uncompressed gfx header to load
; @addr{445b}
loadWeaponGfx:
	ld hl,wLoadedItemGraphic1		; $445b
	ld a,e			; $445e
	cp UNCMP_GFXH_1a			; $445f
	jr nc,+			; $4461
	inc l			; $4463
+
	cp (hl)			; $4464
	ret z			; $4465

	ld (hl),a		; $4466
	push de			; $4467
	call loadUncompressedGfxHeader		; $4468
	pop de			; $446b
	ret			; $446c

;;
; Called from checkTreasureObtained in bank 0.
;
; @param	l	Item to check for (see constants/treasure.s)
; @param[out]	h	Bit 0 set if link has the item
; @param[out]	l	Value of the treasure's "related variable" (ie. item level)
; @addr{446d}
checkTreasureObtained_body:
	ld a,l			; $446d
	cp TREASURE_60			; $446e
	jr nc,@index60OrHigher		; $4470

	ldh (<hFF8B),a	; $4472
	ld hl,wObtainedTreasureFlags		; $4474
	call checkFlag		; $4477
	jr z,@dontHaveItem		; $447a

	push bc			; $447c
	ldh a,(<hFF8B)	; $447d
	ld c,a			; $447f
	ld b,$00		; $4480
	ld hl,treasureCollectionBehaviourTable		; $4482
	add hl,bc		; $4485
	add hl,bc		; $4486
	add hl,bc		; $4487
	pop bc			; $4488
	ldi a,(hl)		; $4489
	ld l,a			; $448a
	or a			; $448b
	jr z,@haveItem			; $448c

	ld h,>wc600Block		; $448e
	ld l,(hl)		; $4490

@haveItem:
	ld h,$01		; $4491
	ret			; $4493

@index60OrHigher:
	and $07			; $4494
	ld hl,$cca8		; $4496
	call checkFlag		; $4499
	jr nz,@haveItem		; $449c

@dontHaveItem:
	ld h,$00		; $449e
	ret			; $44a0

;;
; @param	b	Treasure
; @addr{44a1}
loseTreasure_body:
	push hl			; $44a1
	ld a,b			; $44a2
	call _loseTreasure_helper		; $44a3
	pop hl			; $44a6
	ret			; $44a7

;;
; Unset the bit in wObtainedTreasureFlags, and remove it from the inventory if it's an
; inventory item.
;
; @param	a	Treasure
; @addr{44a8}
_loseTreasure_helper:
	ld b,a			; $44a8
	ld hl,wObtainedTreasureFlags		; $44a9
	call unsetFlag		; $44ac

	; Only continue if it's an inventory item (index < $20)
	ld a,b			; $44af
	cp NUM_INVENTORY_ITEMS			; $44b0
	ret nc			; $44b2

	; Attempt to remove the item from the inventory
	ld hl,wInventoryB		; $44b3
	ld b,INVENTORY_CAPACITY+2		; $44b6
--
	cp (hl)			; $44b8
	jr z,@foundItem			; $44b9

	inc l			; $44bb
	dec b			; $44bc
	jr nz,--		; $44bd
	ret			; $44bf

@foundItem:
	ld (hl),$00		; $44c0

	; Refresh the A/B buttons on the status bar
	ld hl,wStatusBarNeedsRefresh		; $44c2
	set 0,(hl)		; $44c5

	ret			; $44c7

;;
; Called from giveTreasure in bank 0.
;
; @param	b	Item to give (see constants/treasure)
; @param	c	"Parameter"
; @param[out]	b	Sound to play
; @addr{44c8}
giveTreasure_body:
	push hl			; $44c8
	push de			; $44c9
	ld a,b			; $44ca
	ldh (<hFF8B),a	; $44cb
	push bc			; $44cd

	; Check if adding this item requires the removal of another item.
	ld hl,@itemsToRemoveTable		; $44ce
	call @findItemInTable		; $44d1
	jr z,+			; $44d4

	call _loseTreasure_helper		; $44d6
	ld a,c			; $44d9
	call _loseTreasure_helper		; $44da
+
	pop bc			; $44dd
	ld a,b			; $44de
	call @func_4501		; $44df

	; Check if adding this item requires adding another item.
	push af			; $44e2
	ld hl,@extraItemsToAddTable		; $44e3
	call @findItemInTable		; $44e6
	call nz,@func_4501		; $44e9

	pop bc			; $44ec
	pop de			; $44ed
	pop hl			; $44ee
	ret			; $44ef

;;
; @param	hl	Table to search through
; @param	hFF8B	The treasure currently being given to Link
; @param[out]	a,c	Two values associated with the item
; @param[out]	zflag	Set if the item being added wasn't in the table
; @addr{44f0}
@findItemInTable:
	ldh a,(<hFF8B)	; $44f0
	ld c,a			; $44f2
--
	ldi a,(hl)		; $44f3
	cp c			; $44f4
	jr z,+			; $44f5
	or a			; $44f7
	ret z			; $44f8

	inc hl			; $44f9
	inc hl			; $44fa
	jr --			; $44fb
+
	ldi a,(hl)		; $44fd
	ld c,(hl)		; $44fe
	or a			; $44ff
	ret			; $4500

;;
; @param	a	Item being added
; @param	c	Parameter
; @addr{4501}
@func_4501:
	ldh (<hFF8B),a	; $4501
	call _checkIncreaseGashaMaturityForGettingTreasure		; $4503
	call $46b6		; $4506

	ld hl,wObtainedTreasureFlags		; $4509
	ldh a,(<hFF8B)	; $450c
	call setFlag		; $450e

	push bc			; $4511
	ldh a,(<hFF8B)	; $4512
	ld c,a			; $4514
	ld b,$00		; $4515
	ld hl,treasureCollectionBehaviourTable		; $4517
	add hl,bc		; $451a
	add hl,bc		; $451b
	add hl,bc		; $451c
	pop bc			; $451d
	ld d,>wc600Block		; $451e
	ldi a,(hl)		; $4520
	ld e,a			; $4521
	or a			; $4522
	jr nz,+			; $4523
	ld e,<wShortSecretIndex		; $4525
+
	ld a,(hl)		; $4527
	and $0f			; $4528
	push hl			; $452a
	call @applyParameter		; $452b

	; Check whether to play a sound effect
	pop hl			; $452e
	bit 7,(hl)		; $452f
	inc hl			; $4531
	ldi a,(hl)		; $4532
	jr nz,@ret			; $4533
	call playSound		; $4535
	xor a			; $4538

@ret:
	ret			; $4539


; When Link obtains any item in the first column, he will obtain the item in the second
; column with the parameter in the third column.
; Example: When Link gets the seed satchel, he also gets 20 ember seeds.
@extraItemsToAddTable:
	.db TREASURE_SEED_SATCHEL	TREASURE_EMBER_SEEDS	$20
	.db TREASURE_HEART_CONTAINER	TREASURE_HEART_REFILL	$40
	.db TREASURE_BOMB_FLOWER	TREASURE_58		$00
	.db TREASURE_TUNE_OF_ECHOES	TREASURE_HARP		$01
	.db $00

; This is similar to above, except whenever Link obtains an item in the first column, the
; game takes away the items in the next two columns. Apparently unused in ages.
@itemsToRemoveTable:
	.db $00

;;
; This function does something with the "parameter" passed at the start of the function.
;
; See the comments in "treasureCollectionBehaviourTable" for a detailed description of
; what each value does.
;
; @param	a	Index indicating what to do with the parameter
; @param	c	Parameter (could be # of seeds, or the item's level, etc)
; @param	de	The item's "variable" (ie. item level, or ammo)
; @addr{4548}
@applyParameter:
	rst_jumpTable			; $4548
	.dw @ret
	.dw @mode1
	.dw @mode2
	.dw @mode3
	.dw @mode4
	.dw @mode5
	.dw @mode6
	.dw @mode7
	.dw @mode8
	.dw @mode9
	.dw @modea
	.dw @modeb
	.dw @modec
	.dw @moded
	.dw @modee
	.dw @modef

; Set a bit in [$cca8].
@modeb:
	ld a,c			; $4569
	ld hl,$cca8		; $456a
	jp setFlag		; $456d

; Set [de] to c if [de]<c. Also refreshes part of status bar. Used for items with levels.
@mode8:
	ld a,(de)		; $4570
	cp c			; $4571
	ret nc			; $4572
	ld a,c			; $4573
	ld (de),a		; $4574
	ld hl,wStatusBarNeedsRefresh		; $4575
	set 0,(hl)		; $4578
	ret			; $457a

; [de] = c
@mode5:
	ld a,c			; $457b
	ld (de),a		; $457c
	ret			; $457d

; Set bit [wDungeonIndex] in [de].
@mode6:
	ld a,(wDungeonIndex)		; $457e
	ld c,a			; $4581

; Set bit c in [de].
@mode1:
	ld a,c			; $4582
	ld h,d			; $4583
	ld l,e			; $4584
	jp setFlag		; $4585

; Increment [de].
@mode2:
	ld a,(de)		; $4588
	inc a			; $4589
	ld (de),a		; $458a
	ret			; $458b

; Increment [de] as a bcd value.
@mode3:
	ld c,$01		; $458c

; Add c to [de] as a bcd value.
; Mode 4 is also called by mode d, mode f.
@mode4:
	ld a,(de)		; $458e
	add c			; $458f
	daa			; $4590
	jr nc,+			; $4591
	ld a,$99		; $4593
+
	ld (de),a		; $4595
	ret			; $4596

; Increment [de+[wDungeonIndex]].
; Used for small keys.
@mode7:
	ld a,(wDungeonIndex)		; $4597
	add e			; $459a
	ld l,a			; $459b
	ld h,d			; $459c
	inc (hl)		; $459d
	ld hl,wStatusBarNeedsRefresh		; $459e
	set 4,(hl)		; $45a1
	ret			; $45a3

; [de] += c.
@modea:
	ld a,(de)		; $45a4
	add c			; $45a5
	ld (de),a		; $45a6
	ret			; $45a7

; [de] += c, and [de+1] is the cap for this value.
; Also plays a sound effect if it's operating on wLinkHealth.
@modec:
	ld h,d			; $45a8
	ld l,e			; $45a9

	; Check if we're adding to wLinkHealth
	ld a,<wLinkHealth		; $45aa
	cp e			; $45ac
	ldi a,(hl)		; $45ad
	jr nz,+			; $45ae

	; If so, compare current health to max health
	cp (hl)			; $45b0
	jr nz,+			; $45b1

	; This code will probably only run when you get a heart, but your health is
	; already full.
	ld a,SND_GAINHEART		; $45b3
	jp playSound		; $45b5
+
	add c			; $45b8
	ld (de),a		; $45b9
	jr ++			; $45ba

; [de] += c (as bcd values), and [de+1] is the cap.
@moded:
	call @mode4		; $45bc
	ld h,d			; $45bf
	ld l,e			; $45c0
	inc l			; $45c1
++
	cp (hl)			; $45c2
	ret c			; $45c3
	ldd a,(hl)		; $45c4
	ld (hl),a		; $45c5
	ret			; $45c6

; Adds rupee value of 'c' to 2-byte bcd value at [de].
; Also adds to wTotalRupeesCollected if operating on wNumRupees.
@modee:
	; Get the value of the rupee in bc
	ld a,c			; $45c7
	call getRupeeValue		; $45c8

	; Check whether to add this to wTotalRupeesCollected
	ld a,e			; $45cb
	cp <wNumRupees			; $45cc
	jr nz,++		; $45ce

	ld a,GLOBALFLAG_10000_RUPEES_COLLECTED		; $45d0
	call checkGlobalFlag		; $45d2
	jr nz,++		; $45d5

	; Add the amount to the total rupee counter, set the flag when it reaches 10000.
	ld h,d			; $45d7
	ld l,<wTotalRupeesCollected		; $45d8
	call addDecimalToHlRef		; $45da
	jr nc,++		; $45dd
	ld a,GLOBALFLAG_10000_RUPEES_COLLECTED		; $45df
	call setGlobalFlag		; $45e1

++
	ld h,d			; $45e4
	ld l,e			; $45e5
	call addDecimalToHlRef		; $45e6

	; Check for overflow
	ldi a,(hl)		; $45e9
	ld h,(hl)		; $45ea
	ld l,a			; $45eb
	ld bc,$0999		; $45ec
	call compareHlToBc		; $45ef
	dec a			; $45f2
	ret nz			; $45f3

	ld a,c			; $45f4
	ld (de),a		; $45f5
	inc e			; $45f6
	ld a,b			; $45f7
	ld (de),a		; $45f8
	ld a,SND_RUPEE		; $45f9
	jp playSound		; $45fb

; [de] += c (as bcd values), check wSeedSatchelLevel for the cap.
; Used for giving seeds.
@modef:
	call @mode4		; $45fe
	call setStatusBarNeedsRefreshBit1		; $4601
	ld a,(wSeedSatchelLevel)		; $4604
	ld hl,@seedSatchelCapacities-1		; $4607
	rst_addAToHl			; $460a
	ld a,(de)		; $460b
	cp (hl)			; $460c
	ret c			; $460d

	ld a,(hl)		; $460e
	ld (de),a		; $460f
	ret			; $4610

@seedSatchelCapacities:
	.db $20 $50 $99

; Add a ring to the unappraised ring list.
@mode9:
	; Setting bit 6 means the ring is unappraised
	set 6,c			; $4614
	call realignUnappraisedRings		; $4616

	; Check that there are less than 64 unappraised rings (checking aginst a bcd
	; number)
	cp $64			; $4619
	jr c,+			; $461b

	; If there are already 64 unappraised rings, remove one duplicate ring and
	; re-align the list.
	call @removeOneDuplicateRing		; $461d
	call realignUnappraisedRings		; $4620
+
	; Add the ring to the end of the list
	ld a,c			; $4623
	ld (wUnappraisedRingsEnd-1),a		; $4624
	jr realignUnappraisedRings		; $4627

;;
; Decides on one ring to remove by counting all of the unappraised rings and finding the
; one with the most duplicates.
; @addr{4629}
@removeOneDuplicateRing:
	ld a,($ff00+R_SVBK)	; $4629
	push af			; $462b
	ld a,:w4TmpRingBuffer		; $462c
	ld ($ff00+R_SVBK),a	; $462e

	; Construct w4TmpRingBuffer such that each index corresponds to how many
	; unappraised rings of that index Link has.

	ld hl,w4TmpRingBuffer		; $4630
	ld b,NUM_RINGS		; $4633
	call clearMemory		; $4635

	ld de,wUnappraisedRings		; $4638
	ld b,wUnappraisedRingsEnd-wUnappraisedRings		; $463b
--
	ld a,(de)		; $463d
	and $3f			; $463e
	ld hl,w4TmpRingBuffer		; $4640
	rst_addAToHl			; $4643
	inc (hl)		; $4644
	inc e			; $4645
	dec b			; $4646
	jr nz,--		; $4647

	; Now loop through w4TmpRingBuffer to find the ring with the most duplicates.
	; d = max number of duplicates
	; e = the index with the most duplicates

	ld hl,w4TmpRingBuffer		; $4649
	ld de,$0000		; $464c
	ld b,NUM_RINGS		; $464f
--
	ld a,(hl)		; $4651
	cp d			; $4652
	jr c,+			; $4653
	ld d,a			; $4655
	ld e,l			; $4656
+
	inc l			; $4657
	dec b			; $4658
	jr nz,--		; $4659

	ld a,e			; $465b
	sub <w4TmpRingBuffer			; $465c
	or $40			; $465e
	ld e,a			; $4660

	; Restore wram bank
	pop af			; $4661
	ld ($ff00+R_SVBK),a	; $4662

	; Search for an instance of the ring to be replaced in wUnappraisedRings

	ld hl,wUnappraisedRingsEnd-1		; $4664
--
	ldd a,(hl)		; $4667
	cp e			; $4668
	jr nz,--		; $4669

	; Remove that ring from the list
	inc hl			; $466b
	ld (hl),$ff		; $466c
	ret			; $466e

;;
; Reorganize wUnappraisedRings so that there are no blank spaces (everything gets put into
; a contiguous block at the start). Also updates wNumUnappraisedRingsBcd.
;
; @param[out]	a	Number of unappraised rings (bcd)
; @param[out]	b	Number of unappraised rings (normal number)
; @addr{466f}
realignUnappraisedRings:
	ld hl,wUnappraisedRings		; $466f
--
	; Check if this slot is empty.
	ld a,(hl)		; $4672
	cp $ff			; $4673
	jr nz,++		; $4675

	; If there is a ring later in the list, move it to this slot.
	push hl			; $4677
	call @findNextFilledSlot		; $4678
	pop hl			; $467b
	jr nc,+++		; $467c

	ld (hl),a		; $467e
++
	inc l			; $467f
	ld a,l			; $4680
	cp <wUnappraisedRingsEnd			; $4681
	jr nz,--		; $4683
+++
	jr getNumUnappraisedRings		; $4685

;;
; Find the next filled slot in wUnappraisedRings, and clear it.
;
; @param	hl	Where to start searching in the unappraised ring list
; @param[out]	a	The value of the first non-empty ring slot encountered after hl
; @param[out]	cflag	Set if a non-empty ring slot was encountered
; @addr{4687}
@findNextFilledSlot:
	ldi a,(hl)		; $4687
	cp $ff			; $4688
	jr nz,++		; $468a
	ld a,l			; $468c
	cp <wUnappraisedRingsEnd			; $468d
	jr nz,@findNextFilledSlot		; $468f
	ret			; $4691
++
	dec hl			; $4692
	ld (hl),$ff		; $4693
	scf			; $4695
	ret			; $4696

;;
; Sets wNumUnappraisedRingsBcd, and returns the number of unappraised rings
; (non-bcd) in b.
;
; @param[out]	a	Number of unappraised rings (bcd)
; @param[out]	b	Number of unappraised rings (normal number)
; @addr{4697}
getNumUnappraisedRings:
	push de			; $4697
	ld hl,wUnappraisedRings		; $4698
	ld de,$4000		; $469b
--
	ldi a,(hl)		; $469e
	cp $ff			; $469f
	jr z,+			; $46a1
	inc e			; $46a3
+
	dec d			; $46a4
	jr nz,--		; $46a5

	push bc			; $46a7
	ld a,e			; $46a8
	call hexToDec		; $46a9
	swap c			; $46ac
	or c			; $46ae
	ld (wNumUnappraisedRingsBcd),a		; $46af
	pop bc			; $46b2
	ld b,e			; $46b3
	pop de			; $46b4
	ret			; $46b5

;;
; @addr{46b6}
_func_46b6:
	ldh a,(<hFF8B)	; $46b6
	cp $20			; $46b8
	ret nc			; $46ba
	push bc			; $46bb
	call $46dc		; $46bc
	pop bc			; $46bf
	ret nc			; $46c0
	jp z,setStatusBarNeedsRefreshBit1		; $46c1
	push bc			; $46c4
	cpl			; $46c5
	add $88			; $46c6
	ld l,a			; $46c8
	ldh a,(<hFF8B)	; $46c9
	ld c,a			; $46cb
	cp $0c			; $46cc
	jr nz,+			; $46ce

	ld a,(hl)		; $46d0
	ld (hl),c		; $46d1
	call $46dc		; $46d2
+
	ld hl,wStatusBarNeedsRefresh		; $46d5
	set 0,(hl)		; $46d8
	pop bc			; $46da
	ret			; $46db

	ld c,a			; $46dc
	ld hl,wInventoryB		; $46dd
	ld b,$12		; $46e0
_label_3f_073:
	ldi a,(hl)		; $46e2
	cp c			; $46e3
	jr z,_label_3f_075	; $46e4
	dec b			; $46e6
	jr nz,_label_3f_073	; $46e7
	dec b			; $46e9
	ld l,$88		; $46ea
_label_3f_074:
	ldi a,(hl)		; $46ec
	or a			; $46ed
	jr nz,_label_3f_074	; $46ee
_label_3f_075:
	dec l			; $46f0
	ld (hl),c		; $46f1
	ld a,l			; $46f2
	sub $8a			; $46f3
	bit 7,b			; $46f5
	ret			; $46f7

;;
; Loads 7 bytes of "display data" describing a treasure's sprite, its palette, what its
; inventory text should be, and whether to display a "quantity" next to it (ie. level).
;
; See "treasureDisplayData2" to see the exact format of these 7 bytes.
;
; @param	l	Treasure index
; @param[out]	hl	Where the data is stored (wTmpcec0).
; @addr{46f8}
loadTreasureDisplayData:
	ld a,l			; $46f8
	push de			; $46f9
	call @getTableIndices		; $46fa

	; Set up hl to point to "[treasureDisplayData2+e*2]+d*7.

	push bc			; $46fd
	ld hl,$0000		; $46fe

	; hl = d*7
	ld a,d			; $4701
	or a			; $4702
	jr z,+			; $4703
	cpl			; $4705
	inc a			; $4706
	ld l,a			; $4707
	ld h,$ff		; $4708
	ld a,d			; $470a
	call multiplyABy8		; $470b
	add hl,bc		; $470e
+
	push hl			; $470f
	ld a,e			; $4710
	ld hl,treasureDisplayData2		; $4711
	rst_addDoubleIndex			; $4714
	ldi a,(hl)		; $4715
	ld h,(hl)		; $4716
	ld l,a			; $4717
	pop bc			; $4718
	add hl,bc		; $4719

	; Now copy the 7 bytes to wTmpcec0
	ld de,wTmpcec0		; $471a
	ld b,$07		; $471d
-
	ldi a,(hl)		; $471f
	ld (de),a		; $4720
	inc e			; $4721
	dec b			; $4722
	jr nz,-			; $4723

	ld hl,wTmpcec0		; $4725
	pop bc			; $4728
	pop de			; $4729
	ret			; $472a

;;
; @param	a	Item index
; @param[out]	d	Index to read from the sub-table (in turn determined by 'e')
;			This is usually the item's level/loaded ammo, but if the item is
;			not in treasureDisplayData1, then this equals 'a'.
; @param[out]	e	Which sub-table to use from treasureDisplayData2
; @addr{472b}
@getTableIndices:
	ld d,a			; $472b
	ld hl,treasureDisplayData1		; $472c
-
	ldi a,(hl)		; $472f
	or a			; $4730
	jr z,+			; $4731

	cp d			; $4733
	jr z,+			; $4734

	inc hl			; $4736
	inc hl			; $4737
	jr -			; $4738

+
	ldi a,(hl)		; $473a
	ld e,(hl)		; $473b
	or a			; $473c
	jr z,+			; $473d

	ld l,a			; $473f
	ld h,>wc600Block	; $4740
	ld d,(hl)		; $4742
+
	ret			; $4743

;;
; Might be related to item drops from enemies?
;
; @param	c
; @param[out]	c
; @param[out]	zflag
; @addr{4744}
func_4744:
	ld a,c			; $4744
	or a			; $4745
	set 7,a			; $4746
	jr nz,+			; $4748

	ldh a,(<hActiveObjectType)	; $474a
	add Object.subid			; $474c
	ld e,a			; $474e
	ld a,(de)		; $474f
+
	ld hl,$4a46		; $4750
	rst_addAToHl			; $4753
	ld a,(hl)		; $4754
	ld c,a			; $4755
	cp $ff			; $4756
	jr z,checkItemDropUnavailable_body@done		; $4758

	swap a			; $475a
	rrca			; $475c
	and $07			; $475d
	ld hl,$47fe		; $475f
	rst_addDoubleIndex			; $4762
	ldi a,(hl)		; $4763
	ld h,(hl)		; $4764
	ld l,a			; $4765
	call getRandomNumber		; $4766
	and $3f			; $4769
	call checkFlag		; $476b
	jr z,checkItemDropUnavailable_body@done		; $476e

	ld a,c			; $4770
	and $1f			; $4771
	ld hl,$47be		; $4773
	rst_addDoubleIndex			; $4776
	ldi a,(hl)		; $4777
	ld h,(hl)		; $4778
	ld l,a			; $4779
	call getRandomNumber		; $477a
	and $1f			; $477d
	rst_addAToHl			; $477f
	ld a,(hl)		; $4780
	ld c,a			; $4781

;;
; Checks whether an item drop of a given type can spawn.
;
; @param	c	Item drop index (see constants/itemDrops.s)
; @param[out]	c	$ff if item cannot spawn (Link doesn't have it)
; @addr{4782}
checkItemDropUnavailable_body:
	ld a,c			; $4782
	ld hl,_itemDropAvailabilityTable		; $4783
	rst_addDoubleIndex			; $4786
	ldi a,(hl)		; $4787
	ld b,(hl)		; $4788
	ld l,a			; $4789
	ld h,>wc600Block		; $478a
	ld a,(hl)		; $478c
	and b			; $478d
	ret nz			; $478e
@done:
	ld c,$ff		; $478f
	ret			; $4791

; Rings are divided into "tiers" (called "classes" in TourianTourist's ring guide). These
; tiers are mostly used by gasha spots, each of which can give rings from a set tier list.
;
; Each tier has 8 ring types (except for the last one, which only has 2). Some have
; repeated rings in order to fill that list.
;
; @addr{4792}
ringTierTable:
	.dw @tier0
	.dw @tier1
	.dw @tier2
	.dw @tier3
	.dw @tier4

@tier0:
	.db EXPERTS_RING	CHARGE_RING	FIRST_GEN_RING	BOMBPROOF_RING
	.db ENERGY_RING		DBL_EDGED_RING	CHARGE_RING	DBL_EDGED_RING
@tier1:
	.db POWER_RING_L2	PEACE_RING	HEART_RING_L2	RED_JOY_RING
	.db GASHA_RING		PEACE_RING	WHIMSICAL_RING	PROTECTION_RING
@tier2:
	.db MAPLES_RING		TOSS_RING	RED_LUCK_RING	WHISP_RING
	.db ZORA_RING		FIST_RING	QUICKSAND_RING	ROCS_RING
@tier3:
	.db CURSED_RING		LIKE_LIKE_RING	BLUE_LUCK_RING	GREEN_HOLY_RING
	.db BLUE_HOLY_RING	RED_HOLY_RING	OCTO_RING	MOBLIN_RING
@tier4:
	.db GREEN_RING		RANG_RING_L2

	ld b,(hl)		; $47be
	ld c,b			; $47bf
	ld h,(hl)		; $47c0
	ld c,b			; $47c1
	add (hl)		; $47c2
	ld c,b			; $47c3
	and (hl)		; $47c4
	ld c,b			; $47c5
	add $48			; $47c6
	and $48			; $47c8
	ld b,$49		; $47ca
	ld h,$49		; $47cc
	ld b,(hl)		; $47ce
	ld c,c			; $47cf
	ld h,(hl)		; $47d0
	ld c,c			; $47d1
_label_3f_085:
	add (hl)		; $47d2
	ld c,c			; $47d3
	and (hl)		; $47d4
	ld c,c			; $47d5
	add $49			; $47d6
	and $49			; $47d8
	ld b,$4a		; $47da
	ld h,$4a		; $47dc


; Each row corresponds to an item drop (see constants/itemDrops.s).
;   Byte 0: Variable in $c600 block to check
;   Byte 1: Value to AND with that variable to check availability; if nonzero, the item
;           can drop.
; @addr{47de}
_itemDropAvailabilityTable:
	.db <wc608, $ff ; ITEM_DROP_FAIRY
	.db <wc608, $ff ; ITEM_DROP_HEART
	.db <wc608, $ff ; ITEM_DROP_1_RUPEE
	.db <wc608, $ff ; ITEM_DROP_5_RUPEES
	.db (<wObtainedTreasureFlags+TREASURE_BOMBS/8)        , 1<<(TREASURE_BOMBS&7)
	.db (<wObtainedTreasureFlags+TREASURE_EMBER_SEEDS/8)  , 1<<(TREASURE_EMBER_SEEDS&7)
	.db (<wObtainedTreasureFlags+TREASURE_SCENT_SEEDS/8)  , 1<<(TREASURE_SCENT_SEEDS&7)
	.db (<wObtainedTreasureFlags+TREASURE_PEGASUS_SEEDS/8), 1<<(TREASURE_PEGASUS_SEEDS&7)
	.db (<wObtainedTreasureFlags+TREASURE_GALE_SEEDS/8)   , 1<<(TREASURE_GALE_SEEDS&7)
	.db (<wObtainedTreasureFlags+TREASURE_MYSTERY_SEEDS/8), 1<<(TREASURE_MYSTERY_SEEDS&7)

	rlca			; $47f2
	nop			; $47f3
	rlca			; $47f4
	nop			; $47f5
	rlca			; $47f6
	nop			; $47f7
	rlca			; $47f8
	nop			; $47f9
	rlca			; $47fa
	nop			; $47fb
	ld ($0eff),sp		; $47fc
	ld c,b			; $47ff
	ld c,$48		; $4800
	ld d,$48		; $4802
	ld e,$48		; $4804
	ld h,$48		; $4806
	ld l,$48		; $4808
	ld (hl),$48		; $480a
	ld a,$48		; $480c
	ld ($0000),sp		; $480e
.db $20 $80 $00 $00 $10 $08 $10 $08
.db $20 $80
	ld bc,$1080		; $481b
	ld ($0950),sp		; $481e
	inc h			; $4821
	adc b			; $4822
	add c			; $4823
	or b			; $4824
	ld (de),a		; $4825
	ld c,c			; $4826
	ld d,b			; $4827
	ld c,c			; $4828
	inc h			; $4829
	adc b			; $482a
	sbc c			; $482b
	or d			; $482c
	jp nc,$e3b2		; $482d
	xor d			; $4830
	call z,$8f81		; $4831
	add $6c			; $4834
	cp d			; $4836
	rst $38			; $4837
	ld ($bddd),a		; $4838
	cp a			; $483b
	sub $ed			; $483c
	rst $38			; $483e
	rst $38			; $483f
	rst $38			; $4840
	rst $38			; $4841
	rst $38			; $4842
	rst $38			; $4843
	rst $38			; $4844
	rst $38			; $4845
	ld bc,$0101		; $4846
	ld bc,$0101		; $4849
	ld bc,$0101		; $484c
	ld bc,$0101		; $484f
	ld bc,$0101		; $4852
	ld bc,$0101		; $4855
	ld bc,$0101		; $4858
	ld bc,$0101		; $485b
	ld bc,$0101		; $485e
	ld bc,$0101		; $4861
	ld bc,$0101		; $4864
	ld bc,$0101		; $4867
	ld bc,$0101		; $486a
	ld bc,$0101		; $486d
	ld bc,$0201		; $4870
	ld (bc),a		; $4873
	ld (bc),a		; $4874
	ld (bc),a		; $4875
	ld (bc),a		; $4876
	ld (bc),a		; $4877
	ld (bc),a		; $4878
	inc bc			; $4879
	inc bc			; $487a
	nop			; $487b
	ld bc,$0602		; $487c
	ld b,$06		; $487f
	ld b,$05		; $4881
	dec b			; $4883
	add hl,bc		; $4884
	dec b			; $4885
	ld bc,$0101		; $4886
	ld bc,$0101		; $4889
	ld bc,$0101		; $488c
	ld bc,$0101		; $488f
	ld bc,$0101		; $4892
	ld bc,$0807		; $4895
	add hl,bc		; $4898
	rlca			; $4899
	ld b,$05		; $489a
	dec b			; $489c
	dec b			; $489d
	ld b,$06		; $489e
	rlca			; $48a0
	rlca			; $48a1
	ld ($0908),sp		; $48a2
	dec b			; $48a5
	rrca			; $48a6
	rrca			; $48a7
	rrca			; $48a8
	ld bc,$0101		; $48a9
	ld bc,$0101		; $48ac
	ld bc,$0101		; $48af
	ld (bc),a		; $48b2
	ld (bc),a		; $48b3
	ld (bc),a		; $48b4
	ld (bc),a		; $48b5
	ld (bc),a		; $48b6
	ld (bc),a		; $48b7
	ld (bc),a		; $48b8
	ld (bc),a		; $48b9
	ld (bc),a		; $48ba
	ld (bc),a		; $48bb
	ld (bc),a		; $48bc
	ld bc,$0302		; $48bd
	inc bc			; $48c0
	inc bc			; $48c1
	inc bc			; $48c2
	ld (bc),a		; $48c3
	nop			; $48c4
	nop			; $48c5
	inc b			; $48c6
	inc b			; $48c7
	inc b			; $48c8
	inc b			; $48c9
	inc b			; $48ca
	inc b			; $48cb
	inc b			; $48cc
	inc b			; $48cd
	inc b			; $48ce
	inc b			; $48cf
	inc b			; $48d0
	inc b			; $48d1
	inc b			; $48d2
	inc b			; $48d3
	inc b			; $48d4
	inc b			; $48d5
	inc b			; $48d6
	inc b			; $48d7
	inc b			; $48d8
	inc b			; $48d9
	inc b			; $48da
	inc b			; $48db
	inc b			; $48dc
	inc b			; $48dd
	inc b			; $48de
	inc b			; $48df
	inc b			; $48e0
	inc b			; $48e1
	inc b			; $48e2
	inc b			; $48e3
	inc b			; $48e4
	inc b			; $48e5
	dec b			; $48e6
	dec b			; $48e7
	dec b			; $48e8
	dec b			; $48e9
	dec b			; $48ea
	dec b			; $48eb
	ld b,$06		; $48ec
	ld b,$06		; $48ee
	ld b,$07		; $48f0
	rlca			; $48f2
	rlca			; $48f3
	rlca			; $48f4
	rlca			; $48f5
	rlca			; $48f6
	ld ($0808),sp		; $48f7
	ld ($0908),sp		; $48fa
	add hl,bc		; $48fd
	add hl,bc		; $48fe
	add hl,bc		; $48ff
	add hl,bc		; $4900
	dec b			; $4901
	ld b,$07		; $4902
	ld ($0109),sp		; $4904
	ld bc,$0101		; $4907
	ld bc,$0101		; $490a
	ld bc,$0101		; $490d
	ld (bc),a		; $4910
	ld (bc),a		; $4911
	ld (bc),a		; $4912
	ld (bc),a		; $4913
	ld (bc),a		; $4914
	ld (bc),a		; $4915
	ld (bc),a		; $4916
	ld (bc),a		; $4917
	ld (bc),a		; $4918
	inc bc			; $4919
	inc bc			; $491a
	nop			; $491b
	inc b			; $491c
	inc b			; $491d
	inc b			; $491e
	inc b			; $491f
	inc b			; $4920
	inc b			; $4921
	inc b			; $4922
	inc b			; $4923
	inc b			; $4924
	inc b			; $4925
	ld bc,$0101		; $4926
	ld bc,$0101		; $4929
	ld bc,$0202		; $492c
	ld (bc),a		; $492f
	ld (bc),a		; $4930
	inc bc			; $4931
	inc bc			; $4932
	inc bc			; $4933
	inc bc			; $4934
	nop			; $4935
	inc b			; $4936
	inc b			; $4937
	inc b			; $4938
	inc b			; $4939
	inc b			; $493a
	inc b			; $493b
	inc b			; $493c
	inc b			; $493d
	add hl,bc		; $493e
	ld ($0707),sp		; $493f
	ld b,$06		; $4942
	dec b			; $4944
	dec b			; $4945
	ld bc,$0101		; $4946
	ld bc,$0101		; $4949
	ld bc,$0101		; $494c
	ld bc,$0101		; $494f
	ld bc,$0201		; $4952
	ld (bc),a		; $4955
	ld (bc),a		; $4956
	ld (bc),a		; $4957
	inc bc			; $4958
	inc bc			; $4959
	nop			; $495a
	inc b			; $495b
	inc b			; $495c
	inc b			; $495d
	inc b			; $495e
	add hl,bc		; $495f
	ld ($0607),sp		; $4960
	dec b			; $4963
	dec b			; $4964
	rlca			; $4965
	rrca			; $4966
	rrca			; $4967
	ld bc,$0101		; $4968
	ld bc,$0101		; $496b
	ld bc,$0101		; $496e
	ld bc,$0202		; $4971
	ld (bc),a		; $4974
	ld (bc),a		; $4975
	ld (bc),a		; $4976
	ld (bc),a		; $4977
	ld (bc),a		; $4978
	inc bc			; $4979
	inc bc			; $497a
	nop			; $497b
	ld bc,$0602		; $497c
	ld b,$06		; $497f
	ld b,$05		; $4981
	dec b			; $4983
	add hl,bc		; $4984
	add hl,bc		; $4985
	ld bc,$0101		; $4986
	ld bc,$0101		; $4989
	ld (bc),a		; $498c
	ld (bc),a		; $498d
	ld (bc),a		; $498e
	ld (bc),a		; $498f
	ld (bc),a		; $4990
	inc bc			; $4991
	inc bc			; $4992
	inc bc			; $4993
	nop			; $4994
	inc b			; $4995
	inc b			; $4996
	inc b			; $4997
	inc b			; $4998
	inc b			; $4999
	inc b			; $499a
	inc b			; $499b
	inc b			; $499c
	inc b			; $499d
	inc b			; $499e
	add hl,bc		; $499f
	ld ($0707),sp		; $49a0
	ld b,$05		; $49a3
	ld b,$01		; $49a5
	ld bc,$0101		; $49a7
	ld (bc),a		; $49aa
	ld (bc),a		; $49ab
	ld (bc),a		; $49ac
	ld (bc),a		; $49ad
	ld (bc),a		; $49ae
	inc bc			; $49af
	inc bc			; $49b0
	inc bc			; $49b1
	nop			; $49b2
	inc b			; $49b3
	inc b			; $49b4
	inc b			; $49b5
	inc b			; $49b6
	add hl,bc		; $49b7
	add hl,bc		; $49b8
	ld ($0808),sp		; $49b9
	rlca			; $49bc
	rlca			; $49bd
	rlca			; $49be
	ld b,$06		; $49bf
	ld b,$09		; $49c1
	dec b			; $49c3
	dec b			; $49c4
	dec b			; $49c5
	ld bc,$0101		; $49c6
	ld bc,$0202		; $49c9
	ld (bc),a		; $49cc
	ld (bc),a		; $49cd
	ld (bc),a		; $49ce
	ld (bc),a		; $49cf
	inc bc			; $49d0
	inc bc			; $49d1
	inc bc			; $49d2
	inc bc			; $49d3
	inc bc			; $49d4
	inc bc			; $49d5
	inc b			; $49d6
	inc b			; $49d7
	inc b			; $49d8
	inc b			; $49d9
	inc b			; $49da
	inc b			; $49db
	inc b			; $49dc
	inc b			; $49dd
	inc b			; $49de
	inc b			; $49df
	inc b			; $49e0
	inc b			; $49e1
	inc b			; $49e2
	inc b			; $49e3
	inc b			; $49e4
	inc b			; $49e5
	ld (bc),a		; $49e6
	ld (bc),a		; $49e7
	ld (bc),a		; $49e8
	ld (bc),a		; $49e9
	ld (bc),a		; $49ea
	ld (bc),a		; $49eb
	ld (bc),a		; $49ec
	ld (bc),a		; $49ed
	ld (bc),a		; $49ee
	ld (bc),a		; $49ef
	inc bc			; $49f0
	inc bc			; $49f1
	inc bc			; $49f2
	inc bc			; $49f3
	inc bc			; $49f4
	inc bc			; $49f5
	add hl,bc		; $49f6
	add hl,bc		; $49f7
	ld ($0808),sp		; $49f8
	rlca			; $49fb
	rlca			; $49fc
	rlca			; $49fd
	ld b,$06		; $49fe
	ld b,$05		; $4a00
	dec b			; $4a02
	dec b			; $4a03
	add hl,bc		; $4a04
	dec b			; $4a05
	ld bc,$0101		; $4a06
	ld bc,$0101		; $4a09
	ld bc,$0101		; $4a0c
	ld bc,$0101		; $4a0f
	ld bc,$0101		; $4a12
	ld (bc),a		; $4a15
	ld bc,$0202		; $4a16
	ld (bc),a		; $4a19
	ld (bc),a		; $4a1a
	ld (bc),a		; $4a1b
	ld (bc),a		; $4a1c
	ld (bc),a		; $4a1d
	ld (bc),a		; $4a1e
	ld (bc),a		; $4a1f
	ld (bc),a		; $4a20
	ld (bc),a		; $4a21
	inc bc			; $4a22
	inc bc			; $4a23
	inc bc			; $4a24
	inc bc			; $4a25
	nop			; $4a26
	nop			; $4a27
	nop			; $4a28
	nop			; $4a29
	nop			; $4a2a
	nop			; $4a2b
	nop			; $4a2c
	nop			; $4a2d
	nop			; $4a2e
	nop			; $4a2f
	nop			; $4a30
	nop			; $4a31
	nop			; $4a32
	nop			; $4a33
	nop			; $4a34
	nop			; $4a35
	nop			; $4a36
	nop			; $4a37
	nop			; $4a38
	nop			; $4a39
	nop			; $4a3a
	nop			; $4a3b
	nop			; $4a3c
	nop			; $4a3d
	nop			; $4a3e
	nop			; $4a3f
	nop			; $4a40
	nop			; $4a41
	nop			; $4a42
	nop			; $4a43
	nop			; $4a44
	nop			; $4a45
	rst $38			; $4a46
	rst $28			; $4a47
	rst $38			; $4a48
	rst $38			; $4a49
	rst $38			; $4a4a
	rst $38			; $4a4b
	rst $38			; $4a4c
	rst $38			; $4a4d
	and (hl)		; $4a4e
	adc (hl)		; $4a4f
	add (hl)		; $4a50
	pop bc			; $4a51
	xor h			; $4a52
	add (hl)		; $4a53
	rst $38			; $4a54
	add l			; $4a55
	add c			; $4a56
	rst $38			; $4a57
	adc (hl)		; $4a58
	rst $28			; $4a59
	adc (hl)		; $4a5a
	ret nz			; $4a5b
	rst $38			; $4a5c
	ld h,b			; $4a5d
	and l			; $4a5e
	xor $8e			; $4a5f
	res 0,b			; $4a61
	rst_jumpTable			; $4a63
	adc (hl)		; $4a64
	adc (hl)		; $4a65
	xor h			; $4a66
	adc b			; $4a67
	ld b,a			; $4a68
	and h			; $4a69
	ld b,d			; $4a6a
	jp nz,$ff47		; $4a6b
	xor (hl)		; $4a6e
	rst $38			; $4a6f
	rst $38			; $4a70
	rst $38			; $4a71
	ld h,b			; $4a72
	rst $38			; $4a73
	rst $38			; $4a74
	rst $38			; $4a75
	add c			; $4a76
	adc (hl)		; $4a77
	xor (hl)		; $4a78
	rst $38			; $4a79
	rst $38			; $4a7a
	xor (hl)		; $4a7b
	rst $38			; $4a7c
	rst $38			; $4a7d
	rst $38			; $4a7e
	ld h,c			; $4a7f
	rst $38			; $4a80
	rst $38			; $4a81
	ld h,b			; $4a82
	xor d			; $4a83
	and d			; $4a84
	rst $38			; $4a85
	adc (hl)		; $4a86
	ld l,l			; $4a87
	add l			; $4a88
	adc (hl)		; $4a89
	rst $38			; $4a8a
	adc l			; $4a8b
	add d			; $4a8c
	and b			; $4a8d
	add a			; $4a8e
	adc b			; $4a8f
	xor h			; $4a90
	and b			; $4a91
	ld h,h			; $4a92
	rst $38			; $4a93
	daa			; $4a94
	res 4,l			; $4a95
	adc h			; $4a97
	ld h,a			; $4a98
	rst $38			; $4a99
	rst $38			; $4a9a
	adc (hl)		; $4a9b
	rst $38			; $4a9c
	rst $38			; $4a9d
	rst $38			; $4a9e
	rst $38			; $4a9f
	rst $38			; $4aa0
	rst $38			; $4aa1
	rst $38			; $4aa2
	rst $38			; $4aa3
	and d			; $4aa4
	rst $38			; $4aa5
	rst $38			; $4aa6
	rst $38			; $4aa7
	rst $38			; $4aa8
	rst $38			; $4aa9
	ld ($ff00+R_IE),a	; $4aaa
	rst $38			; $4aac
	rst $38			; $4aad
	rst $38			; $4aae
	rst $38			; $4aaf
	rst $38			; $4ab0
	rst $38			; $4ab1
	rst $38			; $4ab2
	rst $38			; $4ab3
	rst $38			; $4ab4
	rst $38			; $4ab5
	rst $28			; $4ab6
	rst $28			; $4ab7
	rst $28			; $4ab8
	rst $28			; $4ab9
	rst $28			; $4aba
	rst $28			; $4abb
	rst $28			; $4abc
	rst $28			; $4abd
	rst $38			; $4abe
	rst $38			; $4abf
	rst $38			; $4ac0
	rst $38			; $4ac1
	rst $38			; $4ac2
	rst $38			; $4ac3
	rst $38			; $4ac4
	rst $38			; $4ac5
	rst $38			; $4ac6
	ld b,c			; $4ac7
	add a			; $4ac8
	ld h,l			; $4ac9
	add (hl)		; $4aca
	adc (hl)		; $4acb
	and a			; $4acc
	xor (hl)		; $4acd
	and b			; $4ace
	ld h,e			; $4acf
	ld l,c			; $4ad0
	and l			; $4ad1
	ld l,(hl)		; $4ad2
	rst $38			; $4ad3
	rst $38			; $4ad4
	rst $38			; $4ad5

;;
; @param	a	Treasure index
; @param	c	Treasure "parameter"
; @addr{4ad6}
_checkIncreaseGashaMaturityForGettingTreasure:
	push bc			; $4ad6
	ld b,a			; $4ad7
	ld hl,@data-1		; $4ad8
--
	inc hl			; $4adb
	ldi a,(hl)		; $4adc
	or a			; $4add
	jr z,++			; $4ade
	cp b			; $4ae0
	jr nz,--		; $4ae1

	cp TREASURE_HEART_REFILL			; $4ae3
	ld a,c			; $4ae5
	jr z,+			; $4ae6
	ld a,(hl)		; $4ae8
+
	call addToGashaMaturity		; $4ae9
++
	pop bc			; $4aec
	ret			; $4aed

@data:
	.db TREASURE_ESSENCE		150
	.db TREASURE_HEART_PIECE	 36
	.db TREASURE_TRADEITEM		100
	.db TREASURE_HEART_REFILL	  4
	.db $00

;;
; Called once as a textbox is about to be shown.
; @addr{4af7}
initTextbox:
	ld a,(wTextboxFlags)		; $4af7
	bit TEXTBOXFLAG_BIT_DONTCHECKPOSITION,a			; $4afa
	jr nz,++		; $4afc

	; Decide whether to put the textbox at the top or bottom
	ldh a,(<hCameraY)	; $4afe
	ld b,a			; $4b00
	ld a,(w1Link.yh)		; $4b01
	sub b			; $4b04
	cp $48			; $4b05
	ld a,$02		; $4b07
	jr c,+			; $4b09
	xor a			; $4b0b
+
	ld (wTextboxPosition),a		; $4b0c
++
	ld a,$07		; $4b0f
	ld ($ff00+R_SVBK),a	; $4b11
	ld hl,$d000		; $4b13
	ld bc,$0460		; $4b16
	call clearMemoryBc		; $4b19
	jp _initTextboxStuff		; $4b1c

;;
; Called every frame while a textbox is being shown.
; @addr{4b1f}
updateTextbox:
	ld a,$07		; $4b1f
	ld ($ff00+R_SVBK),a	; $4b21
	ld d,$d0		; $4b23
	ld a,(wTextIsActive)		; $4b25
	inc a			; $4b28
	jr nz,+			; $4b29

	; If [wTextIsActive] == 0xff...
	ld (wTextDisplayMode),a		; $4b2b
	ld h,d			; $4b2e
	ld l,<w7TextDisplayState	; $4b2f
	ld (hl),$0f		; $4b31
	inc l			; $4b33
	set 3,(hl)		; $4b34
+
	call @updateText	; $4b36

	; Stop everything if [wTextIsActive] == 0
	ld a,(wTextIsActive)		; $4b39
	or a			; $4b3c
	ret nz			; $4b3d

	ld (wTextboxFlags),a		; $4b3e
	jp stubThreadStart		; $4b41

;;
; @addr{4b44}
@updateText:
	ld a,(wTextIsActive)		; $4b44
	cp $80			; $4b47
	ret z			; $4b49

	ld e,<w7TextDisplayState	; $4b4a
	ld a,(wTextDisplayMode)		; $4b4c
	rst_jumpTable			; $4b4f
.dw @standardText
.dw @textOption
.dw @inventoryText

;;
; @addr{4b56}
@standardText:
	ld a,(de)		; $4b56
	rst_jumpTable			; $4b57
.dw @standardTextState0
.dw @standardTextState1
.dw @standardTextState2
.dw @standardTextState3
.dw @standardTextState4
.dw @standardTextState5
.dw @standardTextState6
.dw @standardTextState7
.dw @standardTextState8
.dw @standardTextState9
.dw @standardTextStatea
.dw @standardTextStateb
.dw @standardTextStatec
.dw @standardTextStated
.dw @standardTextStatee
.dw @standardTextStatef
.dw @standardTextState10

;;
; An option has come up (ie yes/no)
; @addr{4b7a}
@textOption:
	ld a,(de)		; $4b7a
	rst_jumpTable			; $4b7b
.dw textOptionCode@state00
.dw textOptionCode@state01
.dw textOptionCode@state02
.dw textOptionCode@state03
.dw textOptionCode@state04

;;
; @addr{4b86}
@inventoryText:
	ld a,(de)		; $4b86
	rst_jumpTable			; $4b87
.dw inventoryTextCode@state00
.dw inventoryTextCode@state01
.dw inventoryTextCode@state02
.dw inventoryTextCode@state03
.dw inventoryTextCode@state04
.dw inventoryTextCode@state05
.dw inventoryTextCode@state06
.dw inventoryTextCode@state07

;;
; Initializing
; @addr{4b98}
@standardTextState0:
	ld a,$01		; $4b98
	ld (de),a		; $4b9a
	call _saveTilesUnderTextbox		; $4b9b
	call _initTextboxMapping		; $4b9e
	jp _dmaTextboxMap		; $4ba1

;;
; Prepare to draw the top line.
; @addr{4ba4}
@standardTextState1:
	ld h,d			; $4ba4
	ld l,<w7TextDisplayState	; $4ba5
	inc (hl)		; $4ba7
	ld l,<w7d0d3		; $4ba8
	ld (hl),$40		; $4baa
	ld l,<w7CharacterDisplayLength		; $4bac
	ldi a,(hl)		; $4bae
	ld (hl),a		; $4baf
	call _drawLineOfText		; $4bb0
	jp _dmaTextGfxBuffer		; $4bb3

;;
; Displaying a row of characters
; State 2: top row
; State 4: bottom row
; State A: bottom row, next row will come up automatically
; @addr{4bb6}
@standardTextState2:
@standardTextState4:
@standardTextStatea:
	call _getNextCharacterToDisplay		; $4bb6
	jr z,+			; $4bb9

	call _updateCharacterDisplayTimer		; $4bbb
	ret nz			; $4bbe

	call _displayNextTextCharacter		; $4bbf
	call _dmaTextboxMap		; $4bc2
	ld d,$d0		; $4bc5
	call _getNextCharacterToDisplay		; $4bc7
	ret nz			; $4bca
+
	call $53eb		; $4bcb
	ret nz			; $4bce

	ld d,$d0		; $4bcf
	call _func_5296		; $4bd1
	ret nz			; $4bd4

	ld h,d			; $4bd5
	ld l,<w7TextStatus		; $4bd6
	ld a,(hl)		; $4bd8
	or a			; $4bd9
	ld l,<w7TextDisplayState	; $4bda
	jr z,@textFinished	; $4bdc

	inc (hl)		; $4bde
	ld l,<w7CharacterDisplayLength		; $4bdf
	ldi a,(hl)		; $4be1
	ld (hl),a		; $4be2
	ret			; $4be3

@textFinished:
	ld (hl),$0f		; $4be4
	ret			; $4be6

;;
; Preparing to draw the bottom line
; @addr{4be7}
@standardTextState3:
@standardTextState9:
	call _updateCharacterDisplayTimer		; $4be7
	ret nz			; $4bea

	call _drawLineOfText		; $4beb
	ld a,$02		; $4bee
	call _dmaTextGfxBuffer		; $4bf0
	ld hl,w7TextDisplayState		; $4bf3
	inc (hl)		; $4bf6
	ld l,<w7d0d3		; $4bf7
	ld (hl),$60		; $4bf9
	ld l,<w7CharacterDisplayLength		; $4bfb
	ldi a,(hl)		; $4bfd
	ld (hl),a		; $4bfe
	ret			; $4bff

;;
; Waiting for input to display the next 2 rows of characters
; @addr{4c00}
@standardTextState5:
	ld a,(wKeysJustPressed)		; $4c00
	and BTN_A | BTN_B		; $4c03
	jp z,_updateTextboxArrow		; $4c05

	ld a,SND_TEXT_2		; $4c08
	call playSound		; $4c0a
	ld h,d			; $4c0d
	ld l,<w7d0c1		; $4c0e
	res 0,(hl)		; $4c10
	jr @standardTextStateb	; $4c12

;;
; Doesn't really do anything
; @addr{4c14}
@standardTextState6:
@standardTextStatec:
	; Go to state $07/0d
	ld h,d			; $4c14
	ld l,e			; $4c15
	inc (hl)		; $4c16

	jp _dmaTextboxMap		; $4c17

;;
; Shifts the text up one tile.
; @addr{4c1a}
@standardTextState7:
@standardTextStated:
	; Go to state $08/0e
	ld h,d			; $4c1a
	ld l,e			; $4c1b
	inc (hl)		; $4c1c

	call _shiftTextboxMapUp		; $4c1d
	jp _subFirstRowOfTextMapBy20		; $4c20

;;
; The first of the next 2 lines of text is about to come up.
; @addr{4c23}
@standardTextState8:
	; Go to state $09
	ld h,d			; $4c23
	ld l,e			; $4c24
	inc (hl)		; $4c25

	ld l,<w7CharacterDisplayLength		; $4c26
	ldi a,(hl)		; $4c28
	ld (hl),a		; $4c29

	; Redraw the previous line of text to the top line.

	call _dmaTextboxMap		; $4c2a
	xor a			; $4c2d
	jp _dmaTextGfxBuffer		; $4c2e

;;
; A new line has just been drawn after scrolling text up. Another line of text
; still needs to scroll up.
; @addr{4c31}
@standardTextStateb:
	; Go to state $0c
	ld h,d			; $4c31
	ld l,e			; $4c32
	inc (hl)		; $4c33

	; Get the position of the red arrow, remove it
	ld l,<w7d0cc		; $4c34
	ld a,(hl)		; $4c36
	add $12			; $4c37
	and $1f			; $4c39
	add <w7TextboxMap+$80			; $4c3b
	ld l,a			; $4c3d
	ld h,>w7TextboxMap		; $4c3e
	ld (hl),$02		; $4c40

	call _shiftTextboxMapUp		; $4c42
	jp _clearTopRowOfTextMap		; $4c45

;;
; The second new line is ready to be shown.
; @addr{4c48}
@standardTextStatee:
	; Go to state $03
	ld h,d			; $4c48
	ld l,e			; $4c49
	ld (hl),$03		; $4c4a

	ld l,<w7CharacterDisplayLength		; $4c4c
	ldi a,(hl)		; $4c4e
	ld (hl),a		; $4c4f

	call _dmaTextboxMap		; $4c50
	xor a			; $4c53
	jp _dmaTextGfxBuffer		; $4c54

;;
; @addr{4c57}
@standardTextStatef:
	ld h,d			; $4c57
	ld l,<w7d0ef		; $4c58
	bit 7,(hl)		; $4c5a
	jr z,@label_3f_096	; $4c5c

	ld a,(wKeysJustPressed)		; $4c5e
	and BTN_A | BTN_B	; $4c61
	ret z			; $4c63

	ld (hl),$00		; $4c64
	ld l,e			; $4c66
	ld (hl),$00		; $4c67
	ld a,<TX_0049		; $4c69
	ld (wTextIndexL),a		; $4c6b
	ld a,>TX_0049		; $4c6e
	add $04			; $4c70
	ld (wTextIndexH),a		; $4c72
	call _checkInitialTextCommands		; $4c75
	ld a,SND_CRANEGAME	; $4c78
	call playSound		; $4c7a
	ld a,TREASURE_HEART_CONTAINER		; $4c7d
	ld c,$04		; $4c7f
	jp giveTreasure		; $4c81

@label_3f_096:
	ld l,<w7d0c1		; $4c84
	bit 3,(hl)		; $4c86
	jr nz,+			; $4c88

	call @checkShouldExit	; $4c8a
	ret z			; $4c8d
+
	ld l,e			; $4c8e
	inc (hl)		; $4c8f
	ld l,<w7d0ef		; $4c90
	bit 0,(hl)		; $4c92
	jr z,+			; $4c94

	ld a,TREASURE_HEART_REFILL		; $4c96
	ld c,$40		; $4c98
	call giveTreasure		; $4c9a
+
	jp _saveTilesUnderTextbox		; $4c9d

;;
; Unsets zero flag if the textbox should be exited from (usually, player has
; pressed a button to exit the textbox).
; @addr{4ca0}
@checkShouldExit:
	ld a,(wTextboxFlags)		; $4ca0
	bit TEXTBOXFLAG_BIT_NONEXITABLE,a			; $4ca3
	jr nz,@@nonExitable	; $4ca5

	ld l,<w7TextboxTimer		; $4ca7
	ld a,(hl)		; $4ca9
	or a			; $4caa
	jr z,+			; $4cab

	dec (hl)		; $4cad
	jr z,@@end		; $4cae
+
	ld a,(wKeysJustPressed)		; $4cb0
	or a			; $4cb3
	ret			; $4cb4

@@nonExitable:
	res TEXTBOXFLAG_BIT_NONEXITABLE,a			; $4cb5
	ld (wTextboxFlags),a		; $4cb7
	ld a,$80		; $4cba
	ld (wTextIsActive),a		; $4cbc
@@end:
	or d			; $4cbf
	ret			; $4cc0

;;
; Closes the textbox
; @addr{4cc1}
@standardTextState10:
	xor a			; $4cc1
	ld (wTextIsActive),a		; $4cc2
	jp _dmaTextboxMap		; $4cc5


textOptionCode:

; This code is for when you have a prompt, ie "yes/no".

;;
; Initialization
; @addr{4cc8}
@state00:
	; hl = w7TextDisplayState (go to state $01)
	ld h,d			; $4cc8
	ld l,e			; $4cc9
	inc (hl)		; $4cca

	; Set the delay until the cursor appears
	ld a,(wTextSpeed)		; $4ccb
	ld hl,@cursorDelay		; $4cce
	rst_addAToHl			; $4cd1
	ld a,(hl)		; $4cd2
	ld e,<w7CharacterDisplayTimer		; $4cd3
	ld (de),a		; $4cd5
	ret			; $4cd6

; These are values determining how many frames until the cursor appears.
; Which value is used depends on wTextSpeed.
@cursorDelay:
	.db $20 $1c $18 $14 $10

;;
; @addr{4cdc}
@state01:
	ld h,d			; $4cdc
	ld l,<w7CharacterDisplayTimer		; $4cdd
	dec (hl)		; $4cdf
	ret nz			; $4ce0

	; hl = w7TextDisplayState (go to state $02)
	ld l,e			; $4ce1
	inc (hl)		; $4ce2

	jp _updateSelectedTextPositionAndDmaTextboxMap		; $4ce3

;;
; @addr{4ce6}
@state02:
	ld a,(wKeysJustPressed)		; $4ce6
	and BTN_A | BTN_B			; $4ce9
	jp z,_textOptionCode_checkDirectionButtons		; $4ceb

	call _textOptionCode_checkBButton		; $4cee
	ret nz			; $4cf1

	; A button pressed

	ld a,SND_SELECTITEM	; $4cf2
	call playSound		; $4cf4

	; Go to state 3
	ld hl,w7TextDisplayState		; $4cf7
	inc (hl)		; $4cfa

	ld l,<w7SelectedTextOption		; $4cfb
	ld a,(hl)		; $4cfd
	ld (wSelectedTextOption),a		; $4cfe

	ld a,(wTextboxFlags)		; $4d01
	bit TEXTBOXFLAG_BIT_NONEXITABLE,a			; $4d04
	ret z			; $4d06

	res TEXTBOXFLAG_BIT_NONEXITABLE,a			; $4d07
	ld (wTextboxFlags),a		; $4d09
	ld a,$80		; $4d0c
	ld (wTextIsActive),a		; $4d0e
	ret			; $4d11

;;
; @addr{4d12}
@state03:
	; hl = w7TextDisplayState (go to state $04)
	ld h,d			; $4d12
	ld l,e			; $4d13
	inc (hl)		; $4d14

	; hl = w7d0c1
	inc l			; $4d15
	bit 4,(hl)		; $4d16
	jr z,+			; $4d18

	; If the textbox ended with command 8 / control code 8, do this special
	; behaviour

	push hl			; $4d1a
	call _readNextTextByte		; $4d1b
	pop hl			; $4d1e
	cp $ff			; $4d1f
	jp z,+			; $4d21

	ld (wTextIndexL),a		; $4d24
	call _checkInitialTextCommands		; $4d27
	jp _func_53dd		; $4d2a

+
	set 3,(hl)		; $4d2d

	; hl = w7TextStatus
	inc l			; $4d2f
	ld (hl),$00		; $4d30

	; Go to standard text mode, state $0f
	ld l,<w7TextDisplayState		; $4d32
	ld (hl),$0f		; $4d34
	ld a,$00		; $4d36
	ld (wTextDisplayMode),a		; $4d38
	ret			; $4d3b

;;
; @addr{4d3c}
@state04:
	ld a,$00		; $4d3c
	ld (wTextDisplayMode),a		; $4d3e
	ld h,d			; $4d41
	ld l,e			; $4d42
	ld (hl),$02		; $4d43
	inc l			; $4d45
	ld (hl),$00		; $4d46
	ld l,$c5		; $4d48
	ldi a,(hl)		; $4d4a
	ld (hl),a		; $4d4b
	ld l,$d3		; $4d4c
	ld (hl),$40		; $4d4e
	ld l,$e0		; $4d50
	ld b,$0a		; $4d52
	call clearMemory		; $4d54
	call _drawLineOfText		; $4d57
	jp _dmaTextGfxBuffer		; $4d5a


inventoryTextCode:

;;
; Initialization
; @addr{4d5d}
@state00:
	; hl = w7TextDisplayState (go to state $01)
	ld h,d			; $4d5d
	ld l,e			; $4d5e
	inc (hl)		; $4d5f

	ld l,<w7TextIndexL_backup		; $4d60
	ld a,(wTextIndexL)		; $4d62
	ld (hl),a		; $4d65

	ld l,<w7InvTextScrollTimer		; $4d66
	ld (hl),$28		; $4d68

	ld l,<w7InvTextSpacesAfterName		; $4d6a
	ld a,$ff		; $4d6c
	ld (hl),a		; $4d6e

	ld l,<w7TextStatus	; $4d6f
	ld (hl),a		; $4d71

	call _doInventoryTextFirstPass		; $4d72

	ld d,>w7TextAddressL		; $4d75
	jr z,+			; $4d77

	ld e,<w7TextAddressL		; $4d79
	ld a,l			; $4d7b
	ld (de),a		; $4d7c
	inc e			; $4d7d
	ld a,h			; $4d7e
	ld (de),a		; $4d7f

	ld e,<w7InvTextSpacesAfterName		; $4d80
	ld a,(de)		; $4d82
	or a			; $4d83
	jr z,++			; $4d84

	inc a			; $4d86
	srl a			; $4d87
	ld (de),a		; $4d89
+
	ld e,<w7InvTextSpacesAfterName		; $4d8a
	ld a,(de)		; $4d8c
	inc a			; $4d8d
	jr z,@@stopText		; $4d8e
++
	ld e,<w7TextStatus	; $4d90
	ld a,(de)		; $4d92
	or a			; $4d93
	jr nz,@@end		; $4d94

@@stopText:
	ld (wTextIsActive),a		; $4d96

@@end:
	; Load the graphics from w7TextGfxBuffer
	ld a,UNCMP_GFXH_17		; $4d99
	jp loadUncompressedGfxHeader		; $4d9b

;;
; Text is paused on the name of the item being viewed
; @addr{4d9e}
@state01:
	call _decInvTextScrollTimer		; $4d9e
	ret nz			; $4da1

	; hl = w7InvTextScrollTimer
	ld (hl),$01		; $4da2

	; hl = w7TextDisplayState (go to state 2)
	ld l,e			; $4da4
	inc (hl)		; $4da5

	ld l,<w7TextStatus	; $4da6
	ld (hl),$ff		; $4da8
	ret			; $4daa

;;
; Text is scrolling and more remains to be read
; @addr{4dab}
@state02:
	call _decInvTextScrollTimer		; $4dab
	ret nz			; $4dae

	call _shiftTextGfxBufferLeft		; $4daf
--
	call _readByteFromW7ActiveBankAndIncHl		; $4db2

	cp $10			; $4db5
	jr nc,@drawCharacter	; $4db7

	cp $01			; $4db9
	jr z,@drawSpace	; $4dbb

	call _handleTextControlCodeWithSpecialCase		; $4dbd
	; Jump if it was command $06 (a special symbol)
	jr z,@saveTextAddressAndDmaTextGfxBuffer	; $4dc0

	; Keep looping until an actual character is read, or the end of the
	; text is reached.
	ld a,(w7TextStatus)		; $4dc2
	or a			; $4dc5
	jr nz,--		; $4dc6

	; End of text has been reached.

	ld a,l			; $4dc8
	ld b,h			; $4dc9

	ld hl,w7TextStatus		; $4dca
	ld (hl),$ff		; $4dcd

	; Insert $10 blank spaces before looping to the start of the text.
	ld l,<w7InvTextSpaceCounter		; $4dcf
	ld (hl),$10		; $4dd1

	; Go to state $03
	ld l,<w7TextDisplayState		; $4dd3
	inc (hl)		; $4dd5

	ld l,<w7TextAddressL		; $4dd6
	ldi (hl),a		; $4dd8
	ld (hl),b		; $4dd9

@drawSpaceWithoutSavingTextAddress:
	ld a,$20		; $4dda
	ld bc,w7TextGfxBuffer+$1e0		; $4ddc
	call retrieveTextCharacter		; $4ddf
	jr @dmaTextGfxBuffer		; $4de2

;;
; Text is scrolling but all of it has been displayed
; @addr{4de4}
@state03:
	call _decInvTextScrollTimer		; $4de4
	ret nz			; $4de7

	; hl = w7InvTextSpaceCounter
	inc l			; $4de8
	dec (hl)		; $4de9
	jr nz,@insertSpace			; $4dea

	; hl = w7TextDisplayState (go to state $04)
	ld l,e			; $4dec
	inc (hl)		; $4ded

	; Reload the text index?
	ld l,<w7TextIndexL_backup		; $4dee
	ld a,(hl)		; $4df0
	ld (wTextIndexL),a		; $4df1
	ld a,(wTextIndexH_backup)		; $4df4
	ld (wTextIndexH),a		; $4df7

	; This will get the start address of the text based on wTextIndexL/H.
	call _checkInitialTextCommands		; $4dfa

@insertSpace:
	call _shiftTextGfxBufferLeft		; $4dfd

@drawSpace:
	; $20 = character for space
	ld a,$20		; $4e00

@drawCharacter:
	ld bc,w7TextGfxBuffer+$1e0		; $4e02
	call retrieveTextCharacter		; $4e05

@saveTextAddressAndDmaTextGfxBuffer:
	ld a,l			; $4e08
	ld (w7TextAddressL),a		; $4e09
	ld a,h			; $4e0c
	ld (w7TextAddressH),a		; $4e0d

@dmaTextGfxBuffer:
	; Copy w7TextGfxBuffer to vram
	ld a,UNCMP_GFXH_17		; $4e10
	jp loadUncompressedGfxHeader		; $4e12

;;
; The name of the item is being read again.
; @addr{4e15}
@state04:
	call _decInvTextScrollTimer		; $4e15
	ret nz			; $4e18

	call _shiftTextGfxBufferLeft		; $4e19
---
	call _readByteFromW7ActiveBankAndIncHl		; $4e1c
	cp $10			; $4e1f
	jr nc,@drawCharacter	; $4e21

	cp $01			; $4e23
	jr nz,++			; $4e25

	; Newline character

	ld a,l			; $4e27
	ld b,h			; $4e28
	ld hl,w7TextAddressL		; $4e29
	ld l,<w7TextAddressL		; $4e2c
	ldi (hl),a		; $4e2e
	ld (hl),b		; $4e2f

	ld l,<w7InvTextSpacesAfterName		; $4e30
	ld a,(hl)		; $4e32
	ld l,<w7InvTextSpaceCounter		; $4e33
	ld (hl),a		; $4e35

	; Go to state $05
	ld l,<w7TextDisplayState		; $4e36
	inc (hl)		; $4e38

	or a			; $4e39
	jr nz,@drawSpaceWithoutSavingTextAddress	; $4e3a

	; Go to state $06
	inc (hl)		; $4e3c
	ret			; $4e3d
++
	call _handleTextControlCodeWithSpecialCase		; $4e3e
	jr z,@saveTextAddressAndDmaTextGfxBuffer	; $4e41

	jr ---			; $4e43

;;
; The name of the item has been read, now it's scrolling to the middle.
; @addr{4e45}
@state05:
	call _decInvTextScrollTimer		; $4e45
	ret nz			; $4e48

	; hl = w7InvTextSpaceCounter
	inc l			; $4e49
	dec (hl)		; $4e4a
	jr nz,@insertSpace		; $4e4b

	; hl = w7InvTextScrollTimer
	dec l			; $4e4d
	ld (hl),$28		; $4e4e

	; hl = w7TextDisplayState (go to state $01)
	ld l,e			; $4e50
	ld (hl),$01		; $4e51
	ret			; $4e53

;;
; @addr{4e54}
@state06:
	call _decInvTextScrollTimer		; $4e54
	ret nz			; $4e57

	; hl = w7InvTextScrollTimer
	ld (hl),$28		; $4e58

	; hl = w7TextDisplayState (go to state $07)
	ld l,e			; $4e5a
	inc (hl)		; $4e5b
	ret			; $4e5c

;;
; @addr{4e5d}
@state07:
	call _decInvTextScrollTimer		; $4e5d
	ret nz			; $4e60

	; hl = w7InvTextScrollTimer
	ld (hl),$08		; $4e61

	; hl = w7TextDisplayState (go to state $02)
	ld l,e			; $4e63
	ld (hl),$02		; $4e64

	ld l,<w7TextStatus		; $4e66
	ld (hl),$ff		; $4e68

	ld l,<w7TextAddressL		; $4e6a
	ldi a,(hl)		; $4e6c
	ld h,(hl)		; $4e6d
	ld l,a			; $4e6e
	jp @drawSpace		; $4e6f

;;
; Initializes text stuff, particularly position variables for the textbox.
; @addr{4e72}
_initTextboxStuff:
	ld a,(wActiveLanguage)		; $4e72
	ld b,a			; $4e75
	add a			; $4e76
	add b			; $4e77
	ld hl,textTableTable
	rst_addAToHl			; $4e7b
	ldi a,(hl)		; $4e7c
	ld (w7TextTableAddr),a		; $4e7d
	ldi a,(hl)		; $4e80
	ld (w7TextTableAddr+1),a		; $4e81
	ld a,(hl)		; $4e84
	ld (w7TextTableBank),a		; $4e85
	call _checkInitialTextCommands		; $4e88

	ld hl,w7TextSound		; $4e8b
	ld (hl),SND_TEXT	; $4e8e

	; w7CharacterDisplayLength
	inc l			; $4e90
	call _getCharacterDisplayLength		; $4e91
	ldi (hl),a		; $4e94

	; w7TextAttribute
	inc l			; $4e95
	ld (hl),$80		; $4e96
	; w7TextArrowState
	inc l			; $4e98
	ld (hl),$03		; $4e99
	; w7TextboxPosBank
	inc l			; $4e9b
	ld de,w3VramTiles	; $4e9c
	ld (hl),:w3VramTiles		; $4e9f

	ld a,(wOpenedMenuType)		; $4ea1
	or a			; $4ea4
	jr z,+			; $4ea5

	ld de,w4TileMap		; $4ea7
	ld (hl),:w4TileMap	; $4eaa
+
	ld a,(wTextboxPosition)		; $4eac
	ld hl,@textboxPositions		; $4eaf
	rst_addDoubleIndex			; $4eb2
	ldi a,(hl)		; $4eb3
	ld h,(hl)		; $4eb4
	ld l,a			; $4eb5
	push hl			; $4eb6
	add e			; $4eb7
	ld l,a			; $4eb8
	ld a,d			; $4eb9
	adc h			; $4eba
	ld h,a			; $4ebb

	; Adjust Y of textbox based on hCameraY
	ld de,$0020		; $4ebc
	ldh a,(<hCameraY)	; $4ebf
	add $04			; $4ec1
	and $f8			; $4ec3
	jr z,++			; $4ec5

	swap a			; $4ec7
	rlca			; $4ec9
-
	add hl,de		; $4eca
	dec a			; $4ecb
	jr nz,-			; $4ecc
++
	; Adjust X of textbox based on hCameraX
	ldh a,(<hCameraX)	; $4ece
	add $04			; $4ed0
	and $f8			; $4ed2
	swap a			; $4ed4
	rlca			; $4ed6
	add l			; $4ed7
	ld (w7TextboxPosL),a		; $4ed8

	ld a,h			; $4edb
	ld (w7TextboxPosH),a		; $4edc

	; Same as above but for calculating the position in vram. Accounts for
	; wScreenOffsetX/Y for some reason? That's weirdly inconsistent. If
	; a textbox came up while those were nonzero, I think graphics could
	; get messed up.
	pop hl			; $4edf
	ldh a,(<hCameraY)	; $4ee0
	ld b,a			; $4ee2
	ld a,(wScreenOffsetY)		; $4ee3
	add b			; $4ee6
	add $04			; $4ee7
	and $f8			; $4ee9
	jr z,++			; $4eeb

	; a /= 8
	swap a			; $4eed
	rlca			; $4eef
-
	add hl,de		; $4ef0
	dec a			; $4ef1
	jr nz,-			; $4ef2
++
	ld a,h			; $4ef4
	and $03			; $4ef5
	ld h,a			; $4ef7
	ld a,(wTextMapAddress)		; $4ef8
	ld b,a			; $4efb
	ld c,$00		; $4efc
	add hl,bc		; $4efe
	ld a,l			; $4eff
	ld (w7TextboxVramPosL),a		; $4f00
	ld a,h			; $4f03
	ld (w7TextboxVramPosH),a		; $4f04

	ld a,(wScreenOffsetX)		; $4f07
	ld b,a			; $4f0a
	ldh a,(<hCameraX)	; $4f0b
	add $04			; $4f0d
	add b			; $4f0f
	and $f8			; $4f10
	swap a			; $4f12
	rlca			; $4f14
	ld (w7d0cc),a		; $4f15

	sub $20			; $4f18
	cpl			; $4f1a
	dec a			; $4f1b
	cp $10			; $4f1c
	jr c,+			; $4f1e
	ld a,$10		; $4f20
+
	ld ($d0cd),a		; $4f22
	ld b,a			; $4f25
	ld a,$10		; $4f26
	sub b			; $4f28
	ld ($d0ce),a		; $4f29

	ld a,(wTextboxFlags)		; $4f2c
	bit TEXTBOXFLAG_BIT_NOCOLORS,a			; $4f2f
	ret nz			; $4f31

	; If neither TEXTBOXFLAG_ALTPALETTE2 nor TEXTBOXFLAG_ALTPALETTE1 is set, use PALH_0e
	and TEXTBOXFLAG_ALTPALETTE2 | TEXTBOXFLAG_ALTPALETTE1	; $4f32
	ld a,PALH_0e		; $4f34
	jr z,+			; $4f36

	; If TEXTBOXFLAG_ALTPALETTE2 is set, use PALH_bd
	ld a,(wTextboxFlags)		; $4f38
	and TEXTBOXFLAG_ALTPALETTE2			; $4f3b
	ld a,PALH_bd		; $4f3d
	jr nz,+			; $4f3f

	; If TEXTBOXFLAG_ALTPALETTE1 is set, use PALH_0d
	ld a,$81		; $4f41
	ld (w7TextAttribute),a		; $4f43
	ld a,PALH_0d		; $4f46
+
	jp loadPaletteHeader		; $4f48

; @addr{4f4b}
@textboxPositions:
	.dw $0020 $00a0 $0140 $0180 $0160 $00c0 $0060

;;
; Gets address of the text index in hl, stores bank number in [w7ActiveBank]
; @addr{4f59}
_getTextAddress:
	push de			; $4f59
	ld a,(w7TextTableAddr)		; $4f5a
	ld l,a			; $4f5d
	ld a,(w7TextTableAddr+1)		; $4f5e
	ld h,a			; $4f61
	push hl			; $4f62
	ld a,(wTextIndexH)		; $4f63
	rst_addDoubleIndex			; $4f66
	call readByteFromW7TextTableBank		; $4f67
	ld c,a			; $4f6a
	call readByteFromW7TextTableBank		; $4f6b
	ld b,a			; $4f6e
	pop hl			; $4f6f
	add hl,bc		; $4f70
	ld a,(wTextIndexL)		; $4f71
	rst_addDoubleIndex			; $4f74
	call readByteFromW7TextTableBank		; $4f75
	ld c,a			; $4f78
	call readByteFromW7TextTableBank		; $4f79
	ld b,a			; $4f7c

; If wTextIndexH < TEXT_OFFSET_SPLIT_INDEX, text is relative to TEXT_OFFSET_1
	ld a,(wActiveLanguage)		; $4f7d
	add a			; $4f80
	ld hl,textOffset1Table
	rst_addDoubleIndex			; $4f84
	ldi a,(hl)		; $4f85
	ld e,a			; $4f86
	ldi a,(hl)		; $4f87
	ld h,(hl)		; $4f88
	ld l,a			; $4f89
	ld a,(wTextIndexH)		; $4f8a
	cp TEXT_OFFSET_SPLIT_INDEX
	jr c,+	; $4f8f
; Else, text is relative to TEXT_OFFSET_2
	ld a,(wActiveLanguage)		; $4f91
	add a			; $4f94
	ld hl,textOffset2Table		; $4f95
	rst_addDoubleIndex			; $4f98
	ldi a,(hl)		; $4f99
	ld e,a			; $4f9a
	ldi a,(hl)		; $4f9b
	ld h,(hl)		; $4f9c
	ld l,a			; $4f9d
+
	ld a,e			; $4f9e
	add $04			; $4f9f
	add hl,bc		; $4fa1
	jr c,++

	ld a,h			; $4fa4
	and $c0			; $4fa5
	rlca			; $4fa7
	rlca			; $4fa8
	add e			; $4fa9
++
	ld (w7ActiveBank),a		; $4faa
	res 7,h			; $4fad
	set 6,h			; $4faf
	pop de			; $4fb1
	ret			; $4fb2


textOffset1Table: ; $0fb3
	.db :TEXT_OFFSET_1
	.dw TEXT_OFFSET_1&$3fff
	.db 0
	.db :TEXT_OFFSET_1
	.dw TEXT_OFFSET_1&$3fff
	.db 0
	.db :TEXT_OFFSET_1
	.dw TEXT_OFFSET_1&$3fff
	.db 0
	.db :TEXT_OFFSET_1
	.dw TEXT_OFFSET_1&$3fff
	.db 0
	.db :TEXT_OFFSET_1
	.dw TEXT_OFFSET_1&$3fff
	.db 0
	.db :TEXT_OFFSET_1
	.dw TEXT_OFFSET_1&$3fff
	.db 0

textOffset2Table: ; $0fcb
	.db :TEXT_OFFSET_2
	.dw TEXT_OFFSET_2&$3fff
	.db 0
	.db :TEXT_OFFSET_2
	.dw TEXT_OFFSET_2&$3fff
	.db 0
; These seem to be corrupted. Only the first entry is used anyway, though.
	.db :TEXT_OFFSET_2
	.dw TEXT_OFFSET_1&$3fff
	.db 0
	.db :TEXT_OFFSET_2
	.dw TEXT_OFFSET_1&$3fff
	.db 0
	.db :TEXT_OFFSET_2
	.dw TEXT_OFFSET_1&$3fff
	.db 0
	.db :TEXT_OFFSET_2
	.dw TEXT_OFFSET_1&$3fff
	.db 0

textTableTable: ; $0fe3
	Pointer3Byte textTableENG
	Pointer3Byte textTableENG
	Pointer3Byte textTableENG
	Pointer3Byte textTableENG
	Pointer3Byte textTableENG
	Pointer3Byte textTableENG

;;
; This peeks at the text to check if the next command is something particular.
; It deals with the textbox positioning command ("\pos()" in text.txt) and
; command 8 (displaying extra text after buying something).
; Most of the time this does nothing though.
; @addr{4ff5}
_checkInitialTextCommands:
	push de			; $4ff5
	call _getTextAddress		; $4ff6
	call readByteFromW7ActiveBank		; $4ff9
	cp $08			; $4ffc
	jr z,@cmd8		; $4ffe

	cp $0c			; $5000
	jr nz,@end		; $5002

@cmdc:
	ld d,h			; $5004
	ld e,l			; $5005
	call _incHlAndUpdateBank		; $5006
	call readByteFromW7ActiveBank		; $5009
	ld b,a			; $500c
	and $fc			; $500d
	cp $20			; $500f
	jr z,+			; $5011

	ld h,d			; $5013
	ld l,e			; $5014
	jr @end			; $5015
+
	ld a,(wTextboxFlags)		; $5017
	bit TEXTBOXFLAG_BIT_DONTCHECKPOSITION,a			; $501a
	jr nz,+			; $501c

	ld a,b			; $501e
	and $07			; $501f
	ld (wTextboxPosition),a		; $5021
+
	call _incHlAndUpdateBank		; $5024

@end:
	ld a,l			; $5027
	ld (w7TextAddressL),a		; $5028
	ld a,h			; $502b
	ld (w7TextAddressH),a		; $502c
	pop de			; $502f
	ret			; $5030

@cmd8:
	call _incHlAndUpdateBank		; $5031
	call readByteFromW7ActiveBank		; $5034
	call _getExtraTextIndex		; $5037
	cp $ff			; $503a
	jp z,@noExtraText	; $503c

	ld (wTextIndexL),a		; $503f
	jr _checkInitialTextCommands		; $5042

@noExtraText:
	ld a,$00		; $5044
	ld (wTextDisplayMode),a		; $5046
	ld hl,w7TextDisplayState		; $5049
	ld (hl),$0f		; $504c

	; w7d0c1
	inc l			; $504e
	set 3,(hl)		; $504f

	; w7TextStatus
	inc l			; $5051
	ld (hl),$00		; $5052
	ret			; $5054

;;
; Gets the graphics for a line of text and puts it into w7TextGfxBuffer.
; Also sets w7LineTextBuffer, w7LineAttributesBuffer, etc.
; @addr{5055}
_drawLineOfText:
	ld h,d			; $5055
	ld l,<w7TextStatus		; $5056
	ld (hl),$ff		; $5058
	ld l,<w7TextAddressL		; $505a
	push hl			; $505c
	ldi a,(hl)		; $505d
	ld h,(hl)		; $505e
	ld l,a			; $505f
	push hl			; $5060
	call _clearTextGfxBuffer		; $5061
	call _clearLineTextBuffer		; $5064
	pop hl			; $5067
	ld bc,w7TextGfxBuffer	; $5068
--
	call _readByteFromW7ActiveBankAndIncHl		; $506b
	cp $10			; $506e
	jr nc,+			; $5070

	call _handleTextControlCode		; $5072

	; Check whether to stop? ($00 = end of textbox, $01 = newline)
	ld a,(w7TextStatus)		; $5075
	cp $02			; $5078
	jr nc,--		; $507a

	jr ++			; $507c
+
	call _setLineTextBuffers		; $507e
	call retrieveTextCharacter		; $5081
	jr --			; $5084
++
	pop de			; $5086
	ld a,l			; $5087
	ld (de),a		; $5088
	inc e			; $5089
	ld a,h			; $508a
	ld (de),a		; $508b
	ld e,$d0		; $508c
	xor a			; $508e
	ld (de),a		; $508f
	ret			; $5090

;;
; @addr{5091}
_clearTextGfxBuffer:
	ld hl,w7TextGfxBuffer	; $5091
	ld bc,$0200		; $5094
	ld a,$ff		; $5097
	jp fillMemoryBc		; $5099

;;
; @addr{509c}
_clearLineTextBuffer:
	ld hl,w7LineTextBuffer		; $509c
	ld d,h			; $509f
	ld e,l			; $50a0
	ld b,$10		; $50a1
	jp clearMemory		; $50a3

;;
; Given an address in w7LineTextBuffers, this sets the values for this
; character in each LineBuffer to appropriate values.
; @param a Character
; @param de Address in w7LineTextBuffer
; @addr{50a6}
_setLineTextBuffers:
	; Write to w7LineTextBuffer
	ld (de),a		; $50a6
	push de			; $50a7
	push hl			; $50a8

	; Write to w7LineAttributesBuffer
	ld hl,w7TextAttribute		; $50a9
	ld a,e			; $50ac
	add $10			; $50ad
	ld e,a			; $50af
	ldd a,(hl)		; $50b0
	ld (de),a		; $50b1

	; Write w7CharacterDisplayLength to w7LineDelaysBuffer
	ld a,e			; $50b2
	add $10			; $50b3
	ld e,a			; $50b5
	dec l			; $50b6
	ldd a,(hl)		; $50b7
	ld (de),a		; $50b8

	; Write w7TextSound to w7LineSoundsBuffer
	ld a,e			; $50b9
	add $10			; $50ba
	ld e,a			; $50bc
	ldd a,(hl)		; $50bd
	ld (de),a		; $50be

	; Write w7SoundEffect to w7LineSoundEffectsBuffer
	ld a,e			; $50bf
	add $10			; $50c0
	ld e,a			; $50c2
	ld a,(hl)		; $50c3
	ld (de),a		; $50c4
	ld (hl),$00		; $50c5

	pop hl			; $50c7
	pop de			; $50c8
	ld a,(de)		; $50c9
	inc e			; $50ca
	ret			; $50cb

;;
; @param a Relative offset for where to write to. Should be $00 or $02.
; @addr{50cc}
_dmaTextGfxBuffer:
	add $94			; $50cc
	ld d,a			; $50ce
	ld e,$00		; $50cf
	ld hl,w7TextGfxBuffer		; $50d1
	ldbc $1f, TEXT_BANK		; $50d4
	push hl			; $50d7
	call queueDmaTransfer		; $50d8
	pop hl			; $50db
	ret			; $50dc

;;
; @addr{50dd}
_saveTilesUnderTextbox:
	ld hl,w7TextboxPosL		; $50dd
	ld e,(hl)		; $50e0
	inc l			; $50e1
	ld d,(hl)		; $50e2
	inc l			; $50e3
	ld l,(hl)		; $50e4
	ld h,$d0		; $50e5
	call @copyTileMap	; $50e7

	; The attribute map is assumed to be $400 bytes after the tile map
	ld hl,w7TextboxPosL		; $50ea
	ld e,(hl)		; $50ed
	inc l			; $50ee
	ldi a,(hl)		; $50ef
	add $04			; $50f0
	ld d,a			; $50f2
	ld l,(hl)		; $50f3
	ld h,$d1		; $50f4

;;
; Copies 6 rows of tiles (from a tile map) from de to hl. A row is $20 bytes,
; so this copies $c0 bytes. It uses an intermediate buffer at wTmpVramBuffer in
; order to copy between any 2 banks.
; @param de Where to copy the data from
; @param hl Where to copy the data to (bank 7)
; @param [w7TextboxPosBank] Bank to copy the data from
; @addr{50f6}
@copyTileMap:
	; Iterate 3 times
	ld a,$03		; $50f6

@next2Rows:
	push af			; $50f8
	push hl			; $50f9
	ld a,(w7TextboxPosBank)		; $50fa
	ld ($ff00+R_SVBK),a	; $50fd

	; Copy 2 rows ($40 bytes) to wTmpVramBuffer
	ld hl,wTmpVramBuffer		; $50ff
	ld a,$02		; $5102
@getNextRow:
	push af			; $5104
	ld a,e			; $5105
	and $e0			; $5106
	ld c,a			; $5108
	ld b,$20		; $5109

@getNextTile:
	ld a,(de)		; $510b
	ldi (hl),a		; $510c
	ld a,e			; $510d
	inc a			; $510e
	and $1f			; $510f
	or c			; $5111
	ld e,a			; $5112
	dec b			; $5113
	jr nz,@getNextTile		; $5114

	ld a,$20		; $5116
	call addAToDe		; $5118
	pop af			; $511b
	dec a			; $511c
	jr nz,@getNextRow		; $511d

	; Change back to bank 7,
	ld a,$07		; $511f
	ld ($ff00+R_SVBK),a	; $5121
	pop hl			; $5123
	push de			; $5124

	; Copy the 2 rows in wTmpVramBuffer to hl (parameter to function)
	ld de,wTmpVramBuffer		; $5125
	ld a,$02		; $5128
@writeNextRow:
	push af			; $512a
	ld a,l			; $512b
	and $e0			; $512c
	ld c,a			; $512e
	ld b,$20		; $512f

@writeNextTile:
	ld a,(de)		; $5131
	ld (hl),a		; $5132
	inc e			; $5133
	ld a,l			; $5134
	inc a			; $5135
	and $1f			; $5136
	or c			; $5138
	ld l,a			; $5139
	dec b			; $513a
	jr nz,@writeNextTile	; $513b

	ld a,$20		; $513d
	rst_addAToHl			; $513f
	pop af			; $5140
	dec a			; $5141
	jr nz,@writeNextRow	; $5142

	pop de			; $5144
	pop af			; $5145
	dec a			; $5146
	jr nz,@next2Rows	; $5147

	ret			; $5149

;;
; Initialize the textbox map and attributes so it starts as a black box.
; @addr{514a}
_initTextboxMapping:
	ld a,(w7d0cc)		; $514a
	inc a			; $514d
	and $1f			; $514e
	ld l,a			; $5150
	ld e,$05		; $5151
--
	ld b,$12		; $5153
	ld a,l			; $5155
	ld d,a			; $5156
	and $e0			; $5157
	ld c,a			; $5159
-
	ld h,>w7TextboxMap	; $515a
	ld (hl),$02		; $515c
	ld h,>w7TextboxAttributes	; $515e
	ld (hl),$80		; $5160
	ld a,l			; $5162
	inc a			; $5163
	and $1f			; $5164
	or c			; $5166
	ld l,a			; $5167
	dec b			; $5168
	jr nz,-			; $5169

	ld a,d			; $516b
	add $20			; $516c
	ld l,a			; $516e
	dec e			; $516f
	jr nz,--		; $5170

	ret			; $5172

;;
; Sets up the textbox map and attributes for dma'ing.
; I have no idea what the branch instructions are for.
; @addr{5173}
_dmaTextboxMap:
	ld a,(wTextMapAddress)		; $5173
	add $03			; $5176
	ld c,a			; $5178
	ld hl,w7TextboxVramPosL		; $5179
	ldi a,(hl)		; $517c
	ld e,a			; $517d
	cp $61			; $517e
	ld a,(hl)		; $5180
	ld d,a			; $5181
	jr c,+			; $5182

	cp c			; $5184
	jr z,++			; $5185
+
	ld b,$09		; $5187
	ld hl,w7TextboxMap	; $5189

@func:
	ld c,TEXT_BANK		; $518c
	push hl			; $518e
	call queueDmaTransfer		; $518f
	pop hl			; $5192
	inc e			; $5193
	inc h			; $5194
	jp queueDmaTransfer		; $5195
++
	xor a			; $5198
	sub e			; $5199
	ld c,a			; $519a
	swap a			; $519b
	dec a			; $519d
	ld b,a			; $519e
	ld hl,w7TextboxMap	; $519f
	push bc			; $51a2
	call @func		; $51a3

	pop bc			; $51a6
	ld a,(wTextMapAddress)		; $51a7
	ld d,a			; $51aa
	ld e,$00		; $51ab
	ld l,c			; $51ad
	ld h,>w7TextboxMap	; $51ae
	ld a,$a0		; $51b0
	sub c			; $51b2
	swap a			; $51b3
	dec a			; $51b5
	ld b,a			; $51b6
	jr @func		; $51b7

;;
; Updates the timer, and sets bit 0 of w7d0c1 if A or B is pressed.
; @addr{51b9}
_updateCharacterDisplayTimer:
	ld h,d			; $51b9
	ld l,<w7TextSoundCooldownCounter		; $51ba
	ld a,(hl)		; $51bc
	or a			; $51bd
	jr z,+			; $51be
	dec (hl)		; $51c0
+
	ld l,<w7TextSlowdownTimer	; $51c1
	ld a,(hl)		; $51c3
	or a			; $51c4
	jr z,@checkInput	; $51c5

	dec (hl)		; $51c7
	jr nz,@countdownToNextCharacter	; $51c8

@checkInput:
	ld a,(wKeysJustPressed)		; $51ca
	and BTN_A | BTN_B		; $51cd
	jr nz,@skipToLineEnd	; $51cf

	; Wait for the next character to display itself
@countdownToNextCharacter:
	ld l,<w7CharacterDisplayTimer		; $51d1
	dec (hl)		; $51d3
	ret			; $51d4

	; Skip to the end of the line
@skipToLineEnd:
	ld l,<w7d0c1		; $51d5
	set 0,(hl)		; $51d7
	xor a			; $51d9
	ret			; $51da

;;
; This function updates the textbox's tilemap to display the next character, as
; well as playing associated sound effects and whatnot.
; @addr{51db}
_displayNextTextCharacter:
	ld e,<w7d0d3		; $51db
	ld a,(de)		; $51dd
	ld c,a			; $51de
	cp $40			; $51df
	ld b,$00		; $51e1
	jr z,+			; $51e3
	ld b,$40		; $51e5
+
	ld e,<w7NextTextColumnToDisplay		; $51e7
	ld a,(de)		; $51e9
	ld l,a			; $51ea
	ld e,<w7d0cc		; $51eb
	ld a,(de)		; $51ed
	add $02			; $51ee
	add l			; $51f0
	and $1f			; $51f1
	add b			; $51f3
	ld e,a			; $51f4

	; Get character, check if it's null (end of text)
	ld h,>w7LineTextBuffer		; $51f5
	ld a,(hl)		; $51f7
	or a			; $51f8
	jr z,@endLine			; $51f9

	; Store character
	ldh (<hFF8B),a	; $51fb

	; Write the tile index of the character to the textbox map (it's 8x16,
	; so there's two bytes to be written)
	ld d,>w7TextboxMap		; $51fd
	ld a,l			; $51ff
	add a			; $5200
	add c			; $5201
	ld b,a			; $5202
	inc b			; $5203
	ld (de),a		; $5204
	ld a,e			; $5205
	add $20			; $5206
	ld e,a			; $5208
	ld a,b			; $5209
	ld (de),a		; $520a

	; Similarly, write the attribute (from w7LineAttributeBuffer to
	; w7TextboxAttributes)
	inc d			; $520b
	ld a,l			; $520c
	add $10			; $520d
	ld l,a			; $520f
	ld a,(hl)		; $5210
	ld (de),a		; $5211
	ld a,e			; $5212
	sub $20			; $5213
	ld e,a			; $5215
	ld a,(hl)		; $5216
	ld (de),a		; $5217

	; Increment the column we're on
	ld d,>w7NextTextColumnToDisplay		; $5218
	ld e,<w7NextTextColumnToDisplay		; $521a
	ld a,(de)		; $521c
	inc a			; $521d
	ld (de),a		; $521e

	; End of line?
	cp $10			; $521f
	jr z,@endLine			; $5221

	call @checkCanAdvanceWithAB		; $5223
	jr nz,+			; $5226

	; Check bit 0 of <w7d0c1 (whether A or B is pressed, skip to line end)
	ld e,<w7d0c1		; $5228
	ld a,(de)		; $522a
	bit 0,a			; $522b
	jr nz,_displayNextTextCharacter	; $522d
+
	call @readSubsequentLineBuffers		; $522f
	or d			; $5232
	ret			; $5233

@endLine:
	; Play the sound effect once more if we got here by pressing A/B
	ld h,d			; $5234
	ld l,<w7d0c1		; $5235
	bit 0,(hl)		; $5237
	ret z			; $5239

	ld l,<w7TextSoundCooldownCounter		; $523a
	ld a,(hl)		; $523c
	or a			; $523d
	jr nz,+			; $523e

	ld (hl),$04		; $5240
	ld l,<w7TextSound		; $5242
	ld a,(hl)		; $5244
	call playSound		; $5245
+
	xor a			; $5248
	ret			; $5249

;;
; Reads and applies values from w7LineDelaysBuffer, w7LineSoundsBuffer, and
; w7LineSoundEffectsBuffer.
; @param hl Pointer within w7LineAttributeBuffer
; @addr{524a}
@readSubsequentLineBuffers:
	; Have hl point to w7LineDelaysBuffer, set w7CharacterDisplayTimer
	ld a,l			; $524a
	add $10			; $524b
	ld l,a			; $524d
	ld a,(hl)		; $524e
	ld e,<w7CharacterDisplayTimer		; $524f
	ld (de),a		; $5251

	; Read from w7LineSoundsBuffer
	ld a,l			; $5252
	add $10			; $5253
	ld l,a			; $5255
	ld a,(hl)		; $5256
	or a			; $5257
	jr z,++			; $5258

	; If character is a space ($20), don't play the text sound
	ld b,a			; $525a
	ldh a,(<hFF8B)	; $525b
	cp ' '			; $525d
	jr z,++			; $525f

	; Don't play the text sound if we already played one recently
	ld e,<w7TextSoundCooldownCounter		; $5261
	ld a,(de)		; $5263
	or a			; $5264
	jr nz,++		; $5265

	ld a,$04		; $5267
	ld (de),a		; $5269
	ld a,b			; $526a
	call @playSound		; $526b

++
	; Read from w7LineSoundEffectsBuffer, play sound if applicable
	; This is different from above, it's for one-off sound effects like the
	; gorons make
	ld a,l			; $526e
	add $10			; $526f
	ld l,a			; $5271
	ld a,(hl)		; $5272
	or a			; $5273
	ret z			; $5274

@playSound:
	push hl			; $5275
	call playSound		; $5276
	pop hl			; $5279
	ret			; $527a

;;
; Sets zero flag if the player isn't allowed to advance with A/B currently.
; @addr{527b}
@checkCanAdvanceWithAB:
	push hl			; $527b
	ld e,<w7NextTextColumnToDisplay		; $527c
	ld a,(de)		; $527e
	add <w7LineAdvanceableBuffer			; $527f
	ld l,a			; $5281
	ld h,>w7LineAdvanceableBuffer		; $5282
	bit 0,(hl)		; $5284
	pop hl			; $5286
	ret			; $5287

;;
; Get the next character to display based on w7NextTextColumnToDisplay.
; Sets the zero flag if there's nothing more to display this line.
; @addr{5288}
_getNextCharacterToDisplay:
	ld e,<w7NextTextColumnToDisplay		; $5288
	ld a,(de)		; $528a
	cp $10			; $528b
	ret z			; $528d

	add <w7LineTextBuffer		; $528e
	ld l,a			; $5290
	ld h,>w7LineTextBuffer	; $5291
	ld a,(hl)		; $5293
	or a			; $5294
	ret			; $5295

;;
; @addr{5296}
_func_5296:
	ld h,d			; $5296
	ld l,<w7d0c1		; $5297
	ldd a,(hl)		; $5299
	bit 2,a			; $529a
	jr nz,@chooseOption	; $529c

	bit 1,a			; $529e
	jr nz,_label_3f_155	; $52a0

	bit 4,a			; $52a2
	ret z			; $52a4

	call _readNextTextByte		; $52a5
	cp $ff			; $52a8
	jr z,_label_3f_158	; $52aa

	ld (wTextIndexL),a		; $52ac
	call _checkInitialTextCommands		; $52af
	ld e,<w7d0c1		; $52b2
	xor a			; $52b4
	ld (de),a		; $52b5
	inc e			; $52b6
	inc a			; $52b7
	ld (de),a		; $52b8
	ret			; $52b9

; The text has an option being displayed (ie. yes/no)
@chooseOption:
	ld e,<w7TextStatus		; $52ba
	ld a,(de)		; $52bc
	or a			; $52bd
	jr nz,_label_3f_159	; $52be

	ld (hl),a		; $52c0
	ld a,$01		; $52c1
	ld (wTextDisplayMode),a		; $52c3
	or h			; $52c6
	ret			; $52c7

_label_3f_155:
	bit 0,a			; $52c8
	jr z,+			; $52ca

	inc l			; $52cc
	res 0,(hl)		; $52cd
	jr _label_3f_157		; $52cf
+
	ld a,(wKeysJustPressed)		; $52d1
	and $03			; $52d4
	jr z,_label_3f_157	; $52d6
	ld (hl),$00		; $52d8
	ld l,$c1		; $52da
	res 1,(hl)		; $52dc
	pop hl			; $52de
	ld a,SND_TEXT_2		; $52df
	jp playSound		; $52e1
_label_3f_157:
	call _updateTextboxArrow		; $52e4
	or h			; $52e7
	ret			; $52e8
_label_3f_158:
	xor a			; $52e9
	ld ($00c2),a		; $52ea
	ret			; $52ed

_label_3f_159:
	ld hl,w7TextboxOptionPositions		; $52ee
_label_3f_160:
	ld a,(hl)		; $52f1
	or a			; $52f2
	ret z			; $52f3

	xor $20			; $52f4
	ldi (hl),a		; $52f6
	ld a,l			; $52f7
	and $07			; $52f8
	jr nz,_label_3f_160	; $52fa
	ret			; $52fc

;;
; @addr{52fd}
_readNextTextByte:
	ld l,<w7TextAddressL	; $52fd
	ldi a,(hl)		; $52ff
	ld h,(hl)		; $5300
	ld l,a			; $5301
	call _readByteFromW7ActiveBankAndIncHl		; $5302

;;
; This is part of text command $08, used in shops when trying to buy something.
; @param a Index
; @addr{5305}
_getExtraTextIndex:
	ld hl,_extraTextIndices		; $5305
	rst_addDoubleIndex			; $5308
	ldi a,(hl)		; $5309
	ld h,(hl)		; $530a
	ld l,a			; $530b
	ldi a,(hl)		; $530c
	ld c,a			; $530d
	ldi a,(hl)		; $530e
	ld b,a			; $530f
	ld a,(bc)		; $5310
	rst_addAToHl			; $5311
	ld a,(hl)		; $5312
	ret			; $5313

;;
; Update the little red arrow in the bottom-right of the textbox.
; @addr{5314}
_updateTextboxArrow:
	ld a,(wFrameCounter)		; $5314
	and $0f			; $5317
	ret nz			; $5319

	; Get position of little red arrow in hl
	ld e,<w7d0cc		; $531a
	ld a,(de)		; $531c
	add $12			; $531d
	and $1f			; $531f
	add <w7TextboxMap+$80			; $5321
	ld l,a			; $5323
	ld h,>w7TextboxMap		; $5324

	ld e,<w7TextArrowState		; $5326
	ld a,(de)		; $5328
	cp $03			; $5329
	ld a,$02		; $532b
	jr z,+			; $532d
	ld a,$03		; $532f
+
	ld (de),a		; $5331
	ld (hl),a		; $5332

	; Calculate the source and destination for the arrow
	ld a,(wTextMapAddress)		; $5333
	add $04			; $5336
	ld c,a			; $5338
	ld l,<w7TextboxMap+$80		; $5339
	ld h,>w7TextboxMap		; $533b
	ld e,<w7TextboxVramPosL		; $533d
	ld a,(de)		; $533f
	add l			; $5340
	ld b,a			; $5341
	inc e			; $5342
	ld a,(de)		; $5343
	adc $00			; $5344
	cp c			; $5346
	jr c,+			; $5347
	ld a,(wTextMapAddress)		; $5349
+
	ld d,a			; $534c
	ld e,b			; $534d
	ldbc $01, TEXT_BANK		; $534e
	jp queueDmaTransfer		; $5351

;;
; This clears the very top row - only the 8x8 portion, not the 8x16 portion.
; @addr{5354}
_clearTopRowOfTextMap:
	ld h,>w7TextboxMap		; $5354
	ld a,(w7d0cc)		; $5356
	add $02			; $5359
	and $1f			; $535b
	ld l,a			; $535d
	ld c,a			; $535e
	ld b,$10		; $535f
	ld a,$02		; $5361
	push bc			; $5363
	call @func		; $5364

	pop bc			; $5367
	ld h,>w7TextboxAttributes		; $5368
	ld l,c			; $536a
	ld a,$80		; $536b

@func:
	ld c,a			; $536d
	ld a,l			; $536e
	and $e0			; $536f
	ld e,a			; $5371
-
	ld (hl),c		; $5372
	ld a,l			; $5373
	inc a			; $5374
	and $1f			; $5375
	or e			; $5377
	ld l,a			; $5378
	dec b			; $5379
	jr nz,-			; $537a
	ret			; $537c

;;
; Shifts everything in w7TextboxMap and w7TextboxAttributes up one tile.
; @addr{537d}
_shiftTextboxMapUp:
	ld h,>w7TextboxMap		; $537d
	call @func		; $537f

	ld h,>w7TextboxAttributes		; $5382
@func:
	ld d,h			; $5384
	ld a,(w7d0cc)		; $5385
	add $02			; $5388
	and $1f			; $538a
	ld e,a			; $538c
	add $20			; $538d
	ld l,a			; $538f
	ld b,a			; $5390
	ld c,$04		; $5391
--
	push bc			; $5393
	ld a,e			; $5394
	and $e0			; $5395
	ld c,a			; $5397
	ld b,$10		; $5398
-
	ld a,(hl)		; $539a
	ld (de),a		; $539b
	ld a,e			; $539c
	inc a			; $539d
	and $1f			; $539e
	or c			; $53a0
	ld e,a			; $53a1
	add $20			; $53a2
	ld l,a			; $53a4
	dec b			; $53a5
	jr nz,-			; $53a6

	pop bc			; $53a8
	ld e,b			; $53a9
	ld a,b			; $53aa
	add $20			; $53ab
	ld l,a			; $53ad
	ld b,a			; $53ae
	dec c			; $53af
	jr nz,--		; $53b0
	ret			; $53b2

;;
; This resets bit 5 for every piece of text in the top row.
; This causes it to reference the values in the map $20 bytes earlier.
; @addr{53b3}
_subFirstRowOfTextMapBy20:
	ld h,>w7TextboxMap		; $53b3
	ld b,$00		; $53b5
	call @func		; $53b7

	ld b,$20		; $53ba
@func:
	ld a,(w7d0cc)		; $53bc
	add $02			; $53bf
	and $1f			; $53c1
	add b			; $53c3
	ld l,a			; $53c4
	and $e0			; $53c5
	ld c,a			; $53c7
	ld b,$10		; $53c8
--
	ld a,(hl)		; $53ca
	and $60			; $53cb
	cp $60			; $53cd
	jr nz,+			; $53cf
	res 5,(hl)		; $53d1
+
	ld a,l			; $53d3
	inc a			; $53d4
	and $1f			; $53d5
	or c			; $53d7
	ld l,a			; $53d8
	dec b			; $53d9
	jr nz,--		; $53da
	ret			; $53dc

;;
; @addr{53dd}
_func_53dd:
	ld h,d			; $53dd
	ld l,<w7d0c1		; $53de
	res 1,(hl)		; $53e0
	call _saveTilesUnderTextbox		; $53e2
	call _initTextboxMapping		; $53e5
	jp _dmaTextboxMap		; $53e8

;;
; Something to do with pieces of heart
; @addr{53eb}
_func_53eb:
	ld h,d			; $53eb
	ld l,<w7d0c1		; $53ec
	bit 5,(hl)		; $53ee
	jr nz,++		; $53f0

	ld l,<w7d0ea		; $53f2
	ld a,(hl)		; $53f4
	or a			; $53f5
	ret z			; $53f6

	dec (hl)		; $53f7
	ret nz			; $53f8

	ld b,$00		; $53f9
	call @func		; $53fb
	ld a,SND_TEXT_2		; $53fe
	call playSound		; $5400
	xor a			; $5403
	ret			; $5404
++
	res 5,(hl)		; $5405
	ld l,<w7d0ea		; $5407
	ld (hl),$1e		; $5409
	ld l,<w7d0ef		; $540b
	ld (hl),$01		; $540d
	call @dmaHeartPieceDisplay		; $540f
	ld b,$ff		; $5412

;;
; Something to do with pieces of heart
; @param b Relative number of pieces of heart to show; $ff to show one less
; than you actually have
; @addr{5414}
@func:
	ld a,(wNumHeartPieces)		; $5414
	add b			; $5417
	add a			; $5418
	push af			; $5419
	sub $08			; $541a
	jr nz,+			; $541c

	ld (wNumHeartPieces),a		; $541e
	dec a			; $5421
	ld (wStatusBarNeedsRefresh),a		; $5422
	ld (w7d0ef),a		; $5425
+
	pop af			; $5428
	ld hl,@data		; $5429
	rst_addDoubleIndex			; $542c
	ld d,$d0		; $542d
	ld a,(w7d0cc)		; $542f
	add $11			; $5432
	and $1f			; $5434
	ld c,a			; $5436
	dec a			; $5437
	and $1f			; $5438
	ld b,a			; $543a
	add $20			; $543b
	ld e,a			; $543d
	ldi a,(hl)		; $543e
	ld (de),a		; $543f
	ld a,b			; $5440
	add $40			; $5441
	ld e,a			; $5443
	ldi a,(hl)		; $5444
	ld (de),a		; $5445
	ld a,c			; $5446
	add $20			; $5447
	ld e,a			; $5449
	ldi a,(hl)		; $544a
	ld (de),a		; $544b
	ld a,c			; $544c
	add $40			; $544d
	ld e,a			; $544f
	ld a,(hl)		; $5450
	ld (de),a		; $5451
	ld d,$d1		; $5452
	ld a,(de)		; $5454
	or $20			; $5455
	ld (de),a		; $5457
	ld a,c			; $5458
	add $20			; $5459
	ld e,a			; $545b
	ld a,(de)		; $545c
	or $20			; $545d
	ld (de),a		; $545f
	call _dmaTextboxMap		; $5460
	or d			; $5463
	ret			; $5464

@data:
	.db $5d $7c $5d $7c $5f $7c $5d $7c
	.db $5f $7e $5d $7c $5f $7e $5d $7e
	.db $5f $7e $5f $7e

;;
; @addr{5479}
@dmaHeartPieceDisplay:
	ld hl,gfx_font_heartpiece		; $5479
	ld de,$95d0		; $547c
	ldbc $00, :gfx_font_heartpiece		; $547f
	call queueDmaTransfer		; $5482

	ld hl,gfx_font_heartpiece+$10		; $5485
	ld e,$f0		; $5488
	call queueDmaTransfer		; $548a

	ld hl,gfx_font_heartpiece+$20		; $548d
	ld de,$97c0		; $5490
	call queueDmaTransfer		; $5493

	ld hl,gfx_font_heartpiece+$30		; $5496
	ld e,$e0		; $5499
	jp queueDmaTransfer		; $549b

;;
; This is called when an item is first selected.
; This calculates w7InvTextSpacesAfterName such that the text will be centered.
; It also draws the initial line of text, because that should be visible
; immediately, not scrolled in.
; @addr{549e}
_doInventoryTextFirstPass:
	call _clearTextGfxBuffer		; $549e
	ld h,d			; $54a1
	ld l,<w7ActiveBank		; $54a2
	ldi a,(hl)		; $54a4
	ldh (<hFF8A),a	; $54a5
	ldi a,(hl)		; $54a7
	ld h,(hl)		; $54a8
	ld l,a			; $54a9
	push hl			; $54aa
	ld e,$00		; $54ab
--
	call _readByteFromW7ActiveBankAndIncHl		; $54ad
	cp $00			; $54b0
	jr z,@nullTerminator	; $54b2

	cp $01			; $54b4
	jr z,@lineEnd		; $54b6

	cp $10			; $54b8
	jr nc,@notControlCode	; $54ba

	call @controlCode		; $54bc
	jr --			; $54bf

@notControlCode:
	; Check if 16 or more characters have been read
	inc e			; $54c1
	bit 4,e			; $54c2
	jr z,--			; $54c4
	jr @lineEnd		; $54c6

@nullTerminator:
	call _popFromTextStack		; $54c8
	ld a,h			; $54cb
	or a			; $54cc
	jr nz,--		; $54cd

@lineEnd:
	call _popFromTextStack		; $54cf

	; pop the initial text address, store it into w7TextAddressL/H
	pop bc			; $54d2
	ld hl,w7ActiveBank		; $54d3
	ldh a,(<hFF8A)	; $54d6
	ldi (hl),a		; $54d8
	ld (hl),c		; $54d9
	inc l			; $54da
	ld (hl),b		; $54db

	; Check how many characters were read
	ld a,e			; $54dc
	or a			; $54dd
	ret z			; $54de

	; Calculate a value for w7InvTextSpacesAfterName such that it will be
	; centered.
	push bc			; $54df
	sub $11			; $54e0
	cpl			; $54e2
	ld l,<w7InvTextSpacesAfterName		; $54e3
	ld (hl),a		; $54e5

	; Calculate where in w7TextGfxBuffer to put the first character
	and $0e			; $54e6
	swap a			; $54e8
	add $00			; $54ea
	ld c,a			; $54ec

	call _clearLineTextBuffer		; $54ed
	ld b,>w7TextGfxBuffer		; $54f0
	pop hl			; $54f2

@nextCharacter:
	call _readByteFromW7ActiveBankAndIncHl		; $54f3
	cp $10			; $54f6
	jr c,+			; $54f8

	; Standard character
	call _setLineTextBuffers		; $54fa
	call retrieveTextCharacter		; $54fd

	; Stop at 16 characters
	bit 4,e			; $5500
	jr z,@nextCharacter	; $5502
	ret			; $5504
+
	; Control code
	call _handleTextControlCode		; $5505

	; Stop at a newline or end of text
	ld a,(w7TextStatus)		; $5508
	cp $02			; $550b
	jr nc,@nextCharacter	; $550d
	ret			; $550f

;;
; When dealing with control codes, we only need to know how much space each one
; takes up. The actual contents of the text aren't important here.
; The point of this function is just to increment e by how many characters
; there are.
; @param a Control code
; @addr{5510}
@controlCode:
	sub $02			; $5510
	ld b,a			; $5512
	push hl			; $5513
	rst_jumpTable			; $5514
.dw @dictionary
.dw @dictionary
.dw @dictionary
.dw @dictionary
.dw @controlCode6
.dw @controlCode7
.dw @controlCode8
.dw @controlCodeNil
.dw @controlCodeA
.dw @controlCodeNil
.dw @controlCodeNil
.dw @controlCodeNil
.dw @controlCodeNil
.dw @controlCodeF

;;
; @addr{5531}
@dictionary:
	pop hl			; $5531
	call _readByteFromW7ActiveBankAndIncHl		; $5532
	ld (wTextIndexL),a		; $5535
	call _pushToTextStack		; $5538
	ld a,b			; $553b
	ld (wTextIndexH),a		; $553c
	jp _getTextAddress		; $553f

;;
; Symbol
; @addr{5542}
@controlCode6:
	inc e			; $5542
@controlCodeNil:
	pop hl			; $5543
	jp _incHlAndUpdateBank		; $5544

;;
; Jump to another text index
; @addr{5547}
@controlCode7:
	pop hl			; $5547
	call _readByteFromW7ActiveBankAndIncHl		; $5548
	ld (wTextIndexL),a		; $554b
	jp _checkInitialTextCommands		; $554e

;;
; Link name, kid name, or secret
; @addr{5551}
@controlCodeA:
	pop hl			; $5551
	call _readByteFromW7ActiveBankAndIncHl		; $5552
	push hl			; $5555
	ld hl,_nameAddressTable		; $5556
	rst_addDoubleIndex			; $5559
	ldi a,(hl)		; $555a
	ld h,(hl)		; $555b
	ld l,a			; $555c
--
	ldi a,(hl)		; $555d
	or a			; $555e
	jr z,+			; $555f

	inc e			; $5561
	jr --			; $5562
+
@controlCode8:
	pop hl			; $5564
	ret			; $5565

;;
; Call another text index
; @addr{5566}
@controlCodeF:
	pop hl			; $5566
	call _readByteFromW7ActiveBankAndIncHl		; $5567
	cp $fc			; $556a
	jr c,++			; $556c

	push hl			; $556e
	cpl			; $556f
	ld hl,wTextSubstitutions		; $5570
	rst_addAToHl			; $5573
	ld a,(hl)		; $5574
	pop hl			; $5575
++
	ld (wTextIndexL),a		; $5576
	call _pushToTextStack		; $5579
	jp _checkInitialTextCommands		; $557c

;;
; Shift w7TextGfxBuffer such that each tile is moved one position to the left.
; @param[out] hl Text address
; @addr{557f}
_shiftTextGfxBufferLeft:
	ld hl,w7TextGfxBuffer		; $557f
	ld de,w7TextGfxBuffer+$20		; $5582
	ld bc,$01e0		; $5585
--
	ld a,(de)		; $5588
	ldi (hl),a		; $5589
	inc de			; $558a
	dec bc			; $558b
	ld a,c			; $558c
	or b			; $558d
	jr nz,--		; $558e

	ld hl,w7TextAddressL		; $5590
	ldi a,(hl)		; $5593
	ld h,(hl)		; $5594
	ld l,a			; $5595
	ret			; $5596

;;
; @addr{5597}
_decInvTextScrollTimer:
	ld h,d			; $5597
	ld l,<w7InvTextScrollTimer		; $5598
	dec (hl)		; $559a
	ret nz			; $559b

	ld (hl),$08		; $559c
	xor a			; $559e
	ret			; $559f

;;
; Sets z flag if $06 is passed (command to read a trade item or symbol
; graphic). I think the reasoning is that the z flag is set when an actual
; character is drawn, since most control codes don't draw characters.
; @addr{55a0}
_handleTextControlCodeWithSpecialCase:
	cp $06			; $55a0
	jr z,@cmd6		; $55a2

	call _handleTextControlCode		; $55a4
	or d			; $55a7
	ret			; $55a8

	; Control code 6: trade item or symbol
@cmd6:
	ld bc,w7TextGfxBuffer+$1e0		; $55a9
	ld de,$d5e0		; $55ac
	call _handleTextControlCode		; $55af
	xor a			; $55b2
	ret			; $55b3

;;
; Updates w7SelectedTextPosition based on w7SelectedTextOption, and draws the
; cursor to that position in w7TextboxMap.
; @addr{55b4}
_updateSelectedTextPosition:
	call _getSelectedTextOptionAddress		; $55b4
	bit 5,(hl)		; $55b7
	ld b,$60		; $55b9
	jr nz,+			; $55bb
	ld b,$20		; $55bd
+
	ld a,(hl)		; $55bf

	; de = w7SelectedTextPosition
	inc e			; $55c0
	ld (de),a		; $55c1

	call _getAddressInTextboxMap		; $55c2
	ld (hl),$04		; $55c5
	ret			; $55c7

;;
; @param[out] hl The address in w7TextboxOptionPositions for the current
; selected option.
; @addr{55c8}
_getSelectedTextOptionAddress:
	ld e,<w7SelectedTextOption		; $55c8
	ld a,(de)		; $55ca
	add <w7TextboxOptionPositions		; $55cb
	ld l,a			; $55cd
	ld h,d			; $55ce
	ret			; $55cf

;;
; @param a Value from w7TextboxOptionPositions
; @param b Offset to start of row ($20 for top row, $60 for bottom)
; @param[out] hl Pointer to somewhere in w7TextboxMap
; @addr{55d0}
_getAddressInTextboxMap:
	and $1e			; $55d0
	rrca			; $55d2
	ld l,a			; $55d3
	ld e,<w7d0cc		; $55d4
	ld a,(de)		; $55d6

	; Text starts 2 tiles from the leftmost edge
	add $02			; $55d7

	add l			; $55d9
	and $1f			; $55da
	add b			; $55dc
	ld l,a			; $55dd
	ld h,>w7TextboxMap		; $55de
	ret			; $55e0

;;
; @addr{55e1}
_removeCursorFromSelectedTextPosition:
	ld b,$60		; $55e1
	ld e,<w7SelectedTextPosition		; $55e3
	ld a,(de)		; $55e5
	ld c,a			; $55e6
	bit 5,a			; $55e7
	jr nz,+			; $55e9
	ld b,$20		; $55eb
+
	call _getAddressInTextboxMap		; $55ed
	ld (hl),c		; $55f0
	ret			; $55f1

;;
; @addr{55f2}
_moveSelectedTextOptionRight:
	ld e,<w7SelectedTextOption		; $55f2
	ld a,(de)		; $55f4
	inc a			; $55f5
	and $07			; $55f6
	ld (de),a		; $55f8
	call _getSelectedTextOptionAddress		; $55f9
	ld a,(hl)		; $55fc
	or a			; $55fd
	ret nz			; $55fe

	xor a			; $55ff
	ld (de),a		; $5600
	ret			; $5601

;;
; @addr{5602}
_moveSelectedTextOptionLeft:
	ld e,<w7SelectedTextOption		; $5602
	ld a,(de)		; $5604
	dec a			; $5605
	and $07			; $5606
	ld (de),a		; $5608
	call _getSelectedTextOptionAddress		; $5609
	ld a,(hl)		; $560c
	or a			; $560d
	ret nz			; $560e
	jr _moveSelectedTextOptionLeft		; $560f

;;
; @addr{5611}
_textOptionCode_checkDirectionButtons:
	ld a,(wKeysJustPressed)		; $5611
	and BTN_UP|BTN_DOWN|BTN_LEFT|BTN_RIGHT			; $5614
	ret z			; $5616

	ld a,SND_MENU_MOVE		; $5617
	call playSound		; $5619
	call _removeCursorFromSelectedTextPosition		; $561c
	call @updateSelectedTextOption		; $561f
	jr _updateSelectedTextPositionAndDmaTextboxMap		; $5622

;;
; Updates w7SelectedTextOption depending on the input.
; @addr{5624}
@updateSelectedTextOption:
	ld a,(wKeysJustPressed)		; $5624
	call getHighestSetBit		; $5627
	sub $04			; $562a

	; Right
	jr z,_moveSelectedTextOptionRight	; $562c

	; Left
	dec a			; $562e
	jr z,_moveSelectedTextOptionLeft	; $562f

	; Up or down

	call _getSelectedTextOptionAddress		; $5631
	ld b,(hl)		; $5634
	ld c,$ff		; $5635
	ld l,<w7TextboxOptionPositions		; $5637
	ld e,l			; $5639
---
	ld a,(hl)		; $563a
	or a			; $563b
	jr z,@end		; $563c

	sub b			; $563e
	jr nc,+			; $563f
	cpl			; $5641
	inc a			; $5642
+
	sub $20			; $5643
	jr nc,+			; $5645
	cpl			; $5647
	inc a			; $5648
+
	cp c			; $5649
	jr nc,+			; $564a
	ld c,a			; $564c
	ld e,l			; $564d
+
	inc l			; $564e
	jr ---			; $564f

@end:
	ld a,c			; $5651
	cp $10			; $5652
	ret nc			; $5654

	ld a,e			; $5655
	sub <w7TextboxOptionPositions			; $5656
	ld e,<w7SelectedTextOption		; $5658
	ld (de),a		; $565a
	ret			; $565b

;;
; @addr{565c}
_updateSelectedTextPositionAndDmaTextboxMap:
	call _updateSelectedTextPosition		; $565c
	jp _dmaTextboxMap		; $565f

;;
; When the B button is pressed, move the cursor to the last option.
; Unsets zero flag if B is pressed.
; @param a Buttons pressed
; @addr{5662}
_textOptionCode_checkBButton:
	and BTN_B			; $5662
	ret z			; $5664

	; Find last option
	ld h,d			; $5665
	ld l,<w7TextboxOptionPositions		; $5666
-
	ldi a,(hl)		; $5668
	or a			; $5669
	jr nz,-			; $566a

	ld a,l			; $566c
	sub <w7TextboxOptionPositions+2		; $566d
	ld l,<w7SelectedTextOption		; $566f
	ld (hl),a		; $5671

	ld a,SND_MENU_MOVE	; $5672
	call playSound		; $5674
	call _removeCursorFromSelectedTextPosition		; $5677
	call _updateSelectedTextPositionAndDmaTextboxMap		; $567a
	or d			; $567d
	ret			; $567e

;;
; Save the current address of text being read.
; @param hl Current address of text
; @addr{567f}
_pushToTextStack:
	push de			; $567f
	push bc			; $5680
	push hl			; $5681
	ld hl,w7TextStack+$1b		; $5682
	ld de,w7TextStack+$1f		; $5685
	ld b,$1c		; $5688
-
	ldd a,(hl)		; $568a
	ld (de),a		; $568b
	dec e			; $568c
	dec b			; $568d
	jr nz,-		; $568e

	; hl = w7TextStack
	inc l			; $5690

	ld de,w7ActiveBank		; $5691
	ld a,(de)		; $5694
	ldi (hl),a		; $5695
	pop de			; $5696
	ld (hl),e		; $5697
	inc l			; $5698
	ld (hl),d		; $5699
	inc l			; $569a
	ld a,(wTextIndexH)		; $569b
	ld (hl),a		; $569e
	ld h,d			; $569f
	ld l,e			; $56a0
	pop bc			; $56a1
	pop de			; $56a2
	ret			; $56a3

;;
; @addr{56a4}
_popFromTextStack:
	push de			; $56a4
	push bc			; $56a5
	ld hl,w7TextStack+3		; $56a6
	ldd a,(hl)		; $56a9
	ld (wTextIndexH),a		; $56aa
	ldd a,(hl)		; $56ad
	ld de,w7TextAddressH		; $56ae
	ld (de),a		; $56b1
	ld b,a			; $56b2
	ldd a,(hl)		; $56b3
	dec e			; $56b4
	ld (de),a		; $56b5
	ld c,a			; $56b6
	ld a,(hl)		; $56b7
	dec e			; $56b8
	ld (de),a		; $56b9
	push bc			; $56ba
	ld de,w7TextStack+4		; $56bb
	ld b,$1c		; $56be
-
	ld a,(de)		; $56c0
	ldi (hl),a		; $56c1
	inc e			; $56c2
	dec b			; $56c3
	jr nz,-			; $56c4

	xor a			; $56c6
	ldi (hl),a		; $56c7
	ldi (hl),a		; $56c8
	ldi (hl),a		; $56c9
	ld (hl),a		; $56ca
	pop hl			; $56cb
	pop bc			; $56cc
	pop de			; $56cd
	ret			; $56ce

;;
; @addr{56cf}
_readByteFromW7ActiveBankAndIncHl:
	call readByteFromW7ActiveBank		; $56cf

;;
; @addr{56d2}
_incHlAndUpdateBank:
	inc l			; $56d2
	ret nz			; $56d3

	inc h			; $56d4
	bit 7,h			; $56d5
	ret z			; $56d7

	rrc h			; $56d8
	push af			; $56da
	ld a,(w7ActiveBank)		; $56db
	inc a			; $56de
	ld (w7ActiveBank),a		; $56df
	pop af			; $56e2
	ret			; $56e3

;;
; Handle control codes for text (any value under $10)
; @param a Control code
; @addr{56e4}
_handleTextControlCode:
	push bc			; $56e4
	push hl			; $56e5
	rst_jumpTable			; $56e6
.dw @controlCode0
.dw @controlCode1
.dw @controlCode2
.dw @controlCode3
.dw @controlCode4
.dw @controlCode5
.dw @controlCode6
.dw @controlCode7
.dw @controlCode8
.dw @controlCode9
.dw @controlCodeA
.dw @controlCodeB
.dw @controlCodeC
.dw @controlCodeD
.dw @controlCodeE
.dw @controlCodeF

; Unused?
@blankCode:
	pop hl			; $5707
	pop bc			; $5708
	ret			; $5709

;;
; Null terminator; end of text
; @addr{570a}
@controlCode0:
	pop hl			; $570a
	pop bc			; $570b
	call _popFromTextStack		; $570c
	ld a,h			; $570f
	or a			; $5710
	ret nz			; $5711

	; If $00 was popped from the text stack, we've reached the end
	ld (w7TextStatus),a		; $5712
	ret			; $5715

;;
; Newline character
; @addr{5716}
@controlCode1:
	pop hl			; $5716
	pop bc			; $5717
	ld a,$01		; $5718
	ld (w7TextStatus),a		; $571a
	ret			; $571d

;;
; Special character - japanese kanji or trade item symbol.
; If bit 7 of the parameter is set, it reads a trade item from
; gfx_font_tradeitems.
; Otherwise, it reads a kanji from gfx_font_jp. This file also contains the
; triangle symbol which is used sometimes in the english version.
; @addr{571e}
@controlCode6:
	pop hl			; $571e
	call _readByteFromW7ActiveBankAndIncHl		; $571f
	ld b,a			; $5722
	cp $80			; $5723
	jr c,@kanji		; $5725

@tradeItem:
	ld a,(wTextGfxColorIndex)		; $5727
	swap a			; $572a
	or $03			; $572c
	ld (wTextGfxColorIndex),a		; $572e
	ld a,$02		; $5731
	ld (w7TextGfxSource),a		; $5733
	ld a,b			; $5736
	sub $80			; $5737
	add a			; $5739
	jr ++			; $573a

@kanji:
	ld a,$01		; $573c
	ld (w7TextGfxSource),a		; $573e
	ld a,b			; $5741
++
	pop bc			; $5742
	push af			; $5743
	ld a,$06		; $5744
	call _setLineTextBuffers		; $5746
	pop af			; $5749
	jp retrieveTextCharacter		; $574a

;;
; Dictionary 0
; @addr{574d}
@controlCode2:
	xor a			; $574d
	jr ++			; $574e

;;
; Dictionary 1
; @addr{5750}
@controlCode3:
	ld a,$01		; $5750
	jr ++			; $5752

;;
; Dictionary 2
; @addr{5754}
@controlCode4:
	ld a,$02		; $5754
	jr ++			; $5756

;;
; Dictionary 3
; @addr{5758}
@controlCode5:
	ld a,$03		; $5758
++
	ldh (<hFF8B),a	; $575a
	pop hl			; $575c
	call _readByteFromW7ActiveBankAndIncHl		; $575d
	ld (wTextIndexL),a		; $5760
	call _pushToTextStack		; $5763
	ldh a,(<hFF8B)	; $5766
	ld (wTextIndexH),a		; $5768
	call _getTextAddress		; $576b
	jr @popBcAndRet		; $576e

;;
; "Call" another piece of text; insert that text, then go back to reading the
; current text.
; @addr{5770}
@controlCodeF:
	pop hl			; $5770
	call _readByteFromW7ActiveBankAndIncHl		; $5771
	cp $fc			; $5774
	jr c,+			; $5776

	push hl			; $5778
	cpl			; $5779
	ld hl,wTextSubstitutions		; $577a
	rst_addAToHl			; $577d
	ld a,(hl)		; $577e
	pop hl			; $577f
+
	ld (wTextIndexL),a		; $5780
	ld a,(wTextIndexH_backup)		; $5783
	ld (wTextIndexH),a		; $5786
	call _pushToTextStack		; $5789
	call _checkInitialTextCommands		; $578c
	jr @popBcAndRet		; $578f

;;
; "Jump" to a different text index
; @addr{5791}
@controlCode7:
	pop hl			; $5791
	call _readByteFromW7ActiveBankAndIncHl		; $5792
	ld (wTextIndexL),a		; $5795
	call _checkInitialTextCommands		; $5798
	jr @popBcAndRet		; $579b

;;
; This tells the game to stop displaying the text, and to show a different
; textbox when this one is closed. Used in shops to show various messages
; depending whether you can hold or can afford a particular item.
; This command actually takes a parameter, but it's not read here.
; @addr{579d}
@controlCode8:
	; Show another textbox later
	ld a,(w7d0c1)		; $579d
	or $10			; $57a0
	ld (w7d0c1),a		; $57a2

	; End this text
	xor a			; $57a5
	ld (w7TextStatus),a		; $57a6

	pop hl			; $57a9
	jr @popBcAndRet		; $57aa

;;
; Change text color or set the attribute byte.
; If the parameter has bit 7 set, it is written directly to w7TextAttribute.
; Otherwise, the parameter is used as an index for a table of preset values.
; @addr{57ac}
@controlCode9:
	pop hl			; $57ac

	; Check TEXTBOXFLAG_NOCOLORS
	ld a,(wTextboxFlags)		; $57ad
	rrca			; $57b0
	jr c,@@noColors		; $57b1

	call _readByteFromW7ActiveBankAndIncHl		; $57b3
	bit 7,a			; $57b6
	jr nz,+			; $57b8

	ld bc,@textColorData	; $57ba
	call addDoubleIndexToBc		; $57bd
	ld a,(bc)		; $57c0
	ld (w7TextAttribute),a		; $57c1
	inc bc			; $57c4
	ld a,(bc)		; $57c5
	ld (wTextGfxColorIndex),a		; $57c6
	pop bc			; $57c9
	ret			; $57ca
+
	ld (w7TextAttribute),a		; $57cb
	jr @popBcAndRet		; $57ce

@@noColors:
	call _incHlAndUpdateBank		; $57d0

@popBcAndRet:
	pop bc			; $57d3
	ret			; $57d4

; b0: attribute byte (which palette to use)
; b1: Value for wTextGfxColorIndex
; @addr{57d5}
@textColorData:
	.db $80 $02
	.db $80 $01
	.db $81 $00
	.db $81 $01
	.db $81 $02

;;
; Link or kid name
; @addr{57df}
@controlCodeA:
	pop hl			; $57df
	pop bc			; $57e0
	call _readByteFromW7ActiveBankAndIncHl		; $57e1
	push hl			; $57e4
	ld hl,_nameAddressTable		; $57e5
	rst_addDoubleIndex			; $57e8
	ldi a,(hl)		; $57e9
	ld h,(hl)		; $57ea
	ld l,a			; $57eb
--
	ldi a,(hl)		; $57ec
	or a			; $57ed
	jr z,+			; $57ee

	call _setLineTextBuffers		; $57f0
	call retrieveTextCharacter		; $57f3
	jr --			; $57f6
+
	pop hl			; $57f8
	ret			; $57f9

;;
; Play a sound effect
; @addr{57fa}
@controlCodeE:
	pop hl			; $57fa
	call _readByteFromW7ActiveBankAndIncHl		; $57fb
	ld (w7SoundEffect),a		; $57fe
	jr @popBcAndRet		; $5801

; Unused?
	pop hl			; $5803
	call _readByteFromW7ActiveBankAndIncHl		; $5804
	ld b,a			; $5807
	call @@func2		; $5808
	call @@func1		; $580b
	jr @popBcAndRet		; $580e

@@func1:
	push de			; $5810
	ld a,e			; $5811
	add $50			; $5812
	ld e,a			; $5814
	ld a,(de)		; $5815
	or $01			; $5816
	ld (de),a		; $5818
	pop de			; $5819
	ret			; $581a

@@func2:
	push de			; $581b
	ld a,e			; $581c
	add $20			; $581d
	ld e,a			; $581f
	ld a,b			; $5820
	ld (de),a		; $5821
	pop de			; $5822
	ret			; $5823

;;
; Set the sound that's made when each character is displayed
; @addr{5824}
@controlCodeB:
	pop hl			; $5824
	call _readByteFromW7ActiveBankAndIncHl		; $5825
	ld (w7TextSound),a		; $5828
	jr @popBcAndRet		; $582b

;;
; Set the number of frames until the textbox closes itself.
; @addr{582d}
@controlCodeD:
	pop hl			; $582d
	call _readByteFromW7ActiveBankAndIncHl		; $582e
	ld (w7TextboxTimer),a		; $5831
	jr @popBcAndRet		; $5834

;;
; Parameter:
;  Bits 0-1: Loaded into c
;  Bits 3-7: Action to perform. Values of 0-7 are valid.
; @addr{5836}
@controlCodeC:
	pop hl			; $5836
	call _readByteFromW7ActiveBankAndIncHl		; $5837
	push hl			; $583a
	ld b,a			; $583b
	and $03			; $583c
	ld c,a			; $583e
	ld a,b			; $583f
	swap a			; $5840
	rlca			; $5842
	and $1f			; $5843
	rst_jumpTable			; $5845
.dw _textControlCodeC_0
.dw _textControlCodeC_1
.dw _textControlCodeC_2
.dw _textControlCodeC_3
.dw _textControlCodeC_ret ; $04 is dealt with in _checkInitialTextCommands.
.dw _textControlCodeC_5
.dw _textControlCodeC_6
.dw _textControlCodeC_7

;;
; Gets the number of frames each character is displayed for, based on
; wTextSpeed.
; @param[out] a Frames per character
; @addr{5856}
_getCharacterDisplayLength:
	push hl			; $5856
	ld a,(wTextSpeed)		; $5857
	swap a			; $585a
	rrca			; $585c
	ld hl,_textSpeedData+2	; $585d
	rst_addAToHl			; $5860
	ld a,(hl)		; $5861
	pop hl			; $5862
	ret			; $5863

;;
; Sets the speed of the text. Value of $02 for c sets it to normal, lower
; values are faster, higher ones are slower.
; @addr{5864}
_textControlCodeC_0:
	ld a,(wTextSpeed)		; $5864
	swap a			; $5867
	rrca			; $5869
	add c			; $586a
	ld hl,_textSpeedData	; $586b
	rst_addAToHl			; $586e
	ld a,(hl)		; $586f
	ld (w7CharacterDisplayLength),a		; $5870
	jr _textControlCodeC_ret		; $5873

; This is the structure which controls the values for each text speed. I don't
; know why there are 8 bytes per text speed, but the 3rd byte of each appears
; to be the only important one.
; @addr{5875}
_textSpeedData:
	.db $04 $05 $07 $08 $0a $0c $0e $0f ; Text speed 1
	.db $03 $04 $05 $07 $08 $0a $0b $0c ; Text speed 2
	.db $02 $03 $04 $05 $06 $08 $08 $0a ; 3
	.db $02 $02 $03 $03 $04 $06 $06 $08 ; 4
	.db $01 $01 $02 $02 $03 $03 $04 $05 ; 5
;;
; Slow down the text. Used for essences.
; @addr{589d}
_textControlCodeC_7:
	ld a,$78		; $589d
	ld (w7TextSlowdownTimer),a		; $589f
	jr _textControlCodeC_ret		; $58a2

;;
; Show the piece of heart icon.
; @addr{58a4}
_textControlCodeC_5:
	ld hl,w7d0c1		; $58a4
	set 5,(hl)		; $58a7

;;
; Stop text here, clear textbox on next button press.
; @addr{58a9}
_textControlCodeC_3:
	ld hl,w7d0c1		; $58a9
	set 1,(hl)		; $58ac

;;
; @addr{58ae}
_textControlCodeC_ret:
	pop hl			; $58ae
	pop bc			; $58af
	ret			; $58b0

;;
; Unused?
; @addr{58b1}
_textControlCodeC_6:
	ld a,($cbab)		; $58b1
	ld (wTextNumberSubstitution+1),a		; $58b4
	ld a,($cbaa)		; $58b7
	ld (wTextNumberSubstitution),a		; $58ba

;;
; Display a number of up to 3 digits. Usually bcd format.
; @addr{58bd}
_textControlCodeC_1:
	pop hl			; $58bd
	pop bc			; $58be

	; Hundreds digit
	ld a,(wTextNumberSubstitution+1)		; $58bf
	or a			; $58c2
	jr z,+			; $58c3

	call @drawDigit		; $58c5

	; Tens digit
	ld a,(wTextNumberSubstitution)		; $58c8
	and $f0			; $58cb
	jr ++			; $58cd
+
	ld a,(wTextNumberSubstitution)		; $58cf
	and $f0			; $58d2
	jr z,+++		; $58d4
++
	swap a			; $58d6
	call @drawDigit		; $58d8
+++
	; Ones digit
	ld a,(wTextNumberSubstitution)		; $58db
	and $0f			; $58de

@drawDigit:
	add $30			; $58e0
	call _setLineTextBuffers		; $58e2
	jp retrieveTextCharacter		; $58e5

;;
; An option is presented, ie. yes/no. This command marks a possible position
; for the cursor.
; @addr{58e8}
_textControlCodeC_2:
	call @getNextTextboxOptionPosition		; $58e8
	ld a,(w7d0c1)		; $58eb
	or $04			; $58ee
	ld (w7d0c1),a		; $58f0

	; e is the position in the line
	ld a,e			; $58f3
	; Multiply by 2 since each character is 2 bytes
	add a			; $58f4
	; w7TextboxMap+$60 is the start of the bottom row
	or $60			; $58f5

	ld b,a			; $58f7
	inc b			; $58f8
	ld (hl),b		; $58f9
	pop hl			; $58fa
	pop bc			; $58fb

	; Reserve this spot for the cursor
	ld a,$20		; $58fc
	call _setLineTextBuffers		; $58fe
	jp retrieveTextCharacter		; $5901

;;
; @addr{5904}
@getNextTextboxOptionPosition:
	ld hl,w7TextboxOptionPositions		; $5904
-
	ld a,(hl)		; $5907
	or a			; $5908
	ret z			; $5909

	inc l			; $590a
	jr -			; $590b

; @addr{590d}
_nameAddressTable:
	.dw wLinkName wKidName
	.dw w7SecretText1 w7SecretText2

; This data structure works with text command $08. When buying something from
; a shop, it checks the given variable ($cbad) and displays one of these pieces
; of text depending on the value.
;
; @addr{5915}
_extraTextIndices:
	.dw $0000
	.dw $0000
	.dw $0000
	.dw $0000
	.dw $0000
	.dw $0000
	.dw $0000
	.dw $0000
	.dw $0000
	.dw $0000
	.dw $0000
	.dw $0000
	.dw $0000
	.dw @index0d
	.dw @index0e
	.dw @index0f
	.dw $0000
	.dw @index11

; Potion in Syrup's hut
@index0d:
	.dw $cbad
	.db <TX_0d02 <TX_0d08 <TX_0d04 <TX_0d03

; Gasha seed in Syrup's hut
@index0e:
	.dw $cbad
	.db <TX_0d06 <TX_0d08 <TX_0d07 <TX_0d03

; Ring box upgrade in upstairs Lynna shop
@index0f:
	.dw $cbad
	.db $ff <TX_0e06 <TX_0e05 $ff

; Bombchus in Syrup's hut
@index11:
	.dw $cbad
	.db <TX_0d0c <TX_0d08 <TX_0d07 <TX_0d03

; @addr{5951}
data_5951:
	.db $3c $b4 $3c $50 $78 $b4 $3c $3c
	.db $3c $70 $78 $78

.ifdef ROM_AGES

; In Seasons these sprites are located elsewhere

titlescreenMakuSeedSprite:
	.db $13
	.db $48 $90 $62 $06
	.db $42 $8e $68 $06
	.db $51 $7a $56 $04
	.db $50 $82 $74 $04
	.db $58 $7a $6a $07
	.db $58 $82 $6c $07
	.db $58 $8a $6e $07
	.db $54 $8a $54 $03
	.db $54 $82 $52 $03
	.db $54 $7a $50 $03
	.db $64 $7a $70 $03
	.db $64 $82 $72 $03
	.db $64 $8a $70 $23
	.db $40 $86 $66 $06
	.db $40 $7f $64 $06
	.db $41 $70 $60 $06
	.db $55 $76 $5a $06
	.db $44 $68 $5e $26
	.db $74 $00 $46 $02

titlescreenPressStartSprites:
	.db $0a
	.db $80 $2c $38 $00
	.db $80 $34 $3a $00
	.db $80 $3c $3c $00
	.db $80 $44 $3e $00
	.db $80 $4c $3e $00
	.db $80 $5c $3e $00
	.db $80 $64 $40 $00
	.db $80 $6c $42 $00
	.db $80 $74 $3a $00
	.db $80 $7c $40 $00

; Sprites used on the closeup shot of Link on the horse in the intro
linkOnHorseCloseupSprites_2:
	.db $26
	.db $80 $80 $40 $06
	.db $80 $50 $42 $00
	.db $80 $58 $44 $00
	.db $68 $40 $46 $06
	.db $b8 $3d $20 $02
	.db $b8 $45 $22 $02
	.db $b8 $4d $24 $02
	.db $b8 $55 $26 $02
	.db $b8 $5d $28 $02
	.db $90 $28 $2c $02
	.db $90 $30 $2e $02
	.db $80 $30 $2a $02
	.db $20 $78 $48 $05
	.db $58 $68 $00 $02
	.db $58 $70 $02 $02
	.db $68 $68 $04 $02
	.db $48 $70 $06 $02
	.db $5a $40 $08 $01
	.db $5a $48 $0a $01
	.db $5a $50 $0c $01
	.db $38 $88 $0e $04
	.db $30 $78 $10 $04
	.db $30 $80 $12 $04
	.db $40 $80 $14 $04
	.db $50 $76 $16 $04
	.db $50 $7e $18 $04
	.db $41 $62 $1a $03
	.db $80 $28 $1c $02
	.db $a8 $59 $1e $02
	.db $98 $20 $30 $02
	.db $98 $28 $32 $02
	.db $8c $38 $34 $07
	.db $a8 $41 $36 $02
	.db $a8 $49 $38 $02
	.db $a8 $51 $3a $02
	.db $90 $40 $3e $07
	.db $8a $5c $4a $00
	.db $8a $64 $4c $00

; Sprites used to touch up the appearance of the temple in the intro (the scene where
; Link's on a cliff with his horse)
introTempleSprites:
	.db $05
	.db $30 $28 $48 $02
	.db $30 $30 $4a $02
	.db $18 $38 $4c $03
	.db $10 $40 $4e $03
	.db $18 $48 $50 $03


; Used in intro (ages only)
linkOnHorseFacingCameraSprite:
	.db $02
	.db $70 $08 $58 $02
	.db $70 $10 $5a $02

.endif ; ROM_AGES


.include "build/data/objectGfxHeaders.s"
.include "build/data/treeGfxHeaders.s"

.include "build/data/enemyData.s"
.include "build/data/partData.s"
.include "build/data/itemData.s"
.include "build/data/interactionData.s"

.include "build/data/treasureCollectionBehaviours.s"
.include "build/data/treasureDisplayData.s"

; @addr{714c}
oamData_714c:
	.db $10
	.db $c8 $38 $2e $0e
	.db $c8 $40 $30 $0e
	.db $c8 $48 $32 $0e
	.db $c8 $60 $34 $0f
	.db $c8 $68 $36 $0f
	.db $c8 $70 $38 $0f
	.db $d8 $78 $06 $2e
	.db $e8 $80 $00 $0d
	.db $e8 $78 $08 $0e
	.db $e0 $90 $00 $0d
	.db $d8 $a0 $00 $0d
	.db $e8 $30 $04 $0e
	.db $d8 $30 $06 $0e
	.db $f8 $28 $02 $0e
	.db $f0 $18 $00 $2d
	.db $e8 $08 $00 $2d

; @addr{718d}
oamData_718d:
	.db $10
	.db $a8 $38 $12 $0a
	.db $b8 $38 $0e $0f
	.db $c8 $38 $0a $0f
	.db $a8 $70 $14 $0a
	.db $b8 $70 $10 $0a
	.db $c8 $70 $0c $0f
	.db $e8 $80 $00 $0d
	.db $d8 $78 $06 $2e
	.db $e8 $78 $08 $0e
	.db $e0 $90 $00 $0d
	.db $d8 $a0 $00 $0d
	.db $f8 $28 $02 $0e
	.db $f0 $18 $00 $2d
	.db $e8 $08 $00 $2d
	.db $d8 $30 $06 $0e
	.db $e8 $30 $08 $2e

; @addr{71ce}
oamData_71ce:
	.db $0a
	.db $50 $40 $40 $0b
	.db $50 $48 $42 $0b
	.db $50 $50 $44 $0b
	.db $50 $58 $46 $0b
	.db $50 $60 $48 $0b
	.db $50 $68 $4a $0b
	.db $70 $70 $3c $0c
	.db $60 $70 $3e $2c
	.db $70 $38 $3a $0c
	.db $60 $38 $3e $0c

; @addr{71f7}
oamData_71f7:
	.db $0a
	.db $10 $40 $22 $08
	.db $10 $68 $22 $28
	.db $60 $38 $16 $0c
	.db $70 $38 $1a $0c
	.db $60 $70 $18 $0c
	.db $70 $70 $1a $2c
	.db $40 $40 $1c $08
	.db $40 $68 $1e $08
	.db $50 $40 $20 $08
	.db $50 $68 $20 $28

; @addr{7220}
oamData_7220:
	.db $0a
	.db $e0 $48 $24 $0b
	.db $e0 $60 $24 $2b
	.db $e0 $50 $26 $0b
	.db $e0 $58 $26 $2b
	.db $f0 $48 $28 $0b
	.db $f0 $60 $28 $2b
	.db $00 $48 $2a $0b
	.db $00 $60 $2a $2b
	.db $f8 $50 $2c $0b
	.db $f8 $58 $2c $2b

; @addr{7249}
oamData_7249:
	.db $27
	.db $38 $38 $00 $01
	.db $38 $58 $02 $00
	.db $30 $48 $04 $00
	.db $30 $50 $06 $00
	.db $40 $48 $08 $00
	.db $58 $38 $0a $00
	.db $50 $40 $0c $02
	.db $50 $48 $0e $04
	.db $58 $50 $10 $03
	.db $60 $57 $12 $03
	.db $60 $5f $14 $03
	.db $60 $30 $16 $00
	.db $72 $38 $18 $00
	.db $70 $30 $1a $03
	.db $88 $28 $1c $00
	.db $3b $9a $1e $04
	.db $4b $9a $20 $04
	.db $58 $90 $22 $05
	.db $58 $98 $24 $05
	.db $22 $a0 $26 $06
	.db $22 $a8 $28 $06
	.db $32 $a0 $2a $06
	.db $32 $a8 $2c $06
	.db $12 $a0 $2e $06
	.db $12 $a8 $30 $06
	.db $12 $b0 $32 $06
	.db $6c $b0 $34 $03
	.db $70 $c0 $36 $01
	.db $80 $c0 $38 $05
	.db $90 $58 $3a $03
	.db $30 $90 $3c $00
	.db $90 $c0 $3e $05
	.db $90 $78 $40 $05
	.db $80 $70 $42 $05
	.db $80 $78 $44 $05
	.db $80 $88 $46 $05
	.db $90 $80 $48 $05
	.db $48 $50 $4a $02
	.db $60 $40 $4c $00


; ==============================================================================
; INTERACID_MONKEY
;
; Variables:
;   var38/39: Copied to speedZ?
;   var3a:    Animation index?
; ==============================================================================
interactionCode39_body:
	ld e,Interaction.state		; $72e6
	ld a,(de)		; $72e8
	rst_jumpTable			; $72e9
	.dw @state0
	.dw _monkeyState1

@state0:
	ld a,$01		; $72ee
	ld (de),a		; $72f0

	ld a,>TX_5700		; $72f1
	call interactionSetHighTextIndex		; $72f3

	call interactionInitGraphics		; $72f6
	call objectSetVisiblec2		; $72f9
	call @initSubid		; $72fc

	ld e,Interaction.var03		; $72ff
	ld a,(de)		; $7301
	cp $09			; $7302
	ret z			; $7304

	ld e,Interaction.enabled		; $7305
	ld a,(de)		; $7307
	or a			; $7308
	jp nz,objectMarkSolidPosition		; $7309
	ret			; $730c

@initSubid:
	ld e,Interaction.subid		; $730d
	ld a,(de)		; $730f
	rst_jumpTable			; $7310
	.dw @subid0Init
	.dw @subid1Init
	.dw @subid2Init
	.dw @subid3Init
	.dw @subid4Init
	.dw @subid5Init
	.dw @subid6Init
	.dw @subid7Init

@subid0Init:
	ld a,$02		; $7321
	call interactionSetAnimation		; $7323

	ld hl,monkeySubid0Script		; $7326
	jp interactionSetScript		; $7329


@subid2Init:
	ld a,$02		; $732c
	ld e,Interaction.oamFlags		; $732e
	ld (de),a		; $7330
	ld a,$06		; $7331
	call interactionSetAnimation		; $7333
	jr ++			; $7336

@subid3Init:
	ld a,$07		; $7338
	call interactionSetAnimation		; $733a
++
	ld a,GLOBALFLAG_INTRO_DONE		; $733d
	call checkGlobalFlag		; $733f
	jp nz,interactionDelete		; $7342

	ld e,Interaction.subid		; $7345
	ld a,(de)		; $7347
	sub $02			; $7348
	ld hl,_introMonkeyScriptTable		; $734a
	rst_addDoubleIndex			; $734d
	ldi a,(hl)		; $734e
	ld h,(hl)		; $734f
	ld l,a			; $7350
	jp interactionSetScript		; $7351


@subid1Init: ; Subids 4 and 5 calls this too
	ld e,Interaction.var03		; $7354
	ld a,(de)		; $7356
	ld c,a			; $7357
	or a			; $7358
	jr nz,@doneSpawning	; $7359

	; Load PALH_ad if this isn't subid 5?
	dec e			; $735b
	ld a,(de)		; $735c
	cp $05			; $735d
	jr z,++			; $735f
	push bc			; $7361
	ld a,PALH_ad		; $7362
	call loadPaletteHeader		; $7364
	pop bc			; $7367
++

	; Spawn 9 monkeys
	ld b,$09		; $7368

@nextMonkey:
	call getFreeInteractionSlot		; $736a
	jr nz,@doneSpawning	; $736d

	ld (hl),INTERACID_MONKEY		; $736f
	inc l			; $7371
	ld e,Interaction.subid		; $7372
	ld a,(de)		; $7374
	ld (hl),a ; Copy subid
	inc l			; $7376
	ld (hl),b ; [var03] = b
	dec b			; $7378
	jr nz,@nextMonkey	; $7379

@doneSpawning:
	; Retrieve var03
	ld a,c			; $737b
	add a			; $737c

	ld hl,@monkeyPositions		; $737d
	rst_addDoubleIndex			; $7380
	ldi a,(hl)		; $7381
	ld e,Interaction.yh		; $7382
	ld (de),a		; $7384
	ldi a,(hl)		; $7385
	ld e,Interaction.xh		; $7386
	ld (de),a		; $7388

	ldi a,(hl)		; $7389
	ld e,Interaction.counter1		; $738a
	ld (de),a		; $738c
	ld a,(hl)		; $738d
	call interactionSetAnimation		; $738e

	; Randomize the animation slightly?
	call getRandomNumber_noPreserveVars		; $7391
	and $0f			; $7394
	ld h,d			; $7396
	ld l,Interaction.counter2		; $7397
	ld (hl),a		; $7399
	sub $07			; $739a
	ld l,Interaction.animCounter		; $739c
	add (hl)		; $739e
	ld (hl),a		; $739f

	; Randomize jump speeds?
	call getRandomNumber		; $73a0
	and $03			; $73a3
	ld bc,@jumpSpeeds		; $73a5
	call addDoubleIndexToBc		; $73a8
	ld l,Interaction.var38		; $73ab
	ld a,(bc)		; $73ad
	ldi (hl),a		; $73ae
	inc bc			; $73af
	ld a,(bc)		; $73b0
	ld (hl),a		; $73b1
	jp _monkeySetJumpSpeed		; $73b2


@jumpSpeeds:
	.dw -$80
	.dw -$a0
	.dw -$70
	.dw -$90


; This table takes var03 as an index.
; Data format:
;   b0: Y
;   b1: X
;   b2: counter1
;   b3: animation
@monkeyPositions:
	.db $58 $88 $f0 $00
	.db $58 $78 $d2 $01
	.db $28 $28 $dc $01
	.db $38 $38 $be $02
	.db $18 $68 $64 $01
	.db $1c $80 $78 $00
	.db $30 $68 $50 $05
	.db $34 $88 $8c $02
	.db $50 $46 $b4 $02
	.db $64 $28 $b8 $08

@subid4Init:
	call objectSetInvisible		; $73e5
	call @subid1Init		; $73e8

	ld l,Interaction.oamFlags		; $73eb
	ld (hl),$06		; $73ed
	ld l,Interaction.counter2		; $73ef
	ld (hl),$3c		; $73f1

	ld l,Interaction.var03		; $73f3
	ld a,(hl)		; $73f5
	cp $09			; $73f6
	jr nz,++		; $73f8

	; Monkey $09: ?
	ld l,Interaction.var3c		; $73fa
	inc (hl)		; $73fc
	ld bc,$6424		; $73fd
	jp interactionSetPosition		; $7400
++
	cp $08			; $7403
	ret nz			; $7405

	; Monkey $08: the monkey with a bowtie
	ld a,$fa		; $7406
	ld e,Interaction.counter1		; $7408
	ld (de),a		; $740a

@initBowtieMonkey:
	ld a,$07		; $740b
	call interactionSetAnimation		; $740d

	; Create a bowtie
	call getFreeInteractionSlot		; $7410
	ret nz			; $7413
	ld (hl),INTERACID_ACCESSORY		; $7414
	inc l			; $7416
	ld (hl),$3d		; $7417
	inc l			; $7419
	ld (hl),$01		; $741a

	ld l,Interaction.relatedObj1		; $741c
	ld (hl),Interaction.start		; $741e
	inc l			; $7420
	ld (hl),d		; $7421

	ld e,Interaction.relatedObj2+1		; $7422
	ld a,h			; $7424
	ld (de),a		; $7425
	ret			; $7426

@subid5Init:
	ld a,GLOBALFLAG_SAVED_NAYRU		; $7427
	call checkGlobalFlag		; $7429
	jp z,interactionDelete		; $742c
	call @subid1Init		; $742f
	ld l,Interaction.counter1		; $7432
	ldi (hl),a		; $7434
	ld (hl),a		; $7435
	ld hl,monkeySubid5Script		; $7436

	ld e,Interaction.var03		; $7439
	ld a,(de)		; $743b
	cp $08			; $743c
	jr nz,+			; $743e

	; Bowtie monkey has a different script
	push af			; $7440
	call @initBowtieMonkey		; $7441
	ld hl,monkeySubid5Script_bowtieMonkey		; $7444
	pop af			; $7447
+
	; Monkey $05 gets the red palette
	cp $05			; $7448
	ld a,$03		; $744a
	jr nz,+			; $744c
	ld a,$02		; $744e
+
	ld e,Interaction.oamFlags		; $7450
	ld (de),a		; $7452
	jp interactionSetScript		; $7453

@subid6Init:
	ld a,$05		; $7456
	jp interactionSetAnimation		; $7458

@subid7Init:
	ld e,Interaction.var03		; $745b
	ld a,(de)		; $745d
	rst_jumpTable			; $745e
	.dw @subid7Init_0
	.dw @subid7Init_1
	.dw @subid7Init_2

@subid7Init_0:
	ld a,GLOBALFLAG_FINISHEDGAME		; $7465
	call checkGlobalFlag		; $7467
	jp nz,interactionDelete		; $746a

	ld a,GLOBALFLAG_SAVED_NAYRU		; $746d
	call checkGlobalFlag		; $746f
	jp z,interactionDelete		; $7472

	ld hl,monkeySubid7Script_0		; $7475
	call interactionSetScript		; $7478
	ld a,$06		; $747b
	jr @setVar3aAnimation		; $747d

@subid7Init_1:
	ld a,GLOBALFLAG_FINISHEDGAME		; $747f
	call checkGlobalFlag		; $7481
	jp z,interactionDelete		; $7484

	ld hl,monkeySubid7Script_1		; $7487
	call interactionSetScript		; $748a
	ld a,$05		; $748d
	jr @setVar3aAnimation		; $748f

@subid7Init_2:
	ld a,GLOBALFLAG_FINISHEDGAME		; $7491
	call checkGlobalFlag		; $7493
	jp nz,interactionDelete		; $7496

	ld a,GLOBALFLAG_MAKU_TREE_SAVED		; $7499
	call checkGlobalFlag		; $749b
	jp z,interactionDelete		; $749e

	ld a,GLOBALFLAG_SAVED_NAYRU		; $74a1
	call checkGlobalFlag		; $74a3
	ld hl,monkeySubid7Script_2		; $74a6
	jp z,@setScript		; $74a9
	ld hl,monkeySubid7Script_3		; $74ac
@setScript:
	call interactionSetScript		; $74af
	ld a,$05		; $74b2

@setVar3aAnimation:
	ld e,Interaction.var3a		; $74b4
	ld (de),a		; $74b6
	jp interactionSetAnimation		; $74b7

_monkeyState1:
	ld e,Interaction.subid		; $74ba
	ld a,(de)		; $74bc
	rst_jumpTable			; $74bd
	.dw _monkeySubid0State1
	.dw _monkeySubid1State1
	.dw _monkeySubid2State1
	.dw _monkeySubid3State1
	.dw _monkeySubid4State1
	.dw _monkeySubid5State1
	.dw interactionAnimate
	.dw _monkeyAnimateAndRunScript

;;
; @addr{74ce}
_monkeySubid0State1:
	call interactionAnimate		; $74ce
	call objectSetPriorityRelativeToLink_withTerrainEffects		; $74d1
	ld e,Interaction.state2		; $74d4
	ld a,(de)		; $74d6
	or a			; $74d7
	call z,objectPreventLinkFromPassing		; $74d8

	ld e,Interaction.state2		; $74db
	ld a,(de)		; $74dd
	rst_jumpTable			; $74de
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw _monkeySubid0State1Substate3

@substate0:
	ld a,($cfd0)		; $74e7
	cp $0e			; $74ea
	jp nz,interactionRunScript		; $74ec
	call interactionIncState2		; $74ef
	ld a,$06		; $74f2
	jp interactionSetAnimation		; $74f4

@substate1:
	ld a,($cfd0)		; $74f7
	cp $10			; $74fa
	ret nz			; $74fc
	call interactionIncState2		; $74fd
	ld l,Interaction.counter1		; $7500
	ld (hl),$32		; $7502
	ld a,$03		; $7504
	call interactionSetAnimation		; $7506
	jr _monkeyJumpSpeed120		; $7509

@substate2:
	call interactionDecCounter1		; $750b
	jr nz,_monkeyUpdateGravityAndHop	; $750e

	call interactionIncState2		; $7510
	ld l,Interaction.angle		; $7513
	ld (hl),$02		; $7515
	ld l,Interaction.zh		; $7517
	ld (hl),$00		; $7519
	ld l,Interaction.speed		; $751b
	ld (hl),SPEED_180		; $751d

_monkeySetAnimationAndJump:
	call interactionSetAnimation		; $751f

_monkeyJumpSpeed100:
	ld bc,-$100		; $7522
	jp objectSetSpeedZ		; $7525

_monkeySubid0State1Substate3:
	call objectCheckWithinScreenBoundary		; $7528
	jr c,++			; $752b
	ld a,$01		; $752d
	ld (wLoadedTreeGfxIndex),a		; $752f
	jp interactionDelete		; $7532
++
	ld c,$20		; $7535
	call objectUpdateSpeedZ_paramC		; $7537
	jp nz,objectApplySpeed		; $753a
	ld a,$04		; $753d
	jr _monkeySetAnimationAndJump		; $753f

_monkeyUpdateGravityAndHop:
	ld c,$20		; $7541
	call objectUpdateSpeedZ_paramC		; $7543
	ret nz			; $7546

_monkeyJumpSpeed120:
	ld bc,-$120		; $7547
	jp objectSetSpeedZ		; $754a

;;
; Updates gravity, and if the monkey landed, resets speedZ to values of var38/var39.
; @addr{754d}
_monkeyUpdateGravityAndJumpIfLanded:
	ld c,$10		; $754d
	call objectUpdateSpeedZ_paramC		; $754f
	ret nz			; $7552

;;
; Sets speedZ to values of var38/var39.
; @addr{7553}
_monkeySetJumpSpeed:
	ld l,Interaction.var38		; $7553
	ldi a,(hl)		; $7555
	ld e,Interaction.speedZ		; $7556
	ld (de),a		; $7558
	inc e			; $7559
	ld a,(hl)		; $755a
	ld (de),a		; $755b
	ret			; $755c

;;
; Monkey disappearance cutscene
; @addr{755d}
_monkeySubid1State1:
	ld e,Interaction.var03		; $755d
	ld a,(de)		; $755f
	rst_jumpTable			; $7560
	.dw _monkey0Disappearance
	.dw _monkey1Disappearance
	.dw _monkey2Disappearance
	.dw _monkey3Disappearance
	.dw _monkey4Disappearance
	.dw _monkey5Disappearance
	.dw _monkey6Disappearance
	.dw _monkey7Disappearance
	.dw _monkey8Disappearance
	.dw _monkey9Disappearance


_monkey0Disappearance:
_monkey1Disappearance:
_monkey2Disappearance:
_monkey4Disappearance:
	ld e,Interaction.state2		; $7575
	ld a,(de)		; $7577
	rst_jumpTable			; $7578
	.dw @substate0
	.dw @substate1
	.dw _monkeyWaitBeforeFlickering
	.dw _monkeyFlickerUntilDeletion

@substate0:
	call interactionAnimate		; $7581
	call interactionDecCounter2		; $7584
	ret nz			; $7587
	jp interactionIncState2		; $7588

@substate1:
	call interactionDecCounter1		; $758b
	jr nz,+			; $758e
	jr _monkeyBeginDisappearing			; $7590
+
	call _monkeyUpdateGravityAndJumpIfLanded		; $7592
	jp interactionAnimate		; $7595

_monkeyBeginDisappearing:
	ld (hl),$3c		; $7598
	ld l,Interaction.oamFlags		; $759a
	ld (hl),$06		; $759c
	ld l,Interaction.zh		; $759e
	ld (hl),$00		; $75a0

	ld a,SND_CLINK		; $75a2
	call playSound		; $75a4
	jp interactionIncState2		; $75a7

_monkeyWaitBeforeFlickering:
	call interactionDecCounter1		; $75aa
	ret nz			; $75ad
	ld (hl),$3c		; $75ae
	jp interactionIncState2		; $75b0

_monkeyFlickerUntilDeletion:
	call interactionDecCounter1		; $75b3
	jr nz,+			; $75b6
	jp interactionDelete		; $75b8
+
	ld b,$01		; $75bb
	jp objectFlickerVisibility		; $75bd


_monkey3Disappearance:
_monkey6Disappearance:
_monkey7Disappearance:
	ld e,Interaction.state2		; $75c0
	ld a,(de)		; $75c2
	rst_jumpTable			; $75c3
	.dw @substate0
	.dw _monkeyWaitBeforeFlickering
	.dw _monkeyFlickerUntilDeletion

@substate0:
	call interactionDecCounter1		; $75ca
	jp nz,interactionAnimate		; $75cd
	jr _monkeyBeginDisappearing		; $75d0


_monkey5Disappearance:
	ld e,Interaction.state2		; $75d2
	ld a,(de)		; $75d4
	rst_jumpTable			; $75d5
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw _monkeyWaitBeforeFlickering
	.dw _monkeyFlickerUntilDeletion

@substate0:
	call interactionIncState2		; $75e0
	ld l,Interaction.oamFlags		; $75e3
	ld (hl),$02		; $75e5

@substate1:
	call interactionDecCounter1		; $75e7
	ret nz			; $75ea
	ld (hl),$b4		; $75eb
	call interactionIncState2		; $75ed
	ld bc,$f3f8		; $75f0
	ld a,$5a		; $75f3
	jp objectCreateExclamationMark		; $75f5

@substate2:
	call interactionDecCounter1		; $75f8
	ret nz			; $75fb
	jp _monkeyBeginDisappearing		; $75fc


	; Unused code?
	ld e,Interaction.state2		; $75ff
	ld a,(de)		; $7601
	rst_jumpTable			; $7602
	.dw @@substate0
	.dw _monkeyWaitBeforeFlickering
	.dw _monkeyFlickerUntilDeletion

@@substate0:
	call interactionDecCounter1		; $7609
	ret nz			; $760c
	jr _monkeyBeginDisappearing		; $760d


_monkey9Disappearance:
	call _monkeyCheckChangeAnimation		; $760f

	ld e,Interaction.state2		; $7612
	ld a,(de)		; $7614
	cp $04			; $7615
	jr nc,++		; $7617
	call interactionDecCounter1		; $7619
	jr nz,++			; $761c
	call _monkeyBeginDisappearing		; $761e
	ld l,Interaction.state2		; $7621
	ld (hl),$04		; $7623
++
	ld e,Interaction.state2		; $7625
	ld a,(de)		; $7627
	rst_jumpTable			; $7628
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw _monkeyWaitBeforeFlickering
	.dw _monkeyFlickerUntilDeletion

@substate0:
	ld h,d			; $7635
	ld l,Interaction.direction		; $7636
	ld a,$08		; $7638
	ldi (hl),a		; $763a
	ld (hl),a		; $763b

	ld l,Interaction.speed		; $763c
	ld (hl),SPEED_100		; $763e
	call interactionIncState2		; $7640
	jp _monkeyJumpSpeed100		; $7643

@substate1:
	ld c,$20		; $7646
	call objectUpdateSpeedZ_paramC		; $7648
	jp nz,objectApplySpeed		; $764b

	call _monkeyJumpSpeed100		; $764e

	ld l,Interaction.var3c		; $7651
	inc (hl)		; $7653
	ld a,(hl)		; $7654
	cp $03			; $7655
	ret nz			; $7657

	call interactionIncState2		; $7658
	ld l,Interaction.var38		; $765b
	ld (hl),$10		; $765d
	ret			; $765f

@substate2:
	ld h,d			; $7660
	ld l,Interaction.var38		; $7661
	dec (hl)		; $7663
	ret nz			; $7664

	ld (hl),$10		; $7665
	call interactionIncState2		; $7667

	ld l,Interaction.direction		; $766a
	ld a,(hl)		; $766c
	xor $10			; $766d
	ldi (hl),a		; $766f
	ld (hl),a		; $7670

	ld l,Interaction.angle		; $7671
	ld a,(hl)		; $7673
	and $10			; $7674
	ld a,$03		; $7676
	jr nz,+			; $7678
	ld a,$08		; $767a
+
	jp _monkeySetAnimationAndJump		; $767c

@substate3:
	ld h,d			; $767f
	ld l,Interaction.var38		; $7680
	dec (hl)		; $7682
	ret nz			; $7683

	ld l,Interaction.var3c		; $7684
	ld (hl),$00		; $7686
	ld l,Interaction.state2		; $7688
	dec (hl)		; $768a
	dec (hl)		; $768b
	ret			; $768c

;;
; Checks if the monkey is in the air, updates var3a and animation accordingly?
; @addr{768d}
_monkeyCheckChangeAnimation:
	ld h,d			; $768d
	ld l,Interaction.zh		; $768e
	ld a,(hl)		; $7690
	sub $03			; $7691
	cp $fa			; $7693
	ld a,$00		; $7695
	jr nc,+			; $7697
	inc a			; $7699
+
	ld l,Interaction.var3a		; $769a
	cp (hl)			; $769c
	ret z			; $769d
	ld (hl),a		; $769e
	ld l,Interaction.animCounter		; $769f
	ld (hl),$01		; $76a1
	jp interactionAnimate		; $76a3


_monkey8Disappearance:
	ld e,Interaction.state2		; $76a6
	ld a,(de)		; $76a8
	rst_jumpTable			; $76a9
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw _monkeyWaitBeforeFlickering
	.dw @substate3
	.dw @substate4

@substate0:
	call interactionDecCounter1		; $76b6
	jr nz,++		; $76b9
	ld (hl),$5a		; $76bb
	call interactionIncState2		; $76bd
	ld bc,$f3f8		; $76c0
	ld a,$3c		; $76c3
	jp objectCreateExclamationMark		; $76c5
++
	ld a,(wFrameCounter)		; $76c8
	and $01			; $76cb
	ret nz			; $76cd
	jp interactionAnimate		; $76ce

@substate1:
	call interactionDecCounter1		; $76d1
	ret nz			; $76d4
	ld (hl),$b4		; $76d5
	jp interactionIncState2		; $76d7

@substate2:
	call interactionDecCounter1		; $76da
	jr nz,+			; $76dd
	jp _monkeyBeginDisappearing		; $76df
+
	ld a,(wFrameCounter)		; $76e2
	and $0f			; $76e5
	ret nz			; $76e7
	ld l,Interaction.direction		; $76e8
	ld a,(hl)		; $76ea
	xor $01			; $76eb
	ld (hl),a		; $76ed
	jp interactionSetAnimation		; $76ee

@substate3:
	call interactionDecCounter1		; $76f1
	jr nz,++		; $76f4
	ld (hl),$1e		; $76f6
	call objectSetInvisible		; $76f8
	jp interactionIncState2		; $76fb
++
	ld b,$01		; $76fe
	jp objectFlickerVisibility		; $7700

@substate4:
	call interactionDecCounter1		; $7703
	ret nz			; $7706
	ld a,$ff		; $7707
	ld ($cfdf),a		; $7709
	jp interactionDelete		; $770c

;;
; Monkey that only exists before intro
; @addr{770f}
_monkeySubid2State1:
_monkeySubid3State1:
	call interactionRunScript		; $770f
	jp interactionAnimateAsNpc		; $7712


;;
; @addr{7715}
_monkeySubid4State1:
	ld e,Interaction.var03		; $7715
	ld a,(de)		; $7717
	rst_jumpTable			; $7718
	.dw @monkey0
	.dw @monkey0
	.dw @monkey0
	.dw @monkey3
	.dw @monkey0
	.dw @monkey3
	.dw @monkey3
	.dw @monkey3
	.dw @monkey3
	.dw @monkey9

@monkey0:
	ld e,Interaction.state2		; $772d
	ld a,(de)		; $772f
	rst_jumpTable			; $7730
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4_0

@substate0:
	call interactionDecCounter2		; $773b
	ret nz			; $773e
	jp interactionIncState2		; $773f

@substate1:
	call interactionDecCounter1		; $7742
	ret nz			; $7745
	ld (hl),$3c		; $7746
	ld l,Interaction.var03		; $7748
	ld a,(hl)		; $774a
	cp $08			; $774b
	jr nz,++		; $774d
	ld a,Object.enabled		; $774f
	call objectGetRelatedObject2Var		; $7751
	ld l,Interaction.oamFlags		; $7754
	ld (hl),$06		; $7756
++
	ld a,SND_GALE_SEED		; $7758
	call playSound		; $775a
	jp interactionIncState2		; $775d

@substate2:
	call interactionDecCounter1		; $7760
	jr nz,++		; $7763
	ld (hl),$3c		; $7765
	call objectSetVisible		; $7767
	jp interactionIncState2		; $776a
++
	ld b,$01		; $776d
	jp objectFlickerVisibility		; $776f

@substate3:
	call interactionDecCounter1		; $7772
	ret nz			; $7775
	ld b,$03		; $7776
	ld l,Interaction.var03		; $7778
	ld a,(hl)		; $777a
	cp $05			; $777b
	jr nz,+			; $777d
	dec b			; $777f
	jr ++			; $7780
+
	cp $08			; $7782
	jr nz,++		; $7784
	ld a,Object.enabled		; $7786
	call objectGetRelatedObject2Var		; $7788
	ld l,Interaction.oamFlags		; $778b
	ld (hl),$02		; $778d
	ld h,d			; $778f
	ld l,Interaction.counter1		; $7790
	ld (hl),$b4		; $7792
++
	ld l,Interaction.oamFlags		; $7794
	ld (hl),b		; $7796
	jp interactionIncState2		; $7797

@substate4_0:
	call _monkeyUpdateGravityAndJumpIfLanded		; $779a

@substate4_1:
	call interactionAnimate		; $779d
	ld e,Interaction.var03		; $77a0
	ld a,(de)		; $77a2
	cp $08			; $77a3
	ret nz			; $77a5
	call interactionDecCounter1		; $77a6
	ret nz			; $77a9
	ld a,$ff		; $77aa
	ld ($cfdf),a		; $77ac
	ret			; $77af

@monkey3:
	ld e,Interaction.state2		; $77b0
	ld a,(de)		; $77b2
	rst_jumpTable			; $77b3
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4_1

@monkey9:
	ld e,Interaction.state2		; $77be
	ld a,(de)		; $77c0
	cp $04			; $77c1
	call nc,_monkeyCheckChangeAnimation		; $77c3
	ld e,Interaction.state2		; $77c6
	ld a,(de)		; $77c8
	rst_jumpTable			; $77c9
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw _monkey9Disappearance@substate0
	.dw _monkey9Disappearance@substate1
	.dw _monkey9Disappearance@substate2
	.dw _monkey9Disappearance@substate3


;;
; @addr{77da}
_monkeySubid5State1:
	ld e,Interaction.var03		; $77da
	ld a,(de)		; $77dc
	rst_jumpTable			; $77dd
	.dw @monkey0
	.dw @monkey0
	.dw @monkey0
	.dw _monkeyAnimateAndRunScript
	.dw @monkey0
	.dw _monkeyAnimateAndRunScript
	.dw _monkeyAnimateAndRunScript
	.dw _monkeyAnimateAndRunScript
	.dw _monkeyAnimateAndRunScript
	.dw _monkeySubid5State1_monkey9

@monkey0:
	call _monkeyUpdateGravityAndJumpIfLanded		; $77f2

_monkeyAnimateAndRunScript:
	call interactionRunScript		; $77f5
	jp interactionAnimateAsNpc		; $77f8

_monkeySubid5State1_monkey9:
	call interactionRunScript		; $77fb
	call _monkeyCheckChangeAnimation		; $77fe
	call objectPushLinkAwayOnCollision		; $7801
	call objectSetPriorityRelativeToLink_withTerrainEffects		; $7804
	ld e,Interaction.state2	; $7807
	ld a,(de)		; $7809
	rst_jumpTable			; $780a
	.dw _monkey9Disappearance@substate0
	.dw _monkey9Disappearance@substate1
	.dw _monkey9Disappearance@substate2
	.dw _monkey9Disappearance@substate3

_introMonkeyScriptTable:
	.dw monkeySubid2Script
	.dw monkeySubid3Script


; ==============================================================================
; INTERACID_RABBIT
; ==============================================================================
interactionCode4b_body:
	ld e,Interaction.state		; $7817
	ld a,(de)		; $7819
	rst_jumpTable			; $781a
	.dw @state0
	.dw @state1

@state0:
	ld a,$01		; $781f
	ld (de),a		; $7821
	call interactionInitGraphics		; $7822
	call objectSetVisiblec2		; $7825
	call @initSubid		; $7828
	ld e,Interaction.enabled		; $782b
	ld a,(de)		; $782d
	or a			; $782e
	jp nz,objectMarkSolidPosition		; $782f
	ret			; $7832

@initSubid:
	ld e,Interaction.subid		; $7833
	ld a,(de)		; $7835
	rst_jumpTable			; $7836
	.dw @initSubid0
	.dw @initSubid1
	.dw @initSubid2
	.dw @initSubid3
	.dw @initSubid4
	.dw @initSubid5
	.dw @initSubid6
	.dw @initSubid7

@initSubid0:
	ld hl,rabbitScript_listeningToNayruGameStart		; $7847
	jp interactionSetScript		; $784a

; This is also called from outside this interaction's code
@initSubid1:
	ld h,d			; $784d
	ld l,Interaction.angle		; $784e
	ld (hl),$18		; $7850
	ld l,Interaction.speed		; $7852
	ld (hl),SPEED_180		; $7854

@setJumpAnimation:
	ld a,$05		; $7856
	call interactionSetAnimation		; $7858

	ld bc,-$180		; $785b
	jp objectSetSpeedZ		; $785e

@initSubid2:
	ld e,Interaction.counter1		; $7861
	ld a,180		; $7863
	ld (de),a		; $7865
	callab interactionBank1.loadStoneNpcPalette		; $7866
	jp _rabbitSubid2SetRandomSpawnDelay		; $786e

@initSubid6:
	; Delete if veran defeated
	ld hl,wGroup4Flags+$fc		; $7871
	bit 7,(hl)		; $7874
	jp nz,interactionDelete		; $7876

	; Delete if haven't beaten Jabu
	ld a,(wEssencesObtained)		; $7879
	bit 6,a			; $787c
	jp z,interactionDelete		; $787e

	callab interactionBank1.loadStoneNpcPalette		; $7881
	ld a,$06		; $7889
	call objectSetCollideRadius		; $788b

@initSubid3:
	ld a,120		; $788e
	ld e,Interaction.counter1		; $7890
	ld (de),a		; $7892

@setStonePaletteAndAnimation:
	ld a,$06		; $7893
	ld e,Interaction.oamFlags		; $7895
	ld (de),a		; $7897
	jp interactionSetAnimation		; $7898

@initSubid5:
	call interactionLoadExtraGraphics		; $789b
	ld h,d			; $789e
	ld l,Interaction.counter1		; $789f
	ld (hl),$0e		; $78a1
	inc l			; $78a3
	ld (hl),$01		; $78a4
	jr @setStonePaletteAndAnimation		; $78a6

@initSubid4:
	call interactionLoadExtraGraphics		; $78a8
	jp _rabbitJump		; $78ab

@initSubid7:
	ld a,GLOBALFLAG_FINISHEDGAME		; $78ae
	call checkGlobalFlag		; $78b0
	jp nz,interactionDelete		; $78b3

	ld a,GLOBALFLAG_MAKU_TREE_SAVED		; $78b6
	call checkGlobalFlag		; $78b8
	jp z,interactionDelete		; $78bb

	ld a,GLOBALFLAG_SAVED_NAYRU		; $78be
	call checkGlobalFlag		; $78c0
	ld hl,rabbitScript_waitingForNayru1		; $78c3
	jp z,+			; $78c6
	ld hl,rabbitScript_waitingForNayru2		; $78c9
+
	call interactionSetScript		; $78cc

@state1:
	ld e,Interaction.subid		; $78cf
	ld a,(de)		; $78d1
	rst_jumpTable			; $78d2
	.dw _rabbitSubid0
	.dw _rabbitSubid1
	.dw _rabbitSubid2
	.dw _rabbitSubid3
	.dw _rabbitSubid4
	.dw _rabbitSubid5
	.dw interactionPushLinkAwayAndUpdateDrawPriority
	.dw _rabbitSubid7


; Listening to Nayru at the start of the game
_rabbitSubid0:
	call interactionAnimateAsNpc		; $78e3
	ld e,Interaction.state2		; $78e6
	ld a,(de)		; $78e8
	rst_jumpTable			; $78e9
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3

@substate0:
	ld a,($cfd0)		; $78f2
	cp $0e			; $78f5
	jp nz,interactionRunScript		; $78f7

	call interactionIncState2		; $78fa
	ld a,$02		; $78fd
	jp interactionSetAnimation		; $78ff

@substate1:
	ld a,($cfd0)		; $7902
	cp $10			; $7905
	jp nz,interactionRunScript		; $7907

	call interactionIncState2		; $790a
	ld l,Interaction.counter1		; $790d
	ld (hl),40		; $790f
	ret			; $7911

@substate2:
	call interactionDecCounter1		; $7912
	jp nz,interactionAnimate		; $7915

	call interactionIncState2		; $7918
	ld l,Interaction.angle		; $791b
	ld (hl),$06		; $791d
	ld l,Interaction.speed		; $791f
	ld (hl),SPEED_180		; $7921

@jump:
	ld bc,-$200		; $7923
	call objectSetSpeedZ		; $7926
	ld a,$04		; $7929
	jp interactionSetAnimation		; $792b

@substate3:
	call objectCheckWithinScreenBoundary		; $792e
	jp nc,interactionDelete		; $7931
	ld c,$20		; $7934
	call objectUpdateSpeedZ_paramC		; $7936
	jp nz,objectApplySpeed		; $7939
	jr @jump		; $793c


_rabbitSubid1:
	ld h,d			; $793e
	ld l,Interaction.counter1		; $793f
	ld a,(hl)		; $7941
	or a			; $7942
	jr z,@updateSubstate	; $7943
	dec (hl)		; $7945
	jr nz,@updateSubstate	; $7946

	inc l			; $7948
	ld a,30 ; [counter2] = 30

	ld (hl),a		; $794b
	ld l,Interaction.state2		; $794c
	ld (hl),$02		; $794e
	ld bc,$f000		; $7950
	call objectCreateExclamationMark		; $7953

@updateSubstate:
	ld e,Interaction.state2		; $7956
	ld a,(de)		; $7958
	rst_jumpTable			; $7959
	.dw @substate0
	.dw @substate1
	.dw @substate2
	.dw @substate3
	.dw @substate4
	.dw @substate5
	.dw @substate6

; This is also called by subids 1 and 3
@substate0:
	call interactionAnimate		; $7968
	ld e,Interaction.animParameter		; $796b
	ld a,(de)		; $796d
	or a			; $796e
	ret z			; $796f
	ld a,SND_JUMP		; $7970
	call playSound		; $7972
	jp interactionIncState2		; $7975

; This is also called by subids 1 and 3
@substate1:
	ld e,Interaction.xh		; $7978
	ld a,(de)		; $797a
	cp $d0			; $797b
	jp nc,interactionDelete		; $797d

	call objectApplySpeed		; $7980
	ld c,$20		; $7983
	call objectUpdateSpeedZ_paramC		; $7985
	ret nz			; $7988

	ld h,d			; $7989
	ld l,Interaction.state2		; $798a
	dec (hl)		; $798c
	jp interactionCode4b_body@setJumpAnimation		; $798d

@substate2:
	call interactionDecCounter2		; $7990
	ret nz			; $7993

	ld (hl),60		; $7994
	ld l,Interaction.xh		; $7996
	ld a,(hl)		; $7998
	ld l,Interaction.var3d		; $7999
	ld (hl),a		; $799b
	jp interactionIncState2		; $799c

@substate3:
	callab interactionBank1.interactionOscillateXRandomly		; $799f
	call interactionDecCounter2		; $79a7
	ret nz			; $79aa
	ld (hl),20		; $79ab

	; Set stone color
	ld l,Interaction.oamFlags		; $79ad
	ld (hl),$06		; $79af

	jp interactionIncState2		; $79b1

@substate4:
	call interactionDecCounter2		; $79b4
	ret nz			; $79b7

	ld bc,$0000		; $79b8
	call objectSetSpeedZ		; $79bb
	jp interactionIncState2		; $79be

@substate5:
	ld c,$20		; $79c1
	call objectUpdateSpeedZ_paramC		; $79c3
	ret nz			; $79c6

	call interactionIncState2		; $79c7
	ld l,Interaction.counter2		; $79ca
	ld (hl),240		; $79cc
	ld a,$04		; $79ce
	jp setScreenShakeCounter		; $79d0

@substate6:
	call interactionDecCounter2		; $79d3
	ret nz			; $79d6
	ld a,$ff		; $79d7
	ld ($cfdf),a		; $79d9
	ret			; $79dc


; "Controller" for the cutscene where rabbits turn to stone? (spawns subid $01)
_rabbitSubid2:
	ld h,d			; $79dd
	ld l,Interaction.counter1		; $79de
	ld a,(hl)		; $79e0
	or a			; $79e1
	jr z,+			; $79e2
	dec (hl)		; $79e4
	call z,_spawnNextRabbitThatTurnsToStone		; $79e5
+
	; After a random delay, spawn a rabbit that just runs across the screen (doesn't
	; turn to stone)
	ld h,d			; $79e8
	ld l,Interaction.var38		; $79e9
	dec (hl)		; $79eb
	ret nz			; $79ec

	call getRandomNumber_noPreserveVars		; $79ed
	and $07			; $79f0
	ld hl,_rabbitSubid2YPositions		; $79f2
	rst_addAToHl			; $79f5
	ld b,(hl)		; $79f6
	call getRandomNumber		; $79f7
	and $0f			; $79fa
	cpl			; $79fc
	inc a			; $79fd
	add $b0			; $79fe
	ld c,a			; $7a00
	call _spawnRabbitWithSubid1		; $7a01
	jp _rabbitSubid2SetRandomSpawnDelay		; $7a04


; Rabbit being restored from stone cutscene (gets restored and jumps away)
_rabbitSubid3:
	ld e,Interaction.state2		; $7a07
	ld a,(de)		; $7a09
	rst_jumpTable			; $7a0a
	.dw @substate0
	.dw @substate1
	.dw _rabbitSubid1@substate0
	.dw _rabbitSubid1@substate1

@substate0:
	call interactionDecCounter1		; $7a13
	ret nz			; $7a16
	ld (hl),$5a		; $7a17
	ld a,$01		; $7a19
	ld ($cfd1),a		; $7a1b
	ld a,SND_RESTORE		; $7a1e
	call playSound		; $7a20
	jp interactionIncState2		; $7a23

; This is also called from subid 5
@substate1:
	call interactionDecCounter1		; $7a26
	jr z,+			; $7a29
	jpab interactionBank1.childFlickerBetweenStone		; $7a2b
+
	call interactionIncState2		; $7a33
	ld l,Interaction.oamFlags		; $7a36
	ld (hl),$02		; $7a38
	ld l,Interaction.var38		; $7a3a
	ld (hl),$20		; $7a3c
	jp interactionCode4b_body@initSubid1		; $7a3e


; Rabbit being restored from stone cutscene (the one that wasn't stone)
_rabbitSubid4:
	ld e,Interaction.state2		; $7a41
	ld a,(de)		; $7a43
	rst_jumpTable			; $7a44
	.dw @substate0
	.dw @substate1
	.dw _rabbitSubid4Substate2
	.dw _rabbitSubid5@substate3
	.dw _rabbitSubid5@ret

@substate0:
	ld a,($cfd1)		; $7a4f
	cp $01			; $7a52
	jr nz,++		; $7a54

	ld h,d			; $7a56
	ld l,Interaction.state2		; $7a57
	ld (hl),$02		; $7a59
	ld hl,rabbitSubid4Script		; $7a5b
	jp interactionSetScript		; $7a5e
++
	call interactionAnimate		; $7a61
	ld e,Interaction.animParameter		; $7a64
	ld a,(de)		; $7a66
	or a			; $7a67
	ret z			; $7a68
	jp interactionIncState2		; $7a69

@substate1:
	ld c,$20		; $7a6c
	call objectUpdateSpeedZ_paramC		; $7a6e
	ret nz			; $7a71

	ld h,d			; $7a72
	ld l,Interaction.state2		; $7a73
	dec (hl)		; $7a75

;;
; @addr{7a76}
_rabbitJump:
	ld a,$07		; $7a76
	call interactionSetAnimation		; $7a78
	ld bc,-$e0		; $7a7b
	jp objectSetSpeedZ		; $7a7e


_rabbitSubid4Substate2:
	ld a,($cfd1)		; $7a81
	cp $02			; $7a84
	jp nz,interactionRunScript		; $7a86

	call interactionIncState2		; $7a89
	ld l,Interaction.angle		; $7a8c
	ld (hl),$18		; $7a8e

	ld l,Interaction.speed		; $7a90
	ld (hl),SPEED_a0		; $7a92
	ld bc,-$180		; $7a94
	call objectSetSpeedZ		; $7a97

	ld a,$09		; $7a9a
	jp interactionSetAnimation		; $7a9c

_rabbitSubid5:
	ld h,d			; $7a9f
	ld l,Interaction.var38		; $7aa0
	ld a,(hl)		; $7aa2
	or a			; $7aa3
	jr z,@updateSubstate	; $7aa4
	dec (hl)		; $7aa6
	jr nz,@updateSubstate	; $7aa7

	; Just collided with another rabbit?

	ld l,Interaction.state2		; $7aa9
	ld (hl),$04		; $7aab
	ld l,Interaction.angle		; $7aad
	ld (hl),$08		; $7aaf

	ld l,Interaction.speed		; $7ab1
	ld (hl),SPEED_a0		; $7ab3
	ld bc,-$1e0		; $7ab5
	call objectSetSpeedZ		; $7ab8

	ldbc INTERACID_CLINK,$80		; $7abb
	call objectCreateInteraction		; $7abe
	jr nz,@label_3f_367	; $7ac1

	ld a,SND_DAMAGE_ENEMY		; $7ac3
	call playSound		; $7ac5
	ld a,$02		; $7ac8
	ld ($cfd1),a		; $7aca

@label_3f_367:
	ld a,$08		; $7acd
	call interactionSetAnimation		; $7acf

@updateSubstate:
	ld e,Interaction.state2		; $7ad2
	ld a,(de)		; $7ad4
	rst_jumpTable			; $7ad5
	.dw @substate0
	.dw _rabbitSubid3@substate1
	.dw _rabbitSubid1@substate0
	.dw _rabbitSubid1@substate1
	.dw @substate3
	.dw @substate4

@substate0:
	ld h,d			; $7ae2
	ld l,Interaction.counter1		; $7ae3
	call decHlRef16WithCap		; $7ae5
	ret nz			; $7ae8

	ld (hl),$5a		; $7ae9
	call interactionIncState2		; $7aeb
	ld a,SND_RESTORE		; $7aee
	jp playSound		; $7af0

; Also called from subid 4
@substate3:
	call objectApplySpeed		; $7af3
	ld c,$20		; $7af6
	call objectUpdateSpeedZAndBounce		; $7af8
	ret nc			; $7afb

	call interactionIncState2		; $7afc
	ld l,Interaction.counter1		; $7aff
	ld (hl),$3c		; $7b01

@ret:
	ret			; $7b03

@substate4:
	call interactionDecCounter1		; $7b04
	ret nz			; $7b07

	ld a,$ff		; $7b08
	ld ($cfdf),a		; $7b0a
	ret			; $7b0d


; Generic NPC waiting around in the spot Nayru used to sing
_rabbitSubid7:
	call interactionRunScript		; $7b0e
	jp c,interactionDelete		; $7b11
	jp npcFaceLinkAndAnimate		; $7b14

;;
; This might be setting one of 4 possible speed values to var38?
; @addr{7b17}
_rabbitSubid2SetRandomSpawnDelay:
	call getRandomNumber_noPreserveVars		; $7b17
	and $03			; $7b1a
	ld bc,_rabbitSubid2SpawnDelays		; $7b1c
	call addAToBc		; $7b1f
	ld a,(bc)		; $7b22
	ld e,Interaction.var38		; $7b23
	ld (de),a		; $7b25
	ret			; $7b26

;;
; hl should point to "counter1".
; @addr{7b27}
_spawnNextRabbitThatTurnsToStone:
	; Increment counter2, the index of the rabbit to spawn (0-2)
	inc l			; $7b27
	ld a,(hl)		; $7b28
	inc (hl)		; $7b29

	ld b,a			; $7b2a
	add a			; $7b2b
	add b			; $7b2c
	ld hl,@data		; $7b2d
	rst_addAToHl			; $7b30
	ldi a,(hl)		; $7b31
	ld e,Interaction.counter1		; $7b32
	ld (de),a		; $7b34
	ld b,(hl)		; $7b35
	inc hl			; $7b36
	ld c,(hl)		; $7b37

	; Spawn a rabbit that will turn to stone after 95 frames
	call _spawnRabbitWithSubid1		; $7b38
	ld l,Interaction.counter1		; $7b3b
	ld (hl),95		; $7b3d
	ret			; $7b3f

; Data for the rabbits that turn to stone in a cutscene. Format:
;   b0: Frames until next rabbit is spawned?
;   b1: Y position
;   b2: X position
@data:
	.db $5a $28 $b8
	.db $1e $40 $a8
	.db $00 $50 $c8 

;;
; Spawns a rabbit for the cutscene where a bunch of rabbits turn to stone
;
; @param	bc	Position
; @addr{7b49}
_spawnRabbitWithSubid1;
	call getFreeInteractionSlot		; $7b49
	ret nz			; $7b4c
	ld (hl),INTERACID_RABBIT		; $7b4d
	inc l			; $7b4f
	inc (hl)		; $7b50
	jp interactionHSetPosition		; $7b51


; A byte from here is chosen randomly to spawn a rabbit at.
_rabbitSubid2YPositions:
	.db $66 $5e $58 $46 $3a $30 $20 $18

; A byte from here is chosen randomly as a delay before spawning another rabbit.
_rabbitSubid2SpawnDelays:
	.db $1e $3c $50 $78

	ld e,$44		; $7b60
	ld a,(de)		; $7b62
	rst_jumpTable			; $7b63
.dw $7b6e
.dw $7ba1
.dw $7be4
.dw $7c0b
.dw objectPreventLinkFromPassing
	call interactionInitGraphics		; $7b6e
	ld a,GLOBALFLAG_TUNI_NUT_PLACED		; $7b71
	call checkGlobalFlag		; $7b73
	jr nz,_label_3f_371	; $7b76
	ld a,TREASURE_TUNI_NUT		; $7b78
	call checkTreasureObtained		; $7b7a
	jr nc,_label_3f_370	; $7b7d
	cp $02			; $7b7f
	jr nz,_label_3f_370	; $7b81
	ld bc,$0810		; $7b83
	call objectSetCollideRadii		; $7b86
	jp interactionIncState		; $7b89
_label_3f_370:
	jp interactionDelete		; $7b8c
_label_3f_371:
	ld bc,$1878		; $7b8f
	call interactionSetPosition		; $7b92
	ld l,$44		; $7b95
	ld (hl),$04		; $7b97
	ld a,$06		; $7b99
	call objectSetCollideRadius		; $7b9b
	jp objectSetVisible82		; $7b9e
	call objectCheckCollidedWithLink_notDeadAndNotGrabbing		; $7ba1
	ret nc			; $7ba4
	call checkLinkCollisionsEnabled		; $7ba5
	ret nc			; $7ba8
	push de			; $7ba9
	call clearAllItemsAndPutLinkOnGround		; $7baa
	pop de			; $7bad
	ld a,$01		; $7bae
	ld (wDisabledObjects),a		; $7bb0
	ld (wMenuDisabled),a		; $7bb3
	ld a,(w1Link.xh)		; $7bb6
	sub $78			; $7bb9
	jr z,_label_3f_374	; $7bbb
	jr c,_label_3f_372	; $7bbd
	ld b,$03		; $7bbf
	jr _label_3f_373		; $7bc1
_label_3f_372:
	cpl			; $7bc3
	inc a			; $7bc4
	ld b,$01		; $7bc5
_label_3f_373:
	ld (wLinkStateParameter),a		; $7bc7
	ld e,$46		; $7bca
	ld (de),a		; $7bcc
	ld a,b			; $7bcd
	ld (w1Link.direction),a		; $7bce
	swap a			; $7bd1
	rrca			; $7bd3
	ld ($d009),a		; $7bd4
	ld a,LINK_STATE_FORCE_MOVEMENT		; $7bd7
	ld (wLinkForceState),a		; $7bd9
	jp interactionIncState		; $7bdc
_label_3f_374:
	call interactionIncState		; $7bdf
	jr _label_3f_375		; $7be2
	call interactionDecCounter1		; $7be4
	ret nz			; $7be7
_label_3f_375:
	xor a			; $7be8
	ld (w1Link.direction),a		; $7be9
	ld e,$46		; $7bec
	ld a,$3c		; $7bee
	ld (de),a		; $7bf0
	ld bc,$8407		; $7bf1
	call objectCreateInteraction		; $7bf4
	ld l,$56		; $7bf7
	ld a,e			; $7bf9
	ldi (hl),a		; $7bfa
	ld a,d			; $7bfb
	ld (hl),a		; $7bfc
	call darkenRoomLightly		; $7bfd
	ld a,SNDCTRL_STOPMUSIC		; $7c00
	call playSound		; $7c02
	call objectSetVisiblec0		; $7c05
	jp interactionIncState		; $7c08
	ld e,$45		; $7c0b
	ld a,(de)		; $7c0d
	rst_jumpTable			; $7c0e
.dw $7c1b
.dw $7c24
.dw $7c37
.dw $7c4c
.dw $7c64
.dw $7c6e
	call interactionDecCounter1		; $7c1b
	ret nz			; $7c1e
	ld (hl),$10		; $7c1f
	jp interactionIncState2		; $7c21
	ld a,(wFrameCounter)		; $7c24
	rrca			; $7c27
	ret c			; $7c28
	ld h,d			; $7c29
	ld l,$4f		; $7c2a
	dec (hl)		; $7c2c
	call interactionDecCounter1		; $7c2d
	ret nz			; $7c30
	call objectCenterOnTile		; $7c31
	jp interactionIncState2		; $7c34
	ld b,$0a		; $7c37
	ld c,$00		; $7c39
	ld e,$49		; $7c3b
	call objectApplyGivenSpeed		; $7c3d
	ld e,$4b		; $7c40
	ld a,(de)		; $7c42
	cp $18			; $7c43
	ret nc			; $7c45
	call objectCenterOnTile		; $7c46
	jp interactionIncState2		; $7c49
	ld c,$20		; $7c4c
	call objectUpdateSpeedZ_paramC		; $7c4e
	ret nz			; $7c51
	ld a,SND_DROPESSENCE		; $7c52
	call playSound		; $7c54
	ld e,$46		; $7c57
	ld a,$5a		; $7c59
	ld (de),a		; $7c5b
	ld a,SND_SOLVEPUZZLE_2		; $7c5c
	call playSound		; $7c5e
	jp interactionIncState2		; $7c61
	call interactionDecCounter1		; $7c64
	ret nz			; $7c67
	call brightenRoom		; $7c68
	jp interactionIncState2		; $7c6b
	ld a,(wPaletteThread_mode)		; $7c6e
	or a			; $7c71
	ret nz			; $7c72
	ld a,GLOBALFLAG_TUNI_NUT_PLACED		; $7c73
	call setGlobalFlag		; $7c75
	ld a,$4c		; $7c78
	call loseTreasure		; $7c7a
	call $7c95		; $7c7d
	xor a			; $7c80
	ld (wDisabledObjects),a		; $7c81
	ld (wMenuDisabled),a		; $7c84
	ld hl,$cfc0		; $7c87
	set 0,(hl)		; $7c8a
	ld a,(wActiveMusic)		; $7c8c
	call playSound		; $7c8f
	jp $7b8f		; $7c92
	ld hl,$c702		; $7c95
	call $7c9d		; $7c98
	ld l,$12		; $7c9b
	set 0,(hl)		; $7c9d
	inc l			; $7c9f
	set 0,(hl)		; $7ca0
	inc l			; $7ca2
	set 0,(hl)		; $7ca3
	inc l			; $7ca5
	ret			; $7ca6

.ifdef BUILD_VANILLA

; Garbage functions appear to follow (corrupted repeats of the above functions).

;;
; @addr{7ca7}
func_7ca7:
	jr -$30			; $7ca7
	call $2118		; $7ca9
	jp $2422		; $7cac

;;
; @addr{7caf}
func_7caf:
	ld c,$20		; $7caf
	call $1f83		; $7cb1
	ret nz			; $7cb4

	ld a,$77		; $7cb5
	call $0cb1		; $7cb7
	ld e,$46		; $7cba
	ld a,$5a		; $7cbc
	ld (de),a		; $7cbe
	ld a,$5b		; $7cbf
	call $0cb1		; $7cc1
	jp $2422		; $7cc4

;;
; @addr{7cc7}
func_7cc7:
	call $2409		; $7cc7
	ret nz			; $7cca
	call $33a2		; $7ccb
	jp $2422		; $7cce

;;
; @addr{7cd1}
func_7cd1:
	ld a,(wPaletteThread_mode)		; $7cd1
	or a			; $7cd4
	ret nz			; $7cd5
	ld a,$29		; $7cd6
	call $324b		; $7cd8
	ld a,$4c		; $7cdb
	call $1761		; $7cdd
	call $7cf8		; $7ce0
	xor a			; $7ce3
	ld (wDisabledObjects),a		; $7ce4
	ld (wMenuDisabled),a		; $7ce7
	ld hl,$cfc0		; $7cea
	set 0,(hl)		; $7ced
	ld a,(wActiveMusic)		; $7cef
	call $0cb1		; $7cf2
	jp $7bf2		; $7cf5

;;
; @addr{7cf8}
func_7cf8:
	ld hl,$c702		; $7cf8
	call $7d00		; $7cfb
	ld l,$12		; $7cfe
	set 0,(hl)		; $7d00
	inc l			; $7d02
	set 0,(hl)		; $7d03
	inc l			; $7d05
	set 0,(hl)		; $7d06
	inc l			; $7d08
	ret			; $7d09

.endif

.ends
